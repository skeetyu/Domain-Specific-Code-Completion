{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource", "gt": "source = new UrlBasedCorsConfigurationSource ( ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source", "gt": ". registerCorsConfiguration ( \"<STR_LIT>\" , config ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties", "gt": ". ElPath path = properties . getPath ( ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties . ElPath path = properties . getPath ( ) ; String avatarUtl = \"<STR_LIT>\" + path . getAvatar ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String", "gt": "pathUtl = \"<STR_LIT>\" + path . getPath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties . ElPath path = properties . getPath ( ) ; String avatarUtl = \"<STR_LIT>\" + path . getAvatar ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String pathUtl = \"<STR_LIT>\" + path . getPath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( avatarUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( pathUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry", "gt": ". addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) . setCachePeriod ( <NUM_LIT> ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties . ElPath path = properties . getPath ( ) ; String avatarUtl = \"<STR_LIT>\" + path . getAvatar ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String pathUtl = \"<STR_LIT>\" + path . getPath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( avatarUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( pathUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) . setCachePeriod ( <NUM_LIT> ) ; } @ Override public void configureMessageConverters ( List < HttpMessageConverter < ? > > converters ) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter ( ) ; List", "gt": "< MediaType > supportMediaTypeList = new ArrayList < > ( ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties . ElPath path = properties . getPath ( ) ; String avatarUtl = \"<STR_LIT>\" + path . getAvatar ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String pathUtl = \"<STR_LIT>\" + path . getPath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( avatarUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( pathUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) . setCachePeriod ( <NUM_LIT> ) ; } @ Override public void configureMessageConverters ( List < HttpMessageConverter < ? > > converters ) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter ( ) ; List < MediaType > supportMediaTypeList = new ArrayList < > ( ) ; supportMediaTypeList . add ( MediaType . APPLICATION_JSON ) ; FastJsonConfig", "gt": "config = new FastJsonConfig ( ) ;"}
{"input": "package me . zhengjie . config ; import com . alibaba . fastjson . serializer . SerializerFeature ; import com . alibaba . fastjson . support . config . FastJsonConfig ; import com . alibaba . fastjson . support . spring . FastJsonHttpMessageConverter ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableWebMvc public class ConfigurerAdapter implements WebMvcConfigurer { private final FileProperties properties ; public ConfigurerAdapter ( FileProperties properties ) { this . properties = properties ; } @ Bean public CorsFilter corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { FileProperties . ElPath path = properties . getPath ( ) ; String avatarUtl = \"<STR_LIT>\" + path . getAvatar ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String pathUtl = \"<STR_LIT>\" + path . getPath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( avatarUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( pathUtl ) . setCachePeriod ( <NUM_LIT> ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) . setCachePeriod ( <NUM_LIT> ) ; } @ Override public void configureMessageConverters ( List < HttpMessageConverter < ? > > converters ) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter ( ) ; List < MediaType > supportMediaTypeList = new ArrayList < > ( ) ; supportMediaTypeList . add ( MediaType . APPLICATION_JSON ) ; FastJsonConfig config = new FastJsonConfig ( ) ; config . setDateFormat ( \"<STR_LIT>\" ) ; config . setSerializerFeatures ( SerializerFeature . DisableCircularReferenceDetect ) ; converter . setFastJsonConfig ( config ) ; converter . setSupportedMediaTypes ( supportMediaTypeList ) ; converter", "gt": ". setDefaultCharset ( StandardCharsets . UTF_8 ) ;"}
{"input": "package me . zhengjie . config . mybatis ; import com . baomidou . mybatisplus . annotation . DbType ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class MybatisPlusConfig { @ Bean public MybatisPlusInterceptor paginationInterceptor ( ) { MybatisPlusInterceptor", "gt": "interceptor = new MybatisPlusInterceptor ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } )", "gt": "public class StringUtils extends org . apache . commons . lang3 . StringUtils {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s", "gt": "= s . toLowerCase ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder", "gt": "sb = new StringBuilder ( s . length ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return", "gt": "s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static", "gt": "String toUnderScoreCase ( String s ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i", "gt": "< s . length ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if", "gt": "( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if", "gt": "( ! upperCase || ! nextUpperCase ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb", "gt": ". append ( Character . toLowerCase ( c ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String", "gt": "ip = request . getHeader ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if", "gt": "( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if", "gt": "( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if", "gt": "( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if", "gt": "( ip . contains ( comma ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip", "gt": "= ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo", "gt": "ipInfo = IP_SEARCHER . memorySearch ( ip ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String", "gt": "browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return", "gt": "browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int", "gt": "w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for", "gt": "( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; interfaces . hasMoreElements ( ) ; ) { NetworkInterface anInterface = interfaces . nextElement ( ) ; for", "gt": "( Enumeration < InetAddress > inetAddresses = anInterface . getInetAddresses ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; interfaces . hasMoreElements ( ) ; ) { NetworkInterface anInterface = interfaces . nextElement ( ) ; for ( Enumeration < InetAddress > inetAddresses = anInterface . getInetAddresses ( ) ; inetAddresses . hasMoreElements ( ) ; ) { InetAddress", "gt": "inetAddr = inetAddresses . nextElement ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; interfaces . hasMoreElements ( ) ; ) { NetworkInterface anInterface = interfaces . nextElement ( ) ; for ( Enumeration < InetAddress > inetAddresses = anInterface . getInetAddresses ( ) ; inetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddr = inetAddresses . nextElement ( ) ; if", "gt": "( ! inetAddr . isLoopbackAddress ( ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; interfaces . hasMoreElements ( ) ; ) { NetworkInterface anInterface = interfaces . nextElement ( ) ; for ( Enumeration < InetAddress > inetAddresses = anInterface . getInetAddresses ( ) ; inetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddr = inetAddresses . nextElement ( ) ; if ( ! inetAddr . isLoopbackAddress ( ) ) { if ( inetAddr . isSiteLocalAddress ( ) ) { return inetAddr . getHostAddress ( ) ; } else", "gt": "if ( candidateAddress == null ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import lombok . extern . slf4j . Slf4j ; import net . dreamlu . mica . ip2region . core . Ip2regionSearcher ; import net . dreamlu . mica . ip2region . core . IpInfo ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . UnknownHostException ; import java . util . * ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final char SEPARATOR = '<STR_LIT>' ; private static final String UNKNOWN = \"<STR_LIT>\" ; private final static Ip2regionSearcher IP_SEARCHER = SpringContextHolder . getBean ( Ip2regionSearcher . class ) ; public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static String toCapitalizeCamelCase ( String s ) { if ( s == null ) { return null ; } s = toCamelCase ( s ) ; return s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } static String toUnderScoreCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; boolean nextUpperCase = true ; if ( i < ( s . length ( ) - <NUM_LIT> ) ) { nextUpperCase = Character . isUpperCase ( s . charAt ( i + <NUM_LIT> ) ) ; } if ( ( i > <NUM_LIT> ) && Character . isUpperCase ( c ) ) { if ( ! upperCase || ! nextUpperCase ) { sb . append ( SEPARATOR ) ; } upperCase = true ; } else { upperCase = false ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static String getIp ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || UNKNOWN . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } String comma = \"<STR_LIT>\" ; String localhost = \"<STR_LIT>\" ; if ( ip . contains ( comma ) ) { ip = ip . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } if ( localhost . equals ( ip ) ) { try { ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( e . getMessage ( ) , e ) ; } } return ip ; } public static String getCityInfo ( String ip ) { IpInfo ipInfo = IP_SEARCHER . memorySearch ( ip ) ; if ( ipInfo != null ) { return ipInfo . getAddress ( ) ; } return null ; } public static String getBrowser ( HttpServletRequest request ) { UserAgent ua = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; String browser = ua . getBrowser ( ) . toString ( ) + \"<STR_LIT>\" + ua . getVersion ( ) ; return browser . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getWeekDay ( ) { String [ ] weekDays = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( ) ) ; int w = cal . get ( Calendar . DAY_OF_WEEK ) - <NUM_LIT> ; if ( w < <NUM_LIT> ) { w = <NUM_LIT> ; } return weekDays [ w ] ; } public static String getLocalIp ( ) { try { InetAddress candidateAddress = null ; for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; interfaces . hasMoreElements ( ) ; ) { NetworkInterface anInterface = interfaces . nextElement ( ) ; for ( Enumeration < InetAddress > inetAddresses = anInterface . getInetAddresses ( ) ; inetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddr = inetAddresses . nextElement ( ) ; if ( ! inetAddr . isLoopbackAddress ( ) ) { if ( inetAddr . isSiteLocalAddress ( ) ) { return inetAddr . getHostAddress ( ) ; } else if ( candidateAddress == null ) { candidateAddress = inetAddr ; } } } } if ( candidateAddress != null ) { return candidateAddress . getHostAddress ( ) ; } InetAddress jdkSuppliedAddress = InetAddress . getLocalHost ( ) ; if ( jdkSuppliedAddress == null ) { return \"<STR_LIT>\" ; } return jdkSuppliedAddress . getHostAddress ( ) ; } catch ( Exception e ) { return \"<STR_LIT>\" ; } } public static List < Field > getAllFields ( Class clazz , List < Field > fields ) { if ( clazz != null ) { fields . addAll ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; getAllFields", "gt": "( clazz . getSuperclass ( ) , fields ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return", "gt": "new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . description ( \"<STR_LIT>\" ) . title ( \"<STR_LIT>\" ) . version ( \"<STR_LIT>\" ) . build ( ) ; } private List < SecurityScheme > securitySchemes ( ) { List < SecurityScheme > securitySchemes = new ArrayList < > ( ) ; ApiKey", "gt": "apiKey = new ApiKey ( tokenHeader , tokenHeader , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . description ( \"<STR_LIT>\" ) . title ( \"<STR_LIT>\" ) . version ( \"<STR_LIT>\" ) . build ( ) ; } private List < SecurityScheme > securitySchemes ( ) { List < SecurityScheme > securitySchemes = new ArrayList < > ( ) ; ApiKey apiKey = new ApiKey ( tokenHeader , tokenHeader , \"<STR_LIT>\" ) ; securitySchemes . add ( apiKey ) ; return securitySchemes ; } private List < SecurityContext > securityContexts ( ) { List", "gt": "< SecurityContext > securityContexts = new ArrayList < > ( ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . description ( \"<STR_LIT>\" ) . title ( \"<STR_LIT>\" ) . version ( \"<STR_LIT>\" ) . build ( ) ; } private List < SecurityScheme > securitySchemes ( ) { List < SecurityScheme > securitySchemes = new ArrayList < > ( ) ; ApiKey apiKey = new ApiKey ( tokenHeader , tokenHeader , \"<STR_LIT>\" ) ; securitySchemes . add ( apiKey ) ; return securitySchemes ; } private List < SecurityContext > securityContexts ( ) { List < SecurityContext > securityContexts = new ArrayList < > ( ) ; securityContexts", "gt": ". add ( getContextByPath ( ) ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . description ( \"<STR_LIT>\" ) . title ( \"<STR_LIT>\" ) . version ( \"<STR_LIT>\" ) . build ( ) ; } private List < SecurityScheme > securitySchemes ( ) { List < SecurityScheme > securitySchemes = new ArrayList < > ( ) ; ApiKey apiKey = new ApiKey ( tokenHeader , tokenHeader , \"<STR_LIT>\" ) ; securitySchemes . add ( apiKey ) ; return securitySchemes ; } private List < SecurityContext > securityContexts ( ) { List < SecurityContext > securityContexts = new ArrayList < > ( ) ; securityContexts . add ( getContextByPath ( ) ) ; return securityContexts ; } private SecurityContext getContextByPath ( ) { return", "gt": "SecurityContext . builder ( ) . securityReferences ( defaultAuth ( ) ) . operationSelector ( o -> o . requestMappingPattern ( ) . matches ( \"<STR_LIT>\" ) ) . build ( ) ;"}
{"input": "package me . zhengjie . config ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . AuthorizationScope ; import springfox . documentation . service . SecurityReference ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spi . service . contexts . SecurityContext ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . ArrayList ; import java . util . List ; @ Configuration @ EnableSwagger2 public class SwaggerConfig { @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Value ( \"<STR_LIT>\" ) private Boolean enabled ; @ Bean @ SuppressWarnings ( \"<STR_LIT>\" ) public Docket createRestApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . enable ( enabled ) . pathMapping ( \"<STR_LIT>\" ) . apiInfo ( apiInfo ( ) ) . select ( ) . paths ( PathSelectors . regex ( \"<STR_LIT>\" ) ) . paths ( PathSelectors . any ( ) ) . build ( ) . securitySchemes ( securitySchemes ( ) ) . securityContexts ( securityContexts ( ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . description ( \"<STR_LIT>\" ) . title ( \"<STR_LIT>\" ) . version ( \"<STR_LIT>\" ) . build ( ) ; } private List < SecurityScheme > securitySchemes ( ) { List < SecurityScheme > securitySchemes = new ArrayList < > ( ) ; ApiKey apiKey = new ApiKey ( tokenHeader , tokenHeader , \"<STR_LIT>\" ) ; securitySchemes . add ( apiKey ) ; return securitySchemes ; } private List < SecurityContext > securityContexts ( ) { List < SecurityContext > securityContexts = new ArrayList < > ( ) ; securityContexts . add ( getContextByPath ( ) ) ; return securityContexts ; } private SecurityContext getContextByPath ( ) { return SecurityContext . builder ( ) . securityReferences ( defaultAuth ( ) ) . operationSelector ( o -> o . requestMappingPattern ( ) . matches ( \"<STR_LIT>\" ) ) . build ( ) ; } private List < SecurityReference > defaultAuth ( ) { List < SecurityReference > securityReferences = new ArrayList < > ( ) ; AuthorizationScope authorizationScope = new AuthorizationScope ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AuthorizationScope", "gt": "[ ] authorizationScopes = new AuthorizationScope [ <NUM_LIT> ] ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public enum DataTypeEnum { MYSQL", "gt": "( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ORACLE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQLSERVER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , H2 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PHOENIX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONGODB ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ELASTICSEARCH ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PRESTO ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOONBOX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CASSANDRA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CLICKHOUSE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , KYLIN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERTICA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , HANA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IMPALA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public enum DataTypeEnum { MYSQL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ORACLE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQLSERVER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , H2 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PHOENIX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONGODB ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ELASTICSEARCH ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PRESTO ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOONBOX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CASSANDRA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CLICKHOUSE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , KYLIN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERTICA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , HANA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IMPALA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String feature ; private String desc ; private String driver ; private String keywordPrefix ; private String keywordSuffix ; private String aliasPrefix ; private String aliasSuffix ; private static final String JDBC_URL_PREFIX = \"<STR_LIT>\" ; DataTypeEnum", "gt": "( String feature , String desc , String driver , String keywordPrefix , String keywordSuffix , String aliasPrefix , String aliasSuffix ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public enum DataTypeEnum { MYSQL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ORACLE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQLSERVER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , H2 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PHOENIX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONGODB ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ELASTICSEARCH ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PRESTO ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOONBOX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CASSANDRA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CLICKHOUSE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , KYLIN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERTICA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , HANA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IMPALA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String feature ; private String desc ; private String driver ; private String keywordPrefix ; private String keywordSuffix ; private String aliasPrefix ; private String aliasSuffix ; private static final String JDBC_URL_PREFIX = \"<STR_LIT>\" ; DataTypeEnum ( String feature , String desc , String driver , String keywordPrefix , String keywordSuffix , String aliasPrefix , String aliasSuffix ) { this . feature = feature ; this . desc = desc ; this . driver = driver ; this . keywordPrefix = keywordPrefix ; this . keywordSuffix = keywordSuffix ; this . aliasPrefix = aliasPrefix ; this . aliasSuffix = aliasSuffix ; } public static DataTypeEnum urlOf ( String jdbcUrl ) { String", "gt": "url = jdbcUrl . toLowerCase ( ) . trim ( ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public enum DataTypeEnum { MYSQL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ORACLE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQLSERVER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , H2 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PHOENIX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONGODB ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ELASTICSEARCH ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PRESTO ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOONBOX ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CASSANDRA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CLICKHOUSE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , KYLIN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERTICA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , HANA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IMPALA ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String feature ; private String desc ; private String driver ; private String keywordPrefix ; private String keywordSuffix ; private String aliasPrefix ; private String aliasSuffix ; private static final String JDBC_URL_PREFIX = \"<STR_LIT>\" ; DataTypeEnum ( String feature , String desc , String driver , String keywordPrefix , String keywordSuffix , String aliasPrefix , String aliasSuffix ) { this . feature = feature ; this . desc = desc ; this . driver = driver ; this . keywordPrefix = keywordPrefix ; this . keywordSuffix = keywordSuffix ; this . aliasPrefix = aliasPrefix ; this . aliasSuffix = aliasSuffix ; } public static DataTypeEnum urlOf ( String jdbcUrl ) { String url = jdbcUrl . toLowerCase ( ) . trim ( ) ; for ( DataTypeEnum dataTypeEnum : values ( ) ) { if ( url . startsWith ( JDBC_URL_PREFIX + dataTypeEnum . feature ) ) { try { Class < ? > aClass = Class . forName ( dataTypeEnum . getDriver ( ) ) ; if ( null == aClass ) { throw", "gt": "new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int", "gt": "dot = filename . lastIndexOf ( '<STR_LIT>' ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else", "gt": "if ( size / MB >= <NUM_LIT> ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize", "gt": "= DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else", "gt": "if ( size / KB >= <NUM_LIT> ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File", "gt": "file = new File ( SYS_TEM_DIR + name ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os", "gt": "= new FileOutputStream ( file ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while", "gt": "( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os", "gt": ". write ( buffer , <NUM_LIT> , bytesRead ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat", "gt": "format = new SimpleDateFormat ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String", "gt": "name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String", "gt": "suffix = getExtensionName ( file . getOriginalFilename ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String", "gt": "fileName = name + nowStr + \"<STR_LIT>\" + suffix ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if", "gt": "( ! dest . getParentFile ( ) . exists ( ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if", "gt": "( ! dest . getParentFile ( ) . mkdirs ( ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter", "gt": "writer = ExcelUtil . getBigWriter ( file ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet", "gt": "sheet = ( SXSSFSheet ) writer . getSheet ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response", "gt": ". setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer", "gt": ". flush ( out , true ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if", "gt": "( image . contains ( type ) ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw", "gt": "new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String", "gt": "img1Md5 = getMd5 ( file1 ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String", "gt": "img2Md5 = getMd5 ( file2 ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return", "gt": "file1Md5 . equals ( file2Md5 ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte", "gt": "[ ] b = new byte [ ( int ) file . length ( ) ] ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in", "gt": "= new FileInputStream ( file ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System", "gt": ". out . println ( in . read ( b ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest", "gt": "mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte", "gt": "[ ] md = mdTemp . digest ( ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char", "gt": "[ ] str = new char [ j * <NUM_LIT> ] ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for", "gt": "( byte byte0 : md ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str", "gt": "[ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response", "gt": ". setCharacterEncoding ( request . getCharacterEncoding ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis", "gt": "= new FileInputStream ( file ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils", "gt": ". copy ( fis , response . getOutputStream ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } public static String verifyFilename ( String fileName ) { fileName", "gt": "= fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } public static String verifyFilename ( String fileName ) { fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName", "gt": "= fileName . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } public static String verifyFilename ( String fileName ) { fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName = fileName . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int maxFileNameLength = <NUM_LIT> ; if ( System . getProperty ( \"<STR_LIT>\" ) . startsWith ( \"<STR_LIT>\" ) ) { maxFileNameLength = <NUM_LIT> ; } if", "gt": "( fileName . length ( ) > maxFileNameLength ) {"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } public static String verifyFilename ( String fileName ) { fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName = fileName . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int maxFileNameLength = <NUM_LIT> ; if ( System . getProperty ( \"<STR_LIT>\" ) . startsWith ( \"<STR_LIT>\" ) ) { maxFileNameLength = <NUM_LIT> ; } if ( fileName . length ( ) > maxFileNameLength ) { fileName = fileName . substring ( <NUM_LIT> , maxFileNameLength ) ; } fileName", "gt": "= fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import cn . hutool . poi . excel . ExcelUtil ; import me . zhengjie . exception . BadRequestException ; import org . apache . poi . util . IOUtils ; import org . apache . poi . xssf . streaming . SXSSFSheet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; import java . security . MessageDigest ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; public class FileUtil extends cn . hutool . core . io . FileUtil { private static final Logger log = LoggerFactory . getLogger ( FileUtil . class ) ; public static final String SYS_TEM_DIR = System . getProperty ( \"<STR_LIT>\" ) + File . separator ; private static final int GB = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final int MB = <NUM_LIT> * <NUM_LIT> ; private static final int KB = <NUM_LIT> ; private static final DecimalFormat DF = new DecimalFormat ( \"<STR_LIT>\" ) ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String TXT = \"<STR_LIT>\" ; public static final String MUSIC = \"<STR_LIT>\" ; public static final String VIDEO = \"<STR_LIT>\" ; public static final String OTHER = \"<STR_LIT>\" ; public static File toFile ( MultipartFile multipartFile ) { String fileName = multipartFile . getOriginalFilename ( ) ; String prefix = \"<STR_LIT>\" + getExtensionName ( fileName ) ; File file = null ; try { file = new File ( SYS_TEM_DIR + IdUtil . simpleUUID ( ) + prefix ) ; multipartFile . transferTo ( file ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } return file ; } public static String getExtensionName ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) - <NUM_LIT> ) ) ) { return filename . substring ( dot + <NUM_LIT> ) ; } } return filename ; } public static String getFileNameNoEx ( String filename ) { if ( ( filename != null ) && ( filename . length ( ) > <NUM_LIT> ) ) { int dot = filename . lastIndexOf ( '<STR_LIT>' ) ; if ( ( dot > - <NUM_LIT> ) && ( dot < ( filename . length ( ) ) ) ) { return filename . substring ( <NUM_LIT> , dot ) ; } } return filename ; } public static String getSize ( long size ) { String resultSize ; if ( size / GB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) GB ) + \"<STR_LIT>\" ; } else if ( size / MB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) MB ) + \"<STR_LIT>\" ; } else if ( size / KB >= <NUM_LIT> ) { resultSize = DF . format ( size / ( float ) KB ) + \"<STR_LIT>\" ; } else { resultSize = size + \"<STR_LIT>\" ; } return resultSize ; } static File inputStreamToFile ( InputStream ins , String name ) { File file = new File ( SYS_TEM_DIR + name ) ; if ( file . exists ( ) ) { return file ; } OutputStream os = null ; try { os = new FileOutputStream ( file ) ; int bytesRead ; int len = <NUM_LIT> ; byte [ ] buffer = new byte [ len ] ; while ( ( bytesRead = ins . read ( buffer , <NUM_LIT> , len ) ) != - <NUM_LIT> ) { os . write ( buffer , <NUM_LIT> , bytesRead ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( ins ) ; } return file ; } public static File upload ( MultipartFile file , String filePath ) { Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String name = getFileNameNoEx ( verifyFilename ( file . getOriginalFilename ( ) ) ) ; String suffix = getExtensionName ( file . getOriginalFilename ( ) ) ; String nowStr = \"<STR_LIT>\" + format . format ( date ) ; try { String fileName = name + nowStr + \"<STR_LIT>\" + suffix ; String path = filePath + fileName ; File dest = new File ( path ) . getCanonicalFile ( ) ; if ( ! dest . getParentFile ( ) . exists ( ) ) { if ( ! dest . getParentFile ( ) . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } file . transferTo ( dest ) ; return dest ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadExcel ( List < Map < String , Object > > list , HttpServletResponse response ) throws IOException { String tempPath = SYS_TEM_DIR + IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ; File file = new File ( tempPath ) ; BigExcelWriter writer = ExcelUtil . getBigWriter ( file ) ; writer . write ( list , true ) ; SXSSFSheet sheet = ( SXSSFSheet ) writer . getSheet ( ) ; sheet . trackAllColumnsForAutoSizing ( ) ; writer . autoSizeColumnAll ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServletOutputStream out = response . getOutputStream ( ) ; file . deleteOnExit ( ) ; writer . flush ( out , true ) ; IoUtil . close ( out ) ; } public static String getFileType ( String type ) { String documents = \"<STR_LIT>\" ; String music = \"<STR_LIT>\" ; String video = \"<STR_LIT>\" ; String image = \"<STR_LIT>\" ; if ( image . contains ( type ) ) { return IMAGE ; } else if ( documents . contains ( type ) ) { return TXT ; } else if ( music . contains ( type ) ) { return MUSIC ; } else if ( video . contains ( type ) ) { return VIDEO ; } else { return OTHER ; } } public static void checkSize ( long maxSize , long size ) { int len = <NUM_LIT> * <NUM_LIT> ; if ( size > ( maxSize * len ) ) { throw new BadRequestException ( \"<STR_LIT>\" + maxSize + \"<STR_LIT>\" ) ; } } public static boolean check ( File file1 , File file2 ) { String img1Md5 = getMd5 ( file1 ) ; String img2Md5 = getMd5 ( file2 ) ; if ( img1Md5 != null ) { return img1Md5 . equals ( img2Md5 ) ; } return false ; } public static boolean check ( String file1Md5 , String file2Md5 ) { return file1Md5 . equals ( file2Md5 ) ; } private static byte [ ] getByte ( File file ) { byte [ ] b = new byte [ ( int ) file . length ( ) ] ; InputStream in = null ; try { in = new FileInputStream ( file ) ; try { System . out . println ( in . read ( b ) ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } finally { CloseUtil . close ( in ) ; } return b ; } private static String getMd5 ( byte [ ] bytes ) { char [ ] hexDigits = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; try { MessageDigest mdTemp = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; mdTemp . update ( bytes ) ; byte [ ] md = mdTemp . digest ( ) ; int j = md . length ; char [ ] str = new char [ j * <NUM_LIT> ] ; int k = <NUM_LIT> ; for ( byte byte0 : md ) { str [ k ++ ] = hexDigits [ byte0 > > > <NUM_LIT> & <NUM_LIT> ] ; str [ k ++ ] = hexDigits [ byte0 & <NUM_LIT> ] ; } return new String ( str ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } public static void downloadFile ( HttpServletRequest request , HttpServletResponse response , File file , boolean deleteOnExit ) { response . setCharacterEncoding ( request . getCharacterEncoding ( ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + file . getName ( ) ) ; IOUtils . copy ( fis , response . getOutputStream ( ) ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; if ( deleteOnExit ) { file . deleteOnExit ( ) ; } } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } public static String verifyFilename ( String fileName ) { fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName = fileName . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int maxFileNameLength = <NUM_LIT> ; if ( System . getProperty ( \"<STR_LIT>\" ) . startsWith ( \"<STR_LIT>\" ) ) { maxFileNameLength = <NUM_LIT> ; } if ( fileName . length ( ) > maxFileNameLength ) { fileName = fileName . substring ( <NUM_LIT> , maxFileNameLength ) ; } fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName = fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; fileName", "gt": "= fileName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . domain . EmailConfig ; import me . zhengjie . service . EmailService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class EmailController { private final EmailService emailService ; @ GetMapping public ResponseEntity < EmailConfig > queryEmailConfig ( ) { return new ResponseEntity < > ( emailService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ PutMapping @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateEmailConfig ( @ Validated @ RequestBody EmailConfig emailConfig ) throws Exception { emailService", "gt": ". config ( emailConfig , emailService . find ( ) ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . domain . EmailConfig ; import me . zhengjie . service . EmailService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class EmailController { private final EmailService emailService ; @ GetMapping public ResponseEntity < EmailConfig > queryEmailConfig ( ) { return new ResponseEntity < > ( emailService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ PutMapping @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateEmailConfig ( @ Validated @ RequestBody EmailConfig emailConfig ) throws Exception { emailService . config ( emailConfig , emailService . find ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ PostMapping @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > sendEmail ( @ Validated @ RequestBody EmailVo emailVo ) { emailService", "gt": ". send ( emailVo , emailService . find ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest", "gt": "httpServletRequest = ( HttpServletRequest ) servletRequest ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String", "gt": "token = resolveToken ( httpServletRequest ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto", "gt": "= onlineUserService . getOne ( loginKey ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if", "gt": "( onlineUserDto != null && StringUtils . hasText ( token ) ) {"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if ( onlineUserDto != null && StringUtils . hasText ( token ) ) { Authentication authentication = tokenProvider . getAuthentication ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; tokenProvider . checkRenewal ( token ) ; } } filterChain", "gt": ". doFilter ( servletRequest , servletResponse ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if ( onlineUserDto != null && StringUtils . hasText ( token ) ) { Authentication authentication = tokenProvider . getAuthentication ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; tokenProvider . checkRenewal ( token ) ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } private String resolveToken ( HttpServletRequest request ) { String", "gt": "bearerToken = request . getHeader ( properties . getHeader ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if ( onlineUserDto != null && StringUtils . hasText ( token ) ) { Authentication authentication = tokenProvider . getAuthentication ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; tokenProvider . checkRenewal ( token ) ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } private String resolveToken ( HttpServletRequest request ) { String bearerToken = request . getHeader ( properties . getHeader ( ) ) ; if", "gt": "( StringUtils . hasText ( bearerToken ) && bearerToken . startsWith ( properties . getTokenStartWith ( ) ) ) {"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if ( onlineUserDto != null && StringUtils . hasText ( token ) ) { Authentication authentication = tokenProvider . getAuthentication ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; tokenProvider . checkRenewal ( token ) ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } private String resolveToken ( HttpServletRequest request ) { String bearerToken = request . getHeader ( properties . getHeader ( ) ) ; if ( StringUtils . hasText ( bearerToken ) && bearerToken . startsWith ( properties . getTokenStartWith ( ) ) ) { return", "gt": "bearerToken . replace ( properties . getTokenStartWith ( ) , \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . util . StrUtil ; import io . jsonwebtoken . ExpiredJwtException ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . util . StringUtils ; import org . springframework . web . filter . GenericFilterBean ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import java . io . IOException ; import java . util . Objects ; public class TokenFilter extends GenericFilterBean { private static final Logger log = LoggerFactory . getLogger ( TokenFilter . class ) ; private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; public TokenFilter ( TokenProvider tokenProvider , SecurityProperties properties , OnlineUserService onlineUserService , UserCacheManager userCacheManager ) { this . properties = properties ; this . onlineUserService = onlineUserService ; this . tokenProvider = tokenProvider ; this . userCacheManager = userCacheManager ; } @ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpServletRequest = ( HttpServletRequest ) servletRequest ; String token = resolveToken ( httpServletRequest ) ; if ( StrUtil . isNotBlank ( token ) ) { OnlineUserDto onlineUserDto = null ; boolean cleanUserCache = false ; try { String loginKey = tokenProvider . loginKey ( token ) ; onlineUserDto = onlineUserService . getOne ( loginKey ) ; } catch ( ExpiredJwtException e ) { log . error ( e . getMessage ( ) ) ; cleanUserCache = true ; } finally { if ( cleanUserCache || Objects . isNull ( onlineUserDto ) ) { userCacheManager . cleanUserCache ( String . valueOf ( tokenProvider . getClaims ( token ) . get ( TokenProvider . AUTHORITIES_KEY ) ) ) ; } } if ( onlineUserDto != null && StringUtils . hasText ( token ) ) { Authentication authentication = tokenProvider . getAuthentication ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; tokenProvider . checkRenewal ( token ) ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } private String resolveToken ( HttpServletRequest request ) { String bearerToken = request . getHeader ( properties . getHeader ( ) ) ; if ( StringUtils . hasText ( bearerToken ) && bearerToken . startsWith ( properties . getTokenStartWith ( ) ) ) { return bearerToken . replace ( properties . getTokenStartWith ( ) , \"<STR_LIT>\" ) ; } else { log", "gt": ". debug ( \"<STR_LIT>\" , bearerToken ) ;"}
{"input": "package me . zhengjie . modules . mnt . domain ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; import java . util . Set ; import java . util . stream . Collectors ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Deploy extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long appId ; @ TableField ( exist = false ) @ ApiModelProperty ( name = \"<STR_LIT>\" , hidden = true ) private Set < Server > deploys ; @ TableField ( exist = false ) private App app ; public void copy ( Deploy source ) { BeanUtil", "gt": ". copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ;"}
{"input": "package me . zhengjie . modules . mnt . domain ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; import java . util . Set ; import java . util . stream . Collectors ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Deploy extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long appId ; @ TableField ( exist = false ) @ ApiModelProperty ( name = \"<STR_LIT>\" , hidden = true ) private Set < Server > deploys ; @ TableField ( exist = false ) private App app ; public void copy ( Deploy source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } public String getServers ( ) { if", "gt": "( CollectionUtil . isNotEmpty ( deploys ) ) {"}
{"input": "package me . zhengjie . modules . quartz . task ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Service ; @ Slf4j @ Service public class TestTask { public void run ( ) { log . info ( \"<STR_LIT>\" ) ; } public void run1 ( String str ) { log", "gt": ". info ( \"<STR_LIT>\" , str ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate", "gt": ". expire ( key , time , timeUnit ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory", "gt": "factory = redisTemplate . getConnectionFactory ( ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List", "gt": "< String > result = new ArrayList < > ( ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result", "gt": ". add ( new String ( cursor . next ( ) ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils", "gt": ". releaseConnection ( rc , factory ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection", "gt": "rc = Objects . requireNonNull ( factory ) . getConnection ( ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor", "gt": "< byte [ ] > cursor = rc . scan ( options ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List", "gt": "< String > result = new ArrayList < > ( size ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if", "gt": "( tmpIndex >= fromIndex && tmpIndex < toIndex ) {"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result", "gt": ". add ( new String ( cursor . next ( ) ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return", "gt": "redisTemplate . hasKey ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log", "gt": ". debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if", "gt": "( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log", "gt": ". debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try", "gt": "( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) {"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return", "gt": "key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List", "gt": "list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate", "gt": ". opsForValue ( ) . set ( key , value ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate", "gt": ". opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return", "gt": "redisTemplate . opsForHash ( ) . entries ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate", "gt": ". opsForHash ( ) . putAll ( key , map ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return", "gt": "redisTemplate . opsForHash ( ) . increment ( key , item , by ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return", "gt": "redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return", "gt": "redisTemplate . opsForSet ( ) . isMember ( key , value ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long", "gt": "count = redisTemplate . opsForSet ( ) . add ( key , values ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return", "gt": "redisTemplate . opsForSet ( ) . size ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long", "gt": "count = redisTemplate . opsForSet ( ) . remove ( key , values ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return", "gt": "redisTemplate . opsForList ( ) . range ( key , start , end ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return", "gt": "redisTemplate . opsForList ( ) . size ( key ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return", "gt": "redisTemplate . opsForList ( ) . index ( key , index ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate", "gt": ". opsForList ( ) . rightPushAll ( key , value ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate", "gt": ". opsForList ( ) . rightPushAll ( key , value ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return", "gt": "redisTemplate . opsForList ( ) . remove ( key , count , value ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public void delByKeys ( String prefix , Set < Long > ids ) { Set", "gt": "< Object > keys = new HashSet < > ( ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public void delByKeys ( String prefix , Set < Long > ids ) { Set < Object > keys = new HashSet < > ( ) ; for", "gt": "( Long id : ids ) {"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public void delByKeys ( String prefix , Set < Long > ids ) { Set < Object > keys = new HashSet < > ( ) ; for ( Long id : ids ) { keys", "gt": ". addAll ( redisTemplate . keys ( new StringBuffer ( prefix ) . append ( id ) . toString ( ) ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public void delByKeys ( String prefix , Set < Long > ids ) { Set < Object > keys = new HashSet < > ( ) ; for ( Long id : ids ) { keys . addAll ( redisTemplate . keys ( new StringBuffer ( prefix ) . append ( id ) . toString ( ) ) ) ; } long count = redisTemplate . delete ( keys ) ; log . debug ( \"<STR_LIT>\" ) ; log", "gt": ". debug ( \"<STR_LIT>\" + keys . toString ( ) ) ;"}
{"input": "package me . zhengjie . utils ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . connection . RedisConnection ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . * ; import org . springframework . data . redis . serializer . StringRedisSerializer ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Component @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class RedisUtils { private static final Logger log = LoggerFactory . getLogger ( RedisUtils . class ) ; private RedisTemplate < Object , Object > redisTemplate ; public RedisUtils ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; this . redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; this . redisTemplate . setStringSerializer ( new StringRedisSerializer ( ) ) ; } public boolean expire ( String key , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , TimeUnit . SECONDS ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public boolean expire ( String key , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . expire ( key , time , timeUnit ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } return true ; } public long getExpire ( Object key ) { return redisTemplate . getExpire ( key , TimeUnit . SECONDS ) ; } public List < String > scan ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( ) ; while ( cursor . hasNext ( ) ) { result . add ( new String ( cursor . next ( ) ) ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public List < String > findKeysForPage ( String patternKey , int page , int size ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( patternKey ) . build ( ) ; RedisConnectionFactory factory = redisTemplate . getConnectionFactory ( ) ; RedisConnection rc = Objects . requireNonNull ( factory ) . getConnection ( ) ; Cursor < byte [ ] > cursor = rc . scan ( options ) ; List < String > result = new ArrayList < > ( size ) ; int tmpIndex = <NUM_LIT> ; int fromIndex = page * size ; int toIndex = page * size + size ; while ( cursor . hasNext ( ) ) { if ( tmpIndex >= fromIndex && tmpIndex < toIndex ) { result . add ( new String ( cursor . next ( ) ) ) ; tmpIndex ++ ; continue ; } if ( tmpIndex >= toIndex ) { break ; } tmpIndex ++ ; cursor . next ( ) ; } try { RedisConnectionUtils . releaseConnection ( rc , factory ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } return result ; } public boolean hasKey ( String key ) { try { return redisTemplate . hasKey ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { boolean result = redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( new StringBuilder ( \"<STR_LIT>\" ) . append ( keys [ <NUM_LIT> ] ) . append ( \"<STR_LIT>\" ) . append ( result ) . toString ( ) ) ; log . debug ( \"<STR_LIT>\" ) ; } else { Set < Object > keySet = new HashSet < > ( ) ; for ( String key : keys ) { if ( redisTemplate . hasKey ( key ) ) keySet . add ( key ) ; } long count = redisTemplate . delete ( keySet ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keySet . toString ( ) ) ; log . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" ) ; } } } public void scanDel ( String pattern ) { ScanOptions options = ScanOptions . scanOptions ( ) . match ( pattern ) . build ( ) ; try ( Cursor < byte [ ] > cursor = redisTemplate . executeWithStickyConnection ( ( RedisCallback < Cursor < byte [ ] > > ) connection -> ( Cursor < byte [ ] > ) new ConvertingCursor < > ( connection . scan ( options ) , redisTemplate . getKeySerializer ( ) :: deserialize ) ) ) { while ( cursor . hasNext ( ) ) { redisTemplate . delete ( cursor . next ( ) ) ; } } } public Object get ( String key ) { return key == null ? null : redisTemplate . opsForValue ( ) . get ( key ) ; } public List < Object > multiGet ( List < String > keys ) { List list = redisTemplate . opsForValue ( ) . multiGet ( Sets . newHashSet ( keys ) ) ; List resultList = Lists . newArrayList ( ) ; Optional . ofNullable ( list ) . ifPresent ( e -> list . forEach ( ele -> Optional . ofNullable ( ele ) . ifPresent ( resultList :: add ) ) ) ; return resultList ; } public boolean set ( String key , Object value ) { try { redisTemplate . opsForValue ( ) . set ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean set ( String key , Object value , long time , TimeUnit timeUnit ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , timeUnit ) ; } else { set ( key , value ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public Object hget ( String key , String item ) { return redisTemplate . opsForHash ( ) . get ( key , item ) ; } public Map < Object , Object > hmget ( String key ) { return redisTemplate . opsForHash ( ) . entries ( key ) ; } public boolean hmset ( String key , Map < String , Object > map ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hmset ( String key , Map < String , Object > map , long time ) { try { redisTemplate . opsForHash ( ) . putAll ( key , map ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean hset ( String key , String item , Object value , long time ) { try { redisTemplate . opsForHash ( ) . put ( key , item , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public void hdel ( String key , Object ... item ) { redisTemplate . opsForHash ( ) . delete ( key , item ) ; } public boolean hHasKey ( String key , String item ) { return redisTemplate . opsForHash ( ) . hasKey ( key , item ) ; } public double hincr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , by ) ; } public double hdecr ( String key , String item , double by ) { return redisTemplate . opsForHash ( ) . increment ( key , item , - by ) ; } public Set < Object > sGet ( String key ) { try { return redisTemplate . opsForSet ( ) . members ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean sHasKey ( String key , Object value ) { try { return redisTemplate . opsForSet ( ) . isMember ( key , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long sSet ( String key , Object ... values ) { try { return redisTemplate . opsForSet ( ) . add ( key , values ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sSetAndTime ( String key , long time , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . add ( key , values ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long sGetSetSize ( String key ) { try { return redisTemplate . opsForSet ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public long setRemove ( String key , Object ... values ) { try { Long count = redisTemplate . opsForSet ( ) . remove ( key , values ) ; return count ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public List < Object > lGet ( String key , long start , long end ) { try { return redisTemplate . opsForList ( ) . range ( key , start , end ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public long lGetListSize ( String key ) { try { return redisTemplate . opsForList ( ) . size ( key ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public Object lGetIndex ( String key , long index ) { try { return redisTemplate . opsForList ( ) . index ( key , index ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return null ; } } public boolean lSet ( String key , Object value ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , Object value , long time ) { try { redisTemplate . opsForList ( ) . rightPush ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lSet ( String key , List < Object > value , long time ) { try { redisTemplate . opsForList ( ) . rightPushAll ( key , value ) ; if ( time > <NUM_LIT> ) { expire ( key , time ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public boolean lUpdateIndex ( String key , long index , Object value ) { try { redisTemplate . opsForList ( ) . set ( key , index , value ) ; return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return false ; } } public long lRemove ( String key , long count , Object value ) { try { return redisTemplate . opsForList ( ) . remove ( key , count , value ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return <NUM_LIT> ; } } public void delByKeys ( String prefix , Set < Long > ids ) { Set < Object > keys = new HashSet < > ( ) ; for ( Long id : ids ) { keys . addAll ( redisTemplate . keys ( new StringBuffer ( prefix ) . append ( id ) . toString ( ) ) ) ; } long count = redisTemplate . delete ( keys ) ; log . debug ( \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + keys . toString ( ) ) ; log", "gt": ". debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String", "gt": "browser = StringUtils . getBrowser ( request ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto", "gt": "= new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log", "gt": ". error ( e . getMessage ( ) , e ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List", "gt": "< String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for", "gt": "( String key : keys ) {"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos", "gt": ". add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos", "gt": ". sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List", "gt": "< Map < String , Object > > list = new ArrayList < > ( ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for", "gt": "( OnlineUserDto user : all ) {"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( OnlineUserDto user : all ) { Map", "gt": "< String , Object > map = new LinkedHashMap < > ( ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( OnlineUserDto user : all ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map", "gt": ". put ( \"<STR_LIT>\" , user . getUserName ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( OnlineUserDto user : all ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , user . getUserName ( ) ) ; map . put ( \"<STR_LIT>\" , user . getDept ( ) ) ; map . put ( \"<STR_LIT>\" , user . getIp ( ) ) ; map", "gt": ". put ( \"<STR_LIT>\" , user . getAddress ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( OnlineUserDto user : all ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , user . getUserName ( ) ) ; map . put ( \"<STR_LIT>\" , user . getDept ( ) ) ; map . put ( \"<STR_LIT>\" , user . getIp ( ) ) ; map . put ( \"<STR_LIT>\" , user . getAddress ( ) ) ; map . put ( \"<STR_LIT>\" , user . getBrowser ( ) ) ; map", "gt": ". put ( \"<STR_LIT>\" , user . getLoginTime ( ) ) ;"}
{"input": "package me . zhengjie . modules . security . service ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . utils . PageResult ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . * ; import org . springframework . data . domain . Pageable ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Service @ Slf4j @ AllArgsConstructor public class OnlineUserService { private final SecurityProperties properties ; private final TokenProvider tokenProvider ; private final RedisUtils redisUtils ; public void save ( JwtUserDto jwtUserDto , String token , HttpServletRequest request ) { String dept = jwtUserDto . getUser ( ) . getDept ( ) . getName ( ) ; String ip = StringUtils . getIp ( request ) ; String browser = StringUtils . getBrowser ( request ) ; String address = StringUtils . getCityInfo ( ip ) ; OnlineUserDto onlineUserDto = null ; try { onlineUserDto = new OnlineUserDto ( jwtUserDto . getUsername ( ) , jwtUserDto . getUser ( ) . getNickName ( ) , dept , browser , ip , address , EncryptUtils . desEncrypt ( token ) , new Date ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . set ( loginKey , onlineUserDto , properties . getTokenValidityInSeconds ( ) , TimeUnit . MILLISECONDS ) ; } public PageResult < OnlineUserDto > getAll ( String username , Pageable pageable ) { List < OnlineUserDto > onlineUserDtos = getAll ( username ) ; return PageUtil . toPage ( PageUtil . paging ( pageable . getPageNumber ( ) , pageable . getPageSize ( ) , onlineUserDtos ) , onlineUserDtos . size ( ) ) ; } public List < OnlineUserDto > getAll ( String username ) { String loginKey = properties . getOnlineKey ( ) + ( StringUtils . isBlank ( username ) ? \"<STR_LIT>\" : \"<STR_LIT>\" + username ) ; List < String > keys = redisUtils . scan ( loginKey + \"<STR_LIT>\" ) ; Collections . reverse ( keys ) ; List < OnlineUserDto > onlineUserDtos = new ArrayList < > ( ) ; for ( String key : keys ) { onlineUserDtos . add ( ( OnlineUserDto ) redisUtils . get ( key ) ) ; } onlineUserDtos . sort ( ( o1 , o2 ) -> o2 . getLoginTime ( ) . compareTo ( o1 . getLoginTime ( ) ) ) ; return onlineUserDtos ; } public void logout ( String token ) { String loginKey = tokenProvider . loginKey ( token ) ; redisUtils . del ( loginKey ) ; } public void download ( List < OnlineUserDto > all , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( OnlineUserDto user : all ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , user . getUserName ( ) ) ; map . put ( \"<STR_LIT>\" , user . getDept ( ) ) ; map . put ( \"<STR_LIT>\" , user . getIp ( ) ) ; map . put ( \"<STR_LIT>\" , user . getAddress ( ) ) ; map . put ( \"<STR_LIT>\" , user . getBrowser ( ) ) ; map . put ( \"<STR_LIT>\" , user . getLoginTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } public OnlineUserDto getOne ( String key ) { return", "gt": "( OnlineUserDto ) redisUtils . get ( key ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource", "gt": "druidDataSource = new DruidDataSource ( ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw", "gt": "new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if", "gt": "( StringUtils . isEmpty ( className ) ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum", "gt": "dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw", "gt": "new RuntimeException ( e . getMessage ( ) ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection", "gt": "= dataSource . getConnection ( ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection", "gt": "= getConnection ( jdbcUrl , userName , password ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute", "gt": "( connection , readSqlList ( sqlFile ) ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for", "gt": "( String sql : sqlList ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if", "gt": "( sql . endsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql", "gt": "= sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try", "gt": "( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while", "gt": "( ( tmp = reader . readLine ( ) ) != null ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { log", "gt": ". info ( \"<STR_LIT>\" , tmp ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { log . info ( \"<STR_LIT>\" , tmp ) ; if", "gt": "( tmp . endsWith ( \"<STR_LIT>\" ) ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { log . info ( \"<STR_LIT>\" , tmp ) ; if ( tmp . endsWith ( \"<STR_LIT>\" ) ) { sb . append ( tmp ) ; sqlList", "gt": ". add ( sb . toString ( ) ) ;"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { log . info ( \"<STR_LIT>\" , tmp ) ; if ( tmp . endsWith ( \"<STR_LIT>\" ) ) { sb . append ( tmp ) ; sqlList . add ( sb . toString ( ) ) ; sb . delete ( <NUM_LIT> , sb . length ( ) ) ; } else { sb . append ( tmp ) ; } } if", "gt": "( ! \"<STR_LIT>\" . endsWith ( sb . toString ( ) . trim ( ) ) ) {"}
{"input": "package me . zhengjie . modules . mnt . util ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . util . StringUtils ; import com . google . common . collect . Lists ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . CloseUtil ; import javax . sql . DataSource ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . sql . * ; import java . util . List ; @ Slf4j public class SqlUtils { private static DataSource getDataSource ( String jdbcUrl , String userName , String password ) { DruidDataSource druidDataSource = new DruidDataSource ( ) ; String className ; try { className = DriverManager . getDriver ( jdbcUrl . trim ( ) ) . getClass ( ) . getName ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } if ( StringUtils . isEmpty ( className ) ) { DataTypeEnum dataTypeEnum = DataTypeEnum . urlOf ( jdbcUrl ) ; if ( null == dataTypeEnum ) { throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } druidDataSource . setDriverClassName ( dataTypeEnum . getDriver ( ) ) ; } else { druidDataSource . setDriverClassName ( className ) ; } druidDataSource . setUrl ( jdbcUrl ) ; druidDataSource . setUsername ( userName ) ; druidDataSource . setPassword ( password ) ; druidDataSource . setMaxWait ( <NUM_LIT> ) ; druidDataSource . setInitialSize ( <NUM_LIT> ) ; druidDataSource . setMinIdle ( <NUM_LIT> ) ; druidDataSource . setMaxActive ( <NUM_LIT> ) ; druidDataSource . setBreakAfterAcquireFailure ( true ) ; try { druidDataSource . init ( ) ; } catch ( SQLException e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new RuntimeException ( e . getMessage ( ) ) ; } return druidDataSource ; } private static Connection getConnection ( String jdbcUrl , String userName , String password ) { DataSource dataSource = getDataSource ( jdbcUrl , userName , password ) ; Connection connection = null ; try { connection = dataSource . getConnection ( ) ; } catch ( Exception ignored ) { } try { int timeOut = <NUM_LIT> ; if ( null == connection || connection . isClosed ( ) || ! connection . isValid ( timeOut ) ) { log . info ( \"<STR_LIT>\" ) ; connection = dataSource . getConnection ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , jdbcUrl ) ; throw new RuntimeException ( \"<STR_LIT>\" + jdbcUrl ) ; } finally { CloseUtil . close ( connection ) ; } return connection ; } private static void releaseConnection ( Connection connection ) { if ( null != connection ) { try { connection . close ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; log . error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } public static boolean testConnection ( String jdbcUrl , String userName , String password ) { Connection connection = null ; try { connection = getConnection ( jdbcUrl , userName , password ) ; if ( null != connection ) { return true ; } } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { releaseConnection ( connection ) ; } return false ; } public static String executeFile ( String jdbcUrl , String userName , String password , File sqlFile ) { Connection connection = getConnection ( jdbcUrl , userName , password ) ; try { batchExecute ( connection , readSqlList ( sqlFile ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return e . getMessage ( ) ; } finally { releaseConnection ( connection ) ; } return \"<STR_LIT>\" ; } public static void batchExecute ( Connection connection , List < String > sqlList ) { Statement st = null ; try { st = connection . createStatement ( ) ; for ( String sql : sqlList ) { if ( sql . endsWith ( \"<STR_LIT>\" ) ) { sql = sql . substring ( <NUM_LIT> , sql . length ( ) - <NUM_LIT> ) ; } st . addBatch ( sql ) ; } st . executeBatch ( ) ; } catch ( SQLException throwables ) { throwables . printStackTrace ( ) ; } finally { CloseUtil . close ( st ) ; } } private static List < String > readSqlList ( File sqlFile ) throws Exception { List < String > sqlList = Lists . newArrayList ( ) ; StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( sqlFile ) , StandardCharsets . UTF_8 ) ) ) { String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { log . info ( \"<STR_LIT>\" , tmp ) ; if ( tmp . endsWith ( \"<STR_LIT>\" ) ) { sb . append ( tmp ) ; sqlList . add ( sb . toString ( ) ) ; sb . delete ( <NUM_LIT> , sb . length ( ) ) ; } else { sb . append ( tmp ) ; } } if ( ! \"<STR_LIT>\" . endsWith ( sb . toString ( ) . trim ( ) ) ) { sqlList", "gt": ". add ( sb . toString ( ) ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration", "gt": "configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate", "gt": "< Object , Object > template = new RedisTemplate < > ( ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig", "gt": ". getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig", "gt": ". getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig", "gt": ". getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class", "gt": "< ? > targetClassClass = target . getClass ( ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container", "gt": ". put ( \"<STR_LIT>\" , method . getName ( ) ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container", "gt": ". put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container . put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ; for ( int i = <NUM_LIT> ; i < params . length ; i ++ ) { container . put ( String . valueOf ( i ) , params [ i ] ) ; } String", "gt": "jsonString = JSON . toJSONString ( container ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container . put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ; for ( int i = <NUM_LIT> ; i < params . length ; i ++ ) { container . put ( String . valueOf ( i ) , params [ i ] ) ; } String jsonString = JSON . toJSONString ( container ) ; return", "gt": "DigestUtils . sha256Hex ( jsonString ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container . put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ; for ( int i = <NUM_LIT> ; i < params . length ; i ++ ) { container . put ( String . valueOf ( i ) , params [ i ] ) ; } String jsonString = JSON . toJSONString ( container ) ; return DigestUtils . sha256Hex ( jsonString ) ; } ; } @ Bean @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public CacheErrorHandler errorHandler ( ) { log . info ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return new CacheErrorHandler ( ) { @ Override public void handleCacheGetError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCachePutError ( RuntimeException e , Cache cache , Object key , Object value ) { log . error ( \"<STR_LIT>\" , key , value , e ) ; } @ Override public void handleCacheEvictError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCacheClearError ( RuntimeException e , Cache cache ) { log . error ( \"<STR_LIT>\" , e ) ; } } ; } } class FastJsonRedisSerializer < T > implements RedisSerializer < T > { private final Class < T > clazz ; FastJsonRedisSerializer", "gt": "( Class < T > clazz ) {"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container . put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ; for ( int i = <NUM_LIT> ; i < params . length ; i ++ ) { container . put ( String . valueOf ( i ) , params [ i ] ) ; } String jsonString = JSON . toJSONString ( container ) ; return DigestUtils . sha256Hex ( jsonString ) ; } ; } @ Bean @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public CacheErrorHandler errorHandler ( ) { log . info ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return new CacheErrorHandler ( ) { @ Override public void handleCacheGetError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCachePutError ( RuntimeException e , Cache cache , Object key , Object value ) { log . error ( \"<STR_LIT>\" , key , value , e ) ; } @ Override public void handleCacheEvictError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCacheClearError ( RuntimeException e , Cache cache ) { log . error ( \"<STR_LIT>\" , e ) ; } } ; } } class FastJsonRedisSerializer < T > implements RedisSerializer < T > { private final Class < T > clazz ; FastJsonRedisSerializer ( Class < T > clazz ) { super ( ) ; this . clazz = clazz ; } @ Override public byte [ ] serialize ( T t ) { if ( t == null ) { return new byte [ <NUM_LIT> ] ; } return JSON . toJSONString ( t , SerializerFeature . WriteClassName ) . getBytes ( StandardCharsets . UTF_8 ) ; } @ Override public T deserialize ( byte [ ] bytes ) { if ( bytes == null || bytes . length == <NUM_LIT> ) { return null ; } String", "gt": "str = new String ( bytes , StandardCharsets . UTF_8 ) ;"}
{"input": "package me . zhengjie . config ; import cn . hutool . core . lang . Assert ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . parser . ParserConfig ; import com . alibaba . fastjson . serializer . SerializerFeature ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . codec . digest . DigestUtils ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . data . redis . RedisProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . Cache ; import org . springframework . cache . annotation . CachingConfigurerSupport ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . cache . interceptor . CacheErrorHandler ; import org . springframework . cache . interceptor . KeyGenerator ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisOperations ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; import reactor . util . annotation . Nullable ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . time . Duration ; import java . util . HashMap ; import java . util . Map ; @ Slf4j @ Configuration @ EnableCaching @ ConditionalOnClass ( RedisOperations . class ) @ EnableConfigurationProperties ( RedisProperties . class ) public class RedisConfig extends CachingConfigurerSupport { @ Bean public RedisCacheConfiguration redisCacheConfiguration ( ) { FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; RedisCacheConfiguration configuration = RedisCacheConfiguration . defaultCacheConfig ( ) ; configuration = configuration . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( fastJsonRedisSerializer ) ) . entryTtl ( Duration . ofHours ( <NUM_LIT> ) ) ; return configuration ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnMissingBean ( name = \"<STR_LIT>\" ) public RedisTemplate < Object , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < Object , Object > template = new RedisTemplate < > ( ) ; FastJsonRedisSerializer < Object > fastJsonRedisSerializer = new FastJsonRedisSerializer < > ( Object . class ) ; template . setValueSerializer ( fastJsonRedisSerializer ) ; template . setHashValueSerializer ( fastJsonRedisSerializer ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; ParserConfig . getGlobalInstance ( ) . addAccept ( \"<STR_LIT>\" ) ; template . setKeySerializer ( new StringRedisSerializer ( ) ) ; template . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; template . setConnectionFactory ( redisConnectionFactory ) ; return template ; } @ Bean @ Override public KeyGenerator keyGenerator ( ) { return ( target , method , params ) -> { Map < String , Object > container = new HashMap < > ( <NUM_LIT> ) ; Class < ? > targetClassClass = target . getClass ( ) ; container . put ( \"<STR_LIT>\" , targetClassClass . toGenericString ( ) ) ; container . put ( \"<STR_LIT>\" , method . getName ( ) ) ; container . put ( \"<STR_LIT>\" , targetClassClass . getPackage ( ) ) ; for ( int i = <NUM_LIT> ; i < params . length ; i ++ ) { container . put ( String . valueOf ( i ) , params [ i ] ) ; } String jsonString = JSON . toJSONString ( container ) ; return DigestUtils . sha256Hex ( jsonString ) ; } ; } @ Bean @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public CacheErrorHandler errorHandler ( ) { log . info ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return new CacheErrorHandler ( ) { @ Override public void handleCacheGetError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCachePutError ( RuntimeException e , Cache cache , Object key , Object value ) { log . error ( \"<STR_LIT>\" , key , value , e ) ; } @ Override public void handleCacheEvictError ( RuntimeException e , Cache cache , Object key ) { log . error ( \"<STR_LIT>\" , key , e ) ; } @ Override public void handleCacheClearError ( RuntimeException e , Cache cache ) { log . error ( \"<STR_LIT>\" , e ) ; } } ; } } class FastJsonRedisSerializer < T > implements RedisSerializer < T > { private final Class < T > clazz ; FastJsonRedisSerializer ( Class < T > clazz ) { super ( ) ; this . clazz = clazz ; } @ Override public byte [ ] serialize ( T t ) { if ( t == null ) { return new byte [ <NUM_LIT> ] ; } return JSON . toJSONString ( t , SerializerFeature . WriteClassName ) . getBytes ( StandardCharsets . UTF_8 ) ; } @ Override public T deserialize ( byte [ ] bytes ) { if ( bytes == null || bytes . length == <NUM_LIT> ) { return null ; } String str = new String ( bytes , StandardCharsets . UTF_8 ) ; return", "gt": "JSON . parseObject ( str , clazz ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return", "gt": "new ResponseEntity < > ( HttpStatus . OK ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig", "gt": "aliPay = alipayService . find ( ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade", "gt": ". setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return", "gt": "ResponseEntity . ok ( payUrl ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade", "gt": ". setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String", "gt": "outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System", "gt": ". out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return", "gt": "new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ; } } @ ApiIgnore @ RequestMapping ( \"<STR_LIT>\" ) @ AnonymousAccess @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > notify ( HttpServletRequest request ) { AlipayConfig alipay = alipayService . find ( ) ; Map < String , String [ ] > parameterMap = request . getParameterMap ( ) ; if", "gt": "( alipayUtils . rsaCheck ( request , alipay ) ) {"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ; } } @ ApiIgnore @ RequestMapping ( \"<STR_LIT>\" ) @ AnonymousAccess @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > notify ( HttpServletRequest request ) { AlipayConfig alipay = alipayService . find ( ) ; Map < String , String [ ] > parameterMap = request . getParameterMap ( ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String tradeStatus = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String", "gt": "tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ; } } @ ApiIgnore @ RequestMapping ( \"<STR_LIT>\" ) @ AnonymousAccess @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > notify ( HttpServletRequest request ) { AlipayConfig alipay = alipayService . find ( ) ; Map < String , String [ ] > parameterMap = request . getParameterMap ( ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String tradeStatus = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String totalAmount = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; if", "gt": "( tradeStatus . equals ( AliPayStatusEnum . SUCCESS . getValue ( ) ) || tradeStatus . equals ( AliPayStatusEnum . FINISHED . getValue ( ) ) ) {"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ; } } @ ApiIgnore @ RequestMapping ( \"<STR_LIT>\" ) @ AnonymousAccess @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > notify ( HttpServletRequest request ) { AlipayConfig alipay = alipayService . find ( ) ; Map < String , String [ ] > parameterMap = request . getParameterMap ( ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String tradeStatus = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String totalAmount = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; if ( tradeStatus . equals ( AliPayStatusEnum . SUCCESS . getValue ( ) ) || tradeStatus . equals ( AliPayStatusEnum . FINISHED . getValue ( ) ) ) { } return", "gt": "new ResponseEntity < > ( HttpStatus . OK ) ;"}
{"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . utils . AliPayStatusEnum ; import me . zhengjie . utils . AlipayUtils ; import me . zhengjie . service . AliPayService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class AliPayController { private final AlipayUtils alipayUtils ; private final AliPayService alipayService ; @ GetMapping public ResponseEntity < AlipayConfig > queryAliConfig ( ) { return new ResponseEntity < > ( alipayService . find ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < Object > updateAliPayConfig ( @ Validated @ RequestBody AlipayConfig alipayConfig ) { alipayService . config ( alipayConfig ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsPc ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig aliPay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsPc ( aliPay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < String > toPayAsWeb ( @ Validated @ RequestBody TradeVo trade ) throws Exception { AlipayConfig alipay = alipayService . find ( ) ; trade . setOutTradeNo ( alipayUtils . getOrderCode ( ) ) ; String payUrl = alipayService . toPayAsWeb ( alipay , trade ) ; return ResponseEntity . ok ( payUrl ) ; } @ ApiIgnore @ AnonymousGetMapping ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < String > returnPage ( HttpServletRequest request , HttpServletResponse response ) { AlipayConfig alipay = alipayService . find ( ) ; response . setContentType ( \"<STR_LIT>\" + alipay . getCharset ( ) ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; System . out . println ( \"<STR_LIT>\" + outTradeNo + \"<STR_LIT>\" + \"<STR_LIT>\" + tradeNo ) ; return new ResponseEntity < > ( \"<STR_LIT>\" , HttpStatus . OK ) ; } else { return new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ; } } @ ApiIgnore @ RequestMapping ( \"<STR_LIT>\" ) @ AnonymousAccess @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > notify ( HttpServletRequest request ) { AlipayConfig alipay = alipayService . find ( ) ; Map < String , String [ ] > parameterMap = request . getParameterMap ( ) ; if ( alipayUtils . rsaCheck ( request , alipay ) ) { String tradeStatus = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String outTradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String tradeNo = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; String totalAmount = new String ( request . getParameter ( \"<STR_LIT>\" ) . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ; if ( tradeStatus . equals ( AliPayStatusEnum . SUCCESS . getValue ( ) ) || tradeStatus . equals ( AliPayStatusEnum . FINISHED . getValue ( ) ) ) { } return new ResponseEntity < > ( HttpStatus . OK ) ; } return", "gt": "new ResponseEntity < > ( HttpStatus . BAD_REQUEST ) ;"}
