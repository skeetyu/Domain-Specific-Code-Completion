{"input": "from gevent import monkey <EOL> monkey", "gt": ". patch_all ( )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def", "gt": "create_app ( ) :"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth", "gt": ". init ( )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if", "gt": "not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) :"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app", "gt": ". logger . info ( \"<STR_LIT>\" )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks", "gt": ". huey . start ( )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks . huey . start ( ) <EOL> @ app . teardown_appcontext <EOL> def", "gt": "shutdown_session ( exception = None ) :"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks . huey . start ( ) <EOL> @ app . teardown_appcontext <EOL> def shutdown_session ( exception = None ) : <EOL> models . db . session . remove ( ) <EOL> return app <EOL> def", "gt": "create_huey_app ( ) :"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks . huey . start ( ) <EOL> @ app . teardown_appcontext <EOL> def shutdown_session ( exception = None ) : <EOL> models . db . session . remove ( ) <EOL> return app <EOL> def create_huey_app ( ) : <EOL> app", "gt": "= flask . Flask ( '<STR_LIT>' )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks . huey . start ( ) <EOL> @ app . teardown_appcontext <EOL> def shutdown_session ( exception = None ) : <EOL> models . db . session . remove ( ) <EOL> return app <EOL> def create_huey_app ( ) : <EOL> app = flask . Flask ( '<STR_LIT>' ) <EOL> load_config ( app ) <EOL> with app . app_context ( ) : <EOL> pool_size", "gt": "= round ( app . config [ '<STR_LIT>' ] * <NUM_LIT> )"}
{"input": "from gevent import monkey <EOL> monkey . patch_all ( ) <EOL> import logging <EOL> import os <EOL> import flask <EOL> from werkzeug . serving import is_running_from_reloader <EOL> import feedi . models as models <EOL> def create_app ( ) : <EOL> app = flask . Flask ( __package__ ) <EOL> load_config ( app ) <EOL> app . logger . info ( '<STR_LIT>' , os . getenv ( '<STR_LIT>' ) ) <EOL> with app . app_context ( ) : <EOL> from . import auth , filters , routes , tasks <EOL> models . init_db ( app ) <EOL> auth . init ( ) <EOL> if not is_running_from_reloader ( ) and not os . environ . get ( '<STR_LIT>' ) : <EOL> app . logger . info ( \"<STR_LIT>\" ) <EOL> tasks . huey . start ( ) <EOL> @ app . teardown_appcontext <EOL> def shutdown_session ( exception = None ) : <EOL> models . db . session . remove ( ) <EOL> return app <EOL> def create_huey_app ( ) : <EOL> app = flask . Flask ( '<STR_LIT>' ) <EOL> load_config ( app ) <EOL> with app . app_context ( ) : <EOL> pool_size = round ( app . config [ '<STR_LIT>' ] * <NUM_LIT> ) <EOL> app . config [ '<STR_LIT>' ] = { '<STR_LIT>' : pool_size } <EOL> models . init_db ( app ) <EOL> return app <EOL> def load_config ( app ) : <EOL> app . logger . setLevel ( logging . INFO ) <EOL> env = os . getenv ( '<STR_LIT>' ) <EOL> if not env : <EOL> app . logger . error ( '<STR_LIT>' ) <EOL> exit ( ) <EOL> app", "gt": ". config . from_object ( '<STR_LIT>' )"}
{"input": "bind = \"<STR_LIT>\" <EOL> worker_class = \"<STR_LIT>\" <EOL> wsgi_app = \"<STR_LIT>\" <EOL> raw_env", "gt": "= [ \"<STR_LIT>\" ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger", "gt": "= logging . getLogger ( __name__ )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES", "gt": "= [ '<STR_LIT>' , '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def", "gt": "register_app ( server_url , callback_url ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return", "gt": "mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def", "gt": "auth_redirect_url ( server_url , client_id , client_secret , callback_url ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client", "gt": "= mastodon . Mastodon ( client_id = client_id ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return", "gt": "client . auth_request_url ( client_id = client_id , scopes = SCOPES ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def", "gt": "fetch_account_data ( server_url , access_token ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client", "gt": "= mastodon . Mastodon ( access_token = access_token ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return", "gt": "client . me ( )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def", "gt": "boost ( server_url , access_token , toot_id ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def", "gt": "favorite ( server_url , access_token , toot_id ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client", "gt": ". status_favourite ( id = toot_id )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots", "gt": "= mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>'", "gt": ": json . dumps ( toot , default = str )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry", "gt": "[ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry", "gt": "[ '<STR_LIT>' ] = f'<STR_LIT>'"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry", "gt": "[ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry", "gt": "[ '<STR_LIT>' ] = display_name ( toot )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry", "gt": "[ '<STR_LIT>' ] = toot [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry", "gt": "[ '<STR_LIT>' ] = entry [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media", "gt": "= [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry", "gt": "[ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if", "gt": "toot . get ( '<STR_LIT>' ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry", "gt": "[ '<STR_LIT>' ] += '<STR_LIT>'"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for", "gt": "option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries", "gt": ". append ( entry )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications", "gt": "= mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\"", "gt": ": ( '<STR_LIT>' , \"<STR_LIT>\" ) ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\"", "gt": ": ( '<STR_LIT>' , \"<STR_LIT>\" ) ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>'", "gt": ": notification [ '<STR_LIT>' ] ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>'", "gt": ": notification [ '<STR_LIT>' ] ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>'", "gt": ": notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>'", "gt": ": display_name ( notification ) ,"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if", "gt": "notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = user_url ( server_url , notification ) <EOL> else : <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , notification [ '<STR_LIT>' ] ) <EOL> entry", "gt": "[ '<STR_LIT>' ] = entry [ '<STR_LIT>' ]"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = user_url ( server_url , notification ) <EOL> else : <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , notification [ '<STR_LIT>' ] ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> entries . append ( entry ) <EOL> return entries <EOL> def user_url ( server_url , status_dict ) : <EOL> return f'<STR_LIT>' <EOL> def status_url ( server_url , status_dict ) : <EOL> \"<STR_LIT>\" <EOL> return f'<STR_LIT>' <EOL> def", "gt": "display_name ( status_dict ) :"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = user_url ( server_url , notification ) <EOL> else : <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , notification [ '<STR_LIT>' ] ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> entries . append ( entry ) <EOL> return entries <EOL> def user_url ( server_url , status_dict ) : <EOL> return f'<STR_LIT>' <EOL> def status_url ( server_url , status_dict ) : <EOL> \"<STR_LIT>\" <EOL> return f'<STR_LIT>' <EOL> def display_name ( status_dict ) : <EOL> return status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] or status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> def mastodon_request ( server_url , method , access_token , newer_than = None , limit = None ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> if newer_than : <EOL> results = getattr ( client , method ) ( min_id = newer_than ) <EOL> items = results <EOL> while results : <EOL> results", "gt": "= client . fetch_previous ( results )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = user_url ( server_url , notification ) <EOL> else : <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , notification [ '<STR_LIT>' ] ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> entries . append ( entry ) <EOL> return entries <EOL> def user_url ( server_url , status_dict ) : <EOL> return f'<STR_LIT>' <EOL> def status_url ( server_url , status_dict ) : <EOL> \"<STR_LIT>\" <EOL> return f'<STR_LIT>' <EOL> def display_name ( status_dict ) : <EOL> return status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] or status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> def mastodon_request ( server_url , method , access_token , newer_than = None , limit = None ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> if newer_than : <EOL> results = getattr ( client , method ) ( min_id = newer_than ) <EOL> items = results <EOL> while results : <EOL> results = client . fetch_previous ( results ) <EOL> items += results <EOL> elif limit : <EOL> results", "gt": "= getattr ( client , method ) ( limit = limit )"}
{"input": "import json <EOL> import logging <EOL> import mastodon <EOL> logger = logging . getLogger ( __name__ ) <EOL> CLIENT_NAME = '<STR_LIT>' <EOL> SCOPES = [ '<STR_LIT>' , '<STR_LIT>' ] <EOL> def register_app ( server_url , callback_url ) : <EOL> return mastodon . Mastodon . create_app ( CLIENT_NAME , api_base_url = server_url , <EOL> redirect_uris = [ callback_url ] , <EOL> scopes = SCOPES ) <EOL> def auth_redirect_url ( server_url , client_id , client_secret , callback_url ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . auth_request_url ( client_id = client_id , scopes = SCOPES , <EOL> redirect_uris = callback_url ) <EOL> def oauth_login ( server_url , client_id , client_secret , callback_url , code ) : <EOL> client = mastodon . Mastodon ( client_id = client_id , <EOL> client_secret = client_secret , <EOL> api_base_url = server_url ) <EOL> return client . log_in ( code = code , redirect_uri = callback_url , scopes = SCOPES ) <EOL> def fetch_account_data ( server_url , access_token ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> return client . me ( ) <EOL> def boost ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_reblog ( id = toot_id ) <EOL> def favorite ( server_url , access_token , toot_id ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> client . status_favourite ( id = toot_id ) <EOL> def fetch_toots ( server_url , access_token , newer_than = None , limit = None ) : <EOL> toots = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for toot in toots : <EOL> entry = { <EOL> '<STR_LIT>' : json . dumps ( toot , default = str ) <EOL> } <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] or toot [ '<STR_LIT>' ] <EOL> if toot . get ( '<STR_LIT>' ) and not toot . get ( '<STR_LIT>' ) : <EOL> continue <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> reblogged_by = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = f'<STR_LIT>' <EOL> toot = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = display_name ( toot ) <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , toot ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> media = [ m [ '<STR_LIT>' ] for m in toot [ '<STR_LIT>' ] if m [ '<STR_LIT>' ] == '<STR_LIT>' ] <EOL> if media : <EOL> entry [ '<STR_LIT>' ] = media [ <NUM_LIT> ] <EOL> elif toot [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = toot [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) <EOL> if toot . get ( '<STR_LIT>' ) : <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> for option in toot [ '<STR_LIT>' ] [ '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] += f'<STR_LIT>' <EOL> entry [ '<STR_LIT>' ] += '<STR_LIT>' <EOL> entries . append ( entry ) <EOL> return entries <EOL> def fetch_notifications ( server_url , access_token , newer_than = None , limit = None ) : <EOL> notifications = mastodon_request ( server_url , '<STR_LIT>' , access_token , newer_than , limit ) <EOL> entries = [ ] <EOL> for notification in notifications : <EOL> NOTIFICATION_PHRASES = { <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> \"<STR_LIT>\" : ( '<STR_LIT>' , \"<STR_LIT>\" ) , <EOL> } <EOL> if notification [ '<STR_LIT>' ] not in NOTIFICATION_PHRASES : <EOL> continue <EOL> ( icon , phrase ) = NOTIFICATION_PHRASES [ notification [ \"<STR_LIT>\" ] ] <EOL> body = f'<STR_LIT>' <EOL> entry = { <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : json . dumps ( notification , default = str ) , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : notification [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : display_name ( notification ) , <EOL> '<STR_LIT>' : body } <EOL> if notification [ '<STR_LIT>' ] in [ '<STR_LIT>' , '<STR_LIT>' ] : <EOL> entry [ '<STR_LIT>' ] = user_url ( server_url , notification ) <EOL> else : <EOL> entry [ '<STR_LIT>' ] = status_url ( server_url , notification [ '<STR_LIT>' ] ) <EOL> entry [ '<STR_LIT>' ] = entry [ '<STR_LIT>' ] <EOL> entries . append ( entry ) <EOL> return entries <EOL> def user_url ( server_url , status_dict ) : <EOL> return f'<STR_LIT>' <EOL> def status_url ( server_url , status_dict ) : <EOL> \"<STR_LIT>\" <EOL> return f'<STR_LIT>' <EOL> def display_name ( status_dict ) : <EOL> return status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] or status_dict [ '<STR_LIT>' ] [ '<STR_LIT>' ] . split ( '<STR_LIT>' ) [ <NUM_LIT> ] <EOL> def mastodon_request ( server_url , method , access_token , newer_than = None , limit = None ) : <EOL> client = mastodon . Mastodon ( access_token = access_token , <EOL> api_base_url = server_url ) <EOL> if newer_than : <EOL> results = getattr ( client , method ) ( min_id = newer_than ) <EOL> items = results <EOL> while results : <EOL> results = client . fetch_previous ( results ) <EOL> items += results <EOL> elif limit : <EOL> results = getattr ( client , method ) ( limit = limit ) <EOL> items = results <EOL> while results and len ( items ) < limit : <EOL> results = client . fetch_next ( results ) <EOL> items += results <EOL> else : <EOL> raise", "gt": "ValueError ( \"<STR_LIT>\" )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta", "gt": "= datetime . datetime . utcnow ( ) - dt"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if", "gt": "delta < datetime . timedelta ( seconds = <NUM_LIT> ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif", "gt": "delta < datetime . timedelta ( hours = <NUM_LIT> ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif", "gt": "delta < datetime . timedelta ( days = <NUM_LIT> ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif", "gt": "delta < datetime . timedelta ( days = <NUM_LIT> ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def", "gt": "feed_domain ( url ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return", "gt": "parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def", "gt": "should_unfold_folder ( filters , folder_name , folder_feeds ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @", "gt": "app . template_filter ( '<STR_LIT>' )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def", "gt": "contains_feed_name ( feed_list , selected_name ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @", "gt": "app . template_filter ( '<STR_LIT>' )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def", "gt": "sanitize_content ( html , truncate = True ) :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if", "gt": "len ( html ) > <NUM_LIT> and truncate :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html", "gt": "= html [ : <NUM_LIT> ] + '<STR_LIT>'"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if", "gt": "soup . html :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if", "gt": "soup . html . body :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup", "gt": ". html . body . unwrap ( )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup", "gt": ". html . unwrap ( )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return", "gt": "str ( soup )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @", "gt": "app . template_filter ( '<STR_LIT>' )"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if", "gt": "not entry . content_short :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if not entry . content_short : <EOL> return '<STR_LIT>' <EOL> if", "gt": "entry . content_url and entry . title :"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if not entry . content_short : <EOL> return '<STR_LIT>' <EOL> if entry . content_url and entry . title : <EOL> title = entry . title <EOL> elif entry . has_distinct_user : <EOL> title", "gt": "= entry . display_name or entry . username"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if not entry . content_short : <EOL> return '<STR_LIT>' <EOL> if entry . content_url and entry . title : <EOL> title = entry . title <EOL> elif entry . has_distinct_user : <EOL> title = entry . display_name or entry . username <EOL> else : <EOL> title", "gt": "= entry . feed . name"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if not entry . content_short : <EOL> return '<STR_LIT>' <EOL> if entry . content_url and entry . title : <EOL> title = entry . title <EOL> elif entry . has_distinct_user : <EOL> title = entry . display_name or entry . username <EOL> else : <EOL> title = entry . feed . name <EOL> body_text", "gt": "= BeautifulSoup ( entry . content_short , '<STR_LIT>' ) . text"}
{"input": "import datetime <EOL> import urllib <EOL> import flask <EOL> from bs4 import BeautifulSoup <EOL> from flask import current_app as app <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def humanize_date ( dt ) : <EOL> delta = datetime . datetime . utcnow ( ) - dt <EOL> if delta < datetime . timedelta ( seconds = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( hours = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return f\"<STR_LIT>\" <EOL> elif delta < datetime . timedelta ( days = <NUM_LIT> ) : <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> return dt . strftime ( \"<STR_LIT>\" ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def feed_domain ( url ) : <EOL> parts = urllib . parse . urlparse ( url ) <EOL> return parts . netloc . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def should_unfold_folder ( filters , folder_name , folder_feeds ) : <EOL> if filters . get ( '<STR_LIT>' ) == folder_name : <EOL> return True <EOL> if filters . get ( '<STR_LIT>' ) : <EOL> if filters [ '<STR_LIT>' ] in [ f . name for f in folder_feeds ] : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def contains_feed_name ( feed_list , selected_name ) : <EOL> for feed in feed_list : <EOL> if feed . name == selected_name : <EOL> return True <EOL> return False <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def sanitize_content ( html , truncate = True ) : <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if len ( html ) > <NUM_LIT> and truncate : <EOL> html = html [ : <NUM_LIT> ] + '<STR_LIT>' <EOL> soup = BeautifulSoup ( html , '<STR_LIT>' ) <EOL> if soup . html : <EOL> if soup . html . body : <EOL> soup . html . body . unwrap ( ) <EOL> soup . html . unwrap ( ) <EOL> for a in soup . find_all ( '<STR_LIT>' , href = True ) : <EOL> read_url = flask . url_for ( \"<STR_LIT>\" , url = a [ \"<STR_LIT>\" ] , redirect = <NUM_LIT> ) <EOL> a [ '<STR_LIT>' ] = <EOL> return str ( soup ) <EOL> @ app . template_filter ( '<STR_LIT>' ) <EOL> def entry_excerpt ( entry ) : <EOL> if not entry . content_short : <EOL> return '<STR_LIT>' <EOL> if entry . content_url and entry . title : <EOL> title = entry . title <EOL> elif entry . has_distinct_user : <EOL> title = entry . display_name or entry . username <EOL> else : <EOL> title = entry . feed . name <EOL> body_text = BeautifulSoup ( entry . content_short , '<STR_LIT>' ) . text <EOL> max_length = <NUM_LIT> <EOL> max_body_length = max ( <NUM_LIT> , max_length - len ( title ) ) <EOL> if len ( body_text ) > max_body_length : <EOL> return", "gt": "body_text [ : max_body_length ] + '<STR_LIT>'"}
