<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( "<STR_LIT>" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return getHorizontalHelper ( layoutManager ) ; } else { return null ; } } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) { mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ; } return mHorizontalHelper ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mAdapter . notifyItemRangeChanged ( position , count ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollWebView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollWebView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollWebView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollWebView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , "<STR_LIT>" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , "<STR_LIT>" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , "<STR_LIT>" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) { mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ; } } private void autoHideScrollbar ( ) { if ( mDragging ) { return ; } mAnimationHelper . hideScrollbar ( mTrackView , mThumbView ) ; } private void cancelAutoHideScrollbar ( ) { mView . removeCallbacks ( mAutoHideScrollbarRunnable ) ; } public interface ViewHelper { void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) ; void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) ; void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) ; int getScrollRange ( ) ; int getScrollOffset ( ) ; void scrollTo ( int offset ) ; @ Nullable default CharSequence getPopupText ( ) { return null ; } } public interface AnimationHelper { void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; boolean isScrollbarAutoHideEnabled ( ) ; int getScrollbarAutoHideDelayMillis ( ) ; void showPopup ( @ NonNull View popupView ) ; void hidePopup ( @ NonNull View popupView ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { } @ Override public void clearView ( @ NonNull View view ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { final Object tag = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( tag instanceof Float ) { ViewCompat . setElevation ( view , ( Float ) tag ) ; } view . setTag ( R . id . item_touch_helper_previous_elevation , null ) ; } view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; } @ Override public void onSelected ( @ NonNull View view ) { } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; } @ Override public void showPopup ( @ NonNull View popupView ) { if ( mShowingPopup ) { return ; } mShowingPopup = true ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . start ( ) ; } @ Override public void hidePopup ( @ NonNull View popupView ) { if ( ! mShowingPopup ) { return ; } mShowingPopup = false ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( HIDE_DURATION_MILLIS ) . start ( ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY_GROUP_PREFIX ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Rect ; import android . os . Build ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . SparseArray ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityNodeInfo ; import android . view . animation . Interpolator ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . Px ; import androidx . annotation . RequiresApi ; import androidx . annotation . RestrictTo ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat . AccessibilityActionCompat ; import androidx . core . view . accessibility . AccessibilityViewCommand ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . PagerSnapHelper ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ItemDecoration ; import androidx . fluidviewpager2 . adapter . FragmentStateAdapter ; import androidx . fluidviewpager2 . adapter . StatefulAdapter ; import androidx . interpolator . view . animation . FastOutSlowInInterpolator ; import androidx . viewpager2 . R ; import com . google . android . material . motion . MotionUtils ; import java . lang . annotation . Retention ; public final class ViewPager2 extends ViewGroup { public static final int ORIENTATION_HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int ORIENTATION_VERTICAL = RecyclerView . VERTICAL ; public static final int SCROLL_STATE_IDLE = <NUM_LIT> ; public static final int SCROLL_STATE_DRAGGING = <NUM_LIT> ; public static final int SCROLL_STATE_SETTLING = <NUM_LIT> ; public static final int OFFSCREEN_PAGE_LIMIT_DEFAULT = - <NUM_LIT> ; static boolean sFeatureEnhancedA11yEnabled = true ; private final Rect mTmpContainerRect = new Rect ( ) ; private final Rect mTmpChildRect = new Rect ( ) ; int mCurrentItem ; boolean mCurrentItemDirty = false ; LinearLayoutManager mLayoutManager ; RecyclerView mRecyclerView ; ScrollEventAdapter mScrollEventAdapter ; AccessibilityProvider mAccessibilityProvider ; private CompositeOnPageChangeCallback mExternalPageChangeCallbacks = new CompositeOnPageChangeCallback ( <NUM_LIT> ) ; private RecyclerView . AdapterDataObserver mCurrentItemDataSetChangeObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { mCurrentItemDirty = true ; mScrollEventAdapter . notifyDataSetChangeHappened ( ) ; } } ; private int mPendingCurrentItem = NO_POSITION ; private Parcelable mPendingAdapterState ; private PagerSnapHelper mPagerSnapHelper ; private CompositeOnPageChangeCallback mPageChangeEventDispatcher ; private FakeDrag mFakeDragger ; private androidx . fluidviewpager2 . widget . PageTransformerAdapter mPageTransformerAdapter ; private RecyclerView . ItemAnimator mSavedItemAnimator = null ; private boolean mSavedItemAnimatorPresent = false ; private boolean mUserInputEnabled = true ; private @ OffscreenPageLimit int mOffscreenPageLimit = OFFSCREEN_PAGE_LIMIT_DEFAULT ; public ViewPager2 ( @ NonNull Context context ) { super ( context ) ; initialize ( context , null ) ; } public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; initialize ( context , attrs ) ; } public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initialize ( context , attrs ) ; } @ RequiresApi ( <NUM_LIT> ) @ SuppressLint ( "<STR_LIT>" ) public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; initialize ( context , attrs ) ; } private void initialize ( Context context , AttributeSet attrs ) { mAccessibilityProvider = sFeatureEnhancedA11yEnabled ? new PageAwareAccessibilityProvider ( ) : new BasicAccessibilityProvider ( ) ; mRecyclerView = new RecyclerViewImpl ( context ) ; mRecyclerView . setId ( View . generateViewId ( ) ) ; mRecyclerView . setDescendantFocusability ( FOCUS_BEFORE_DESCENDANTS ) ; mLayoutManager = new LinearLayoutManagerImpl ( context ) ; mRecyclerView . setLayoutManager ( mLayoutManager ) ; mRecyclerView . setScrollingTouchSlop ( RecyclerView . TOUCH_SLOP_PAGING ) ; setOrientation ( context , attrs ) ; mRecyclerView . setLayoutParams ( new ViewGroup . LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ) ; mRecyclerView . addOnChildAttachStateChangeListener ( enforceChildFillListener ( ) ) ; mScrollEventAdapter = new ScrollEventAdapter ( this ) ; mFakeDragger = new FakeDrag ( this , mScrollEventAdapter , mRecyclerView ) ; mPagerSnapHelper = new PagerSnapHelperImpl ( ) ; mPagerSnapHelper . attachToRecyclerView ( mRecyclerView ) ; mRecyclerView . addOnScrollListener ( mScrollEventAdapter ) ; mPageChangeEventDispatcher = new CompositeOnPageChangeCallback ( <NUM_LIT> ) ; mScrollEventAdapter . setOnPageChangeCallback ( mPageChangeEventDispatcher ) ; final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { if ( mCurrentItem != position ) { mCurrentItem = position ; mAccessibilityProvider . onSetNewCurrentItem ( ) ; } } @ Override public void onPageScrollStateChanged ( int newState ) { if ( newState == SCROLL_STATE_IDLE ) { updateCurrentItem ( ) ; } } } ; final OnPageChangeCallback focusClearer = new OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { clearFocus ( ) ; if ( hasFocus ( ) ) { mRecyclerView . requestFocus ( View . FOCUS_FORWARD ) ; } } } ; mPageChangeEventDispatcher . addOnPageChangeCallback ( currentItemUpdater ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( focusClearer ) ; mAccessibilityProvider . onInitialize ( mPageChangeEventDispatcher , mRecyclerView ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( mExternalPageChangeCallbacks ) ; mPageTransformerAdapter = new androidx . fluidviewpager2 . widget . PageTransformerAdapter ( mLayoutManager ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( mPageTransformerAdapter ) ; attachViewToParent ( mRecyclerView , <NUM_LIT> , mRecyclerView . getLayoutParams ( ) ) ; } private RecyclerView . OnChildAttachStateChangeListener enforceChildFillListener ( ) { return new RecyclerView . OnChildAttachStateChangeListener ( ) { @ Override public void onChildViewAttachedToWindow ( @ NonNull View view ) { RecyclerView . LayoutParams layoutParams = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( layoutParams . width != LayoutParams . MATCH_PARENT || layoutParams . height != LayoutParams . MATCH_PARENT ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } @ Override public void onChildViewDetachedFromWindow ( @ NonNull View view ) { } } ; } @ RequiresApi ( <NUM_LIT> ) @ Override public CharSequence getAccessibilityClassName ( ) { if ( mAccessibilityProvider . handlesGetAccessibilityClassName ( ) ) { return mAccessibilityProvider . onGetAccessibilityClassName ( ) ; } return super . getAccessibilityClassName ( ) ; } private void setOrientation ( Context context , AttributeSet attrs ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . ViewPager2 ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , R . styleable . ViewPager2 , attrs , a , <NUM_LIT> , <NUM_LIT> ) ; try { setOrientation ( a . getInt ( R . styleable . ViewPager2_android_orientation , ORIENTATION_HORIZONTAL ) ) ; } finally { a . recycle ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable @ Override protected Parcelable onSaveInstanceState ( ) { Parcelable superState = super . onSaveInstanceState ( ) ; SavedState ss = new SavedState ( superState ) ; ss . mRecyclerViewId = mRecyclerView . getId ( ) ; ss . mCurrentItem = mPendingCurrentItem == NO_POSITION ? mCurrentItem : mPendingCurrentItem ; if ( mPendingAdapterState != null ) { ss . mAdapterState = mPendingAdapterState ; } else { Adapter < ? > adapter = mRecyclerView . getAdapter ( ) ; if ( adapter instanceof StatefulAdapter ) { ss . mAdapterState = ( ( StatefulAdapter ) adapter ) . saveState ( ) ; } } return ss ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( ! ( state instanceof SavedState ) ) { super . onRestoreInstanceState ( state ) ; return ; } SavedState ss = ( SavedState ) state ; super . onRestoreInstanceState ( ss . getSuperState ( ) ) ; mPendingCurrentItem = ss . mCurrentItem ; mPendingAdapterState = ss . mAdapterState ; } private void restorePendingState ( ) { if ( mPendingCurrentItem == NO_POSITION ) { return ; } Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { return ; } if ( mPendingAdapterState != null ) { if ( adapter instanceof StatefulAdapter ) { ( ( StatefulAdapter ) adapter ) . restoreState ( mPendingAdapterState ) ; } mPendingAdapterState = null ; } mCurrentItem = Math . max ( <NUM_LIT> , Math . min ( mPendingCurrentItem , adapter . getItemCount ( ) - <NUM_LIT> ) ) ; mPendingCurrentItem = NO_POSITION ; mRecyclerView . scrollToPosition ( mCurrentItem ) ; mAccessibilityProvider . onRestorePendingState ( ) ; } @ Override protected void dispatchRestoreInstanceState ( SparseArray < Parcelable > container ) { Parcelable state = container . get ( getId ( ) ) ; if ( state instanceof SavedState ) { final int previousRvId = ( ( SavedState ) state ) . mRecyclerViewId ; final int currentRvId = mRecyclerView . getId ( ) ; container . put ( currentRvId , container . get ( previousRvId ) ) ; container . remove ( previousRvId ) ; } super . dispatchRestoreInstanceState ( container ) ; restorePendingState ( ) ; } private void registerCurrentItemDataSetTracker ( @ Nullable Adapter < ? > adapter ) { if ( adapter != null ) { adapter . registerAdapterDataObserver ( mCurrentItemDataSetChangeObserver ) ; } } private void unregisterCurrentItemDataSetTracker ( @ Nullable Adapter < ? > adapter ) { if ( adapter != null ) { adapter . unregisterAdapterDataObserver ( mCurrentItemDataSetChangeObserver ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public @ Nullable Adapter getAdapter ( ) { return mRecyclerView . getAdapter ( ) ; } public void setAdapter ( @ Nullable @ SuppressWarnings ( "<STR_LIT>" ) Adapter adapter ) { final Adapter < ? > currentAdapter = mRecyclerView . getAdapter ( ) ; mAccessibilityProvider . onDetachAdapter ( currentAdapter ) ; unregisterCurrentItemDataSetTracker ( currentAdapter ) ; mRecyclerView . setAdapter ( adapter ) ; mCurrentItem = <NUM_LIT> ; restorePendingState ( ) ; mAccessibilityProvider . onAttachAdapter ( adapter ) ; registerCurrentItemDataSetTracker ( adapter ) ; } @ Override public void onViewAdded ( View child ) { throw new IllegalStateException ( getClass ( ) . getSimpleName ( ) + "<STR_LIT>" ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { measureChild ( mRecyclerView , widthMeasureSpec , heightMeasureSpec ) ; int width = mRecyclerView . getMeasuredWidth ( ) ; int height = mRecyclerView . getMeasuredHeight ( ) ; int childState = mRecyclerView . getMeasuredState ( ) ; width += getPaddingLeft ( ) + getPaddingRight ( ) ; height += getPaddingTop ( ) + getPaddingBottom ( ) ; width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; height = Math . max ( height , getSuggestedMinimumHeight ( ) ) ; setMeasuredDimension ( resolveSizeAndState ( width , widthMeasureSpec , childState ) , resolveSizeAndState ( height , heightMeasureSpec , childState << MEASURED_HEIGHT_STATE_SHIFT ) ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { int width = mRecyclerView . getMeasuredWidth ( ) ; int height = mRecyclerView . getMeasuredHeight ( ) ; mTmpContainerRect . left = getPaddingLeft ( ) ; mTmpContainerRect . right = r - l - getPaddingRight ( ) ; mTmpContainerRect . top = getPaddingTop ( ) ; mTmpContainerRect . bottom = b - t - getPaddingBottom ( ) ; Gravity . apply ( Gravity . TOP | Gravity . START , width , height , mTmpContainerRect , mTmpChildRect ) ; mRecyclerView . layout ( mTmpChildRect . left , mTmpChildRect . top , mTmpChildRect . right , mTmpChildRect . bottom ) ; if ( mCurrentItemDirty ) { updateCurrentItem ( ) ; } } void updateCurrentItem ( ) { if ( mPagerSnapHelper == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } View snapView = mPagerSnapHelper . findSnapView ( mLayoutManager ) ; if ( snapView == null ) { return ; } int snapPosition = mLayoutManager . getPosition ( snapView ) ; if ( snapPosition != mCurrentItem && getScrollState ( ) == SCROLL_STATE_IDLE ) { mPageChangeEventDispatcher . onPageSelected ( snapPosition ) ; } mCurrentItemDirty = false ; } int getPageSize ( ) { final RecyclerView rv = mRecyclerView ; return getOrientation ( ) == ORIENTATION_HORIZONTAL ? rv . getWidth ( ) - rv . getPaddingLeft ( ) - rv . getPaddingRight ( ) : rv . getHeight ( ) - rv . getPaddingTop ( ) - rv . getPaddingBottom ( ) ; } public @ Orientation int getOrientation ( ) { return mLayoutManager . getOrientation ( ) == LinearLayoutManager . VERTICAL ? ViewPager2 . ORIENTATION_VERTICAL : ViewPager2 . ORIENTATION_HORIZONTAL ; } public void setOrientation ( @ Orientation int orientation ) { mLayoutManager . setOrientation ( orientation ) ; mAccessibilityProvider . onSetOrientation ( ) ; } boolean isRtl ( ) { return mLayoutManager . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; } public void setCurrentItem ( int item , boolean smoothScroll ) { if ( isFakeDragging ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } setCurrentItemInternal ( item , smoothScroll ) ; } void setCurrentItemInternal ( int item , boolean smoothScroll ) { Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { if ( mPendingCurrentItem != NO_POSITION ) { mPendingCurrentItem = Math . max ( item , <NUM_LIT> ) ; } return ; } if ( adapter . getItemCount ( ) <= <NUM_LIT> ) { return ; } item = Math . max ( item , <NUM_LIT> ) ; item = Math . min ( item , adapter . getItemCount ( ) - <NUM_LIT> ) ; if ( item == mCurrentItem && mScrollEventAdapter . isIdle ( ) ) { return ; } if ( item == mCurrentItem && smoothScroll ) { return ; } double previousItem = mCurrentItem ; mCurrentItem = item ; mAccessibilityProvider . onSetNewCurrentItem ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { previousItem = mScrollEventAdapter . getRelativeScrollPosition ( ) ; } mScrollEventAdapter . notifyProgrammaticScroll ( item , smoothScroll ) ; if ( ! smoothScroll ) { mRecyclerView . scrollToPosition ( item ) ; return ; } if ( Math . abs ( item - previousItem ) > <NUM_LIT> ) { mRecyclerView . scrollToPosition ( item > previousItem ? item - <NUM_LIT> : item + <NUM_LIT> ) ; mRecyclerView . post ( new SmoothScrollToPosition ( item , mRecyclerView ) ) ; } else { mRecyclerView . smoothScrollToPosition ( item ) ; } } public int getCurrentItem ( ) { return mCurrentItem ; } public void setCurrentItem ( int item ) { setCurrentItem ( item , true ) ; } @ ScrollState public int getScrollState ( ) { return mScrollEventAdapter . getScrollState ( ) ; } public boolean beginFakeDrag ( ) { return mFakeDragger . beginFakeDrag ( ) ; } public boolean fakeDragBy ( @ SuppressLint ( "<STR_LIT>" ) @ Px float offsetPxFloat ) { return mFakeDragger . fakeDragBy ( offsetPxFloat ) ; } public boolean endFakeDrag ( ) { return mFakeDragger . endFakeDrag ( ) ; } public boolean isFakeDragging ( ) { return mFakeDragger . isFakeDragging ( ) ; } void snapToPage ( ) { View view = mPagerSnapHelper . findSnapView ( mLayoutManager ) ; if ( view == null ) { return ; } int [ ] snapDistance = mPagerSnapHelper . calculateDistanceToFinalSnap ( mLayoutManager , view ) ; TimeInterpolator interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , com . google . android . material . R . attr . motionEasingStandardInterpolator , new FastOutSlowInInterpolator ( ) ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] , ( Interpolator ) interpolator ) ; } } public boolean isUserInputEnabled ( ) { return mUserInputEnabled ; } public void setUserInputEnabled ( boolean enabled ) { mUserInputEnabled = enabled ; mAccessibilityProvider . onSetUserInputEnabled ( ) ; } @ OffscreenPageLimit public int getOffscreenPageLimit ( ) { return mOffscreenPageLimit ; } public void setOffscreenPageLimit ( @ OffscreenPageLimit int limit ) { if ( limit < <NUM_LIT> && limit != OFFSCREEN_PAGE_LIMIT_DEFAULT ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOffscreenPageLimit = limit ; mRecyclerView . requestLayout ( ) ; } @ Override public boolean canScrollHorizontally ( int direction ) { return mRecyclerView . canScrollHorizontally ( direction ) ; } @ Override public boolean canScrollVertically ( int direction ) { return mRecyclerView . canScrollVertically ( direction ) ; } public void registerOnPageChangeCallback ( @ NonNull OnPageChangeCallback callback ) { mExternalPageChangeCallbacks . addOnPageChangeCallback ( callback ) ; } public void unregisterOnPageChangeCallback ( @ NonNull OnPageChangeCallback callback ) { mExternalPageChangeCallbacks . removeOnPageChangeCallback ( callback ) ; } public void setPageTransformer ( @ Nullable PageTransformer transformer ) { if ( transformer != null ) { if ( ! mSavedItemAnimatorPresent ) { mSavedItemAnimator = mRecyclerView . getItemAnimator ( ) ; mSavedItemAnimatorPresent = true ; } mRecyclerView . setItemAnimator ( null ) ; } else { if ( mSavedItemAnimatorPresent ) { mRecyclerView . setItemAnimator ( mSavedItemAnimator ) ; mSavedItemAnimator = null ; mSavedItemAnimatorPresent = false ; } } if ( transformer == mPageTransformerAdapter . getPageTransformer ( ) ) { return ; } mPageTransformerAdapter . setPageTransformer ( transformer ) ; requestTransform ( ) ; } public void requestTransform ( ) { if ( mPageTransformerAdapter . getPageTransformer ( ) == null ) { return ; } double relativePosition = mScrollEventAdapter . getRelativeScrollPosition ( ) ; int position = ( int ) relativePosition ; float positionOffset = ( float ) ( relativePosition - position ) ; int positionOffsetPx = Math . round ( getPageSize ( ) * positionOffset ) ; mPageTransformerAdapter . onPageScrolled ( position , positionOffset , positionOffsetPx ) ; } @ Override public void setLayoutDirection ( int layoutDirection ) { super . setLayoutDirection ( layoutDirection ) ; mAccessibilityProvider . onSetLayoutDirection ( ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { super . onInitializeAccessibilityNodeInfo ( info ) ; mAccessibilityProvider . onInitializeAccessibilityNodeInfo ( info ) ; } @ Override public boolean performAccessibilityAction ( int action , @ Nullable Bundle arguments ) { if ( mAccessibilityProvider . handlesPerformAccessibilityAction ( action , arguments ) ) { return mAccessibilityProvider . onPerformAccessibilityAction ( action , arguments ) ; } return super . performAccessibilityAction ( action , arguments ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor ) { mRecyclerView . addItemDecoration ( decor ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { mRecyclerView . addItemDecoration ( decor , index ) ; } @ NonNull public ItemDecoration getItemDecorationAt ( int index ) { return mRecyclerView . getItemDecorationAt ( index ) ; } public int getItemDecorationCount ( ) { return mRecyclerView . getItemDecorationCount ( ) ; } public void invalidateItemDecorations ( ) { mRecyclerView . invalidateItemDecorations ( ) ; } public void removeItemDecorationAt ( int index ) { mRecyclerView . removeItemDecorationAt ( index ) ; } public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { mRecyclerView . removeItemDecoration ( decor ) ; } @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { ORIENTATION_HORIZONTAL , ORIENTATION_VERTICAL } ) public @ interface Orientation { } @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { SCROLL_STATE_IDLE , SCROLL_STATE_DRAGGING , SCROLL_STATE_SETTLING } ) public @ interface ScrollState { } @ SuppressWarnings ( "<STR_LIT>" ) @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { OFFSCREEN_PAGE_LIMIT_DEFAULT } ) @ IntRange ( from = <NUM_LIT> ) public @ interface OffscreenPageLimit { } public interface PageTransformer { void transformPage ( @ NonNull View page , float position ) ; } static class SavedState extends BaseSavedState { public static final Creator < SavedState > CREATOR = new ClassLoaderCreator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel source , ClassLoader loader ) { return Build . VERSION . SDK_INT >= <NUM_LIT> ? new SavedState ( source , loader ) : new SavedState ( source ) ; } @ Override public SavedState createFromParcel ( Parcel source ) { return createFromParcel ( source , null ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; int mRecyclerViewId ; int mCurrentItem ; Parcelable mAdapterState ; @ RequiresApi ( <NUM_LIT> ) @ SuppressLint ( "<STR_LIT>" ) SavedState ( Parcel source , ClassLoader loader ) { super ( source , loader ) ; readValues ( source , loader ) ; } SavedState ( Parcel source ) { super ( source ) ; readValues ( source , null ) ; } SavedState ( Parcelable superState ) { super ( superState ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void readValues ( Parcel source , ClassLoader loader ) { mRecyclerViewId = source . readInt ( ) ; mCurrentItem = source . readInt ( ) ; mAdapterState = source . readParcelable ( loader ) ; } @ Override public void writeToParcel ( Parcel out , int flags ) { super . writeToParcel ( out , flags ) ; out . writeInt ( mRecyclerViewId ) ; out . writeInt ( mCurrentItem ) ; out . writeParcelable ( mAdapterState , flags ) ; } } private static class SmoothScrollToPosition implements Runnable { private final int mPosition ; private final RecyclerView mRecyclerView ; SmoothScrollToPosition ( int position , RecyclerView recyclerView ) { mPosition = position ; mRecyclerView = recyclerView ; } @ Override public void run ( ) { mRecyclerView . smoothScrollToPosition ( mPosition ) ; } } public abstract static class OnPageChangeCallback { public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { } public void onPageSelected ( int position ) { } public void onPageScrollStateChanged ( @ ScrollState int state ) { } } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } private class RecyclerViewImpl extends RecyclerView { RecyclerViewImpl ( @ NonNull Context context ) { super ( context ) ; } @ RequiresApi ( <NUM_LIT> ) @ Override public CharSequence getAccessibilityClassName ( ) { if ( mAccessibilityProvider . handlesRvGetAccessibilityClassName ( ) ) { return mAccessibilityProvider . onRvGetAccessibilityClassName ( ) ; } return super . getAccessibilityClassName ( ) ; } @ Override public void onInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; event . setFromIndex ( mCurrentItem ) ; event . setToIndex ( mCurrentItem ) ; mAccessibilityProvider . onRvInitializeAccessibilityEvent ( event ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onTouchEvent ( MotionEvent event ) { return isUserInputEnabled ( ) && super . onTouchEvent ( event ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { return isUserInputEnabled ( ) && super . onInterceptTouchEvent ( ev ) ; } } private class LinearLayoutManagerImpl extends LinearLayoutManager { LinearLayoutManagerImpl ( Context context ) { super ( context ) ; } @ Override public boolean performAccessibilityAction ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , int action , @ Nullable Bundle args ) { if ( mAccessibilityProvider . handlesLmPerformAccessibilityAction ( action ) ) { return mAccessibilityProvider . onLmPerformAccessibilityAction ( action ) ; } return super . performAccessibilityAction ( recycler , state , action , args ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( recycler , state , info ) ; mAccessibilityProvider . onLmInitializeAccessibilityNodeInfo ( info ) ; } @ Override public void onInitializeAccessibilityNodeInfoForItem ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { mAccessibilityProvider . onLmInitializeAccessibilityNodeInfoForItem ( host , info ) ; } @ Override protected void calculateExtraLayoutSpace ( @ NonNull RecyclerView . State state , @ NonNull int [ ] extraLayoutSpace ) { int pageLimit = getOffscreenPageLimit ( ) ; if ( pageLimit == OFFSCREEN_PAGE_LIMIT_DEFAULT ) { super . calculateExtraLayoutSpace ( state , extraLayoutSpace ) ; return ; } final int offscreenSpace = getPageSize ( ) * pageLimit ; extraLayoutSpace [ <NUM_LIT> ] = offscreenSpace ; extraLayoutSpace [ <NUM_LIT> ] = offscreenSpace ; } @ Override public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate , boolean focusedChildVisible ) { return false ; } } private class PagerSnapHelperImpl extends PagerSnapHelper { PagerSnapHelperImpl ( ) { } @ Nullable @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { return isFakeDragging ( ) ? null : super . findSnapView ( layoutManager ) ; } } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) private abstract class AccessibilityProvider { void onInitialize ( @ NonNull CompositeOnPageChangeCallback pageChangeEventDispatcher , @ NonNull RecyclerView recyclerView ) { } boolean handlesGetAccessibilityClassName ( ) { return false ; } String onGetAccessibilityClassName ( ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onRestorePendingState ( ) { } void onAttachAdapter ( @ Nullable Adapter < ? > newAdapter ) { } void onDetachAdapter ( @ Nullable Adapter < ? > oldAdapter ) { } void onSetOrientation ( ) { } void onSetNewCurrentItem ( ) { } void onSetUserInputEnabled ( ) { } void onSetLayoutDirection ( ) { } void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { } boolean handlesPerformAccessibilityAction ( int action , Bundle arguments ) { return false ; } boolean onPerformAccessibilityAction ( int action , Bundle arguments ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onRvInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { } boolean handlesLmPerformAccessibilityAction ( int action ) { return false ; } boolean onLmPerformAccessibilityAction ( int action ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onLmInitializeAccessibilityNodeInfo ( @ NonNull AccessibilityNodeInfoCompat info ) { } void onLmInitializeAccessibilityNodeInfoForItem ( @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { } boolean handlesRvGetAccessibilityClassName ( ) { return false ; } CharSequence onRvGetAccessibilityClassName ( ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } class BasicAccessibilityProvider extends AccessibilityProvider { @ Override public boolean handlesLmPerformAccessibilityAction ( int action ) { return ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD || action == AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) && ! isUserInputEnabled ( ) ; } @ Override public boolean onLmPerformAccessibilityAction ( int action ) { if ( ! handlesLmPerformAccessibilityAction ( action ) ) { throw new IllegalStateException ( ) ; } return false ; } @ Override public void onLmInitializeAccessibilityNodeInfo ( @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! isUserInputEnabled ( ) ) { info . removeAction ( AccessibilityActionCompat . ACTION_SCROLL_BACKWARD ) ; info . removeAction ( AccessibilityActionCompat . ACTION_SCROLL_FORWARD ) ; info . setScrollable ( false ) ; } } @ Override public boolean handlesRvGetAccessibilityClassName ( ) { return true ; } @ Override public CharSequence onRvGetAccessibilityClassName ( ) { if ( ! handlesRvGetAccessibilityClassName ( ) ) { throw new IllegalStateException ( ) ; } return "<STR_LIT>" ; } } class PageAwareAccessibilityProvider extends AccessibilityProvider { private final AccessibilityViewCommand mActionPageForward = new AccessibilityViewCommand ( ) { @ Override public boolean perform ( @ NonNull View view , @ Nullable CommandArguments arguments ) { ViewPager2 viewPager = ( ViewPager2 ) view ; setCurrentItemFromAccessibilityCommand ( viewPager . getCurrentItem ( ) + <NUM_LIT> ) ; return true ; } } ; private final AccessibilityViewCommand mActionPageBackward = new AccessibilityViewCommand ( ) { @ Override public boolean perform ( @ NonNull View view , @ Nullable CommandArguments arguments ) { ViewPager2 viewPager = ( ViewPager2 ) view ; setCurrentItemFromAccessibilityCommand ( viewPager . getCurrentItem ( ) - <NUM_LIT> ) ; return true ; } } ; private RecyclerView . AdapterDataObserver mAdapterDataObserver ; @ Override public void onInitialize ( @ NonNull CompositeOnPageChangeCallback pageChangeEventDispatcher , @ NonNull RecyclerView recyclerView ) { recyclerView . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_NO ) ; mAdapterDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updatePageAccessibilityActions ( ) ; } } ; if ( ViewPager2 . this . getImportantForAccessibility ( ) == View . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewPager2 . this . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } } @ Override public boolean handlesGetAccessibilityClassName ( ) { return true ; } @ Override public String onGetAccessibilityClassName ( ) { if ( ! handlesGetAccessibilityClassName ( ) ) { throw new IllegalStateException ( ) ; } return "<STR_LIT>" ; } @ Override public void onRestorePendingState ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onAttachAdapter ( @ Nullable Adapter < ? > newAdapter ) { updatePageAccessibilityActions ( ) ; if ( newAdapter != null ) { newAdapter . registerAdapterDataObserver ( mAdapterDataObserver ) ; } } @ Override public void onDetachAdapter ( @ Nullable Adapter < ? > oldAdapter ) { if ( oldAdapter != null ) { oldAdapter . unregisterAdapterDataObserver ( mAdapterDataObserver ) ; } } @ Override public void onSetOrientation ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onSetNewCurrentItem ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onSetUserInputEnabled ( ) { updatePageAccessibilityActions ( ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { sendAccessibilityEvent ( AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED ) ; } } @ Override public void onSetLayoutDirection ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { AccessibilityNodeInfoCompat infoCompat = AccessibilityNodeInfoCompat . wrap ( info ) ; addCollectionInfo ( infoCompat ) ; addScrollActions ( infoCompat ) ; } @ Override void onLmInitializeAccessibilityNodeInfoForItem ( @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { addCollectionItemInfo ( host , info ) ; } @ Override public boolean handlesPerformAccessibilityAction ( int action , Bundle arguments ) { return action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD || action == AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ; } @ Override public boolean onPerformAccessibilityAction ( int action , Bundle arguments ) { if ( ! handlesPerformAccessibilityAction ( action , arguments ) ) { throw new IllegalStateException ( ) ; } int nextItem = ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ? getCurrentItem ( ) - <NUM_LIT> : getCurrentItem ( ) + <NUM_LIT> ; setCurrentItemFromAccessibilityCommand ( nextItem ) ; return true ; } @ Override public void onRvInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { event . setSource ( ViewPager2 . this ) ; event . setClassName ( onGetAccessibilityClassName ( ) ) ; } void setCurrentItemFromAccessibilityCommand ( int item ) { if ( isUserInputEnabled ( ) ) { setCurrentItemInternal ( item , true ) ; } } void updatePageAccessibilityActions ( ) { ViewPager2 viewPager = ViewPager2 . this ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageLeft = android . R . id . accessibilityActionPageLeft ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageRight = android . R . id . accessibilityActionPageRight ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageUp = android . R . id . accessibilityActionPageUp ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageDown = android . R . id . accessibilityActionPageDown ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageLeft ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageRight ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageUp ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageDown ) ; if ( getAdapter ( ) == null ) { return ; } int itemCount = getAdapter ( ) . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return ; } if ( ! isUserInputEnabled ( ) ) { return ; } if ( getOrientation ( ) == ORIENTATION_HORIZONTAL ) { boolean isLayoutRtl = isRtl ( ) ; int actionIdPageForward = isLayoutRtl ? actionIdPageLeft : actionIdPageRight ; int actionIdPageBackward = isLayoutRtl ? actionIdPageRight : actionIdPageLeft ; if ( mCurrentItem < itemCount - <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageForward , null ) , null , mActionPageForward ) ; } if ( mCurrentItem > <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageBackward , null ) , null , mActionPageBackward ) ; } } else { if ( mCurrentItem < itemCount - <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageDown , null ) , null , mActionPageForward ) ; } if ( mCurrentItem > <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageUp , null ) , null , mActionPageBackward ) ; } } } private void addCollectionInfo ( AccessibilityNodeInfoCompat infoCompat ) { int rowCount = <NUM_LIT> ; int colCount = <NUM_LIT> ; if ( getAdapter ( ) != null ) { if ( getOrientation ( ) == ORIENTATION_VERTICAL ) { rowCount = getAdapter ( ) . getItemCount ( ) ; colCount = <NUM_LIT> ; } else { colCount = getAdapter ( ) . getItemCount ( ) ; rowCount = <NUM_LIT> ; } } AccessibilityNodeInfoCompat . CollectionInfoCompat collectionInfo = AccessibilityNodeInfoCompat . CollectionInfoCompat . obtain ( rowCount , colCount , false , AccessibilityNodeInfoCompat . CollectionInfoCompat . SELECTION_MODE_NONE ) ; infoCompat . setCollectionInfo ( collectionInfo ) ; } private void addCollectionItemInfo ( View host , AccessibilityNodeInfoCompat infoCompat ) { int rowIndex = ( getOrientation ( ) == ORIENTATION_VERTICAL ) ? mLayoutManager . getPosition ( host ) : <NUM_LIT> ; int colIndex = ( getOrientation ( ) == ORIENTATION_HORIZONTAL ) ? mLayoutManager . getPosition ( host ) : <NUM_LIT> ; AccessibilityNodeInfoCompat . CollectionItemInfoCompat collectionItemInfoCompat = AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( rowIndex , <NUM_LIT> , colIndex , <NUM_LIT> , false , false ) ; infoCompat . setCollectionItemInfo ( collectionItemInfoCompat ) ; } private void addScrollActions ( AccessibilityNodeInfoCompat infoCompat ) { final Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { return ; } int itemCount = adapter . getItemCount ( ) ; if ( itemCount == <NUM_LIT> || ! isUserInputEnabled ( ) ) { return ; } if ( mCurrentItem > <NUM_LIT> ) { infoCompat . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; } if ( mCurrentItem < itemCount - <NUM_LIT> ) { infoCompat . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; } infoCompat . setScrollable ( true ) ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) { mViewPager . snapToPage ( ) ; } return true ; } private void beginFakeVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; final ViewConfiguration configuration = ViewConfiguration . get ( mViewPager . getContext ( ) ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void addFakeMotionEvent ( long time , int action , float x , float y ) { final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , action , x , y , <NUM_LIT> ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( String . format ( Locale . US , "<STR_LIT>" , i , mLayoutManager . getChildCount ( ) ) ) ; } int currPos = mLayoutManager . getPosition ( view ) ; float viewOffset = transformOffset + ( currPos - position ) ; mPageTransformer . transformPage ( view , viewOffset ) ; } } @ Override public void onPageSelected ( int position ) { } @ Override public void onPageScrollStateChanged ( int state ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup { private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ; @ Override public long localToGlobal ( long localId ) { Long globalId = mLocalToGlobalLookup . get ( localId ) ; if ( globalId == null ) { globalId = obtainId ( ) ; mLocalToGlobalLookup . put ( localId , globalId ) ; } return globalId ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollNestedScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollNestedScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) protected int computeVerticalScrollRange ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollRange ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) protected int computeVerticalScrollOffset ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollNestedScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollNestedScrollView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_text_size ) ) ; } ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( "<STR_LIT>" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( "<STR_LIT>" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } } mBackgroundThreadExecutor = sDiffExecutor ; } return new AsyncDifferConfig < > ( mMainThreadExecutor , mBackgroundThreadExecutor , mDiffCallback ) ; } private static final Object sExecutorLock = new Object ( ) ; private static Executor sDiffExecutor = null ; } } </s>
<s> package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( "<STR_LIT>" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( "<STR_LIT>" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( "<STR_LIT>" + mArtists + "<STR_LIT>" + mAlbums + "<STR_LIT>" + mSongs + "<STR_LIT>" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( "<STR_LIT>" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void addAlbum ( ) { try { new File ( "<STR_LIT>" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( "<STR_LIT>" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = "<STR_LIT>" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , "<STR_LIT>" + albumName + "<STR_LIT>" + artist + "<STR_LIT>" + i + "<STR_LIT>" ) ; File file = new File ( "<STR_LIT>" + albumName + "<STR_LIT>" + artist + "<STR_LIT>" + i + "<STR_LIT>" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + "<STR_LIT>" + getRandomWord ( <NUM_LIT> ) + "<STR_LIT>" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ; mBuilder . setLength ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { mBuilder . append ( elements [ mRandom . nextInt ( max ) ] ) ; } char c = mBuilder . charAt ( <NUM_LIT> ) ; c = Character . toUpperCase ( c ) ; mBuilder . setCharAt ( <NUM_LIT> , c ) ; return mBuilder . toString ( ) ; } private String getRandomName ( ) { boolean longfirst = mRandom . nextInt ( <NUM_LIT> ) < <NUM_LIT> ; String first = getRandomWord ( longfirst ? <NUM_LIT> : <NUM_LIT> ) ; String last = getRandomWord ( <NUM_LIT> ) ; switch ( mRandom . nextInt ( <NUM_LIT> ) ) { case <NUM_LIT> : if ( ! last . startsWith ( "<STR_LIT>" ) ) { last = "<STR_LIT>" + last ; } break ; case <NUM_LIT> : last = "<STR_LIT>" + last ; break ; case <NUM_LIT> : last = "<STR_LIT>" + last ; break ; } return first + "<STR_LIT>" + last ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import static androidx . annotation . RestrictTo . Scope . LIBRARY_GROUP_PREFIX ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . core . view . ViewCompat . TYPE_NON_TOUCH ; import static androidx . core . view . ViewCompat . TYPE_TOUCH ; import android . animation . LayoutTransition ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . database . Observable ; import android . graphics . Canvas ; import android . graphics . Matrix ; import android . graphics . PointF ; import android . graphics . Rect ; import android . graphics . RectF ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . hardware . SensorManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . util . Log ; import android . util . SparseArray ; import android . view . Display ; import android . view . FocusFinder ; import android . view . InputDevice ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityManager ; import android . view . animation . Interpolator ; import android . widget . EdgeEffect ; import android . widget . LinearLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . Px ; import androidx . annotation . RestrictTo ; import androidx . annotation . VisibleForTesting ; import androidx . core . os . TraceCompat ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . InputDeviceCompat ; import androidx . core . view . MotionEventCompat ; import androidx . core . view . NestedScrollingChild2 ; import androidx . core . view . NestedScrollingChild3 ; import androidx . core . view . NestedScrollingChildHelper ; import androidx . core . view . ScrollingView ; import androidx . core . view . ViewCompat ; import androidx . core . view . ViewConfigurationCompat ; import androidx . core . view . accessibility . AccessibilityEventCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . customview . poolingcontainer . PoolingContainer ; import androidx . customview . poolingcontainer . PoolingContainerListener ; import androidx . customview . view . AbsSavedState ; import androidx . fluidrecyclerview . R ; import androidx . fluidrecyclerview . widget . RecyclerView . ItemAnimator . ItemHolderInfo ; import org . helixform . fluidrecyclerview . EdgeEffectAdapter ; import org . helixform . fluidrecyclerview . OverScrollerAdapter ; import org . helixform . fluidrecyclerview . VelocityTracker ; import org . helixform . fluidrecyclerview . VelocityTrackerFactory ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . ref . WeakReference ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Set ; public class RecyclerView extends ViewGroup implements ScrollingView , NestedScrollingChild2 , NestedScrollingChild3 { static final String TAG = "<STR_LIT>" ; static boolean sDebugAssertionsEnabled = false ; static boolean sVerboseLoggingEnabled = false ; static final boolean VERBOSE_TRACING = false ; private static final int [ ] NESTED_SCROLLING_ATTRS = { <NUM_LIT> } ; private static final float SCROLL_FRICTION = <NUM_LIT> ; private static final float INFLEXION = <NUM_LIT> ; private static final float DECELERATION_RATE = ( float ) ( Math . log ( <NUM_LIT> ) / Math . log ( <NUM_LIT> ) ) ; private final float mPhysicalCoef ; static final boolean FORCE_INVALIDATE_DISPLAY_LIST = Build . VERSION . SDK_INT == <NUM_LIT> || Build . VERSION . SDK_INT == <NUM_LIT> || Build . VERSION . SDK_INT == <NUM_LIT> ; static final boolean ALLOW_SIZE_IN_UNSPECIFIED_SPEC = Build . VERSION . SDK_INT >= <NUM_LIT> ; static final boolean POST_UPDATES_ON_ANIMATION = Build . VERSION . SDK_INT >= <NUM_LIT> ; static final boolean ALLOW_THREAD_GAP_WORK = Build . VERSION . SDK_INT >= <NUM_LIT> ; private static final boolean FORCE_ABS_FOCUS_SEARCH_DIRECTION = Build . VERSION . SDK_INT <= <NUM_LIT> ; private static final boolean IGNORE_DETACHED_FOCUSED_CHILD = Build . VERSION . SDK_INT <= <NUM_LIT> ; private static final float FLING_DESTRETCH_FACTOR = <NUM_LIT> ; static final boolean DISPATCH_TEMP_DETACH = false ; @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ IntDef ( { HORIZONTAL , VERTICAL } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface Orientation { } public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; static final int DEFAULT_ORIENTATION = VERTICAL ; public static final int NO_POSITION = - <NUM_LIT> ; public static final long NO_ID = - <NUM_LIT> ; public static final int INVALID_TYPE = - <NUM_LIT> ; public static final int TOUCH_SLOP_DEFAULT = <NUM_LIT> ; public static final int TOUCH_SLOP_PAGING = <NUM_LIT> ; public static final int UNDEFINED_DURATION = Integer . MIN_VALUE ; static final int MAX_SCROLL_DURATION = <NUM_LIT> ; static final String TRACE_SCROLL_TAG = "<STR_LIT>" ; private static final String TRACE_ON_LAYOUT_TAG = "<STR_LIT>" ; private static final String TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG = "<STR_LIT>" ; private static final String TRACE_HANDLE_ADAPTER_UPDATES_TAG = "<STR_LIT>" ; static final String TRACE_BIND_VIEW_TAG = "<STR_LIT>" ; static final String TRACE_PREFETCH_TAG = "<STR_LIT>" ; static final String TRACE_NESTED_PREFETCH_TAG = "<STR_LIT>" ; static final String TRACE_CREATE_VIEW_TAG = "<STR_LIT>" ; private static final Class < ? > [ ] LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE = new Class < ? > [ ] { Context . class , AttributeSet . class , int . class , int . class } ; public static void setDebugAssertionsEnabled ( boolean debugAssertionsEnabled ) { RecyclerView . sDebugAssertionsEnabled = debugAssertionsEnabled ; } public static void setVerboseLoggingEnabled ( boolean verboseLoggingEnabled ) { RecyclerView . sVerboseLoggingEnabled = verboseLoggingEnabled ; } private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver ( ) ; final Recycler mRecycler = new Recycler ( ) ; SavedState mPendingSavedState ; AdapterHelper mAdapterHelper ; ChildHelper mChildHelper ; final ViewInfoStore mViewInfoStore = new ViewInfoStore ( ) ; boolean mClipToPadding ; final Runnable mUpdateChildViewsRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( ! mFirstLayoutComplete || isLayoutRequested ( ) ) { return ; } if ( ! mIsAttached ) { requestLayout ( ) ; return ; } if ( mLayoutSuppressed ) { mLayoutWasDefered = true ; return ; } consumePendingUpdateOperations ( ) ; } } ; final Rect mTempRect = new Rect ( ) ; private final Rect mTempRect2 = new Rect ( ) ; final RectF mTempRectF = new RectF ( ) ; Adapter mAdapter ; @ VisibleForTesting LayoutManager mLayout ; RecyclerListener mRecyclerListener ; final List < RecyclerListener > mRecyclerListeners = new ArrayList < > ( ) ; final ArrayList < ItemDecoration > mItemDecorations = new ArrayList < > ( ) ; private final ArrayList < OnItemTouchListener > mOnItemTouchListeners = new ArrayList < > ( ) ; private OnItemTouchListener mInterceptingOnItemTouchListener ; boolean mIsAttached ; boolean mHasFixedSize ; boolean mEnableFastScroller ; @ VisibleForTesting boolean mFirstLayoutComplete ; private int mInterceptRequestLayoutDepth = <NUM_LIT> ; boolean mLayoutWasDefered ; boolean mLayoutSuppressed ; private boolean mIgnoreMotionEventTillDown ; private int mEatenAccessibilityChangeFlags ; boolean mAdapterUpdateDuringMeasure ; private final AccessibilityManager mAccessibilityManager ; private List < OnChildAttachStateChangeListener > mOnChildAttachStateListeners ; boolean mDataSetHasChangedAfterLayout = false ; boolean mDispatchItemsChangedEvent = false ; private int mLayoutOrScrollCounter = <NUM_LIT> ; private int mDispatchScrollCounter = <NUM_LIT> ; private EdgeEffectAdapter mHorizontalEdgeEffect , mVerticalEdgeEffect ; ItemAnimator mItemAnimator = new DefaultItemAnimator ( ) ; private static final int INVALID_POINTER = - <NUM_LIT> ; public static final int SCROLL_STATE_IDLE = <NUM_LIT> ; public static final int SCROLL_STATE_DRAGGING = <NUM_LIT> ; public static final int SCROLL_STATE_SETTLING = <NUM_LIT> ; static final long FOREVER_NS = Long . MAX_VALUE ; private int mScrollState = SCROLL_STATE_IDLE ; private int mScrollPointerId = INVALID_POINTER ; private VelocityTracker mVelocityTracker ; private int mInitialTouchX ; private int mInitialTouchY ; private int mLastTouchX ; private int mLastTouchY ; private int mTouchSlop ; private OnFlingListener mOnFlingListener ; private final int mMinFlingVelocity ; private final int mMaxFlingVelocity ; private float mScaledHorizontalScrollFactor = Float . MIN_VALUE ; private float mScaledVerticalScrollFactor = Float . MIN_VALUE ; private boolean mPreserveFocusAfterLayout = true ; final ViewFlinger mViewFlinger = new ViewFlinger ( ) ; GapWorker mGapWorker ; GapWorker . LayoutPrefetchRegistryImpl mPrefetchRegistry = ALLOW_THREAD_GAP_WORK ? new GapWorker . LayoutPrefetchRegistryImpl ( ) : null ; final State mState = new State ( ) ; private OnScrollListener mScrollListener ; private List < OnScrollListener > mScrollListeners ; boolean mItemsAddedOrRemoved = false ; boolean mItemsChanged = false ; private ItemAnimator . ItemAnimatorListener mItemAnimatorListener = new ItemAnimatorRestoreListener ( ) ; boolean mPostedAnimatorRunner = false ; RecyclerViewAccessibilityDelegate mAccessibilityDelegate ; private ChildDrawingOrderCallback mChildDrawingOrderCallback ; private final int [ ] mMinMaxLayoutPositions = new int [ <NUM_LIT> ] ; private NestedScrollingChildHelper mScrollingChildHelper ; private final int [ ] mScrollOffset = new int [ <NUM_LIT> ] ; private final int [ ] mNestedOffsets = new int [ <NUM_LIT> ] ; final int [ ] mReusableIntPair = new int [ <NUM_LIT> ] ; @ VisibleForTesting final List < ViewHolder > mPendingAccessibilityImportanceChange = new ArrayList < > ( ) ; private Runnable mItemAnimatorRunner = new Runnable ( ) { @ Override public void run ( ) { if ( mItemAnimator != null ) { mItemAnimator . runPendingAnimations ( ) ; } mPostedAnimatorRunner = false ; } } ; static final Interpolator sQuinticInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { t -= <NUM_LIT> ; return t * t * t * t * t + <NUM_LIT> ; } } ; private boolean mLastAutoMeasureSkippedDueToExact ; private int mLastAutoMeasureNonExactMeasuredWidth = <NUM_LIT> ; private int mLastAutoMeasureNonExactMeasuredHeight = <NUM_LIT> ; private final ViewInfoStore . ProcessCallback mViewInfoProcessCallback = new ViewInfoStore . ProcessCallback ( ) { @ Override public void processDisappeared ( ViewHolder viewHolder , @ NonNull ItemHolderInfo info , @ Nullable ItemHolderInfo postInfo ) { mRecycler . unscrapView ( viewHolder ) ; animateDisappearance ( viewHolder , info , postInfo ) ; } @ Override public void processAppeared ( ViewHolder viewHolder , ItemHolderInfo preInfo , ItemHolderInfo info ) { animateAppearance ( viewHolder , preInfo , info ) ; } @ Override public void processPersistent ( ViewHolder viewHolder , @ NonNull ItemHolderInfo preInfo , @ NonNull ItemHolderInfo postInfo ) { viewHolder . setIsRecyclable ( false ) ; if ( mDataSetHasChangedAfterLayout ) { if ( mItemAnimator . animateChange ( viewHolder , viewHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } else if ( mItemAnimator . animatePersistence ( viewHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } @ Override public void unused ( ViewHolder viewHolder ) { mLayout . removeAndRecycleView ( viewHolder . itemView , mRecycler ) ; } } ; public RecyclerView ( @ NonNull Context context ) { this ( context , null ) ; } public RecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . recyclerViewStyle ) ; } public RecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; setScrollContainer ( true ) ; setFocusableInTouchMode ( true ) ; final ViewConfiguration vc = ViewConfiguration . get ( context ) ; mTouchSlop = vc . getScaledTouchSlop ( ) ; mScaledHorizontalScrollFactor = ViewConfigurationCompat . getScaledHorizontalScrollFactor ( vc , context ) ; mScaledVerticalScrollFactor = ViewConfigurationCompat . getScaledVerticalScrollFactor ( vc , context ) ; mMinFlingVelocity = vc . getScaledMinimumFlingVelocity ( ) ; mMaxFlingVelocity = vc . getScaledMaximumFlingVelocity ( ) ; final float ppi = context . getResources ( ) . getDisplayMetrics ( ) . density * <NUM_LIT> ; mPhysicalCoef = SensorManager . GRAVITY_EARTH * <NUM_LIT> * ppi * <NUM_LIT> ; setWillNotDraw ( getOverScrollMode ( ) == View . OVER_SCROLL_NEVER ) ; mItemAnimator . setListener ( mItemAnimatorListener ) ; initAdapterManager ( ) ; initChildrenHelper ( ) ; initAutofill ( ) ; if ( ViewCompat . getImportantForAccessibility ( this ) == ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewCompat . setImportantForAccessibility ( this , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } mAccessibilityManager = ( AccessibilityManager ) getContext ( ) . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; setAccessibilityDelegateCompat ( new RecyclerViewAccessibilityDelegate ( this ) ) ; TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . RecyclerView , defStyleAttr , <NUM_LIT> ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , R . styleable . RecyclerView , attrs , a , defStyleAttr , <NUM_LIT> ) ; String layoutManagerName = a . getString ( R . styleable . RecyclerView_layoutManager ) ; int descendantFocusability = a . getInt ( R . styleable . RecyclerView_android_descendantFocusability , - <NUM_LIT> ) ; if ( descendantFocusability == - <NUM_LIT> ) { setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; } mClipToPadding = a . getBoolean ( R . styleable . RecyclerView_android_clipToPadding , true ) ; mEnableFastScroller = a . getBoolean ( R . styleable . RecyclerView_fastScrollEnabled , false ) ; if ( mEnableFastScroller ) { StateListDrawable verticalThumbDrawable = ( StateListDrawable ) a . getDrawable ( R . styleable . RecyclerView_fastScrollVerticalThumbDrawable ) ; Drawable verticalTrackDrawable = a . getDrawable ( R . styleable . RecyclerView_fastScrollVerticalTrackDrawable ) ; StateListDrawable horizontalThumbDrawable = ( StateListDrawable ) a . getDrawable ( R . styleable . RecyclerView_fastScrollHorizontalThumbDrawable ) ; Drawable horizontalTrackDrawable = a . getDrawable ( R . styleable . RecyclerView_fastScrollHorizontalTrackDrawable ) ; initFastScroller ( verticalThumbDrawable , verticalTrackDrawable , horizontalThumbDrawable , horizontalTrackDrawable ) ; } a . recycle ( ) ; createLayoutManager ( context , layoutManagerName , attrs , defStyleAttr , <NUM_LIT> ) ; boolean nestedScrollingEnabled = true ; if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { a = context . obtainStyledAttributes ( attrs , NESTED_SCROLLING_ATTRS , defStyleAttr , <NUM_LIT> ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , NESTED_SCROLLING_ATTRS , attrs , a , defStyleAttr , <NUM_LIT> ) ; nestedScrollingEnabled = a . getBoolean ( <NUM_LIT> , true ) ; a . recycle ( ) ; } setNestedScrollingEnabled ( nestedScrollingEnabled ) ; PoolingContainer . setPoolingContainer ( this , true ) ; } String exceptionLabel ( ) { return "<STR_LIT>" + super . toString ( ) + "<STR_LIT>" + mAdapter + "<STR_LIT>" + mLayout + "<STR_LIT>" + getContext ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void initAutofill ( ) { if ( ViewCompat . getImportantForAutofill ( this ) == View . IMPORTANT_FOR_AUTOFILL_AUTO ) { ViewCompat . setImportantForAutofill ( this , View . IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS ) ; } } @ Nullable public RecyclerViewAccessibilityDelegate getCompatAccessibilityDelegate ( ) { return mAccessibilityDelegate ; } public void setAccessibilityDelegateCompat ( @ Nullable RecyclerViewAccessibilityDelegate accessibilityDelegate ) { mAccessibilityDelegate = accessibilityDelegate ; ViewCompat . setAccessibilityDelegate ( this , mAccessibilityDelegate ) ; } @ Override public CharSequence getAccessibilityClassName ( ) { return "<STR_LIT>" ; } private void createLayoutManager ( Context context , String className , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { if ( className != null ) { className = className . trim ( ) ; if ( ! className . isEmpty ( ) ) { className = getFullClassName ( context , className ) ; try { ClassLoader classLoader ; if ( isInEditMode ( ) ) { classLoader = this . getClass ( ) . getClassLoader ( ) ; } else { classLoader = context . getClassLoader ( ) ; } Class < ? extends LayoutManager > layoutManagerClass = Class . forName ( className , false , classLoader ) . asSubclass ( LayoutManager . class ) ; Constructor < ? extends LayoutManager > constructor ; Object [ ] constructorArgs = null ; try { constructor = layoutManagerClass . getConstructor ( LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE ) ; constructorArgs = new Object [ ] { context , attrs , defStyleAttr , defStyleRes } ; } catch ( NoSuchMethodException e ) { try { constructor = layoutManagerClass . getConstructor ( ) ; } catch ( NoSuchMethodException e1 ) { e1 . initCause ( e ) ; throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e1 ) ; } } constructor . setAccessible ( true ) ; setLayoutManager ( constructor . newInstance ( constructorArgs ) ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( InstantiationException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( ClassCastException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } } } } private String getFullClassName ( Context context , String className ) { if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return context . getPackageName ( ) + className ; } if ( className . contains ( "<STR_LIT>" ) ) { return className ; } return RecyclerView . class . getPackage ( ) . getName ( ) + '<STR_LIT>' + className ; } private void initChildrenHelper ( ) { mChildHelper = new ChildHelper ( new ChildHelper . Callback ( ) { @ Override public int getChildCount ( ) { return RecyclerView . this . getChildCount ( ) ; } @ Override public void addView ( View child , int index ) { if ( VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } RecyclerView . this . addView ( child , index ) ; if ( VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } dispatchChildAttached ( child ) ; } @ Override public int indexOfChild ( View view ) { return RecyclerView . this . indexOfChild ( view ) ; } @ Override public void removeViewAt ( int index ) { final View child = RecyclerView . this . getChildAt ( index ) ; if ( child != null ) { dispatchChildDetached ( child ) ; child . clearAnimation ( ) ; } if ( VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } RecyclerView . this . removeViewAt ( index ) ; if ( VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } } @ Override public View getChildAt ( int offset ) { return RecyclerView . this . getChildAt ( offset ) ; } @ Override public void removeAllViews ( ) { final int count = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View child = getChildAt ( i ) ; dispatchChildDetached ( child ) ; child . clearAnimation ( ) ; } RecyclerView . this . removeAllViews ( ) ; } @ Override public ViewHolder getChildViewHolder ( View view ) { return getChildViewHolderInt ( view ) ; } @ Override public void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { if ( ! vh . isTmpDetached ( ) && ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + vh ) ; } vh . clearTmpDetachFlag ( ) ; } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + "<STR_LIT>" + index + exceptionLabel ( ) ) ; } } RecyclerView . this . attachViewToParent ( child , index , layoutParams ) ; } @ Override public void detachViewFromParent ( int offset ) { final View view = getChildAt ( offset ) ; if ( view != null ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; if ( vh != null ) { if ( vh . isTmpDetached ( ) && ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + vh ) ; } vh . addFlags ( ViewHolder . FLAG_TMP_DETACHED ) ; } } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + offset + exceptionLabel ( ) ) ; } } RecyclerView . this . detachViewFromParent ( offset ) ; } @ Override public void onEnteredHiddenState ( View child ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { vh . onEnteredHiddenState ( RecyclerView . this ) ; } } @ Override public void onLeftHiddenState ( View child ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { vh . onLeftHiddenState ( RecyclerView . this ) ; } } } ) ; } void initAdapterManager ( ) { mAdapterHelper = new AdapterHelper ( new AdapterHelper . Callback ( ) { @ Override public ViewHolder findViewHolder ( int position ) { final ViewHolder vh = findViewHolderForPosition ( position , true ) ; if ( vh == null ) { return null ; } if ( mChildHelper . isHidden ( vh . itemView ) ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } return null ; } return vh ; } @ Override public void offsetPositionsForRemovingInvisible ( int start , int count ) { offsetPositionRecordsForRemove ( start , count , true ) ; mItemsAddedOrRemoved = true ; mState . mDeletedInvisibleItemCountSincePreviousLayout += count ; } @ Override public void offsetPositionsForRemovingLaidOutOrNewView ( int positionStart , int itemCount ) { offsetPositionRecordsForRemove ( positionStart , itemCount , false ) ; mItemsAddedOrRemoved = true ; } @ Override public void markViewHoldersUpdated ( int positionStart , int itemCount , Object payload ) { viewRangeUpdate ( positionStart , itemCount , payload ) ; mItemsChanged = true ; } @ Override public void onDispatchFirstPass ( AdapterHelper . UpdateOp op ) { dispatchUpdate ( op ) ; } void dispatchUpdate ( AdapterHelper . UpdateOp op ) { switch ( op . cmd ) { case AdapterHelper . UpdateOp . ADD : mLayout . onItemsAdded ( RecyclerView . this , op . positionStart , op . itemCount ) ; break ; case AdapterHelper . UpdateOp . REMOVE : mLayout . onItemsRemoved ( RecyclerView . this , op . positionStart , op . itemCount ) ; break ; case AdapterHelper . UpdateOp . UPDATE : mLayout . onItemsUpdated ( RecyclerView . this , op . positionStart , op . itemCount , op . payload ) ; break ; case AdapterHelper . UpdateOp . MOVE : mLayout . onItemsMoved ( RecyclerView . this , op . positionStart , op . itemCount , <NUM_LIT> ) ; break ; } } @ Override public void onDispatchSecondPass ( AdapterHelper . UpdateOp op ) { dispatchUpdate ( op ) ; } @ Override public void offsetPositionsForAdd ( int positionStart , int itemCount ) { offsetPositionRecordsForInsert ( positionStart , itemCount ) ; mItemsAddedOrRemoved = true ; } @ Override public void offsetPositionsForMove ( int from , int to ) { offsetPositionRecordsForMove ( from , to ) ; mItemsAddedOrRemoved = true ; } } ) ; } public void setHasFixedSize ( boolean hasFixedSize ) { mHasFixedSize = hasFixedSize ; } public boolean hasFixedSize ( ) { return mHasFixedSize ; } @ Override public void setClipToPadding ( boolean clipToPadding ) { if ( clipToPadding != mClipToPadding ) { invalidateGlows ( ) ; } mClipToPadding = clipToPadding ; super . setClipToPadding ( clipToPadding ) ; if ( mFirstLayoutComplete ) { requestLayout ( ) ; } } @ Override public boolean getClipToPadding ( ) { return mClipToPadding ; } public void setScrollingTouchSlop ( int slopConstant ) { final ViewConfiguration vc = ViewConfiguration . get ( getContext ( ) ) ; switch ( slopConstant ) { default : Log . w ( TAG , "<STR_LIT>" + slopConstant + "<STR_LIT>" ) ; case TOUCH_SLOP_DEFAULT : mTouchSlop = vc . getScaledTouchSlop ( ) ; break ; case TOUCH_SLOP_PAGING : mTouchSlop = vc . getScaledPagingTouchSlop ( ) ; break ; } } public void swapAdapter ( @ Nullable Adapter adapter , boolean removeAndRecycleExistingViews ) { setLayoutFrozen ( false ) ; setAdapterInternal ( adapter , true , removeAndRecycleExistingViews ) ; processDataSetCompletelyChanged ( true ) ; requestLayout ( ) ; } public void setAdapter ( @ Nullable Adapter adapter ) { setLayoutFrozen ( false ) ; setAdapterInternal ( adapter , false , true ) ; processDataSetCompletelyChanged ( false ) ; requestLayout ( ) ; } void removeAndRecycleViews ( ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } if ( mLayout != null ) { mLayout . removeAndRecycleAllViews ( mRecycler ) ; mLayout . removeAndRecycleScrapInt ( mRecycler ) ; } mRecycler . clear ( ) ; } private void setAdapterInternal ( @ Nullable Adapter < ? > adapter , boolean compatibleWithPrevious , boolean removeAndRecycleViews ) { if ( mAdapter != null ) { mAdapter . unregisterAdapterDataObserver ( mObserver ) ; mAdapter . onDetachedFromRecyclerView ( this ) ; } if ( ! compatibleWithPrevious || removeAndRecycleViews ) { removeAndRecycleViews ( ) ; } mAdapterHelper . reset ( ) ; final Adapter < ? > oldAdapter = mAdapter ; mAdapter = adapter ; if ( adapter != null ) { adapter . registerAdapterDataObserver ( mObserver ) ; adapter . onAttachedToRecyclerView ( this ) ; } if ( mLayout != null ) { mLayout . onAdapterChanged ( oldAdapter , mAdapter ) ; } mRecycler . onAdapterChanged ( oldAdapter , mAdapter , compatibleWithPrevious ) ; mState . mStructureChanged = true ; } @ Nullable public Adapter getAdapter ( ) { return mAdapter ; } @ Deprecated public void setRecyclerListener ( @ Nullable RecyclerListener listener ) { mRecyclerListener = listener ; } public void addRecyclerListener ( @ NonNull RecyclerListener listener ) { checkArgument ( listener != null , "<STR_LIT>" + "<STR_LIT>" ) ; mRecyclerListeners . add ( listener ) ; } public void removeRecyclerListener ( @ NonNull RecyclerListener listener ) { mRecyclerListeners . remove ( listener ) ; } @ Override public int getBaseline ( ) { if ( mLayout != null ) { return mLayout . getBaseline ( ) ; } else { return super . getBaseline ( ) ; } } public void addOnChildAttachStateChangeListener ( @ NonNull OnChildAttachStateChangeListener listener ) { if ( mOnChildAttachStateListeners == null ) { mOnChildAttachStateListeners = new ArrayList < > ( ) ; } mOnChildAttachStateListeners . add ( listener ) ; } public void removeOnChildAttachStateChangeListener ( @ NonNull OnChildAttachStateChangeListener listener ) { if ( mOnChildAttachStateListeners == null ) { return ; } mOnChildAttachStateListeners . remove ( listener ) ; } public void clearOnChildAttachStateChangeListeners ( ) { if ( mOnChildAttachStateListeners != null ) { mOnChildAttachStateListeners . clear ( ) ; } } public void setLayoutManager ( @ Nullable LayoutManager layout ) { if ( layout == mLayout ) { return ; } stopScroll ( ) ; if ( mLayout != null ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } mLayout . removeAndRecycleAllViews ( mRecycler ) ; mLayout . removeAndRecycleScrapInt ( mRecycler ) ; mRecycler . clear ( ) ; if ( mIsAttached ) { mLayout . dispatchDetachedFromWindow ( this , mRecycler ) ; } mLayout . setRecyclerView ( null ) ; mLayout = null ; } else { mRecycler . clear ( ) ; } mChildHelper . removeAllViewsUnfiltered ( ) ; mLayout = layout ; if ( layout != null ) { if ( layout . mRecyclerView != null ) { throw new IllegalArgumentException ( "<STR_LIT>" + layout + "<STR_LIT>" + layout . mRecyclerView . exceptionLabel ( ) ) ; } mLayout . setRecyclerView ( this ) ; if ( mIsAttached ) { mLayout . dispatchAttachedToWindow ( this ) ; } } mRecycler . updateViewCacheSize ( ) ; requestLayout ( ) ; } public void setOnFlingListener ( @ Nullable OnFlingListener onFlingListener ) { mOnFlingListener = onFlingListener ; } @ Nullable public OnFlingListener getOnFlingListener ( ) { return mOnFlingListener ; } @ Override protected Parcelable onSaveInstanceState ( ) { SavedState state = new SavedState ( super . onSaveInstanceState ( ) ) ; if ( mPendingSavedState != null ) { state . copyFrom ( mPendingSavedState ) ; } else if ( mLayout != null ) { state . mLayoutState = mLayout . onSaveInstanceState ( ) ; } else { state . mLayoutState = null ; } return state ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( ! ( state instanceof SavedState ) ) { super . onRestoreInstanceState ( state ) ; return ; } mPendingSavedState = ( SavedState ) state ; super . onRestoreInstanceState ( mPendingSavedState . getSuperState ( ) ) ; requestLayout ( ) ; } @ Override protected void dispatchSaveInstanceState ( SparseArray < Parcelable > container ) { dispatchFreezeSelfOnly ( container ) ; } @ Override protected void dispatchRestoreInstanceState ( SparseArray < Parcelable > container ) { dispatchThawSelfOnly ( container ) ; } private void addAnimatingView ( ViewHolder viewHolder ) { final View view = viewHolder . itemView ; final boolean alreadyParented = view . getParent ( ) == this ; mRecycler . unscrapView ( getChildViewHolder ( view ) ) ; if ( viewHolder . isTmpDetached ( ) ) { mChildHelper . attachViewToParent ( view , - <NUM_LIT> , view . getLayoutParams ( ) , true ) ; } else if ( ! alreadyParented ) { mChildHelper . addView ( view , true ) ; } else { mChildHelper . hide ( view ) ; } } boolean removeAnimatingView ( View view ) { startInterceptRequestLayout ( ) ; final boolean removed = mChildHelper . removeViewIfHidden ( view ) ; if ( removed ) { final ViewHolder viewHolder = getChildViewHolderInt ( view ) ; mRecycler . unscrapView ( viewHolder ) ; mRecycler . recycleViewHolderInternal ( viewHolder ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + view + "<STR_LIT>" + this ) ; } } stopInterceptRequestLayout ( ! removed ) ; return removed ; } @ Nullable public LayoutManager getLayoutManager ( ) { return mLayout ; } @ NonNull public RecycledViewPool getRecycledViewPool ( ) { return mRecycler . getRecycledViewPool ( ) ; } public void setRecycledViewPool ( @ Nullable RecycledViewPool pool ) { mRecycler . setRecycledViewPool ( pool ) ; } public void setViewCacheExtension ( @ Nullable ViewCacheExtension extension ) { mRecycler . setViewCacheExtension ( extension ) ; } public void setItemViewCacheSize ( int size ) { mRecycler . setViewCacheSize ( size ) ; } public int getScrollState ( ) { return mScrollState ; } void setScrollState ( int state ) { if ( state == mScrollState ) { return ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + state + "<STR_LIT>" + mScrollState , new Exception ( ) ) ; } mScrollState = state ; if ( state != SCROLL_STATE_SETTLING ) { stopScrollersInternal ( ) ; } dispatchOnScrollStateChanged ( state ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mItemDecorations . isEmpty ( ) ) { setWillNotDraw ( false ) ; } if ( index < <NUM_LIT> ) { mItemDecorations . add ( decor ) ; } else { mItemDecorations . add ( index , decor ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor ) { addItemDecoration ( decor , - <NUM_LIT> ) ; } @ NonNull public ItemDecoration getItemDecorationAt ( int index ) { final int size = getItemDecorationCount ( ) ; if ( index < <NUM_LIT> || index >= size ) { throw new IndexOutOfBoundsException ( index + "<STR_LIT>" + size ) ; } return mItemDecorations . get ( index ) ; } public int getItemDecorationCount ( ) { return mItemDecorations . size ( ) ; } public void removeItemDecorationAt ( int index ) { final int size = getItemDecorationCount ( ) ; if ( index < <NUM_LIT> || index >= size ) { throw new IndexOutOfBoundsException ( index + "<STR_LIT>" + size ) ; } removeItemDecoration ( getItemDecorationAt ( index ) ) ; } public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } mItemDecorations . remove ( decor ) ; if ( mItemDecorations . isEmpty ( ) ) { setWillNotDraw ( getOverScrollMode ( ) == View . OVER_SCROLL_NEVER ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public void setChildDrawingOrderCallback ( @ Nullable ChildDrawingOrderCallback childDrawingOrderCallback ) { if ( childDrawingOrderCallback == mChildDrawingOrderCallback ) { return ; } mChildDrawingOrderCallback = childDrawingOrderCallback ; setChildrenDrawingOrderEnabled ( mChildDrawingOrderCallback != null ) ; } @ Deprecated public void setOnScrollListener ( @ Nullable OnScrollListener listener ) { mScrollListener = listener ; } public void addOnScrollListener ( @ NonNull OnScrollListener listener ) { if ( mScrollListeners == null ) { mScrollListeners = new ArrayList < > ( ) ; } mScrollListeners . add ( listener ) ; } public void removeOnScrollListener ( @ NonNull OnScrollListener listener ) { if ( mScrollListeners != null ) { mScrollListeners . remove ( listener ) ; } } public void clearOnScrollListeners ( ) { if ( mScrollListeners != null ) { mScrollListeners . clear ( ) ; } } public void scrollToPosition ( int position ) { if ( mLayoutSuppressed ) { return ; } stopScroll ( ) ; if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } mLayout . scrollToPosition ( position ) ; awakenScrollBars ( ) ; } void jumpToPositionForSmoothScroller ( int position ) { if ( mLayout == null ) { return ; } setScrollState ( SCROLL_STATE_SETTLING ) ; mLayout . scrollToPosition ( position ) ; awakenScrollBars ( ) ; } public void smoothScrollToPosition ( int position ) { if ( mLayoutSuppressed ) { return ; } if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } mLayout . smoothScrollToPosition ( this , mState , position ) ; } @ Override public void scrollTo ( int x , int y ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void scrollBy ( int x , int y ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; if ( canScrollHorizontal || canScrollVertical ) { scrollByInternal ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , null , TYPE_TOUCH ) ; } } public void nestedScrollBy ( int x , int y ) { nestedScrollByInternal ( x , y , null , TYPE_NON_TOUCH ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void nestedScrollByInternal ( int x , int y , @ Nullable MotionEvent motionEvent , int type ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontal ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertical ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } float verticalDisplacement = motionEvent == null ? getHeight ( ) / <NUM_LIT> : motionEvent . getY ( ) ; float horizontalDisplacement = motionEvent == null ? getWidth ( ) / <NUM_LIT> : motionEvent . getX ( ) ; x -= releaseHorizontalGlow ( x , verticalDisplacement ) ; y -= releaseVerticalGlow ( y , horizontalDisplacement ) ; startNestedScroll ( nestedScrollAxis , type ) ; if ( dispatchNestedPreScroll ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , mReusableIntPair , mScrollOffset , type ) ) { x -= mReusableIntPair [ <NUM_LIT> ] ; y -= mReusableIntPair [ <NUM_LIT> ] ; } scrollByInternal ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , motionEvent , type ) ; if ( mGapWorker != null && ( x != <NUM_LIT> || y != <NUM_LIT> ) ) { mGapWorker . postFromTraversal ( this , x , y ) ; } stopNestedScroll ( type ) ; } void scrollStep ( int dx , int dy , @ Nullable int [ ] consumed ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; TraceCompat . beginSection ( TRACE_SCROLL_TAG ) ; fillRemainingScrollValues ( mState ) ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; if ( dx != <NUM_LIT> ) { consumedX = mLayout . scrollHorizontallyBy ( dx , mRecycler , mState ) ; } if ( dy != <NUM_LIT> ) { consumedY = mLayout . scrollVerticallyBy ( dy , mRecycler , mState ) ; } TraceCompat . endSection ( ) ; repositionShadowingViews ( ) ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; if ( consumed != null ) { consumed [ <NUM_LIT> ] = consumedX ; consumed [ <NUM_LIT> ] = consumedY ; } } void consumePendingUpdateOperations ( ) { if ( ! mFirstLayoutComplete || mDataSetHasChangedAfterLayout ) { TraceCompat . beginSection ( TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; return ; } if ( ! mAdapterHelper . hasPendingUpdates ( ) ) { return ; } if ( mAdapterHelper . hasAnyUpdateTypes ( AdapterHelper . UpdateOp . UPDATE ) && ! mAdapterHelper . hasAnyUpdateTypes ( AdapterHelper . UpdateOp . ADD | AdapterHelper . UpdateOp . REMOVE | AdapterHelper . UpdateOp . MOVE ) ) { TraceCompat . beginSection ( TRACE_HANDLE_ADAPTER_UPDATES_TAG ) ; startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mAdapterHelper . preProcess ( ) ; if ( ! mLayoutWasDefered ) { if ( hasUpdatedView ( ) ) { dispatchLayout ( ) ; } else { mAdapterHelper . consumePostponedUpdates ( ) ; } } stopInterceptRequestLayout ( true ) ; onExitLayoutOrScroll ( ) ; TraceCompat . endSection ( ) ; } else if ( mAdapterHelper . hasPendingUpdates ( ) ) { TraceCompat . beginSection ( TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; } } private boolean hasUpdatedView ( ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder == null || holder . shouldIgnore ( ) ) { continue ; } if ( holder . isUpdated ( ) ) { return true ; } } return false ; } boolean scrollByInternal ( int x , int y , MotionEvent ev , int type ) { int unconsumedX = <NUM_LIT> ; int unconsumedY = <NUM_LIT> ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; consumePendingUpdateOperations ( ) ; if ( mAdapter != null ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; scrollStep ( x , y , mReusableIntPair ) ; consumedX = mReusableIntPair [ <NUM_LIT> ] ; consumedY = mReusableIntPair [ <NUM_LIT> ] ; unconsumedX = x - consumedX ; unconsumedY = y - consumedY ; } if ( ! mItemDecorations . isEmpty ( ) ) { invalidate ( ) ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( consumedX , consumedY , unconsumedX , unconsumedY , mScrollOffset , type , mReusableIntPair ) ; unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; boolean consumedNestedScroll = mReusableIntPair [ <NUM_LIT> ] != <NUM_LIT> || mReusableIntPair [ <NUM_LIT> ] != <NUM_LIT> ; mLastTouchX -= mScrollOffset [ <NUM_LIT> ] ; mLastTouchY -= mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; if ( getOverScrollMode ( ) != View . OVER_SCROLL_NEVER ) { if ( ev != null && ! MotionEventCompat . isFromSource ( ev , InputDevice . SOURCE_MOUSE ) ) { pullGlows ( ev . getX ( ) , unconsumedX , ev . getY ( ) , unconsumedY ) ; } } if ( consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ) { dispatchOnScrolled ( consumedX , consumedY ) ; } if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } return consumedNestedScroll || consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ; } private int releaseHorizontalGlow ( int deltaX , float y ) { if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) mHorizontalEdgeEffect . onPullDistance ( deltaX , true ) ; invalidate ( ) ; return consumed ; } return <NUM_LIT> ; } private int releaseVerticalGlow ( int deltaY , float x ) { if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) mVerticalEdgeEffect . onPullDistance ( deltaY , true ) ; invalidate ( ) ; return consumed ; } return <NUM_LIT> ; } @ Override public int computeHorizontalScrollOffset ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollOffset ( mState ) : <NUM_LIT> ; } @ Override public int computeHorizontalScrollExtent ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollExtent ( mState ) : <NUM_LIT> ; } @ Override public int computeHorizontalScrollRange ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollRange ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollOffset ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollOffset ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollExtent ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollExtent ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollRange ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollRange ( mState ) : <NUM_LIT> ; } void startInterceptRequestLayout ( ) { mInterceptRequestLayoutDepth ++ ; if ( mInterceptRequestLayoutDepth == <NUM_LIT> && ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } } void stopInterceptRequestLayout ( boolean performLayoutChildren ) { if ( mInterceptRequestLayoutDepth < <NUM_LIT> ) { if ( sDebugAssertionsEnabled ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } mInterceptRequestLayoutDepth = <NUM_LIT> ; } if ( ! performLayoutChildren && ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } if ( mInterceptRequestLayoutDepth == <NUM_LIT> ) { if ( performLayoutChildren && mLayoutWasDefered && ! mLayoutSuppressed && mLayout != null && mAdapter != null ) { dispatchLayout ( ) ; } if ( ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } } mInterceptRequestLayoutDepth -- ; } @ Override public final void suppressLayout ( boolean suppress ) { if ( suppress != mLayoutSuppressed ) { assertNotInLayoutOrScroll ( "<STR_LIT>" ) ; if ( ! suppress ) { mLayoutSuppressed = false ; if ( mLayoutWasDefered && mLayout != null && mAdapter != null ) { requestLayout ( ) ; } mLayoutWasDefered = false ; } else { final long now = SystemClock . uptimeMillis ( ) ; MotionEvent cancelEvent = MotionEvent . obtain ( now , now , MotionEvent . ACTION_CANCEL , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; onTouchEvent ( cancelEvent ) ; mLayoutSuppressed = true ; mIgnoreMotionEventTillDown = true ; stopScroll ( ) ; } } } @ Override public final boolean isLayoutSuppressed ( ) { return mLayoutSuppressed ; } @ Deprecated public void setLayoutFrozen ( boolean frozen ) { suppressLayout ( frozen ) ; } @ Deprecated public boolean isLayoutFrozen ( ) { return isLayoutSuppressed ( ) ; } @ Deprecated @ Override public void setLayoutTransition ( LayoutTransition transition ) { if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { if ( transition == null ) { suppressLayout ( false ) ; return ; } else { int layoutTransitionChanging = <NUM_LIT> ; if ( transition . getAnimator ( LayoutTransition . CHANGE_APPEARING ) == null && transition . getAnimator ( LayoutTransition . CHANGE_DISAPPEARING ) == null && transition . getAnimator ( LayoutTransition . APPEARING ) == null && transition . getAnimator ( LayoutTransition . DISAPPEARING ) == null && transition . getAnimator ( layoutTransitionChanging ) == null ) { suppressLayout ( true ) ; return ; } } } if ( transition == null ) { super . setLayoutTransition ( null ) ; } else { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } } public void smoothScrollBy ( @ Px int dx , @ Px int dy ) { smoothScrollBy ( dx , dy , null ) ; } public void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator ) { smoothScrollBy ( dx , dy , interpolator , UNDEFINED_DURATION ) ; } public void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator , int duration ) { smoothScrollBy ( dx , dy , interpolator , duration , false ) ; } void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator , int duration , boolean withNestedScrolling ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } if ( ! mLayout . canScrollHorizontally ( ) ) { dx = <NUM_LIT> ; } if ( ! mLayout . canScrollVertically ( ) ) { dy = <NUM_LIT> ; } if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { boolean durationSuggestsAnimation = duration == UNDEFINED_DURATION || duration > <NUM_LIT> ; if ( durationSuggestsAnimation ) { if ( withNestedScrolling ) { int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( dx != <NUM_LIT> ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( dy != <NUM_LIT> ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_NON_TOUCH ) ; } mViewFlinger . smoothScrollBy ( dx , dy , duration , interpolator ) ; } else { scrollBy ( dx , dy ) ; } } } public boolean fling ( int velocityX , int velocityY ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return false ; } if ( mLayoutSuppressed ) { return false ; } final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; if ( ! canScrollHorizontal || Math . abs ( velocityX ) < mMinFlingVelocity ) { velocityX = <NUM_LIT> ; } if ( ! canScrollVertical || Math . abs ( velocityY ) < mMinFlingVelocity ) { velocityY = <NUM_LIT> ; } if ( velocityX == <NUM_LIT> && velocityY == <NUM_LIT> ) { return false ; } int flingX = <NUM_LIT> ; int flingY = <NUM_LIT> ; if ( velocityX != <NUM_LIT> ) { if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { if ( shouldAbsorb ( mHorizontalEdgeEffect , velocityX ) ) { mHorizontalEdgeEffect . onAbsorb ( velocityX ) ; } else { flingX = velocityX ; } velocityX = <NUM_LIT> ; } } if ( velocityY != <NUM_LIT> ) { if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { if ( shouldAbsorb ( mVerticalEdgeEffect , velocityY ) ) { mVerticalEdgeEffect . onAbsorb ( - velocityY ) ; } else { flingY = velocityY ; } velocityY = <NUM_LIT> ; } } if ( flingX != <NUM_LIT> || flingY != <NUM_LIT> ) { flingX = Math . max ( - mMaxFlingVelocity , Math . min ( flingX , mMaxFlingVelocity ) ) ; flingY = Math . max ( - mMaxFlingVelocity , Math . min ( flingY , mMaxFlingVelocity ) ) ; mViewFlinger . fling ( flingX , flingY ) ; } if ( velocityX == <NUM_LIT> && velocityY == <NUM_LIT> ) { return flingX != <NUM_LIT> || flingY != <NUM_LIT> ; } if ( ! dispatchNestedPreFling ( velocityX , velocityY ) ) { final boolean canScroll = canScrollHorizontal || canScrollVertical ; dispatchNestedFling ( velocityX , velocityY , canScroll ) ; if ( mOnFlingListener != null && mOnFlingListener . onFling ( velocityX , velocityY ) ) { return true ; } if ( canScroll ) { int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontal ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertical ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_NON_TOUCH ) ; velocityX = Math . max ( - mMaxFlingVelocity , Math . min ( velocityX , mMaxFlingVelocity ) ) ; velocityY = Math . max ( - mMaxFlingVelocity , Math . min ( velocityY , mMaxFlingVelocity ) ) ; mViewFlinger . fling ( velocityX , velocityY ) ; return true ; } } return false ; } private boolean shouldAbsorb ( @ NonNull EdgeEffectAdapter edgeEffect , int velocity ) { return true ; } int consumeFlingInHorizontalStretch ( int unconsumedX ) { return consumeFlingInStretch ( unconsumedX , mHorizontalEdgeEffect ) ; } int consumeFlingInVerticalStretch ( int unconsumedY ) { return consumeFlingInStretch ( unconsumedY , mVerticalEdgeEffect ) ; } private int consumeFlingInStretch ( int unconsumed , EdgeEffectAdapter edgeEffect ) { if ( unconsumed != <NUM_LIT> && edgeEffect != null && edgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) edgeEffect . onPullDistance ( unconsumed , true ) ; return unconsumed > <NUM_LIT> ? ( unconsumed - consumed ) : ( unconsumed + consumed ) ; } return unconsumed ; } public void stopScroll ( ) { setScrollState ( SCROLL_STATE_IDLE ) ; stopScrollersInternal ( ) ; } private void stopScrollersInternal ( ) { mViewFlinger . stop ( ) ; if ( mLayout != null ) { mLayout . stopSmoothScroller ( ) ; } } public int getMinFlingVelocity ( ) { return mMinFlingVelocity ; } public int getMaxFlingVelocity ( ) { return mMaxFlingVelocity ; } private void pullGlows ( float x , float overscrollX , float y , float overscrollY ) { boolean invalidate = false ; if ( overscrollX != <NUM_LIT> ) { ensureHorizontalGlow ( ) ; mHorizontalEdgeEffect . onPullDistance ( overscrollX , false ) ; invalidate = true ; } if ( overscrollY != <NUM_LIT> ) { ensureVerticalGlow ( ) ; mVerticalEdgeEffect . onPullDistance ( overscrollY , false ) ; invalidate = true ; } if ( invalidate || overscrollX != <NUM_LIT> || overscrollY != <NUM_LIT> ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } private void releaseGlows ( ) { boolean needsInvalidate = false ; if ( mHorizontalEdgeEffect != null ) { mHorizontalEdgeEffect . onRelease ( ) ; needsInvalidate = mHorizontalEdgeEffect . isFinished ( ) ; } if ( mVerticalEdgeEffect != null ) { mVerticalEdgeEffect . onRelease ( ) ; needsInvalidate |= mVerticalEdgeEffect . isFinished ( ) ; } if ( needsInvalidate ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } void absorbGlows ( int velocityX , int velocityY ) { if ( velocityX != <NUM_LIT> ) { ensureHorizontalGlow ( ) ; if ( mHorizontalEdgeEffect . isFinished ( ) ) { mHorizontalEdgeEffect . onAbsorb ( velocityX ) ; } } if ( velocityY != <NUM_LIT> ) { ensureVerticalGlow ( ) ; if ( mVerticalEdgeEffect . isFinished ( ) ) { mVerticalEdgeEffect . onAbsorb ( velocityY ) ; } } if ( velocityX != <NUM_LIT> || velocityY != <NUM_LIT> ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } void ensureHorizontalGlow ( ) { if ( mHorizontalEdgeEffect != null ) { return ; } mHorizontalEdgeEffect = new EdgeEffectAdapter ( getContext ( ) ) ; mHorizontalEdgeEffect . updateViewportRange ( getWidth ( ) ) ; } void ensureVerticalGlow ( ) { if ( mVerticalEdgeEffect != null ) { return ; } mVerticalEdgeEffect = new EdgeEffectAdapter ( getContext ( ) ) ; mVerticalEdgeEffect . updateViewportRange ( getHeight ( ) ) ; } void invalidateGlows ( ) { mHorizontalEdgeEffect = mVerticalEdgeEffect = null ; } public void setEdgeEffectFactory ( @ NonNull EdgeEffectFactory edgeEffectFactory ) { } @ NonNull public EdgeEffectFactory getEdgeEffectFactory ( ) { return null ; } @ Override public View focusSearch ( View focused , int direction ) { View result = mLayout . onInterceptFocusSearch ( focused , direction ) ; if ( result != null ) { return result ; } final boolean canRunFocusFailure = mAdapter != null && mLayout != null && ! isComputingLayout ( ) && ! mLayoutSuppressed ; final FocusFinder ff = FocusFinder . getInstance ( ) ; if ( canRunFocusFailure && ( direction == View . FOCUS_FORWARD || direction == View . FOCUS_BACKWARD ) ) { boolean needsFocusFailureLayout = false ; if ( mLayout . canScrollVertically ( ) ) { final int absDir = direction == View . FOCUS_FORWARD ? View . FOCUS_DOWN : View . FOCUS_UP ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found == null ; if ( FORCE_ABS_FOCUS_SEARCH_DIRECTION ) { direction = absDir ; } } if ( ! needsFocusFailureLayout && mLayout . canScrollHorizontally ( ) ) { boolean rtl = mLayout . getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; final int absDir = ( direction == View . FOCUS_FORWARD ) ^ rtl ? View . FOCUS_RIGHT : View . FOCUS_LEFT ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found == null ; if ( FORCE_ABS_FOCUS_SEARCH_DIRECTION ) { direction = absDir ; } } if ( needsFocusFailureLayout ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView == null ) { return null ; } startInterceptRequestLayout ( ) ; mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; stopInterceptRequestLayout ( false ) ; } result = ff . findNextFocus ( this , focused , direction ) ; } else { result = ff . findNextFocus ( this , focused , direction ) ; if ( result == null && canRunFocusFailure ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView == null ) { return null ; } startInterceptRequestLayout ( ) ; result = mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; stopInterceptRequestLayout ( false ) ; } } if ( result != null && ! result . hasFocusable ( ) ) { if ( getFocusedChild ( ) == null ) { return super . focusSearch ( focused , direction ) ; } requestChildOnScreen ( result , null ) ; return focused ; } return isPreferredNextFocus ( focused , result , direction ) ? result : super . focusSearch ( focused , direction ) ; } private boolean isPreferredNextFocus ( View focused , View next , int direction ) { if ( next == null || next == this || next == focused ) { return false ; } if ( findContainingItemView ( next ) == null ) { return false ; } if ( focused == null ) { return true ; } if ( findContainingItemView ( focused ) == null ) { return true ; } mTempRect . set ( <NUM_LIT> , <NUM_LIT> , focused . getWidth ( ) , focused . getHeight ( ) ) ; mTempRect2 . set ( <NUM_LIT> , <NUM_LIT> , next . getWidth ( ) , next . getHeight ( ) ) ; offsetDescendantRectToMyCoords ( focused , mTempRect ) ; offsetDescendantRectToMyCoords ( next , mTempRect2 ) ; final int rtl = mLayout . getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ? - <NUM_LIT> : <NUM_LIT> ; int rightness = <NUM_LIT> ; if ( ( mTempRect . left < mTempRect2 . left || mTempRect . right <= mTempRect2 . left ) && mTempRect . right < mTempRect2 . right ) { rightness = <NUM_LIT> ; } else if ( ( mTempRect . right > mTempRect2 . right || mTempRect . left >= mTempRect2 . right ) && mTempRect . left > mTempRect2 . left ) { rightness = - <NUM_LIT> ; } int downness = <NUM_LIT> ; if ( ( mTempRect . top < mTempRect2 . top || mTempRect . bottom <= mTempRect2 . top ) && mTempRect . bottom < mTempRect2 . bottom ) { downness = <NUM_LIT> ; } else if ( ( mTempRect . bottom > mTempRect2 . bottom || mTempRect . top >= mTempRect2 . bottom ) && mTempRect . top > mTempRect2 . top ) { downness = - <NUM_LIT> ; } switch ( direction ) { case View . FOCUS_LEFT : return rightness < <NUM_LIT> ; case View . FOCUS_RIGHT : return rightness > <NUM_LIT> ; case View . FOCUS_UP : return downness < <NUM_LIT> ; case View . FOCUS_DOWN : return downness > <NUM_LIT> ; case View . FOCUS_FORWARD : return downness > <NUM_LIT> || ( downness == <NUM_LIT> && rightness * rtl > <NUM_LIT> ) ; case View . FOCUS_BACKWARD : return downness < <NUM_LIT> || ( downness == <NUM_LIT> && rightness * rtl < <NUM_LIT> ) ; } throw new IllegalArgumentException ( "<STR_LIT>" + direction + exceptionLabel ( ) ) ; } @ Override public void requestChildFocus ( View child , View focused ) { if ( ! mLayout . onRequestChildFocus ( this , mState , child , focused ) && focused != null ) { requestChildOnScreen ( child , focused ) ; } super . requestChildFocus ( child , focused ) ; } private void requestChildOnScreen ( @ NonNull View child , @ Nullable View focused ) { View rectView = ( focused != null ) ? focused : child ; mTempRect . set ( <NUM_LIT> , <NUM_LIT> , rectView . getWidth ( ) , rectView . getHeight ( ) ) ; final ViewGroup . LayoutParams focusedLayoutParams = rectView . getLayoutParams ( ) ; if ( focusedLayoutParams instanceof LayoutParams ) { final LayoutParams lp = ( LayoutParams ) focusedLayoutParams ; if ( ! lp . mInsetsDirty ) { final Rect insets = lp . mDecorInsets ; mTempRect . left -= insets . left ; mTempRect . right += insets . right ; mTempRect . top -= insets . top ; mTempRect . bottom += insets . bottom ; } } if ( focused != null ) { offsetDescendantRectToMyCoords ( focused , mTempRect ) ; offsetRectIntoDescendantCoords ( child , mTempRect ) ; } mLayout . requestChildRectangleOnScreen ( this , child , mTempRect , ! mFirstLayoutComplete , ( focused == null ) ) ; } @ Override public boolean requestChildRectangleOnScreen ( View child , Rect rect , boolean immediate ) { return mLayout . requestChildRectangleOnScreen ( this , child , rect , immediate ) ; } @ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { if ( mLayout == null || ! mLayout . onAddFocusables ( this , views , direction , focusableMode ) ) { super . addFocusables ( views , direction , focusableMode ) ; } } @ Override protected boolean onRequestFocusInDescendants ( int direction , Rect previouslyFocusedRect ) { if ( isComputingLayout ( ) ) { return false ; } return super . onRequestFocusInDescendants ( direction , previouslyFocusedRect ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; mLayoutOrScrollCounter = <NUM_LIT> ; mIsAttached = true ; mFirstLayoutComplete = mFirstLayoutComplete && ! isLayoutRequested ( ) ; mRecycler . onAttachedToWindow ( ) ; if ( mLayout != null ) { mLayout . dispatchAttachedToWindow ( this ) ; } mPostedAnimatorRunner = false ; if ( ALLOW_THREAD_GAP_WORK ) { mGapWorker = GapWorker . sGapWorker . get ( ) ; if ( mGapWorker == null ) { mGapWorker = new GapWorker ( ) ; Display display = ViewCompat . getDisplay ( this ) ; float refreshRate = <NUM_LIT> ; if ( ! isInEditMode ( ) && display != null ) { float displayRefreshRate = display . getRefreshRate ( ) ; if ( displayRefreshRate >= <NUM_LIT> ) { refreshRate = displayRefreshRate ; } } mGapWorker . mFrameIntervalNs = ( long ) ( <NUM_LIT> / refreshRate ) ; GapWorker . sGapWorker . set ( mGapWorker ) ; } mGapWorker . add ( this ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } stopScroll ( ) ; mIsAttached = false ; if ( mLayout != null ) { mLayout . dispatchDetachedFromWindow ( this , mRecycler ) ; } mPendingAccessibilityImportanceChange . clear ( ) ; removeCallbacks ( mItemAnimatorRunner ) ; mViewInfoStore . onDetach ( ) ; mRecycler . onDetachedFromWindow ( ) ; PoolingContainer . callPoolingContainerOnReleaseForChildren ( this ) ; if ( ALLOW_THREAD_GAP_WORK && mGapWorker != null ) { mGapWorker . remove ( this ) ; mGapWorker = null ; } } @ Override public boolean isAttachedToWindow ( ) { return mIsAttached ; } void assertInLayoutOrScroll ( String message ) { if ( ! isComputingLayout ( ) ) { if ( message == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } throw new IllegalStateException ( message + exceptionLabel ( ) ) ; } } void assertNotInLayoutOrScroll ( String message ) { if ( isComputingLayout ( ) ) { if ( message == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } throw new IllegalStateException ( message ) ; } if ( mDispatchScrollCounter > <NUM_LIT> ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" , new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ) ; } } public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchListeners . add ( listener ) ; } public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchListeners . remove ( listener ) ; if ( mInterceptingOnItemTouchListener == listener ) { mInterceptingOnItemTouchListener = null ; } } private boolean dispatchToOnItemTouchListeners ( MotionEvent e ) { if ( mInterceptingOnItemTouchListener == null ) { if ( e . getAction ( ) == MotionEvent . ACTION_DOWN ) { return false ; } return findInterceptingOnItemTouchListener ( e ) ; } else { mInterceptingOnItemTouchListener . onTouchEvent ( this , e ) ; final int action = e . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingOnItemTouchListener = null ; } return true ; } } private boolean findInterceptingOnItemTouchListener ( MotionEvent e ) { int action = e . getAction ( ) ; final int listenerCount = mOnItemTouchListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { final OnItemTouchListener listener = mOnItemTouchListeners . get ( i ) ; if ( listener . onInterceptTouchEvent ( this , e ) && action != MotionEvent . ACTION_CANCEL ) { mInterceptingOnItemTouchListener = listener ; return true ; } } return false ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent e ) { if ( mLayoutSuppressed ) { return false ; } mInterceptingOnItemTouchListener = null ; if ( findInterceptingOnItemTouchListener ( e ) ) { cancelScroll ( ) ; return true ; } if ( mLayout == null ) { return false ; } final boolean canScrollHorizontally = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertically = mLayout . canScrollVertically ( ) ; if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTrackerFactory . create ( getContext ( ) ) ; } mVelocityTracker . addMovement ( e ) ; final int action = e . getActionMasked ( ) ; final int actionIndex = e . getActionIndex ( ) ; switch ( action ) { case MotionEvent . ACTION_DOWN : if ( mIgnoreMotionEventTillDown ) { mIgnoreMotionEventTillDown = false ; } mScrollPointerId = e . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( ) + <NUM_LIT> ) ; if ( stopGlowAnimations ( e ) || mScrollState == SCROLL_STATE_SETTLING ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; setScrollState ( SCROLL_STATE_DRAGGING ) ; stopNestedScroll ( TYPE_NON_TOUCH ) ; } mNestedOffsets [ <NUM_LIT> ] = mNestedOffsets [ <NUM_LIT> ] = <NUM_LIT> ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontally ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertically ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_TOUCH ) ; break ; case MotionEvent . ACTION_POINTER_DOWN : mScrollPointerId = e . getPointerId ( actionIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( actionIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( actionIndex ) + <NUM_LIT> ) ; break ; case MotionEvent . ACTION_MOVE : { final int index = e . findPointerIndex ( mScrollPointerId ) ; if ( index < <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + mScrollPointerId + "<STR_LIT>" ) ; return false ; } final int x = ( int ) ( e . getX ( index ) + <NUM_LIT> ) ; final int y = ( int ) ( e . getY ( index ) + <NUM_LIT> ) ; if ( mScrollState != SCROLL_STATE_DRAGGING ) { final int dx = x - mInitialTouchX ; final int dy = y - mInitialTouchY ; boolean startScroll = false ; if ( canScrollHorizontally && Math . abs ( dx ) > mTouchSlop ) { mLastTouchX = x ; startScroll = true ; } if ( canScrollVertically && Math . abs ( dy ) > mTouchSlop ) { mLastTouchY = y ; startScroll = true ; } if ( startScroll ) { setScrollState ( SCROLL_STATE_DRAGGING ) ; } } } break ; case MotionEvent . ACTION_POINTER_UP : { onPointerUp ( e ) ; } break ; case MotionEvent . ACTION_UP : { mVelocityTracker . clear ( ) ; stopNestedScroll ( TYPE_TOUCH ) ; } break ; case MotionEvent . ACTION_CANCEL : { cancelScroll ( ) ; } } return mScrollState == SCROLL_STATE_DRAGGING ; } private boolean stopGlowAnimations ( MotionEvent e ) { boolean stopped = false ; if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { stopped = true ; } if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { stopped = true ; } return stopped ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { final int listenerCount = mOnItemTouchListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { final OnItemTouchListener listener = mOnItemTouchListeners . get ( i ) ; listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ; } super . requestDisallowInterceptTouchEvent ( disallowIntercept ) ; } @ Override public boolean onTouchEvent ( MotionEvent e ) { if ( mLayoutSuppressed || mIgnoreMotionEventTillDown ) { return false ; } if ( dispatchToOnItemTouchListeners ( e ) ) { cancelScroll ( ) ; return true ; } if ( mLayout == null ) { return false ; } final boolean canScrollHorizontally = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertically = mLayout . canScrollVertically ( ) ; if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTrackerFactory . create ( getContext ( ) ) ; } boolean eventAddedToVelocityTracker = false ; final int action = e . getActionMasked ( ) ; final int actionIndex = e . getActionIndex ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { mNestedOffsets [ <NUM_LIT> ] = mNestedOffsets [ <NUM_LIT> ] = <NUM_LIT> ; } final MotionEvent vtev = MotionEvent . obtain ( e ) ; vtev . offsetLocation ( mNestedOffsets [ <NUM_LIT> ] , mNestedOffsets [ <NUM_LIT> ] ) ; switch ( action ) { case MotionEvent . ACTION_DOWN : { mScrollPointerId = e . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( ) + <NUM_LIT> ) ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontally ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertically ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_TOUCH ) ; } break ; case MotionEvent . ACTION_POINTER_DOWN : { mScrollPointerId = e . getPointerId ( actionIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( actionIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( actionIndex ) + <NUM_LIT> ) ; } break ; case MotionEvent . ACTION_MOVE : { final int index = e . findPointerIndex ( mScrollPointerId ) ; if ( index < <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + mScrollPointerId + "<STR_LIT>" ) ; return false ; } final int x = ( int ) ( e . getX ( index ) + <NUM_LIT> ) ; final int y = ( int ) ( e . getY ( index ) + <NUM_LIT> ) ; int dx = mLastTouchX - x ; int dy = mLastTouchY - y ; if ( mScrollState != SCROLL_STATE_DRAGGING ) { boolean startScroll = false ; if ( canScrollHorizontally ) { if ( dx > <NUM_LIT> ) { dx = Math . max ( <NUM_LIT> , dx - mTouchSlop ) ; } else { dx = Math . min ( <NUM_LIT> , dx + mTouchSlop ) ; } if ( dx != <NUM_LIT> ) { startScroll = true ; } } if ( canScrollVertically ) { if ( dy > <NUM_LIT> ) { dy = Math . max ( <NUM_LIT> , dy - mTouchSlop ) ; } else { dy = Math . min ( <NUM_LIT> , dy + mTouchSlop ) ; } if ( dy != <NUM_LIT> ) { startScroll = true ; } } if ( startScroll ) { setScrollState ( SCROLL_STATE_DRAGGING ) ; } } if ( mScrollState == SCROLL_STATE_DRAGGING ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dx -= releaseHorizontalGlow ( dx , e . getY ( ) ) ; dy -= releaseVerticalGlow ( dy , e . getX ( ) ) ; if ( dispatchNestedPreScroll ( canScrollHorizontally ? dx : <NUM_LIT> , canScrollVertically ? dy : <NUM_LIT> , mReusableIntPair , mScrollOffset , TYPE_TOUCH ) ) { dx -= mReusableIntPair [ <NUM_LIT> ] ; dy -= mReusableIntPair [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mLastTouchX = x - mScrollOffset [ <NUM_LIT> ] ; mLastTouchY = y - mScrollOffset [ <NUM_LIT> ] ; if ( scrollByInternal ( canScrollHorizontally ? dx : <NUM_LIT> , canScrollVertically ? dy : <NUM_LIT> , e , TYPE_TOUCH ) ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } if ( mGapWorker != null && ( dx != <NUM_LIT> || dy != <NUM_LIT> ) ) { mGapWorker . postFromTraversal ( this , dx , dy ) ; } } } break ; case MotionEvent . ACTION_POINTER_UP : { onPointerUp ( e ) ; } break ; case MotionEvent . ACTION_UP : { mVelocityTracker . addMovement ( vtev ) ; eventAddedToVelocityTracker = true ; mVelocityTracker . computeCurrentVelocity ( <NUM_LIT> , mMaxFlingVelocity ) ; final float xvel = canScrollHorizontally ? - mVelocityTracker . getXVelocity ( mScrollPointerId ) : <NUM_LIT> ; final float yvel = canScrollVertically ? - mVelocityTracker . getYVelocity ( mScrollPointerId ) : <NUM_LIT> ; if ( ! ( ( xvel != <NUM_LIT> || yvel != <NUM_LIT> ) && fling ( ( int ) xvel , ( int ) yvel ) ) ) { setScrollState ( SCROLL_STATE_IDLE ) ; } resetScroll ( ) ; } break ; case MotionEvent . ACTION_CANCEL : { cancelScroll ( ) ; } break ; } if ( ! eventAddedToVelocityTracker ) { mVelocityTracker . addMovement ( vtev ) ; } vtev . recycle ( ) ; return true ; } private void resetScroll ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } stopNestedScroll ( TYPE_TOUCH ) ; releaseGlows ( ) ; } private void cancelScroll ( ) { resetScroll ( ) ; setScrollState ( SCROLL_STATE_IDLE ) ; } private void onPointerUp ( MotionEvent e ) { final int actionIndex = e . getActionIndex ( ) ; if ( e . getPointerId ( actionIndex ) == mScrollPointerId ) { final int newIndex = actionIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mScrollPointerId = e . getPointerId ( newIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( newIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( newIndex ) + <NUM_LIT> ) ; } } @ Override public boolean onGenericMotionEvent ( MotionEvent event ) { if ( mLayout == null ) { return false ; } if ( mLayoutSuppressed ) { return false ; } if ( event . getAction ( ) == MotionEvent . ACTION_SCROLL ) { final float vScroll , hScroll ; if ( ( event . getSource ( ) & InputDeviceCompat . SOURCE_CLASS_POINTER ) != <NUM_LIT> ) { if ( mLayout . canScrollVertically ( ) ) { vScroll = - event . getAxisValue ( MotionEvent . AXIS_VSCROLL ) ; } else { vScroll = <NUM_LIT> ; } if ( mLayout . canScrollHorizontally ( ) ) { hScroll = event . getAxisValue ( MotionEvent . AXIS_HSCROLL ) ; } else { hScroll = <NUM_LIT> ; } } else if ( ( event . getSource ( ) & InputDeviceCompat . SOURCE_ROTARY_ENCODER ) != <NUM_LIT> ) { final float axisScroll = event . getAxisValue ( MotionEventCompat . AXIS_SCROLL ) ; if ( mLayout . canScrollVertically ( ) ) { vScroll = - axisScroll ; hScroll = <NUM_LIT> ; } else if ( mLayout . canScrollHorizontally ( ) ) { vScroll = <NUM_LIT> ; hScroll = axisScroll ; } else { vScroll = <NUM_LIT> ; hScroll = <NUM_LIT> ; } } else { vScroll = <NUM_LIT> ; hScroll = <NUM_LIT> ; } if ( vScroll != <NUM_LIT> || hScroll != <NUM_LIT> ) { nestedScrollByInternal ( ( int ) ( hScroll * mScaledHorizontalScrollFactor ) , ( int ) ( vScroll * mScaledVerticalScrollFactor ) , event , TYPE_NON_TOUCH ) ; } } return false ; } @ Override protected void onMeasure ( int widthSpec , int heightSpec ) { if ( mLayout == null ) { defaultOnMeasure ( widthSpec , heightSpec ) ; return ; } if ( mLayout . isAutoMeasureEnabled ( ) ) { final int widthMode = MeasureSpec . getMode ( widthSpec ) ; final int heightMode = MeasureSpec . getMode ( heightSpec ) ; mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; mLastAutoMeasureSkippedDueToExact = widthMode == MeasureSpec . EXACTLY && heightMode == MeasureSpec . EXACTLY ; if ( mLastAutoMeasureSkippedDueToExact || mAdapter == null ) { return ; } if ( mState . mLayoutStep == State . STEP_START ) { dispatchLayoutStep1 ( ) ; } mLayout . setMeasureSpecs ( widthSpec , heightSpec ) ; mState . mIsMeasuring = true ; dispatchLayoutStep2 ( ) ; mLayout . setMeasuredDimensionFromChildren ( widthSpec , heightSpec ) ; if ( mLayout . shouldMeasureTwice ( ) ) { mLayout . setMeasureSpecs ( MeasureSpec . makeMeasureSpec ( getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ) ; mState . mIsMeasuring = true ; dispatchLayoutStep2 ( ) ; mLayout . setMeasuredDimensionFromChildren ( widthSpec , heightSpec ) ; } mLastAutoMeasureNonExactMeasuredWidth = getMeasuredWidth ( ) ; mLastAutoMeasureNonExactMeasuredHeight = getMeasuredHeight ( ) ; } else { if ( mHasFixedSize ) { mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; return ; } if ( mAdapterUpdateDuringMeasure ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; processAdapterUpdatesAndSetAnimationFlags ( ) ; onExitLayoutOrScroll ( ) ; if ( mState . mRunPredictiveAnimations ) { mState . mInPreLayout = true ; } else { mAdapterHelper . consumeUpdatesInOnePass ( ) ; mState . mInPreLayout = false ; } mAdapterUpdateDuringMeasure = false ; stopInterceptRequestLayout ( false ) ; } else if ( mState . mRunPredictiveAnimations ) { setMeasuredDimension ( getMeasuredWidth ( ) , getMeasuredHeight ( ) ) ; return ; } if ( mAdapter != null ) { mState . mItemCount = mAdapter . getItemCount ( ) ; } else { mState . mItemCount = <NUM_LIT> ; } startInterceptRequestLayout ( ) ; mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; stopInterceptRequestLayout ( false ) ; mState . mInPreLayout = false ; } } void defaultOnMeasure ( int widthSpec , int heightSpec ) { final int width = LayoutManager . chooseSize ( widthSpec , getPaddingLeft ( ) + getPaddingRight ( ) , ViewCompat . getMinimumWidth ( this ) ) ; final int height = LayoutManager . chooseSize ( heightSpec , getPaddingTop ( ) + getPaddingBottom ( ) , ViewCompat . getMinimumHeight ( this ) ) ; setMeasuredDimension ( width , height ) ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( w != oldw || h != oldh ) { invalidateGlows ( ) ; } } public void setItemAnimator ( @ Nullable ItemAnimator animator ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; mItemAnimator . setListener ( null ) ; } mItemAnimator = animator ; if ( mItemAnimator != null ) { mItemAnimator . setListener ( mItemAnimatorListener ) ; } } void onEnterLayoutOrScroll ( ) { mLayoutOrScrollCounter ++ ; } void onExitLayoutOrScroll ( ) { onExitLayoutOrScroll ( true ) ; } void onExitLayoutOrScroll ( boolean enableChangeEvents ) { mLayoutOrScrollCounter -- ; if ( mLayoutOrScrollCounter < <NUM_LIT> ) { if ( sDebugAssertionsEnabled && mLayoutOrScrollCounter < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } mLayoutOrScrollCounter = <NUM_LIT> ; if ( enableChangeEvents ) { dispatchContentChangedIfNecessary ( ) ; dispatchPendingImportantForAccessibilityChanges ( ) ; } } } boolean isAccessibilityEnabled ( ) { return mAccessibilityManager != null && mAccessibilityManager . isEnabled ( ) ; } private void dispatchContentChangedIfNecessary ( ) { final int flags = mEatenAccessibilityChangeFlags ; mEatenAccessibilityChangeFlags = <NUM_LIT> ; if ( flags != <NUM_LIT> && isAccessibilityEnabled ( ) ) { final AccessibilityEvent event = AccessibilityEvent . obtain ( ) ; event . setEventType ( AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED ) ; AccessibilityEventCompat . setContentChangeTypes ( event , flags ) ; sendAccessibilityEventUnchecked ( event ) ; } } public boolean isComputingLayout ( ) { return mLayoutOrScrollCounter > <NUM_LIT> ; } boolean shouldDeferAccessibilityEvent ( AccessibilityEvent event ) { if ( isComputingLayout ( ) ) { int type = <NUM_LIT> ; if ( event != null ) { type = AccessibilityEventCompat . getContentChangeTypes ( event ) ; } if ( type == <NUM_LIT> ) { type = AccessibilityEventCompat . CONTENT_CHANGE_TYPE_UNDEFINED ; } mEatenAccessibilityChangeFlags |= type ; return true ; } return false ; } @ Override public void sendAccessibilityEventUnchecked ( AccessibilityEvent event ) { if ( shouldDeferAccessibilityEvent ( event ) ) { return ; } super . sendAccessibilityEventUnchecked ( event ) ; } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { onPopulateAccessibilityEvent ( event ) ; return true ; } @ Nullable public ItemAnimator getItemAnimator ( ) { return mItemAnimator ; } void postAnimationRunner ( ) { if ( ! mPostedAnimatorRunner && mIsAttached ) { ViewCompat . postOnAnimation ( this , mItemAnimatorRunner ) ; mPostedAnimatorRunner = true ; } } private boolean predictiveItemAnimationsEnabled ( ) { return ( mItemAnimator != null && mLayout . supportsPredictiveItemAnimations ( ) ) ; } private void processAdapterUpdatesAndSetAnimationFlags ( ) { if ( mDataSetHasChangedAfterLayout ) { mAdapterHelper . reset ( ) ; if ( mDispatchItemsChangedEvent ) { mLayout . onItemsChanged ( this ) ; } } if ( predictiveItemAnimationsEnabled ( ) ) { mAdapterHelper . preProcess ( ) ; } else { mAdapterHelper . consumeUpdatesInOnePass ( ) ; } boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged ; mState . mRunSimpleAnimations = mFirstLayoutComplete && mItemAnimator != null && ( mDataSetHasChangedAfterLayout || animationTypeSupported || mLayout . mRequestedSimpleAnimations ) && ( ! mDataSetHasChangedAfterLayout || mAdapter . hasStableIds ( ) ) ; mState . mRunPredictiveAnimations = mState . mRunSimpleAnimations && animationTypeSupported && ! mDataSetHasChangedAfterLayout && predictiveItemAnimationsEnabled ( ) ; } void dispatchLayout ( ) { if ( mAdapter == null ) { Log . w ( TAG , "<STR_LIT>" ) ; return ; } if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } mState . mIsMeasuring = false ; boolean needsRemeasureDueToExactSkip = mLastAutoMeasureSkippedDueToExact && ( mLastAutoMeasureNonExactMeasuredWidth != getWidth ( ) || mLastAutoMeasureNonExactMeasuredHeight != getHeight ( ) ) ; mLastAutoMeasureNonExactMeasuredWidth = <NUM_LIT> ; mLastAutoMeasureNonExactMeasuredHeight = <NUM_LIT> ; mLastAutoMeasureSkippedDueToExact = false ; if ( mState . mLayoutStep == State . STEP_START ) { dispatchLayoutStep1 ( ) ; mLayout . setExactMeasureSpecsFrom ( this ) ; dispatchLayoutStep2 ( ) ; } else if ( mAdapterHelper . hasUpdates ( ) || needsRemeasureDueToExactSkip || mLayout . getWidth ( ) != getWidth ( ) || mLayout . getHeight ( ) != getHeight ( ) ) { mLayout . setExactMeasureSpecsFrom ( this ) ; dispatchLayoutStep2 ( ) ; } else { mLayout . setExactMeasureSpecsFrom ( this ) ; } dispatchLayoutStep3 ( ) ; } private void saveFocusInfo ( ) { View child = null ; if ( mPreserveFocusAfterLayout && hasFocus ( ) && mAdapter != null ) { child = getFocusedChild ( ) ; } final ViewHolder focusedVh = child == null ? null : findContainingViewHolder ( child ) ; if ( focusedVh == null ) { resetFocusInfo ( ) ; } else { mState . mFocusedItemId = mAdapter . hasStableIds ( ) ? focusedVh . getItemId ( ) : NO_ID ; mState . mFocusedItemPosition = mDataSetHasChangedAfterLayout ? NO_POSITION : ( focusedVh . isRemoved ( ) ? focusedVh . mOldPosition : focusedVh . getAbsoluteAdapterPosition ( ) ) ; mState . mFocusedSubChildId = getDeepestFocusedViewWithId ( focusedVh . itemView ) ; } } private void resetFocusInfo ( ) { mState . mFocusedItemId = NO_ID ; mState . mFocusedItemPosition = NO_POSITION ; mState . mFocusedSubChildId = View . NO_ID ; } @ Nullable private View findNextViewToFocus ( ) { int startFocusSearchIndex = mState . mFocusedItemPosition != - <NUM_LIT> ? mState . mFocusedItemPosition : <NUM_LIT> ; ViewHolder nextFocus ; final int itemCount = mState . getItemCount ( ) ; for ( int i = startFocusSearchIndex ; i < itemCount ; i ++ ) { nextFocus = findViewHolderForAdapterPosition ( i ) ; if ( nextFocus == null ) { break ; } if ( nextFocus . itemView . hasFocusable ( ) ) { return nextFocus . itemView ; } } final int limit = Math . min ( itemCount , startFocusSearchIndex ) ; for ( int i = limit - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { nextFocus = findViewHolderForAdapterPosition ( i ) ; if ( nextFocus == null ) { return null ; } if ( nextFocus . itemView . hasFocusable ( ) ) { return nextFocus . itemView ; } } return null ; } private void recoverFocusFromState ( ) { if ( ! mPreserveFocusAfterLayout || mAdapter == null || ! hasFocus ( ) || getDescendantFocusability ( ) == FOCUS_BLOCK_DESCENDANTS || ( getDescendantFocusability ( ) == FOCUS_BEFORE_DESCENDANTS && isFocused ( ) ) ) { return ; } if ( ! isFocused ( ) ) { final View focusedChild = getFocusedChild ( ) ; if ( IGNORE_DETACHED_FOCUSED_CHILD && ( focusedChild . getParent ( ) == null || ! focusedChild . hasFocus ( ) ) ) { if ( mChildHelper . getChildCount ( ) == <NUM_LIT> ) { requestFocus ( ) ; return ; } } else if ( ! mChildHelper . isHidden ( focusedChild ) ) { return ; } } ViewHolder focusTarget = null ; if ( mState . mFocusedItemId != NO_ID && mAdapter . hasStableIds ( ) ) { focusTarget = findViewHolderForItemId ( mState . mFocusedItemId ) ; } View viewToFocus = null ; if ( focusTarget == null || mChildHelper . isHidden ( focusTarget . itemView ) || ! focusTarget . itemView . hasFocusable ( ) ) { if ( mChildHelper . getChildCount ( ) > <NUM_LIT> ) { viewToFocus = findNextViewToFocus ( ) ; } } else { viewToFocus = focusTarget . itemView ; } if ( viewToFocus != null ) { if ( mState . mFocusedSubChildId != NO_ID ) { View child = viewToFocus . findViewById ( mState . mFocusedSubChildId ) ; if ( child != null && child . isFocusable ( ) ) { viewToFocus = child ; } } viewToFocus . requestFocus ( ) ; } } private int getDeepestFocusedViewWithId ( View view ) { int lastKnownId = view . getId ( ) ; while ( ! view . isFocused ( ) && view instanceof ViewGroup && view . hasFocus ( ) ) { view = ( ( ViewGroup ) view ) . getFocusedChild ( ) ; final int id = view . getId ( ) ; if ( id != View . NO_ID ) { lastKnownId = view . getId ( ) ; } } return lastKnownId ; } final void fillRemainingScrollValues ( State state ) { if ( getScrollState ( ) == SCROLL_STATE_SETTLING ) { final OverScrollerAdapter scroller = mViewFlinger . mOverScroller ; state . mRemainingScrollHorizontal = scroller . getFinalX ( ) - scroller . getCurrX ( ) ; state . mRemainingScrollVertical = scroller . getFinalY ( ) - scroller . getCurrY ( ) ; } else { state . mRemainingScrollHorizontal = <NUM_LIT> ; state . mRemainingScrollVertical = <NUM_LIT> ; } } private void dispatchLayoutStep1 ( ) { mState . assertLayoutStep ( State . STEP_START ) ; fillRemainingScrollValues ( mState ) ; mState . mIsMeasuring = false ; startInterceptRequestLayout ( ) ; mViewInfoStore . clear ( ) ; onEnterLayoutOrScroll ( ) ; processAdapterUpdatesAndSetAnimationFlags ( ) ; saveFocusInfo ( ) ; mState . mTrackOldChangeHolders = mState . mRunSimpleAnimations && mItemsChanged ; mItemsAddedOrRemoved = mItemsChanged = false ; mState . mInPreLayout = mState . mRunPredictiveAnimations ; mState . mItemCount = mAdapter . getItemCount ( ) ; findMinMaxChildLayoutPositions ( mMinMaxLayoutPositions ) ; if ( mState . mRunSimpleAnimations ) { int count = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) || ( holder . isInvalid ( ) && ! mAdapter . hasStableIds ( ) ) ) { continue ; } final ItemHolderInfo animationInfo = mItemAnimator . recordPreLayoutInformation ( mState , holder , ItemAnimator . buildAdapterChangeFlagsForAnimations ( holder ) , holder . getUnmodifiedPayloads ( ) ) ; mViewInfoStore . addToPreLayout ( holder , animationInfo ) ; if ( mState . mTrackOldChangeHolders && holder . isUpdated ( ) && ! holder . isRemoved ( ) && ! holder . shouldIgnore ( ) && ! holder . isInvalid ( ) ) { long key = getChangedHolderKey ( holder ) ; mViewInfoStore . addToOldChangeHolders ( key , holder ) ; } } } if ( mState . mRunPredictiveAnimations ) { saveOldPositions ( ) ; final boolean didStructureChange = mState . mStructureChanged ; mState . mStructureChanged = false ; mLayout . onLayoutChildren ( mRecycler , mState ) ; mState . mStructureChanged = didStructureChange ; for ( int i = <NUM_LIT> ; i < mChildHelper . getChildCount ( ) ; ++ i ) { final View child = mChildHelper . getChildAt ( i ) ; final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; if ( viewHolder . shouldIgnore ( ) ) { continue ; } if ( ! mViewInfoStore . isInPreLayout ( viewHolder ) ) { int flags = ItemAnimator . buildAdapterChangeFlagsForAnimations ( viewHolder ) ; boolean wasHidden = viewHolder . hasAnyOfTheFlags ( ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( ! wasHidden ) { flags |= ItemAnimator . FLAG_APPEARED_IN_PRE_LAYOUT ; } final ItemHolderInfo animationInfo = mItemAnimator . recordPreLayoutInformation ( mState , viewHolder , flags , viewHolder . getUnmodifiedPayloads ( ) ) ; if ( wasHidden ) { recordAnimationInfoIfBouncedHiddenView ( viewHolder , animationInfo ) ; } else { mViewInfoStore . addToAppearedInPreLayoutHolders ( viewHolder , animationInfo ) ; } } } clearOldPositions ( ) ; } else { clearOldPositions ( ) ; } onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; mState . mLayoutStep = State . STEP_LAYOUT ; } private void dispatchLayoutStep2 ( ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mState . assertLayoutStep ( State . STEP_LAYOUT | State . STEP_ANIMATIONS ) ; mAdapterHelper . consumeUpdatesInOnePass ( ) ; mState . mItemCount = mAdapter . getItemCount ( ) ; mState . mDeletedInvisibleItemCountSincePreviousLayout = <NUM_LIT> ; if ( mPendingSavedState != null && mAdapter . canRestoreState ( ) ) { if ( mPendingSavedState . mLayoutState != null ) { mLayout . onRestoreInstanceState ( mPendingSavedState . mLayoutState ) ; } mPendingSavedState = null ; } mState . mInPreLayout = false ; mLayout . onLayoutChildren ( mRecycler , mState ) ; mState . mStructureChanged = false ; mState . mRunSimpleAnimations = mState . mRunSimpleAnimations && mItemAnimator != null ; mState . mLayoutStep = State . STEP_ANIMATIONS ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; } private void dispatchLayoutStep3 ( ) { mState . assertLayoutStep ( State . STEP_ANIMATIONS ) ; startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mState . mLayoutStep = State . STEP_START ; if ( mState . mRunSimpleAnimations ) { for ( int i = mChildHelper . getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) ) { continue ; } long key = getChangedHolderKey ( holder ) ; final ItemHolderInfo animationInfo = mItemAnimator . recordPostLayoutInformation ( mState , holder ) ; ViewHolder oldChangeViewHolder = mViewInfoStore . getFromOldChangeHolders ( key ) ; if ( oldChangeViewHolder != null && ! oldChangeViewHolder . shouldIgnore ( ) ) { final boolean oldDisappearing = mViewInfoStore . isDisappearing ( oldChangeViewHolder ) ; final boolean newDisappearing = mViewInfoStore . isDisappearing ( holder ) ; if ( oldDisappearing && oldChangeViewHolder == holder ) { mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; } else { final ItemHolderInfo preInfo = mViewInfoStore . popFromPreLayout ( oldChangeViewHolder ) ; mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; ItemHolderInfo postInfo = mViewInfoStore . popFromPostLayout ( holder ) ; if ( preInfo == null ) { handleMissingPreInfoForChangeError ( key , holder , oldChangeViewHolder ) ; } else { animateChange ( oldChangeViewHolder , holder , preInfo , postInfo , oldDisappearing , newDisappearing ) ; } } } else { mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; } } mViewInfoStore . process ( mViewInfoProcessCallback ) ; } mLayout . removeAndRecycleScrapInt ( mRecycler ) ; mState . mPreviousLayoutItemCount = mState . mItemCount ; mDataSetHasChangedAfterLayout = false ; mDispatchItemsChangedEvent = false ; mState . mRunSimpleAnimations = false ; mState . mRunPredictiveAnimations = false ; mLayout . mRequestedSimpleAnimations = false ; if ( mRecycler . mChangedScrap != null ) { mRecycler . mChangedScrap . clear ( ) ; } if ( mLayout . mPrefetchMaxObservedInInitialPrefetch ) { mLayout . mPrefetchMaxCountObserved = <NUM_LIT> ; mLayout . mPrefetchMaxObservedInInitialPrefetch = false ; mRecycler . updateViewCacheSize ( ) ; } mLayout . onLayoutCompleted ( mState ) ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; mViewInfoStore . clear ( ) ; if ( didChildRangeChange ( mMinMaxLayoutPositions [ <NUM_LIT> ] , mMinMaxLayoutPositions [ <NUM_LIT> ] ) ) { dispatchOnScrolled ( <NUM_LIT> , <NUM_LIT> ) ; } recoverFocusFromState ( ) ; resetFocusInfo ( ) ; } private void handleMissingPreInfoForChangeError ( long key , ViewHolder holder , ViewHolder oldChangeViewHolder ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mChildHelper . getChildAt ( i ) ; ViewHolder other = getChildViewHolderInt ( view ) ; if ( other == holder ) { continue ; } final long otherKey = getChangedHolderKey ( other ) ; if ( otherKey == key ) { if ( mAdapter != null && mAdapter . hasStableIds ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + other + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } else { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + other + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } } } Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" + oldChangeViewHolder + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } void recordAnimationInfoIfBouncedHiddenView ( ViewHolder viewHolder , ItemHolderInfo animationInfo ) { viewHolder . setFlags ( <NUM_LIT> , ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( mState . mTrackOldChangeHolders && viewHolder . isUpdated ( ) && ! viewHolder . isRemoved ( ) && ! viewHolder . shouldIgnore ( ) ) { long key = getChangedHolderKey ( viewHolder ) ; mViewInfoStore . addToOldChangeHolders ( key , viewHolder ) ; } mViewInfoStore . addToPreLayout ( viewHolder , animationInfo ) ; } private void findMinMaxChildLayoutPositions ( int [ ] into ) { final int count = mChildHelper . getChildCount ( ) ; if ( count == <NUM_LIT> ) { into [ <NUM_LIT> ] = NO_POSITION ; into [ <NUM_LIT> ] = NO_POSITION ; return ; } int minPositionPreLayout = Integer . MAX_VALUE ; int maxPositionPreLayout = Integer . MIN_VALUE ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) ) { continue ; } final int pos = holder . getLayoutPosition ( ) ; if ( pos < minPositionPreLayout ) { minPositionPreLayout = pos ; } if ( pos > maxPositionPreLayout ) { maxPositionPreLayout = pos ; } } into [ <NUM_LIT> ] = minPositionPreLayout ; into [ <NUM_LIT> ] = maxPositionPreLayout ; } private boolean didChildRangeChange ( int minPositionPreLayout , int maxPositionPreLayout ) { findMinMaxChildLayoutPositions ( mMinMaxLayoutPositions ) ; return mMinMaxLayoutPositions [ <NUM_LIT> ] != minPositionPreLayout || mMinMaxLayoutPositions [ <NUM_LIT> ] != maxPositionPreLayout ; } @ Override protected void removeDetachedView ( View child , boolean animate ) { ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { if ( vh . isTmpDetached ( ) ) { vh . clearTmpDetachFlag ( ) ; } else if ( ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + exceptionLabel ( ) ) ; } } child . clearAnimation ( ) ; dispatchChildDetached ( child ) ; super . removeDetachedView ( child , animate ) ; } long getChangedHolderKey ( ViewHolder holder ) { return mAdapter . hasStableIds ( ) ? holder . getItemId ( ) : holder . mPosition ; } void animateAppearance ( @ NonNull ViewHolder itemHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { itemHolder . setIsRecyclable ( false ) ; if ( mItemAnimator . animateAppearance ( itemHolder , preLayoutInfo , postLayoutInfo ) ) { postAnimationRunner ( ) ; } } void animateDisappearance ( @ NonNull ViewHolder holder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { addAnimatingView ( holder ) ; holder . setIsRecyclable ( false ) ; if ( mItemAnimator . animateDisappearance ( holder , preLayoutInfo , postLayoutInfo ) ) { postAnimationRunner ( ) ; } } private void animateChange ( @ NonNull ViewHolder oldHolder , @ NonNull ViewHolder newHolder , @ NonNull ItemHolderInfo preInfo , @ NonNull ItemHolderInfo postInfo , boolean oldHolderDisappearing , boolean newHolderDisappearing ) { oldHolder . setIsRecyclable ( false ) ; if ( oldHolderDisappearing ) { addAnimatingView ( oldHolder ) ; } if ( oldHolder != newHolder ) { if ( newHolderDisappearing ) { addAnimatingView ( newHolder ) ; } oldHolder . mShadowedHolder = newHolder ; addAnimatingView ( oldHolder ) ; mRecycler . unscrapView ( oldHolder ) ; newHolder . setIsRecyclable ( false ) ; newHolder . mShadowingHolder = oldHolder ; } if ( mItemAnimator . animateChange ( oldHolder , newHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { TraceCompat . beginSection ( TRACE_ON_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; mFirstLayoutComplete = true ; } @ Override public void requestLayout ( ) { if ( mInterceptRequestLayoutDepth == <NUM_LIT> && ! mLayoutSuppressed ) { super . requestLayout ( ) ; } else { mLayoutWasDefered = true ; } } void markItemDecorInsetsDirty ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = mChildHelper . getUnfilteredChildAt ( i ) ; ( ( LayoutParams ) child . getLayoutParams ( ) ) . mInsetsDirty = true ; } mRecycler . markItemDecorInsetsDirty ( ) ; } @ Override public void draw ( Canvas c ) { c . save ( ) ; boolean needsInvalidate = false ; if ( mHorizontalEdgeEffect != null && ! mHorizontalEdgeEffect . isFinished ( ) ) { mHorizontalEdgeEffect . computeScrollOffset ( ) ; c . translate ( mHorizontalEdgeEffect . getDistance ( ) , <NUM_LIT> ) ; needsInvalidate = true ; } if ( mVerticalEdgeEffect != null && ! mVerticalEdgeEffect . isFinished ( ) ) { mVerticalEdgeEffect . computeScrollOffset ( ) ; c . translate ( <NUM_LIT> , mVerticalEdgeEffect . getDistance ( ) ) ; needsInvalidate = true ; } super . draw ( c ) ; final int count = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mItemDecorations . get ( i ) . onDrawOver ( c , this , mState ) ; } c . restore ( ) ; if ( ! needsInvalidate && mItemAnimator != null && mItemDecorations . size ( ) > <NUM_LIT> && mItemAnimator . isRunning ( ) ) { needsInvalidate = true ; } if ( needsInvalidate ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } @ Override public void onDraw ( Canvas c ) { super . onDraw ( c ) ; final int count = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mItemDecorations . get ( i ) . onDraw ( c , this , mState ) ; } } @ Override protected boolean checkLayoutParams ( ViewGroup . LayoutParams p ) { return p instanceof LayoutParams && mLayout . checkLayoutParams ( ( LayoutParams ) p ) ; } @ Override protected ViewGroup . LayoutParams generateDefaultLayoutParams ( ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateDefaultLayoutParams ( ) ; } @ Override public ViewGroup . LayoutParams generateLayoutParams ( AttributeSet attrs ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateLayoutParams ( getContext ( ) , attrs ) ; } @ Override protected ViewGroup . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams p ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateLayoutParams ( p ) ; } public boolean isAnimating ( ) { return mItemAnimator != null && mItemAnimator . isRunning ( ) ; } void saveOldPositions ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( sDebugAssertionsEnabled && holder . mPosition == - <NUM_LIT> && ! holder . isRemoved ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } if ( ! holder . shouldIgnore ( ) ) { holder . saveOldPosition ( ) ; } } } void clearOldPositions ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( ! holder . shouldIgnore ( ) ) { holder . clearOldPosition ( ) ; } } mRecycler . clearOldPositions ( ) ; } void offsetPositionRecordsForMove ( int from , int to ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; final int start , end , inBetweenOffset ; if ( from < to ) { start = from ; end = to ; inBetweenOffset = - <NUM_LIT> ; } else { start = to ; end = from ; inBetweenOffset = <NUM_LIT> ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder == null || holder . mPosition < start || holder . mPosition > end ) { continue ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder ) ; } if ( holder . mPosition == from ) { holder . offsetPosition ( to - from , false ) ; } else { holder . offsetPosition ( inBetweenOffset , false ) ; } mState . mStructureChanged = true ; } mRecycler . offsetPositionRecordsForMove ( from , to ) ; requestLayout ( ) ; } void offsetPositionRecordsForInsert ( int positionStart , int itemCount ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) && holder . mPosition >= positionStart ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition + itemCount ) ) ; } holder . offsetPosition ( itemCount , false ) ; mState . mStructureChanged = true ; } } mRecycler . offsetPositionRecordsForInsert ( positionStart , itemCount ) ; requestLayout ( ) ; } void offsetPositionRecordsForRemove ( int positionStart , int itemCount , boolean applyToPreLayout ) { final int positionEnd = positionStart + itemCount ; final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) ) { if ( holder . mPosition >= positionEnd ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition - itemCount ) ) ; } holder . offsetPosition ( - itemCount , applyToPreLayout ) ; mState . mStructureChanged = true ; } else if ( holder . mPosition >= positionStart ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" ) ; } holder . flagRemovedAndOffsetPosition ( positionStart - <NUM_LIT> , - itemCount , applyToPreLayout ) ; mState . mStructureChanged = true ; } } } mRecycler . offsetPositionRecordsForRemove ( positionStart , itemCount , applyToPreLayout ) ; requestLayout ( ) ; } void viewRangeUpdate ( int positionStart , int itemCount , Object payload ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; final int positionEnd = positionStart + itemCount ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = mChildHelper . getUnfilteredChildAt ( i ) ; final ViewHolder holder = getChildViewHolderInt ( child ) ; if ( holder == null || holder . shouldIgnore ( ) ) { continue ; } if ( holder . mPosition >= positionStart && holder . mPosition < positionEnd ) { holder . addFlags ( ViewHolder . FLAG_UPDATE ) ; holder . addChangePayload ( payload ) ; ( ( LayoutParams ) child . getLayoutParams ( ) ) . mInsetsDirty = true ; } } mRecycler . viewRangeUpdate ( positionStart , itemCount ) ; } boolean canReuseUpdatedViewHolder ( ViewHolder viewHolder ) { return mItemAnimator == null || mItemAnimator . canReuseUpdatedViewHolder ( viewHolder , viewHolder . getUnmodifiedPayloads ( ) ) ; } void processDataSetCompletelyChanged ( boolean dispatchItemsChanged ) { mDispatchItemsChangedEvent |= dispatchItemsChanged ; mDataSetHasChangedAfterLayout = true ; markKnownViewsInvalid ( ) ; } void markKnownViewsInvalid ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) ) { holder . addFlags ( ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID ) ; } } markItemDecorInsetsDirty ( ) ; mRecycler . markKnownViewsInvalid ( ) ; } public void invalidateItemDecorations ( ) { if ( mItemDecorations . size ( ) == <NUM_LIT> ) { return ; } if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public boolean getPreserveFocusAfterLayout ( ) { return mPreserveFocusAfterLayout ; } public void setPreserveFocusAfterLayout ( boolean preserveFocusAfterLayout ) { mPreserveFocusAfterLayout = preserveFocusAfterLayout ; } public ViewHolder getChildViewHolder ( @ NonNull View child ) { final ViewParent parent = child . getParent ( ) ; if ( parent != null && parent != this ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + "<STR_LIT>" + this ) ; } return getChildViewHolderInt ( child ) ; } @ Nullable public View findContainingItemView ( @ NonNull View view ) { ViewParent parent = view . getParent ( ) ; while ( parent != null && parent != this && parent instanceof View ) { view = ( View ) parent ; parent = view . getParent ( ) ; } return parent == this ? view : null ; } @ Nullable public ViewHolder findContainingViewHolder ( @ NonNull View view ) { View itemView = findContainingItemView ( view ) ; return itemView == null ? null : getChildViewHolder ( itemView ) ; } static ViewHolder getChildViewHolderInt ( View child ) { if ( child == null ) { return null ; } return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mViewHolder ; } @ Deprecated public int getChildPosition ( @ NonNull View child ) { return getChildAdapterPosition ( child ) ; } public int getChildAdapterPosition ( @ NonNull View child ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getAbsoluteAdapterPosition ( ) : NO_POSITION ; } public int getChildLayoutPosition ( @ NonNull View child ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getLayoutPosition ( ) : NO_POSITION ; } public long getChildItemId ( @ NonNull View child ) { if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { return NO_ID ; } final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getItemId ( ) : NO_ID ; } @ Deprecated @ Nullable public ViewHolder findViewHolderForPosition ( int position ) { return findViewHolderForPosition ( position , false ) ; } @ Nullable public ViewHolder findViewHolderForLayoutPosition ( int position ) { return findViewHolderForPosition ( position , false ) ; } @ Nullable public ViewHolder findViewHolderForAdapterPosition ( int position ) { if ( mDataSetHasChangedAfterLayout ) { return null ; } final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) && getAdapterPositionInRecyclerView ( holder ) == position ) { if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } @ Nullable ViewHolder findViewHolderForPosition ( int position , boolean checkNewPosition ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) ) { if ( checkNewPosition ) { if ( holder . mPosition != position ) { continue ; } } else if ( holder . getLayoutPosition ( ) != position ) { continue ; } if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } public ViewHolder findViewHolderForItemId ( long id ) { if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { return null ; } final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) && holder . getItemId ( ) == id ) { if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } @ Nullable public View findChildViewUnder ( float x , float y ) { final int count = mChildHelper . getChildCount ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View child = mChildHelper . getChildAt ( i ) ; final float translationX = child . getTranslationX ( ) ; final float translationY = child . getTranslationY ( ) ; if ( x >= child . getLeft ( ) + translationX && x <= child . getRight ( ) + translationX && y >= child . getTop ( ) + translationY && y <= child . getBottom ( ) + translationY ) { return child ; } } return null ; } @ Override public boolean drawChild ( Canvas canvas , View child , long drawingTime ) { return super . drawChild ( canvas , child , drawingTime ) ; } public void offsetChildrenVertical ( @ Px int dy ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { mChildHelper . getChildAt ( i ) . offsetTopAndBottom ( dy ) ; } } public void onChildAttachedToWindow ( @ NonNull View child ) { } public void onChildDetachedFromWindow ( @ NonNull View child ) { } public void offsetChildrenHorizontal ( @ Px int dx ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { mChildHelper . getChildAt ( i ) . offsetLeftAndRight ( dx ) ; } } public void getDecoratedBoundsWithMargins ( @ NonNull View view , @ NonNull Rect outBounds ) { getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } static void getDecoratedBoundsWithMarginsInt ( View view , Rect outBounds ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect insets = lp . mDecorInsets ; outBounds . set ( view . getLeft ( ) - insets . left - lp . leftMargin , view . getTop ( ) - insets . top - lp . topMargin , view . getRight ( ) + insets . right + lp . rightMargin , view . getBottom ( ) + insets . bottom + lp . bottomMargin ) ; } Rect getItemDecorInsetsForChild ( View child ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . mInsetsDirty ) { return lp . mDecorInsets ; } if ( mState . isPreLayout ( ) && ( lp . isItemChanged ( ) || lp . isViewInvalid ( ) ) ) { return lp . mDecorInsets ; } final Rect insets = lp . mDecorInsets ; insets . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; final int decorCount = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < decorCount ; i ++ ) { mTempRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mItemDecorations . get ( i ) . getItemOffsets ( mTempRect , child , this , mState ) ; insets . left += mTempRect . left ; insets . top += mTempRect . top ; insets . right += mTempRect . right ; insets . bottom += mTempRect . bottom ; } lp . mInsetsDirty = false ; return insets ; } public void onScrolled ( @ Px int dx , @ Px int dy ) { } void dispatchOnScrolled ( int hresult , int vresult ) { mDispatchScrollCounter ++ ; final int scrollX = getScrollX ( ) ; final int scrollY = getScrollY ( ) ; onScrollChanged ( scrollX , scrollY , scrollX - hresult , scrollY - vresult ) ; onScrolled ( hresult , vresult ) ; if ( mScrollListener != null ) { mScrollListener . onScrolled ( this , hresult , vresult ) ; } if ( mScrollListeners != null ) { for ( int i = mScrollListeners . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mScrollListeners . get ( i ) . onScrolled ( this , hresult , vresult ) ; } } mDispatchScrollCounter -- ; } public void onScrollStateChanged ( int state ) { } private float getSplineFlingDistance ( int velocity ) { final double l = Math . log ( INFLEXION * Math . abs ( velocity ) / ( SCROLL_FRICTION * mPhysicalCoef ) ) ; final double decelMinusOne = DECELERATION_RATE - <NUM_LIT> ; return ( float ) ( SCROLL_FRICTION * mPhysicalCoef * Math . exp ( DECELERATION_RATE / decelMinusOne * l ) ) ; } void dispatchOnScrollStateChanged ( int state ) { if ( mLayout != null ) { mLayout . onScrollStateChanged ( state ) ; } onScrollStateChanged ( state ) ; if ( mScrollListener != null ) { mScrollListener . onScrollStateChanged ( this , state ) ; } if ( mScrollListeners != null ) { for ( int i = mScrollListeners . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mScrollListeners . get ( i ) . onScrollStateChanged ( this , state ) ; } } } public boolean hasPendingAdapterUpdates ( ) { return ! mFirstLayoutComplete || mDataSetHasChangedAfterLayout || mAdapterHelper . hasPendingUpdates ( ) ; } class ViewFlinger implements Runnable { private int mLastFlingX ; private int mLastFlingY ; OverScrollerAdapter mOverScroller ; Interpolator mInterpolator = sQuinticInterpolator ; private boolean mEatRunOnAnimationRequest = false ; private boolean mReSchedulePostAnimationCallback = false ; ViewFlinger ( ) { mOverScroller = new OverScrollerAdapter ( getContext ( ) , sQuinticInterpolator ) ; } @ Override public void run ( ) { if ( mLayout == null ) { stop ( ) ; return ; } mReSchedulePostAnimationCallback = false ; mEatRunOnAnimationRequest = true ; consumePendingUpdateOperations ( ) ; final OverScrollerAdapter scroller = mOverScroller ; if ( scroller . computeScrollOffset ( ) ) { final int x = scroller . getCurrX ( ) ; final int y = scroller . getCurrY ( ) ; int unconsumedX = x - mLastFlingX ; int unconsumedY = y - mLastFlingY ; mLastFlingX = x ; mLastFlingY = y ; unconsumedX = consumeFlingInHorizontalStretch ( unconsumedX ) ; unconsumedY = consumeFlingInVerticalStretch ( unconsumedY ) ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; if ( dispatchNestedPreScroll ( unconsumedX , unconsumedY , mReusableIntPair , null , TYPE_NON_TOUCH ) ) { unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; } if ( mAdapter != null ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; scrollStep ( unconsumedX , unconsumedY , mReusableIntPair ) ; consumedX = mReusableIntPair [ <NUM_LIT> ] ; consumedY = mReusableIntPair [ <NUM_LIT> ] ; unconsumedX -= consumedX ; unconsumedY -= consumedY ; SmoothScroller smoothScroller = mLayout . mSmoothScroller ; if ( smoothScroller != null && ! smoothScroller . isPendingInitialRun ( ) && smoothScroller . isRunning ( ) ) { final int adapterSize = mState . getItemCount ( ) ; if ( adapterSize == <NUM_LIT> ) { smoothScroller . stop ( ) ; } else if ( smoothScroller . getTargetPosition ( ) >= adapterSize ) { smoothScroller . setTargetPosition ( adapterSize - <NUM_LIT> ) ; smoothScroller . onAnimation ( consumedX , consumedY ) ; } else { smoothScroller . onAnimation ( consumedX , consumedY ) ; } } } if ( ! mItemDecorations . isEmpty ( ) ) { invalidate ( ) ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( consumedX , consumedY , unconsumedX , unconsumedY , null , TYPE_NON_TOUCH , mReusableIntPair ) ; unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; if ( consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ) { dispatchOnScrolled ( consumedX , consumedY ) ; } if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } boolean scrollerFinishedX = scroller . getCurrX ( ) == scroller . getFinalX ( ) ; boolean scrollerFinishedY = scroller . getCurrY ( ) == scroller . getFinalY ( ) ; final boolean doneScrolling = scroller . isFinished ( ) || ( ( scrollerFinishedX || unconsumedX != <NUM_LIT> ) && ( scrollerFinishedY || unconsumedY != <NUM_LIT> ) ) ; SmoothScroller smoothScroller = mLayout . mSmoothScroller ; boolean smoothScrollerPending = smoothScroller != null && smoothScroller . isPendingInitialRun ( ) ; if ( ! smoothScrollerPending && doneScrolling ) { if ( getOverScrollMode ( ) != View . OVER_SCROLL_NEVER ) { final int vel = ( int ) scroller . getCurrVelocity ( ) ; int velX = unconsumedX < <NUM_LIT> ? vel : unconsumedX > <NUM_LIT> ? - vel : <NUM_LIT> ; int velY = unconsumedY < <NUM_LIT> ? vel : unconsumedY > <NUM_LIT> ? - vel : <NUM_LIT> ; absorbGlows ( velX , velY ) ; } if ( ALLOW_THREAD_GAP_WORK ) { mPrefetchRegistry . clearPrefetchPositions ( ) ; } } else { postOnAnimation ( ) ; if ( mGapWorker != null ) { mGapWorker . postFromTraversal ( RecyclerView . this , consumedX , consumedY ) ; } } } SmoothScroller smoothScroller = mLayout . mSmoothScroller ; if ( smoothScroller != null && smoothScroller . isPendingInitialRun ( ) ) { smoothScroller . onAnimation ( <NUM_LIT> , <NUM_LIT> ) ; } mEatRunOnAnimationRequest = false ; if ( mReSchedulePostAnimationCallback ) { internalPostOnAnimation ( ) ; } else { setScrollState ( SCROLL_STATE_IDLE ) ; stopNestedScroll ( TYPE_NON_TOUCH ) ; } } void postOnAnimation ( ) { if ( mEatRunOnAnimationRequest ) { mReSchedulePostAnimationCallback = true ; } else { internalPostOnAnimation ( ) ; } } private void internalPostOnAnimation ( ) { removeCallbacks ( this ) ; ViewCompat . postOnAnimation ( RecyclerView . this , this ) ; } public void fling ( int velocityX , int velocityY ) { setScrollState ( SCROLL_STATE_SETTLING ) ; mLastFlingX = mLastFlingY = <NUM_LIT> ; if ( mInterpolator != sQuinticInterpolator ) { mInterpolator = sQuinticInterpolator ; mOverScroller = new OverScrollerAdapter ( getContext ( ) , sQuinticInterpolator ) ; } mOverScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; postOnAnimation ( ) ; } public void smoothScrollBy ( int dx , int dy , int duration , @ Nullable Interpolator interpolator ) { if ( duration == UNDEFINED_DURATION ) { duration = computeScrollDuration ( dx , dy ) ; } if ( interpolator == null ) { interpolator = sQuinticInterpolator ; } if ( mInterpolator != interpolator ) { mInterpolator = interpolator ; mOverScroller = new OverScrollerAdapter ( getContext ( ) , interpolator ) ; } mLastFlingX = mLastFlingY = <NUM_LIT> ; setScrollState ( SCROLL_STATE_SETTLING ) ; mOverScroller . startScroll ( <NUM_LIT> , <NUM_LIT> , dx , dy , duration ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { mOverScroller . computeScrollOffset ( ) ; } postOnAnimation ( ) ; } private int computeScrollDuration ( int dx , int dy ) { final int absDx = Math . abs ( dx ) ; final int absDy = Math . abs ( dy ) ; final boolean horizontal = absDx > absDy ; final int containerSize = horizontal ? getWidth ( ) : getHeight ( ) ; float absDelta = ( float ) ( horizontal ? absDx : absDy ) ; final int duration = ( int ) ( ( ( absDelta / containerSize ) + <NUM_LIT> ) * <NUM_LIT> ) ; return Math . min ( duration , MAX_SCROLL_DURATION ) ; } public void stop ( ) { removeCallbacks ( this ) ; mOverScroller . abortAnimation ( ) ; } } void repositionShadowingViews ( ) { int count = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mChildHelper . getChildAt ( i ) ; ViewHolder holder = getChildViewHolder ( view ) ; if ( holder != null && holder . mShadowingHolder != null ) { View shadowingView = holder . mShadowingHolder . itemView ; int left = view . getLeft ( ) ; int top = view . getTop ( ) ; if ( left != shadowingView . getLeft ( ) || top != shadowingView . getTop ( ) ) { shadowingView . layout ( left , top , left + shadowingView . getWidth ( ) , top + shadowingView . getHeight ( ) ) ; } } } } private class RecyclerViewDataObserver extends AdapterDataObserver { RecyclerViewDataObserver ( ) { } @ Override public void onChanged ( ) { assertNotInLayoutOrScroll ( null ) ; mState . mStructureChanged = true ; processDataSetCompletelyChanged ( true ) ; if ( ! mAdapterHelper . hasPendingUpdates ( ) ) { requestLayout ( ) ; } } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeChanged ( positionStart , itemCount , payload ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeInserted ( positionStart , itemCount ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeRemoved ( positionStart , itemCount ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeMoved ( fromPosition , toPosition , itemCount ) ) { triggerUpdateProcessor ( ) ; } } void triggerUpdateProcessor ( ) { if ( POST_UPDATES_ON_ANIMATION && mHasFixedSize && mIsAttached ) { ViewCompat . postOnAnimation ( RecyclerView . this , mUpdateChildViewsRunnable ) ; } else { mAdapterUpdateDuringMeasure = true ; requestLayout ( ) ; } } @ Override public void onStateRestorationPolicyChanged ( ) { if ( mPendingSavedState == null ) { return ; } Adapter < ? > adapter = mAdapter ; if ( adapter != null && adapter . canRestoreState ( ) ) { requestLayout ( ) ; } } } public static class EdgeEffectFactory { @ Retention ( RetentionPolicy . SOURCE ) @ IntDef ( { DIRECTION_LEFT , DIRECTION_TOP , DIRECTION_RIGHT , DIRECTION_BOTTOM } ) public @ interface EdgeDirection { } public static final int DIRECTION_LEFT = <NUM_LIT> ; public static final int DIRECTION_TOP = <NUM_LIT> ; public static final int DIRECTION_RIGHT = <NUM_LIT> ; public static final int DIRECTION_BOTTOM = <NUM_LIT> ; protected @ NonNull EdgeEffect createEdgeEffect ( @ NonNull RecyclerView view , @ EdgeDirection int direction ) { return new EdgeEffect ( view . getContext ( ) ) ; } } public static class RecycledViewPool { private static final int DEFAULT_MAX_SCRAP = <NUM_LIT> ; static class ScrapData { final ArrayList < ViewHolder > mScrapHeap = new ArrayList < > ( ) ; int mMaxScrap = DEFAULT_MAX_SCRAP ; long mCreateRunningAverageNs = <NUM_LIT> ; long mBindRunningAverageNs = <NUM_LIT> ; } SparseArray < ScrapData > mScrap = new SparseArray < > ( ) ; int mAttachCountForClearing = <NUM_LIT> ; Set < Adapter < ? > > mAttachedAdaptersForPoolingContainer = Collections . newSetFromMap ( new IdentityHashMap < > ( ) ) ; public void clear ( ) { for ( int i = <NUM_LIT> ; i < mScrap . size ( ) ; i ++ ) { ScrapData data = mScrap . valueAt ( i ) ; for ( ViewHolder scrap : data . mScrapHeap ) { PoolingContainer . callPoolingContainerOnRelease ( scrap . itemView ) ; } data . mScrapHeap . clear ( ) ; } } public void setMaxRecycledViews ( int viewType , int max ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mMaxScrap = max ; final ArrayList < ViewHolder > scrapHeap = scrapData . mScrapHeap ; while ( scrapHeap . size ( ) > max ) { scrapHeap . remove ( scrapHeap . size ( ) - <NUM_LIT> ) ; } } public int getRecycledViewCount ( int viewType ) { return getScrapDataForType ( viewType ) . mScrapHeap . size ( ) ; } @ Nullable public ViewHolder getRecycledView ( int viewType ) { final ScrapData scrapData = mScrap . get ( viewType ) ; if ( scrapData != null && ! scrapData . mScrapHeap . isEmpty ( ) ) { final ArrayList < ViewHolder > scrapHeap = scrapData . mScrapHeap ; for ( int i = scrapHeap . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! scrapHeap . get ( i ) . isAttachedToTransitionOverlay ( ) ) { return scrapHeap . remove ( i ) ; } } } return null ; } int size ( ) { int count = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < mScrap . size ( ) ; i ++ ) { ArrayList < ViewHolder > viewHolders = mScrap . valueAt ( i ) . mScrapHeap ; if ( viewHolders != null ) { count += viewHolders . size ( ) ; } } return count ; } public void putRecycledView ( ViewHolder scrap ) { final int viewType = scrap . getItemViewType ( ) ; final ArrayList < ViewHolder > scrapHeap = getScrapDataForType ( viewType ) . mScrapHeap ; if ( mScrap . get ( viewType ) . mMaxScrap <= scrapHeap . size ( ) ) { PoolingContainer . callPoolingContainerOnRelease ( scrap . itemView ) ; return ; } if ( sDebugAssertionsEnabled && scrapHeap . contains ( scrap ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } scrap . resetInternal ( ) ; scrapHeap . add ( scrap ) ; } long runningAverage ( long oldAverage , long newValue ) { if ( oldAverage == <NUM_LIT> ) { return newValue ; } return ( oldAverage / <NUM_LIT> * <NUM_LIT> ) + ( newValue / <NUM_LIT> ) ; } void factorInCreateTime ( int viewType , long createTimeNs ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mCreateRunningAverageNs = runningAverage ( scrapData . mCreateRunningAverageNs , createTimeNs ) ; } void factorInBindTime ( int viewType , long bindTimeNs ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mBindRunningAverageNs = runningAverage ( scrapData . mBindRunningAverageNs , bindTimeNs ) ; } boolean willCreateInTime ( int viewType , long approxCurrentNs , long deadlineNs ) { long expectedDurationNs = getScrapDataForType ( viewType ) . mCreateRunningAverageNs ; return expectedDurationNs == <NUM_LIT> || ( approxCurrentNs + expectedDurationNs < deadlineNs ) ; } boolean willBindInTime ( int viewType , long approxCurrentNs , long deadlineNs ) { long expectedDurationNs = getScrapDataForType ( viewType ) . mBindRunningAverageNs ; return expectedDurationNs == <NUM_LIT> || ( approxCurrentNs + expectedDurationNs < deadlineNs ) ; } void attach ( ) { mAttachCountForClearing ++ ; } void detach ( ) { mAttachCountForClearing -- ; } void attachForPoolingContainer ( @ NonNull Adapter < ? > adapter ) { mAttachedAdaptersForPoolingContainer . add ( adapter ) ; } void detachForPoolingContainer ( @ NonNull Adapter < ? > adapter , boolean isBeingReplaced ) { mAttachedAdaptersForPoolingContainer . remove ( adapter ) ; if ( mAttachedAdaptersForPoolingContainer . size ( ) == <NUM_LIT> && ! isBeingReplaced ) { for ( int keyIndex = <NUM_LIT> ; keyIndex < mScrap . size ( ) ; keyIndex ++ ) { ArrayList < ViewHolder > scrapHeap = mScrap . get ( mScrap . keyAt ( keyIndex ) ) . mScrapHeap ; for ( int i = <NUM_LIT> ; i < scrapHeap . size ( ) ; i ++ ) { PoolingContainer . callPoolingContainerOnRelease ( scrapHeap . get ( i ) . itemView ) ; } } } } void onAdapterChanged ( Adapter < ? > oldAdapter , Adapter < ? > newAdapter , boolean compatibleWithPrevious ) { if ( oldAdapter != null ) { detach ( ) ; } if ( ! compatibleWithPrevious && mAttachCountForClearing == <NUM_LIT> ) { clear ( ) ; } if ( newAdapter != null ) { attach ( ) ; } } private ScrapData getScrapDataForType ( int viewType ) { ScrapData scrapData = mScrap . get ( viewType ) ; if ( scrapData == null ) { scrapData = new ScrapData ( ) ; mScrap . put ( viewType , scrapData ) ; } return scrapData ; } } @ Nullable static RecyclerView findNestedRecyclerView ( @ NonNull View view ) { if ( ! ( view instanceof ViewGroup ) ) { return null ; } if ( view instanceof RecyclerView ) { return ( RecyclerView ) view ; } final ViewGroup parent = ( ViewGroup ) view ; final int count = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View child = parent . getChildAt ( i ) ; final RecyclerView descendant = findNestedRecyclerView ( child ) ; if ( descendant != null ) { return descendant ; } } return null ; } static void clearNestedRecyclerViewIfNotNested ( @ NonNull ViewHolder holder ) { if ( holder . mNestedRecyclerView != null ) { View item = holder . mNestedRecyclerView . get ( ) ; while ( item != null ) { if ( item == holder . itemView ) { return ; } ViewParent parent = item . getParent ( ) ; if ( parent instanceof View ) { item = ( View ) parent ; } else { item = null ; } } holder . mNestedRecyclerView = null ; } } long getNanoTime ( ) { if ( ALLOW_THREAD_GAP_WORK ) { return System . nanoTime ( ) ; } else { return <NUM_LIT> ; } } public final class Recycler { final ArrayList < ViewHolder > mAttachedScrap = new ArrayList < > ( ) ; ArrayList < ViewHolder > mChangedScrap = null ; final ArrayList < ViewHolder > mCachedViews = new ArrayList < ViewHolder > ( ) ; private final List < ViewHolder > mUnmodifiableAttachedScrap = Collections . unmodifiableList ( mAttachedScrap ) ; private int mRequestedCacheMax = DEFAULT_CACHE_SIZE ; int mViewCacheMax = DEFAULT_CACHE_SIZE ; RecycledViewPool mRecyclerPool ; private ViewCacheExtension mViewCacheExtension ; static final int DEFAULT_CACHE_SIZE = <NUM_LIT> ; public void clear ( ) { mAttachedScrap . clear ( ) ; recycleAndClearCachedViews ( ) ; } public void setViewCacheSize ( int viewCount ) { mRequestedCacheMax = viewCount ; updateViewCacheSize ( ) ; } void updateViewCacheSize ( ) { int extraCache = mLayout != null ? mLayout . mPrefetchMaxCountObserved : <NUM_LIT> ; mViewCacheMax = mRequestedCacheMax + extraCache ; for ( int i = mCachedViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> && mCachedViews . size ( ) > mViewCacheMax ; i -- ) { recycleCachedViewAt ( i ) ; } } @ NonNull public List < ViewHolder > getScrapList ( ) { return mUnmodifiableAttachedScrap ; } boolean validateViewHolderForOffsetPosition ( ViewHolder holder ) { if ( holder . isRemoved ( ) ) { if ( sDebugAssertionsEnabled && ! mState . isPreLayout ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } return mState . isPreLayout ( ) ; } if ( holder . mPosition < <NUM_LIT> || holder . mPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( ! mState . isPreLayout ( ) ) { final int type = mAdapter . getItemViewType ( holder . mPosition ) ; if ( type != holder . getItemViewType ( ) ) { return false ; } } if ( mAdapter . hasStableIds ( ) ) { return holder . getItemId ( ) == mAdapter . getItemId ( holder . mPosition ) ; } return true ; } @ SuppressWarnings ( "<STR_LIT>" ) private boolean tryBindViewHolderByDeadline ( @ NonNull ViewHolder holder , int offsetPosition , int position , long deadlineNs ) { holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = RecyclerView . this ; final int viewType = holder . getItemViewType ( ) ; long startBindNs = getNanoTime ( ) ; if ( deadlineNs != FOREVER_NS && ! mRecyclerPool . willBindInTime ( viewType , startBindNs , deadlineNs ) ) { return false ; } boolean reattachedForBind = false ; if ( holder . isTmpDetached ( ) ) { attachViewToParent ( holder . itemView , getChildCount ( ) , holder . itemView . getLayoutParams ( ) ) ; reattachedForBind = true ; } mAdapter . bindViewHolder ( holder , offsetPosition ) ; if ( reattachedForBind ) { detachViewFromParent ( holder . itemView ) ; } long endBindNs = getNanoTime ( ) ; mRecyclerPool . factorInBindTime ( holder . getItemViewType ( ) , endBindNs - startBindNs ) ; attachAccessibilityDelegateOnBind ( holder ) ; if ( mState . isPreLayout ( ) ) { holder . mPreLayoutPosition = position ; } return true ; } public void bindViewToPosition ( @ NonNull View view , int position ) { ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition < <NUM_LIT> || offsetPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + position + "<STR_LIT>" + offsetPosition + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } tryBindViewHolderByDeadline ( holder , offsetPosition , position , FOREVER_NS ) ; final ViewGroup . LayoutParams lp = holder . itemView . getLayoutParams ( ) ; final LayoutParams rvLayoutParams ; if ( lp == null ) { rvLayoutParams = ( LayoutParams ) generateDefaultLayoutParams ( ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else if ( ! checkLayoutParams ( lp ) ) { rvLayoutParams = ( LayoutParams ) generateLayoutParams ( lp ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else { rvLayoutParams = ( LayoutParams ) lp ; } rvLayoutParams . mInsetsDirty = true ; rvLayoutParams . mViewHolder = holder ; rvLayoutParams . mPendingInvalidate = holder . itemView . getParent ( ) == null ; } public int convertPreLayoutPositionToPostLayout ( int position ) { if ( position < <NUM_LIT> || position >= mState . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + position + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } if ( ! mState . isPreLayout ( ) ) { return position ; } return mAdapterHelper . findPositionOffset ( position ) ; } @ NonNull public View getViewForPosition ( int position ) { return getViewForPosition ( position , false ) ; } View getViewForPosition ( int position , boolean dryRun ) { return tryGetViewHolderForPositionByDeadline ( position , dryRun , FOREVER_NS ) . itemView ; } @ Nullable ViewHolder tryGetViewHolderForPositionByDeadline ( int position , boolean dryRun , long deadlineNs ) { if ( position < <NUM_LIT> || position >= mState . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + position + "<STR_LIT>" + position + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } boolean fromScrapOrHiddenOrCache = false ; ViewHolder holder = null ; if ( mState . isPreLayout ( ) ) { holder = getChangedScrapViewForPosition ( position ) ; fromScrapOrHiddenOrCache = holder != null ; } if ( holder == null ) { holder = getScrapOrHiddenOrCachedHolderForPosition ( position , dryRun ) ; if ( holder != null ) { if ( ! validateViewHolderForOffsetPosition ( holder ) ) { if ( ! dryRun ) { holder . addFlags ( ViewHolder . FLAG_INVALID ) ; if ( holder . isScrap ( ) ) { removeDetachedView ( holder . itemView , false ) ; holder . unScrap ( ) ; } else if ( holder . wasReturnedFromScrap ( ) ) { holder . clearReturnedFromScrapFlag ( ) ; } recycleViewHolderInternal ( holder ) ; } holder = null ; } else { fromScrapOrHiddenOrCache = true ; } } } if ( holder == null ) { final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition < <NUM_LIT> || offsetPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + position + "<STR_LIT>" + offsetPosition + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } final int type = mAdapter . getItemViewType ( offsetPosition ) ; if ( mAdapter . hasStableIds ( ) ) { holder = getScrapOrCachedViewForId ( mAdapter . getItemId ( offsetPosition ) , type , dryRun ) ; if ( holder != null ) { holder . mPosition = offsetPosition ; fromScrapOrHiddenOrCache = true ; } } if ( holder == null && mViewCacheExtension != null ) { final View view = mViewCacheExtension . getViewForPositionAndType ( this , position , type ) ; if ( view != null ) { holder = getChildViewHolder ( view ) ; if ( holder == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } else if ( holder . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } } } if ( holder == null ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + position + "<STR_LIT>" ) ; } holder = getRecycledViewPool ( ) . getRecycledView ( type ) ; if ( holder != null ) { holder . resetInternal ( ) ; if ( FORCE_INVALIDATE_DISPLAY_LIST ) { invalidateDisplayListInt ( holder ) ; } } } if ( holder == null ) { long start = getNanoTime ( ) ; if ( deadlineNs != FOREVER_NS && ! mRecyclerPool . willCreateInTime ( type , start , deadlineNs ) ) { return null ; } holder = mAdapter . createViewHolder ( RecyclerView . this , type ) ; if ( ALLOW_THREAD_GAP_WORK ) { RecyclerView innerView = findNestedRecyclerView ( holder . itemView ) ; if ( innerView != null ) { holder . mNestedRecyclerView = new WeakReference < > ( innerView ) ; } } long end = getNanoTime ( ) ; mRecyclerPool . factorInCreateTime ( type , end - start ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } } } if ( fromScrapOrHiddenOrCache && ! mState . isPreLayout ( ) && holder . hasAnyOfTheFlags ( ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ) { holder . setFlags ( <NUM_LIT> , ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( mState . mRunSimpleAnimations ) { int changeFlags = ItemAnimator . buildAdapterChangeFlagsForAnimations ( holder ) ; changeFlags |= ItemAnimator . FLAG_APPEARED_IN_PRE_LAYOUT ; final ItemHolderInfo info = mItemAnimator . recordPreLayoutInformation ( mState , holder , changeFlags , holder . getUnmodifiedPayloads ( ) ) ; recordAnimationInfoIfBouncedHiddenView ( holder , info ) ; } } boolean bound = false ; if ( mState . isPreLayout ( ) && holder . isBound ( ) ) { holder . mPreLayoutPosition = position ; } else if ( ! holder . isBound ( ) || holder . needsUpdate ( ) || holder . isInvalid ( ) ) { if ( sDebugAssertionsEnabled && holder . isRemoved ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; bound = tryBindViewHolderByDeadline ( holder , offsetPosition , position , deadlineNs ) ; } final ViewGroup . LayoutParams lp = holder . itemView . getLayoutParams ( ) ; final LayoutParams rvLayoutParams ; if ( lp == null ) { rvLayoutParams = ( LayoutParams ) generateDefaultLayoutParams ( ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else if ( ! checkLayoutParams ( lp ) ) { rvLayoutParams = ( LayoutParams ) generateLayoutParams ( lp ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else { rvLayoutParams = ( LayoutParams ) lp ; } rvLayoutParams . mViewHolder = holder ; rvLayoutParams . mPendingInvalidate = fromScrapOrHiddenOrCache && bound ; return holder ; } private void attachAccessibilityDelegateOnBind ( ViewHolder holder ) { if ( isAccessibilityEnabled ( ) ) { final View itemView = holder . itemView ; if ( ViewCompat . getImportantForAccessibility ( itemView ) == ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewCompat . setImportantForAccessibility ( itemView , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } if ( mAccessibilityDelegate == null ) { return ; } AccessibilityDelegateCompat itemDelegate = mAccessibilityDelegate . getItemDelegate ( ) ; if ( itemDelegate instanceof RecyclerViewAccessibilityDelegate . ItemDelegate ) { ( ( RecyclerViewAccessibilityDelegate . ItemDelegate ) itemDelegate ) . saveOriginalDelegate ( itemView ) ; } ViewCompat . setAccessibilityDelegate ( itemView , itemDelegate ) ; } } private void invalidateDisplayListInt ( ViewHolder holder ) { if ( holder . itemView instanceof ViewGroup ) { invalidateDisplayListInt ( ( ViewGroup ) holder . itemView , false ) ; } } private void invalidateDisplayListInt ( ViewGroup viewGroup , boolean invalidateThis ) { for ( int i = viewGroup . getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = viewGroup . getChildAt ( i ) ; if ( view instanceof ViewGroup ) { invalidateDisplayListInt ( ( ViewGroup ) view , true ) ; } } if ( ! invalidateThis ) { return ; } if ( viewGroup . getVisibility ( ) == View . INVISIBLE ) { viewGroup . setVisibility ( View . VISIBLE ) ; viewGroup . setVisibility ( View . INVISIBLE ) ; } else { final int visibility = viewGroup . getVisibility ( ) ; viewGroup . setVisibility ( View . INVISIBLE ) ; viewGroup . setVisibility ( visibility ) ; } } public void recycleView ( @ NonNull View view ) { ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder . isTmpDetached ( ) ) { removeDetachedView ( view , false ) ; } if ( holder . isScrap ( ) ) { holder . unScrap ( ) ; } else if ( holder . wasReturnedFromScrap ( ) ) { holder . clearReturnedFromScrapFlag ( ) ; } recycleViewHolderInternal ( holder ) ; if ( mItemAnimator != null && ! holder . isRecyclable ( ) ) { mItemAnimator . endAnimation ( holder ) ; } } void recycleAndClearCachedViews ( ) { final int count = mCachedViews . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { recycleCachedViewAt ( i ) ; } mCachedViews . clear ( ) ; if ( ALLOW_THREAD_GAP_WORK ) { mPrefetchRegistry . clearPrefetchPositions ( ) ; } } void recycleCachedViewAt ( int cachedViewIndex ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + cachedViewIndex ) ; } ViewHolder viewHolder = mCachedViews . get ( cachedViewIndex ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + viewHolder ) ; } addViewHolderToRecycledViewPool ( viewHolder , true ) ; mCachedViews . remove ( cachedViewIndex ) ; } void recycleViewHolderInternal ( ViewHolder holder ) { if ( holder . isScrap ( ) || holder . itemView . getParent ( ) != null ) { throw new IllegalArgumentException ( "<STR_LIT>" + holder . isScrap ( ) + "<STR_LIT>" + ( holder . itemView . getParent ( ) != null ) + exceptionLabel ( ) ) ; } if ( holder . isTmpDetached ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( holder . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } final boolean transientStatePreventsRecycling = holder . doesTransientStatePreventRecycling ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) final boolean forceRecycle = mAdapter != null && transientStatePreventsRecycling && mAdapter . onFailedToRecycleView ( holder ) ; boolean cached = false ; boolean recycled = false ; if ( sDebugAssertionsEnabled && mCachedViews . contains ( holder ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( forceRecycle || holder . isRecyclable ( ) ) { if ( mViewCacheMax > <NUM_LIT> && ! holder . hasAnyOfTheFlags ( ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) ) { int cachedViewSize = mCachedViews . size ( ) ; if ( cachedViewSize >= mViewCacheMax && cachedViewSize > <NUM_LIT> ) { recycleCachedViewAt ( <NUM_LIT> ) ; cachedViewSize -- ; } int targetCacheIndex = cachedViewSize ; if ( ALLOW_THREAD_GAP_WORK && cachedViewSize > <NUM_LIT> && ! mPrefetchRegistry . lastPrefetchIncludedPosition ( holder . mPosition ) ) { int cacheIndex = cachedViewSize - <NUM_LIT> ; while ( cacheIndex >= <NUM_LIT> ) { int cachedPos = mCachedViews . get ( cacheIndex ) . mPosition ; if ( ! mPrefetchRegistry . lastPrefetchIncludedPosition ( cachedPos ) ) { break ; } cacheIndex -- ; } targetCacheIndex = cacheIndex + <NUM_LIT> ; } mCachedViews . add ( targetCacheIndex , holder ) ; cached = true ; } if ( ! cached ) { addViewHolderToRecycledViewPool ( holder , true ) ; recycled = true ; } } else { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } } mViewInfoStore . removeViewHolder ( holder ) ; if ( ! cached && ! recycled && transientStatePreventsRecycling ) { PoolingContainer . callPoolingContainerOnRelease ( holder . itemView ) ; holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = null ; } } void addViewHolderToRecycledViewPool ( @ NonNull ViewHolder holder , boolean dispatchRecycled ) { clearNestedRecyclerViewIfNotNested ( holder ) ; View itemView = holder . itemView ; if ( mAccessibilityDelegate != null ) { AccessibilityDelegateCompat itemDelegate = mAccessibilityDelegate . getItemDelegate ( ) ; AccessibilityDelegateCompat originalDelegate = null ; if ( itemDelegate instanceof RecyclerViewAccessibilityDelegate . ItemDelegate ) { originalDelegate = ( ( RecyclerViewAccessibilityDelegate . ItemDelegate ) itemDelegate ) . getAndRemoveOriginalDelegateForItem ( itemView ) ; } ViewCompat . setAccessibilityDelegate ( itemView , originalDelegate ) ; } if ( dispatchRecycled ) { dispatchViewRecycled ( holder ) ; } holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = null ; getRecycledViewPool ( ) . putRecycledView ( holder ) ; } void quickRecycleScrapView ( View view ) { final ViewHolder holder = getChildViewHolderInt ( view ) ; holder . mScrapContainer = null ; holder . mInChangeScrap = false ; holder . clearReturnedFromScrapFlag ( ) ; recycleViewHolderInternal ( holder ) ; } void scrapView ( View view ) { final ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder . hasAnyOfTheFlags ( ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_INVALID ) || ! holder . isUpdated ( ) || canReuseUpdatedViewHolder ( holder ) ) { if ( holder . isInvalid ( ) && ! holder . isRemoved ( ) && ! mAdapter . hasStableIds ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } holder . setScrapContainer ( this , false ) ; mAttachedScrap . add ( holder ) ; } else { if ( mChangedScrap == null ) { mChangedScrap = new ArrayList < ViewHolder > ( ) ; } holder . setScrapContainer ( this , true ) ; mChangedScrap . add ( holder ) ; } } void unscrapView ( ViewHolder holder ) { if ( holder . mInChangeScrap ) { mChangedScrap . remove ( holder ) ; } else { mAttachedScrap . remove ( holder ) ; } holder . mScrapContainer = null ; holder . mInChangeScrap = false ; holder . clearReturnedFromScrapFlag ( ) ; } int getScrapCount ( ) { return mAttachedScrap . size ( ) ; } View getScrapViewAt ( int index ) { return mAttachedScrap . get ( index ) . itemView ; } void clearScrap ( ) { mAttachedScrap . clear ( ) ; if ( mChangedScrap != null ) { mChangedScrap . clear ( ) ; } } ViewHolder getChangedScrapViewForPosition ( int position ) { final int changedScrapSize ; if ( mChangedScrap == null || ( changedScrapSize = mChangedScrap . size ( ) ) == <NUM_LIT> ) { return null ; } for ( int i = <NUM_LIT> ; i < changedScrapSize ; i ++ ) { final ViewHolder holder = mChangedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getLayoutPosition ( ) == position ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } if ( mAdapter . hasStableIds ( ) ) { final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition > <NUM_LIT> && offsetPosition < mAdapter . getItemCount ( ) ) { final long id = mAdapter . getItemId ( offsetPosition ) ; for ( int i = <NUM_LIT> ; i < changedScrapSize ; i ++ ) { final ViewHolder holder = mChangedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getItemId ( ) == id ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } } } return null ; } ViewHolder getScrapOrHiddenOrCachedHolderForPosition ( int position , boolean dryRun ) { final int scrapCount = mAttachedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < scrapCount ; i ++ ) { final ViewHolder holder = mAttachedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ( mState . mInPreLayout || ! holder . isRemoved ( ) ) ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } if ( ! dryRun ) { View view = mChildHelper . findHiddenNonRemovedView ( position ) ; if ( view != null ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; mChildHelper . unhide ( view ) ; int layoutIndex = mChildHelper . indexOfChild ( view ) ; if ( layoutIndex == RecyclerView . NO_POSITION ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } mChildHelper . detachViewFromParent ( layoutIndex ) ; scrapView ( view ) ; vh . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP | ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; return vh ; } } final int cacheSize = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cacheSize ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( ! holder . isInvalid ( ) && holder . getLayoutPosition ( ) == position && ! holder . isAttachedToTransitionOverlay ( ) ) { if ( ! dryRun ) { mCachedViews . remove ( i ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + position + "<STR_LIT>" + holder ) ; } return holder ; } } return null ; } ViewHolder getScrapOrCachedViewForId ( long id , int type , boolean dryRun ) { final int count = mAttachedScrap . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mAttachedScrap . get ( i ) ; if ( holder . getItemId ( ) == id && ! holder . wasReturnedFromScrap ( ) ) { if ( type == holder . getItemViewType ( ) ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; if ( holder . isRemoved ( ) ) { if ( ! mState . isPreLayout ( ) ) { holder . setFlags ( ViewHolder . FLAG_UPDATE , ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED ) ; } } return holder ; } else if ( ! dryRun ) { mAttachedScrap . remove ( i ) ; removeDetachedView ( holder . itemView , false ) ; quickRecycleScrapView ( holder . itemView ) ; } } } final int cacheSize = mCachedViews . size ( ) ; for ( int i = cacheSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder . getItemId ( ) == id && ! holder . isAttachedToTransitionOverlay ( ) ) { if ( type == holder . getItemViewType ( ) ) { if ( ! dryRun ) { mCachedViews . remove ( i ) ; } return holder ; } else if ( ! dryRun ) { recycleCachedViewAt ( i ) ; return null ; } } } return null ; } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchViewRecycled ( @ NonNull ViewHolder holder ) { if ( mRecyclerListener != null ) { mRecyclerListener . onViewRecycled ( holder ) ; } final int listenerCount = mRecyclerListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { mRecyclerListeners . get ( i ) . onViewRecycled ( holder ) ; } if ( mAdapter != null ) { mAdapter . onViewRecycled ( holder ) ; } if ( mState != null ) { mViewInfoStore . removeViewHolder ( holder ) ; } if ( sVerboseLoggingEnabled ) Log . d ( TAG , "<STR_LIT>" + holder ) ; } void onAdapterChanged ( Adapter < ? > oldAdapter , Adapter < ? > newAdapter , boolean compatibleWithPrevious ) { clear ( ) ; poolingContainerDetach ( oldAdapter , true ) ; getRecycledViewPool ( ) . onAdapterChanged ( oldAdapter , newAdapter , compatibleWithPrevious ) ; maybeSendPoolingContainerAttach ( ) ; } void offsetPositionRecordsForMove ( int from , int to ) { final int start , end , inBetweenOffset ; if ( from < to ) { start = from ; end = to ; inBetweenOffset = - <NUM_LIT> ; } else { start = to ; end = from ; inBetweenOffset = <NUM_LIT> ; } final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder == null || holder . mPosition < start || holder . mPosition > end ) { continue ; } if ( holder . mPosition == from ) { holder . offsetPosition ( to - from , false ) ; } else { holder . offsetPosition ( inBetweenOffset , false ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder ) ; } } } void offsetPositionRecordsForInsert ( int insertedAt , int count ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null && holder . mPosition >= insertedAt ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition + count ) ) ; } holder . offsetPosition ( count , false ) ; } } } void offsetPositionRecordsForRemove ( int removedFrom , int count , boolean applyToPreLayout ) { final int removedEnd = removedFrom + count ; final int cachedCount = mCachedViews . size ( ) ; for ( int i = cachedCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null ) { if ( holder . mPosition >= removedEnd ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition - count ) ) ; } holder . offsetPosition ( - count , applyToPreLayout ) ; } else if ( holder . mPosition >= removedFrom ) { holder . addFlags ( ViewHolder . FLAG_REMOVED ) ; recycleCachedViewAt ( i ) ; } } } } void setViewCacheExtension ( ViewCacheExtension extension ) { mViewCacheExtension = extension ; } void setRecycledViewPool ( RecycledViewPool pool ) { poolingContainerDetach ( mAdapter ) ; if ( mRecyclerPool != null ) { mRecyclerPool . detach ( ) ; } mRecyclerPool = pool ; if ( mRecyclerPool != null && getAdapter ( ) != null ) { mRecyclerPool . attach ( ) ; } maybeSendPoolingContainerAttach ( ) ; } private void maybeSendPoolingContainerAttach ( ) { if ( mRecyclerPool != null && mAdapter != null && isAttachedToWindow ( ) ) { mRecyclerPool . attachForPoolingContainer ( mAdapter ) ; } } private void poolingContainerDetach ( Adapter < ? > adapter ) { poolingContainerDetach ( adapter , false ) ; } private void poolingContainerDetach ( Adapter < ? > adapter , boolean isBeingReplaced ) { if ( mRecyclerPool != null ) { mRecyclerPool . detachForPoolingContainer ( adapter , isBeingReplaced ) ; } } void onAttachedToWindow ( ) { maybeSendPoolingContainerAttach ( ) ; } void onDetachedFromWindow ( ) { for ( int i = <NUM_LIT> ; i < mCachedViews . size ( ) ; i ++ ) { PoolingContainer . callPoolingContainerOnRelease ( mCachedViews . get ( i ) . itemView ) ; } poolingContainerDetach ( mAdapter ) ; } RecycledViewPool getRecycledViewPool ( ) { if ( mRecyclerPool == null ) { mRecyclerPool = new RecycledViewPool ( ) ; maybeSendPoolingContainerAttach ( ) ; } return mRecyclerPool ; } void viewRangeUpdate ( int positionStart , int itemCount ) { final int positionEnd = positionStart + itemCount ; final int cachedCount = mCachedViews . size ( ) ; for ( int i = cachedCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder == null ) { continue ; } final int pos = holder . mPosition ; if ( pos >= positionStart && pos < positionEnd ) { holder . addFlags ( ViewHolder . FLAG_UPDATE ) ; recycleCachedViewAt ( i ) ; } } } void markKnownViewsInvalid ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null ) { holder . addFlags ( ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID ) ; holder . addChangePayload ( null ) ; } } if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { recycleAndClearCachedViews ( ) ; } } void clearOldPositions ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; holder . clearOldPosition ( ) ; } final int scrapCount = mAttachedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < scrapCount ; i ++ ) { mAttachedScrap . get ( i ) . clearOldPosition ( ) ; } if ( mChangedScrap != null ) { final int changedScrapCount = mChangedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < changedScrapCount ; i ++ ) { mChangedScrap . get ( i ) . clearOldPosition ( ) ; } } } void markItemDecorInsetsDirty ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; LayoutParams layoutParams = ( LayoutParams ) holder . itemView . getLayoutParams ( ) ; if ( layoutParams != null ) { layoutParams . mInsetsDirty = true ; } } } } public abstract static class ViewCacheExtension { @ Nullable public abstract View getViewForPositionAndType ( @ NonNull Recycler recycler , int position , int type ) ; } public abstract static class Adapter < VH extends ViewHolder > { private final AdapterDataObservable mObservable = new AdapterDataObservable ( ) ; private boolean mHasStableIds = false ; private StateRestorationPolicy mStateRestorationPolicy = StateRestorationPolicy . ALLOW ; @ NonNull public abstract VH onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) ; public abstract void onBindViewHolder ( @ NonNull VH holder , int position ) ; public void onBindViewHolder ( @ NonNull VH holder , int position , @ NonNull List < Object > payloads ) { onBindViewHolder ( holder , position ) ; } public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { if ( adapter == this ) { return localPosition ; } return NO_POSITION ; } @ NonNull public final VH createViewHolder ( @ NonNull ViewGroup parent , int viewType ) { try { TraceCompat . beginSection ( TRACE_CREATE_VIEW_TAG ) ; final VH holder = onCreateViewHolder ( parent , viewType ) ; if ( holder . itemView . getParent ( ) != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } holder . mItemViewType = viewType ; return holder ; } finally { TraceCompat . endSection ( ) ; } } public final void bindViewHolder ( @ NonNull VH holder , int position ) { boolean rootBind = holder . mBindingAdapter == null ; if ( rootBind ) { holder . mPosition = position ; if ( hasStableIds ( ) ) { holder . mItemId = getItemId ( position ) ; } holder . setFlags ( ViewHolder . FLAG_BOUND , ViewHolder . FLAG_BOUND | ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) ; TraceCompat . beginSection ( TRACE_BIND_VIEW_TAG ) ; } holder . mBindingAdapter = this ; if ( sDebugAssertionsEnabled ) { if ( holder . itemView . getParent ( ) == null && ( ViewCompat . isAttachedToWindow ( holder . itemView ) != holder . isTmpDetached ( ) ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder . isTmpDetached ( ) + "<STR_LIT>" + ViewCompat . isAttachedToWindow ( holder . itemView ) + "<STR_LIT>" + holder ) ; } if ( holder . itemView . getParent ( ) == null && ViewCompat . isAttachedToWindow ( holder . itemView ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder ) ; } } onBindViewHolder ( holder , position , holder . getUnmodifiedPayloads ( ) ) ; if ( rootBind ) { holder . clearPayload ( ) ; final ViewGroup . LayoutParams layoutParams = holder . itemView . getLayoutParams ( ) ; if ( layoutParams instanceof RecyclerView . LayoutParams ) { ( ( LayoutParams ) layoutParams ) . mInsetsDirty = true ; } TraceCompat . endSection ( ) ; } } public int getItemViewType ( int position ) { return <NUM_LIT> ; } public void setHasStableIds ( boolean hasStableIds ) { if ( hasObservers ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mHasStableIds = hasStableIds ; } public long getItemId ( int position ) { return NO_ID ; } public abstract int getItemCount ( ) ; public final boolean hasStableIds ( ) { return mHasStableIds ; } public void onViewRecycled ( @ NonNull VH holder ) { } public boolean onFailedToRecycleView ( @ NonNull VH holder ) { return false ; } public void onViewAttachedToWindow ( @ NonNull VH holder ) { } public void onViewDetachedFromWindow ( @ NonNull VH holder ) { } public final boolean hasObservers ( ) { return mObservable . hasObservers ( ) ; } public void registerAdapterDataObserver ( @ NonNull AdapterDataObserver observer ) { mObservable . registerObserver ( observer ) ; } public void unregisterAdapterDataObserver ( @ NonNull AdapterDataObserver observer ) { mObservable . unregisterObserver ( observer ) ; } public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { } public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { } public final void notifyDataSetChanged ( ) { mObservable . notifyChanged ( ) ; } public final void notifyItemChanged ( int position ) { mObservable . notifyItemRangeChanged ( position , <NUM_LIT> ) ; } public final void notifyItemChanged ( int position , @ Nullable Object payload ) { mObservable . notifyItemRangeChanged ( position , <NUM_LIT> , payload ) ; } public final void notifyItemRangeChanged ( int positionStart , int itemCount ) { mObservable . notifyItemRangeChanged ( positionStart , itemCount ) ; } public final void notifyItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mObservable . notifyItemRangeChanged ( positionStart , itemCount , payload ) ; } public final void notifyItemInserted ( int position ) { mObservable . notifyItemRangeInserted ( position , <NUM_LIT> ) ; } public final void notifyItemMoved ( int fromPosition , int toPosition ) { mObservable . notifyItemMoved ( fromPosition , toPosition ) ; } public final void notifyItemRangeInserted ( int positionStart , int itemCount ) { mObservable . notifyItemRangeInserted ( positionStart , itemCount ) ; } public final void notifyItemRemoved ( int position ) { mObservable . notifyItemRangeRemoved ( position , <NUM_LIT> ) ; } public final void notifyItemRangeRemoved ( int positionStart , int itemCount ) { mObservable . notifyItemRangeRemoved ( positionStart , itemCount ) ; } public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { mStateRestorationPolicy = strategy ; mObservable . notifyStateRestorationPolicyChanged ( ) ; } @ NonNull public final StateRestorationPolicy getStateRestorationPolicy ( ) { return mStateRestorationPolicy ; } boolean canRestoreState ( ) { switch ( mStateRestorationPolicy ) { case PREVENT : return false ; case PREVENT_WHEN_EMPTY : return getItemCount ( ) > <NUM_LIT> ; default : return true ; } } public enum StateRestorationPolicy { ALLOW , PREVENT_WHEN_EMPTY , PREVENT } } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchChildDetached ( View child ) { final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; onChildDetachedFromWindow ( child ) ; if ( mAdapter != null && viewHolder != null ) { mAdapter . onViewDetachedFromWindow ( viewHolder ) ; } if ( mOnChildAttachStateListeners != null ) { final int cnt = mOnChildAttachStateListeners . size ( ) ; for ( int i = cnt - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mOnChildAttachStateListeners . get ( i ) . onChildViewDetachedFromWindow ( child ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchChildAttached ( View child ) { final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; onChildAttachedToWindow ( child ) ; if ( mAdapter != null && viewHolder != null ) { mAdapter . onViewAttachedToWindow ( viewHolder ) ; } if ( mOnChildAttachStateListeners != null ) { final int cnt = mOnChildAttachStateListeners . size ( ) ; for ( int i = cnt - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mOnChildAttachStateListeners . get ( i ) . onChildViewAttachedToWindow ( child ) ; } } } public abstract static class LayoutManager { ChildHelper mChildHelper ; RecyclerView mRecyclerView ; private final ViewBoundsCheck . Callback mHorizontalBoundCheckCallback = new ViewBoundsCheck . Callback ( ) { @ Override public View getChildAt ( int index ) { return LayoutManager . this . getChildAt ( index ) ; } @ Override public int getParentStart ( ) { return LayoutManager . this . getPaddingLeft ( ) ; } @ Override public int getParentEnd ( ) { return LayoutManager . this . getWidth ( ) - LayoutManager . this . getPaddingRight ( ) ; } @ Override public int getChildStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getChildEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedRight ( view ) + params . rightMargin ; } } ; private final ViewBoundsCheck . Callback mVerticalBoundCheckCallback = new ViewBoundsCheck . Callback ( ) { @ Override public View getChildAt ( int index ) { return LayoutManager . this . getChildAt ( index ) ; } @ Override public int getParentStart ( ) { return LayoutManager . this . getPaddingTop ( ) ; } @ Override public int getParentEnd ( ) { return LayoutManager . this . getHeight ( ) - LayoutManager . this . getPaddingBottom ( ) ; } @ Override public int getChildStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedTop ( view ) - params . topMargin ; } @ Override public int getChildEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedBottom ( view ) + params . bottomMargin ; } } ; ViewBoundsCheck mHorizontalBoundCheck = new ViewBoundsCheck ( mHorizontalBoundCheckCallback ) ; ViewBoundsCheck mVerticalBoundCheck = new ViewBoundsCheck ( mVerticalBoundCheckCallback ) ; @ Nullable SmoothScroller mSmoothScroller ; boolean mRequestedSimpleAnimations = false ; boolean mIsAttachedToWindow = false ; boolean mAutoMeasure = false ; private boolean mMeasurementCacheEnabled = true ; private boolean mItemPrefetchEnabled = true ; int mPrefetchMaxCountObserved ; boolean mPrefetchMaxObservedInInitialPrefetch ; private int mWidthMode , mHeightMode ; private int mWidth , mHeight ; public interface LayoutPrefetchRegistry { void addPosition ( int layoutPosition , int pixelDistance ) ; } void setRecyclerView ( RecyclerView recyclerView ) { if ( recyclerView == null ) { mRecyclerView = null ; mChildHelper = null ; mWidth = <NUM_LIT> ; mHeight = <NUM_LIT> ; } else { mRecyclerView = recyclerView ; mChildHelper = recyclerView . mChildHelper ; mWidth = recyclerView . getWidth ( ) ; mHeight = recyclerView . getHeight ( ) ; } mWidthMode = MeasureSpec . EXACTLY ; mHeightMode = MeasureSpec . EXACTLY ; } void setMeasureSpecs ( int wSpec , int hSpec ) { mWidth = MeasureSpec . getSize ( wSpec ) ; mWidthMode = MeasureSpec . getMode ( wSpec ) ; if ( mWidthMode == MeasureSpec . UNSPECIFIED && ! ALLOW_SIZE_IN_UNSPECIFIED_SPEC ) { mWidth = <NUM_LIT> ; } mHeight = MeasureSpec . getSize ( hSpec ) ; mHeightMode = MeasureSpec . getMode ( hSpec ) ; if ( mHeightMode == MeasureSpec . UNSPECIFIED && ! ALLOW_SIZE_IN_UNSPECIFIED_SPEC ) { mHeight = <NUM_LIT> ; } } void setMeasuredDimensionFromChildren ( int widthSpec , int heightSpec ) { final int count = getChildCount ( ) ; if ( count == <NUM_LIT> ) { mRecyclerView . defaultOnMeasure ( widthSpec , heightSpec ) ; return ; } int minX = Integer . MAX_VALUE ; int minY = Integer . MAX_VALUE ; int maxX = Integer . MIN_VALUE ; int maxY = Integer . MIN_VALUE ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View child = getChildAt ( i ) ; final Rect bounds = mRecyclerView . mTempRect ; getDecoratedBoundsWithMargins ( child , bounds ) ; if ( bounds . left < minX ) { minX = bounds . left ; } if ( bounds . right > maxX ) { maxX = bounds . right ; } if ( bounds . top < minY ) { minY = bounds . top ; } if ( bounds . bottom > maxY ) { maxY = bounds . bottom ; } } mRecyclerView . mTempRect . set ( minX , minY , maxX , maxY ) ; setMeasuredDimension ( mRecyclerView . mTempRect , widthSpec , heightSpec ) ; } public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { int usedWidth = childrenBounds . width ( ) + getPaddingLeft ( ) + getPaddingRight ( ) ; int usedHeight = childrenBounds . height ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; int width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; int height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; setMeasuredDimension ( width , height ) ; } public void requestLayout ( ) { if ( mRecyclerView != null ) { mRecyclerView . requestLayout ( ) ; } } public void assertInLayoutOrScroll ( String message ) { if ( mRecyclerView != null ) { mRecyclerView . assertInLayoutOrScroll ( message ) ; } } public static int chooseSize ( int spec , int desired , int min ) { final int mode = View . MeasureSpec . getMode ( spec ) ; final int size = View . MeasureSpec . getSize ( spec ) ; switch ( mode ) { case View . MeasureSpec . EXACTLY : return size ; case View . MeasureSpec . AT_MOST : return Math . min ( size , Math . max ( desired , min ) ) ; case View . MeasureSpec . UNSPECIFIED : default : return Math . max ( desired , min ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void assertNotInLayoutOrScroll ( String message ) { if ( mRecyclerView != null ) { mRecyclerView . assertNotInLayoutOrScroll ( message ) ; } } @ Deprecated public void setAutoMeasureEnabled ( boolean enabled ) { mAutoMeasure = enabled ; } public boolean isAutoMeasureEnabled ( ) { return mAutoMeasure ; } public boolean supportsPredictiveItemAnimations ( ) { return false ; } public final void setItemPrefetchEnabled ( boolean enabled ) { if ( enabled != mItemPrefetchEnabled ) { mItemPrefetchEnabled = enabled ; mPrefetchMaxCountObserved = <NUM_LIT> ; if ( mRecyclerView != null ) { mRecyclerView . mRecycler . updateViewCacheSize ( ) ; } } } public final boolean isItemPrefetchEnabled ( ) { return mItemPrefetchEnabled ; } @ SuppressLint ( "<STR_LIT>" ) public void collectAdjacentPrefetchPositions ( int dx , int dy , State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { } @ SuppressLint ( "<STR_LIT>" ) public void collectInitialPrefetchPositions ( int adapterItemCount , LayoutPrefetchRegistry layoutPrefetchRegistry ) { } void dispatchAttachedToWindow ( RecyclerView view ) { mIsAttachedToWindow = true ; onAttachedToWindow ( view ) ; } void dispatchDetachedFromWindow ( RecyclerView view , Recycler recycler ) { mIsAttachedToWindow = false ; onDetachedFromWindow ( view , recycler ) ; } public boolean isAttachedToWindow ( ) { return mIsAttachedToWindow ; } public void postOnAnimation ( Runnable action ) { if ( mRecyclerView != null ) { ViewCompat . postOnAnimation ( mRecyclerView , action ) ; } } public boolean removeCallbacks ( Runnable action ) { if ( mRecyclerView != null ) { return mRecyclerView . removeCallbacks ( action ) ; } return false ; } @ CallSuper public void onAttachedToWindow ( RecyclerView view ) { } @ Deprecated public void onDetachedFromWindow ( RecyclerView view ) { } @ CallSuper @ SuppressLint ( "<STR_LIT>" ) public void onDetachedFromWindow ( RecyclerView view , Recycler recycler ) { onDetachedFromWindow ( view ) ; } public boolean getClipToPadding ( ) { return mRecyclerView != null && mRecyclerView . mClipToPadding ; } @ SuppressLint ( "<STR_LIT>" ) public void onLayoutChildren ( Recycler recycler , State state ) { Log . e ( TAG , "<STR_LIT>" ) ; } @ SuppressLint ( "<STR_LIT>" ) public void onLayoutCompleted ( State state ) { } @ SuppressLint ( "<STR_LIT>" ) public abstract LayoutParams generateDefaultLayoutParams ( ) ; public boolean checkLayoutParams ( LayoutParams lp ) { return lp != null ; } @ SuppressLint ( "<STR_LIT>" ) public LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof LayoutParams ) { return new LayoutParams ( ( LayoutParams ) lp ) ; } else if ( lp instanceof MarginLayoutParams ) { return new LayoutParams ( ( MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ SuppressLint ( "<STR_LIT>" ) public LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ SuppressLint ( "<STR_LIT>" ) public int scrollHorizontallyBy ( int dx , Recycler recycler , State state ) { return <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public int scrollVerticallyBy ( int dy , Recycler recycler , State state ) { return <NUM_LIT> ; } public boolean canScrollHorizontally ( ) { return false ; } public boolean canScrollVertically ( ) { return false ; } public void scrollToPosition ( int position ) { if ( sVerboseLoggingEnabled ) { Log . e ( TAG , "<STR_LIT>" ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void smoothScrollToPosition ( RecyclerView recyclerView , State state , int position ) { Log . e ( TAG , "<STR_LIT>" ) ; } @ SuppressLint ( "<STR_LIT>" ) public void startSmoothScroll ( SmoothScroller smoothScroller ) { if ( mSmoothScroller != null && smoothScroller != mSmoothScroller && mSmoothScroller . isRunning ( ) ) { mSmoothScroller . stop ( ) ; } mSmoothScroller = smoothScroller ; mSmoothScroller . start ( mRecyclerView , this ) ; } public boolean isSmoothScrolling ( ) { return mSmoothScroller != null && mSmoothScroller . isRunning ( ) ; } public int getLayoutDirection ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) ; } @ SuppressLint ( "<STR_LIT>" ) public void endAnimation ( View view ) { if ( mRecyclerView . mItemAnimator != null ) { mRecyclerView . mItemAnimator . endAnimation ( getChildViewHolderInt ( view ) ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void addDisappearingView ( View child ) { addDisappearingView ( child , - <NUM_LIT> ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addDisappearingView ( View child , int index ) { addViewInt ( child , index , true ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addView ( View child ) { addView ( child , - <NUM_LIT> ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addView ( View child , int index ) { addViewInt ( child , index , false ) ; } private void addViewInt ( View child , int index , boolean disappearing ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; if ( disappearing || holder . isRemoved ( ) ) { mRecyclerView . mViewInfoStore . addToDisappearedInLayout ( holder ) ; } else { mRecyclerView . mViewInfoStore . removeFromDisappearedInLayout ( holder ) ; } final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( holder . wasReturnedFromScrap ( ) || holder . isScrap ( ) ) { if ( holder . isScrap ( ) ) { holder . unScrap ( ) ; } else { holder . clearReturnedFromScrapFlag ( ) ; } mChildHelper . attachViewToParent ( child , index , child . getLayoutParams ( ) , false ) ; if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchFinishTemporaryDetach ( child ) ; } } else if ( child . getParent ( ) == mRecyclerView ) { int currentIndex = mChildHelper . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { index = mChildHelper . getChildCount ( ) ; } if ( currentIndex == - <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + mRecyclerView . indexOfChild ( child ) + mRecyclerView . exceptionLabel ( ) ) ; } if ( currentIndex != index ) { mRecyclerView . mLayout . moveView ( currentIndex , index ) ; } } else { mChildHelper . addView ( child , index , false ) ; lp . mInsetsDirty = true ; if ( mSmoothScroller != null && mSmoothScroller . isRunning ( ) ) { mSmoothScroller . onChildAttachedToWindow ( child ) ; } } if ( lp . mPendingInvalidate ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + lp . mViewHolder ) ; } holder . itemView . invalidate ( ) ; lp . mPendingInvalidate = false ; } } @ SuppressLint ( "<STR_LIT>" ) public void removeView ( View child ) { mChildHelper . removeView ( child ) ; } public void removeViewAt ( int index ) { final View child = getChildAt ( index ) ; if ( child != null ) { mChildHelper . removeViewAt ( index ) ; } } public void removeAllViews ( ) { final int childCount = getChildCount ( ) ; for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mChildHelper . removeViewAt ( i ) ; } } public int getBaseline ( ) { return - <NUM_LIT> ; } public int getPosition ( @ NonNull View view ) { return ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . getViewLayoutPosition ( ) ; } public int getItemViewType ( @ NonNull View view ) { return getChildViewHolderInt ( view ) . getItemViewType ( ) ; } @ Nullable public View findContainingItemView ( @ NonNull View view ) { if ( mRecyclerView == null ) { return null ; } View found = mRecyclerView . findContainingItemView ( view ) ; if ( found == null ) { return null ; } if ( mChildHelper . isHidden ( found ) ) { return null ; } return found ; } @ Nullable public View findViewByPosition ( int position ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh == null ) { continue ; } if ( vh . getLayoutPosition ( ) == position && ! vh . shouldIgnore ( ) && ( mRecyclerView . mState . isPreLayout ( ) || ! vh . isRemoved ( ) ) ) { return child ; } } return null ; } public void detachView ( @ NonNull View child ) { final int ind = mChildHelper . indexOfChild ( child ) ; if ( ind >= <NUM_LIT> ) { detachViewInternal ( ind , child ) ; } } public void detachViewAt ( int index ) { detachViewInternal ( index , getChildAt ( index ) ) ; } private void detachViewInternal ( int index , @ NonNull View view ) { if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchStartTemporaryDetach ( view ) ; } mChildHelper . detachViewFromParent ( index ) ; } public void attachView ( @ NonNull View child , int index , LayoutParams lp ) { ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh . isRemoved ( ) ) { mRecyclerView . mViewInfoStore . addToDisappearedInLayout ( vh ) ; } else { mRecyclerView . mViewInfoStore . removeFromDisappearedInLayout ( vh ) ; } mChildHelper . attachViewToParent ( child , index , lp , vh . isRemoved ( ) ) ; if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchFinishTemporaryDetach ( child ) ; } } public void attachView ( @ NonNull View child , int index ) { attachView ( child , index , ( LayoutParams ) child . getLayoutParams ( ) ) ; } public void attachView ( @ NonNull View child ) { attachView ( child , - <NUM_LIT> ) ; } public void removeDetachedView ( @ NonNull View child ) { mRecyclerView . removeDetachedView ( child , false ) ; } public void moveView ( int fromIndex , int toIndex ) { View view = getChildAt ( fromIndex ) ; if ( view == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + fromIndex + mRecyclerView . toString ( ) ) ; } detachViewAt ( fromIndex ) ; attachView ( view , toIndex ) ; } public void detachAndScrapView ( @ NonNull View child , @ NonNull Recycler recycler ) { int index = mChildHelper . indexOfChild ( child ) ; scrapOrRecycleView ( recycler , index , child ) ; } public void detachAndScrapViewAt ( int index , @ NonNull Recycler recycler ) { final View child = getChildAt ( index ) ; scrapOrRecycleView ( recycler , index , child ) ; } public void removeAndRecycleView ( @ NonNull View child , @ NonNull Recycler recycler ) { removeView ( child ) ; recycler . recycleView ( child ) ; } public void removeAndRecycleViewAt ( int index , @ NonNull Recycler recycler ) { final View view = getChildAt ( index ) ; removeViewAt ( index ) ; recycler . recycleView ( view ) ; } public int getChildCount ( ) { return mChildHelper != null ? mChildHelper . getChildCount ( ) : <NUM_LIT> ; } @ Nullable public View getChildAt ( int index ) { return mChildHelper != null ? mChildHelper . getChildAt ( index ) : null ; } public int getWidthMode ( ) { return mWidthMode ; } public int getHeightMode ( ) { return mHeightMode ; } @ Px public int getWidth ( ) { return mWidth ; } @ Px public int getHeight ( ) { return mHeight ; } @ Px public int getPaddingLeft ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingLeft ( ) : <NUM_LIT> ; } @ Px public int getPaddingTop ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingTop ( ) : <NUM_LIT> ; } @ Px public int getPaddingRight ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingRight ( ) : <NUM_LIT> ; } @ Px public int getPaddingBottom ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingBottom ( ) : <NUM_LIT> ; } @ Px public int getPaddingStart ( ) { return mRecyclerView != null ? ViewCompat . getPaddingStart ( mRecyclerView ) : <NUM_LIT> ; } @ Px public int getPaddingEnd ( ) { return mRecyclerView != null ? ViewCompat . getPaddingEnd ( mRecyclerView ) : <NUM_LIT> ; } public boolean isFocused ( ) { return mRecyclerView != null && mRecyclerView . isFocused ( ) ; } public boolean hasFocus ( ) { return mRecyclerView != null && mRecyclerView . hasFocus ( ) ; } @ Nullable public View getFocusedChild ( ) { if ( mRecyclerView == null ) { return null ; } final View focused = mRecyclerView . getFocusedChild ( ) ; if ( focused == null || mChildHelper . isHidden ( focused ) ) { return null ; } return focused ; } public int getItemCount ( ) { final Adapter a = mRecyclerView != null ? mRecyclerView . getAdapter ( ) : null ; return a != null ? a . getItemCount ( ) : <NUM_LIT> ; } public void offsetChildrenHorizontal ( @ Px int dx ) { if ( mRecyclerView != null ) { mRecyclerView . offsetChildrenHorizontal ( dx ) ; } } public void offsetChildrenVertical ( @ Px int dy ) { if ( mRecyclerView != null ) { mRecyclerView . offsetChildrenVertical ( dy ) ; } } public void ignoreView ( @ NonNull View view ) { if ( view . getParent ( ) != mRecyclerView || mRecyclerView . indexOfChild ( view ) == - <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + mRecyclerView . exceptionLabel ( ) ) ; } final ViewHolder vh = getChildViewHolderInt ( view ) ; vh . addFlags ( ViewHolder . FLAG_IGNORE ) ; mRecyclerView . mViewInfoStore . removeViewHolder ( vh ) ; } public void stopIgnoringView ( @ NonNull View view ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; vh . stopIgnoring ( ) ; vh . resetInternal ( ) ; vh . addFlags ( ViewHolder . FLAG_INVALID ) ; } public void detachAndScrapAttachedViews ( @ NonNull Recycler recycler ) { final int childCount = getChildCount ( ) ; for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View v = getChildAt ( i ) ; scrapOrRecycleView ( recycler , i , v ) ; } } private void scrapOrRecycleView ( Recycler recycler , int index , View view ) { final ViewHolder viewHolder = getChildViewHolderInt ( view ) ; if ( viewHolder . shouldIgnore ( ) ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + viewHolder ) ; } return ; } if ( viewHolder . isInvalid ( ) && ! viewHolder . isRemoved ( ) && ! mRecyclerView . mAdapter . hasStableIds ( ) ) { removeViewAt ( index ) ; recycler . recycleViewHolderInternal ( viewHolder ) ; } else { detachViewAt ( index ) ; recycler . scrapView ( view ) ; mRecyclerView . mViewInfoStore . onViewDetached ( viewHolder ) ; } } void removeAndRecycleScrapInt ( Recycler recycler ) { final int scrapCount = recycler . getScrapCount ( ) ; for ( int i = scrapCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View scrap = recycler . getScrapViewAt ( i ) ; final ViewHolder vh = getChildViewHolderInt ( scrap ) ; if ( vh . shouldIgnore ( ) ) { continue ; } vh . setIsRecyclable ( false ) ; if ( vh . isTmpDetached ( ) ) { mRecyclerView . removeDetachedView ( scrap , false ) ; } if ( mRecyclerView . mItemAnimator != null ) { mRecyclerView . mItemAnimator . endAnimation ( vh ) ; } vh . setIsRecyclable ( true ) ; recycler . quickRecycleScrapView ( scrap ) ; } recycler . clearScrap ( ) ; if ( scrapCount > <NUM_LIT> ) { mRecyclerView . invalidate ( ) ; } } public void measureChild ( @ NonNull View child , int widthUsed , int heightUsed ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; widthUsed += insets . left + insets . right ; heightUsed += insets . top + insets . bottom ; final int widthSpec = getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) + widthUsed , lp . width , canScrollHorizontally ( ) ) ; final int heightSpec = getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) + heightUsed , lp . height , canScrollVertically ( ) ) ; if ( shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ) { child . measure ( widthSpec , heightSpec ) ; } } boolean shouldReMeasureChild ( View child , int widthSpec , int heightSpec , LayoutParams lp ) { return ! mMeasurementCacheEnabled || ! isMeasurementUpToDate ( child . getMeasuredWidth ( ) , widthSpec , lp . width ) || ! isMeasurementUpToDate ( child . getMeasuredHeight ( ) , heightSpec , lp . height ) ; } boolean shouldMeasureChild ( View child , int widthSpec , int heightSpec , LayoutParams lp ) { return child . isLayoutRequested ( ) || ! mMeasurementCacheEnabled || ! isMeasurementUpToDate ( child . getWidth ( ) , widthSpec , lp . width ) || ! isMeasurementUpToDate ( child . getHeight ( ) , heightSpec , lp . height ) ; } public boolean isMeasurementCacheEnabled ( ) { return mMeasurementCacheEnabled ; } public void setMeasurementCacheEnabled ( boolean measurementCacheEnabled ) { mMeasurementCacheEnabled = measurementCacheEnabled ; } private static boolean isMeasurementUpToDate ( int childSize , int spec , int dimension ) { final int specMode = MeasureSpec . getMode ( spec ) ; final int specSize = MeasureSpec . getSize ( spec ) ; if ( dimension > <NUM_LIT> && childSize != dimension ) { return false ; } switch ( specMode ) { case MeasureSpec . UNSPECIFIED : return true ; case MeasureSpec . AT_MOST : return specSize >= childSize ; case MeasureSpec . EXACTLY : return specSize == childSize ; } return false ; } public void measureChildWithMargins ( @ NonNull View child , int widthUsed , int heightUsed ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; widthUsed += insets . left + insets . right ; heightUsed += insets . top + insets . bottom ; final int widthSpec = getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) + lp . leftMargin + lp . rightMargin + widthUsed , lp . width , canScrollHorizontally ( ) ) ; final int heightSpec = getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) + lp . topMargin + lp . bottomMargin + heightUsed , lp . height , canScrollVertically ( ) ) ; if ( shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ) { child . measure ( widthSpec , heightSpec ) ; } } @ Deprecated public static int getChildMeasureSpec ( int parentSize , int padding , int childDimension , boolean canScroll ) { int size = Math . max ( <NUM_LIT> , parentSize - padding ) ; int resultSize = <NUM_LIT> ; int resultMode = <NUM_LIT> ; if ( canScroll ) { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else { resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; } } else { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { resultSize = size ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = size ; resultMode = MeasureSpec . AT_MOST ; } } return MeasureSpec . makeMeasureSpec ( resultSize , resultMode ) ; } public static int getChildMeasureSpec ( int parentSize , int parentMode , int padding , int childDimension , boolean canScroll ) { int size = Math . max ( <NUM_LIT> , parentSize - padding ) ; int resultSize = <NUM_LIT> ; int resultMode = <NUM_LIT> ; if ( canScroll ) { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { switch ( parentMode ) { case MeasureSpec . AT_MOST : case MeasureSpec . EXACTLY : resultSize = size ; resultMode = parentMode ; break ; case MeasureSpec . UNSPECIFIED : resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; break ; } } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; } } else { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { resultSize = size ; resultMode = parentMode ; } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = size ; if ( parentMode == MeasureSpec . AT_MOST || parentMode == MeasureSpec . EXACTLY ) { resultMode = MeasureSpec . AT_MOST ; } else { resultMode = MeasureSpec . UNSPECIFIED ; } } } return MeasureSpec . makeMeasureSpec ( resultSize , resultMode ) ; } public int getDecoratedMeasuredWidth ( @ NonNull View child ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; return child . getMeasuredWidth ( ) + insets . left + insets . right ; } public int getDecoratedMeasuredHeight ( @ NonNull View child ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; return child . getMeasuredHeight ( ) + insets . top + insets . bottom ; } public void layoutDecorated ( @ NonNull View child , int left , int top , int right , int bottom ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; child . layout ( left + insets . left , top + insets . top , right - insets . right , bottom - insets . bottom ) ; } public void layoutDecoratedWithMargins ( @ NonNull View child , int left , int top , int right , int bottom ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = lp . mDecorInsets ; child . layout ( left + insets . left + lp . leftMargin , top + insets . top + lp . topMargin , right - insets . right - lp . rightMargin , bottom - insets . bottom - lp . bottomMargin ) ; } public void getTransformedBoundingBox ( @ NonNull View child , boolean includeDecorInsets , @ NonNull Rect out ) { if ( includeDecorInsets ) { Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; out . set ( - insets . left , - insets . top , child . getWidth ( ) + insets . right , child . getHeight ( ) + insets . bottom ) ; } else { out . set ( <NUM_LIT> , <NUM_LIT> , child . getWidth ( ) , child . getHeight ( ) ) ; } if ( mRecyclerView != null ) { final Matrix childMatrix = child . getMatrix ( ) ; if ( childMatrix != null && ! childMatrix . isIdentity ( ) ) { final RectF tempRectF = mRecyclerView . mTempRectF ; tempRectF . set ( out ) ; childMatrix . mapRect ( tempRectF ) ; out . set ( ( int ) Math . floor ( tempRectF . left ) , ( int ) Math . floor ( tempRectF . top ) , ( int ) Math . ceil ( tempRectF . right ) , ( int ) Math . ceil ( tempRectF . bottom ) ) ; } } out . offset ( child . getLeft ( ) , child . getTop ( ) ) ; } public void getDecoratedBoundsWithMargins ( @ NonNull View view , @ NonNull Rect outBounds ) { RecyclerView . getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } public int getDecoratedLeft ( @ NonNull View child ) { return child . getLeft ( ) - getLeftDecorationWidth ( child ) ; } public int getDecoratedTop ( @ NonNull View child ) { return child . getTop ( ) - getTopDecorationHeight ( child ) ; } public int getDecoratedRight ( @ NonNull View child ) { return child . getRight ( ) + getRightDecorationWidth ( child ) ; } public int getDecoratedBottom ( @ NonNull View child ) { return child . getBottom ( ) + getBottomDecorationHeight ( child ) ; } public void calculateItemDecorationsForChild ( @ NonNull View child , @ NonNull Rect outRect ) { if ( mRecyclerView == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; outRect . set ( insets ) ; } public int getTopDecorationHeight ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . top ; } public int getBottomDecorationHeight ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . bottom ; } public int getLeftDecorationWidth ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . left ; } public int getRightDecorationWidth ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . right ; } @ Nullable public View onFocusSearchFailed ( @ NonNull View focused , int direction , @ NonNull Recycler recycler , @ NonNull State state ) { return null ; } @ Nullable public View onInterceptFocusSearch ( @ NonNull View focused , int direction ) { return null ; } private int [ ] getChildRectangleOnScreenScrollAmount ( View child , Rect rect ) { int [ ] out = new int [ <NUM_LIT> ] ; final int parentLeft = getPaddingLeft ( ) ; final int parentTop = getPaddingTop ( ) ; final int parentRight = getWidth ( ) - getPaddingRight ( ) ; final int parentBottom = getHeight ( ) - getPaddingBottom ( ) ; final int childLeft = child . getLeft ( ) + rect . left - child . getScrollX ( ) ; final int childTop = child . getTop ( ) + rect . top - child . getScrollY ( ) ; final int childRight = childLeft + rect . width ( ) ; final int childBottom = childTop + rect . height ( ) ; final int offScreenLeft = Math . min ( <NUM_LIT> , childLeft - parentLeft ) ; final int offScreenTop = Math . min ( <NUM_LIT> , childTop - parentTop ) ; final int offScreenRight = Math . max ( <NUM_LIT> , childRight - parentRight ) ; final int offScreenBottom = Math . max ( <NUM_LIT> , childBottom - parentBottom ) ; final int dx ; if ( getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ) { dx = offScreenRight != <NUM_LIT> ? offScreenRight : Math . max ( offScreenLeft , childRight - parentRight ) ; } else { dx = offScreenLeft != <NUM_LIT> ? offScreenLeft : Math . min ( childLeft - parentLeft , offScreenRight ) ; } final int dy = offScreenTop != <NUM_LIT> ? offScreenTop : Math . min ( childTop - parentTop , offScreenBottom ) ; out [ <NUM_LIT> ] = dx ; out [ <NUM_LIT> ] = dy ; return out ; } public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate ) { return requestChildRectangleOnScreen ( parent , child , rect , immediate , false ) ; } public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate , boolean focusedChildVisible ) { int [ ] scrollAmount = getChildRectangleOnScreenScrollAmount ( child , rect ) ; int dx = scrollAmount [ <NUM_LIT> ] ; int dy = scrollAmount [ <NUM_LIT> ] ; if ( ! focusedChildVisible || isFocusedChildVisibleAfterScrolling ( parent , dx , dy ) ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { if ( immediate ) { parent . scrollBy ( dx , dy ) ; } else { parent . smoothScrollBy ( dx , dy ) ; } return true ; } } return false ; } public boolean isViewPartiallyVisible ( @ NonNull View child , boolean completelyVisible , boolean acceptEndPointInclusion ) { int boundsFlag = ( ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_EQ_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_EQ_PVE ) ; boolean isViewFullyVisible = mHorizontalBoundCheck . isViewWithinBoundFlags ( child , boundsFlag ) && mVerticalBoundCheck . isViewWithinBoundFlags ( child , boundsFlag ) ; if ( completelyVisible ) { return isViewFullyVisible ; } else { return ! isViewFullyVisible ; } } private boolean isFocusedChildVisibleAfterScrolling ( RecyclerView parent , int dx , int dy ) { final View focusedChild = parent . getFocusedChild ( ) ; if ( focusedChild == null ) { return false ; } final int parentLeft = getPaddingLeft ( ) ; final int parentTop = getPaddingTop ( ) ; final int parentRight = getWidth ( ) - getPaddingRight ( ) ; final int parentBottom = getHeight ( ) - getPaddingBottom ( ) ; final Rect bounds = mRecyclerView . mTempRect ; getDecoratedBoundsWithMargins ( focusedChild , bounds ) ; if ( bounds . left - dx >= parentRight || bounds . right - dx <= parentLeft || bounds . top - dy >= parentBottom || bounds . bottom - dy <= parentTop ) { return false ; } return true ; } @ Deprecated public boolean onRequestChildFocus ( @ NonNull RecyclerView parent , @ NonNull View child , @ Nullable View focused ) { return isSmoothScrolling ( ) || parent . isComputingLayout ( ) ; } public boolean onRequestChildFocus ( @ NonNull RecyclerView parent , @ NonNull State state , @ NonNull View child , @ Nullable View focused ) { return onRequestChildFocus ( parent , child , focused ) ; } public void onAdapterChanged ( @ Nullable Adapter oldAdapter , @ Nullable Adapter newAdapter ) { } public boolean onAddFocusables ( @ NonNull RecyclerView recyclerView , @ NonNull ArrayList < View > views , int direction , int focusableMode ) { return false ; } public void onItemsChanged ( @ NonNull RecyclerView recyclerView ) { } public void onItemsAdded ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsRemoved ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsUpdated ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsUpdated ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount , @ Nullable Object payload ) { onItemsUpdated ( recyclerView , positionStart , itemCount ) ; } public void onItemsMoved ( @ NonNull RecyclerView recyclerView , int from , int to , int itemCount ) { } public int computeHorizontalScrollExtent ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeHorizontalScrollOffset ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeHorizontalScrollRange ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollExtent ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollOffset ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollRange ( @ NonNull State state ) { return <NUM_LIT> ; } public void onMeasure ( @ NonNull Recycler recycler , @ NonNull State state , int widthSpec , int heightSpec ) { mRecyclerView . defaultOnMeasure ( widthSpec , heightSpec ) ; } public void setMeasuredDimension ( int widthSize , int heightSize ) { mRecyclerView . setMeasuredDimension ( widthSize , heightSize ) ; } @ Px public int getMinimumWidth ( ) { return ViewCompat . getMinimumWidth ( mRecyclerView ) ; } @ Px public int getMinimumHeight ( ) { return ViewCompat . getMinimumHeight ( mRecyclerView ) ; } @ Nullable public Parcelable onSaveInstanceState ( ) { return null ; } @ SuppressLint ( "<STR_LIT>" ) public void onRestoreInstanceState ( Parcelable state ) { } void stopSmoothScroller ( ) { if ( mSmoothScroller != null ) { mSmoothScroller . stop ( ) ; } } void onSmoothScrollerStopped ( SmoothScroller smoothScroller ) { if ( mSmoothScroller == smoothScroller ) { mSmoothScroller = null ; } } public void onScrollStateChanged ( int state ) { } public void removeAndRecycleAllViews ( @ NonNull Recycler recycler ) { for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = getChildAt ( i ) ; if ( ! getChildViewHolderInt ( view ) . shouldIgnore ( ) ) { removeAndRecycleViewAt ( i , recycler ) ; } } } void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfoCompat info ) { onInitializeAccessibilityNodeInfo ( mRecyclerView . mRecycler , mRecyclerView . mState , info ) ; } public void onInitializeAccessibilityNodeInfo ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull AccessibilityNodeInfoCompat info ) { if ( mRecyclerView . canScrollVertically ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; info . setScrollable ( true ) ; } if ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; info . setScrollable ( true ) ; } final AccessibilityNodeInfoCompat . CollectionInfoCompat collectionInfo = AccessibilityNodeInfoCompat . CollectionInfoCompat . obtain ( getRowCountForAccessibility ( recycler , state ) , getColumnCountForAccessibility ( recycler , state ) , isLayoutHierarchical ( recycler , state ) , getSelectionModeForAccessibility ( recycler , state ) ) ; info . setCollectionInfo ( collectionInfo ) ; } public void onInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { onInitializeAccessibilityEvent ( mRecyclerView . mRecycler , mRecyclerView . mState , event ) ; } public void onInitializeAccessibilityEvent ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull AccessibilityEvent event ) { if ( mRecyclerView == null || event == null ) { return ; } event . setScrollable ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) || mRecyclerView . canScrollVertically ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) ; if ( mRecyclerView . mAdapter != null ) { event . setItemCount ( mRecyclerView . mAdapter . getItemCount ( ) ) ; } } void onInitializeAccessibilityNodeInfoForItem ( View host , AccessibilityNodeInfoCompat info ) { final ViewHolder vh = getChildViewHolderInt ( host ) ; if ( vh != null && ! vh . isRemoved ( ) && ! mChildHelper . isHidden ( vh . itemView ) ) { onInitializeAccessibilityNodeInfoForItem ( mRecyclerView . mRecycler , mRecyclerView . mState , host , info ) ; } } public void onInitializeAccessibilityNodeInfoForItem ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { } public void requestSimpleAnimationsInNextLayout ( ) { mRequestedSimpleAnimations = true ; } public int getSelectionModeForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return AccessibilityNodeInfoCompat . CollectionInfoCompat . SELECTION_MODE_NONE ; } public int getRowCountForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return - <NUM_LIT> ; } public int getColumnCountForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return - <NUM_LIT> ; } public boolean isLayoutHierarchical ( @ NonNull Recycler recycler , @ NonNull State state ) { return false ; } boolean performAccessibilityAction ( int action , @ Nullable Bundle args ) { return performAccessibilityAction ( mRecyclerView . mRecycler , mRecyclerView . mState , action , args ) ; } public boolean performAccessibilityAction ( @ NonNull Recycler recycler , @ NonNull State state , int action , @ Nullable Bundle args ) { if ( mRecyclerView == null ) { return false ; } int vScroll = <NUM_LIT> , hScroll = <NUM_LIT> ; int height = getHeight ( ) ; int width = getWidth ( ) ; Rect rect = new Rect ( ) ; if ( mRecyclerView . getMatrix ( ) . isIdentity ( ) && mRecyclerView . getGlobalVisibleRect ( rect ) ) { height = rect . height ( ) ; width = rect . width ( ) ; } switch ( action ) { case AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD : if ( mRecyclerView . canScrollVertically ( - <NUM_LIT> ) ) { vScroll = - ( height - getPaddingTop ( ) - getPaddingBottom ( ) ) ; } if ( mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) ) { hScroll = - ( width - getPaddingLeft ( ) - getPaddingRight ( ) ) ; } break ; case AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD : if ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) ) { vScroll = height - getPaddingTop ( ) - getPaddingBottom ( ) ; } if ( mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) { hScroll = width - getPaddingLeft ( ) - getPaddingRight ( ) ; } break ; } if ( vScroll == <NUM_LIT> && hScroll == <NUM_LIT> ) { return false ; } mRecyclerView . smoothScrollBy ( hScroll , vScroll , null , UNDEFINED_DURATION , true ) ; return true ; } boolean performAccessibilityActionForItem ( @ NonNull View view , int action , @ Nullable Bundle args ) { return performAccessibilityActionForItem ( mRecyclerView . mRecycler , mRecyclerView . mState , view , action , args ) ; } public boolean performAccessibilityActionForItem ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull View view , int action , @ Nullable Bundle args ) { return false ; } public static Properties getProperties ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = new Properties ( ) ; TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . RecyclerView , defStyleAttr , defStyleRes ) ; properties . orientation = a . getInt ( R . styleable . RecyclerView_android_orientation , DEFAULT_ORIENTATION ) ; properties . spanCount = a . getInt ( R . styleable . RecyclerView_spanCount , <NUM_LIT> ) ; properties . reverseLayout = a . getBoolean ( R . styleable . RecyclerView_reverseLayout , false ) ; properties . stackFromEnd = a . getBoolean ( R . styleable . RecyclerView_stackFromEnd , false ) ; a . recycle ( ) ; return properties ; } void setExactMeasureSpecsFrom ( RecyclerView recyclerView ) { setMeasureSpecs ( MeasureSpec . makeMeasureSpec ( recyclerView . getWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( recyclerView . getHeight ( ) , MeasureSpec . EXACTLY ) ) ; } boolean shouldMeasureTwice ( ) { return false ; } boolean hasFlexibleChildInBothOrientations ( ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final ViewGroup . LayoutParams lp = child . getLayoutParams ( ) ; if ( lp . width < <NUM_LIT> && lp . height < <NUM_LIT> ) { return true ; } } return false ; } public static class Properties { public int orientation ; public int spanCount ; public boolean reverseLayout ; public boolean stackFromEnd ; } } public abstract static class ItemDecoration { public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { onDraw ( c , parent ) ; } @ Deprecated public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { onDrawOver ( c , parent ) ; } @ Deprecated public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Deprecated public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) { getItemOffsets ( outRect , ( ( LayoutParams ) view . getLayoutParams ( ) ) . getViewLayoutPosition ( ) , parent ) ; } } public interface OnItemTouchListener { boolean onInterceptTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) ; void onTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) ; void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) ; } public static class SimpleOnItemTouchListener implements RecyclerView . OnItemTouchListener { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) { return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) { } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } } public abstract static class OnScrollListener { public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { } public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { } } public interface RecyclerListener { void onViewRecycled ( @ NonNull ViewHolder holder ) ; } public interface OnChildAttachStateChangeListener { void onChildViewAttachedToWindow ( @ NonNull View view ) ; void onChildViewDetachedFromWindow ( @ NonNull View view ) ; } public abstract static class ViewHolder { @ NonNull public final View itemView ; WeakReference < RecyclerView > mNestedRecyclerView ; int mPosition = NO_POSITION ; int mOldPosition = NO_POSITION ; long mItemId = NO_ID ; int mItemViewType = INVALID_TYPE ; int mPreLayoutPosition = NO_POSITION ; ViewHolder mShadowedHolder = null ; ViewHolder mShadowingHolder = null ; static final int FLAG_BOUND = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_INVALID = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_REMOVED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_NOT_RECYCLABLE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_RETURNED_FROM_SCRAP = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_IGNORE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_TMP_DETACHED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_ADAPTER_POSITION_UNKNOWN = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_ADAPTER_FULLUPDATE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_MOVED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_APPEARED_IN_PRE_LAYOUT = <NUM_LIT> << <NUM_LIT> ; static final int PENDING_ACCESSIBILITY_STATE_NOT_SET = - <NUM_LIT> ; static final int FLAG_BOUNCED_FROM_HIDDEN_LIST = <NUM_LIT> << <NUM_LIT> ; int mFlags ; private static final List < Object > FULLUPDATE_PAYLOADS = Collections . emptyList ( ) ; List < Object > mPayloads = null ; List < Object > mUnmodifiedPayloads = null ; private int mIsRecyclableCount = <NUM_LIT> ; Recycler mScrapContainer = null ; boolean mInChangeScrap = false ; private int mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; @ VisibleForTesting int mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET ; RecyclerView mOwnerRecyclerView ; Adapter < ? extends ViewHolder > mBindingAdapter ; public ViewHolder ( @ NonNull View itemView ) { if ( itemView == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } this . itemView = itemView ; } void flagRemovedAndOffsetPosition ( int mNewPosition , int offset , boolean applyToPreLayout ) { addFlags ( ViewHolder . FLAG_REMOVED ) ; offsetPosition ( offset , applyToPreLayout ) ; mPosition = mNewPosition ; } void offsetPosition ( int offset , boolean applyToPreLayout ) { if ( mOldPosition == NO_POSITION ) { mOldPosition = mPosition ; } if ( mPreLayoutPosition == NO_POSITION ) { mPreLayoutPosition = mPosition ; } if ( applyToPreLayout ) { mPreLayoutPosition += offset ; } mPosition += offset ; if ( itemView . getLayoutParams ( ) != null ) { ( ( LayoutParams ) itemView . getLayoutParams ( ) ) . mInsetsDirty = true ; } } void clearOldPosition ( ) { mOldPosition = NO_POSITION ; mPreLayoutPosition = NO_POSITION ; } void saveOldPosition ( ) { if ( mOldPosition == NO_POSITION ) { mOldPosition = mPosition ; } } boolean shouldIgnore ( ) { return ( mFlags & FLAG_IGNORE ) != <NUM_LIT> ; } @ Deprecated public final int getPosition ( ) { return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition ; } public final int getLayoutPosition ( ) { return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition ; } @ Deprecated public final int getAdapterPosition ( ) { return getBindingAdapterPosition ( ) ; } public final int getBindingAdapterPosition ( ) { if ( mBindingAdapter == null ) { return NO_POSITION ; } if ( mOwnerRecyclerView == null ) { return NO_POSITION ; } @ SuppressWarnings ( "<STR_LIT>" ) Adapter < ? extends ViewHolder > rvAdapter = mOwnerRecyclerView . getAdapter ( ) ; if ( rvAdapter == null ) { return NO_POSITION ; } int globalPosition = mOwnerRecyclerView . getAdapterPositionInRecyclerView ( this ) ; if ( globalPosition == NO_POSITION ) { return NO_POSITION ; } return rvAdapter . findRelativeAdapterPositionIn ( mBindingAdapter , this , globalPosition ) ; } public final int getAbsoluteAdapterPosition ( ) { if ( mOwnerRecyclerView == null ) { return NO_POSITION ; } return mOwnerRecyclerView . getAdapterPositionInRecyclerView ( this ) ; } @ Nullable public final Adapter < ? extends ViewHolder > getBindingAdapter ( ) { return mBindingAdapter ; } public final int getOldPosition ( ) { return mOldPosition ; } public final long getItemId ( ) { return mItemId ; } public final int getItemViewType ( ) { return mItemViewType ; } boolean isScrap ( ) { return mScrapContainer != null ; } void unScrap ( ) { mScrapContainer . unscrapView ( this ) ; } boolean wasReturnedFromScrap ( ) { return ( mFlags & FLAG_RETURNED_FROM_SCRAP ) != <NUM_LIT> ; } void clearReturnedFromScrapFlag ( ) { mFlags = mFlags & ~ FLAG_RETURNED_FROM_SCRAP ; } void clearTmpDetachFlag ( ) { mFlags = mFlags & ~ FLAG_TMP_DETACHED ; } void stopIgnoring ( ) { mFlags = mFlags & ~ FLAG_IGNORE ; } void setScrapContainer ( Recycler recycler , boolean isChangeScrap ) { mScrapContainer = recycler ; mInChangeScrap = isChangeScrap ; } boolean isInvalid ( ) { return ( mFlags & FLAG_INVALID ) != <NUM_LIT> ; } boolean needsUpdate ( ) { return ( mFlags & FLAG_UPDATE ) != <NUM_LIT> ; } boolean isBound ( ) { return ( mFlags & FLAG_BOUND ) != <NUM_LIT> ; } boolean isRemoved ( ) { return ( mFlags & FLAG_REMOVED ) != <NUM_LIT> ; } boolean hasAnyOfTheFlags ( int flags ) { return ( mFlags & flags ) != <NUM_LIT> ; } boolean isTmpDetached ( ) { return ( mFlags & FLAG_TMP_DETACHED ) != <NUM_LIT> ; } boolean isAttachedToTransitionOverlay ( ) { return itemView . getParent ( ) != null && itemView . getParent ( ) != mOwnerRecyclerView ; } boolean isAdapterPositionUnknown ( ) { return ( mFlags & FLAG_ADAPTER_POSITION_UNKNOWN ) != <NUM_LIT> || isInvalid ( ) ; } void setFlags ( int flags , int mask ) { mFlags = ( mFlags & ~ mask ) | ( flags & mask ) ; } void addFlags ( int flags ) { mFlags |= flags ; } void addChangePayload ( Object payload ) { if ( payload == null ) { addFlags ( FLAG_ADAPTER_FULLUPDATE ) ; } else if ( ( mFlags & FLAG_ADAPTER_FULLUPDATE ) == <NUM_LIT> ) { createPayloadsIfNeeded ( ) ; mPayloads . add ( payload ) ; } } private void createPayloadsIfNeeded ( ) { if ( mPayloads == null ) { mPayloads = new ArrayList < Object > ( ) ; mUnmodifiedPayloads = Collections . unmodifiableList ( mPayloads ) ; } } void clearPayload ( ) { if ( mPayloads != null ) { mPayloads . clear ( ) ; } mFlags = mFlags & ~ FLAG_ADAPTER_FULLUPDATE ; } List < Object > getUnmodifiedPayloads ( ) { if ( ( mFlags & FLAG_ADAPTER_FULLUPDATE ) == <NUM_LIT> ) { if ( mPayloads == null || mPayloads . size ( ) == <NUM_LIT> ) { return FULLUPDATE_PAYLOADS ; } return mUnmodifiedPayloads ; } else { return FULLUPDATE_PAYLOADS ; } } void resetInternal ( ) { if ( sDebugAssertionsEnabled && isTmpDetached ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + this + "<STR_LIT>" ) ; } mFlags = <NUM_LIT> ; mPosition = NO_POSITION ; mOldPosition = NO_POSITION ; mItemId = NO_ID ; mPreLayoutPosition = NO_POSITION ; mIsRecyclableCount = <NUM_LIT> ; mShadowedHolder = null ; mShadowingHolder = null ; clearPayload ( ) ; mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET ; clearNestedRecyclerViewIfNotNested ( this ) ; } void onEnteredHiddenState ( RecyclerView parent ) { if ( mPendingAccessibilityState != PENDING_ACCESSIBILITY_STATE_NOT_SET ) { mWasImportantForAccessibilityBeforeHidden = mPendingAccessibilityState ; } else { mWasImportantForAccessibilityBeforeHidden = ViewCompat . getImportantForAccessibility ( itemView ) ; } parent . setChildImportantForAccessibilityInternal ( this , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS ) ; } void onLeftHiddenState ( RecyclerView parent ) { parent . setChildImportantForAccessibilityInternal ( this , mWasImportantForAccessibilityBeforeHidden ) ; mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; } @ Override public String toString ( ) { String className = getClass ( ) . isAnonymousClass ( ) ? "<STR_LIT>" : getClass ( ) . getSimpleName ( ) ; final StringBuilder sb = new StringBuilder ( className + "<STR_LIT>" + Integer . toHexString ( hashCode ( ) ) + "<STR_LIT>" + mPosition + "<STR_LIT>" + mItemId + "<STR_LIT>" + mOldPosition + "<STR_LIT>" + mPreLayoutPosition ) ; if ( isScrap ( ) ) { sb . append ( "<STR_LIT>" ) . append ( mInChangeScrap ? "<STR_LIT>" : "<STR_LIT>" ) ; } if ( isInvalid ( ) ) sb . append ( "<STR_LIT>" ) ; if ( ! isBound ( ) ) sb . append ( "<STR_LIT>" ) ; if ( needsUpdate ( ) ) sb . append ( "<STR_LIT>" ) ; if ( isRemoved ( ) ) sb . append ( "<STR_LIT>" ) ; if ( shouldIgnore ( ) ) sb . append ( "<STR_LIT>" ) ; if ( isTmpDetached ( ) ) sb . append ( "<STR_LIT>" ) ; if ( ! isRecyclable ( ) ) sb . append ( "<STR_LIT>" + mIsRecyclableCount + "<STR_LIT>" ) ; if ( isAdapterPositionUnknown ( ) ) sb . append ( "<STR_LIT>" ) ; if ( itemView . getParent ( ) == null ) sb . append ( "<STR_LIT>" ) ; sb . append ( "<STR_LIT>" ) ; return sb . toString ( ) ; } public final void setIsRecyclable ( boolean recyclable ) { mIsRecyclableCount = recyclable ? mIsRecyclableCount - <NUM_LIT> : mIsRecyclableCount + <NUM_LIT> ; if ( mIsRecyclableCount < <NUM_LIT> ) { mIsRecyclableCount = <NUM_LIT> ; if ( sDebugAssertionsEnabled ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + this ) ; } Log . e ( VIEW_LOG_TAG , "<STR_LIT>" + "<STR_LIT>" + this ) ; } else if ( ! recyclable && mIsRecyclableCount == <NUM_LIT> ) { mFlags |= FLAG_NOT_RECYCLABLE ; } else if ( recyclable && mIsRecyclableCount == <NUM_LIT> ) { mFlags &= ~ FLAG_NOT_RECYCLABLE ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + recyclable + "<STR_LIT>" + this ) ; } } public final boolean isRecyclable ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) == <NUM_LIT> && ! ViewCompat . hasTransientState ( itemView ) ; } boolean shouldBeKeptAsChild ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) != <NUM_LIT> ; } boolean doesTransientStatePreventRecycling ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) == <NUM_LIT> && ViewCompat . hasTransientState ( itemView ) ; } boolean isUpdated ( ) { return ( mFlags & FLAG_UPDATE ) != <NUM_LIT> ; } } @ VisibleForTesting boolean setChildImportantForAccessibilityInternal ( ViewHolder viewHolder , int importantForAccessibility ) { if ( isComputingLayout ( ) ) { viewHolder . mPendingAccessibilityState = importantForAccessibility ; mPendingAccessibilityImportanceChange . add ( viewHolder ) ; return false ; } ViewCompat . setImportantForAccessibility ( viewHolder . itemView , importantForAccessibility ) ; return true ; } void dispatchPendingImportantForAccessibilityChanges ( ) { for ( int i = mPendingAccessibilityImportanceChange . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ViewHolder viewHolder = mPendingAccessibilityImportanceChange . get ( i ) ; if ( viewHolder . itemView . getParent ( ) != this || viewHolder . shouldIgnore ( ) ) { continue ; } int state = viewHolder . mPendingAccessibilityState ; if ( state != ViewHolder . PENDING_ACCESSIBILITY_STATE_NOT_SET ) { ViewCompat . setImportantForAccessibility ( viewHolder . itemView , state ) ; viewHolder . mPendingAccessibilityState = ViewHolder . PENDING_ACCESSIBILITY_STATE_NOT_SET ; } } mPendingAccessibilityImportanceChange . clear ( ) ; } int getAdapterPositionInRecyclerView ( ViewHolder viewHolder ) { if ( viewHolder . hasAnyOfTheFlags ( ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) || ! viewHolder . isBound ( ) ) { return RecyclerView . NO_POSITION ; } return mAdapterHelper . applyPendingUpdatesToPosition ( viewHolder . mPosition ) ; } @ VisibleForTesting void initFastScroller ( StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable ) { if ( verticalThumbDrawable == null || verticalTrackDrawable == null || horizontalThumbDrawable == null || horizontalTrackDrawable == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } Resources resources = getContext ( ) . getResources ( ) ; new FastScroller ( this , verticalThumbDrawable , verticalTrackDrawable , horizontalThumbDrawable , horizontalTrackDrawable , resources . getDimensionPixelSize ( R . dimen . fastscroll_default_thickness ) , resources . getDimensionPixelSize ( R . dimen . fastscroll_minimum_range ) , resources . getDimensionPixelOffset ( R . dimen . fastscroll_margin ) ) ; } @ Override public void setNestedScrollingEnabled ( boolean enabled ) { getScrollingChildHelper ( ) . setNestedScrollingEnabled ( enabled ) ; } @ Override public boolean isNestedScrollingEnabled ( ) { return getScrollingChildHelper ( ) . isNestedScrollingEnabled ( ) ; } @ Override public boolean startNestedScroll ( int axes ) { return getScrollingChildHelper ( ) . startNestedScroll ( axes ) ; } @ Override public boolean startNestedScroll ( int axes , int type ) { return getScrollingChildHelper ( ) . startNestedScroll ( axes , type ) ; } @ Override public void stopNestedScroll ( ) { getScrollingChildHelper ( ) . stopNestedScroll ( ) ; } @ Override public void stopNestedScroll ( int type ) { getScrollingChildHelper ( ) . stopNestedScroll ( type ) ; } @ Override public boolean hasNestedScrollingParent ( ) { return getScrollingChildHelper ( ) . hasNestedScrollingParent ( ) ; } @ Override public boolean hasNestedScrollingParent ( int type ) { return getScrollingChildHelper ( ) . hasNestedScrollingParent ( type ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow ) { return getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow , int type ) { return getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type ) ; } @ Override public final void dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow , int type , @ NonNull int [ ] consumed ) { getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type , consumed ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow ) { return getScrollingChildHelper ( ) . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow , int type ) { return getScrollingChildHelper ( ) . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow , type ) ; } @ Override public boolean dispatchNestedFling ( float velocityX , float velocityY , boolean consumed ) { return getScrollingChildHelper ( ) . dispatchNestedFling ( velocityX , velocityY , consumed ) ; } @ Override public boolean dispatchNestedPreFling ( float velocityX , float velocityY ) { return getScrollingChildHelper ( ) . dispatchNestedPreFling ( velocityX , velocityY ) ; } public static class LayoutParams extends android . view . ViewGroup . MarginLayoutParams { ViewHolder mViewHolder ; final Rect mDecorInsets = new Rect ( ) ; boolean mInsetsDirty = true ; boolean mPendingInvalidate = false ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( LayoutParams source ) { super ( ( ViewGroup . LayoutParams ) source ) ; } public boolean viewNeedsUpdate ( ) { return mViewHolder . needsUpdate ( ) ; } public boolean isViewInvalid ( ) { return mViewHolder . isInvalid ( ) ; } public boolean isItemRemoved ( ) { return mViewHolder . isRemoved ( ) ; } public boolean isItemChanged ( ) { return mViewHolder . isUpdated ( ) ; } @ Deprecated public int getViewPosition ( ) { return mViewHolder . getPosition ( ) ; } public int getViewLayoutPosition ( ) { return mViewHolder . getLayoutPosition ( ) ; } @ Deprecated public int getViewAdapterPosition ( ) { return mViewHolder . getBindingAdapterPosition ( ) ; } public int getAbsoluteAdapterPosition ( ) { return mViewHolder . getAbsoluteAdapterPosition ( ) ; } public int getBindingAdapterPosition ( ) { return mViewHolder . getBindingAdapterPosition ( ) ; } } public abstract static class AdapterDataObserver { public void onChanged ( ) { } public void onItemRangeChanged ( int positionStart , int itemCount ) { } public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onItemRangeChanged ( positionStart , itemCount ) ; } public void onItemRangeInserted ( int positionStart , int itemCount ) { } public void onItemRangeRemoved ( int positionStart , int itemCount ) { } public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { } public void onStateRestorationPolicyChanged ( ) { } } public abstract static class SmoothScroller { private int mTargetPosition = RecyclerView . NO_POSITION ; private RecyclerView mRecyclerView ; private LayoutManager mLayoutManager ; private boolean mPendingInitialRun ; private boolean mRunning ; private View mTargetView ; private final Action mRecyclingAction ; private boolean mStarted ; public SmoothScroller ( ) { mRecyclingAction = new Action ( <NUM_LIT> , <NUM_LIT> ) ; } void start ( RecyclerView recyclerView , LayoutManager layoutManager ) { recyclerView . mViewFlinger . stop ( ) ; if ( mStarted ) { Log . w ( TAG , "<STR_LIT>" + this . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + "<STR_LIT>" + this . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } mRecyclerView = recyclerView ; mLayoutManager = layoutManager ; if ( mTargetPosition == RecyclerView . NO_POSITION ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mRecyclerView . mState . mTargetPosition = mTargetPosition ; mRunning = true ; mPendingInitialRun = true ; mTargetView = findViewByPosition ( getTargetPosition ( ) ) ; onStart ( ) ; mRecyclerView . mViewFlinger . postOnAnimation ( ) ; mStarted = true ; } public void setTargetPosition ( int targetPosition ) { mTargetPosition = targetPosition ; } @ Nullable public PointF computeScrollVectorForPosition ( int targetPosition ) { LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager instanceof ScrollVectorProvider ) { return ( ( ScrollVectorProvider ) layoutManager ) . computeScrollVectorForPosition ( targetPosition ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + ScrollVectorProvider . class . getCanonicalName ( ) ) ; return null ; } @ Nullable public LayoutManager getLayoutManager ( ) { return mLayoutManager ; } protected final void stop ( ) { if ( ! mRunning ) { return ; } mRunning = false ; onStop ( ) ; mRecyclerView . mState . mTargetPosition = RecyclerView . NO_POSITION ; mTargetView = null ; mTargetPosition = RecyclerView . NO_POSITION ; mPendingInitialRun = false ; mLayoutManager . onSmoothScrollerStopped ( this ) ; mLayoutManager = null ; mRecyclerView = null ; } public boolean isPendingInitialRun ( ) { return mPendingInitialRun ; } public boolean isRunning ( ) { return mRunning ; } public int getTargetPosition ( ) { return mTargetPosition ; } void onAnimation ( int dx , int dy ) { final RecyclerView recyclerView = mRecyclerView ; if ( mTargetPosition == RecyclerView . NO_POSITION || recyclerView == null ) { stop ( ) ; } if ( mPendingInitialRun && mTargetView == null && mLayoutManager != null ) { PointF pointF = computeScrollVectorForPosition ( mTargetPosition ) ; if ( pointF != null && ( pointF . x != <NUM_LIT> || pointF . y != <NUM_LIT> ) ) { recyclerView . scrollStep ( ( int ) Math . signum ( pointF . x ) , ( int ) Math . signum ( pointF . y ) , null ) ; } } mPendingInitialRun = false ; if ( mTargetView != null ) { if ( getChildPosition ( mTargetView ) == mTargetPosition ) { onTargetFound ( mTargetView , recyclerView . mState , mRecyclingAction ) ; mRecyclingAction . runIfNecessary ( recyclerView ) ; stop ( ) ; } else { Log . e ( TAG , "<STR_LIT>" ) ; mTargetView = null ; } } if ( mRunning ) { onSeekTargetStep ( dx , dy , recyclerView . mState , mRecyclingAction ) ; boolean hadJumpTarget = mRecyclingAction . hasJumpTarget ( ) ; mRecyclingAction . runIfNecessary ( recyclerView ) ; if ( hadJumpTarget ) { if ( mRunning ) { mPendingInitialRun = true ; recyclerView . mViewFlinger . postOnAnimation ( ) ; } } } } public int getChildPosition ( View view ) { return mRecyclerView . getChildLayoutPosition ( view ) ; } public int getChildCount ( ) { return mRecyclerView . mLayout . getChildCount ( ) ; } public View findViewByPosition ( int position ) { return mRecyclerView . mLayout . findViewByPosition ( position ) ; } @ Deprecated public void instantScrollToPosition ( int position ) { mRecyclerView . scrollToPosition ( position ) ; } protected void onChildAttachedToWindow ( View child ) { if ( getChildPosition ( child ) == getTargetPosition ( ) ) { mTargetView = child ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } } } protected void normalize ( @ NonNull PointF scrollVector ) { final float magnitude = ( float ) Math . sqrt ( scrollVector . x * scrollVector . x + scrollVector . y * scrollVector . y ) ; scrollVector . x /= magnitude ; scrollVector . y /= magnitude ; } protected abstract void onStart ( ) ; protected abstract void onStop ( ) ; protected abstract void onSeekTargetStep ( @ Px int dx , @ Px int dy , @ NonNull State state , @ NonNull Action action ) ; protected abstract void onTargetFound ( @ NonNull View targetView , @ NonNull State state , @ NonNull Action action ) ; public static class Action { public static final int UNDEFINED_DURATION = RecyclerView . UNDEFINED_DURATION ; private int mDx ; private int mDy ; private int mDuration ; private int mJumpToPosition = NO_POSITION ; private Interpolator mInterpolator ; private boolean mChanged = false ; private int mConsecutiveUpdates = <NUM_LIT> ; public Action ( @ Px int dx , @ Px int dy ) { this ( dx , dy , UNDEFINED_DURATION , null ) ; } public Action ( @ Px int dx , @ Px int dy , int duration ) { this ( dx , dy , duration , null ) ; } public Action ( @ Px int dx , @ Px int dy , int duration , @ Nullable Interpolator interpolator ) { mDx = dx ; mDy = dy ; mDuration = duration ; mInterpolator = interpolator ; } public void jumpTo ( int targetPosition ) { mJumpToPosition = targetPosition ; } boolean hasJumpTarget ( ) { return mJumpToPosition >= <NUM_LIT> ; } void runIfNecessary ( RecyclerView recyclerView ) { if ( mJumpToPosition >= <NUM_LIT> ) { final int position = mJumpToPosition ; mJumpToPosition = NO_POSITION ; recyclerView . jumpToPositionForSmoothScroller ( position ) ; mChanged = false ; return ; } if ( mChanged ) { validate ( ) ; recyclerView . mViewFlinger . smoothScrollBy ( mDx , mDy , mDuration , mInterpolator ) ; mConsecutiveUpdates ++ ; if ( mConsecutiveUpdates > <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } mChanged = false ; } else { mConsecutiveUpdates = <NUM_LIT> ; } } private void validate ( ) { if ( mInterpolator != null && mDuration < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } else if ( mDuration < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } @ Px public int getDx ( ) { return mDx ; } public void setDx ( @ Px int dx ) { mChanged = true ; mDx = dx ; } @ Px public int getDy ( ) { return mDy ; } public void setDy ( @ Px int dy ) { mChanged = true ; mDy = dy ; } public int getDuration ( ) { return mDuration ; } public void setDuration ( int duration ) { mChanged = true ; mDuration = duration ; } @ Nullable public Interpolator getInterpolator ( ) { return mInterpolator ; } public void setInterpolator ( @ Nullable Interpolator interpolator ) { mChanged = true ; mInterpolator = interpolator ; } public void update ( @ Px int dx , @ Px int dy , int duration , @ Nullable Interpolator interpolator ) { mDx = dx ; mDy = dy ; mDuration = duration ; mInterpolator = interpolator ; mChanged = true ; } } public interface ScrollVectorProvider { @ Nullable PointF computeScrollVectorForPosition ( int targetPosition ) ; } } static class AdapterDataObservable extends Observable < AdapterDataObserver > { public boolean hasObservers ( ) { return ! mObservers . isEmpty ( ) ; } public void notifyChanged ( ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onChanged ( ) ; } } public void notifyStateRestorationPolicyChanged ( ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onStateRestorationPolicyChanged ( ) ; } } public void notifyItemRangeChanged ( int positionStart , int itemCount ) { notifyItemRangeChanged ( positionStart , itemCount , null ) ; } public void notifyItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeChanged ( positionStart , itemCount , payload ) ; } } public void notifyItemRangeInserted ( int positionStart , int itemCount ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeInserted ( positionStart , itemCount ) ; } } public void notifyItemRangeRemoved ( int positionStart , int itemCount ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeRemoved ( positionStart , itemCount ) ; } } public void notifyItemMoved ( int fromPosition , int toPosition ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeMoved ( fromPosition , toPosition , <NUM_LIT> ) ; } } } @ RestrictTo ( LIBRARY ) public static class SavedState extends AbsSavedState { Parcelable mLayoutState ; @ SuppressWarnings ( "<STR_LIT>" ) SavedState ( Parcel in , ClassLoader loader ) { super ( in , loader ) ; mLayoutState = in . readParcelable ( loader != null ? loader : LayoutManager . class . getClassLoader ( ) ) ; } SavedState ( Parcelable superState ) { super ( superState ) ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeParcelable ( mLayoutState , <NUM_LIT> ) ; } void copyFrom ( SavedState other ) { mLayoutState = other . mLayoutState ; } public static final Creator < SavedState > CREATOR = new ClassLoaderCreator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in , ClassLoader loader ) { return new SavedState ( in , loader ) ; } @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in , null ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } public static class State { static final int STEP_START = <NUM_LIT> ; static final int STEP_LAYOUT = <NUM_LIT> << <NUM_LIT> ; static final int STEP_ANIMATIONS = <NUM_LIT> << <NUM_LIT> ; void assertLayoutStep ( int accepted ) { if ( ( accepted & mLayoutStep ) == <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + Integer . toBinaryString ( accepted ) + "<STR_LIT>" + Integer . toBinaryString ( mLayoutStep ) ) ; } } int mTargetPosition = RecyclerView . NO_POSITION ; private SparseArray < Object > mData ; int mPreviousLayoutItemCount = <NUM_LIT> ; int mDeletedInvisibleItemCountSincePreviousLayout = <NUM_LIT> ; @ IntDef ( flag = true , value = { STEP_START , STEP_LAYOUT , STEP_ANIMATIONS } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface LayoutState { } @ LayoutState int mLayoutStep = STEP_START ; int mItemCount = <NUM_LIT> ; boolean mStructureChanged = false ; boolean mInPreLayout = false ; boolean mTrackOldChangeHolders = false ; boolean mIsMeasuring = false ; boolean mRunSimpleAnimations = false ; boolean mRunPredictiveAnimations = false ; int mFocusedItemPosition ; long mFocusedItemId ; int mFocusedSubChildId ; int mRemainingScrollHorizontal ; int mRemainingScrollVertical ; void prepareForNestedPrefetch ( Adapter adapter ) { mLayoutStep = STEP_START ; mItemCount = adapter . getItemCount ( ) ; mInPreLayout = false ; mTrackOldChangeHolders = false ; mIsMeasuring = false ; } public boolean isMeasuring ( ) { return mIsMeasuring ; } public boolean isPreLayout ( ) { return mInPreLayout ; } public boolean willRunPredictiveAnimations ( ) { return mRunPredictiveAnimations ; } public boolean willRunSimpleAnimations ( ) { return mRunSimpleAnimations ; } public void remove ( int resourceId ) { if ( mData == null ) { return ; } mData . remove ( resourceId ) ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public < T > T get ( int resourceId ) { if ( mData == null ) { return null ; } return ( T ) mData . get ( resourceId ) ; } public void put ( int resourceId , Object data ) { if ( mData == null ) { mData = new SparseArray < Object > ( ) ; } mData . put ( resourceId , data ) ; } public int getTargetScrollPosition ( ) { return mTargetPosition ; } public boolean hasTargetScrollPosition ( ) { return mTargetPosition != RecyclerView . NO_POSITION ; } public boolean didStructureChange ( ) { return mStructureChanged ; } public int getItemCount ( ) { return mInPreLayout ? ( mPreviousLayoutItemCount - mDeletedInvisibleItemCountSincePreviousLayout ) : mItemCount ; } public int getRemainingScrollHorizontal ( ) { return mRemainingScrollHorizontal ; } public int getRemainingScrollVertical ( ) { return mRemainingScrollVertical ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mTargetPosition + "<STR_LIT>" + mData + "<STR_LIT>" + mItemCount + "<STR_LIT>" + mIsMeasuring + "<STR_LIT>" + mPreviousLayoutItemCount + "<STR_LIT>" + mDeletedInvisibleItemCountSincePreviousLayout + "<STR_LIT>" + mStructureChanged + "<STR_LIT>" + mInPreLayout + "<STR_LIT>" + mRunSimpleAnimations + "<STR_LIT>" + mRunPredictiveAnimations + '<STR_LIT>' ; } } public abstract static class OnFlingListener { public abstract boolean onFling ( int velocityX , int velocityY ) ; } private class ItemAnimatorRestoreListener implements ItemAnimator . ItemAnimatorListener { ItemAnimatorRestoreListener ( ) { } @ Override public void onAnimationFinished ( ViewHolder item ) { item . setIsRecyclable ( true ) ; if ( item . mShadowedHolder != null && item . mShadowingHolder == null ) { item . mShadowedHolder = null ; } item . mShadowingHolder = null ; if ( ! item . shouldBeKeptAsChild ( ) ) { if ( ! removeAnimatingView ( item . itemView ) && item . isTmpDetached ( ) ) { removeDetachedView ( item . itemView , false ) ; } } } } @ SuppressWarnings ( "<STR_LIT>" ) public abstract static class ItemAnimator { public static final int FLAG_CHANGED = ViewHolder . FLAG_UPDATE ; public static final int FLAG_REMOVED = ViewHolder . FLAG_REMOVED ; public static final int FLAG_INVALIDATED = ViewHolder . FLAG_INVALID ; public static final int FLAG_MOVED = ViewHolder . FLAG_MOVED ; public static final int FLAG_APPEARED_IN_PRE_LAYOUT = ViewHolder . FLAG_APPEARED_IN_PRE_LAYOUT ; @ IntDef ( flag = true , value = { FLAG_CHANGED , FLAG_REMOVED , FLAG_MOVED , FLAG_INVALIDATED , FLAG_APPEARED_IN_PRE_LAYOUT } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface AdapterChanges { } private ItemAnimatorListener mListener = null ; private ArrayList < ItemAnimatorFinishedListener > mFinishedListeners = new ArrayList < ItemAnimatorFinishedListener > ( ) ; private long mAddDuration = <NUM_LIT> ; private long mRemoveDuration = <NUM_LIT> ; private long mMoveDuration = <NUM_LIT> ; private long mChangeDuration = <NUM_LIT> ; public long getMoveDuration ( ) { return mMoveDuration ; } public void setMoveDuration ( long moveDuration ) { mMoveDuration = moveDuration ; } public long getAddDuration ( ) { return mAddDuration ; } public void setAddDuration ( long addDuration ) { mAddDuration = addDuration ; } public long getRemoveDuration ( ) { return mRemoveDuration ; } public void setRemoveDuration ( long removeDuration ) { mRemoveDuration = removeDuration ; } public long getChangeDuration ( ) { return mChangeDuration ; } public void setChangeDuration ( long changeDuration ) { mChangeDuration = changeDuration ; } void setListener ( ItemAnimatorListener listener ) { mListener = listener ; } public @ NonNull ItemHolderInfo recordPreLayoutInformation ( @ NonNull State state , @ NonNull ViewHolder viewHolder , @ AdapterChanges int changeFlags , @ NonNull List < Object > payloads ) { return obtainHolderInfo ( ) . setFrom ( viewHolder ) ; } public @ NonNull ItemHolderInfo recordPostLayoutInformation ( @ NonNull State state , @ NonNull ViewHolder viewHolder ) { return obtainHolderInfo ( ) . setFrom ( viewHolder ) ; } public abstract boolean animateDisappearance ( @ NonNull ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) ; public abstract boolean animateAppearance ( @ NonNull ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; public abstract boolean animatePersistence ( @ NonNull ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; public abstract boolean animateChange ( @ NonNull ViewHolder oldHolder , @ NonNull ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; @ AdapterChanges static int buildAdapterChangeFlagsForAnimations ( ViewHolder viewHolder ) { int flags = viewHolder . mFlags & ( FLAG_INVALIDATED | FLAG_REMOVED | FLAG_CHANGED ) ; if ( viewHolder . isInvalid ( ) ) { return FLAG_INVALIDATED ; } if ( ( flags & FLAG_INVALIDATED ) == <NUM_LIT> ) { final int oldPos = viewHolder . getOldPosition ( ) ; final int pos = viewHolder . getAbsoluteAdapterPosition ( ) ; if ( oldPos != NO_POSITION && pos != NO_POSITION && oldPos != pos ) { flags |= FLAG_MOVED ; } } return flags ; } public abstract void runPendingAnimations ( ) ; public abstract void endAnimation ( @ NonNull ViewHolder item ) ; public abstract void endAnimations ( ) ; public abstract boolean isRunning ( ) ; public final void dispatchAnimationFinished ( @ NonNull ViewHolder viewHolder ) { onAnimationFinished ( viewHolder ) ; if ( mListener != null ) { mListener . onAnimationFinished ( viewHolder ) ; } } public void onAnimationFinished ( @ NonNull ViewHolder viewHolder ) { } public final void dispatchAnimationStarted ( @ NonNull ViewHolder viewHolder ) { onAnimationStarted ( viewHolder ) ; } public void onAnimationStarted ( @ NonNull ViewHolder viewHolder ) { } public final boolean isRunning ( @ Nullable ItemAnimatorFinishedListener listener ) { boolean running = isRunning ( ) ; if ( listener != null ) { if ( ! running ) { listener . onAnimationsFinished ( ) ; } else { mFinishedListeners . add ( listener ) ; } } return running ; } public boolean canReuseUpdatedViewHolder ( @ NonNull ViewHolder viewHolder ) { return true ; } public boolean canReuseUpdatedViewHolder ( @ NonNull ViewHolder viewHolder , @ NonNull List < Object > payloads ) { return canReuseUpdatedViewHolder ( viewHolder ) ; } public final void dispatchAnimationsFinished ( ) { final int count = mFinishedListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { mFinishedListeners . get ( i ) . onAnimationsFinished ( ) ; } mFinishedListeners . clear ( ) ; } @ NonNull public ItemHolderInfo obtainHolderInfo ( ) { return new ItemHolderInfo ( ) ; } interface ItemAnimatorListener { void onAnimationFinished ( @ NonNull ViewHolder item ) ; } public interface ItemAnimatorFinishedListener { void onAnimationsFinished ( ) ; } public static class ItemHolderInfo { public int left ; public int top ; public int right ; public int bottom ; @ AdapterChanges public int changeFlags ; public ItemHolderInfo ( ) { } @ NonNull public ItemHolderInfo setFrom ( @ NonNull RecyclerView . ViewHolder holder ) { return setFrom ( holder , <NUM_LIT> ) ; } @ NonNull public ItemHolderInfo setFrom ( @ NonNull RecyclerView . ViewHolder holder , @ AdapterChanges int flags ) { final View view = holder . itemView ; this . left = view . getLeft ( ) ; this . top = view . getTop ( ) ; this . right = view . getRight ( ) ; this . bottom = view . getBottom ( ) ; return this ; } } } @ Override protected int getChildDrawingOrder ( int childCount , int i ) { if ( mChildDrawingOrderCallback == null ) { return super . getChildDrawingOrder ( childCount , i ) ; } else { return mChildDrawingOrderCallback . onGetChildDrawingOrder ( childCount , i ) ; } } public interface ChildDrawingOrderCallback { int onGetChildDrawingOrder ( int childCount , int i ) ; } private NestedScrollingChildHelper getScrollingChildHelper ( ) { if ( mScrollingChildHelper == null ) { mScrollingChildHelper = new NestedScrollingChildHelper ( this ) ; } return mScrollingChildHelper ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { "<STR_LIT>" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( "<STR_LIT>" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + oldListPosition + "<STR_LIT>" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + newListPosition + "<STR_LIT>" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( posX , newPos ) ; batchingCallback . onChanged ( updatedNewPos - <NUM_LIT> , <NUM_LIT> , changePayload ) ; } } else { postponedUpdates . add ( new PostponedUpdate ( posX , currentListSize - posX - <NUM_LIT> , true ) ) ; } } else { batchingCallback . onRemoved ( posX , <NUM_LIT> ) ; currentListSize -- ; } } while ( posY > endY ) { posY -- ; int status = mNewItemStatuses [ posY ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int oldPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , oldPos , true ) ; if ( postponedUpdate == null ) { postponedUpdates . add ( new PostponedUpdate ( posY , currentListSize - posX , false ) ) ; } else { int updatedOldPos = currentListSize - postponedUpdate . currentPos - <NUM_LIT> ; batchingCallback . onMoved ( updatedOldPos , posX ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( oldPos , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } } } else { batchingCallback . onInserted ( posX , <NUM_LIT> ) ; currentListSize ++ ; } } posX = diagonal . x ; posY = diagonal . y ; for ( int i = <NUM_LIT> ; i < diagonal . size ; i ++ ) { if ( ( mOldItemStatuses [ posX ] & FLAG_MASK ) == FLAG_CHANGED ) { Object changePayload = mCallback . getChangePayload ( posX , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } posX ++ ; posY ++ ; } posX = diagonal . x ; posY = diagonal . y ; } batchingCallback . dispatchLastEvent ( ) ; } @ Nullable private static PostponedUpdate getPostponedUpdate ( Collection < PostponedUpdate > postponedUpdates , int posInList , boolean removal ) { PostponedUpdate postponedUpdate = null ; Iterator < PostponedUpdate > itr = postponedUpdates . iterator ( ) ; while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( update . posInOwnerList == posInList && update . removal == removal ) { postponedUpdate = update ; itr . remove ( ) ; break ; } } while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( removal ) { update . currentPos -- ; } else { update . currentPos ++ ; } } return postponedUpdate ; } } private static class PostponedUpdate { int posInOwnerList ; int currentPos ; boolean removal ; PostponedUpdate ( int posInOwnerList , int currentPos , boolean removal ) { this . posInOwnerList = posInOwnerList ; this . currentPos = currentPos ; this . removal = removal ; } } static class CenteredArray { private final int [ ] mData ; private final int mMid ; CenteredArray ( int size ) { mData = new int [ size ] ; mMid = mData . length / <NUM_LIT> ; } int get ( int index ) { return mData [ index + mMid ] ; } int [ ] backingData ( ) { return mData ; } void set ( int index , int value ) { mData [ index + mMid ] = value ; } public void fill ( int value ) { Arrays . fill ( mData , value ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ; mPath . close ( ) ; if ( needMirroring ( ) ) { mTempMatrix . setScale ( - <NUM_LIT> , <NUM_LIT> , width / <NUM_LIT> , <NUM_LIT> ) ; } else { mTempMatrix . reset ( ) ; } mTempMatrix . postTranslate ( bounds . left , bounds . top ) ; mPath . transform ( mTempMatrix ) ; } private static void pathArcTo ( @ NonNull Path path , float centerX , float centerY , float radius , float startAngle , float sweepAngle ) { path . arcTo ( centerX - radius , centerY - radius , centerX + radius , centerY + radius , startAngle , sweepAngle , false ) ; } @ Override public boolean getPadding ( @ NonNull Rect padding ) { if ( needMirroring ( ) ) { padding . set ( mPaddingEnd , <NUM_LIT> , mPaddingStart , <NUM_LIT> ) ; } else { padding . set ( mPaddingStart , <NUM_LIT> , mPaddingEnd , <NUM_LIT> ) ; } return true ; } @ Override public void getOutline ( @ NonNull Outline outline ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q && ! mPath . isConvex ( ) ) { super . getOutline ( outline ) ; return ; } outline . setConvexPath ( mPath ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op ) ; Log . d ( TAG , "<STR_LIT>" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op . positionStart + "<STR_LIT>" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + pos + "<STR_LIT>" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; Log . d ( TAG , "<STR_LIT>" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" ) ; Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ; Object payload ; int itemCount ; UpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { this . cmd = cmd ; this . positionStart = positionStart ; this . itemCount = itemCount ; this . payload = payload ; } String cmdToString ( ) { switch ( cmd ) { case ADD : return "<STR_LIT>" ; case REMOVE : return "<STR_LIT>" ; case UPDATE : return "<STR_LIT>" ; case MOVE : return "<STR_LIT>" ; } return "<STR_LIT>" ; } @ Override public String toString ( ) { return Integer . toHexString ( System . identityHashCode ( this ) ) + "<STR_LIT>" + cmdToString ( ) + "<STR_LIT>" + positionStart + "<STR_LIT>" + itemCount + "<STR_LIT>" + payload + "<STR_LIT>" ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof UpdateOp ) ) { return false ; } UpdateOp op = ( UpdateOp ) o ; if ( cmd != op . cmd ) { return false ; } if ( cmd == MOVE && Math . abs ( itemCount - positionStart ) == <NUM_LIT> ) { if ( itemCount == op . positionStart && positionStart == op . itemCount ) { return true ; } } if ( itemCount != op . itemCount ) { return false ; } if ( positionStart != op . positionStart ) { return false ; } if ( payload != null ) { if ( ! payload . equals ( op . payload ) ) { return false ; } } else if ( op . payload != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = cmd ; result = <NUM_LIT> * result + positionStart ; result = <NUM_LIT> * result + itemCount ; return result ; } } @ Override public UpdateOp obtainUpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { UpdateOp op = mUpdateOpPool . acquire ( ) ; if ( op == null ) { op = new UpdateOp ( cmd , positionStart , itemCount , payload ) ; } else { op . cmd = cmd ; op . positionStart = positionStart ; op . itemCount = itemCount ; op . payload = payload ; } return op ; } @ Override public void recycleUpdateOp ( UpdateOp op ) { if ( ! mDisableRecycler ) { op . payload = null ; mUpdateOpPool . release ( op ) ; } } void recycleUpdateOpsAndClearList ( List < UpdateOp > ops ) { final int count = ops . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { recycleUpdateOp ( ops . get ( i ) ) ; } ops . clear ( ) ; } interface Callback { RecyclerView . ViewHolder findViewHolder ( int position ) ; void offsetPositionsForRemovingInvisible ( int positionStart , int itemCount ) ; void offsetPositionsForRemovingLaidOutOrNewView ( int positionStart , int itemCount ) ; void markViewHoldersUpdated ( int positionStart , int itemCount , Object payloads ) ; void onDispatchFirstPass ( UpdateOp updateOp ) ; void onDispatchSecondPass ( UpdateOp updateOp ) ; void offsetPositionsForAdd ( int positionStart , int itemCount ) ; void offsetPositionsForMove ( int from , int to ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ; i < count ; i ++ ) { ViewCompat . dispatchApplyWindowInsets ( rv . getChildAt ( i ) , new WindowInsetsCompat ( applied ) ) ; } return consumeAllInsets ( applied ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private WindowInsetsCompat consumeAllInsets ( @ NonNull WindowInsetsCompat insets ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( WindowInsetsCompat . CONSUMED . toWindowInsets ( ) != null ) { return WindowInsetsCompat . CONSUMED ; } return insets . consumeSystemWindowInsets ( ) . consumeStableInsets ( ) ; } return insets ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollScrollView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollScrollView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import androidx . annotation . NonNull ; public interface ViewHelperProvider { @ NonNull FastScroller . ViewHelper getViewHelper ( ) ; } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; } return a . getColorStateList ( <NUM_LIT> ) ; } finally { a . recycle ( ) ; } } @ Nullable public static Drawable getGradientDrawableWithTintAttr ( @ DrawableRes int drawableRes , @ AttrRes int tintAttrRes , @ NonNull Context context ) { Drawable drawable = AppCompatResources . getDrawable ( context , drawableRes ) ; if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . LOLLIPOP_MR1 && drawable instanceof GradientDrawable ) { drawable = DrawableCompat . wrap ( drawable ) ; drawable . setTintList ( getColorStateListFromAttrRes ( tintAttrRes , context ) ) ; } return drawable ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( "<STR_LIT>" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + index + "<STR_LIT>" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + index + "<STR_LIT>" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; } public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback { @ Override abstract public int compare ( T2 o1 , T2 o2 ) ; abstract public void onChanged ( int position , int count ) ; @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { onChanged ( position , count ) ; } abstract public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) ; abstract public boolean areItemsTheSame ( T2 item1 , T2 item2 ) ; @ Nullable public Object getChangePayload ( T2 item1 , T2 item2 ) { return null ; } } public static class BatchedCallback < T2 > extends Callback < T2 > { final Callback < T2 > mWrappedCallback ; private final BatchingListUpdateCallback mBatchingListUpdateCallback ; @ SuppressLint ( "<STR_LIT>" ) public BatchedCallback ( Callback < T2 > wrappedCallback ) { mWrappedCallback = wrappedCallback ; mBatchingListUpdateCallback = new BatchingListUpdateCallback ( mWrappedCallback ) ; } @ Override public int compare ( T2 o1 , T2 o2 ) { return mWrappedCallback . compare ( o1 , o2 ) ; } @ Override public void onInserted ( int position , int count ) { mBatchingListUpdateCallback . onInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mBatchingListUpdateCallback . onRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mBatchingListUpdateCallback . onMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mBatchingListUpdateCallback . onChanged ( position , count , null ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mBatchingListUpdateCallback . onChanged ( position , count , payload ) ; } @ Override public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) { return mWrappedCallback . areContentsTheSame ( oldItem , newItem ) ; } @ Override public boolean areItemsTheSame ( T2 item1 , T2 item2 ) { return mWrappedCallback . areItemsTheSame ( item1 , item2 ) ; } @ Nullable @ Override public Object getChangePayload ( T2 item1 , T2 item2 ) { return mWrappedCallback . getChangePayload ( item1 , item2 ) ; } public void dispatchLastEvent ( ) { mBatchingListUpdateCallback . dispatchLastEvent ( ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . graphics . Rect ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . BitSet ; import java . util . List ; public class StaggeredGridLayoutManager extends RecyclerView . LayoutManager implements RecyclerView . SmoothScroller . ScrollVectorProvider { private static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; public static final int GAP_HANDLING_NONE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) @ Deprecated public static final int GAP_HANDLING_LAZY = <NUM_LIT> ; public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = <NUM_LIT> ; static final int INVALID_OFFSET = Integer . MIN_VALUE ; private static final float MAX_SCROLL_FACTOR = <NUM_LIT> / <NUM_LIT> ; private int mSpanCount = - <NUM_LIT> ; Span [ ] mSpans ; @ NonNull OrientationHelper mPrimaryOrientation ; @ NonNull OrientationHelper mSecondaryOrientation ; private int mOrientation ; private int mSizePerSpan ; @ NonNull private final LayoutState mLayoutState ; boolean mReverseLayout = false ; boolean mShouldReverseLayout = false ; private BitSet mRemainingSpans ; int mPendingScrollPosition = RecyclerView . NO_POSITION ; int mPendingScrollPositionOffset = INVALID_OFFSET ; LazySpanLookup mLazySpanLookup = new LazySpanLookup ( ) ; private int mGapStrategy = GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS ; private boolean mLastLayoutFromEnd ; private boolean mLastLayoutRTL ; private SavedState mPendingSavedState ; private int mFullSizeSpec ; private final Rect mTmpRect = new Rect ( ) ; private final AnchorInfo mAnchorInfo = new AnchorInfo ( ) ; private boolean mLaidOutInvalidFullSpan = false ; private boolean mSmoothScrollbarEnabled = true ; private int [ ] mPrefetchDistances ; private final Runnable mCheckForGapsRunnable = new Runnable ( ) { @ Override public void run ( ) { checkForGaps ( ) ; } } ; @ SuppressWarnings ( "<STR_LIT>" ) public StaggeredGridLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setOrientation ( properties . orientation ) ; setSpanCount ( properties . spanCount ) ; setReverseLayout ( properties . reverseLayout ) ; mLayoutState = new LayoutState ( ) ; createOrientationHelpers ( ) ; } public StaggeredGridLayoutManager ( int spanCount , int orientation ) { mOrientation = orientation ; setSpanCount ( spanCount ) ; mLayoutState = new LayoutState ( ) ; createOrientationHelpers ( ) ; } @ Override public boolean isAutoMeasureEnabled ( ) { return mGapStrategy != GAP_HANDLING_NONE ; } private void createOrientationHelpers ( ) { mPrimaryOrientation = OrientationHelper . createOrientationHelper ( this , mOrientation ) ; mSecondaryOrientation = OrientationHelper . createOrientationHelper ( this , <NUM_LIT> - mOrientation ) ; } boolean checkForGaps ( ) { if ( getChildCount ( ) == <NUM_LIT> || mGapStrategy == GAP_HANDLING_NONE || ! isAttachedToWindow ( ) ) { return false ; } final int minPos , maxPos ; if ( mShouldReverseLayout ) { minPos = getLastChildPosition ( ) ; maxPos = getFirstChildPosition ( ) ; } else { minPos = getFirstChildPosition ( ) ; maxPos = getLastChildPosition ( ) ; } if ( minPos == <NUM_LIT> ) { View gapView = hasGapsToFix ( ) ; if ( gapView != null ) { mLazySpanLookup . clear ( ) ; requestSimpleAnimationsInNextLayout ( ) ; requestLayout ( ) ; return true ; } } if ( ! mLaidOutInvalidFullSpan ) { return false ; } int invalidGapDir = mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; final LazySpanLookup . FullSpanItem invalidFsi = mLazySpanLookup . getFirstFullSpanItemInRange ( minPos , maxPos + <NUM_LIT> , invalidGapDir , true ) ; if ( invalidFsi == null ) { mLaidOutInvalidFullSpan = false ; mLazySpanLookup . forceInvalidateAfter ( maxPos + <NUM_LIT> ) ; return false ; } final LazySpanLookup . FullSpanItem validFsi = mLazySpanLookup . getFirstFullSpanItemInRange ( minPos , invalidFsi . mPosition , invalidGapDir * - <NUM_LIT> , true ) ; if ( validFsi == null ) { mLazySpanLookup . forceInvalidateAfter ( invalidFsi . mPosition ) ; } else { mLazySpanLookup . forceInvalidateAfter ( validFsi . mPosition + <NUM_LIT> ) ; } requestSimpleAnimationsInNextLayout ( ) ; requestLayout ( ) ; return true ; } @ Override public void onScrollStateChanged ( int state ) { if ( state == RecyclerView . SCROLL_STATE_IDLE ) { checkForGaps ( ) ; } } @ Override public void onDetachedFromWindow ( RecyclerView view , RecyclerView . Recycler recycler ) { super . onDetachedFromWindow ( view , recycler ) ; removeCallbacks ( mCheckForGapsRunnable ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; } view . requestLayout ( ) ; } View hasGapsToFix ( ) { int startChildIndex = <NUM_LIT> ; int endChildIndex = getChildCount ( ) - <NUM_LIT> ; BitSet mSpansToCheck = new BitSet ( mSpanCount ) ; mSpansToCheck . set ( <NUM_LIT> , mSpanCount , true ) ; final int firstChildIndex , childLimit ; final int preferredSpanDir = mOrientation == VERTICAL && isLayoutRTL ( ) ? <NUM_LIT> : - <NUM_LIT> ; if ( mShouldReverseLayout ) { firstChildIndex = endChildIndex ; childLimit = startChildIndex - <NUM_LIT> ; } else { firstChildIndex = startChildIndex ; childLimit = endChildIndex + <NUM_LIT> ; } final int nextChildDiff = firstChildIndex < childLimit ? <NUM_LIT> : - <NUM_LIT> ; for ( int i = firstChildIndex ; i != childLimit ; i += nextChildDiff ) { View child = getChildAt ( i ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( mSpansToCheck . get ( lp . mSpan . mIndex ) ) { if ( checkSpanForGap ( lp . mSpan ) ) { return child ; } mSpansToCheck . clear ( lp . mSpan . mIndex ) ; } if ( lp . mFullSpan ) { continue ; } if ( i + nextChildDiff != childLimit ) { View nextChild = getChildAt ( i + nextChildDiff ) ; boolean compareSpans = false ; if ( mShouldReverseLayout ) { int myEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; int nextEnd = mPrimaryOrientation . getDecoratedEnd ( nextChild ) ; if ( myEnd < nextEnd ) { return child ; } else if ( myEnd == nextEnd ) { compareSpans = true ; } } else { int myStart = mPrimaryOrientation . getDecoratedStart ( child ) ; int nextStart = mPrimaryOrientation . getDecoratedStart ( nextChild ) ; if ( myStart > nextStart ) { return child ; } else if ( myStart == nextStart ) { compareSpans = true ; } } if ( compareSpans ) { LayoutParams nextLp = ( LayoutParams ) nextChild . getLayoutParams ( ) ; if ( lp . mSpan . mIndex - nextLp . mSpan . mIndex < <NUM_LIT> != preferredSpanDir < <NUM_LIT> ) { return child ; } } } } return null ; } private boolean checkSpanForGap ( Span span ) { if ( mShouldReverseLayout ) { if ( span . getEndLine ( ) < mPrimaryOrientation . getEndAfterPadding ( ) ) { final View endView = span . mViews . get ( span . mViews . size ( ) - <NUM_LIT> ) ; final LayoutParams lp = span . getLayoutParams ( endView ) ; return ! lp . mFullSpan ; } } else if ( span . getStartLine ( ) > mPrimaryOrientation . getStartAfterPadding ( ) ) { final View startView = span . mViews . get ( <NUM_LIT> ) ; final LayoutParams lp = span . getLayoutParams ( startView ) ; return ! lp . mFullSpan ; } return false ; } public void setSpanCount ( int spanCount ) { assertNotInLayoutOrScroll ( null ) ; if ( spanCount != mSpanCount ) { invalidateSpanAssignments ( ) ; mSpanCount = spanCount ; mRemainingSpans = new BitSet ( mSpanCount ) ; mSpans = new Span [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] = new Span ( i ) ; } requestLayout ( ) ; } } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } assertNotInLayoutOrScroll ( null ) ; if ( orientation == mOrientation ) { return ; } mOrientation = orientation ; OrientationHelper tmp = mPrimaryOrientation ; mPrimaryOrientation = mSecondaryOrientation ; mSecondaryOrientation = tmp ; requestLayout ( ) ; } public void setReverseLayout ( boolean reverseLayout ) { assertNotInLayoutOrScroll ( null ) ; if ( mPendingSavedState != null && mPendingSavedState . mReverseLayout != reverseLayout ) { mPendingSavedState . mReverseLayout = reverseLayout ; } mReverseLayout = reverseLayout ; requestLayout ( ) ; } public int getGapStrategy ( ) { return mGapStrategy ; } public void setGapStrategy ( int gapStrategy ) { assertNotInLayoutOrScroll ( null ) ; if ( gapStrategy == mGapStrategy ) { return ; } if ( gapStrategy != GAP_HANDLING_NONE && gapStrategy != GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mGapStrategy = gapStrategy ; requestLayout ( ) ; } @ Override public void assertNotInLayoutOrScroll ( String message ) { if ( mPendingSavedState == null ) { super . assertNotInLayoutOrScroll ( message ) ; } } public int getSpanCount ( ) { return mSpanCount ; } public void invalidateSpanAssignments ( ) { mLazySpanLookup . clear ( ) ; requestLayout ( ) ; } private void resolveShouldLayoutReverse ( ) { if ( mOrientation == VERTICAL || ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } boolean isLayoutRTL ( ) { return getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean getReverseLayout ( ) { return mReverseLayout ; } @ Override public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { final int width , height ; final int horizontalPadding = getPaddingLeft ( ) + getPaddingRight ( ) ; final int verticalPadding = getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mOrientation == VERTICAL ) { final int usedHeight = childrenBounds . height ( ) + verticalPadding ; height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; width = chooseSize ( wSpec , mSizePerSpan * mSpanCount + horizontalPadding , getMinimumWidth ( ) ) ; } else { final int usedWidth = childrenBounds . width ( ) + horizontalPadding ; width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; height = chooseSize ( hSpec , mSizePerSpan * mSpanCount + verticalPadding , getMinimumHeight ( ) ) ; } setMeasuredDimension ( width , height ) ; } @ Override public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { onLayoutChildren ( recycler , state , true ) ; } @ Override public void onAdapterChanged ( @ Nullable RecyclerView . Adapter oldAdapter , @ Nullable RecyclerView . Adapter newAdapter ) { mLazySpanLookup . clear ( ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; } } private void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean shouldCheckForGaps ) { final AnchorInfo anchorInfo = mAnchorInfo ; if ( mPendingSavedState != null || mPendingScrollPosition != RecyclerView . NO_POSITION ) { if ( state . getItemCount ( ) == <NUM_LIT> ) { removeAndRecycleAllViews ( recycler ) ; anchorInfo . reset ( ) ; return ; } } boolean recalculateAnchor = ! anchorInfo . mValid || mPendingScrollPosition != RecyclerView . NO_POSITION || mPendingSavedState != null ; if ( recalculateAnchor ) { anchorInfo . reset ( ) ; if ( mPendingSavedState != null ) { applyPendingSavedState ( anchorInfo ) ; } else { resolveShouldLayoutReverse ( ) ; anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; } updateAnchorInfoForLayout ( state , anchorInfo ) ; anchorInfo . mValid = true ; } if ( mPendingSavedState == null && mPendingScrollPosition == RecyclerView . NO_POSITION ) { if ( anchorInfo . mLayoutFromEnd != mLastLayoutFromEnd || isLayoutRTL ( ) != mLastLayoutRTL ) { mLazySpanLookup . clear ( ) ; anchorInfo . mInvalidateOffsets = true ; } } if ( getChildCount ( ) > <NUM_LIT> && ( mPendingSavedState == null || mPendingSavedState . mSpanOffsetsSize < <NUM_LIT> ) ) { if ( anchorInfo . mInvalidateOffsets ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; if ( anchorInfo . mOffset != INVALID_OFFSET ) { mSpans [ i ] . setLine ( anchorInfo . mOffset ) ; } } } else { if ( recalculateAnchor || mAnchorInfo . mSpanReferenceLines == null ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . cacheReferenceLineAndClear ( mShouldReverseLayout , anchorInfo . mOffset ) ; } mAnchorInfo . saveSpanReferenceLines ( mSpans ) ; } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final Span span = mSpans [ i ] ; span . clear ( ) ; span . setLine ( mAnchorInfo . mSpanReferenceLines [ i ] ) ; } } } } detachAndScrapAttachedViews ( recycler ) ; mLayoutState . mRecycle = false ; mLaidOutInvalidFullSpan = false ; updateMeasureSpecs ( mSecondaryOrientation . getTotalSpace ( ) ) ; updateLayoutState ( anchorInfo . mPosition , state ) ; if ( anchorInfo . mLayoutFromEnd ) { setLayoutStateDirection ( LayoutState . LAYOUT_START ) ; fill ( recycler , mLayoutState , state ) ; setLayoutStateDirection ( LayoutState . LAYOUT_END ) ; mLayoutState . mCurrentPosition = anchorInfo . mPosition + mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state ) ; } else { setLayoutStateDirection ( LayoutState . LAYOUT_END ) ; fill ( recycler , mLayoutState , state ) ; setLayoutStateDirection ( LayoutState . LAYOUT_START ) ; mLayoutState . mCurrentPosition = anchorInfo . mPosition + mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state ) ; } repositionToWrapContentIfNecessary ( ) ; if ( getChildCount ( ) > <NUM_LIT> ) { if ( mShouldReverseLayout ) { fixEndGap ( recycler , state , true ) ; fixStartGap ( recycler , state , false ) ; } else { fixStartGap ( recycler , state , true ) ; fixEndGap ( recycler , state , false ) ; } } boolean hasGaps = false ; if ( shouldCheckForGaps && ! state . isPreLayout ( ) ) { final boolean needToCheckForGaps = mGapStrategy != GAP_HANDLING_NONE && getChildCount ( ) > <NUM_LIT> && ( mLaidOutInvalidFullSpan || hasGapsToFix ( ) != null ) ; if ( needToCheckForGaps ) { removeCallbacks ( mCheckForGapsRunnable ) ; if ( checkForGaps ( ) ) { hasGaps = true ; } } } if ( state . isPreLayout ( ) ) { mAnchorInfo . reset ( ) ; } mLastLayoutFromEnd = anchorInfo . mLayoutFromEnd ; mLastLayoutRTL = isLayoutRTL ( ) ; if ( hasGaps ) { mAnchorInfo . reset ( ) ; onLayoutChildren ( recycler , state , false ) ; } } @ Override public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; mPendingSavedState = null ; mAnchorInfo . reset ( ) ; } private void repositionToWrapContentIfNecessary ( ) { if ( mSecondaryOrientation . getMode ( ) == View . MeasureSpec . EXACTLY ) { return ; } float maxSize = <NUM_LIT> ; final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; float size = mSecondaryOrientation . getDecoratedMeasurement ( child ) ; if ( size < maxSize ) { continue ; } LayoutParams layoutParams = ( LayoutParams ) child . getLayoutParams ( ) ; if ( layoutParams . isFullSpan ( ) ) { size = <NUM_LIT> * size / mSpanCount ; } maxSize = Math . max ( maxSize , size ) ; } int before = mSizePerSpan ; int desired = Math . round ( maxSize * mSpanCount ) ; if ( mSecondaryOrientation . getMode ( ) == View . MeasureSpec . AT_MOST ) { desired = Math . min ( desired , mSecondaryOrientation . getTotalSpace ( ) ) ; } updateMeasureSpecs ( desired ) ; if ( mSizePerSpan == before ) { return ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { continue ; } if ( isLayoutRTL ( ) && mOrientation == VERTICAL ) { int newOffset = - ( mSpanCount - <NUM_LIT> - lp . mSpan . mIndex ) * mSizePerSpan ; int prevOffset = - ( mSpanCount - <NUM_LIT> - lp . mSpan . mIndex ) * before ; child . offsetLeftAndRight ( newOffset - prevOffset ) ; } else { int newOffset = lp . mSpan . mIndex * mSizePerSpan ; int prevOffset = lp . mSpan . mIndex * before ; if ( mOrientation == VERTICAL ) { child . offsetLeftAndRight ( newOffset - prevOffset ) ; } else { child . offsetTopAndBottom ( newOffset - prevOffset ) ; } } } } private void applyPendingSavedState ( AnchorInfo anchorInfo ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mPendingSavedState ) ; } if ( mPendingSavedState . mSpanOffsetsSize > <NUM_LIT> ) { if ( mPendingSavedState . mSpanOffsetsSize == mSpanCount ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; int line = mPendingSavedState . mSpanOffsets [ i ] ; if ( line != Span . INVALID_LINE ) { if ( mPendingSavedState . mAnchorLayoutFromEnd ) { line += mPrimaryOrientation . getEndAfterPadding ( ) ; } else { line += mPrimaryOrientation . getStartAfterPadding ( ) ; } } mSpans [ i ] . setLine ( line ) ; } } else { mPendingSavedState . invalidateSpanInfo ( ) ; mPendingSavedState . mAnchorPosition = mPendingSavedState . mVisibleAnchorPosition ; } } mLastLayoutRTL = mPendingSavedState . mLastLayoutRTL ; setReverseLayout ( mPendingSavedState . mReverseLayout ) ; resolveShouldLayoutReverse ( ) ; if ( mPendingSavedState . mAnchorPosition != RecyclerView . NO_POSITION ) { mPendingScrollPosition = mPendingSavedState . mAnchorPosition ; anchorInfo . mLayoutFromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; } else { anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; } if ( mPendingSavedState . mSpanLookupSize > <NUM_LIT> ) { mLazySpanLookup . mData = mPendingSavedState . mSpanLookup ; mLazySpanLookup . mFullSpanItems = mPendingSavedState . mFullSpanItems ; } } void updateAnchorInfoForLayout ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( updateAnchorFromPendingData ( state , anchorInfo ) ) { return ; } if ( updateAnchorFromChildren ( state , anchorInfo ) ) { return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } anchorInfo . assignCoordinateFromPadding ( ) ; anchorInfo . mPosition = <NUM_LIT> ; } private boolean updateAnchorFromChildren ( RecyclerView . State state , AnchorInfo anchorInfo ) { anchorInfo . mPosition = mLastLayoutFromEnd ? findLastReferenceChildPosition ( state . getItemCount ( ) ) : findFirstReferenceChildPosition ( state . getItemCount ( ) ) ; anchorInfo . mOffset = INVALID_OFFSET ; return true ; } boolean updateAnchorFromPendingData ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( state . isPreLayout ( ) || mPendingScrollPosition == RecyclerView . NO_POSITION ) { return false ; } if ( mPendingScrollPosition < <NUM_LIT> || mPendingScrollPosition >= state . getItemCount ( ) ) { mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; return false ; } if ( mPendingSavedState == null || mPendingSavedState . mAnchorPosition == RecyclerView . NO_POSITION || mPendingSavedState . mSpanOffsetsSize < <NUM_LIT> ) { final View child = findViewByPosition ( mPendingScrollPosition ) ; if ( child != null ) { anchorInfo . mPosition = mShouldReverseLayout ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; if ( mPendingScrollPositionOffset != INVALID_OFFSET ) { if ( anchorInfo . mLayoutFromEnd ) { final int target = mPrimaryOrientation . getEndAfterPadding ( ) - mPendingScrollPositionOffset ; anchorInfo . mOffset = target - mPrimaryOrientation . getDecoratedEnd ( child ) ; } else { final int target = mPrimaryOrientation . getStartAfterPadding ( ) + mPendingScrollPositionOffset ; anchorInfo . mOffset = target - mPrimaryOrientation . getDecoratedStart ( child ) ; } return true ; } final int childSize = mPrimaryOrientation . getDecoratedMeasurement ( child ) ; if ( childSize > mPrimaryOrientation . getTotalSpace ( ) ) { anchorInfo . mOffset = anchorInfo . mLayoutFromEnd ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; return true ; } final int startGap = mPrimaryOrientation . getDecoratedStart ( child ) - mPrimaryOrientation . getStartAfterPadding ( ) ; if ( startGap < <NUM_LIT> ) { anchorInfo . mOffset = - startGap ; return true ; } final int endGap = mPrimaryOrientation . getEndAfterPadding ( ) - mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( endGap < <NUM_LIT> ) { anchorInfo . mOffset = endGap ; return true ; } anchorInfo . mOffset = INVALID_OFFSET ; } else { anchorInfo . mPosition = mPendingScrollPosition ; if ( mPendingScrollPositionOffset == INVALID_OFFSET ) { final int position = calculateScrollDirectionForPosition ( anchorInfo . mPosition ) ; anchorInfo . mLayoutFromEnd = position == LayoutState . LAYOUT_END ; anchorInfo . assignCoordinateFromPadding ( ) ; } else { anchorInfo . assignCoordinateFromPadding ( mPendingScrollPositionOffset ) ; } anchorInfo . mInvalidateOffsets = true ; } } else { anchorInfo . mOffset = INVALID_OFFSET ; anchorInfo . mPosition = mPendingScrollPosition ; } return true ; } void updateMeasureSpecs ( int totalSpace ) { mSizePerSpan = totalSpace / mSpanCount ; mFullSizeSpec = View . MeasureSpec . makeMeasureSpec ( totalSpace , mSecondaryOrientation . getMode ( ) ) ; } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null ; } public int [ ] findFirstVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findFirstVisibleItemPosition ( ) ; } return into ; } public int [ ] findFirstCompletelyVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findFirstCompletelyVisibleItemPosition ( ) ; } return into ; } public int [ ] findLastVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findLastVisibleItemPosition ( ) ; } return into ; } public int [ ] findLastCompletelyVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findLastCompletelyVisibleItemPosition ( ) ; } return into ; } @ Override public int computeHorizontalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } private int computeScrollOffset ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollOffset ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled , mShouldReverseLayout ) ; } @ Override public int computeVerticalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override public int computeHorizontalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } private int computeScrollExtent ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollExtent ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled ) ; } @ Override public int computeVerticalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override public int computeHorizontalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private int computeScrollRange ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollRange ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled ) ; } @ Override public int computeVerticalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private void measureChildWithDecorationsAndMargin ( View child , LayoutParams lp , boolean alreadyMeasured ) { if ( lp . mFullSpan ) { if ( mOrientation == VERTICAL ) { measureChildWithDecorationsAndMargin ( child , mFullSizeSpec , getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) , lp . height , true ) , alreadyMeasured ) ; } else { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) , lp . width , true ) , mFullSizeSpec , alreadyMeasured ) ; } } else { if ( mOrientation == VERTICAL ) { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( mSizePerSpan , getWidthMode ( ) , <NUM_LIT> , lp . width , false ) , getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) , lp . height , true ) , alreadyMeasured ) ; } else { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) , lp . width , true ) , getChildMeasureSpec ( mSizePerSpan , getHeightMode ( ) , <NUM_LIT> , lp . height , false ) , alreadyMeasured ) ; } } } private void measureChildWithDecorationsAndMargin ( View child , int widthSpec , int heightSpec , boolean alreadyMeasured ) { calculateItemDecorationsForChild ( child , mTmpRect ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; widthSpec = updateSpecWithExtra ( widthSpec , lp . leftMargin + mTmpRect . left , lp . rightMargin + mTmpRect . right ) ; heightSpec = updateSpecWithExtra ( heightSpec , lp . topMargin + mTmpRect . top , lp . bottomMargin + mTmpRect . bottom ) ; final boolean measure = alreadyMeasured ? shouldReMeasureChild ( child , widthSpec , heightSpec , lp ) : shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ; if ( measure ) { child . measure ( widthSpec , heightSpec ) ; } } private int updateSpecWithExtra ( int spec , int startInset , int endInset ) { if ( startInset == <NUM_LIT> && endInset == <NUM_LIT> ) { return spec ; } final int mode = View . MeasureSpec . getMode ( spec ) ; if ( mode == View . MeasureSpec . AT_MOST || mode == View . MeasureSpec . EXACTLY ) { return View . MeasureSpec . makeMeasureSpec ( Math . max ( <NUM_LIT> , View . MeasureSpec . getSize ( spec ) - startInset - endInset ) , mode ) ; } return spec ; } @ Override public void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof SavedState ) { mPendingSavedState = ( SavedState ) state ; if ( mPendingScrollPosition != RecyclerView . NO_POSITION ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; mPendingSavedState . invalidateSpanInfo ( ) ; } requestLayout ( ) ; } else if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } @ Override public Parcelable onSaveInstanceState ( ) { if ( mPendingSavedState != null ) { return new SavedState ( mPendingSavedState ) ; } SavedState state = new SavedState ( ) ; state . mReverseLayout = mReverseLayout ; state . mAnchorLayoutFromEnd = mLastLayoutFromEnd ; state . mLastLayoutRTL = mLastLayoutRTL ; if ( mLazySpanLookup != null && mLazySpanLookup . mData != null ) { state . mSpanLookup = mLazySpanLookup . mData ; state . mSpanLookupSize = state . mSpanLookup . length ; state . mFullSpanItems = mLazySpanLookup . mFullSpanItems ; } else { state . mSpanLookupSize = <NUM_LIT> ; } if ( getChildCount ( ) > <NUM_LIT> ) { state . mAnchorPosition = mLastLayoutFromEnd ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; state . mVisibleAnchorPosition = findFirstVisibleItemPositionInt ( ) ; state . mSpanOffsetsSize = mSpanCount ; state . mSpanOffsets = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { int line ; if ( mLastLayoutFromEnd ) { line = mSpans [ i ] . getEndLine ( Span . INVALID_LINE ) ; if ( line != Span . INVALID_LINE ) { line -= mPrimaryOrientation . getEndAfterPadding ( ) ; } } else { line = mSpans [ i ] . getStartLine ( Span . INVALID_LINE ) ; if ( line != Span . INVALID_LINE ) { line -= mPrimaryOrientation . getStartAfterPadding ( ) ; } } state . mSpanOffsets [ i ] = line ; } } else { state . mAnchorPosition = RecyclerView . NO_POSITION ; state . mVisibleAnchorPosition = RecyclerView . NO_POSITION ; state . mSpanOffsetsSize = <NUM_LIT> ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + state ) ; } return state ; } @ Override public void onInitializeAccessibilityEvent ( AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; if ( getChildCount ( ) > <NUM_LIT> ) { final View start = findFirstVisibleItemClosestToStart ( false ) ; final View end = findFirstVisibleItemClosestToEnd ( false ) ; if ( start == null || end == null ) { return ; } final int startPos = getPosition ( start ) ; final int endPos = getPosition ( end ) ; if ( startPos < endPos ) { event . setFromIndex ( startPos ) ; event . setToIndex ( endPos ) ; } else { event . setFromIndex ( endPos ) ; event . setToIndex ( startPos ) ; } } } int findFirstVisibleItemPositionInt ( ) { final View first = mShouldReverseLayout ? findFirstVisibleItemClosestToEnd ( true ) : findFirstVisibleItemClosestToStart ( true ) ; return first == null ? RecyclerView . NO_POSITION : getPosition ( first ) ; } View findFirstVisibleItemClosestToStart ( boolean fullyVisible ) { final int boundsStart = mPrimaryOrientation . getStartAfterPadding ( ) ; final int boundsEnd = mPrimaryOrientation . getEndAfterPadding ( ) ; final int limit = getChildCount ( ) ; View partiallyVisible = null ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View child = getChildAt ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( childEnd <= boundsStart || childStart >= boundsEnd ) { continue ; } if ( childStart >= boundsStart || ! fullyVisible ) { return child ; } if ( partiallyVisible == null ) { partiallyVisible = child ; } } return partiallyVisible ; } View findFirstVisibleItemClosestToEnd ( boolean fullyVisible ) { final int boundsStart = mPrimaryOrientation . getStartAfterPadding ( ) ; final int boundsEnd = mPrimaryOrientation . getEndAfterPadding ( ) ; View partiallyVisible = null ; for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View child = getChildAt ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( childEnd <= boundsStart || childStart >= boundsEnd ) { continue ; } if ( childEnd <= boundsEnd || ! fullyVisible ) { return child ; } if ( partiallyVisible == null ) { partiallyVisible = child ; } } return partiallyVisible ; } private void fixEndGap ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { final int maxEndLine = getMaxEnd ( Integer . MIN_VALUE ) ; if ( maxEndLine == Integer . MIN_VALUE ) { return ; } int gap = mPrimaryOrientation . getEndAfterPadding ( ) - maxEndLine ; int fixOffset ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( - gap , recycler , state ) ; } else { return ; } gap -= fixOffset ; if ( canOffsetChildren && gap > <NUM_LIT> ) { mPrimaryOrientation . offsetChildren ( gap ) ; } } private void fixStartGap ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { final int minStartLine = getMinStart ( Integer . MAX_VALUE ) ; if ( minStartLine == Integer . MAX_VALUE ) { return ; } int gap = minStartLine - mPrimaryOrientation . getStartAfterPadding ( ) ; int fixOffset ; if ( gap > <NUM_LIT> ) { fixOffset = scrollBy ( gap , recycler , state ) ; } else { return ; } gap -= fixOffset ; if ( canOffsetChildren && gap > <NUM_LIT> ) { mPrimaryOrientation . offsetChildren ( - gap ) ; } } private void updateLayoutState ( int anchorPosition , RecyclerView . State state ) { mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . mCurrentPosition = anchorPosition ; int startExtra = <NUM_LIT> ; int endExtra = <NUM_LIT> ; if ( isSmoothScrolling ( ) ) { final int targetPos = state . getTargetScrollPosition ( ) ; if ( targetPos != RecyclerView . NO_POSITION ) { if ( mShouldReverseLayout == targetPos < anchorPosition ) { endExtra = mPrimaryOrientation . getTotalSpace ( ) ; } else { startExtra = mPrimaryOrientation . getTotalSpace ( ) ; } } } final boolean clipToPadding = getClipToPadding ( ) ; if ( clipToPadding ) { mLayoutState . mStartLine = mPrimaryOrientation . getStartAfterPadding ( ) - startExtra ; mLayoutState . mEndLine = mPrimaryOrientation . getEndAfterPadding ( ) + endExtra ; } else { mLayoutState . mEndLine = mPrimaryOrientation . getEnd ( ) + endExtra ; mLayoutState . mStartLine = - startExtra ; } mLayoutState . mStopInFocusable = false ; mLayoutState . mRecycle = true ; mLayoutState . mInfinite = mPrimaryOrientation . getMode ( ) == View . MeasureSpec . UNSPECIFIED && mPrimaryOrientation . getEnd ( ) == <NUM_LIT> ; } private void setLayoutStateDirection ( int direction ) { mLayoutState . mLayoutDirection = direction ; mLayoutState . mItemDirection = ( mShouldReverseLayout == ( direction == LayoutState . LAYOUT_START ) ) ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; } @ Override public void offsetChildrenHorizontal ( int dx ) { super . offsetChildrenHorizontal ( dx ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . onOffset ( dx ) ; } } @ Override public void offsetChildrenVertical ( int dy ) { super . offsetChildrenVertical ( dy ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . onOffset ( dy ) ; } } @ Override public void onItemsRemoved ( RecyclerView recyclerView , int positionStart , int itemCount ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . REMOVE ) ; } @ Override public void onItemsAdded ( RecyclerView recyclerView , int positionStart , int itemCount ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . ADD ) ; } @ Override public void onItemsChanged ( RecyclerView recyclerView ) { mLazySpanLookup . clear ( ) ; requestLayout ( ) ; } @ Override public void onItemsMoved ( RecyclerView recyclerView , int from , int to , int itemCount ) { handleUpdate ( from , to , AdapterHelper . UpdateOp . MOVE ) ; } @ Override public void onItemsUpdated ( RecyclerView recyclerView , int positionStart , int itemCount , Object payload ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . UPDATE ) ; } private void handleUpdate ( int positionStart , int itemCountOrToPosition , int cmd ) { int minPosition = mShouldReverseLayout ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; final int affectedRangeEnd ; final int affectedRangeStart ; if ( cmd == AdapterHelper . UpdateOp . MOVE ) { if ( positionStart < itemCountOrToPosition ) { affectedRangeEnd = itemCountOrToPosition + <NUM_LIT> ; affectedRangeStart = positionStart ; } else { affectedRangeEnd = positionStart + <NUM_LIT> ; affectedRangeStart = itemCountOrToPosition ; } } else { affectedRangeStart = positionStart ; affectedRangeEnd = positionStart + itemCountOrToPosition ; } mLazySpanLookup . invalidateAfter ( affectedRangeStart ) ; switch ( cmd ) { case AdapterHelper . UpdateOp . ADD : mLazySpanLookup . offsetForAddition ( positionStart , itemCountOrToPosition ) ; break ; case AdapterHelper . UpdateOp . REMOVE : mLazySpanLookup . offsetForRemoval ( positionStart , itemCountOrToPosition ) ; break ; case AdapterHelper . UpdateOp . MOVE : mLazySpanLookup . offsetForRemoval ( positionStart , <NUM_LIT> ) ; mLazySpanLookup . offsetForAddition ( itemCountOrToPosition , <NUM_LIT> ) ; break ; } if ( affectedRangeEnd <= minPosition ) { return ; } int maxPosition = mShouldReverseLayout ? getFirstChildPosition ( ) : getLastChildPosition ( ) ; if ( affectedRangeStart <= maxPosition ) { requestLayout ( ) ; } } private int fill ( RecyclerView . Recycler recycler , LayoutState layoutState , RecyclerView . State state ) { mRemainingSpans . set ( <NUM_LIT> , mSpanCount , true ) ; final int targetLine ; if ( mLayoutState . mInfinite ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { targetLine = Integer . MAX_VALUE ; } else { targetLine = Integer . MIN_VALUE ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { targetLine = layoutState . mEndLine + layoutState . mAvailable ; } else { targetLine = layoutState . mStartLine - layoutState . mAvailable ; } } updateAllRemainingSpans ( layoutState . mLayoutDirection , targetLine ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + targetLine + "<STR_LIT>" + "<STR_LIT>" + mRemainingSpans + "<STR_LIT>" + layoutState ) ; } final int defaultNewViewLine = mShouldReverseLayout ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; boolean added = false ; while ( layoutState . hasMore ( state ) && ( mLayoutState . mInfinite || ! mRemainingSpans . isEmpty ( ) ) ) { View view = layoutState . next ( recycler ) ; LayoutParams lp = ( ( LayoutParams ) view . getLayoutParams ( ) ) ; final int position = lp . getViewLayoutPosition ( ) ; final int spanIndex = mLazySpanLookup . getSpan ( position ) ; Span currentSpan ; final boolean assignSpan = spanIndex == LayoutParams . INVALID_SPAN_ID ; if ( assignSpan ) { currentSpan = lp . mFullSpan ? mSpans [ <NUM_LIT> ] : getNextSpan ( layoutState ) ; mLazySpanLookup . setSpan ( position , currentSpan ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + currentSpan . mIndex + "<STR_LIT>" + position ) ; } } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + spanIndex + "<STR_LIT>" + position ) ; } currentSpan = mSpans [ spanIndex ] ; } lp . mSpan = currentSpan ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } measureChildWithDecorationsAndMargin ( view , lp , false ) ; final int start ; final int end ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { start = lp . mFullSpan ? getMaxEnd ( defaultNewViewLine ) : currentSpan . getEndLine ( defaultNewViewLine ) ; end = start + mPrimaryOrientation . getDecoratedMeasurement ( view ) ; if ( assignSpan && lp . mFullSpan ) { LazySpanLookup . FullSpanItem fullSpanItem ; fullSpanItem = createFullSpanItemFromEnd ( start ) ; fullSpanItem . mGapDir = LayoutState . LAYOUT_START ; fullSpanItem . mPosition = position ; mLazySpanLookup . addFullSpanItem ( fullSpanItem ) ; } } else { end = lp . mFullSpan ? getMinStart ( defaultNewViewLine ) : currentSpan . getStartLine ( defaultNewViewLine ) ; start = end - mPrimaryOrientation . getDecoratedMeasurement ( view ) ; if ( assignSpan && lp . mFullSpan ) { LazySpanLookup . FullSpanItem fullSpanItem ; fullSpanItem = createFullSpanItemFromStart ( end ) ; fullSpanItem . mGapDir = LayoutState . LAYOUT_END ; fullSpanItem . mPosition = position ; mLazySpanLookup . addFullSpanItem ( fullSpanItem ) ; } } if ( lp . mFullSpan && layoutState . mItemDirection == LayoutState . ITEM_DIRECTION_HEAD ) { if ( assignSpan ) { mLaidOutInvalidFullSpan = true ; } else { final boolean hasInvalidGap ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { hasInvalidGap = ! areAllEndsEqual ( ) ; } else { hasInvalidGap = ! areAllStartsEqual ( ) ; } if ( hasInvalidGap ) { final LazySpanLookup . FullSpanItem fullSpanItem = mLazySpanLookup . getFullSpanItem ( position ) ; if ( fullSpanItem != null ) { fullSpanItem . mHasUnwantedGapAfter = true ; } mLaidOutInvalidFullSpan = true ; } } } attachViewToSpans ( view , lp , layoutState ) ; final int otherStart ; final int otherEnd ; if ( isLayoutRTL ( ) && mOrientation == VERTICAL ) { otherEnd = lp . mFullSpan ? mSecondaryOrientation . getEndAfterPadding ( ) : mSecondaryOrientation . getEndAfterPadding ( ) - ( mSpanCount - <NUM_LIT> - currentSpan . mIndex ) * mSizePerSpan ; otherStart = otherEnd - mSecondaryOrientation . getDecoratedMeasurement ( view ) ; } else { otherStart = lp . mFullSpan ? mSecondaryOrientation . getStartAfterPadding ( ) : currentSpan . mIndex * mSizePerSpan + mSecondaryOrientation . getStartAfterPadding ( ) ; otherEnd = otherStart + mSecondaryOrientation . getDecoratedMeasurement ( view ) ; } if ( mOrientation == VERTICAL ) { layoutDecoratedWithMargins ( view , otherStart , start , otherEnd , end ) ; } else { layoutDecoratedWithMargins ( view , start , otherStart , end , otherEnd ) ; } if ( lp . mFullSpan ) { updateAllRemainingSpans ( mLayoutState . mLayoutDirection , targetLine ) ; } else { updateRemainingSpans ( currentSpan , mLayoutState . mLayoutDirection , targetLine ) ; } recycle ( recycler , mLayoutState ) ; if ( mLayoutState . mStopInFocusable && view . hasFocusable ( ) ) { if ( lp . mFullSpan ) { mRemainingSpans . clear ( ) ; } else { mRemainingSpans . set ( currentSpan . mIndex , false ) ; } } added = true ; } if ( ! added ) { recycle ( recycler , mLayoutState ) ; } final int diff ; if ( mLayoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { final int minStart = getMinStart ( mPrimaryOrientation . getStartAfterPadding ( ) ) ; diff = mPrimaryOrientation . getStartAfterPadding ( ) - minStart ; } else { final int maxEnd = getMaxEnd ( mPrimaryOrientation . getEndAfterPadding ( ) ) ; diff = maxEnd - mPrimaryOrientation . getEndAfterPadding ( ) ; } return diff > <NUM_LIT> ? Math . min ( layoutState . mAvailable , diff ) : <NUM_LIT> ; } private LazySpanLookup . FullSpanItem createFullSpanItemFromEnd ( int newItemTop ) { LazySpanLookup . FullSpanItem fsi = new LazySpanLookup . FullSpanItem ( ) ; fsi . mGapPerSpan = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { fsi . mGapPerSpan [ i ] = newItemTop - mSpans [ i ] . getEndLine ( newItemTop ) ; } return fsi ; } private LazySpanLookup . FullSpanItem createFullSpanItemFromStart ( int newItemBottom ) { LazySpanLookup . FullSpanItem fsi = new LazySpanLookup . FullSpanItem ( ) ; fsi . mGapPerSpan = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { fsi . mGapPerSpan [ i ] = mSpans [ i ] . getStartLine ( newItemBottom ) - newItemBottom ; } return fsi ; } private void attachViewToSpans ( View view , LayoutParams lp , LayoutState layoutState ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { if ( lp . mFullSpan ) { appendViewToAllSpans ( view ) ; } else { lp . mSpan . appendToSpan ( view ) ; } } else { if ( lp . mFullSpan ) { prependViewToAllSpans ( view ) ; } else { lp . mSpan . prependToSpan ( view ) ; } } } private void recycle ( RecyclerView . Recycler recycler , LayoutState layoutState ) { if ( ! layoutState . mRecycle || layoutState . mInfinite ) { return ; } if ( layoutState . mAvailable == <NUM_LIT> ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { recycleFromEnd ( recycler , layoutState . mEndLine ) ; } else { recycleFromStart ( recycler , layoutState . mStartLine ) ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { int scrolled = layoutState . mStartLine - getMaxStart ( layoutState . mStartLine ) ; final int line ; if ( scrolled < <NUM_LIT> ) { line = layoutState . mEndLine ; } else { line = layoutState . mEndLine - Math . min ( scrolled , layoutState . mAvailable ) ; } recycleFromEnd ( recycler , line ) ; } else { int scrolled = getMinEnd ( layoutState . mEndLine ) - layoutState . mEndLine ; final int line ; if ( scrolled < <NUM_LIT> ) { line = layoutState . mStartLine ; } else { line = layoutState . mStartLine + Math . min ( scrolled , layoutState . mAvailable ) ; } recycleFromStart ( recycler , line ) ; } } } private void appendViewToAllSpans ( View view ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mSpans [ i ] . appendToSpan ( view ) ; } } private void prependViewToAllSpans ( View view ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mSpans [ i ] . prependToSpan ( view ) ; } } private void updateAllRemainingSpans ( int layoutDir , int targetLine ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . mViews . isEmpty ( ) ) { continue ; } updateRemainingSpans ( mSpans [ i ] , layoutDir , targetLine ) ; } } private void updateRemainingSpans ( Span span , int layoutDir , int targetLine ) { final int deletedSize = span . getDeletedSize ( ) ; if ( layoutDir == LayoutState . LAYOUT_START ) { final int line = span . getStartLine ( ) ; if ( line + deletedSize <= targetLine ) { mRemainingSpans . set ( span . mIndex , false ) ; } } else { final int line = span . getEndLine ( ) ; if ( line - deletedSize >= targetLine ) { mRemainingSpans . set ( span . mIndex , false ) ; } } } private int getMaxStart ( int def ) { int maxStart = mSpans [ <NUM_LIT> ] . getStartLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanStart = mSpans [ i ] . getStartLine ( def ) ; if ( spanStart > maxStart ) { maxStart = spanStart ; } } return maxStart ; } private int getMinStart ( int def ) { int minStart = mSpans [ <NUM_LIT> ] . getStartLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanStart = mSpans [ i ] . getStartLine ( def ) ; if ( spanStart < minStart ) { minStart = spanStart ; } } return minStart ; } boolean areAllEndsEqual ( ) { int end = mSpans [ <NUM_LIT> ] . getEndLine ( Span . INVALID_LINE ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . getEndLine ( Span . INVALID_LINE ) != end ) { return false ; } } return true ; } boolean areAllStartsEqual ( ) { int start = mSpans [ <NUM_LIT> ] . getStartLine ( Span . INVALID_LINE ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . getStartLine ( Span . INVALID_LINE ) != start ) { return false ; } } return true ; } private int getMaxEnd ( int def ) { int maxEnd = mSpans [ <NUM_LIT> ] . getEndLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanEnd = mSpans [ i ] . getEndLine ( def ) ; if ( spanEnd > maxEnd ) { maxEnd = spanEnd ; } } return maxEnd ; } private int getMinEnd ( int def ) { int minEnd = mSpans [ <NUM_LIT> ] . getEndLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanEnd = mSpans [ i ] . getEndLine ( def ) ; if ( spanEnd < minEnd ) { minEnd = spanEnd ; } } return minEnd ; } private void recycleFromStart ( RecyclerView . Recycler recycler , int line ) { while ( getChildCount ( ) > <NUM_LIT> ) { View child = getChildAt ( <NUM_LIT> ) ; if ( mPrimaryOrientation . getDecoratedEnd ( child ) <= line && mPrimaryOrientation . getTransformedEndWithDecoration ( child ) <= line ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { if ( mSpans [ j ] . mViews . size ( ) == <NUM_LIT> ) { return ; } } for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { mSpans [ j ] . popStart ( ) ; } } else { if ( lp . mSpan . mViews . size ( ) == <NUM_LIT> ) { return ; } lp . mSpan . popStart ( ) ; } removeAndRecycleView ( child , recycler ) ; } else { return ; } } } private void recycleFromEnd ( RecyclerView . Recycler recycler , int line ) { final int childCount = getChildCount ( ) ; int i ; for ( i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mPrimaryOrientation . getDecoratedStart ( child ) >= line && mPrimaryOrientation . getTransformedStartWithDecoration ( child ) >= line ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { if ( mSpans [ j ] . mViews . size ( ) == <NUM_LIT> ) { return ; } } for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { mSpans [ j ] . popEnd ( ) ; } } else { if ( lp . mSpan . mViews . size ( ) == <NUM_LIT> ) { return ; } lp . mSpan . popEnd ( ) ; } removeAndRecycleView ( child , recycler ) ; } else { return ; } } } private boolean preferLastSpan ( int layoutDir ) { if ( mOrientation == HORIZONTAL ) { return ( layoutDir == LayoutState . LAYOUT_START ) != mShouldReverseLayout ; } return ( ( layoutDir == LayoutState . LAYOUT_START ) == mShouldReverseLayout ) == isLayoutRTL ( ) ; } private Span getNextSpan ( LayoutState layoutState ) { final boolean preferLastSpan = preferLastSpan ( layoutState . mLayoutDirection ) ; final int startIndex , endIndex , diff ; if ( preferLastSpan ) { startIndex = mSpanCount - <NUM_LIT> ; endIndex = - <NUM_LIT> ; diff = - <NUM_LIT> ; } else { startIndex = <NUM_LIT> ; endIndex = mSpanCount ; diff = <NUM_LIT> ; } if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { Span min = null ; int minLine = Integer . MAX_VALUE ; final int defaultLine = mPrimaryOrientation . getStartAfterPadding ( ) ; for ( int i = startIndex ; i != endIndex ; i += diff ) { final Span other = mSpans [ i ] ; int otherLine = other . getEndLine ( defaultLine ) ; if ( otherLine < minLine ) { min = other ; minLine = otherLine ; } } return min ; } else { Span max = null ; int maxLine = Integer . MIN_VALUE ; final int defaultLine = mPrimaryOrientation . getEndAfterPadding ( ) ; for ( int i = startIndex ; i != endIndex ; i += diff ) { final Span other = mSpans [ i ] ; int otherLine = other . getStartLine ( defaultLine ) ; if ( otherLine > maxLine ) { max = other ; maxLine = otherLine ; } } return max ; } } @ Override public boolean canScrollVertically ( ) { return mOrientation == VERTICAL ; } @ Override public boolean canScrollHorizontally ( ) { return mOrientation == HORIZONTAL ; } @ Override public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { return scrollBy ( dx , recycler , state ) ; } @ Override public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { return scrollBy ( dy , recycler , state ) ; } private int calculateScrollDirectionForPosition ( int position ) { if ( getChildCount ( ) == <NUM_LIT> ) { return mShouldReverseLayout ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; } final int firstChildPos = getFirstChildPosition ( ) ; return position < firstChildPos != mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; } @ Override public PointF computeScrollVectorForPosition ( int targetPosition ) { final int direction = calculateScrollDirectionForPosition ( targetPosition ) ; PointF outVector = new PointF ( ) ; if ( direction == <NUM_LIT> ) { return null ; } if ( mOrientation == HORIZONTAL ) { outVector . x = direction ; outVector . y = <NUM_LIT> ; } else { outVector . x = <NUM_LIT> ; outVector . y = direction ; } return outVector ; } @ Override public void smoothScrollToPosition ( RecyclerView recyclerView , RecyclerView . State state , int position ) { LinearSmoothScroller scroller = new LinearSmoothScroller ( recyclerView . getContext ( ) ) ; scroller . setTargetPosition ( position ) ; startSmoothScroll ( scroller ) ; } @ Override public void scrollToPosition ( int position ) { if ( mPendingSavedState != null && mPendingSavedState . mAnchorPosition != position ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; } mPendingScrollPosition = position ; mPendingScrollPositionOffset = INVALID_OFFSET ; requestLayout ( ) ; } public void scrollToPositionWithOffset ( int position , int offset ) { if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; } mPendingScrollPosition = position ; mPendingScrollPositionOffset = offset ; requestLayout ( ) ; } @ Override @ RestrictTo ( LIBRARY ) public void collectAdjacentPrefetchPositions ( int dx , int dy , RecyclerView . State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int delta = ( mOrientation == HORIZONTAL ) ? dx : dy ; if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return ; } prepareLayoutStateForDelta ( delta , state ) ; if ( mPrefetchDistances == null || mPrefetchDistances . length < mSpanCount ) { mPrefetchDistances = new int [ mSpanCount ] ; } int itemPrefetchCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { int distance = mLayoutState . mItemDirection == LayoutState . LAYOUT_START ? mLayoutState . mStartLine - mSpans [ i ] . getStartLine ( mLayoutState . mStartLine ) : mSpans [ i ] . getEndLine ( mLayoutState . mEndLine ) - mLayoutState . mEndLine ; if ( distance >= <NUM_LIT> ) { mPrefetchDistances [ itemPrefetchCount ] = distance ; itemPrefetchCount ++ ; } } Arrays . sort ( mPrefetchDistances , <NUM_LIT> , itemPrefetchCount ) ; for ( int i = <NUM_LIT> ; i < itemPrefetchCount && mLayoutState . hasMore ( state ) ; i ++ ) { layoutPrefetchRegistry . addPosition ( mLayoutState . mCurrentPosition , mPrefetchDistances [ i ] ) ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; } } void prepareLayoutStateForDelta ( int delta , RecyclerView . State state ) { final int referenceChildPosition ; final int layoutDir ; if ( delta > <NUM_LIT> ) { layoutDir = LayoutState . LAYOUT_END ; referenceChildPosition = getLastChildPosition ( ) ; } else { layoutDir = LayoutState . LAYOUT_START ; referenceChildPosition = getFirstChildPosition ( ) ; } mLayoutState . mRecycle = true ; updateLayoutState ( referenceChildPosition , state ) ; setLayoutStateDirection ( layoutDir ) ; mLayoutState . mCurrentPosition = referenceChildPosition + mLayoutState . mItemDirection ; mLayoutState . mAvailable = Math . abs ( delta ) ; } int scrollBy ( int dt , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || dt == <NUM_LIT> ) { return <NUM_LIT> ; } prepareLayoutStateForDelta ( dt , state ) ; int consumed = fill ( recycler , mLayoutState , state ) ; final int available = mLayoutState . mAvailable ; final int totalScroll ; if ( available < consumed ) { totalScroll = dt ; } else if ( dt < <NUM_LIT> ) { totalScroll = - consumed ; } else { totalScroll = consumed ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + dt + "<STR_LIT>" + totalScroll ) ; } mPrimaryOrientation . offsetChildren ( - totalScroll ) ; mLastLayoutFromEnd = mShouldReverseLayout ; mLayoutState . mAvailable = <NUM_LIT> ; recycle ( recycler , mLayoutState ) ; return totalScroll ; } int getLastChildPosition ( ) { final int childCount = getChildCount ( ) ; return childCount == <NUM_LIT> ? <NUM_LIT> : getPosition ( getChildAt ( childCount - <NUM_LIT> ) ) ; } int getFirstChildPosition ( ) { final int childCount = getChildCount ( ) ; return childCount == <NUM_LIT> ? <NUM_LIT> : getPosition ( getChildAt ( <NUM_LIT> ) ) ; } private int findFirstReferenceChildPosition ( int itemCount ) { final int limit = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { return position ; } } return <NUM_LIT> ; } private int findLastReferenceChildPosition ( int itemCount ) { for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { return position ; } } return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { if ( mOrientation == HORIZONTAL ) { return new LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; } else { return new LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } } @ Override public RecyclerView . LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ Override public RecyclerView . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof ViewGroup . MarginLayoutParams ) { return new LayoutParams ( ( ViewGroup . MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ Override public boolean checkLayoutParams ( RecyclerView . LayoutParams lp ) { return lp instanceof LayoutParams ; } public int getOrientation ( ) { return mOrientation ; } @ Nullable @ Override public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final View directChild = findContainingItemView ( focused ) ; if ( directChild == null ) { return null ; } resolveShouldLayoutReverse ( ) ; final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; if ( layoutDir == LayoutState . INVALID_LAYOUT ) { return null ; } LayoutParams prevFocusLayoutParams = ( LayoutParams ) directChild . getLayoutParams ( ) ; boolean prevFocusFullSpan = prevFocusLayoutParams . mFullSpan ; final Span prevFocusSpan = prevFocusLayoutParams . mSpan ; final int referenceChildPosition ; if ( layoutDir == LayoutState . LAYOUT_END ) { referenceChildPosition = getLastChildPosition ( ) ; } else { referenceChildPosition = getFirstChildPosition ( ) ; } updateLayoutState ( referenceChildPosition , state ) ; setLayoutStateDirection ( layoutDir ) ; mLayoutState . mCurrentPosition = referenceChildPosition + mLayoutState . mItemDirection ; mLayoutState . mAvailable = ( int ) ( MAX_SCROLL_FACTOR * mPrimaryOrientation . getTotalSpace ( ) ) ; mLayoutState . mStopInFocusable = true ; mLayoutState . mRecycle = false ; fill ( recycler , mLayoutState , state ) ; mLastLayoutFromEnd = mShouldReverseLayout ; if ( ! prevFocusFullSpan ) { View view = prevFocusSpan . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } if ( preferLastSpan ( layoutDir ) ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View view = mSpans [ i ] . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { View view = mSpans [ i ] . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } } boolean shouldSearchFromStart = ! mReverseLayout == ( layoutDir == LayoutState . LAYOUT_START ) ; View unfocusableCandidate = null ; if ( ! prevFocusFullSpan ) { unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? prevFocusSpan . findFirstPartiallyVisibleItemPosition ( ) : prevFocusSpan . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } if ( preferLastSpan ( layoutDir ) ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( i == prevFocusSpan . mIndex ) { continue ; } unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? mSpans [ i ] . findFirstPartiallyVisibleItemPosition ( ) : mSpans [ i ] . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? mSpans [ i ] . findFirstPartiallyVisibleItemPosition ( ) : mSpans [ i ] . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } } return null ; } private int convertFocusDirectionToLayoutDirection ( int focusDirection ) { switch ( focusDirection ) { case View . FOCUS_BACKWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_START ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_END ; } else { return LayoutState . LAYOUT_START ; } case View . FOCUS_FORWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_END ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_START ; } else { return LayoutState . LAYOUT_END ; } case View . FOCUS_UP : return mOrientation == VERTICAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_DOWN : return mOrientation == VERTICAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; case View . FOCUS_LEFT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_RIGHT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; default : if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + focusDirection ) ; } return LayoutState . INVALID_LAYOUT ; } } public static class LayoutParams extends RecyclerView . LayoutParams { public static final int INVALID_SPAN_ID = - <NUM_LIT> ; Span mSpan ; boolean mFullSpan ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( ViewGroup . MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( RecyclerView . LayoutParams source ) { super ( source ) ; } public void setFullSpan ( boolean fullSpan ) { mFullSpan = fullSpan ; } public boolean isFullSpan ( ) { return mFullSpan ; } public final int getSpanIndex ( ) { if ( mSpan == null ) { return INVALID_SPAN_ID ; } return mSpan . mIndex ; } } class Span { static final int INVALID_LINE = Integer . MIN_VALUE ; ArrayList < View > mViews = new ArrayList < > ( ) ; int mCachedStart = INVALID_LINE ; int mCachedEnd = INVALID_LINE ; int mDeletedSize = <NUM_LIT> ; final int mIndex ; Span ( int index ) { mIndex = index ; } int getStartLine ( int def ) { if ( mCachedStart != INVALID_LINE ) { return mCachedStart ; } if ( mViews . size ( ) == <NUM_LIT> ) { return def ; } calculateCachedStart ( ) ; return mCachedStart ; } void calculateCachedStart ( ) { final View startView = mViews . get ( <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( startView ) ; mCachedStart = mPrimaryOrientation . getDecoratedStart ( startView ) ; if ( lp . mFullSpan ) { LazySpanLookup . FullSpanItem fsi = mLazySpanLookup . getFullSpanItem ( lp . getViewLayoutPosition ( ) ) ; if ( fsi != null && fsi . mGapDir == LayoutState . LAYOUT_START ) { mCachedStart -= fsi . getGapForSpan ( mIndex ) ; } } } int getStartLine ( ) { if ( mCachedStart != INVALID_LINE ) { return mCachedStart ; } calculateCachedStart ( ) ; return mCachedStart ; } int getEndLine ( int def ) { if ( mCachedEnd != INVALID_LINE ) { return mCachedEnd ; } final int size = mViews . size ( ) ; if ( size == <NUM_LIT> ) { return def ; } calculateCachedEnd ( ) ; return mCachedEnd ; } void calculateCachedEnd ( ) { final View endView = mViews . get ( mViews . size ( ) - <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( endView ) ; mCachedEnd = mPrimaryOrientation . getDecoratedEnd ( endView ) ; if ( lp . mFullSpan ) { LazySpanLookup . FullSpanItem fsi = mLazySpanLookup . getFullSpanItem ( lp . getViewLayoutPosition ( ) ) ; if ( fsi != null && fsi . mGapDir == LayoutState . LAYOUT_END ) { mCachedEnd += fsi . getGapForSpan ( mIndex ) ; } } } int getEndLine ( ) { if ( mCachedEnd != INVALID_LINE ) { return mCachedEnd ; } calculateCachedEnd ( ) ; return mCachedEnd ; } void prependToSpan ( View view ) { LayoutParams lp = getLayoutParams ( view ) ; lp . mSpan = this ; mViews . add ( <NUM_LIT> , view ) ; mCachedStart = INVALID_LINE ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedEnd = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize += mPrimaryOrientation . getDecoratedMeasurement ( view ) ; } } void appendToSpan ( View view ) { LayoutParams lp = getLayoutParams ( view ) ; lp . mSpan = this ; mViews . add ( view ) ; mCachedEnd = INVALID_LINE ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedStart = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize += mPrimaryOrientation . getDecoratedMeasurement ( view ) ; } } void cacheReferenceLineAndClear ( boolean reverseLayout , int offset ) { int reference ; if ( reverseLayout ) { reference = getEndLine ( INVALID_LINE ) ; } else { reference = getStartLine ( INVALID_LINE ) ; } clear ( ) ; if ( reference == INVALID_LINE ) { return ; } if ( ( reverseLayout && reference < mPrimaryOrientation . getEndAfterPadding ( ) ) || ( ! reverseLayout && reference > mPrimaryOrientation . getStartAfterPadding ( ) ) ) { return ; } if ( offset != INVALID_OFFSET ) { reference += offset ; } mCachedStart = mCachedEnd = reference ; } void clear ( ) { mViews . clear ( ) ; invalidateCache ( ) ; mDeletedSize = <NUM_LIT> ; } void invalidateCache ( ) { mCachedStart = INVALID_LINE ; mCachedEnd = INVALID_LINE ; } void setLine ( int line ) { mCachedEnd = mCachedStart = line ; } void popEnd ( ) { final int size = mViews . size ( ) ; View end = mViews . remove ( size - <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( end ) ; lp . mSpan = null ; if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize -= mPrimaryOrientation . getDecoratedMeasurement ( end ) ; } if ( size == <NUM_LIT> ) { mCachedStart = INVALID_LINE ; } mCachedEnd = INVALID_LINE ; } void popStart ( ) { View start = mViews . remove ( <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( start ) ; lp . mSpan = null ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedEnd = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize -= mPrimaryOrientation . getDecoratedMeasurement ( start ) ; } mCachedStart = INVALID_LINE ; } public int getDeletedSize ( ) { return mDeletedSize ; } LayoutParams getLayoutParams ( View view ) { return ( LayoutParams ) view . getLayoutParams ( ) ; } void onOffset ( int dt ) { if ( mCachedStart != INVALID_LINE ) { mCachedStart += dt ; } if ( mCachedEnd != INVALID_LINE ) { mCachedEnd += dt ; } } public int findFirstVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , false ) : findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , false ) ; } public int findFirstPartiallyVisibleItemPosition ( ) { return mReverseLayout ? findOnePartiallyVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) : findOnePartiallyVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) ; } public int findFirstCompletelyVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) : findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) ; } public int findLastVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , false ) : findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , false ) ; } public int findLastPartiallyVisibleItemPosition ( ) { return mReverseLayout ? findOnePartiallyVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) : findOnePartiallyVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) ; } public int findLastCompletelyVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) : findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) ; } int findOnePartiallyOrCompletelyVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible , boolean acceptCompletelyVisible , boolean acceptEndPointInclusion ) { final int start = mPrimaryOrientation . getStartAfterPadding ( ) ; final int end = mPrimaryOrientation . getEndAfterPadding ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mViews . get ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; boolean childStartInclusion = acceptEndPointInclusion ? ( childStart <= end ) : ( childStart < end ) ; boolean childEndInclusion = acceptEndPointInclusion ? ( childEnd >= start ) : ( childEnd > start ) ; if ( childStartInclusion && childEndInclusion ) { if ( completelyVisible && acceptCompletelyVisible ) { if ( childStart >= start && childEnd <= end ) { return getPosition ( child ) ; } } else if ( acceptCompletelyVisible ) { return getPosition ( child ) ; } else if ( childStart < start || childEnd > end ) { return getPosition ( child ) ; } } } return RecyclerView . NO_POSITION ; } int findOneVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible ) { return findOnePartiallyOrCompletelyVisibleChild ( fromIndex , toIndex , completelyVisible , true , false ) ; } int findOnePartiallyVisibleChild ( int fromIndex , int toIndex , boolean acceptEndPointInclusion ) { return findOnePartiallyOrCompletelyVisibleChild ( fromIndex , toIndex , false , false , acceptEndPointInclusion ) ; } public View getFocusableViewAfter ( int referenceChildPosition , int layoutDir ) { View candidate = null ; if ( layoutDir == LayoutState . LAYOUT_START ) { final int limit = mViews . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View view = mViews . get ( i ) ; if ( ( mReverseLayout && getPosition ( view ) <= referenceChildPosition ) || ( ! mReverseLayout && getPosition ( view ) >= referenceChildPosition ) ) { break ; } if ( view . hasFocusable ( ) ) { candidate = view ; } else { break ; } } } else { for ( int i = mViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = mViews . get ( i ) ; if ( ( mReverseLayout && getPosition ( view ) >= referenceChildPosition ) || ( ! mReverseLayout && getPosition ( view ) <= referenceChildPosition ) ) { break ; } if ( view . hasFocusable ( ) ) { candidate = view ; } else { break ; } } } return candidate ; } } static class LazySpanLookup { private static final int MIN_SIZE = <NUM_LIT> ; int [ ] mData ; List < FullSpanItem > mFullSpanItems ; int forceInvalidateAfter ( int position ) { if ( mFullSpanItems != null ) { for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= position ) { mFullSpanItems . remove ( i ) ; } } } return invalidateAfter ( position ) ; } int invalidateAfter ( int position ) { if ( mData == null ) { return RecyclerView . NO_POSITION ; } if ( position >= mData . length ) { return RecyclerView . NO_POSITION ; } int endPosition = invalidateFullSpansAfter ( position ) ; if ( endPosition == RecyclerView . NO_POSITION ) { Arrays . fill ( mData , position , mData . length , LayoutParams . INVALID_SPAN_ID ) ; return mData . length ; } else { final int invalidateToIndex = Math . min ( endPosition + <NUM_LIT> , mData . length ) ; Arrays . fill ( mData , position , invalidateToIndex , LayoutParams . INVALID_SPAN_ID ) ; return invalidateToIndex ; } } int getSpan ( int position ) { if ( mData == null || position >= mData . length ) { return LayoutParams . INVALID_SPAN_ID ; } else { return mData [ position ] ; } } void setSpan ( int position , Span span ) { ensureSize ( position ) ; mData [ position ] = span . mIndex ; } int sizeForPosition ( int position ) { int len = mData . length ; while ( len <= position ) { len *= <NUM_LIT> ; } return len ; } void ensureSize ( int position ) { if ( mData == null ) { mData = new int [ Math . max ( position , MIN_SIZE ) + <NUM_LIT> ] ; Arrays . fill ( mData , LayoutParams . INVALID_SPAN_ID ) ; } else if ( position >= mData . length ) { int [ ] old = mData ; mData = new int [ sizeForPosition ( position ) ] ; System . arraycopy ( old , <NUM_LIT> , mData , <NUM_LIT> , old . length ) ; Arrays . fill ( mData , old . length , mData . length , LayoutParams . INVALID_SPAN_ID ) ; } } void clear ( ) { if ( mData != null ) { Arrays . fill ( mData , LayoutParams . INVALID_SPAN_ID ) ; } mFullSpanItems = null ; } void offsetForRemoval ( int positionStart , int itemCount ) { if ( mData == null || positionStart >= mData . length ) { return ; } ensureSize ( positionStart + itemCount ) ; System . arraycopy ( mData , positionStart + itemCount , mData , positionStart , mData . length - positionStart - itemCount ) ; Arrays . fill ( mData , mData . length - itemCount , mData . length , LayoutParams . INVALID_SPAN_ID ) ; offsetFullSpansForRemoval ( positionStart , itemCount ) ; } private void offsetFullSpansForRemoval ( int positionStart , int itemCount ) { if ( mFullSpanItems == null ) { return ; } final int end = positionStart + itemCount ; for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition < positionStart ) { continue ; } if ( fsi . mPosition < end ) { mFullSpanItems . remove ( i ) ; } else { fsi . mPosition -= itemCount ; } } } void offsetForAddition ( int positionStart , int itemCount ) { if ( mData == null || positionStart >= mData . length ) { return ; } ensureSize ( positionStart + itemCount ) ; System . arraycopy ( mData , positionStart , mData , positionStart + itemCount , mData . length - positionStart - itemCount ) ; Arrays . fill ( mData , positionStart , positionStart + itemCount , LayoutParams . INVALID_SPAN_ID ) ; offsetFullSpansForAddition ( positionStart , itemCount ) ; } private void offsetFullSpansForAddition ( int positionStart , int itemCount ) { if ( mFullSpanItems == null ) { return ; } for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition < positionStart ) { continue ; } fsi . mPosition += itemCount ; } } private int invalidateFullSpansAfter ( int position ) { if ( mFullSpanItems == null ) { return RecyclerView . NO_POSITION ; } final FullSpanItem item = getFullSpanItem ( position ) ; if ( item != null ) { mFullSpanItems . remove ( item ) ; } int nextFsiIndex = - <NUM_LIT> ; final int count = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= position ) { nextFsiIndex = i ; break ; } } if ( nextFsiIndex != - <NUM_LIT> ) { FullSpanItem fsi = mFullSpanItems . get ( nextFsiIndex ) ; mFullSpanItems . remove ( nextFsiIndex ) ; return fsi . mPosition ; } return RecyclerView . NO_POSITION ; } public void addFullSpanItem ( FullSpanItem fullSpanItem ) { if ( mFullSpanItems == null ) { mFullSpanItems = new ArrayList < > ( ) ; } final int size = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { FullSpanItem other = mFullSpanItems . get ( i ) ; if ( other . mPosition == fullSpanItem . mPosition ) { if ( DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } else { mFullSpanItems . remove ( i ) ; } } if ( other . mPosition >= fullSpanItem . mPosition ) { mFullSpanItems . add ( i , fullSpanItem ) ; return ; } } mFullSpanItems . add ( fullSpanItem ) ; } public FullSpanItem getFullSpanItem ( int position ) { if ( mFullSpanItems == null ) { return null ; } for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition == position ) { return fsi ; } } return null ; } public FullSpanItem getFirstFullSpanItemInRange ( int minPos , int maxPos , int gapDir , boolean hasUnwantedGapAfter ) { if ( mFullSpanItems == null ) { return null ; } final int limit = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= maxPos ) { return null ; } if ( fsi . mPosition >= minPos && ( gapDir == <NUM_LIT> || fsi . mGapDir == gapDir || ( hasUnwantedGapAfter && fsi . mHasUnwantedGapAfter ) ) ) { return fsi ; } } return null ; } @ SuppressLint ( "<STR_LIT>" ) static class FullSpanItem implements Parcelable { int mPosition ; int mGapDir ; int [ ] mGapPerSpan ; boolean mHasUnwantedGapAfter ; FullSpanItem ( Parcel in ) { mPosition = in . readInt ( ) ; mGapDir = in . readInt ( ) ; mHasUnwantedGapAfter = in . readInt ( ) == <NUM_LIT> ; int spanCount = in . readInt ( ) ; if ( spanCount > <NUM_LIT> ) { mGapPerSpan = new int [ spanCount ] ; in . readIntArray ( mGapPerSpan ) ; } } FullSpanItem ( ) { } int getGapForSpan ( int spanIndex ) { return mGapPerSpan == null ? <NUM_LIT> : mGapPerSpan [ spanIndex ] ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mPosition ) ; dest . writeInt ( mGapDir ) ; dest . writeInt ( mHasUnwantedGapAfter ? <NUM_LIT> : <NUM_LIT> ) ; if ( mGapPerSpan != null && mGapPerSpan . length > <NUM_LIT> ) { dest . writeInt ( mGapPerSpan . length ) ; dest . writeIntArray ( mGapPerSpan ) ; } else { dest . writeInt ( <NUM_LIT> ) ; } } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mPosition + "<STR_LIT>" + mGapDir + "<STR_LIT>" + mHasUnwantedGapAfter + "<STR_LIT>" + Arrays . toString ( mGapPerSpan ) + '<STR_LIT>' ; } public static final Parcelable . Creator < FullSpanItem > CREATOR = new Parcelable . Creator < FullSpanItem > ( ) { @ Override public FullSpanItem createFromParcel ( Parcel in ) { return new FullSpanItem ( in ) ; } @ Override public FullSpanItem [ ] newArray ( int size ) { return new FullSpanItem [ size ] ; } } ; } } @ RestrictTo ( LIBRARY ) @ SuppressLint ( "<STR_LIT>" ) public static class SavedState implements Parcelable { int mAnchorPosition ; int mVisibleAnchorPosition ; int mSpanOffsetsSize ; int [ ] mSpanOffsets ; int mSpanLookupSize ; int [ ] mSpanLookup ; List < LazySpanLookup . FullSpanItem > mFullSpanItems ; boolean mReverseLayout ; boolean mAnchorLayoutFromEnd ; boolean mLastLayoutRTL ; public SavedState ( ) { } SavedState ( Parcel in ) { mAnchorPosition = in . readInt ( ) ; mVisibleAnchorPosition = in . readInt ( ) ; mSpanOffsetsSize = in . readInt ( ) ; if ( mSpanOffsetsSize > <NUM_LIT> ) { mSpanOffsets = new int [ mSpanOffsetsSize ] ; in . readIntArray ( mSpanOffsets ) ; } mSpanLookupSize = in . readInt ( ) ; if ( mSpanLookupSize > <NUM_LIT> ) { mSpanLookup = new int [ mSpanLookupSize ] ; in . readIntArray ( mSpanLookup ) ; } mReverseLayout = in . readInt ( ) == <NUM_LIT> ; mAnchorLayoutFromEnd = in . readInt ( ) == <NUM_LIT> ; mLastLayoutRTL = in . readInt ( ) == <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) List < LazySpanLookup . FullSpanItem > fullSpanItems = in . readArrayList ( LazySpanLookup . FullSpanItem . class . getClassLoader ( ) ) ; mFullSpanItems = fullSpanItems ; } public SavedState ( SavedState other ) { mSpanOffsetsSize = other . mSpanOffsetsSize ; mAnchorPosition = other . mAnchorPosition ; mVisibleAnchorPosition = other . mVisibleAnchorPosition ; mSpanOffsets = other . mSpanOffsets ; mSpanLookupSize = other . mSpanLookupSize ; mSpanLookup = other . mSpanLookup ; mReverseLayout = other . mReverseLayout ; mAnchorLayoutFromEnd = other . mAnchorLayoutFromEnd ; mLastLayoutRTL = other . mLastLayoutRTL ; mFullSpanItems = other . mFullSpanItems ; } void invalidateSpanInfo ( ) { mSpanOffsets = null ; mSpanOffsetsSize = <NUM_LIT> ; mSpanLookupSize = <NUM_LIT> ; mSpanLookup = null ; mFullSpanItems = null ; } void invalidateAnchorPositionInfo ( ) { mSpanOffsets = null ; mSpanOffsetsSize = <NUM_LIT> ; mAnchorPosition = RecyclerView . NO_POSITION ; mVisibleAnchorPosition = RecyclerView . NO_POSITION ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mAnchorPosition ) ; dest . writeInt ( mVisibleAnchorPosition ) ; dest . writeInt ( mSpanOffsetsSize ) ; if ( mSpanOffsetsSize > <NUM_LIT> ) { dest . writeIntArray ( mSpanOffsets ) ; } dest . writeInt ( mSpanLookupSize ) ; if ( mSpanLookupSize > <NUM_LIT> ) { dest . writeIntArray ( mSpanLookup ) ; } dest . writeInt ( mReverseLayout ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeInt ( mAnchorLayoutFromEnd ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeInt ( mLastLayoutRTL ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeList ( mFullSpanItems ) ; } public static final Parcelable . Creator < SavedState > CREATOR = new Parcelable . Creator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } class AnchorInfo { int mPosition ; int mOffset ; boolean mLayoutFromEnd ; boolean mInvalidateOffsets ; boolean mValid ; int [ ] mSpanReferenceLines ; AnchorInfo ( ) { reset ( ) ; } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = INVALID_OFFSET ; mLayoutFromEnd = false ; mInvalidateOffsets = false ; mValid = false ; if ( mSpanReferenceLines != null ) { Arrays . fill ( mSpanReferenceLines , - <NUM_LIT> ) ; } } void saveSpanReferenceLines ( Span [ ] spans ) { int spanCount = spans . length ; if ( mSpanReferenceLines == null || mSpanReferenceLines . length < spanCount ) { mSpanReferenceLines = new int [ mSpans . length ] ; } for ( int i = <NUM_LIT> ; i < spanCount ; i ++ ) { mSpanReferenceLines [ i ] = spans [ i ] . getStartLine ( Span . INVALID_LINE ) ; } } void assignCoordinateFromPadding ( ) { mOffset = mLayoutFromEnd ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; } void assignCoordinateFromPadding ( int addedDistance ) { if ( mLayoutFromEnd ) { mOffset = mPrimaryOrientation . getEndAfterPadding ( ) - addedDistance ; } else { mOffset = mPrimaryOrientation . getStartAfterPadding ( ) + addedDistance ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnTouchEvent ( event ) ; } return true ; } } } return superOnTouchEvent ( event ) ; } @ Override public int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } @ Override public int getScrollOffset ( ) { return computeVerticalScrollOffset ( ) ; } @ Override public void scrollTo ( int offset ) { scrollTo ( getScrollX ( ) , offset ) ; } protected abstract void superDraw ( @ NonNull Canvas canvas ) ; protected abstract void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) ; protected abstract boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract boolean superOnTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract int computeVerticalScrollRange ( ) ; protected abstract int computeVerticalScrollOffset ( ) ; protected abstract int getScrollX ( ) ; protected abstract void scrollTo ( int x , int y ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( "<STR_LIT>" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( "<STR_LIT>" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) { return mDiffer . getCurrentList ( ) . size ( ) ; } @ NonNull public List < T > getCurrentList ( ) { return mDiffer . getCurrentList ( ) ; } public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , "<STR_LIT>" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + "<STR_LIT>" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( "<STR_LIT>" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , "<STR_LIT>" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( "<STR_LIT>" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , "<STR_LIT>" + position ) ; return ; } if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( "<STR_LIT>" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( "<STR_LIT>" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( "<STR_LIT>" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( "<STR_LIT>" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( "<STR_LIT>" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( "<STR_LIT>" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; } else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) { removeTile ( lastLoadedTileStart ) ; } else { return ; } } } private void log ( String s , Object ... args ) { Log . d ( TAG , "<STR_LIT>" + String . format ( s , args ) ) ; } } ; public static abstract class DataCallback < T > { @ WorkerThread public abstract int refreshData ( ) ; @ WorkerThread public abstract void fillData ( @ NonNull T [ ] data , int startPosition , int itemCount ) ; @ WorkerThread public void recycleData ( @ NonNull T [ ] data , int itemCount ) { } @ WorkerThread public int getMaxCachedTiles ( ) { return <NUM_LIT> ; } } public static abstract class ViewCallback { public static final int HINT_SCROLL_NONE = <NUM_LIT> ; public static final int HINT_SCROLL_DESC = <NUM_LIT> ; public static final int HINT_SCROLL_ASC = <NUM_LIT> ; @ UiThread public abstract void getItemRangeInto ( @ NonNull int [ ] outRange ) ; @ UiThread public void extendRangeInto ( @ NonNull int [ ] range , @ NonNull int [ ] outRange , int scrollHint ) { final int fullRange = range [ <NUM_LIT> ] - range [ <NUM_LIT> ] + <NUM_LIT> ; final int halfRange = fullRange / <NUM_LIT> ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] - ( scrollHint == HINT_SCROLL_DESC ? fullRange : halfRange ) ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] + ( scrollHint == HINT_SCROLL_ASC ? fullRange : halfRange ) ; } @ UiThread public abstract void onDataRefresh ( ) ; @ UiThread public abstract void onItemLoaded ( int position ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; return ( int ) ( ( float ) laidOutArea / laidOutRange * state . getItemCount ( ) ) ; } private ScrollbarHelper ( ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( "<STR_LIT>" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = "<STR_LIT>" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { return mController . getWrappedAdapterAndPosition ( globalPosition ) ; } public static final class Config { public final boolean isolateViewTypes ; @ NonNull public final StableIdMode stableIdMode ; @ NonNull public static final Config DEFAULT = new Config ( true , NO_STABLE_IDS ) ; Config ( boolean isolateViewTypes , @ NonNull StableIdMode stableIdMode ) { this . isolateViewTypes = isolateViewTypes ; this . stableIdMode = stableIdMode ; } public enum StableIdMode { NO_STABLE_IDS , ISOLATED_STABLE_IDS , SHARED_STABLE_IDS } public static final class Builder { private boolean mIsolateViewTypes = DEFAULT . isolateViewTypes ; private StableIdMode mStableIdMode = DEFAULT . stableIdMode ; @ NonNull public Builder setIsolateViewTypes ( boolean isolateViewTypes ) { mIsolateViewTypes = isolateViewTypes ; return this ; } @ NonNull public Builder setStableIdMode ( @ NonNull StableIdMode stableIdMode ) { mStableIdMode = stableIdMode ; return this ; } @ NonNull public Config build ( ) { return new Config ( mIsolateViewTypes , mStableIdMode ) ; } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } } </s>
<s> package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( "<STR_LIT>" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } } public interface TabConfigurationStrategy { void onConfigureTab ( @ NonNull TabLayout . Tab tab , int position ) ; } private static class TabLayoutOnPageChangeCallback extends ViewPager2 . OnPageChangeCallback { @ NonNull private final WeakReference < TabLayout > tabLayoutRef ; private int previousScrollState ; private int scrollState ; TabLayoutOnPageChangeCallback ( TabLayout tabLayout ) { tabLayoutRef = new WeakReference < > ( tabLayout ) ; reset ( ) ; } @ Override public void onPageScrollStateChanged ( final int state ) { previousScrollState = scrollState ; scrollState = state ; TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { tabLayout . updateViewPagerScrollState ( scrollState ) ; } } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { boolean updateSelectedTabView = scrollState != SCROLL_STATE_SETTLING || previousScrollState == SCROLL_STATE_DRAGGING ; boolean updateIndicator = ! ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . setScrollPosition ( position , positionOffset , updateSelectedTabView , updateIndicator , false ) ; } } @ Override public void onPageSelected ( final int position ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null && tabLayout . getSelectedTabPosition ( ) != position && position < tabLayout . getTabCount ( ) ) { boolean updateIndicator = scrollState == SCROLL_STATE_IDLE || ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . selectTab ( tabLayout . getTabAt ( position ) , updateIndicator ) ; } } void reset ( ) { previousScrollState = scrollState = SCROLL_STATE_IDLE ; } } private static class ViewPagerOnTabSelectedListener implements TabLayout . OnTabSelectedListener { private final ViewPager2 viewPager ; private final boolean smoothScroll ; ViewPagerOnTabSelectedListener ( ViewPager2 viewPager , boolean smoothScroll ) { this . viewPager = viewPager ; this . smoothScroll = smoothScroll ; } @ Override public void onTabSelected ( @ NonNull TabLayout . Tab tab ) { viewPager . setCurrentItem ( tab . getPosition ( ) , smoothScroll ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } private class PagerAdapterObserver extends RecyclerView . AdapterDataObserver { PagerAdapterObserver ( ) { } @ Override public void onChanged ( ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . Nullable ; public interface ListUpdateCallback { void onInserted ( int position , int count ) ; void onRemoved ( int position , int count ) ; void onMoved ( int fromPosition , int toPosition ) ; void onChanged ( int position , int count , @ Nullable Object payload ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mAvailable + "<STR_LIT>" + mCurrentPosition + "<STR_LIT>" + mItemDirection + "<STR_LIT>" + mLayoutDirection + "<STR_LIT>" + mStartLine + "<STR_LIT>" + mEndLine + '<STR_LIT>' ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . content . Context ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . util . Log ; import android . util . SparseIntArray ; import android . view . View ; import android . view . ViewGroup ; import android . widget . GridView ; import androidx . annotation . NonNull ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import java . util . Arrays ; public class GridLayoutManager extends LinearLayoutManager { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; public static final int DEFAULT_SPAN_COUNT = - <NUM_LIT> ; boolean mPendingSpanCountChange = false ; int mSpanCount = DEFAULT_SPAN_COUNT ; int [ ] mCachedBorders ; View [ ] mSet ; final SparseIntArray mPreLayoutSpanSizeCache = new SparseIntArray ( ) ; final SparseIntArray mPreLayoutSpanIndexCache = new SparseIntArray ( ) ; SpanSizeLookup mSpanSizeLookup = new DefaultSpanSizeLookup ( ) ; final Rect mDecorInsets = new Rect ( ) ; private boolean mUsingSpansToEstimateScrollBarDimensions ; public GridLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setSpanCount ( properties . spanCount ) ; } public GridLayoutManager ( Context context , int spanCount ) { super ( context ) ; setSpanCount ( spanCount ) ; } public GridLayoutManager ( Context context , int spanCount , @ RecyclerView . Orientation int orientation , boolean reverseLayout ) { super ( context , orientation , reverseLayout ) ; setSpanCount ( spanCount ) ; } @ Override public void setStackFromEnd ( boolean stackFromEnd ) { if ( stackFromEnd ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } super . setStackFromEnd ( false ) ; } @ Override public int getRowCountForAccessibility ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == HORIZONTAL ) { return mSpanCount ; } if ( state . getItemCount ( ) < <NUM_LIT> ) { return <NUM_LIT> ; } return getSpanGroupIndex ( recycler , state , state . getItemCount ( ) - <NUM_LIT> ) + <NUM_LIT> ; } @ Override public int getColumnCountForAccessibility ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == VERTICAL ) { return mSpanCount ; } if ( state . getItemCount ( ) < <NUM_LIT> ) { return <NUM_LIT> ; } return getSpanGroupIndex ( recycler , state , state . getItemCount ( ) - <NUM_LIT> ) + <NUM_LIT> ; } @ Override public void onInitializeAccessibilityNodeInfoForItem ( RecyclerView . Recycler recycler , RecyclerView . State state , View host , AccessibilityNodeInfoCompat info ) { ViewGroup . LayoutParams lp = host . getLayoutParams ( ) ; if ( ! ( lp instanceof LayoutParams ) ) { super . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; return ; } LayoutParams glp = ( LayoutParams ) lp ; int spanGroupIndex = getSpanGroupIndex ( recycler , state , glp . getViewLayoutPosition ( ) ) ; if ( mOrientation == HORIZONTAL ) { info . setCollectionItemInfo ( AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( glp . getSpanIndex ( ) , glp . getSpanSize ( ) , spanGroupIndex , <NUM_LIT> , false , false ) ) ; } else { info . setCollectionItemInfo ( AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( spanGroupIndex , <NUM_LIT> , glp . getSpanIndex ( ) , glp . getSpanSize ( ) , false , false ) ) ; } } @ Override public void onInitializeAccessibilityNodeInfo ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( recycler , state , info ) ; info . setClassName ( GridView . class . getName ( ) ) ; } @ Override public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( state . isPreLayout ( ) ) { cachePreLayoutSpanMapping ( ) ; } super . onLayoutChildren ( recycler , state ) ; if ( DEBUG ) { validateChildOrder ( ) ; } clearPreLayoutSpanMappingCache ( ) ; } @ Override public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingSpanCountChange = false ; } private void clearPreLayoutSpanMappingCache ( ) { mPreLayoutSpanSizeCache . clear ( ) ; mPreLayoutSpanIndexCache . clear ( ) ; } private void cachePreLayoutSpanMapping ( ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final LayoutParams lp = ( LayoutParams ) getChildAt ( i ) . getLayoutParams ( ) ; final int viewPosition = lp . getViewLayoutPosition ( ) ; mPreLayoutSpanSizeCache . put ( viewPosition , lp . getSpanSize ( ) ) ; mPreLayoutSpanIndexCache . put ( viewPosition , lp . getSpanIndex ( ) ) ; } } @ Override public void onItemsAdded ( RecyclerView recyclerView , int positionStart , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsChanged ( RecyclerView recyclerView ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsRemoved ( RecyclerView recyclerView , int positionStart , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsUpdated ( RecyclerView recyclerView , int positionStart , int itemCount , Object payload ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsMoved ( RecyclerView recyclerView , int from , int to , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { if ( mOrientation == HORIZONTAL ) { return new LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; } else { return new LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } } @ Override public RecyclerView . LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ Override public RecyclerView . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof ViewGroup . MarginLayoutParams ) { return new LayoutParams ( ( ViewGroup . MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ Override public boolean checkLayoutParams ( RecyclerView . LayoutParams lp ) { return lp instanceof LayoutParams ; } public void setSpanSizeLookup ( SpanSizeLookup spanSizeLookup ) { mSpanSizeLookup = spanSizeLookup ; } public SpanSizeLookup getSpanSizeLookup ( ) { return mSpanSizeLookup ; } private void updateMeasurements ( ) { int totalSpace ; if ( getOrientation ( ) == VERTICAL ) { totalSpace = getWidth ( ) - getPaddingRight ( ) - getPaddingLeft ( ) ; } else { totalSpace = getHeight ( ) - getPaddingBottom ( ) - getPaddingTop ( ) ; } calculateItemBorders ( totalSpace ) ; } @ Override public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { if ( mCachedBorders == null ) { super . setMeasuredDimension ( childrenBounds , wSpec , hSpec ) ; } final int width , height ; final int horizontalPadding = getPaddingLeft ( ) + getPaddingRight ( ) ; final int verticalPadding = getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mOrientation == VERTICAL ) { final int usedHeight = childrenBounds . height ( ) + verticalPadding ; height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; width = chooseSize ( wSpec , mCachedBorders [ mCachedBorders . length - <NUM_LIT> ] + horizontalPadding , getMinimumWidth ( ) ) ; } else { final int usedWidth = childrenBounds . width ( ) + horizontalPadding ; width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; height = chooseSize ( hSpec , mCachedBorders [ mCachedBorders . length - <NUM_LIT> ] + verticalPadding , getMinimumHeight ( ) ) ; } setMeasuredDimension ( width , height ) ; } private void calculateItemBorders ( int totalSpace ) { mCachedBorders = calculateItemBorders ( mCachedBorders , mSpanCount , totalSpace ) ; } static int [ ] calculateItemBorders ( int [ ] cachedBorders , int spanCount , int totalSpace ) { if ( cachedBorders == null || cachedBorders . length != spanCount + <NUM_LIT> || cachedBorders [ cachedBorders . length - <NUM_LIT> ] != totalSpace ) { cachedBorders = new int [ spanCount + <NUM_LIT> ] ; } cachedBorders [ <NUM_LIT> ] = <NUM_LIT> ; int sizePerSpan = totalSpace / spanCount ; int sizePerSpanRemainder = totalSpace % spanCount ; int consumedPixels = <NUM_LIT> ; int additionalSize = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i <= spanCount ; i ++ ) { int itemSize = sizePerSpan ; additionalSize += sizePerSpanRemainder ; if ( additionalSize > <NUM_LIT> && ( spanCount - additionalSize ) < sizePerSpanRemainder ) { itemSize += <NUM_LIT> ; additionalSize -= spanCount ; } consumedPixels += itemSize ; cachedBorders [ i ] = consumedPixels ; } return cachedBorders ; } int getSpaceForSpanRange ( int startSpan , int spanSize ) { if ( mOrientation == VERTICAL && isLayoutRTL ( ) ) { return mCachedBorders [ mSpanCount - startSpan ] - mCachedBorders [ mSpanCount - startSpan - spanSize ] ; } else { return mCachedBorders [ startSpan + spanSize ] - mCachedBorders [ startSpan ] ; } } @ Override void onAnchorReady ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int itemDirection ) { super . onAnchorReady ( recycler , state , anchorInfo , itemDirection ) ; updateMeasurements ( ) ; if ( state . getItemCount ( ) > <NUM_LIT> && ! state . isPreLayout ( ) ) { ensureAnchorIsInCorrectSpan ( recycler , state , anchorInfo , itemDirection ) ; } ensureViewSet ( ) ; } private void ensureViewSet ( ) { if ( mSet == null || mSet . length != mSpanCount ) { mSet = new View [ mSpanCount ] ; } } @ Override public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { updateMeasurements ( ) ; ensureViewSet ( ) ; return super . scrollHorizontallyBy ( dx , recycler , state ) ; } @ Override public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { updateMeasurements ( ) ; ensureViewSet ( ) ; return super . scrollVerticallyBy ( dy , recycler , state ) ; } private void ensureAnchorIsInCorrectSpan ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int itemDirection ) { final boolean layingOutInPrimaryDirection = itemDirection == LayoutState . ITEM_DIRECTION_TAIL ; int span = getSpanIndex ( recycler , state , anchorInfo . mPosition ) ; if ( layingOutInPrimaryDirection ) { while ( span > <NUM_LIT> && anchorInfo . mPosition > <NUM_LIT> ) { anchorInfo . mPosition -- ; span = getSpanIndex ( recycler , state , anchorInfo . mPosition ) ; } } else { final int indexLimit = state . getItemCount ( ) - <NUM_LIT> ; int pos = anchorInfo . mPosition ; int bestSpan = span ; while ( pos < indexLimit ) { int next = getSpanIndex ( recycler , state , pos + <NUM_LIT> ) ; if ( next > bestSpan ) { pos += <NUM_LIT> ; bestSpan = next ; } else { break ; } } anchorInfo . mPosition = pos ; } } @ Override View findReferenceChild ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean layoutFromEnd , boolean traverseChildrenInReverseOrder ) { int start = <NUM_LIT> ; int end = getChildCount ( ) ; int diff = <NUM_LIT> ; if ( traverseChildrenInReverseOrder ) { start = getChildCount ( ) - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } int itemCount = state . getItemCount ( ) ; ensureLayoutState ( ) ; View invalidMatch = null ; View outOfBoundsMatch = null ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; for ( int i = start ; i != end ; i += diff ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { final int span = getSpanIndex ( recycler , state , position ) ; if ( span != <NUM_LIT> ) { continue ; } if ( ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . isItemRemoved ( ) ) { if ( invalidMatch == null ) { invalidMatch = view ; } } else if ( mOrientationHelper . getDecoratedStart ( view ) >= boundsEnd || mOrientationHelper . getDecoratedEnd ( view ) < boundsStart ) { if ( outOfBoundsMatch == null ) { outOfBoundsMatch = view ; } } else { return view ; } } } return outOfBoundsMatch != null ? outOfBoundsMatch : invalidMatch ; } private int getSpanGroupIndex ( RecyclerView . Recycler recycler , RecyclerView . State state , int viewPosition ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getCachedSpanGroupIndex ( viewPosition , mSpanCount ) ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( viewPosition ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + viewPosition ) ; } Log . w ( TAG , "<STR_LIT>" + viewPosition ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getCachedSpanGroupIndex ( adapterPosition , mSpanCount ) ; } private int getSpanIndex ( RecyclerView . Recycler recycler , RecyclerView . State state , int pos ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getCachedSpanIndex ( pos , mSpanCount ) ; } final int cached = mPreLayoutSpanIndexCache . get ( pos , - <NUM_LIT> ) ; if ( cached != - <NUM_LIT> ) { return cached ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( pos ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + pos ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + pos ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getCachedSpanIndex ( adapterPosition , mSpanCount ) ; } private int getSpanSize ( RecyclerView . Recycler recycler , RecyclerView . State state , int pos ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getSpanSize ( pos ) ; } final int cached = mPreLayoutSpanSizeCache . get ( pos , - <NUM_LIT> ) ; if ( cached != - <NUM_LIT> ) { return cached ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( pos ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + pos ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + pos ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getSpanSize ( adapterPosition ) ; } @ Override void collectPrefetchPositionsForLayoutState ( RecyclerView . State state , LayoutState layoutState , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int remainingSpan = mSpanCount ; int count = <NUM_LIT> ; while ( count < mSpanCount && layoutState . hasMore ( state ) && remainingSpan > <NUM_LIT> ) { final int pos = layoutState . mCurrentPosition ; layoutPrefetchRegistry . addPosition ( pos , Math . max ( <NUM_LIT> , layoutState . mScrollingOffset ) ) ; final int spanSize = mSpanSizeLookup . getSpanSize ( pos ) ; remainingSpan -= spanSize ; layoutState . mCurrentPosition += layoutState . mItemDirection ; count ++ ; } } @ Override void layoutChunk ( RecyclerView . Recycler recycler , RecyclerView . State state , LayoutState layoutState , LayoutChunkResult result ) { final int otherDirSpecMode = mOrientationHelper . getModeInOther ( ) ; final boolean flexibleInOtherDir = otherDirSpecMode != View . MeasureSpec . EXACTLY ; final int currentOtherDirSize = getChildCount ( ) > <NUM_LIT> ? mCachedBorders [ mSpanCount ] : <NUM_LIT> ; if ( flexibleInOtherDir ) { updateMeasurements ( ) ; } final boolean layingOutInPrimaryDirection = layoutState . mItemDirection == LayoutState . ITEM_DIRECTION_TAIL ; int count = <NUM_LIT> ; int remainingSpan = mSpanCount ; if ( ! layingOutInPrimaryDirection ) { int itemSpanIndex = getSpanIndex ( recycler , state , layoutState . mCurrentPosition ) ; int itemSpanSize = getSpanSize ( recycler , state , layoutState . mCurrentPosition ) ; remainingSpan = itemSpanIndex + itemSpanSize ; } while ( count < mSpanCount && layoutState . hasMore ( state ) && remainingSpan > <NUM_LIT> ) { int pos = layoutState . mCurrentPosition ; final int spanSize = getSpanSize ( recycler , state , pos ) ; if ( spanSize > mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + pos + "<STR_LIT>" + spanSize + "<STR_LIT>" + mSpanCount + "<STR_LIT>" ) ; } remainingSpan -= spanSize ; if ( remainingSpan < <NUM_LIT> ) { break ; } View view = layoutState . next ( recycler ) ; if ( view == null ) { break ; } mSet [ count ] = view ; count ++ ; } if ( count == <NUM_LIT> ) { result . mFinished = true ; return ; } int maxSize = <NUM_LIT> ; float maxSizeInOther = <NUM_LIT> ; assignSpans ( recycler , state , count , layingOutInPrimaryDirection ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; if ( layoutState . mScrapList == null ) { if ( layingOutInPrimaryDirection ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } } else { if ( layingOutInPrimaryDirection ) { addDisappearingView ( view ) ; } else { addDisappearingView ( view , <NUM_LIT> ) ; } } calculateItemDecorationsForChild ( view , mDecorInsets ) ; measureChild ( view , otherDirSpecMode , false ) ; final int size = mOrientationHelper . getDecoratedMeasurement ( view ) ; if ( size > maxSize ) { maxSize = size ; } final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final float otherSize = <NUM_LIT> * mOrientationHelper . getDecoratedMeasurementInOther ( view ) / lp . mSpanSize ; if ( otherSize > maxSizeInOther ) { maxSizeInOther = otherSize ; } } if ( flexibleInOtherDir ) { guessMeasurement ( maxSizeInOther , currentOtherDirSize ) ; maxSize = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; measureChild ( view , View . MeasureSpec . EXACTLY , true ) ; final int size = mOrientationHelper . getDecoratedMeasurement ( view ) ; if ( size > maxSize ) { maxSize = size ; } } } for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mSet [ i ] ; if ( mOrientationHelper . getDecoratedMeasurement ( view ) != maxSize ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect decorInsets = lp . mDecorInsets ; final int verticalInsets = decorInsets . top + decorInsets . bottom + lp . topMargin + lp . bottomMargin ; final int horizontalInsets = decorInsets . left + decorInsets . right + lp . leftMargin + lp . rightMargin ; final int totalSpaceInOther = getSpaceForSpanRange ( lp . mSpanIndex , lp . mSpanSize ) ; final int wSpec ; final int hSpec ; if ( mOrientation == VERTICAL ) { wSpec = getChildMeasureSpec ( totalSpaceInOther , View . MeasureSpec . EXACTLY , horizontalInsets , lp . width , false ) ; hSpec = View . MeasureSpec . makeMeasureSpec ( maxSize - verticalInsets , View . MeasureSpec . EXACTLY ) ; } else { wSpec = View . MeasureSpec . makeMeasureSpec ( maxSize - horizontalInsets , View . MeasureSpec . EXACTLY ) ; hSpec = getChildMeasureSpec ( totalSpaceInOther , View . MeasureSpec . EXACTLY , verticalInsets , lp . height , false ) ; } measureChildWithDecorationsAndMargin ( view , wSpec , hSpec , true ) ; } } result . mConsumed = maxSize ; int left = <NUM_LIT> , right = <NUM_LIT> , top = <NUM_LIT> , bottom = <NUM_LIT> ; if ( mOrientation == VERTICAL ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { bottom = layoutState . mOffset ; top = bottom - maxSize ; } else { top = layoutState . mOffset ; bottom = top + maxSize ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { right = layoutState . mOffset ; left = right - maxSize ; } else { left = layoutState . mOffset ; right = left + maxSize ; } } for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; LayoutParams params = ( LayoutParams ) view . getLayoutParams ( ) ; if ( mOrientation == VERTICAL ) { if ( isLayoutRTL ( ) ) { right = getPaddingLeft ( ) + mCachedBorders [ mSpanCount - params . mSpanIndex ] ; left = right - mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } else { left = getPaddingLeft ( ) + mCachedBorders [ params . mSpanIndex ] ; right = left + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } } else { top = getPaddingTop ( ) + mCachedBorders [ params . mSpanIndex ] ; bottom = top + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } layoutDecoratedWithMargins ( view , left , top , right , bottom ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + getPosition ( view ) + "<STR_LIT>" + ( left + params . leftMargin ) + "<STR_LIT>" + ( top + params . topMargin ) + "<STR_LIT>" + ( right - params . rightMargin ) + "<STR_LIT>" + ( bottom - params . bottomMargin ) + "<STR_LIT>" + params . mSpanIndex + "<STR_LIT>" + params . mSpanSize ) ; } if ( params . isItemRemoved ( ) || params . isItemChanged ( ) ) { result . mIgnoreConsumed = true ; } result . mFocusable |= view . hasFocusable ( ) ; } Arrays . fill ( mSet , null ) ; } private void measureChild ( View view , int otherDirParentSpecMode , boolean alreadyMeasured ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect decorInsets = lp . mDecorInsets ; final int verticalInsets = decorInsets . top + decorInsets . bottom + lp . topMargin + lp . bottomMargin ; final int horizontalInsets = decorInsets . left + decorInsets . right + lp . leftMargin + lp . rightMargin ; final int availableSpaceInOther = getSpaceForSpanRange ( lp . mSpanIndex , lp . mSpanSize ) ; final int wSpec ; final int hSpec ; if ( mOrientation == VERTICAL ) { wSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , horizontalInsets , lp . width , false ) ; hSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getHeightMode ( ) , verticalInsets , lp . height , true ) ; } else { hSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , verticalInsets , lp . height , false ) ; wSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getWidthMode ( ) , horizontalInsets , lp . width , true ) ; } measureChildWithDecorationsAndMargin ( view , wSpec , hSpec , alreadyMeasured ) ; } private void guessMeasurement ( float maxSizeInOther , int currentOtherDirSize ) { final int contentSize = Math . round ( maxSizeInOther * mSpanCount ) ; calculateItemBorders ( Math . max ( contentSize , currentOtherDirSize ) ) ; } private void measureChildWithDecorationsAndMargin ( View child , int widthSpec , int heightSpec , boolean alreadyMeasured ) { RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; final boolean measure ; if ( alreadyMeasured ) { measure = shouldReMeasureChild ( child , widthSpec , heightSpec , lp ) ; } else { measure = shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ; } if ( measure ) { child . measure ( widthSpec , heightSpec ) ; } } private void assignSpans ( RecyclerView . Recycler recycler , RecyclerView . State state , int count , boolean layingOutInPrimaryDirection ) { int span , start , end , diff ; if ( layingOutInPrimaryDirection ) { start = <NUM_LIT> ; end = count ; diff = <NUM_LIT> ; } else { start = count - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } span = <NUM_LIT> ; for ( int i = start ; i != end ; i += diff ) { View view = mSet [ i ] ; LayoutParams params = ( LayoutParams ) view . getLayoutParams ( ) ; params . mSpanSize = getSpanSize ( recycler , state , getPosition ( view ) ) ; params . mSpanIndex = span ; span += params . mSpanSize ; } } public int getSpanCount ( ) { return mSpanCount ; } public void setSpanCount ( int spanCount ) { if ( spanCount == mSpanCount ) { return ; } mPendingSpanCountChange = true ; if ( spanCount < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + spanCount ) ; } mSpanCount = spanCount ; mSpanSizeLookup . invalidateSpanIndexCache ( ) ; requestLayout ( ) ; } public abstract static class SpanSizeLookup { final SparseIntArray mSpanIndexCache = new SparseIntArray ( ) ; final SparseIntArray mSpanGroupIndexCache = new SparseIntArray ( ) ; private boolean mCacheSpanIndices = false ; private boolean mCacheSpanGroupIndices = false ; public abstract int getSpanSize ( int position ) ; public void setSpanIndexCacheEnabled ( boolean cacheSpanIndices ) { if ( ! cacheSpanIndices ) { mSpanGroupIndexCache . clear ( ) ; } mCacheSpanIndices = cacheSpanIndices ; } public void setSpanGroupIndexCacheEnabled ( boolean cacheSpanGroupIndices ) { if ( ! cacheSpanGroupIndices ) { mSpanGroupIndexCache . clear ( ) ; } mCacheSpanGroupIndices = cacheSpanGroupIndices ; } public void invalidateSpanIndexCache ( ) { mSpanIndexCache . clear ( ) ; } public void invalidateSpanGroupIndexCache ( ) { mSpanGroupIndexCache . clear ( ) ; } public boolean isSpanIndexCacheEnabled ( ) { return mCacheSpanIndices ; } public boolean isSpanGroupIndexCacheEnabled ( ) { return mCacheSpanGroupIndices ; } int getCachedSpanIndex ( int position , int spanCount ) { if ( ! mCacheSpanIndices ) { return getSpanIndex ( position , spanCount ) ; } final int existing = mSpanIndexCache . get ( position , - <NUM_LIT> ) ; if ( existing != - <NUM_LIT> ) { return existing ; } final int value = getSpanIndex ( position , spanCount ) ; mSpanIndexCache . put ( position , value ) ; return value ; } int getCachedSpanGroupIndex ( int position , int spanCount ) { if ( ! mCacheSpanGroupIndices ) { return getSpanGroupIndex ( position , spanCount ) ; } final int existing = mSpanGroupIndexCache . get ( position , - <NUM_LIT> ) ; if ( existing != - <NUM_LIT> ) { return existing ; } final int value = getSpanGroupIndex ( position , spanCount ) ; mSpanGroupIndexCache . put ( position , value ) ; return value ; } public int getSpanIndex ( int position , int spanCount ) { int positionSpanSize = getSpanSize ( position ) ; if ( positionSpanSize == spanCount ) { return <NUM_LIT> ; } int span = <NUM_LIT> ; int startPos = <NUM_LIT> ; if ( mCacheSpanIndices ) { int prevKey = findFirstKeyLessThan ( mSpanIndexCache , position ) ; if ( prevKey >= <NUM_LIT> ) { span = mSpanIndexCache . get ( prevKey ) + getSpanSize ( prevKey ) ; startPos = prevKey + <NUM_LIT> ; } } for ( int i = startPos ; i < position ; i ++ ) { int size = getSpanSize ( i ) ; span += size ; if ( span == spanCount ) { span = <NUM_LIT> ; } else if ( span > spanCount ) { span = size ; } } if ( span + positionSpanSize <= spanCount ) { return span ; } return <NUM_LIT> ; } static int findFirstKeyLessThan ( SparseIntArray cache , int position ) { int lo = <NUM_LIT> ; int hi = cache . size ( ) - <NUM_LIT> ; while ( lo <= hi ) { final int mid = ( lo + hi ) > > > <NUM_LIT> ; final int midVal = cache . keyAt ( mid ) ; if ( midVal < position ) { lo = mid + <NUM_LIT> ; } else { hi = mid - <NUM_LIT> ; } } int index = lo - <NUM_LIT> ; if ( index >= <NUM_LIT> && index < cache . size ( ) ) { return cache . keyAt ( index ) ; } return - <NUM_LIT> ; } public int getSpanGroupIndex ( int adapterPosition , int spanCount ) { int span = <NUM_LIT> ; int group = <NUM_LIT> ; int start = <NUM_LIT> ; if ( mCacheSpanGroupIndices ) { int prevKey = findFirstKeyLessThan ( mSpanGroupIndexCache , adapterPosition ) ; if ( prevKey != - <NUM_LIT> ) { group = mSpanGroupIndexCache . get ( prevKey ) ; start = prevKey + <NUM_LIT> ; span = getCachedSpanIndex ( prevKey , spanCount ) + getSpanSize ( prevKey ) ; if ( span == spanCount ) { span = <NUM_LIT> ; group ++ ; } } } int positionSpanSize = getSpanSize ( adapterPosition ) ; for ( int i = start ; i < adapterPosition ; i ++ ) { int size = getSpanSize ( i ) ; span += size ; if ( span == spanCount ) { span = <NUM_LIT> ; group ++ ; } else if ( span > spanCount ) { span = size ; group ++ ; } } if ( span + positionSpanSize > spanCount ) { group ++ ; } return group ; } } @ Override public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { View prevFocusedChild = findContainingItemView ( focused ) ; if ( prevFocusedChild == null ) { return null ; } LayoutParams lp = ( LayoutParams ) prevFocusedChild . getLayoutParams ( ) ; final int prevSpanStart = lp . mSpanIndex ; final int prevSpanEnd = lp . mSpanIndex + lp . mSpanSize ; View view = super . onFocusSearchFailed ( focused , direction , recycler , state ) ; if ( view == null ) { return null ; } final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; final boolean ascend = ( layoutDir == LayoutState . LAYOUT_END ) != mShouldReverseLayout ; final int start , inc , limit ; if ( ascend ) { start = getChildCount ( ) - <NUM_LIT> ; inc = - <NUM_LIT> ; limit = - <NUM_LIT> ; } else { start = <NUM_LIT> ; inc = <NUM_LIT> ; limit = getChildCount ( ) ; } final boolean preferLastSpan = mOrientation == VERTICAL && isLayoutRTL ( ) ; View focusableWeakCandidate = null ; int focusableWeakCandidateSpanIndex = - <NUM_LIT> ; int focusableWeakCandidateOverlap = <NUM_LIT> ; View unfocusableWeakCandidate = null ; int unfocusableWeakCandidateSpanIndex = - <NUM_LIT> ; int unfocusableWeakCandidateOverlap = <NUM_LIT> ; int focusableSpanGroupIndex = getSpanGroupIndex ( recycler , state , start ) ; for ( int i = start ; i != limit ; i += inc ) { int spanGroupIndex = getSpanGroupIndex ( recycler , state , i ) ; View candidate = getChildAt ( i ) ; if ( candidate == prevFocusedChild ) { break ; } if ( candidate . hasFocusable ( ) && spanGroupIndex != focusableSpanGroupIndex ) { if ( focusableWeakCandidate != null ) { break ; } continue ; } final LayoutParams candidateLp = ( LayoutParams ) candidate . getLayoutParams ( ) ; final int candidateStart = candidateLp . mSpanIndex ; final int candidateEnd = candidateLp . mSpanIndex + candidateLp . mSpanSize ; if ( candidate . hasFocusable ( ) && candidateStart == prevSpanStart && candidateEnd == prevSpanEnd ) { return candidate ; } boolean assignAsWeek = false ; if ( ( candidate . hasFocusable ( ) && focusableWeakCandidate == null ) || ( ! candidate . hasFocusable ( ) && unfocusableWeakCandidate == null ) ) { assignAsWeek = true ; } else { int maxStart = Math . max ( candidateStart , prevSpanStart ) ; int minEnd = Math . min ( candidateEnd , prevSpanEnd ) ; int overlap = minEnd - maxStart ; if ( candidate . hasFocusable ( ) ) { if ( overlap > focusableWeakCandidateOverlap ) { assignAsWeek = true ; } else if ( overlap == focusableWeakCandidateOverlap && preferLastSpan == ( candidateStart > focusableWeakCandidateSpanIndex ) ) { assignAsWeek = true ; } } else if ( focusableWeakCandidate == null && isViewPartiallyVisible ( candidate , false , true ) ) { if ( overlap > unfocusableWeakCandidateOverlap ) { assignAsWeek = true ; } else if ( overlap == unfocusableWeakCandidateOverlap && preferLastSpan == ( candidateStart > unfocusableWeakCandidateSpanIndex ) ) { assignAsWeek = true ; } } } if ( assignAsWeek ) { if ( candidate . hasFocusable ( ) ) { focusableWeakCandidate = candidate ; focusableWeakCandidateSpanIndex = candidateLp . mSpanIndex ; focusableWeakCandidateOverlap = Math . min ( candidateEnd , prevSpanEnd ) - Math . max ( candidateStart , prevSpanStart ) ; } else { unfocusableWeakCandidate = candidate ; unfocusableWeakCandidateSpanIndex = candidateLp . mSpanIndex ; unfocusableWeakCandidateOverlap = Math . min ( candidateEnd , prevSpanEnd ) - Math . max ( candidateStart , prevSpanStart ) ; } } } return ( focusableWeakCandidate != null ) ? focusableWeakCandidate : unfocusableWeakCandidate ; } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null && ! mPendingSpanCountChange ; } @ Override public int computeHorizontalScrollRange ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollRangeWithSpanInfo ( state ) ; } else { return super . computeHorizontalScrollRange ( state ) ; } } @ Override public int computeVerticalScrollRange ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollRangeWithSpanInfo ( state ) ; } else { return super . computeVerticalScrollRange ( state ) ; } } @ Override public int computeHorizontalScrollOffset ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollOffsetWithSpanInfo ( state ) ; } else { return super . computeHorizontalScrollOffset ( state ) ; } } @ Override public int computeVerticalScrollOffset ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollOffsetWithSpanInfo ( state ) ; } else { return super . computeVerticalScrollOffset ( state ) ; } } public void setUsingSpansToEstimateScrollbarDimensions ( boolean useSpansToEstimateScrollBarDimensions ) { mUsingSpansToEstimateScrollBarDimensions = useSpansToEstimateScrollBarDimensions ; } public boolean isUsingSpansToEstimateScrollbarDimensions ( ) { return mUsingSpansToEstimateScrollBarDimensions ; } private int computeScrollRangeWithSpanInfo ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; View startChild = findFirstVisibleChildClosestToStart ( ! isSmoothScrollbarEnabled ( ) , true ) ; View endChild = findFirstVisibleChildClosestToEnd ( ! isSmoothScrollbarEnabled ( ) , true ) ; if ( startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! isSmoothScrollbarEnabled ( ) ) { return mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; } final int laidOutArea = mOrientationHelper . getDecoratedEnd ( endChild ) - mOrientationHelper . getDecoratedStart ( startChild ) ; final int firstVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; final int lastVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int totalSpans = mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; final int laidOutSpans = lastVisibleSpan - firstVisibleSpan + <NUM_LIT> ; return ( int ) ( ( ( float ) laidOutArea / laidOutSpans ) * totalSpans ) ; } private int computeScrollOffsetWithSpanInfo ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; boolean smoothScrollEnabled = isSmoothScrollbarEnabled ( ) ; View startChild = findFirstVisibleChildClosestToStart ( ! smoothScrollEnabled , true ) ; View endChild = findFirstVisibleChildClosestToEnd ( ! smoothScrollEnabled , true ) ; if ( startChild == null || endChild == null ) { return <NUM_LIT> ; } int startChildSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; int endChildSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int minSpan = Math . min ( startChildSpan , endChildSpan ) ; final int maxSpan = Math . max ( startChildSpan , endChildSpan ) ; final int totalSpans = mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; final int spansBefore = mShouldReverseLayout ? Math . max ( <NUM_LIT> , totalSpans - maxSpan - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minSpan ) ; if ( ! smoothScrollEnabled ) { return spansBefore ; } final int laidOutArea = Math . abs ( mOrientationHelper . getDecoratedEnd ( endChild ) - mOrientationHelper . getDecoratedStart ( startChild ) ) ; final int firstVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; final int lastVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int laidOutSpans = lastVisibleSpan - firstVisibleSpan + <NUM_LIT> ; final float avgSizePerSpan = ( float ) laidOutArea / laidOutSpans ; return Math . round ( spansBefore * avgSizePerSpan + ( mOrientationHelper . getStartAfterPadding ( ) - mOrientationHelper . getDecoratedStart ( startChild ) ) ) ; } public static final class DefaultSpanSizeLookup extends SpanSizeLookup { @ Override public int getSpanSize ( int position ) { return <NUM_LIT> ; } @ Override public int getSpanIndex ( int position , int spanCount ) { return position % spanCount ; } } public static class LayoutParams extends RecyclerView . LayoutParams { public static final int INVALID_SPAN_ID = - <NUM_LIT> ; int mSpanIndex = INVALID_SPAN_ID ; int mSpanSize = <NUM_LIT> ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( ViewGroup . MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( RecyclerView . LayoutParams source ) { super ( source ) ; } public int getSpanIndex ( ) { return mSpanIndex ; } public int getSpanSize ( ) { return mSpanSize ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } throw new IllegalStateException ( String . format ( Locale . US , "<STR_LIT>" + "<STR_LIT>" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; if ( hasNewTarget ) { dispatchSelected ( target ) ; } } void notifyBeginFakeDrag ( ) { mAdapterState = STATE_IN_PROGRESS_FAKE_DRAG ; startDrag ( true ) ; } void notifyEndFakeDrag ( ) { if ( isDragging ( ) && ! mFakeDragging ) { return ; } mFakeDragging = false ; updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mScrollValues . mPosition != mDragStartPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } else { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; } } void setOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallback = callback ; } int getScrollState ( ) { return mScrollState ; } boolean isIdle ( ) { return mScrollState == SCROLL_STATE_IDLE ; } boolean isDragging ( ) { return mScrollState == SCROLL_STATE_DRAGGING ; } boolean isFakeDragging ( ) { return mFakeDragging ; } private boolean isInAnyDraggingState ( ) { return mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG || mAdapterState == STATE_IN_PROGRESS_FAKE_DRAG ; } double getRelativeScrollPosition ( ) { updateScrollEventValues ( ) ; return mScrollValues . mPosition + ( double ) mScrollValues . mOffset ; } private void dispatchStateChanged ( @ ScrollState int state ) { if ( mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE ) { return ; } if ( mScrollState == state ) { return ; } mScrollState = state ; if ( mCallback != null ) { mCallback . onPageScrollStateChanged ( state ) ; } } private void dispatchSelected ( int target ) { if ( mCallback != null ) { mCallback . onPageSelected ( target ) ; } } private void dispatchScrolled ( int position , float offset , int offsetPx ) { if ( mCallback != null ) { mCallback . onPageScrolled ( position , offset , offsetPx ) ; } } private int getPosition ( ) { return mLayoutManager . findFirstVisibleItemPosition ( ) ; } @ Retention ( SOURCE ) @ IntDef ( { STATE_IDLE , STATE_IN_PROGRESS_MANUAL_DRAG , STATE_IN_PROGRESS_SMOOTH_SCROLL , STATE_IN_PROGRESS_IMMEDIATE_SCROLL , STATE_IN_PROGRESS_FAKE_DRAG } ) private @ interface AdapterState { } private static final class ScrollEventValues { int mPosition ; float mOffset ; int mOffsetPx ; ScrollEventValues ( ) { } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = <NUM_LIT> ; mOffsetPx = <NUM_LIT> ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processPersistent ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void unused ( RecyclerView . ViewHolder holder ) ; } static class InfoRecord { static final int FLAG_DISAPPEARED = <NUM_LIT> ; static final int FLAG_APPEAR = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_PRE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_POST = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_APPEAR_AND_DISAPPEAR = FLAG_APPEAR | FLAG_DISAPPEARED ; static final int FLAG_PRE_AND_POST = FLAG_PRE | FLAG_POST ; static final int FLAG_APPEAR_PRE_AND_POST = FLAG_APPEAR | FLAG_PRE | FLAG_POST ; int flags ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ; static Pools . Pool < InfoRecord > sPool = new Pools . SimplePool < > ( <NUM_LIT> ) ; private InfoRecord ( ) { } static InfoRecord obtain ( ) { InfoRecord record = sPool . acquire ( ) ; return record == null ? new InfoRecord ( ) : record ; } static void recycle ( InfoRecord record ) { record . flags = <NUM_LIT> ; record . preInfo = null ; record . postInfo = null ; sPool . release ( record ) ; } static void drainCache ( ) { while ( sPool . acquire ( ) != null ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( "<STR_LIT>" ) void addTile ( int generation , TileList . Tile < T > tile ) ; void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > { void refresh ( int generation ) ; void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) ; void loadTile ( int position , int scrollHint ) ; @ SuppressLint ( "<STR_LIT>" ) void recycleTile ( TileList . Tile < T > tile ) ; } MainThreadCallback < T > getMainThreadProxy ( MainThreadCallback < T > callback ) ; BackgroundCallback < T > getBackgroundProxy ( BackgroundCallback < T > callback ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( "<STR_LIT>" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } void snapToTargetExistingView ( ) { if ( mRecyclerView == null ) { return ; } RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return ; } View snapView = findSnapView ( layoutManager ) ; if ( snapView == null ) { return ; } int [ ] snapDistance = calculateDistanceToFinalSnap ( layoutManager , snapView ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] ) ; } } @ Nullable protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { return createSnapScroller ( layoutManager ) ; } @ Nullable @ Deprecated protected LinearSmoothScroller createSnapScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { if ( mRecyclerView == null ) { return ; } int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } } ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable public abstract int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) ; @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable @ SuppressLint ( "<STR_LIT>" ) public abstract View findSnapView ( RecyclerView . LayoutManager layoutManager ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; } if ( moveOp . positionStart < addOp . positionStart ) { offset ++ ; } if ( addOp . positionStart <= moveOp . positionStart ) { moveOp . positionStart += addOp . itemCount ; } if ( addOp . positionStart <= moveOp . itemCount ) { moveOp . itemCount += addOp . itemCount ; } addOp . positionStart += offset ; list . set ( move , addOp ) ; list . set ( add , moveOp ) ; } void swapMoveUpdate ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int update , AdapterHelper . UpdateOp updateOp ) { AdapterHelper . UpdateOp extraUp1 = null ; AdapterHelper . UpdateOp extraUp2 = null ; if ( moveOp . itemCount < updateOp . positionStart ) { updateOp . positionStart -- ; } else if ( moveOp . itemCount < updateOp . positionStart + updateOp . itemCount ) { updateOp . itemCount -- ; extraUp1 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart , <NUM_LIT> , updateOp . payload ) ; } if ( moveOp . positionStart <= updateOp . positionStart ) { updateOp . positionStart ++ ; } else if ( moveOp . positionStart < updateOp . positionStart + updateOp . itemCount ) { final int remaining = updateOp . positionStart + updateOp . itemCount - moveOp . positionStart ; extraUp2 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart + <NUM_LIT> , remaining , updateOp . payload ) ; updateOp . itemCount -= remaining ; } list . set ( update , moveOp ) ; if ( updateOp . itemCount > <NUM_LIT> ) { list . set ( move , updateOp ) ; } else { list . remove ( move ) ; mCallback . recycleUpdateOp ( updateOp ) ; } if ( extraUp1 != null ) { list . add ( move , extraUp1 ) ; } if ( extraUp2 != null ) { list . add ( move , extraUp2 ) ; } } private int getLastMoveOutOfOrder ( List < AdapterHelper . UpdateOp > list ) { boolean foundNonMove = false ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final AdapterHelper . UpdateOp op1 = list . get ( i ) ; if ( op1 . cmd == AdapterHelper . UpdateOp . MOVE ) { if ( foundNonMove ) { return i ; } } else { foundNonMove = true ; } } return - <NUM_LIT> ; } interface Callback { AdapterHelper . UpdateOp obtainUpdateOp ( int cmd , int startPosition , int itemCount , Object payload ) ; void recycleUpdateOp ( AdapterHelper . UpdateOp op ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oldHolder + "<STR_LIT>" + newHolder + "<STR_LIT>" + fromX + "<STR_LIT>" + fromY + "<STR_LIT>" + toX + "<STR_LIT>" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) { dispatchAnimationsFinished ( ) ; } } @ Override public void endAnimations ( ) { int count = mPendingMoves . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo item = mPendingMoves . get ( i ) ; View view = item . holder . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item . holder ) ; mPendingMoves . remove ( i ) ; } count = mPendingRemovals . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingRemovals . get ( i ) ; dispatchRemoveFinished ( item ) ; mPendingRemovals . remove ( i ) ; } count = mPendingAdditions . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingAdditions . get ( i ) ; item . itemView . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; mPendingAdditions . remove ( i ) ; } count = mPendingChanges . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { endChangeAnimationIfNecessary ( mPendingChanges . get ( i ) ) ; } mPendingChanges . clear ( ) ; if ( ! isRunning ( ) ) { return ; } int listCount = mMovesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; count = moves . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; RecyclerView . ViewHolder item = moveInfo . holder ; View view = item . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( moveInfo . holder ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( moves ) ; } } } listCount = mAdditionsList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; count = additions . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { RecyclerView . ViewHolder item = additions . get ( j ) ; View view = item . itemView ; view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; additions . remove ( j ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( additions ) ; } } } listCount = mChangesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; count = changes . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { endChangeAnimationIfNecessary ( changes . get ( j ) ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( changes ) ; } } } cancelAll ( mRemoveAnimations ) ; cancelAll ( mMoveAnimations ) ; cancelAll ( mAddAnimations ) ; cancelAll ( mChangeAnimations ) ; dispatchAnimationsFinished ( ) ; } void cancelAll ( List < RecyclerView . ViewHolder > viewHolders ) { for ( int i = viewHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { viewHolders . get ( i ) . itemView . animate ( ) . cancel ( ) ; } } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull List < Object > payloads ) { return ! payloads . isEmpty ( ) || super . canReuseUpdatedViewHolder ( viewHolder , payloads ) ; } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = "<STR_LIT>" ; private static final String KEY_PREFIX_STATE = "<STR_LIT>" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( "<STR_LIT>" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( "<STR_LIT>" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , "<STR_LIT>" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( "<STR_LIT>" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ; mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageScrollStateChanged ( int state ) { updateFragmentMaxLifecycle ( false ) ; } @ Override public void onPageSelected ( int position ) { updateFragmentMaxLifecycle ( false ) ; } } ; mViewPager . registerOnPageChangeCallback ( mPageChangeCallback ) ; mDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updateFragmentMaxLifecycle ( true ) ; } } ; registerAdapterDataObserver ( mDataObserver ) ; mLifecycleObserver = new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { updateFragmentMaxLifecycle ( false ) ; } } ; mLifecycle . addObserver ( mLifecycleObserver ) ; } void unregister ( @ NonNull RecyclerView recyclerView ) { androidx . fluidviewpager2 . widget . ViewPager2 viewPager = inferViewPager ( recyclerView ) ; viewPager . unregisterOnPageChangeCallback ( mPageChangeCallback ) ; unregisterAdapterDataObserver ( mDataObserver ) ; mLifecycle . removeObserver ( mLifecycleObserver ) ; mViewPager = null ; } void updateFragmentMaxLifecycle ( boolean dataSetChanged ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } if ( mViewPager . getScrollState ( ) != androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ) { return ; } if ( mFragments . isEmpty ( ) || getItemCount ( ) == <NUM_LIT> ) { return ; } final int currentItem = mViewPager . getCurrentItem ( ) ; if ( currentItem >= getItemCount ( ) ) { return ; } long currentItemId = getItemId ( currentItem ) ; if ( currentItemId == mPrimaryItemId && ! dataSetChanged ) { return ; } Fragment currentItemFragment = mFragments . get ( currentItemId ) ; if ( currentItemFragment == null || ! currentItemFragment . isAdded ( ) ) { return ; } mPrimaryItemId = currentItemId ; FragmentTransaction transaction = mFragmentManager . beginTransaction ( ) ; Fragment toResume = null ; List < List < OnPostEventListener > > onPost = new ArrayList < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . valueAt ( ix ) ; if ( ! fragment . isAdded ( ) ) { continue ; } if ( itemId != mPrimaryItemId ) { transaction . setMaxLifecycle ( fragment , STARTED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( fragment , STARTED ) ) ; } else { toResume = fragment ; } fragment . setMenuVisibility ( itemId == mPrimaryItemId ) ; } if ( toResume != null ) { transaction . setMaxLifecycle ( toResume , RESUMED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( toResume , RESUMED ) ) ; } if ( ! transaction . isEmpty ( ) ) { transaction . commitNow ( ) ; Collections . reverse ( onPost ) ; for ( List < OnPostEventListener > event : onPost ) { mFragmentEventDispatcher . dispatchPostEvents ( event ) ; } } } @ NonNull private androidx . fluidviewpager2 . widget . ViewPager2 inferViewPager ( @ NonNull RecyclerView recyclerView ) { ViewParent parent = recyclerView . getParent ( ) ; if ( parent instanceof androidx . fluidviewpager2 . widget . ViewPager2 ) { return ( ViewPager2 ) parent ; } throw new IllegalStateException ( "<STR_LIT>" + parent ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) { int previousEnd = mLastEventPosition + mLastEventCount ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; mLastEventCount = Math . max ( previousEnd , position + count ) - mLastEventPosition ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventPayload = payload ; mLastEventType = TYPE_CHANGE ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ; mTrackingListeners . clear ( ) ; mInterceptingListener = listener ; return true ; } else { mTrackingListeners . add ( listener ) ; } } return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { if ( mInterceptingListener == null ) { return ; } mInterceptingListener . onTouchEvent ( recyclerView , event ) ; int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingListener = null ; } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { for ( OnItemTouchListener listener : mListeners ) { listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ; } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( "<STR_LIT>" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + oldHolder + "<STR_LIT>" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( "<STR_LIT>" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeFinished ( item , oldItem ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchRemoveStarting ( RecyclerView . ViewHolder item ) { onRemoveStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchMoveStarting ( RecyclerView . ViewHolder item ) { onMoveStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchAddStarting ( RecyclerView . ViewHolder item ) { onAddStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeStarting ( item , oldItem ) ; } @ SuppressLint ( "<STR_LIT>" ) @ SuppressWarnings ( "<STR_LIT>" ) public void onRemoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onRemoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public void onAddStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onAddFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public void onMoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onMoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) @ SuppressWarnings ( "<STR_LIT>" ) public void onChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { } @ SuppressLint ( "<STR_LIT>" ) public void onChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; } @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { NestedAdapterWrapper wrapper = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( wrapper == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + globalViewType ) ; } return wrapper ; } @ Override @ NonNull public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { NestedAdapterWrapper existingWrapper = mGlobalTypeToWrapper . valueAt ( i ) ; if ( existingWrapper == wrapper ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } class WrapperViewTypeLookup implements ViewTypeLookup { private SparseIntArray mLocalToGlobalMapping = new SparseIntArray ( <NUM_LIT> ) ; private SparseIntArray mGlobalToLocalMapping = new SparseIntArray ( <NUM_LIT> ) ; final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { int index = mLocalToGlobalMapping . indexOfKey ( localType ) ; if ( index > - <NUM_LIT> ) { return mLocalToGlobalMapping . valueAt ( index ) ; } int globalType = obtainViewType ( mWrapper ) ; mLocalToGlobalMapping . put ( localType , globalType ) ; mGlobalToLocalMapping . put ( globalType , localType ) ; return globalType ; } @ Override public int globalToLocal ( int globalType ) { int index = mGlobalToLocalMapping . indexOfKey ( globalType ) ; if ( index < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + globalType + "<STR_LIT>" + "<STR_LIT>" + mWrapper . adapter ) ; } return mGlobalToLocalMapping . valueAt ( index ) ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; } offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) { return null ; } LinearLayoutManager linearLayoutManager = ( LinearLayoutManager ) layoutManager ; if ( linearLayoutManager . getOrientation ( ) != RecyclerView . VERTICAL ) { return null ; } return linearLayoutManager ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( "<STR_LIT>" ) final Callback mCallback ; @ SuppressWarnings ( "<STR_LIT>" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , "<STR_LIT>" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) { adapter . bindViewHolder ( viewHolder , localPosition ) ; } public long getItemId ( int localPosition ) { long localItemId = adapter . getItemId ( localPosition ) ; return mStableIdLookup . localToGlobal ( localItemId ) ; } interface Callback { void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) ; void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) ; void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) { return mItemDecoration ; } public State getState ( ) { return mState ; } @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { mState = state ; } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { mItemDecoration . getItemOffsets ( outRect , itemPosition , parent ) ; } @ Override public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) { mItemDecoration . getItemOffsets ( outRect , view , parent , state ) ; } } } </s>
<s> package com . google . android . material . slider ; import static androidx . core . math . MathUtils . clamp ; import static androidx . core . view . accessibility . AccessibilityNodeInfoCompat . RangeInfoCompat . RANGE_TYPE_FLOAT ; import static com . google . android . material . slider . LabelFormatter . LABEL_FLOATING ; import static com . google . android . material . slider . LabelFormatter . LABEL_GONE ; import static com . google . android . material . slider . LabelFormatter . LABEL_VISIBLE ; import static com . google . android . material . slider . LabelFormatter . LABEL_WITHIN_BOUNDS ; import static com . google . android . material . theme . overlay . MaterialThemeOverlay . wrap ; import static java . lang . Float . compare ; import static java . lang . Math . abs ; import static java . lang . Math . max ; import static java . lang . Math . min ; import static java . util . Collections . max ; import static java . util . Collections . min ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . graphics . Paint . Cap ; import android . graphics . Paint . Style ; import android . graphics . Path ; import android . graphics . PorterDuff . Mode ; import android . graphics . PorterDuffXfermode ; import android . graphics . Rect ; import android . graphics . RectF ; import android . graphics . Region . Op ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . RippleDrawable ; import android . os . Build . VERSION ; import android . os . Build . VERSION_CODES ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityManager ; import android . widget . SeekBar ; import androidx . annotation . ColorInt ; import androidx . annotation . ColorRes ; import androidx . annotation . DimenRes ; import androidx . annotation . Dimension ; import androidx . annotation . DrawableRes ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . content . ContextCompat ; import androidx . core . graphics . drawable . DrawableCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat . RangeInfoCompat ; import androidx . customview . widget . ExploreByTouchHelper ; import com . google . android . material . R ; import com . google . android . material . animation . AnimationUtils ; import com . google . android . material . drawable . DrawableUtils ; import com . google . android . material . internal . DescendantOffsetUtils ; import com . google . android . material . internal . ThemeEnforcement ; import com . google . android . material . internal . ViewOverlayImpl ; import com . google . android . material . internal . ViewUtils ; import com . google . android . material . motion . MotionUtils ; import com . google . android . material . resources . MaterialResources ; import com . google . android . material . shape . CornerFamily ; import com . google . android . material . shape . MaterialShapeDrawable ; import com . google . android . material . shape . ShapeAppearanceModel ; import com . google . android . material . tooltip . TooltipDrawable ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . math . BigDecimal ; import java . math . MathContext ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; @ SuppressLint ( "<STR_LIT>" ) abstract class BaseOverlaySlider < S extends BaseOverlaySlider < S , L , T > , L extends BaseOnChangeListener < S > , T extends BaseOnSliderTouchListener < S > > extends View { static final int DEF_STYLE_RES = R . style . Widget_MaterialComponents_Slider ; static final int UNIT_VALUE = <NUM_LIT> ; static final int UNIT_PX = <NUM_LIT> ; private static final String TAG = BaseOverlaySlider . class . getSimpleName ( ) ; private static final String EXCEPTION_ILLEGAL_VALUE = "<STR_LIT>" + "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_DISCRETE_VALUE = "<STR_LIT>" + "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_VALUE_FROM = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_VALUE_TO = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_STEP_SIZE = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE_UNIT = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE = "<STR_LIT>" + "<STR_LIT>" ; private static final String WARNING_FLOATING_POINT_ERROR = "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; private static final int TIMEOUT_SEND_ACCESSIBILITY_EVENT = <NUM_LIT> ; private static final int HALO_ALPHA = <NUM_LIT> ; private static final double THRESHOLD = <NUM_LIT> ; private static final int DEFAULT_LABEL_ANIMATION_ENTER_DURATION = <NUM_LIT> ; private static final int DEFAULT_LABEL_ANIMATION_EXIT_DURATION = <NUM_LIT> ; private static final int LABEL_ANIMATION_ENTER_DURATION_ATTR = R . attr . motionDurationMedium4 ; private static final int LABEL_ANIMATION_EXIT_DURATION_ATTR = R . attr . motionDurationShort3 ; private static final int LABEL_ANIMATION_ENTER_EASING_ATTR = R . attr . motionEasingEmphasizedInterpolator ; private static final int LABEL_ANIMATION_EXIT_EASING_ATTR = R . attr . motionEasingEmphasizedAccelerateInterpolator ; @ Dimension private static final int MIN_TOUCH_TARGET_DP = <NUM_LIT> ; @ NonNull private final Paint inactiveTrackPaint ; @ NonNull private final Paint inactiveTrackPaintUnder ; @ NonNull private final Paint activeTrackPaint ; @ NonNull private final Paint activeTrackPaintUnder ; @ NonNull private final Paint thumbPaint ; @ NonNull private final Paint haloPaint ; @ NonNull private final Paint inactiveTicksPaint ; @ NonNull private final Paint activeTicksPaint ; @ NonNull private final AccessibilityHelper accessibilityHelper ; private final AccessibilityManager accessibilityManager ; @ NonNull private final List < TooltipDrawable > labels = new ArrayList < > ( ) ; @ NonNull private final List < L > changeListeners = new ArrayList < > ( ) ; @ NonNull private final List < T > touchListeners = new ArrayList < > ( ) ; private final int scaledTouchSlop ; @ NonNull private final MaterialShapeDrawable defaultThumbDrawable = new MaterialShapeDrawable ( ) ; private AccessibilityEventSender accessibilityEventSender ; private int labelStyle ; private boolean labelsAreAnimatedIn = false ; private ValueAnimator labelsInAnimator ; private ValueAnimator labelsOutAnimator ; private int minTrackSidePadding ; private int defaultThumbRadius ; private int defaultTrackHeight ; private int defaultTickActiveRadius ; private int defaultTickInactiveRadius ; @ Dimension ( unit = Dimension . PX ) private int minTouchTargetSize ; private int minWidgetHeight ; private int widgetHeight ; private int labelBehavior ; private int trackHeight ; private int trackSidePadding ; private int thumbRadius ; private int haloRadius ; private RectF boundRectF = new RectF ( ) ; private Path boundPath = new Path ( ) ; private int labelPadding ; private float touchDownX ; private MotionEvent lastEvent ; private LabelFormatter formatter ; private boolean thumbIsPressed = false ; private float valueFrom ; private float valueTo ; private ArrayList < Float > values = new ArrayList < > ( ) ; private int activeThumbIdx = - <NUM_LIT> ; private int focusedThumbIdx = - <NUM_LIT> ; private float stepSize = <NUM_LIT> ; private float [ ] ticksCoordinates ; private boolean tickVisible = true ; private int tickActiveRadius ; private int tickInactiveRadius ; private int trackWidth ; private boolean forceDrawCompatHalo ; private boolean isLongPress = false ; private boolean dirtyConfig ; @ NonNull private ColorStateList haloColor ; @ NonNull private ColorStateList tickColorActive ; @ NonNull private ColorStateList tickColorInactive ; @ NonNull private ColorStateList trackColorActive ; @ NonNull private ColorStateList trackColorInactive ; @ Nullable private Drawable customThumbDrawable ; @ NonNull private List < Drawable > customThumbDrawablesForValues = Collections . emptyList ( ) ; private float touchPosition ; @ SeparationUnit private int separationUnit = UNIT_PX ; public BaseOverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public BaseOverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public BaseOverlaySlider ( @ NonNull Context context , @ Nullable final AttributeSet attrs , final int defStyleAttr ) { super ( wrap ( context , attrs , defStyleAttr , DEF_STYLE_RES ) , attrs , defStyleAttr ) ; context = getContext ( ) ; inactiveTrackPaintUnder = new Paint ( ) ; inactiveTrackPaintUnder . setXfermode ( new PorterDuffXfermode ( Mode . OVERLAY ) ) ; inactiveTrackPaintUnder . setStyle ( Style . STROKE ) ; inactiveTrackPaintUnder . setColor ( ContextCompat . getColor ( context , org . akanework . gramophone . R . color . contrast_secondaryOverlayColor ) ) ; inactiveTrackPaint = new Paint ( ) ; inactiveTrackPaint . setStyle ( Style . STROKE ) ; activeTrackPaintUnder = new Paint ( ) ; activeTrackPaintUnder . setXfermode ( new PorterDuffXfermode ( Mode . OVERLAY ) ) ; activeTrackPaintUnder . setStyle ( Style . STROKE ) ; activeTrackPaintUnder . setColor ( ContextCompat . getColor ( context , org . akanework . gramophone . R . color . contrast_primaryOverlayColor ) ) ; activeTrackPaint = new Paint ( ) ; activeTrackPaint . setStyle ( Style . STROKE ) ; thumbPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; thumbPaint . setStyle ( Style . FILL ) ; thumbPaint . setXfermode ( new PorterDuffXfermode ( Mode . CLEAR ) ) ; haloPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; haloPaint . setStyle ( Style . FILL ) ; inactiveTicksPaint = new Paint ( ) ; inactiveTicksPaint . setStyle ( Style . STROKE ) ; inactiveTicksPaint . setStrokeCap ( Cap . ROUND ) ; activeTicksPaint = new Paint ( ) ; activeTicksPaint . setStyle ( Style . STROKE ) ; activeTicksPaint . setStrokeCap ( Cap . ROUND ) ; loadResources ( context . getResources ( ) ) ; processAttributes ( context , attrs , defStyleAttr ) ; setFocusable ( true ) ; setClickable ( true ) ; defaultThumbDrawable . setShadowCompatibilityMode ( MaterialShapeDrawable . SHADOW_COMPAT_MODE_ALWAYS ) ; scaledTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; accessibilityHelper = new AccessibilityHelper ( this ) ; ViewCompat . setAccessibilityDelegate ( this , accessibilityHelper ) ; accessibilityManager = ( AccessibilityManager ) getContext ( ) . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; } private static int pivotIndex ( float [ ] coordinates , float position ) { return Math . round ( position * ( coordinates . length / <NUM_LIT> - <NUM_LIT> ) ) ; } private static float getAnimatorCurrentValueOrDefault ( ValueAnimator animator , float defaultValue ) { if ( animator != null && animator . isRunning ( ) ) { float value = ( float ) animator . getAnimatedValue ( ) ; animator . cancel ( ) ; return value ; } return defaultValue ; } private static boolean isMouseEvent ( MotionEvent event ) { return event . getToolType ( <NUM_LIT> ) == MotionEvent . TOOL_TYPE_MOUSE ; } private void loadResources ( @ NonNull Resources resources ) { minWidgetHeight = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_widget_height ) ; minTrackSidePadding = resources . getDimensionPixelOffset ( R . dimen . mtrl_slider_track_side_padding ) ; trackSidePadding = minTrackSidePadding ; defaultThumbRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_thumb_radius ) ; defaultTrackHeight = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_track_height ) ; defaultTickActiveRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_tick_radius ) ; defaultTickInactiveRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_tick_radius ) ; labelPadding = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_label_padding ) ; } private void processAttributes ( Context context , AttributeSet attrs , int defStyleAttr ) { TypedArray a = ThemeEnforcement . obtainStyledAttributes ( context , attrs , R . styleable . Slider , defStyleAttr , DEF_STYLE_RES ) ; labelStyle = a . getResourceId ( R . styleable . Slider_labelStyle , R . style . Widget_MaterialComponents_Tooltip ) ; valueFrom = a . getFloat ( R . styleable . Slider_android_valueFrom , <NUM_LIT> ) ; valueTo = a . getFloat ( R . styleable . Slider_android_valueTo , <NUM_LIT> ) ; setValues ( valueFrom ) ; stepSize = a . getFloat ( R . styleable . Slider_android_stepSize , <NUM_LIT> ) ; @ SuppressLint ( "<STR_LIT>" ) float defaultMinTouchTargetSize = ( float ) Math . ceil ( ViewUtils . dpToPx ( getContext ( ) , MIN_TOUCH_TARGET_DP ) ) ; minTouchTargetSize = ( int ) Math . ceil ( a . getDimension ( R . styleable . Slider_minTouchTargetSize , defaultMinTouchTargetSize ) ) ; boolean hasTrackColor = a . hasValue ( R . styleable . Slider_trackColor ) ; int trackColorInactiveRes = hasTrackColor ? R . styleable . Slider_trackColor : R . styleable . Slider_trackColorInactive ; int trackColorActiveRes = hasTrackColor ? R . styleable . Slider_trackColor : R . styleable . Slider_trackColorActive ; ColorStateList trackColorInactive = MaterialResources . getColorStateList ( context , a , trackColorInactiveRes ) ; setTrackInactiveTintList ( trackColorInactive != null ? trackColorInactive : AppCompatResources . getColorStateList ( context , R . color . material_slider_inactive_track_color ) ) ; ColorStateList trackColorActive = MaterialResources . getColorStateList ( context , a , trackColorActiveRes ) ; setTrackActiveTintList ( trackColorActive != null ? trackColorActive : AppCompatResources . getColorStateList ( context , R . color . material_slider_active_track_color ) ) ; ColorStateList thumbColor = MaterialResources . getColorStateList ( context , a , R . styleable . Slider_thumbColor ) ; defaultThumbDrawable . setFillColor ( thumbColor ) ; if ( a . hasValue ( R . styleable . Slider_thumbStrokeColor ) ) { setThumbStrokeColor ( MaterialResources . getColorStateList ( context , a , R . styleable . Slider_thumbStrokeColor ) ) ; } setThumbStrokeWidth ( a . getDimension ( R . styleable . Slider_thumbStrokeWidth , <NUM_LIT> ) ) ; ColorStateList haloColor = MaterialResources . getColorStateList ( context , a , R . styleable . Slider_haloColor ) ; setHaloTintList ( haloColor != null ? haloColor : AppCompatResources . getColorStateList ( context , R . color . material_slider_halo_color ) ) ; tickVisible = a . getBoolean ( R . styleable . Slider_tickVisible , true ) ; boolean hasTickColor = a . hasValue ( R . styleable . Slider_tickColor ) ; int tickColorInactiveRes = hasTickColor ? R . styleable . Slider_tickColor : R . styleable . Slider_tickColorInactive ; int tickColorActiveRes = hasTickColor ? R . styleable . Slider_tickColor : R . styleable . Slider_tickColorActive ; ColorStateList tickColorInactive = MaterialResources . getColorStateList ( context , a , tickColorInactiveRes ) ; setTickInactiveTintList ( tickColorInactive != null ? tickColorInactive : AppCompatResources . getColorStateList ( context , R . color . material_slider_inactive_tick_marks_color ) ) ; ColorStateList tickColorActive = MaterialResources . getColorStateList ( context , a , tickColorActiveRes ) ; setTickActiveTintList ( tickColorActive != null ? tickColorActive : AppCompatResources . getColorStateList ( context , R . color . material_slider_active_tick_marks_color ) ) ; setThumbRadius ( a . getDimensionPixelSize ( R . styleable . Slider_thumbRadius , <NUM_LIT> ) ) ; setHaloRadius ( a . getDimensionPixelSize ( R . styleable . Slider_haloRadius , <NUM_LIT> ) ) ; setThumbElevation ( a . getDimension ( R . styleable . Slider_thumbElevation , <NUM_LIT> ) ) ; setTrackHeight ( a . getDimensionPixelSize ( R . styleable . Slider_trackHeight , <NUM_LIT> ) ) ; setTickActiveRadius ( a . getDimensionPixelSize ( R . styleable . Slider_tickRadiusActive , <NUM_LIT> ) ) ; setTickInactiveRadius ( a . getDimensionPixelSize ( R . styleable . Slider_tickRadiusInactive , <NUM_LIT> ) ) ; setLabelBehavior ( a . getInt ( R . styleable . Slider_labelBehavior , LABEL_FLOATING ) ) ; if ( ! a . getBoolean ( R . styleable . Slider_android_enabled , true ) ) { setEnabled ( false ) ; } a . recycle ( ) ; } private boolean maybeIncreaseTrackSidePadding ( ) { int increasedSidePaddingByThumb = max ( thumbRadius - defaultThumbRadius , <NUM_LIT> ) ; int increasedSidePaddingByTrack = max ( ( trackHeight - defaultTrackHeight ) / <NUM_LIT> , <NUM_LIT> ) ; int increasedSidePaddingByActiveTick = max ( tickActiveRadius - defaultTickActiveRadius , <NUM_LIT> ) ; int increasedSidePaddingByInactiveTick = max ( tickInactiveRadius - defaultTickInactiveRadius , <NUM_LIT> ) ; int newTrackSidePadding = minTrackSidePadding + max ( max ( increasedSidePaddingByThumb , increasedSidePaddingByTrack ) , max ( increasedSidePaddingByActiveTick , increasedSidePaddingByInactiveTick ) ) ; if ( trackSidePadding == newTrackSidePadding ) { return false ; } trackSidePadding = newTrackSidePadding ; if ( ViewCompat . isLaidOut ( this ) ) { updateTrackWidth ( getWidth ( ) ) ; } return true ; } private void validateValueFrom ( ) { if ( valueFrom >= valueTo ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE_FROM , valueFrom , valueTo ) ) ; } } private void validateValueTo ( ) { if ( valueTo <= valueFrom ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE_TO , valueTo , valueFrom ) ) ; } } private boolean valueLandsOnTick ( float value ) { return isMultipleOfStepSize ( value - valueFrom ) ; } private boolean isMultipleOfStepSize ( float value ) { double result = new BigDecimal ( Float . toString ( value ) ) . divide ( new BigDecimal ( Float . toString ( stepSize ) ) , MathContext . DECIMAL64 ) . doubleValue ( ) ; return Math . abs ( Math . round ( result ) - result ) < THRESHOLD ; } private void validateStepSize ( ) { if ( stepSize > <NUM_LIT> && ! valueLandsOnTick ( valueTo ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_STEP_SIZE , stepSize , valueFrom , valueTo ) ) ; } } private void validateValues ( ) { for ( Float value : values ) { if ( value < valueFrom || value > valueTo ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE , value , valueFrom , valueTo ) ) ; } if ( stepSize > <NUM_LIT> && ! valueLandsOnTick ( value ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_DISCRETE_VALUE , value , valueFrom , stepSize , stepSize ) ) ; } } } private void validateMinSeparation ( ) { final float minSeparation = getMinSeparation ( ) ; if ( minSeparation < <NUM_LIT> ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION , minSeparation ) ) ; } if ( stepSize > <NUM_LIT> && minSeparation > <NUM_LIT> ) { if ( separationUnit != UNIT_VALUE ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE_UNIT , minSeparation , stepSize ) ) ; } if ( minSeparation < stepSize || ! isMultipleOfStepSize ( minSeparation ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE , minSeparation , stepSize , stepSize ) ) ; } } } private void warnAboutFloatingPointError ( ) { if ( stepSize == <NUM_LIT> ) { return ; } if ( ( int ) stepSize != stepSize ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , stepSize ) ) ; } if ( ( int ) valueFrom != valueFrom ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , valueFrom ) ) ; } if ( ( int ) valueTo != valueTo ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , valueTo ) ) ; } } private void validateConfigurationIfDirty ( ) { if ( dirtyConfig ) { validateValueFrom ( ) ; validateValueTo ( ) ; validateStepSize ( ) ; validateValues ( ) ; validateMinSeparation ( ) ; warnAboutFloatingPointError ( ) ; dirtyConfig = false ; } } public float getValueFrom ( ) { return valueFrom ; } public void setValueFrom ( float valueFrom ) { this . valueFrom = valueFrom ; dirtyConfig = true ; postInvalidate ( ) ; } public float getValueTo ( ) { return valueTo ; } public void setValueTo ( float valueTo ) { this . valueTo = valueTo ; dirtyConfig = true ; postInvalidate ( ) ; } @ NonNull List < Float > getValues ( ) { return new ArrayList < > ( values ) ; } void setValues ( @ NonNull Float ... values ) { ArrayList < Float > list = new ArrayList < > ( ) ; Collections . addAll ( list , values ) ; setValuesInternal ( list ) ; } void setValues ( @ NonNull List < Float > values ) { setValuesInternal ( new ArrayList < > ( values ) ) ; } private void setValuesInternal ( @ NonNull ArrayList < Float > values ) { if ( values . isEmpty ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } Collections . sort ( values ) ; if ( this . values . size ( ) == values . size ( ) ) { if ( this . values . equals ( values ) ) { return ; } } this . values = values ; dirtyConfig = true ; focusedThumbIdx = <NUM_LIT> ; updateHaloHotspot ( ) ; createLabelPool ( ) ; dispatchOnChangedProgrammatically ( ) ; postInvalidate ( ) ; } private void createLabelPool ( ) { if ( labels . size ( ) > values . size ( ) ) { List < TooltipDrawable > tooltipDrawables = labels . subList ( values . size ( ) , labels . size ( ) ) ; for ( TooltipDrawable label : tooltipDrawables ) { if ( ViewCompat . isAttachedToWindow ( this ) ) { detachLabelFromContentView ( label ) ; } } tooltipDrawables . clear ( ) ; } while ( labels . size ( ) < values . size ( ) ) { TooltipDrawable tooltipDrawable = TooltipDrawable . createFromAttributes ( getContext ( ) , null , <NUM_LIT> , labelStyle ) ; labels . add ( tooltipDrawable ) ; if ( ViewCompat . isAttachedToWindow ( this ) ) { attachLabelToContentView ( tooltipDrawable ) ; } } int strokeWidth = labels . size ( ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; for ( TooltipDrawable label : labels ) { label . setStrokeWidth ( strokeWidth ) ; } } public float getStepSize ( ) { return stepSize ; } public void setStepSize ( float stepSize ) { if ( stepSize < <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( EXCEPTION_ILLEGAL_STEP_SIZE , stepSize , valueFrom , valueTo ) ) ; } if ( this . stepSize != stepSize ) { this . stepSize = stepSize ; dirtyConfig = true ; postInvalidate ( ) ; } } void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { setCustomThumbDrawable ( getResources ( ) . getDrawable ( drawableResId ) ) ; } void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { customThumbDrawable = initializeCustomThumbDrawable ( drawable ) ; customThumbDrawablesForValues . clear ( ) ; postInvalidate ( ) ; } void setCustomThumbDrawablesForValues ( @ NonNull @ DrawableRes int ... customThumbDrawableResIds ) { Drawable [ ] customThumbDrawables = new Drawable [ customThumbDrawableResIds . length ] ; for ( int i = <NUM_LIT> ; i < customThumbDrawableResIds . length ; i ++ ) { customThumbDrawables [ i ] = getResources ( ) . getDrawable ( customThumbDrawableResIds [ i ] ) ; } setCustomThumbDrawablesForValues ( customThumbDrawables ) ; } void setCustomThumbDrawablesForValues ( @ NonNull Drawable ... customThumbDrawables ) { this . customThumbDrawable = null ; this . customThumbDrawablesForValues = new ArrayList < > ( ) ; for ( Drawable originalDrawable : customThumbDrawables ) { this . customThumbDrawablesForValues . add ( initializeCustomThumbDrawable ( originalDrawable ) ) ; } postInvalidate ( ) ; } private Drawable initializeCustomThumbDrawable ( Drawable originalDrawable ) { Drawable drawable = originalDrawable . mutate ( ) . getConstantState ( ) . newDrawable ( ) ; adjustCustomThumbDrawableBounds ( drawable ) ; return drawable ; } private void adjustCustomThumbDrawableBounds ( Drawable drawable ) { int thumbDiameter = thumbRadius * <NUM_LIT> ; int originalWidth = drawable . getIntrinsicWidth ( ) ; int originalHeight = drawable . getIntrinsicHeight ( ) ; if ( originalWidth == - <NUM_LIT> && originalHeight == - <NUM_LIT> ) { drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , thumbDiameter , thumbDiameter ) ; } else { float scaleRatio = ( float ) thumbDiameter / max ( originalWidth , originalHeight ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( originalWidth * scaleRatio ) , ( int ) ( originalHeight * scaleRatio ) ) ; } } public int getFocusedThumbIndex ( ) { return focusedThumbIdx ; } public void setFocusedThumbIndex ( int index ) { if ( index < <NUM_LIT> || index >= values . size ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } focusedThumbIdx = index ; accessibilityHelper . requestKeyboardFocusForVirtualView ( focusedThumbIdx ) ; postInvalidate ( ) ; } public int getActiveThumbIndex ( ) { return activeThumbIdx ; } protected void setActiveThumbIndex ( int index ) { activeThumbIdx = index ; } public void addOnChangeListener ( @ NonNull L listener ) { changeListeners . add ( listener ) ; } public void removeOnChangeListener ( @ NonNull L listener ) { changeListeners . remove ( listener ) ; } public void clearOnChangeListeners ( ) { changeListeners . clear ( ) ; } public void addOnSliderTouchListener ( @ NonNull T listener ) { touchListeners . add ( listener ) ; } public void removeOnSliderTouchListener ( @ NonNull T listener ) { touchListeners . remove ( listener ) ; } public void clearOnSliderTouchListeners ( ) { touchListeners . clear ( ) ; } public boolean hasLabelFormatter ( ) { return formatter != null ; } public void setLabelFormatter ( @ Nullable LabelFormatter formatter ) { this . formatter = formatter ; } public float getThumbElevation ( ) { return defaultThumbDrawable . getElevation ( ) ; } public void setThumbElevation ( float elevation ) { defaultThumbDrawable . setElevation ( elevation ) ; } public void setThumbElevationResource ( @ DimenRes int elevation ) { setThumbElevation ( getResources ( ) . getDimension ( elevation ) ) ; } @ Dimension public int getThumbRadius ( ) { return thumbRadius ; } public void setThumbRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int radius ) { if ( radius == thumbRadius ) { return ; } thumbRadius = radius ; defaultThumbDrawable . setShapeAppearanceModel ( ShapeAppearanceModel . builder ( ) . setAllCorners ( CornerFamily . ROUNDED , thumbRadius ) . build ( ) ) ; defaultThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , thumbRadius * <NUM_LIT> , thumbRadius * <NUM_LIT> ) ; if ( customThumbDrawable != null ) { adjustCustomThumbDrawableBounds ( customThumbDrawable ) ; } for ( Drawable customDrawable : customThumbDrawablesForValues ) { adjustCustomThumbDrawableBounds ( customDrawable ) ; } updateWidgetLayout ( ) ; } public void setThumbRadiusResource ( @ DimenRes int radius ) { setThumbRadius ( getResources ( ) . getDimensionPixelSize ( radius ) ) ; } public void setThumbStrokeColorResource ( @ ColorRes int thumbStrokeColorResourceId ) { if ( thumbStrokeColorResourceId != <NUM_LIT> ) { setThumbStrokeColor ( AppCompatResources . getColorStateList ( getContext ( ) , thumbStrokeColorResourceId ) ) ; } } public ColorStateList getThumbStrokeColor ( ) { return defaultThumbDrawable . getStrokeColor ( ) ; } public void setThumbStrokeColor ( @ Nullable ColorStateList thumbStrokeColor ) { defaultThumbDrawable . setStrokeColor ( thumbStrokeColor ) ; postInvalidate ( ) ; } public void setThumbStrokeWidthResource ( @ DimenRes int thumbStrokeWidthResourceId ) { if ( thumbStrokeWidthResourceId != <NUM_LIT> ) { setThumbStrokeWidth ( getResources ( ) . getDimension ( thumbStrokeWidthResourceId ) ) ; } } public float getThumbStrokeWidth ( ) { return defaultThumbDrawable . getStrokeWidth ( ) ; } public void setThumbStrokeWidth ( float thumbStrokeWidth ) { defaultThumbDrawable . setStrokeWidth ( thumbStrokeWidth ) ; postInvalidate ( ) ; } @ Dimension ( ) public int getHaloRadius ( ) { return haloRadius ; } public void setHaloRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int radius ) { if ( radius == haloRadius ) { return ; } haloRadius = radius ; Drawable background = getBackground ( ) ; if ( ! shouldDrawCompatHalo ( ) && background instanceof RippleDrawable ) { DrawableUtils . setRippleDrawableRadius ( ( RippleDrawable ) background , haloRadius ) ; return ; } postInvalidate ( ) ; } public void setHaloRadiusResource ( @ DimenRes int radius ) { setHaloRadius ( getResources ( ) . getDimensionPixelSize ( radius ) ) ; } @ LabelBehavior public int getLabelBehavior ( ) { return labelBehavior ; } public void setLabelBehavior ( @ LabelBehavior int labelBehavior ) { if ( this . labelBehavior != labelBehavior ) { this . labelBehavior = labelBehavior ; requestLayout ( ) ; } } private boolean shouldAlwaysShowLabel ( ) { return this . labelBehavior == LABEL_VISIBLE ; } @ Dimension ( ) public int getTrackSidePadding ( ) { return trackSidePadding ; } @ Dimension ( ) public int getTrackWidth ( ) { return trackWidth ; } @ Dimension ( ) public int getTrackHeight ( ) { return trackHeight ; } public void setTrackHeight ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int trackHeight ) { if ( this . trackHeight != trackHeight ) { this . trackHeight = trackHeight ; invalidateTrack ( ) ; updateWidgetLayout ( ) ; } } private void updateTrackBound ( ) { int yCenter = calculateTrackCenter ( ) ; boundRectF . set ( trackSidePadding , yCenter - trackHeight / <NUM_LIT> , trackSidePadding + trackWidth , yCenter + trackHeight / <NUM_LIT> ) ; boundPath . addRoundRect ( boundRectF , trackHeight / <NUM_LIT> , trackHeight / <NUM_LIT> , Path . Direction . CW ) ; } @ Dimension ( ) public int getTickActiveRadius ( ) { return tickActiveRadius ; } public void setTickActiveRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int tickActiveRadius ) { if ( this . tickActiveRadius != tickActiveRadius ) { this . tickActiveRadius = tickActiveRadius ; activeTicksPaint . setStrokeWidth ( tickActiveRadius * <NUM_LIT> ) ; updateWidgetLayout ( ) ; } } @ Dimension ( ) public int getTickInactiveRadius ( ) { return tickInactiveRadius ; } public void setTickInactiveRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int tickInactiveRadius ) { if ( this . tickInactiveRadius != tickInactiveRadius ) { this . tickInactiveRadius = tickInactiveRadius ; inactiveTicksPaint . setStrokeWidth ( tickInactiveRadius * <NUM_LIT> ) ; updateWidgetLayout ( ) ; } } private void updateWidgetLayout ( ) { boolean sizeChanged = maybeIncreaseWidgetHeight ( ) ; boolean sidePaddingChanged = maybeIncreaseTrackSidePadding ( ) ; if ( sizeChanged ) { requestLayout ( ) ; } else if ( sidePaddingChanged ) { postInvalidate ( ) ; } } private boolean maybeIncreaseWidgetHeight ( ) { int topAndBottomPaddings = getPaddingTop ( ) + getPaddingBottom ( ) ; int minHeightRequiredByTrack = trackHeight + topAndBottomPaddings ; int minHeightRequiredByThumb = thumbRadius * <NUM_LIT> + getPaddingTop ( ) + getPaddingBottom ( ) ; int newWidgetHeight = max ( minWidgetHeight , max ( minHeightRequiredByTrack , minHeightRequiredByThumb ) ) ; if ( newWidgetHeight == widgetHeight ) { return false ; } widgetHeight = newWidgetHeight ; return true ; } @ NonNull public ColorStateList getHaloTintList ( ) { return haloColor ; } public void setHaloTintList ( @ NonNull ColorStateList haloColor ) { if ( haloColor . equals ( this . haloColor ) ) { return ; } this . haloColor = haloColor ; Drawable background = getBackground ( ) ; if ( ! shouldDrawCompatHalo ( ) && background instanceof RippleDrawable ) { ( ( RippleDrawable ) background ) . setColor ( haloColor ) ; return ; } haloPaint . setColor ( getColorForState ( haloColor ) ) ; haloPaint . setAlpha ( HALO_ALPHA ) ; invalidate ( ) ; } @ NonNull public ColorStateList getThumbTintList ( ) { return defaultThumbDrawable . getFillColor ( ) ; } public void setThumbTintList ( @ NonNull ColorStateList thumbColor ) { if ( thumbColor . equals ( defaultThumbDrawable . getFillColor ( ) ) ) { return ; } defaultThumbDrawable . setFillColor ( thumbColor ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTickTintList ( ) { if ( ! tickColorInactive . equals ( tickColorActive ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return tickColorActive ; } public void setTickTintList ( @ NonNull ColorStateList tickColor ) { setTickInactiveTintList ( tickColor ) ; setTickActiveTintList ( tickColor ) ; } @ NonNull public ColorStateList getTickActiveTintList ( ) { return tickColorActive ; } public void setTickActiveTintList ( @ NonNull ColorStateList tickColor ) { if ( tickColor . equals ( tickColorActive ) ) { return ; } tickColorActive = tickColor ; activeTicksPaint . setColor ( getColorForState ( tickColorActive ) ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTickInactiveTintList ( ) { return tickColorInactive ; } public void setTickInactiveTintList ( @ NonNull ColorStateList tickColor ) { if ( tickColor . equals ( tickColorInactive ) ) { return ; } tickColorInactive = tickColor ; inactiveTicksPaint . setColor ( getColorForState ( tickColorInactive ) ) ; invalidate ( ) ; } public boolean isTickVisible ( ) { return tickVisible ; } public void setTickVisible ( boolean tickVisible ) { if ( this . tickVisible != tickVisible ) { this . tickVisible = tickVisible ; postInvalidate ( ) ; } } @ NonNull public ColorStateList getTrackTintList ( ) { if ( ! trackColorInactive . equals ( trackColorActive ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return trackColorActive ; } public void setTrackTintList ( @ NonNull ColorStateList trackColor ) { setTrackInactiveTintList ( trackColor ) ; setTrackActiveTintList ( trackColor ) ; } @ NonNull public ColorStateList getTrackActiveTintList ( ) { return trackColorActive ; } public void setTrackActiveTintList ( @ NonNull ColorStateList trackColor ) { if ( trackColor . equals ( trackColorActive ) ) { return ; } trackColorActive = trackColor ; activeTrackPaint . setColor ( getColorForState ( trackColorActive ) ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTrackInactiveTintList ( ) { return trackColorInactive ; } public void setTrackInactiveTintList ( @ NonNull ColorStateList trackColor ) { if ( trackColor . equals ( trackColorInactive ) ) { return ; } trackColorInactive = trackColor ; inactiveTrackPaint . setColor ( getColorForState ( trackColorInactive ) ) ; invalidate ( ) ; } public void setTrackColorInactiveOverlay ( @ ColorInt int color ) { inactiveTrackPaintUnder . setColor ( color ) ; invalidate ( ) ; } public void setTrackColorActiveOverlay ( @ ColorInt int color ) { activeTrackPaintUnder . setColor ( color ) ; invalidate ( ) ; } @ Override protected void onVisibilityChanged ( @ NonNull View changedView , int visibility ) { super . onVisibilityChanged ( changedView , visibility ) ; if ( visibility != VISIBLE ) { ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( this ) ; if ( contentViewOverlay == null ) { return ; } for ( TooltipDrawable label : labels ) { contentViewOverlay . remove ( label ) ; } } } @ Override public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; setLayerType ( enabled ? LAYER_TYPE_NONE : LAYER_TYPE_HARDWARE , null ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; for ( TooltipDrawable label : labels ) { attachLabelToContentView ( label ) ; } } private void attachLabelToContentView ( TooltipDrawable label ) { label . setRelativeToView ( ViewUtils . getContentView ( this ) ) ; } @ Override protected void onDetachedFromWindow ( ) { if ( accessibilityEventSender != null ) { removeCallbacks ( accessibilityEventSender ) ; } labelsAreAnimatedIn = false ; for ( TooltipDrawable label : labels ) { detachLabelFromContentView ( label ) ; } super . onDetachedFromWindow ( ) ; } private void detachLabelFromContentView ( TooltipDrawable label ) { ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( this ) ; if ( contentViewOverlay != null ) { contentViewOverlay . remove ( label ) ; label . detachView ( ViewUtils . getContentView ( this ) ) ; } } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( widgetHeight + ( labelBehavior == LABEL_WITHIN_BOUNDS || shouldAlwaysShowLabel ( ) ? labels . get ( <NUM_LIT> ) . getIntrinsicHeight ( ) : <NUM_LIT> ) , MeasureSpec . EXACTLY ) ) ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { updateTrackWidth ( w ) ; updateHaloHotspot ( ) ; } private void maybeCalculateTicksCoordinates ( ) { if ( stepSize <= <NUM_LIT> ) { return ; } validateConfigurationIfDirty ( ) ; int tickCount = ( int ) ( ( valueTo - valueFrom ) / stepSize + <NUM_LIT> ) ; tickCount = min ( tickCount , trackWidth / ( trackHeight * <NUM_LIT> ) + <NUM_LIT> ) ; if ( ticksCoordinates == null || ticksCoordinates . length != tickCount * <NUM_LIT> ) { ticksCoordinates = new float [ tickCount * <NUM_LIT> ] ; } float interval = trackWidth / ( float ) ( tickCount - <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < tickCount * <NUM_LIT> ; i += <NUM_LIT> ) { ticksCoordinates [ i ] = trackSidePadding + i / <NUM_LIT> * interval ; ticksCoordinates [ i + <NUM_LIT> ] = calculateTrackCenter ( ) ; } } private void updateTrackWidth ( int width ) { trackWidth = max ( width - trackSidePadding * <NUM_LIT> , <NUM_LIT> ) ; maybeCalculateTicksCoordinates ( ) ; updateTrackBound ( ) ; } private void updateHaloHotspot ( ) { if ( ! shouldDrawCompatHalo ( ) && getMeasuredWidth ( ) > <NUM_LIT> ) { final Drawable background = getBackground ( ) ; if ( background instanceof RippleDrawable ) { int x = ( int ) ( normalizeValue ( values . get ( focusedThumbIdx ) ) * trackWidth + trackSidePadding ) ; int y = calculateTrackCenter ( ) ; DrawableCompat . setHotspotBounds ( background , x - haloRadius , y - haloRadius , x + haloRadius , y + haloRadius ) ; } } } private int calculateTrackCenter ( ) { return widgetHeight / <NUM_LIT> + ( labelBehavior == LABEL_WITHIN_BOUNDS || shouldAlwaysShowLabel ( ) ? labels . get ( <NUM_LIT> ) . getIntrinsicHeight ( ) : <NUM_LIT> ) ; } @ Override protected void onDraw ( @ NonNull Canvas canvas ) { if ( dirtyConfig ) { validateConfigurationIfDirty ( ) ; maybeCalculateTicksCoordinates ( ) ; } super . onDraw ( canvas ) ; int yCenter = calculateTrackCenter ( ) ; canvas . clipPath ( boundPath ) ; drawInactiveTrackOverlay ( canvas , trackWidth , yCenter ) ; drawInactiveTrack ( canvas , trackWidth , yCenter ) ; if ( max ( getValues ( ) ) > valueFrom ) { drawActiveTrackOverlay ( canvas , trackWidth , yCenter ) ; drawActiveTrack ( canvas , trackWidth , yCenter ) ; } maybeDrawTicks ( canvas ) ; if ( ( thumbIsPressed || isFocused ( ) ) && isEnabled ( ) ) { maybeDrawCompatHalo ( canvas , trackWidth , yCenter ) ; } if ( ( activeThumbIdx != - <NUM_LIT> || shouldAlwaysShowLabel ( ) ) && isEnabled ( ) ) { ensureLabelsAdded ( ) ; } else { ensureLabelsRemoved ( ) ; } drawThumbs ( canvas , trackWidth , yCenter ) ; } private float [ ] getActiveRange ( ) { float max = max ( getValues ( ) ) ; float min = min ( getValues ( ) ) ; float left = normalizeValue ( values . size ( ) == <NUM_LIT> ? valueFrom : min ) ; float right = normalizeValue ( max ) ; return isRtl ( ) ? new float [ ] { right , left } : new float [ ] { left , right } ; } private void drawInactiveTrackOverlay ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( right < trackSidePadding + width ) { canvas . drawLine ( right , yCenter , trackSidePadding + width , yCenter , inactiveTrackPaintUnder ) ; } float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( left > trackSidePadding ) { canvas . drawLine ( trackSidePadding , yCenter , left , yCenter , inactiveTrackPaintUnder ) ; } } private void drawInactiveTrack ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( right < trackSidePadding + width ) { canvas . drawLine ( right , yCenter , trackSidePadding + width , yCenter , inactiveTrackPaint ) ; } float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( left > trackSidePadding ) { canvas . drawLine ( trackSidePadding , yCenter , left , yCenter , inactiveTrackPaint ) ; } } private float normalizeValue ( float value ) { float normalized = ( value - valueFrom ) / ( valueTo - valueFrom ) ; if ( isRtl ( ) ) { return <NUM_LIT> - normalized ; } return normalized ; } private void drawActiveTrackOverlay ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; canvas . drawLine ( left , yCenter , right , yCenter , activeTrackPaintUnder ) ; } private void drawActiveTrack ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; canvas . drawLine ( left , yCenter , right , yCenter , activeTrackPaint ) ; } private void maybeDrawTicks ( @ NonNull Canvas canvas ) { if ( ! tickVisible || stepSize <= <NUM_LIT> ) { return ; } float [ ] activeRange = getActiveRange ( ) ; int leftPivotIndex = pivotIndex ( ticksCoordinates , activeRange [ <NUM_LIT> ] ) ; int rightPivotIndex = pivotIndex ( ticksCoordinates , activeRange [ <NUM_LIT> ] ) ; canvas . drawPoints ( ticksCoordinates , <NUM_LIT> , leftPivotIndex * <NUM_LIT> , inactiveTicksPaint ) ; canvas . drawPoints ( ticksCoordinates , leftPivotIndex * <NUM_LIT> , rightPivotIndex * <NUM_LIT> - leftPivotIndex * <NUM_LIT> , activeTicksPaint ) ; canvas . drawPoints ( ticksCoordinates , rightPivotIndex * <NUM_LIT> , ticksCoordinates . length - rightPivotIndex * <NUM_LIT> , inactiveTicksPaint ) ; } private void drawThumbs ( @ NonNull Canvas canvas , int width , int yCenter ) { for ( int i = <NUM_LIT> ; i < values . size ( ) ; i ++ ) { float value = values . get ( i ) ; if ( customThumbDrawable != null ) { drawThumbDrawable ( canvas , width , yCenter , value , customThumbDrawable ) ; } else if ( i < customThumbDrawablesForValues . size ( ) ) { drawThumbDrawable ( canvas , width , yCenter , value , customThumbDrawablesForValues . get ( i ) ) ; } else { if ( ! isEnabled ( ) ) { canvas . drawCircle ( trackSidePadding + normalizeValue ( value ) * width , yCenter , thumbRadius , thumbPaint ) ; } drawThumbDrawable ( canvas , width , yCenter , value , defaultThumbDrawable ) ; } } } private void drawThumbDrawable ( @ NonNull Canvas canvas , int width , int top , float value , @ NonNull Drawable thumbDrawable ) { canvas . save ( ) ; canvas . translate ( trackSidePadding + ( int ) ( normalizeValue ( value ) * width ) - ( thumbDrawable . getBounds ( ) . width ( ) / <NUM_LIT> ) , top - ( thumbDrawable . getBounds ( ) . height ( ) / <NUM_LIT> ) ) ; thumbDrawable . draw ( canvas ) ; canvas . restore ( ) ; } private void maybeDrawCompatHalo ( @ NonNull Canvas canvas , int width , int top ) { if ( shouldDrawCompatHalo ( ) ) { int centerX = ( int ) ( trackSidePadding + normalizeValue ( values . get ( focusedThumbIdx ) ) * width ) ; if ( VERSION . SDK_INT < VERSION_CODES . P ) { canvas . clipRect ( centerX - haloRadius , top - haloRadius , centerX + haloRadius , top + haloRadius , Op . UNION ) ; } canvas . drawCircle ( centerX , top , haloRadius , haloPaint ) ; } } private boolean shouldDrawCompatHalo ( ) { return forceDrawCompatHalo || VERSION . SDK_INT < VERSION_CODES . LOLLIPOP || ! ( getBackground ( ) instanceof RippleDrawable ) ; } @ Override public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! isEnabled ( ) ) { return false ; } float x = event . getX ( ) ; touchPosition = ( x - trackSidePadding ) / trackWidth ; touchPosition = max ( <NUM_LIT> , touchPosition ) ; touchPosition = min ( <NUM_LIT> , touchPosition ) ; switch ( event . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : touchDownX = x ; if ( isPotentialVerticalScroll ( event ) ) { break ; } getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; if ( ! pickActiveThumb ( ) ) { break ; } requestFocus ( ) ; thumbIsPressed = true ; snapTouchPosition ( ) ; updateHaloHotspot ( ) ; invalidate ( ) ; onStartTrackingTouch ( ) ; break ; case MotionEvent . ACTION_MOVE : if ( ! thumbIsPressed ) { if ( isPotentialVerticalScroll ( event ) && abs ( x - touchDownX ) < scaledTouchSlop ) { return false ; } getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; onStartTrackingTouch ( ) ; } if ( ! pickActiveThumb ( ) ) { break ; } thumbIsPressed = true ; snapTouchPosition ( ) ; updateHaloHotspot ( ) ; invalidate ( ) ; break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : thumbIsPressed = false ; if ( lastEvent != null && lastEvent . getActionMasked ( ) == MotionEvent . ACTION_DOWN && abs ( lastEvent . getX ( ) - event . getX ( ) ) <= scaledTouchSlop && abs ( lastEvent . getY ( ) - event . getY ( ) ) <= scaledTouchSlop ) { if ( pickActiveThumb ( ) ) { onStartTrackingTouch ( ) ; } } if ( activeThumbIdx != - <NUM_LIT> ) { snapTouchPosition ( ) ; updateHaloHotspot ( ) ; activeThumbIdx = - <NUM_LIT> ; onStopTrackingTouch ( ) ; } invalidate ( ) ; break ; default : } setPressed ( thumbIsPressed ) ; lastEvent = MotionEvent . obtain ( event ) ; return true ; } private double snapPosition ( float position ) { if ( stepSize > <NUM_LIT> ) { int stepCount = ( int ) ( ( valueTo - valueFrom ) / stepSize ) ; return Math . round ( position * stepCount ) / ( double ) stepCount ; } return position ; } protected boolean pickActiveThumb ( ) { if ( activeThumbIdx != - <NUM_LIT> ) { return true ; } float touchValue = getValueOfTouchPositionAbsolute ( ) ; float touchX = valueToX ( touchValue ) ; activeThumbIdx = <NUM_LIT> ; float activeThumbDiff = abs ( values . get ( activeThumbIdx ) - touchValue ) ; for ( int i = <NUM_LIT> ; i < values . size ( ) ; i ++ ) { float valueDiff = abs ( values . get ( i ) - touchValue ) ; float valueX = valueToX ( values . get ( i ) ) ; if ( compare ( valueDiff , activeThumbDiff ) > <NUM_LIT> ) { break ; } boolean movingForward = isRtl ( ) ? ( valueX - touchX ) > <NUM_LIT> : ( valueX - touchX ) < <NUM_LIT> ; if ( compare ( valueDiff , activeThumbDiff ) < <NUM_LIT> ) { activeThumbDiff = valueDiff ; activeThumbIdx = i ; continue ; } if ( compare ( valueDiff , activeThumbDiff ) == <NUM_LIT> ) { if ( abs ( valueX - touchX ) < scaledTouchSlop ) { activeThumbIdx = - <NUM_LIT> ; return false ; } if ( movingForward ) { activeThumbDiff = valueDiff ; activeThumbIdx = i ; } } } return activeThumbIdx != - <NUM_LIT> ; } private float getValueOfTouchPositionAbsolute ( ) { float position = touchPosition ; if ( isRtl ( ) ) { position = <NUM_LIT> - position ; } return ( position * ( valueTo - valueFrom ) + valueFrom ) ; } private boolean snapTouchPosition ( ) { return snapActiveThumbToValue ( getValueOfTouchPosition ( ) ) ; } private boolean snapActiveThumbToValue ( float value ) { return snapThumbToValue ( activeThumbIdx , value ) ; } private boolean snapThumbToValue ( int idx , float value ) { focusedThumbIdx = idx ; if ( abs ( value - values . get ( idx ) ) < THRESHOLD ) { return false ; } float newValue = getClampedValue ( idx , value ) ; values . set ( idx , newValue ) ; dispatchOnChangedFromUser ( idx ) ; return true ; } private float getClampedValue ( int idx , float value ) { float minSeparation = getMinSeparation ( ) ; minSeparation = separationUnit == UNIT_PX ? dimenToValue ( minSeparation ) : minSeparation ; if ( isRtl ( ) ) { minSeparation = - minSeparation ; } float upperBound = idx + <NUM_LIT> >= values . size ( ) ? valueTo : values . get ( idx + <NUM_LIT> ) - minSeparation ; float lowerBound = idx - <NUM_LIT> < <NUM_LIT> ? valueFrom : values . get ( idx - <NUM_LIT> ) + minSeparation ; return clamp ( value , lowerBound , upperBound ) ; } private float dimenToValue ( float dimen ) { if ( dimen == <NUM_LIT> ) { return <NUM_LIT> ; } return ( ( dimen - trackSidePadding ) / trackWidth ) * ( valueFrom - valueTo ) + valueFrom ; } protected void setSeparationUnit ( int separationUnit ) { this . separationUnit = separationUnit ; dirtyConfig = true ; postInvalidate ( ) ; } protected float getMinSeparation ( ) { return <NUM_LIT> ; } private float getValueOfTouchPosition ( ) { double position = snapPosition ( touchPosition ) ; if ( isRtl ( ) ) { position = <NUM_LIT> - position ; } return ( float ) ( position * ( valueTo - valueFrom ) + valueFrom ) ; } private float valueToX ( float value ) { return normalizeValue ( value ) * trackWidth + trackSidePadding ; } private ValueAnimator createLabelAnimator ( boolean enter ) { float startFraction = enter ? <NUM_LIT> : <NUM_LIT> ; startFraction = getAnimatorCurrentValueOrDefault ( enter ? labelsOutAnimator : labelsInAnimator , startFraction ) ; float endFraction = enter ? <NUM_LIT> : <NUM_LIT> ; ValueAnimator animator = ValueAnimator . ofFloat ( startFraction , endFraction ) ; int duration ; TimeInterpolator interpolator ; if ( enter ) { duration = MotionUtils . resolveThemeDuration ( getContext ( ) , LABEL_ANIMATION_ENTER_DURATION_ATTR , DEFAULT_LABEL_ANIMATION_ENTER_DURATION ) ; interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , LABEL_ANIMATION_ENTER_EASING_ATTR , AnimationUtils . DECELERATE_INTERPOLATOR ) ; } else { duration = MotionUtils . resolveThemeDuration ( getContext ( ) , LABEL_ANIMATION_EXIT_DURATION_ATTR , DEFAULT_LABEL_ANIMATION_EXIT_DURATION ) ; interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , LABEL_ANIMATION_EXIT_EASING_ATTR , AnimationUtils . FAST_OUT_LINEAR_IN_INTERPOLATOR ) ; } animator . setDuration ( duration ) ; animator . setInterpolator ( interpolator ) ; animator . addUpdateListener ( new AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { float fraction = ( float ) animation . getAnimatedValue ( ) ; for ( TooltipDrawable label : labels ) { label . setRevealFraction ( fraction ) ; } ViewCompat . postInvalidateOnAnimation ( BaseOverlaySlider . this ) ; } } ) ; return animator ; } private void ensureLabelsRemoved ( ) { if ( labelsAreAnimatedIn ) { labelsAreAnimatedIn = false ; labelsOutAnimator = createLabelAnimator ( false ) ; labelsInAnimator = null ; labelsOutAnimator . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { super . onAnimationEnd ( animation ) ; ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( BaseOverlaySlider . this ) ; for ( TooltipDrawable label : labels ) { contentViewOverlay . remove ( label ) ; } } } ) ; labelsOutAnimator . start ( ) ; } } private void ensureLabelsAdded ( ) { if ( labelBehavior == LABEL_GONE ) { return ; } if ( ! labelsAreAnimatedIn ) { labelsAreAnimatedIn = true ; labelsInAnimator = createLabelAnimator ( true ) ; labelsOutAnimator = null ; labelsInAnimator . start ( ) ; } Iterator < TooltipDrawable > labelItr = labels . iterator ( ) ; for ( int i = <NUM_LIT> ; i < values . size ( ) && labelItr . hasNext ( ) ; i ++ ) { if ( i == focusedThumbIdx ) { continue ; } setValueForLabel ( labelItr . next ( ) , values . get ( i ) ) ; } if ( ! labelItr . hasNext ( ) ) { throw new IllegalStateException ( String . format ( "<STR_LIT>" , labels . size ( ) , values . size ( ) ) ) ; } setValueForLabel ( labelItr . next ( ) , values . get ( focusedThumbIdx ) ) ; } private String formatValue ( float value ) { if ( hasLabelFormatter ( ) ) { return formatter . getFormattedValue ( value ) ; } return String . format ( ( int ) value == value ? "<STR_LIT>" : "<STR_LIT>" , value ) ; } private void setValueForLabel ( TooltipDrawable label , float value ) { label . setText ( formatValue ( value ) ) ; int left = trackSidePadding + ( int ) ( normalizeValue ( value ) * trackWidth ) - label . getIntrinsicWidth ( ) / <NUM_LIT> ; int top = calculateTrackCenter ( ) - ( labelPadding + thumbRadius ) ; label . setBounds ( left , top - label . getIntrinsicHeight ( ) , left + label . getIntrinsicWidth ( ) , top ) ; Rect rect = new Rect ( label . getBounds ( ) ) ; DescendantOffsetUtils . offsetDescendantRect ( ViewUtils . getContentView ( this ) , this , rect ) ; label . setBounds ( rect ) ; ViewUtils . getContentViewOverlay ( this ) . add ( label ) ; } private void invalidateTrack ( ) { activeTrackPaint . setStrokeWidth ( trackHeight ) ; activeTrackPaintUnder . setStrokeWidth ( trackHeight ) ; inactiveTrackPaint . setStrokeWidth ( trackHeight ) ; inactiveTrackPaintUnder . setStrokeWidth ( trackHeight ) ; } private boolean isInVerticalScrollingContainer ( ) { ViewParent p = getParent ( ) ; while ( p instanceof ViewGroup ) { ViewGroup parent = ( ViewGroup ) p ; boolean canScrollVertically = parent . canScrollVertically ( <NUM_LIT> ) || parent . canScrollVertically ( - <NUM_LIT> ) ; if ( canScrollVertically && parent . shouldDelayChildPressedState ( ) ) { return true ; } p = p . getParent ( ) ; } return false ; } private boolean isPotentialVerticalScroll ( MotionEvent event ) { return ! isMouseEvent ( event ) && isInVerticalScrollingContainer ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void dispatchOnChangedProgrammatically ( ) { for ( L listener : changeListeners ) { for ( Float value : values ) { listener . onValueChange ( ( S ) this , value , false ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) private void dispatchOnChangedFromUser ( int idx ) { for ( L listener : changeListeners ) { listener . onValueChange ( ( S ) this , values . get ( idx ) , true ) ; } if ( accessibilityManager != null && accessibilityManager . isEnabled ( ) ) { scheduleAccessibilityEventSender ( idx ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) private void onStartTrackingTouch ( ) { for ( T listener : touchListeners ) { listener . onStartTrackingTouch ( ( S ) this ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) private void onStopTrackingTouch ( ) { for ( T listener : touchListeners ) { listener . onStopTrackingTouch ( ( S ) this ) ; } } @ Override protected void drawableStateChanged ( ) { super . drawableStateChanged ( ) ; inactiveTrackPaint . setColor ( getColorForState ( trackColorInactive ) ) ; activeTrackPaint . setColor ( getColorForState ( trackColorActive ) ) ; inactiveTicksPaint . setColor ( getColorForState ( tickColorInactive ) ) ; activeTicksPaint . setColor ( getColorForState ( tickColorActive ) ) ; for ( TooltipDrawable label : labels ) { if ( label . isStateful ( ) ) { label . setState ( getDrawableState ( ) ) ; } } if ( defaultThumbDrawable . isStateful ( ) ) { defaultThumbDrawable . setState ( getDrawableState ( ) ) ; } haloPaint . setColor ( getColorForState ( haloColor ) ) ; haloPaint . setAlpha ( HALO_ALPHA ) ; } @ ColorInt private int getColorForState ( @ NonNull ColorStateList colorStateList ) { return colorStateList . getColorForState ( getDrawableState ( ) , colorStateList . getDefaultColor ( ) ) ; } @ VisibleForTesting void forceDrawCompatHalo ( boolean force ) { forceDrawCompatHalo = force ; } @ Override public boolean onKeyDown ( int keyCode , @ NonNull KeyEvent event ) { if ( ! isEnabled ( ) ) { return super . onKeyDown ( keyCode , event ) ; } if ( values . size ( ) == <NUM_LIT> ) { activeThumbIdx = <NUM_LIT> ; } if ( activeThumbIdx == - <NUM_LIT> ) { Boolean handled = onKeyDownNoActiveThumb ( keyCode , event ) ; return handled != null ? handled : super . onKeyDown ( keyCode , event ) ; } isLongPress |= event . isLongPress ( ) ; Float increment = calculateIncrementForKey ( keyCode ) ; if ( increment != null ) { if ( snapActiveThumbToValue ( values . get ( activeThumbIdx ) + increment ) ) { updateHaloHotspot ( ) ; postInvalidate ( ) ; } return true ; } switch ( keyCode ) { case KeyEvent . KEYCODE_TAB : if ( event . hasNoModifiers ( ) ) { return moveFocus ( <NUM_LIT> ) ; } if ( event . isShiftPressed ( ) ) { return moveFocus ( - <NUM_LIT> ) ; } return false ; case KeyEvent . KEYCODE_DPAD_CENTER : case KeyEvent . KEYCODE_ENTER : activeThumbIdx = - <NUM_LIT> ; postInvalidate ( ) ; return true ; default : } return super . onKeyDown ( keyCode , event ) ; } @ Nullable private Boolean onKeyDownNoActiveThumb ( int keyCode , @ NonNull KeyEvent event ) { switch ( keyCode ) { case KeyEvent . KEYCODE_TAB : if ( event . hasNoModifiers ( ) ) { return moveFocus ( <NUM_LIT> ) ; } if ( event . isShiftPressed ( ) ) { return moveFocus ( - <NUM_LIT> ) ; } return false ; case KeyEvent . KEYCODE_DPAD_LEFT : moveFocusInAbsoluteDirection ( - <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_MINUS : moveFocus ( - <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_DPAD_RIGHT : moveFocusInAbsoluteDirection ( <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_EQUALS : case KeyEvent . KEYCODE_PLUS : moveFocus ( <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_DPAD_CENTER : case KeyEvent . KEYCODE_ENTER : activeThumbIdx = focusedThumbIdx ; postInvalidate ( ) ; return true ; default : } return null ; } @ Override public boolean onKeyUp ( int keyCode , @ NonNull KeyEvent event ) { isLongPress = false ; return super . onKeyUp ( keyCode , event ) ; } final boolean isRtl ( ) { return ViewCompat . getLayoutDirection ( this ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } private boolean moveFocus ( int direction ) { int oldFocusedThumbIdx = focusedThumbIdx ; final long newFocusedThumbIdx = ( long ) oldFocusedThumbIdx + direction ; focusedThumbIdx = ( int ) clamp ( newFocusedThumbIdx , <NUM_LIT> , values . size ( ) - <NUM_LIT> ) ; if ( focusedThumbIdx == oldFocusedThumbIdx ) { return false ; } if ( activeThumbIdx != - <NUM_LIT> ) { activeThumbIdx = focusedThumbIdx ; } updateHaloHotspot ( ) ; postInvalidate ( ) ; return true ; } private boolean moveFocusInAbsoluteDirection ( int direction ) { if ( isRtl ( ) ) { direction = direction == Integer . MIN_VALUE ? Integer . MAX_VALUE : - direction ; } return moveFocus ( direction ) ; } @ Nullable private Float calculateIncrementForKey ( int keyCode ) { float increment = isLongPress ? calculateStepIncrement ( <NUM_LIT> ) : calculateStepIncrement ( ) ; switch ( keyCode ) { case KeyEvent . KEYCODE_DPAD_LEFT : return isRtl ( ) ? increment : - increment ; case KeyEvent . KEYCODE_DPAD_RIGHT : return isRtl ( ) ? - increment : increment ; case KeyEvent . KEYCODE_MINUS : return - increment ; case KeyEvent . KEYCODE_EQUALS : case KeyEvent . KEYCODE_PLUS : return increment ; default : return null ; } } private float calculateStepIncrement ( ) { return stepSize == <NUM_LIT> ? <NUM_LIT> : stepSize ; } private float calculateStepIncrement ( int stepFactor ) { float increment = calculateStepIncrement ( ) ; float numSteps = ( valueTo - valueFrom ) / increment ; if ( numSteps <= stepFactor ) { return increment ; } return Math . round ( ( numSteps / stepFactor ) ) * increment ; } @ Override protected void onFocusChanged ( boolean gainFocus , int direction , @ Nullable Rect previouslyFocusedRect ) { super . onFocusChanged ( gainFocus , direction , previouslyFocusedRect ) ; if ( ! gainFocus ) { activeThumbIdx = - <NUM_LIT> ; accessibilityHelper . clearKeyboardFocusForVirtualView ( focusedThumbIdx ) ; } else { focusThumbOnFocusGained ( direction ) ; accessibilityHelper . requestKeyboardFocusForVirtualView ( focusedThumbIdx ) ; } } private void focusThumbOnFocusGained ( int direction ) { switch ( direction ) { case FOCUS_BACKWARD : moveFocus ( Integer . MAX_VALUE ) ; break ; case FOCUS_LEFT : moveFocusInAbsoluteDirection ( Integer . MAX_VALUE ) ; break ; case FOCUS_FORWARD : moveFocus ( Integer . MIN_VALUE ) ; break ; case FOCUS_RIGHT : moveFocusInAbsoluteDirection ( Integer . MIN_VALUE ) ; break ; case FOCUS_UP : case FOCUS_DOWN : default : } } @ VisibleForTesting final int getAccessibilityFocusedVirtualViewId ( ) { return accessibilityHelper . getAccessibilityFocusedVirtualViewId ( ) ; } @ NonNull @ Override public CharSequence getAccessibilityClassName ( ) { return SeekBar . class . getName ( ) ; } @ Override public boolean dispatchHoverEvent ( @ NonNull MotionEvent event ) { return accessibilityHelper . dispatchHoverEvent ( event ) || super . dispatchHoverEvent ( event ) ; } @ Override public boolean dispatchKeyEvent ( @ NonNull KeyEvent event ) { return super . dispatchKeyEvent ( event ) ; } private void scheduleAccessibilityEventSender ( int idx ) { if ( accessibilityEventSender == null ) { accessibilityEventSender = new AccessibilityEventSender ( ) ; } else { removeCallbacks ( accessibilityEventSender ) ; } accessibilityEventSender . setVirtualViewId ( idx ) ; postDelayed ( accessibilityEventSender , TIMEOUT_SEND_ACCESSIBILITY_EVENT ) ; } @ Override protected Parcelable onSaveInstanceState ( ) { Parcelable superState = super . onSaveInstanceState ( ) ; SliderState sliderState = new SliderState ( superState ) ; sliderState . valueFrom = valueFrom ; sliderState . valueTo = valueTo ; sliderState . values = new ArrayList < > ( values ) ; sliderState . stepSize = stepSize ; sliderState . hasFocus = hasFocus ( ) ; return sliderState ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { SliderState sliderState = ( SliderState ) state ; super . onRestoreInstanceState ( sliderState . getSuperState ( ) ) ; valueFrom = sliderState . valueFrom ; valueTo = sliderState . valueTo ; setValuesInternal ( sliderState . values ) ; stepSize = sliderState . stepSize ; if ( sliderState . hasFocus ) { requestFocus ( ) ; } } void updateBoundsForVirtualViewId ( int virtualViewId , Rect virtualViewBounds ) { int x = trackSidePadding + ( int ) ( normalizeValue ( getValues ( ) . get ( virtualViewId ) ) * trackWidth ) ; int y = calculateTrackCenter ( ) ; int touchTargetRadius = ( thumbRadius > minTouchTargetSize ? thumbRadius : minTouchTargetSize ) / <NUM_LIT> ; virtualViewBounds . set ( x - touchTargetRadius , y - touchTargetRadius , x + touchTargetRadius , y + touchTargetRadius ) ; } @ IntDef ( { LABEL_FLOATING , LABEL_WITHIN_BOUNDS , LABEL_GONE , LABEL_VISIBLE } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface LabelBehavior { } @ IntDef ( { UNIT_PX , UNIT_VALUE } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface SeparationUnit { } static class SliderState extends BaseSavedState { public static final Creator < SliderState > CREATOR = new Creator < SliderState > ( ) { @ NonNull @ Override public SliderState createFromParcel ( @ NonNull Parcel source ) { return new SliderState ( source ) ; } @ NonNull @ Override public SliderState [ ] newArray ( int size ) { return new SliderState [ size ] ; } } ; float valueFrom ; float valueTo ; ArrayList < Float > values ; float stepSize ; boolean hasFocus ; SliderState ( Parcelable superState ) { super ( superState ) ; } private SliderState ( @ NonNull Parcel source ) { super ( source ) ; valueFrom = source . readFloat ( ) ; valueTo = source . readFloat ( ) ; values = new ArrayList < > ( ) ; source . readList ( values , Float . class . getClassLoader ( ) ) ; stepSize = source . readFloat ( ) ; hasFocus = source . createBooleanArray ( ) [ <NUM_LIT> ] ; } @ Override public void writeToParcel ( @ NonNull Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeFloat ( valueFrom ) ; dest . writeFloat ( valueTo ) ; dest . writeList ( values ) ; dest . writeFloat ( stepSize ) ; boolean [ ] booleans = new boolean [ <NUM_LIT> ] ; booleans [ <NUM_LIT> ] = hasFocus ; dest . writeBooleanArray ( booleans ) ; } } private static class AccessibilityHelper extends ExploreByTouchHelper { final Rect virtualViewBounds = new Rect ( ) ; private final BaseOverlaySlider < ? , ? , ? > slider ; AccessibilityHelper ( BaseOverlaySlider < ? , ? , ? > slider ) { super ( slider ) ; this . slider = slider ; } @ Override protected int getVirtualViewAt ( float x , float y ) { for ( int i = <NUM_LIT> ; i < slider . getValues ( ) . size ( ) ; i ++ ) { slider . updateBoundsForVirtualViewId ( i , virtualViewBounds ) ; if ( virtualViewBounds . contains ( ( int ) x , ( int ) y ) ) { return i ; } } return ExploreByTouchHelper . HOST_ID ; } @ Override protected void getVisibleVirtualViews ( List < Integer > virtualViewIds ) { for ( int i = <NUM_LIT> ; i < slider . getValues ( ) . size ( ) ; i ++ ) { virtualViewIds . add ( i ) ; } } @ Override protected void onPopulateNodeForVirtualView ( int virtualViewId , AccessibilityNodeInfoCompat info ) { info . addAction ( AccessibilityNodeInfoCompat . AccessibilityActionCompat . ACTION_SET_PROGRESS ) ; List < Float > values = slider . getValues ( ) ; final float value = values . get ( virtualViewId ) ; float valueFrom = slider . getValueFrom ( ) ; float valueTo = slider . getValueTo ( ) ; if ( slider . isEnabled ( ) ) { if ( value > valueFrom ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; } if ( value < valueTo ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; } } info . setRangeInfo ( RangeInfoCompat . obtain ( RANGE_TYPE_FLOAT , valueFrom , valueTo , value ) ) ; info . setClassName ( SeekBar . class . getName ( ) ) ; StringBuilder contentDescription = new StringBuilder ( ) ; if ( slider . getContentDescription ( ) != null ) { contentDescription . append ( slider . getContentDescription ( ) ) . append ( "<STR_LIT>" ) ; } String verbalValue = slider . formatValue ( value ) ; String verbalValueType = slider . getContext ( ) . getString ( R . string . material_slider_value ) ; if ( values . size ( ) > <NUM_LIT> ) { verbalValueType = startOrEndDescription ( virtualViewId ) ; } contentDescription . append ( String . format ( Locale . US , "<STR_LIT>" , verbalValueType , verbalValue ) ) ; info . setContentDescription ( contentDescription . toString ( ) ) ; slider . updateBoundsForVirtualViewId ( virtualViewId , virtualViewBounds ) ; info . setBoundsInParent ( virtualViewBounds ) ; } @ NonNull private String startOrEndDescription ( int virtualViewId ) { List < Float > values = slider . getValues ( ) ; if ( virtualViewId == values . size ( ) - <NUM_LIT> ) { return slider . getContext ( ) . getString ( R . string . material_slider_range_end ) ; } if ( virtualViewId == <NUM_LIT> ) { return slider . getContext ( ) . getString ( R . string . material_slider_range_start ) ; } return "<STR_LIT>" ; } @ Override protected boolean onPerformActionForVirtualView ( int virtualViewId , int action , Bundle arguments ) { if ( ! slider . isEnabled ( ) ) { return false ; } switch ( action ) { case android . R . id . accessibilityActionSetProgress : { if ( arguments == null || ! arguments . containsKey ( AccessibilityNodeInfoCompat . ACTION_ARGUMENT_PROGRESS_VALUE ) ) { return false ; } float value = arguments . getFloat ( AccessibilityNodeInfoCompat . ACTION_ARGUMENT_PROGRESS_VALUE ) ; if ( slider . snapThumbToValue ( virtualViewId , value ) ) { slider . updateHaloHotspot ( ) ; slider . postInvalidate ( ) ; invalidateVirtualView ( virtualViewId ) ; return true ; } return false ; } case AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD : case AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD : { float increment = slider . calculateStepIncrement ( <NUM_LIT> ) ; if ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) { increment = - increment ; } if ( slider . isRtl ( ) ) { increment = - increment ; } List < Float > values = slider . getValues ( ) ; float clamped = clamp ( values . get ( virtualViewId ) + increment , slider . getValueFrom ( ) , slider . getValueTo ( ) ) ; if ( slider . snapThumbToValue ( virtualViewId , clamped ) ) { slider . updateHaloHotspot ( ) ; slider . postInvalidate ( ) ; invalidateVirtualView ( virtualViewId ) ; return true ; } return false ; } default : return false ; } } } private class AccessibilityEventSender implements Runnable { int virtualViewId = - <NUM_LIT> ; void setVirtualViewId ( int virtualViewId ) { this . virtualViewId = virtualViewId ; } @ Override public void run ( ) { accessibilityHelper . sendEventForVirtualView ( virtualViewId , AccessibilityEvent . TYPE_VIEW_SELECTED ) ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageSelected ( int position ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageSelected ( position ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageScrollStateChanged ( @ ViewPager2 . ScrollState int state ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrollStateChanged ( state ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } private void throwCallbackListModifiedWhileInUse ( ConcurrentModificationException parent ) { throw new IllegalStateException ( "<STR_LIT>" , parent ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( "<STR_LIT>" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( "<STR_LIT>" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; } if ( oldItem == null && newItem == null ) { return true ; } throw new AssertionError ( ) ; } @ Nullable @ Override public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . getChangePayload ( oldItem , newItem ) ; } throw new AssertionError ( ) ; } } ) ; mMainThreadExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( mMaxScheduledGeneration == runGeneration ) { latchList ( newList , result , commitCallback ) ; } } } ) ; } } ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void latchList ( @ NonNull List < T > newList , @ NonNull DiffUtil . DiffResult diffResult , @ Nullable Runnable commitCallback ) { final List < T > previousList = mReadOnlyList ; mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; diffResult . dispatchUpdatesTo ( mUpdateCallback ) ; onCurrentListChanged ( previousList , commitCallback ) ; } private void onCurrentListChanged ( @ NonNull List < T > previousList , @ Nullable Runnable commitCallback ) { for ( ListListener < T > listener : mListeners ) { listener . onCurrentListChanged ( previousList , mReadOnlyList ) ; } if ( commitCallback != null ) { commitCallback . run ( ) ; } } public void addListListener ( @ NonNull ListListener < T > listener ) { mListeners . add ( listener ) ; } public void removeListListener ( @ NonNull ListListener < T > listener ) { mListeners . remove ( listener ) ; } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ; container . setSaveEnabled ( false ) ; return new FragmentViewHolder ( container ) ; } @ NonNull FrameLayout getContainer ( ) { return ( FrameLayout ) itemView ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , "<STR_LIT>" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ; ViewParent parentParent = parent . getParent ( ) ; if ( parent instanceof RecyclerView && parentParent instanceof ViewPager2 ) { return ( ViewPager2 ) parentParent ; } throw new IllegalStateException ( "<STR_LIT>" ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = "<STR_LIT>" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( "<STR_LIT>" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getLayoutManager ( ) . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int right = mBounds . right + Math . round ( child . getTranslationX ( ) ) ; final int left = right - mDivider . getIntrinsicWidth ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mDivider == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } if ( mOrientation == VERTICAL ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicHeight ( ) ) ; } else { outRect . set ( <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicWidth ( ) , <NUM_LIT> ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( "<STR_LIT>" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( "<STR_LIT>" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( "<STR_LIT>" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( "<STR_LIT>" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( "<STR_LIT>" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( "<STR_LIT>" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ; final int right = layoutManager . getDecoratedRight ( view ) + params . rightMargin ; final int start = layoutManager . getPaddingLeft ( ) ; final int end = layoutManager . getWidth ( ) - layoutManager . getPaddingRight ( ) ; return calculateDtToFit ( left , right , start , end , snapPreference ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ; if ( mLastAccessedTile == tile ) { mLastAccessedTile = null ; } mTiles . delete ( startPosition ) ; return tile ; } public static class Tile < T > { public final T [ ] mItems ; public int mStartPosition ; public int mItemCount ; Tile < T > mNext ; Tile ( @ NonNull Class < T > klass , int size ) { @ SuppressWarnings ( "<STR_LIT>" ) T [ ] items = ( T [ ] ) Array . newInstance ( klass , size ) ; mItems = items ; } boolean containsPosition ( int pos ) { return mStartPosition <= pos && pos < mStartPosition + mItemCount ; } T getByPosition ( int pos ) { return mItems [ pos - mStartPosition ] ; } } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import android . os . Parcelable ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . fluidviewpager2 . widget . ViewPager2 ; public interface StatefulAdapter { @ NonNull Parcelable saveState ( ) ; void restoreState ( @ NonNull Parcelable savedState ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( "<STR_LIT>" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( "<STR_LIT>" , "<STR_LIT>" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( "<STR_LIT>" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( "<STR_LIT>" , "<STR_LIT>" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) { item . next = mRoot ; mRoot = item ; } } void sendMessage ( SyncQueueItem item ) { synchronized ( mLock ) { if ( mRoot == null ) { mRoot = item ; return ; } SyncQueueItem last = mRoot ; while ( last . next != null ) { last = last . next ; } last . next = item ; } } void removeMessages ( int what ) { synchronized ( mLock ) { while ( mRoot != null && mRoot . what == what ) { SyncQueueItem item = mRoot ; mRoot = mRoot . next ; item . recycle ( ) ; } if ( mRoot != null ) { SyncQueueItem prev = mRoot ; SyncQueueItem item = prev . next ; while ( item != null ) { SyncQueueItem next = item . next ; if ( item . what == what ) { prev . next = next ; item . recycle ( ) ; } else { prev = item ; } item = next ; } } } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . os . Build ; import android . util . Log ; import android . view . GestureDetector ; import android . view . HapticFeedbackConstants ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewParent ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . GestureDetectorCompat ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; import androidx . fluidrecyclerview . widget . RecyclerView . OnItemTouchListener ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . ArrayList ; import java . util . List ; public class ItemTouchHelper extends RecyclerView . ItemDecoration implements RecyclerView . OnChildAttachStateChangeListener { public static final int UP = <NUM_LIT> ; public static final int DOWN = <NUM_LIT> << <NUM_LIT> ; public static final int LEFT = <NUM_LIT> << <NUM_LIT> ; public static final int RIGHT = <NUM_LIT> << <NUM_LIT> ; public static final int START = LEFT << <NUM_LIT> ; public static final int END = RIGHT << <NUM_LIT> ; public static final int ACTION_STATE_IDLE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ACTION_STATE_SWIPE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ACTION_STATE_DRAG = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_SWIPE_SUCCESS = <NUM_LIT> << <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_SWIPE_CANCEL = <NUM_LIT> << <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_DRAG = <NUM_LIT> << <NUM_LIT> ; private static final String TAG = "<STR_LIT>" ; private static final boolean DEBUG = false ; private static final int ACTIVE_POINTER_ID_NONE = - <NUM_LIT> ; static final int DIRECTION_FLAG_COUNT = <NUM_LIT> ; private static final int ACTION_MODE_IDLE_MASK = ( <NUM_LIT> << DIRECTION_FLAG_COUNT ) - <NUM_LIT> ; static final int ACTION_MODE_SWIPE_MASK = ACTION_MODE_IDLE_MASK << DIRECTION_FLAG_COUNT ; static final int ACTION_MODE_DRAG_MASK = ACTION_MODE_SWIPE_MASK << DIRECTION_FLAG_COUNT ; private static final int PIXELS_PER_SECOND = <NUM_LIT> ; final List < View > mPendingCleanup = new ArrayList < > ( ) ; private final float [ ] mTmpPosition = new float [ <NUM_LIT> ] ; @ SuppressWarnings ( "<STR_LIT>" ) ViewHolder mSelected = null ; float mInitialTouchX ; float mInitialTouchY ; private float mSwipeEscapeVelocity ; private float mMaxSwipeVelocity ; float mDx ; float mDy ; private float mSelectedStartX ; private float mSelectedStartY ; @ SuppressWarnings ( "<STR_LIT>" ) int mActivePointerId = ACTIVE_POINTER_ID_NONE ; @ NonNull Callback mCallback ; private int mActionState = ACTION_STATE_IDLE ; @ SuppressWarnings ( "<STR_LIT>" ) int mSelectedFlags ; @ VisibleForTesting List < RecoverAnimation > mRecoverAnimations = new ArrayList < > ( ) ; private int mSlop ; RecyclerView mRecyclerView ; @ SuppressWarnings ( "<STR_LIT>" ) final Runnable mScrollRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( mSelected != null && scrollIfNecessary ( ) ) { if ( mSelected != null ) { moveIfNecessary ( mSelected ) ; } mRecyclerView . removeCallbacks ( mScrollRunnable ) ; ViewCompat . postOnAnimation ( mRecyclerView , this ) ; } } } ; VelocityTracker mVelocityTracker ; private List < ViewHolder > mSwapTargets ; private List < Integer > mDistances ; private RecyclerView . ChildDrawingOrderCallback mChildDrawingOrderCallback = null ; @ SuppressWarnings ( "<STR_LIT>" ) View mOverdrawChild = null ; @ SuppressWarnings ( "<STR_LIT>" ) int mOverdrawChildPosition = - <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) GestureDetectorCompat mGestureDetector ; private ItemTouchHelperGestureListener mItemTouchHelperGestureListener ; private final OnItemTouchListener mOnItemTouchListener = new OnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { mGestureDetector . onTouchEvent ( event ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + event . getX ( ) + "<STR_LIT>" + event . getY ( ) + "<STR_LIT>" + event ) ; } final int action = event . getActionMasked ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { mActivePointerId = event . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = event . getX ( ) ; mInitialTouchY = event . getY ( ) ; obtainVelocityTracker ( ) ; if ( mSelected == null ) { final RecoverAnimation animation = findAnimation ( event ) ; if ( animation != null ) { mInitialTouchX -= animation . mX ; mInitialTouchY -= animation . mY ; endRecoverAnimation ( animation . mViewHolder , true ) ; if ( mPendingCleanup . remove ( animation . mViewHolder . itemView ) ) { mCallback . clearView ( mRecyclerView , animation . mViewHolder ) ; } select ( animation . mViewHolder , animation . mActionState ) ; updateDxDy ( event , mSelectedFlags , <NUM_LIT> ) ; } } } else if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mActivePointerId = ACTIVE_POINTER_ID_NONE ; select ( null , ACTION_STATE_IDLE ) ; } else if ( mActivePointerId != ACTIVE_POINTER_ID_NONE ) { final int index = event . findPointerIndex ( mActivePointerId ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index ) ; } if ( index >= <NUM_LIT> ) { checkSelectForSwipe ( action , event , index ) ; } } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( event ) ; } return mSelected != null ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { mGestureDetector . onTouchEvent ( event ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mInitialTouchX + "<STR_LIT>" + mInitialTouchY + "<STR_LIT>" + event ) ; } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( event ) ; } if ( mActivePointerId == ACTIVE_POINTER_ID_NONE ) { return ; } final int action = event . getActionMasked ( ) ; final int activePointerIndex = event . findPointerIndex ( mActivePointerId ) ; if ( activePointerIndex >= <NUM_LIT> ) { checkSelectForSwipe ( action , event , activePointerIndex ) ; } ViewHolder viewHolder = mSelected ; if ( viewHolder == null ) { return ; } switch ( action ) { case MotionEvent . ACTION_MOVE : { if ( activePointerIndex >= <NUM_LIT> ) { updateDxDy ( event , mSelectedFlags , activePointerIndex ) ; moveIfNecessary ( viewHolder ) ; mRecyclerView . removeCallbacks ( mScrollRunnable ) ; mScrollRunnable . run ( ) ; mRecyclerView . invalidate ( ) ; } break ; } case MotionEvent . ACTION_CANCEL : if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } case MotionEvent . ACTION_UP : select ( null , ACTION_STATE_IDLE ) ; mActivePointerId = ACTIVE_POINTER_ID_NONE ; break ; case MotionEvent . ACTION_POINTER_UP : { final int pointerIndex = event . getActionIndex ( ) ; final int pointerId = event . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mActivePointerId = event . getPointerId ( newPointerIndex ) ; updateDxDy ( event , mSelectedFlags , pointerIndex ) ; } break ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { if ( ! disallowIntercept ) { return ; } select ( null , ACTION_STATE_IDLE ) ; } } ; private Rect mTmpRect ; private long mDragScrollStartTimeInMs ; public ItemTouchHelper ( @ NonNull Callback callback ) { mCallback = callback ; } private static boolean hitTest ( View child , float x , float y , float left , float top ) { return x >= left && x <= left + child . getWidth ( ) && y >= top && y <= top + child . getHeight ( ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( recyclerView != null ) { final Resources resources = recyclerView . getResources ( ) ; mSwipeEscapeVelocity = resources . getDimension ( R . dimen . item_touch_helper_swipe_escape_velocity ) ; mMaxSwipeVelocity = resources . getDimension ( R . dimen . item_touch_helper_swipe_escape_max_velocity ) ; setupCallbacks ( ) ; } } private void setupCallbacks ( ) { ViewConfiguration vc = ViewConfiguration . get ( mRecyclerView . getContext ( ) ) ; mSlop = vc . getScaledTouchSlop ( ) ; mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( mOnItemTouchListener ) ; mRecyclerView . addOnChildAttachStateChangeListener ( this ) ; startGestureDetection ( ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( mOnItemTouchListener ) ; mRecyclerView . removeOnChildAttachStateChangeListener ( this ) ; final int recoverAnimSize = mRecoverAnimations . size ( ) ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation recoverAnimation = mRecoverAnimations . get ( <NUM_LIT> ) ; recoverAnimation . cancel ( ) ; mCallback . clearView ( mRecyclerView , recoverAnimation . mViewHolder ) ; } mRecoverAnimations . clear ( ) ; mOverdrawChild = null ; mOverdrawChildPosition = - <NUM_LIT> ; releaseVelocityTracker ( ) ; stopGestureDetection ( ) ; } private void startGestureDetection ( ) { mItemTouchHelperGestureListener = new ItemTouchHelperGestureListener ( ) ; mGestureDetector = new GestureDetectorCompat ( mRecyclerView . getContext ( ) , mItemTouchHelperGestureListener ) ; } private void stopGestureDetection ( ) { if ( mItemTouchHelperGestureListener != null ) { mItemTouchHelperGestureListener . doNotReactToLongPress ( ) ; mItemTouchHelperGestureListener = null ; } if ( mGestureDetector != null ) { mGestureDetector = null ; } } private void getSelectedDxDy ( float [ ] outPosition ) { if ( ( mSelectedFlags & ( LEFT | RIGHT ) ) != <NUM_LIT> ) { outPosition [ <NUM_LIT> ] = mSelectedStartX + mDx - mSelected . itemView . getLeft ( ) ; } else { outPosition [ <NUM_LIT> ] = mSelected . itemView . getTranslationX ( ) ; } if ( ( mSelectedFlags & ( UP | DOWN ) ) != <NUM_LIT> ) { outPosition [ <NUM_LIT> ] = mSelectedStartY + mDy - mSelected . itemView . getTop ( ) ; } else { outPosition [ <NUM_LIT> ] = mSelected . itemView . getTranslationY ( ) ; } } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { float dx = <NUM_LIT> , dy = <NUM_LIT> ; if ( mSelected != null ) { getSelectedDxDy ( mTmpPosition ) ; dx = mTmpPosition [ <NUM_LIT> ] ; dy = mTmpPosition [ <NUM_LIT> ] ; } mCallback . onDrawOver ( c , parent , mSelected , mRecoverAnimations , mActionState , dx , dy ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { mOverdrawChildPosition = - <NUM_LIT> ; float dx = <NUM_LIT> , dy = <NUM_LIT> ; if ( mSelected != null ) { getSelectedDxDy ( mTmpPosition ) ; dx = mTmpPosition [ <NUM_LIT> ] ; dy = mTmpPosition [ <NUM_LIT> ] ; } mCallback . onDraw ( c , parent , mSelected , mRecoverAnimations , mActionState , dx , dy ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void select ( @ Nullable ViewHolder selected , int actionState ) { if ( selected == mSelected && actionState == mActionState ) { return ; } mDragScrollStartTimeInMs = Long . MIN_VALUE ; final int prevActionState = mActionState ; endRecoverAnimation ( selected , true ) ; mActionState = actionState ; if ( actionState == ACTION_STATE_DRAG ) { if ( selected == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOverdrawChild = selected . itemView ; addChildDrawingOrderCallback ( ) ; } int actionStateMask = ( <NUM_LIT> << ( DIRECTION_FLAG_COUNT + DIRECTION_FLAG_COUNT * actionState ) ) - <NUM_LIT> ; boolean preventLayout = false ; if ( mSelected != null ) { final ViewHolder prevSelected = mSelected ; if ( prevSelected . itemView . getParent ( ) != null ) { final int swipeDir = prevActionState == ACTION_STATE_DRAG ? <NUM_LIT> : swipeIfNecessary ( prevSelected ) ; releaseVelocityTracker ( ) ; final float targetTranslateX , targetTranslateY ; int animationType ; switch ( swipeDir ) { case LEFT : case RIGHT : case START : case END : targetTranslateY = <NUM_LIT> ; targetTranslateX = Math . signum ( mDx ) * mRecyclerView . getWidth ( ) ; break ; case UP : case DOWN : targetTranslateX = <NUM_LIT> ; targetTranslateY = Math . signum ( mDy ) * mRecyclerView . getHeight ( ) ; break ; default : targetTranslateX = <NUM_LIT> ; targetTranslateY = <NUM_LIT> ; } if ( prevActionState == ACTION_STATE_DRAG ) { animationType = ANIMATION_TYPE_DRAG ; } else if ( swipeDir > <NUM_LIT> ) { animationType = ANIMATION_TYPE_SWIPE_SUCCESS ; } else { animationType = ANIMATION_TYPE_SWIPE_CANCEL ; } getSelectedDxDy ( mTmpPosition ) ; final float currentTranslateX = mTmpPosition [ <NUM_LIT> ] ; final float currentTranslateY = mTmpPosition [ <NUM_LIT> ] ; final RecoverAnimation rv = new RecoverAnimation ( prevSelected , animationType , prevActionState , currentTranslateX , currentTranslateY , targetTranslateX , targetTranslateY ) { @ Override public void onAnimationEnd ( Animator animation ) { super . onAnimationEnd ( animation ) ; if ( this . mOverridden ) { return ; } if ( swipeDir <= <NUM_LIT> ) { mCallback . clearView ( mRecyclerView , prevSelected ) ; } else { mPendingCleanup . add ( prevSelected . itemView ) ; mIsPendingCleanup = true ; if ( swipeDir > <NUM_LIT> ) { postDispatchSwipe ( this , swipeDir ) ; } } if ( mOverdrawChild == prevSelected . itemView ) { removeChildDrawingOrderCallbackIfNecessary ( prevSelected . itemView ) ; } } } ; final long duration = mCallback . getAnimationDuration ( mRecyclerView , animationType , targetTranslateX - currentTranslateX , targetTranslateY - currentTranslateY ) ; rv . setDuration ( duration ) ; mRecoverAnimations . add ( rv ) ; rv . start ( ) ; preventLayout = true ; } else { removeChildDrawingOrderCallbackIfNecessary ( prevSelected . itemView ) ; mCallback . clearView ( mRecyclerView , prevSelected ) ; } mSelected = null ; } if ( selected != null ) { mSelectedFlags = ( mCallback . getAbsoluteMovementFlags ( mRecyclerView , selected ) & actionStateMask ) > > ( mActionState * DIRECTION_FLAG_COUNT ) ; mSelectedStartX = selected . itemView . getLeft ( ) ; mSelectedStartY = selected . itemView . getTop ( ) ; mSelected = selected ; if ( actionState == ACTION_STATE_DRAG ) { mSelected . itemView . performHapticFeedback ( HapticFeedbackConstants . LONG_PRESS ) ; } } final ViewParent rvParent = mRecyclerView . getParent ( ) ; if ( rvParent != null ) { rvParent . requestDisallowInterceptTouchEvent ( mSelected != null ) ; } if ( ! preventLayout ) { mRecyclerView . getLayoutManager ( ) . requestSimpleAnimationsInNextLayout ( ) ; } mCallback . onSelectedChanged ( mSelected , mActionState ) ; mRecyclerView . invalidate ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void postDispatchSwipe ( final RecoverAnimation anim , final int swipeDir ) { mRecyclerView . post ( new Runnable ( ) { @ Override public void run ( ) { if ( mRecyclerView != null && mRecyclerView . isAttachedToWindow ( ) && ! anim . mOverridden && anim . mViewHolder . getAbsoluteAdapterPosition ( ) != RecyclerView . NO_POSITION ) { final RecyclerView . ItemAnimator animator = mRecyclerView . getItemAnimator ( ) ; if ( ( animator == null || ! animator . isRunning ( null ) ) && ! hasRunningRecoverAnim ( ) ) { mCallback . onSwiped ( anim . mViewHolder , swipeDir ) ; } else { mRecyclerView . post ( this ) ; } } } } ) ; } @ SuppressWarnings ( "<STR_LIT>" ) boolean hasRunningRecoverAnim ( ) { final int size = mRecoverAnimations . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { if ( ! mRecoverAnimations . get ( i ) . mEnded ) { return true ; } } return false ; } @ SuppressWarnings ( "<STR_LIT>" ) boolean scrollIfNecessary ( ) { if ( mSelected == null ) { mDragScrollStartTimeInMs = Long . MIN_VALUE ; return false ; } final long now = System . currentTimeMillis ( ) ; final long scrollDuration = mDragScrollStartTimeInMs == Long . MIN_VALUE ? <NUM_LIT> : now - mDragScrollStartTimeInMs ; RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; if ( mTmpRect == null ) { mTmpRect = new Rect ( ) ; } int scrollX = <NUM_LIT> ; int scrollY = <NUM_LIT> ; lm . calculateItemDecorationsForChild ( mSelected . itemView , mTmpRect ) ; if ( lm . canScrollHorizontally ( ) ) { int curX = ( int ) ( mSelectedStartX + mDx ) ; final int leftDiff = curX - mTmpRect . left - mRecyclerView . getPaddingLeft ( ) ; if ( mDx < <NUM_LIT> && leftDiff < <NUM_LIT> ) { scrollX = leftDiff ; } else if ( mDx > <NUM_LIT> ) { final int rightDiff = curX + mSelected . itemView . getWidth ( ) + mTmpRect . right - ( mRecyclerView . getWidth ( ) - mRecyclerView . getPaddingRight ( ) ) ; if ( rightDiff > <NUM_LIT> ) { scrollX = rightDiff ; } } } if ( lm . canScrollVertically ( ) ) { int curY = ( int ) ( mSelectedStartY + mDy ) ; final int topDiff = curY - mTmpRect . top - mRecyclerView . getPaddingTop ( ) ; if ( mDy < <NUM_LIT> && topDiff < <NUM_LIT> ) { scrollY = topDiff ; } else if ( mDy > <NUM_LIT> ) { final int bottomDiff = curY + mSelected . itemView . getHeight ( ) + mTmpRect . bottom - ( mRecyclerView . getHeight ( ) - mRecyclerView . getPaddingBottom ( ) ) ; if ( bottomDiff > <NUM_LIT> ) { scrollY = bottomDiff ; } } } if ( scrollX != <NUM_LIT> ) { scrollX = mCallback . interpolateOutOfBoundsScroll ( mRecyclerView , mSelected . itemView . getWidth ( ) , scrollX , mRecyclerView . getWidth ( ) , scrollDuration ) ; } if ( scrollY != <NUM_LIT> ) { scrollY = mCallback . interpolateOutOfBoundsScroll ( mRecyclerView , mSelected . itemView . getHeight ( ) , scrollY , mRecyclerView . getHeight ( ) , scrollDuration ) ; } if ( scrollX != <NUM_LIT> || scrollY != <NUM_LIT> ) { if ( mDragScrollStartTimeInMs == Long . MIN_VALUE ) { mDragScrollStartTimeInMs = now ; } mRecyclerView . scrollBy ( scrollX , scrollY ) ; return true ; } mDragScrollStartTimeInMs = Long . MIN_VALUE ; return false ; } private List < ViewHolder > findSwapTargets ( ViewHolder viewHolder ) { if ( mSwapTargets == null ) { mSwapTargets = new ArrayList < > ( ) ; mDistances = new ArrayList < > ( ) ; } else { mSwapTargets . clear ( ) ; mDistances . clear ( ) ; } final int margin = mCallback . getBoundingBoxMargin ( ) ; final int left = Math . round ( mSelectedStartX + mDx ) - margin ; final int top = Math . round ( mSelectedStartY + mDy ) - margin ; final int right = left + viewHolder . itemView . getWidth ( ) + <NUM_LIT> * margin ; final int bottom = top + viewHolder . itemView . getHeight ( ) + <NUM_LIT> * margin ; final int centerX = ( left + right ) / <NUM_LIT> ; final int centerY = ( top + bottom ) / <NUM_LIT> ; final RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; final int childCount = lm . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View other = lm . getChildAt ( i ) ; if ( other == viewHolder . itemView ) { continue ; } if ( other . getBottom ( ) < top || other . getTop ( ) > bottom || other . getRight ( ) < left || other . getLeft ( ) > right ) { continue ; } final ViewHolder otherVh = mRecyclerView . getChildViewHolder ( other ) ; if ( mCallback . canDropOver ( mRecyclerView , mSelected , otherVh ) ) { final int dx = Math . abs ( centerX - ( other . getLeft ( ) + other . getRight ( ) ) / <NUM_LIT> ) ; final int dy = Math . abs ( centerY - ( other . getTop ( ) + other . getBottom ( ) ) / <NUM_LIT> ) ; final int dist = dx * dx + dy * dy ; int pos = <NUM_LIT> ; final int cnt = mSwapTargets . size ( ) ; for ( int j = <NUM_LIT> ; j < cnt ; j ++ ) { if ( dist > mDistances . get ( j ) ) { pos ++ ; } else { break ; } } mSwapTargets . add ( pos , otherVh ) ; mDistances . add ( pos , dist ) ; } } return mSwapTargets ; } @ SuppressWarnings ( "<STR_LIT>" ) void moveIfNecessary ( ViewHolder viewHolder ) { if ( mRecyclerView . isLayoutRequested ( ) ) { return ; } if ( mActionState != ACTION_STATE_DRAG ) { return ; } final float threshold = mCallback . getMoveThreshold ( viewHolder ) ; final int x = ( int ) ( mSelectedStartX + mDx ) ; final int y = ( int ) ( mSelectedStartY + mDy ) ; if ( Math . abs ( y - viewHolder . itemView . getTop ( ) ) < viewHolder . itemView . getHeight ( ) * threshold && Math . abs ( x - viewHolder . itemView . getLeft ( ) ) < viewHolder . itemView . getWidth ( ) * threshold ) { return ; } List < ViewHolder > swapTargets = findSwapTargets ( viewHolder ) ; if ( swapTargets . size ( ) == <NUM_LIT> ) { return ; } ViewHolder target = mCallback . chooseDropTarget ( viewHolder , swapTargets , x , y ) ; if ( target == null ) { mSwapTargets . clear ( ) ; mDistances . clear ( ) ; return ; } final int toPosition = target . getAbsoluteAdapterPosition ( ) ; final int fromPosition = viewHolder . getAbsoluteAdapterPosition ( ) ; if ( mCallback . onMove ( mRecyclerView , viewHolder , target ) ) { mCallback . onMoved ( mRecyclerView , viewHolder , fromPosition , target , toPosition , x , y ) ; } } @ Override public void onChildViewAttachedToWindow ( @ NonNull View view ) { } @ Override public void onChildViewDetachedFromWindow ( @ NonNull View view ) { removeChildDrawingOrderCallbackIfNecessary ( view ) ; final ViewHolder holder = mRecyclerView . getChildViewHolder ( view ) ; if ( holder == null ) { return ; } if ( mSelected != null && holder == mSelected ) { select ( null , ACTION_STATE_IDLE ) ; } else { endRecoverAnimation ( holder , false ) ; if ( mPendingCleanup . remove ( holder . itemView ) ) { mCallback . clearView ( mRecyclerView , holder ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) void endRecoverAnimation ( ViewHolder viewHolder , boolean override ) { final int recoverAnimSize = mRecoverAnimations . size ( ) ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; if ( anim . mViewHolder == viewHolder ) { anim . mOverridden |= override ; if ( ! anim . mEnded ) { anim . cancel ( ) ; } mRecoverAnimations . remove ( i ) ; return ; } } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { outRect . setEmpty ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void obtainVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; } mVelocityTracker = VelocityTracker . obtain ( ) ; } private void releaseVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } } private ViewHolder findSwipedView ( MotionEvent motionEvent ) { final RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; if ( mActivePointerId == ACTIVE_POINTER_ID_NONE ) { return null ; } final int pointerIndex = motionEvent . findPointerIndex ( mActivePointerId ) ; final float dx = motionEvent . getX ( pointerIndex ) - mInitialTouchX ; final float dy = motionEvent . getY ( pointerIndex ) - mInitialTouchY ; final float absDx = Math . abs ( dx ) ; final float absDy = Math . abs ( dy ) ; if ( absDx < mSlop && absDy < mSlop ) { return null ; } if ( absDx > absDy && lm . canScrollHorizontally ( ) ) { return null ; } else if ( absDy > absDx && lm . canScrollVertically ( ) ) { return null ; } View child = findChildView ( motionEvent ) ; if ( child == null ) { return null ; } return mRecyclerView . getChildViewHolder ( child ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void checkSelectForSwipe ( int action , MotionEvent motionEvent , int pointerIndex ) { if ( mSelected != null || action != MotionEvent . ACTION_MOVE || mActionState == ACTION_STATE_DRAG || ! mCallback . isItemViewSwipeEnabled ( ) ) { return ; } if ( mRecyclerView . getScrollState ( ) == RecyclerView . SCROLL_STATE_DRAGGING ) { return ; } final ViewHolder vh = findSwipedView ( motionEvent ) ; if ( vh == null ) { return ; } final int movementFlags = mCallback . getAbsoluteMovementFlags ( mRecyclerView , vh ) ; final int swipeFlags = ( movementFlags & ACTION_MODE_SWIPE_MASK ) > > ( DIRECTION_FLAG_COUNT * ACTION_STATE_SWIPE ) ; if ( swipeFlags == <NUM_LIT> ) { return ; } final float x = motionEvent . getX ( pointerIndex ) ; final float y = motionEvent . getY ( pointerIndex ) ; final float dx = x - mInitialTouchX ; final float dy = y - mInitialTouchY ; final float absDx = Math . abs ( dx ) ; final float absDy = Math . abs ( dy ) ; if ( absDx < mSlop && absDy < mSlop ) { return ; } if ( absDx > absDy ) { if ( dx < <NUM_LIT> && ( swipeFlags & LEFT ) == <NUM_LIT> ) { return ; } if ( dx > <NUM_LIT> && ( swipeFlags & RIGHT ) == <NUM_LIT> ) { return ; } } else { if ( dy < <NUM_LIT> && ( swipeFlags & UP ) == <NUM_LIT> ) { return ; } if ( dy > <NUM_LIT> && ( swipeFlags & DOWN ) == <NUM_LIT> ) { return ; } } mDx = mDy = <NUM_LIT> ; mActivePointerId = motionEvent . getPointerId ( <NUM_LIT> ) ; select ( vh , ACTION_STATE_SWIPE ) ; } @ SuppressWarnings ( "<STR_LIT>" ) View findChildView ( MotionEvent event ) { final float x = event . getX ( ) ; final float y = event . getY ( ) ; if ( mSelected != null ) { final View selectedView = mSelected . itemView ; if ( hitTest ( selectedView , x , y , mSelectedStartX + mDx , mSelectedStartY + mDy ) ) { return selectedView ; } } for ( int i = mRecoverAnimations . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; final View view = anim . mViewHolder . itemView ; if ( hitTest ( view , x , y , anim . mX , anim . mY ) ) { return view ; } } return mRecyclerView . findChildViewUnder ( x , y ) ; } public void startDrag ( @ NonNull ViewHolder viewHolder ) { if ( ! mCallback . hasDragFlag ( mRecyclerView , viewHolder ) ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } if ( viewHolder . itemView . getParent ( ) != mRecyclerView ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } obtainVelocityTracker ( ) ; mDx = mDy = <NUM_LIT> ; select ( viewHolder , ACTION_STATE_DRAG ) ; } public void startSwipe ( @ NonNull ViewHolder viewHolder ) { if ( ! mCallback . hasSwipeFlag ( mRecyclerView , viewHolder ) ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } if ( viewHolder . itemView . getParent ( ) != mRecyclerView ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } obtainVelocityTracker ( ) ; mDx = mDy = <NUM_LIT> ; select ( viewHolder , ACTION_STATE_SWIPE ) ; } @ SuppressWarnings ( "<STR_LIT>" ) RecoverAnimation findAnimation ( MotionEvent event ) { if ( mRecoverAnimations . isEmpty ( ) ) { return null ; } View target = findChildView ( event ) ; for ( int i = mRecoverAnimations . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; if ( anim . mViewHolder . itemView == target ) { return anim ; } } return null ; } @ SuppressWarnings ( "<STR_LIT>" ) void updateDxDy ( MotionEvent ev , int directionFlags , int pointerIndex ) { final float x = ev . getX ( pointerIndex ) ; final float y = ev . getY ( pointerIndex ) ; mDx = x - mInitialTouchX ; mDy = y - mInitialTouchY ; if ( ( directionFlags & LEFT ) == <NUM_LIT> ) { mDx = Math . max ( <NUM_LIT> , mDx ) ; } if ( ( directionFlags & RIGHT ) == <NUM_LIT> ) { mDx = Math . min ( <NUM_LIT> , mDx ) ; } if ( ( directionFlags & UP ) == <NUM_LIT> ) { mDy = Math . max ( <NUM_LIT> , mDy ) ; } if ( ( directionFlags & DOWN ) == <NUM_LIT> ) { mDy = Math . min ( <NUM_LIT> , mDy ) ; } } private int swipeIfNecessary ( ViewHolder viewHolder ) { if ( mActionState == ACTION_STATE_DRAG ) { return <NUM_LIT> ; } final int originalMovementFlags = mCallback . getMovementFlags ( mRecyclerView , viewHolder ) ; final int absoluteMovementFlags = mCallback . convertToAbsoluteDirection ( originalMovementFlags , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; final int flags = ( absoluteMovementFlags & ACTION_MODE_SWIPE_MASK ) > > ( ACTION_STATE_SWIPE * DIRECTION_FLAG_COUNT ) ; if ( flags == <NUM_LIT> ) { return <NUM_LIT> ; } final int originalFlags = ( originalMovementFlags & ACTION_MODE_SWIPE_MASK ) > > ( ACTION_STATE_SWIPE * DIRECTION_FLAG_COUNT ) ; int swipeDir ; if ( Math . abs ( mDx ) > Math . abs ( mDy ) ) { if ( ( swipeDir = checkHorizontalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { if ( ( originalFlags & swipeDir ) == <NUM_LIT> ) { return Callback . convertToRelativeDirection ( swipeDir , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; } return swipeDir ; } if ( ( swipeDir = checkVerticalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { return swipeDir ; } } else { if ( ( swipeDir = checkVerticalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { return swipeDir ; } if ( ( swipeDir = checkHorizontalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { if ( ( originalFlags & swipeDir ) == <NUM_LIT> ) { return Callback . convertToRelativeDirection ( swipeDir , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; } return swipeDir ; } } return <NUM_LIT> ; } private int checkHorizontalSwipe ( ViewHolder viewHolder , int flags ) { if ( ( flags & ( LEFT | RIGHT ) ) != <NUM_LIT> ) { final int dirFlag = mDx > <NUM_LIT> ? RIGHT : LEFT ; if ( mVelocityTracker != null && mActivePointerId > - <NUM_LIT> ) { mVelocityTracker . computeCurrentVelocity ( PIXELS_PER_SECOND , mCallback . getSwipeVelocityThreshold ( mMaxSwipeVelocity ) ) ; final float xVelocity = mVelocityTracker . getXVelocity ( mActivePointerId ) ; final float yVelocity = mVelocityTracker . getYVelocity ( mActivePointerId ) ; final int velDirFlag = xVelocity > <NUM_LIT> ? RIGHT : LEFT ; final float absXVelocity = Math . abs ( xVelocity ) ; if ( ( velDirFlag & flags ) != <NUM_LIT> && dirFlag == velDirFlag && absXVelocity >= mCallback . getSwipeEscapeVelocity ( mSwipeEscapeVelocity ) && absXVelocity > Math . abs ( yVelocity ) ) { return velDirFlag ; } } final float threshold = mRecyclerView . getWidth ( ) * mCallback . getSwipeThreshold ( viewHolder ) ; if ( ( flags & dirFlag ) != <NUM_LIT> && Math . abs ( mDx ) > threshold ) { return dirFlag ; } } return <NUM_LIT> ; } private int checkVerticalSwipe ( ViewHolder viewHolder , int flags ) { if ( ( flags & ( UP | DOWN ) ) != <NUM_LIT> ) { final int dirFlag = mDy > <NUM_LIT> ? DOWN : UP ; if ( mVelocityTracker != null && mActivePointerId > - <NUM_LIT> ) { mVelocityTracker . computeCurrentVelocity ( PIXELS_PER_SECOND , mCallback . getSwipeVelocityThreshold ( mMaxSwipeVelocity ) ) ; final float xVelocity = mVelocityTracker . getXVelocity ( mActivePointerId ) ; final float yVelocity = mVelocityTracker . getYVelocity ( mActivePointerId ) ; final int velDirFlag = yVelocity > <NUM_LIT> ? DOWN : UP ; final float absYVelocity = Math . abs ( yVelocity ) ; if ( ( velDirFlag & flags ) != <NUM_LIT> && velDirFlag == dirFlag && absYVelocity >= mCallback . getSwipeEscapeVelocity ( mSwipeEscapeVelocity ) && absYVelocity > Math . abs ( xVelocity ) ) { return velDirFlag ; } } final float threshold = mRecyclerView . getHeight ( ) * mCallback . getSwipeThreshold ( viewHolder ) ; if ( ( flags & dirFlag ) != <NUM_LIT> && Math . abs ( mDy ) > threshold ) { return dirFlag ; } } return <NUM_LIT> ; } private void addChildDrawingOrderCallback ( ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { return ; } if ( mChildDrawingOrderCallback == null ) { mChildDrawingOrderCallback = new RecyclerView . ChildDrawingOrderCallback ( ) { @ Override public int onGetChildDrawingOrder ( int childCount , int i ) { if ( mOverdrawChild == null ) { return i ; } int childPosition = mOverdrawChildPosition ; if ( childPosition == - <NUM_LIT> ) { childPosition = mRecyclerView . indexOfChild ( mOverdrawChild ) ; mOverdrawChildPosition = childPosition ; } if ( i == childCount - <NUM_LIT> ) { return childPosition ; } return i < childPosition ? i : i + <NUM_LIT> ; } } ; } mRecyclerView . setChildDrawingOrderCallback ( mChildDrawingOrderCallback ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void removeChildDrawingOrderCallbackIfNecessary ( View view ) { if ( view == mOverdrawChild ) { mOverdrawChild = null ; if ( mChildDrawingOrderCallback != null ) { mRecyclerView . setChildDrawingOrderCallback ( null ) ; } } } public interface ViewDropHandler { void prepareForDrop ( @ NonNull View view , @ NonNull View target , int x , int y ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public abstract static class Callback { @ SuppressWarnings ( "<STR_LIT>" ) public static final int DEFAULT_DRAG_ANIMATION_DURATION = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int DEFAULT_SWIPE_ANIMATION_DURATION = <NUM_LIT> ; static final int RELATIVE_DIR_FLAGS = START | END | ( ( START | END ) << DIRECTION_FLAG_COUNT ) | ( ( START | END ) << ( <NUM_LIT> * DIRECTION_FLAG_COUNT ) ) ; private static final int ABS_HORIZONTAL_DIR_FLAGS = LEFT | RIGHT | ( ( LEFT | RIGHT ) << DIRECTION_FLAG_COUNT ) | ( ( LEFT | RIGHT ) << ( <NUM_LIT> * DIRECTION_FLAG_COUNT ) ) ; private static final Interpolator sDragScrollInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { return t * t * t * t * t ; } } ; private static final Interpolator sDragViewScrollCapInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { t -= <NUM_LIT> ; return t * t * t * t * t + <NUM_LIT> ; } } ; private static final long DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS = <NUM_LIT> ; private int mCachedMaxScrollSpeed = - <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public static ItemTouchUIUtil getDefaultUIUtil ( ) { return ItemTouchUIUtilImpl . INSTANCE ; } @ SuppressWarnings ( "<STR_LIT>" ) public static int convertToRelativeDirection ( int flags , int layoutDirection ) { int masked = flags & ABS_HORIZONTAL_DIR_FLAGS ; if ( masked == <NUM_LIT> ) { return flags ; } flags &= ~ masked ; if ( layoutDirection == ViewCompat . LAYOUT_DIRECTION_LTR ) { flags |= masked << <NUM_LIT> ; return flags ; } else { flags |= ( ( masked << <NUM_LIT> ) & ~ ABS_HORIZONTAL_DIR_FLAGS ) ; flags |= ( ( masked << <NUM_LIT> ) & ABS_HORIZONTAL_DIR_FLAGS ) << <NUM_LIT> ; } return flags ; } public static int makeMovementFlags ( int dragFlags , int swipeFlags ) { return makeFlag ( ACTION_STATE_IDLE , swipeFlags | dragFlags ) | makeFlag ( ACTION_STATE_SWIPE , swipeFlags ) | makeFlag ( ACTION_STATE_DRAG , dragFlags ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public static int makeFlag ( int actionState , int directions ) { return directions << ( actionState * DIRECTION_FLAG_COUNT ) ; } public abstract int getMovementFlags ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) ; @ SuppressWarnings ( "<STR_LIT>" ) public int convertToAbsoluteDirection ( int flags , int layoutDirection ) { int masked = flags & RELATIVE_DIR_FLAGS ; if ( masked == <NUM_LIT> ) { return flags ; } flags &= ~ masked ; if ( layoutDirection == ViewCompat . LAYOUT_DIRECTION_LTR ) { flags |= masked > > <NUM_LIT> ; return flags ; } else { flags |= ( ( masked > > <NUM_LIT> ) & ~ RELATIVE_DIR_FLAGS ) ; flags |= ( ( masked > > <NUM_LIT> ) & RELATIVE_DIR_FLAGS ) > > <NUM_LIT> ; } return flags ; } final int getAbsoluteMovementFlags ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getMovementFlags ( recyclerView , viewHolder ) ; return convertToAbsoluteDirection ( flags , ViewCompat . getLayoutDirection ( recyclerView ) ) ; } boolean hasDragFlag ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getAbsoluteMovementFlags ( recyclerView , viewHolder ) ; return ( flags & ACTION_MODE_DRAG_MASK ) != <NUM_LIT> ; } boolean hasSwipeFlag ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getAbsoluteMovementFlags ( recyclerView , viewHolder ) ; return ( flags & ACTION_MODE_SWIPE_MASK ) != <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public boolean canDropOver ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder current , @ NonNull ViewHolder target ) { return true ; } public abstract boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder , @ NonNull ViewHolder target ) ; public boolean isLongPressDragEnabled ( ) { return true ; } public boolean isItemViewSwipeEnabled ( ) { return true ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getBoundingBoxMargin ( ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeThreshold ( @ NonNull ViewHolder viewHolder ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getMoveThreshold ( @ NonNull ViewHolder viewHolder ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeEscapeVelocity ( float defaultValue ) { return defaultValue ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeVelocityThreshold ( float defaultValue ) { return defaultValue ; } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public ViewHolder chooseDropTarget ( @ NonNull ViewHolder selected , @ NonNull List < ViewHolder > dropTargets , int curX , int curY ) { int right = curX + selected . itemView . getWidth ( ) ; int bottom = curY + selected . itemView . getHeight ( ) ; ViewHolder winner = null ; int winnerScore = - <NUM_LIT> ; final int dx = curX - selected . itemView . getLeft ( ) ; final int dy = curY - selected . itemView . getTop ( ) ; final int targetsSize = dropTargets . size ( ) ; for ( int i = <NUM_LIT> ; i < targetsSize ; i ++ ) { final ViewHolder target = dropTargets . get ( i ) ; if ( dx > <NUM_LIT> ) { int diff = target . itemView . getRight ( ) - right ; if ( diff < <NUM_LIT> && target . itemView . getRight ( ) > selected . itemView . getRight ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dx < <NUM_LIT> ) { int diff = target . itemView . getLeft ( ) - curX ; if ( diff > <NUM_LIT> && target . itemView . getLeft ( ) < selected . itemView . getLeft ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dy < <NUM_LIT> ) { int diff = target . itemView . getTop ( ) - curY ; if ( diff > <NUM_LIT> && target . itemView . getTop ( ) < selected . itemView . getTop ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dy > <NUM_LIT> ) { int diff = target . itemView . getBottom ( ) - bottom ; if ( diff < <NUM_LIT> && target . itemView . getBottom ( ) > selected . itemView . getBottom ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } } return winner ; } public abstract void onSwiped ( @ NonNull ViewHolder viewHolder , int direction ) ; public void onSelectedChanged ( @ Nullable ViewHolder viewHolder , int actionState ) { if ( viewHolder != null ) { ItemTouchUIUtilImpl . INSTANCE . onSelected ( viewHolder . itemView ) ; } } private int getMaxDragScroll ( RecyclerView recyclerView ) { if ( mCachedMaxScrollSpeed == - <NUM_LIT> ) { mCachedMaxScrollSpeed = recyclerView . getResources ( ) . getDimensionPixelSize ( R . dimen . item_touch_helper_max_drag_scroll_per_frame ) ; } return mCachedMaxScrollSpeed ; } public void onMoved ( @ NonNull final RecyclerView recyclerView , @ NonNull final ViewHolder viewHolder , int fromPos , @ NonNull final ViewHolder target , int toPos , int x , int y ) { final RecyclerView . LayoutManager layoutManager = recyclerView . getLayoutManager ( ) ; if ( layoutManager instanceof ViewDropHandler ) { ( ( ViewDropHandler ) layoutManager ) . prepareForDrop ( viewHolder . itemView , target . itemView , x , y ) ; return ; } if ( layoutManager . canScrollHorizontally ( ) ) { final int minLeft = layoutManager . getDecoratedLeft ( target . itemView ) ; if ( minLeft <= recyclerView . getPaddingLeft ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } final int maxRight = layoutManager . getDecoratedRight ( target . itemView ) ; if ( maxRight >= recyclerView . getWidth ( ) - recyclerView . getPaddingRight ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } } if ( layoutManager . canScrollVertically ( ) ) { final int minTop = layoutManager . getDecoratedTop ( target . itemView ) ; if ( minTop <= recyclerView . getPaddingTop ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } final int maxBottom = layoutManager . getDecoratedBottom ( target . itemView ) ; if ( maxBottom >= recyclerView . getHeight ( ) - recyclerView . getPaddingBottom ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } } } void onDraw ( Canvas c , RecyclerView parent , ViewHolder selected , List < ItemTouchHelper . RecoverAnimation > recoverAnimationList , int actionState , float dX , float dY ) { final int recoverAnimSize = recoverAnimationList . size ( ) ; for ( int i = <NUM_LIT> ; i < recoverAnimSize ; i ++ ) { final ItemTouchHelper . RecoverAnimation anim = recoverAnimationList . get ( i ) ; anim . update ( ) ; final int count = c . save ( ) ; onChildDraw ( c , parent , anim . mViewHolder , anim . mX , anim . mY , anim . mActionState , false ) ; c . restoreToCount ( count ) ; } if ( selected != null ) { final int count = c . save ( ) ; onChildDraw ( c , parent , selected , dX , dY , actionState , true ) ; c . restoreToCount ( count ) ; } } void onDrawOver ( Canvas c , RecyclerView parent , ViewHolder selected , List < ItemTouchHelper . RecoverAnimation > recoverAnimationList , int actionState , float dX , float dY ) { final int recoverAnimSize = recoverAnimationList . size ( ) ; for ( int i = <NUM_LIT> ; i < recoverAnimSize ; i ++ ) { final ItemTouchHelper . RecoverAnimation anim = recoverAnimationList . get ( i ) ; final int count = c . save ( ) ; onChildDrawOver ( c , parent , anim . mViewHolder , anim . mX , anim . mY , anim . mActionState , false ) ; c . restoreToCount ( count ) ; } if ( selected != null ) { final int count = c . save ( ) ; onChildDrawOver ( c , parent , selected , dX , dY , actionState , true ) ; c . restoreToCount ( count ) ; } boolean hasRunningAnimation = false ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = recoverAnimationList . get ( i ) ; if ( anim . mEnded && ! anim . mIsPendingCleanup ) { recoverAnimationList . remove ( i ) ; } else if ( ! anim . mEnded ) { hasRunningAnimation = true ; } } if ( hasRunningAnimation ) { parent . invalidate ( ) ; } } public void clearView ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) { ItemTouchUIUtilImpl . INSTANCE . clearView ( viewHolder . itemView ) ; } public void onChildDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder , float dX , float dY , int actionState , boolean isCurrentlyActive ) { ItemTouchUIUtilImpl . INSTANCE . onDraw ( c , recyclerView , viewHolder . itemView , dX , dY , actionState , isCurrentlyActive ) ; } public void onChildDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ SuppressLint ( "<STR_LIT>" ) ViewHolder viewHolder , float dX , float dY , int actionState , boolean isCurrentlyActive ) { ItemTouchUIUtilImpl . INSTANCE . onDrawOver ( c , recyclerView , viewHolder . itemView , dX , dY , actionState , isCurrentlyActive ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public long getAnimationDuration ( @ NonNull RecyclerView recyclerView , int animationType , float animateDx , float animateDy ) { final RecyclerView . ItemAnimator itemAnimator = recyclerView . getItemAnimator ( ) ; if ( itemAnimator == null ) { return animationType == ANIMATION_TYPE_DRAG ? DEFAULT_DRAG_ANIMATION_DURATION : DEFAULT_SWIPE_ANIMATION_DURATION ; } else { return animationType == ANIMATION_TYPE_DRAG ? itemAnimator . getMoveDuration ( ) : itemAnimator . getRemoveDuration ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public int interpolateOutOfBoundsScroll ( @ NonNull RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( <NUM_LIT> , <NUM_LIT> * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = <NUM_LIT> ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == <NUM_LIT> ) { return viewSizeOutOfBounds > <NUM_LIT> ? <NUM_LIT> : - <NUM_LIT> ; } return value ; } } public abstract static class SimpleCallback extends Callback { private int mDefaultSwipeDirs ; private int mDefaultDragDirs ; public SimpleCallback ( int dragDirs , int swipeDirs ) { mDefaultSwipeDirs = swipeDirs ; mDefaultDragDirs = dragDirs ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public void setDefaultSwipeDirs ( @ SuppressWarnings ( "<STR_LIT>" ) int defaultSwipeDirs ) { mDefaultSwipeDirs = defaultSwipeDirs ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public void setDefaultDragDirs ( @ SuppressWarnings ( "<STR_LIT>" ) int defaultDragDirs ) { mDefaultDragDirs = defaultDragDirs ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getSwipeDirs ( @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull RecyclerView recyclerView , @ NonNull @ SuppressWarnings ( "<STR_LIT>" ) ViewHolder viewHolder ) { return mDefaultSwipeDirs ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getDragDirs ( @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull RecyclerView recyclerView , @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull ViewHolder viewHolder ) { return mDefaultDragDirs ; } @ Override public int getMovementFlags ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) { return makeMovementFlags ( getDragDirs ( recyclerView , viewHolder ) , getSwipeDirs ( recyclerView , viewHolder ) ) ; } } private class ItemTouchHelperGestureListener extends GestureDetector . SimpleOnGestureListener { private boolean mShouldReactToLongPress = true ; ItemTouchHelperGestureListener ( ) { } void doNotReactToLongPress ( ) { mShouldReactToLongPress = false ; } @ Override public boolean onDown ( MotionEvent e ) { return true ; } @ Override public void onLongPress ( MotionEvent e ) { if ( ! mShouldReactToLongPress ) { return ; } View child = findChildView ( e ) ; if ( child != null ) { ViewHolder vh = mRecyclerView . getChildViewHolder ( child ) ; if ( vh != null ) { if ( ! mCallback . hasDragFlag ( mRecyclerView , vh ) ) { return ; } int pointerId = e . getPointerId ( <NUM_LIT> ) ; if ( pointerId == mActivePointerId ) { final int index = e . findPointerIndex ( mActivePointerId ) ; final float x = e . getX ( index ) ; final float y = e . getY ( index ) ; mInitialTouchX = x ; mInitialTouchY = y ; mDx = mDy = <NUM_LIT> ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mInitialTouchX + "<STR_LIT>" + mInitialTouchY ) ; } if ( mCallback . isLongPressDragEnabled ( ) ) { select ( vh , ACTION_STATE_DRAG ) ; } } } } } } @ VisibleForTesting static class RecoverAnimation implements Animator . AnimatorListener { final float mStartDx ; final float mStartDy ; final float mTargetX ; final float mTargetY ; final ViewHolder mViewHolder ; final int mActionState ; @ VisibleForTesting final ValueAnimator mValueAnimator ; final int mAnimationType ; boolean mIsPendingCleanup ; float mX ; float mY ; boolean mOverridden = false ; boolean mEnded = false ; private float mFraction ; RecoverAnimation ( ViewHolder viewHolder , int animationType , int actionState , float startDx , float startDy , float targetX , float targetY ) { mActionState = actionState ; mAnimationType = animationType ; mViewHolder = viewHolder ; mStartDx = startDx ; mStartDy = startDy ; mTargetX = targetX ; mTargetY = targetY ; mValueAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; mValueAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { setFraction ( animation . getAnimatedFraction ( ) ) ; } } ) ; mValueAnimator . setTarget ( viewHolder . itemView ) ; mValueAnimator . addListener ( this ) ; setFraction ( <NUM_LIT> ) ; } public void setDuration ( long duration ) { mValueAnimator . setDuration ( duration ) ; } public void start ( ) { mViewHolder . setIsRecyclable ( false ) ; mValueAnimator . start ( ) ; } public void cancel ( ) { mValueAnimator . cancel ( ) ; } public void setFraction ( float fraction ) { mFraction = fraction ; } public void update ( ) { if ( mStartDx == mTargetX ) { mX = mViewHolder . itemView . getTranslationX ( ) ; } else { mX = mStartDx + mFraction * ( mTargetX - mStartDx ) ; } if ( mStartDy == mTargetY ) { mY = mViewHolder . itemView . getTranslationY ( ) ; } else { mY = mStartDy + mFraction * ( mTargetY - mStartDy ) ; } } @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { if ( ! mEnded ) { mViewHolder . setIsRecyclable ( true ) ; } mEnded = true ; } @ Override public void onAnimationCancel ( Animator animation ) { setFraction ( <NUM_LIT> ) ; } @ Override public void onAnimationRepeat ( Animator animation ) { } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . RestrictTo ; import androidx . core . os . TraceCompat ; import androidx . core . view . ViewCompat ; import java . util . List ; public class LinearLayoutManager extends RecyclerView . LayoutManager implements ItemTouchHelper . ViewDropHandler , RecyclerView . SmoothScroller . ScrollVectorProvider { private static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; public static final int INVALID_OFFSET = Integer . MIN_VALUE ; private static final float MAX_SCROLL_FACTOR = <NUM_LIT> / <NUM_LIT> ; @ RecyclerView . Orientation int mOrientation = RecyclerView . DEFAULT_ORIENTATION ; private LayoutState mLayoutState ; OrientationHelper mOrientationHelper ; private boolean mLastStackFromEnd ; private boolean mReverseLayout = false ; boolean mShouldReverseLayout = false ; private boolean mStackFromEnd = false ; private boolean mSmoothScrollbarEnabled = true ; int mPendingScrollPosition = RecyclerView . NO_POSITION ; int mPendingScrollPositionOffset = INVALID_OFFSET ; private boolean mRecycleChildrenOnDetach ; SavedState mPendingSavedState = null ; final AnchorInfo mAnchorInfo = new AnchorInfo ( ) ; private final LayoutChunkResult mLayoutChunkResult = new LayoutChunkResult ( ) ; private int mInitialPrefetchItemCount = <NUM_LIT> ; private int [ ] mReusableIntPair = new int [ <NUM_LIT> ] ; public LinearLayoutManager ( @ SuppressLint ( "<STR_LIT>" ) Context context ) { this ( context , RecyclerView . DEFAULT_ORIENTATION , false ) ; } public LinearLayoutManager ( @ SuppressLint ( "<STR_LIT>" ) Context context , @ RecyclerView . Orientation int orientation , boolean reverseLayout ) { setOrientation ( orientation ) ; setReverseLayout ( reverseLayout ) ; } @ SuppressLint ( "<STR_LIT>" ) public LinearLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setOrientation ( properties . orientation ) ; setReverseLayout ( properties . reverseLayout ) ; setStackFromEnd ( properties . stackFromEnd ) ; } @ Override public boolean isAutoMeasureEnabled ( ) { return true ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { return new RecyclerView . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } public boolean getRecycleChildrenOnDetach ( ) { return mRecycleChildrenOnDetach ; } public void setRecycleChildrenOnDetach ( boolean recycleChildrenOnDetach ) { mRecycleChildrenOnDetach = recycleChildrenOnDetach ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDetachedFromWindow ( RecyclerView view , RecyclerView . Recycler recycler ) { super . onDetachedFromWindow ( view , recycler ) ; if ( mRecycleChildrenOnDetach ) { removeAndRecycleAllViews ( recycler ) ; recycler . clear ( ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onInitializeAccessibilityEvent ( AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; if ( getChildCount ( ) > <NUM_LIT> ) { event . setFromIndex ( findFirstVisibleItemPosition ( ) ) ; event . setToIndex ( findLastVisibleItemPosition ( ) ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public Parcelable onSaveInstanceState ( ) { if ( mPendingSavedState != null ) { return new SavedState ( mPendingSavedState ) ; } SavedState state = new SavedState ( ) ; if ( getChildCount ( ) > <NUM_LIT> ) { ensureLayoutState ( ) ; boolean didLayoutFromEnd = mLastStackFromEnd ^ mShouldReverseLayout ; state . mAnchorLayoutFromEnd = didLayoutFromEnd ; if ( didLayoutFromEnd ) { final View refChild = getChildClosestToEnd ( ) ; state . mAnchorOffset = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( refChild ) ; state . mAnchorPosition = getPosition ( refChild ) ; } else { final View refChild = getChildClosestToStart ( ) ; state . mAnchorPosition = getPosition ( refChild ) ; state . mAnchorOffset = mOrientationHelper . getDecoratedStart ( refChild ) - mOrientationHelper . getStartAfterPadding ( ) ; } } else { state . invalidateAnchor ( ) ; } return state ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof SavedState ) { mPendingSavedState = ( SavedState ) state ; if ( mPendingScrollPosition != RecyclerView . NO_POSITION ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } else if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } @ Override public boolean canScrollHorizontally ( ) { return mOrientation == HORIZONTAL ; } @ Override public boolean canScrollVertically ( ) { return mOrientation == VERTICAL ; } public void setStackFromEnd ( boolean stackFromEnd ) { assertNotInLayoutOrScroll ( null ) ; if ( mStackFromEnd == stackFromEnd ) { return ; } mStackFromEnd = stackFromEnd ; requestLayout ( ) ; } public boolean getStackFromEnd ( ) { return mStackFromEnd ; } @ RecyclerView . Orientation public int getOrientation ( ) { return mOrientation ; } public void setOrientation ( @ RecyclerView . Orientation int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" + orientation ) ; } assertNotInLayoutOrScroll ( null ) ; if ( orientation != mOrientation || mOrientationHelper == null ) { mOrientationHelper = OrientationHelper . createOrientationHelper ( this , orientation ) ; mAnchorInfo . mOrientationHelper = mOrientationHelper ; mOrientation = orientation ; requestLayout ( ) ; } } private void resolveShouldLayoutReverse ( ) { if ( mOrientation == VERTICAL || ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } public boolean getReverseLayout ( ) { return mReverseLayout ; } public void setReverseLayout ( boolean reverseLayout ) { assertNotInLayoutOrScroll ( null ) ; if ( reverseLayout == mReverseLayout ) { return ; } mReverseLayout = reverseLayout ; requestLayout ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public View findViewByPosition ( int position ) { final int childCount = getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } final int firstChild = getPosition ( getChildAt ( <NUM_LIT> ) ) ; final int viewPosition = position - firstChild ; if ( viewPosition >= <NUM_LIT> && viewPosition < childCount ) { final View child = getChildAt ( viewPosition ) ; if ( getPosition ( child ) == position ) { return child ; } } return super . findViewByPosition ( position ) ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Deprecated protected int getExtraLayoutSpace ( RecyclerView . State state ) { if ( state . hasTargetScrollPosition ( ) ) { return mOrientationHelper . getTotalSpace ( ) ; } else { return <NUM_LIT> ; } } protected void calculateExtraLayoutSpace ( @ NonNull RecyclerView . State state , @ NonNull int [ ] extraLayoutSpace ) { int extraLayoutSpaceStart = <NUM_LIT> ; int extraLayoutSpaceEnd = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) int extraScrollSpace = getExtraLayoutSpace ( state ) ; if ( mLayoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { extraLayoutSpaceStart = extraScrollSpace ; } else { extraLayoutSpaceEnd = extraScrollSpace ; } extraLayoutSpace [ <NUM_LIT> ] = extraLayoutSpaceStart ; extraLayoutSpace [ <NUM_LIT> ] = extraLayoutSpaceEnd ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void smoothScrollToPosition ( RecyclerView recyclerView , RecyclerView . State state , int position ) { LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller ( recyclerView . getContext ( ) ) ; linearSmoothScroller . setTargetPosition ( position ) ; startSmoothScroll ( linearSmoothScroller ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public PointF computeScrollVectorForPosition ( int targetPosition ) { if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final int firstChildPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; final int direction = targetPosition < firstChildPos != mShouldReverseLayout ? - <NUM_LIT> : <NUM_LIT> ; if ( mOrientation == HORIZONTAL ) { return new PointF ( direction , <NUM_LIT> ) ; } else { return new PointF ( <NUM_LIT> , direction ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + state . isPreLayout ( ) ) ; } if ( mPendingSavedState != null || mPendingScrollPosition != RecyclerView . NO_POSITION ) { if ( state . getItemCount ( ) == <NUM_LIT> ) { removeAndRecycleAllViews ( recycler ) ; return ; } } if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { mPendingScrollPosition = mPendingSavedState . mAnchorPosition ; } ensureLayoutState ( ) ; mLayoutState . mRecycle = false ; resolveShouldLayoutReverse ( ) ; final View focused = getFocusedChild ( ) ; if ( ! mAnchorInfo . mValid || mPendingScrollPosition != RecyclerView . NO_POSITION || mPendingSavedState != null ) { mAnchorInfo . reset ( ) ; mAnchorInfo . mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd ; updateAnchorInfoForLayout ( recycler , state , mAnchorInfo ) ; mAnchorInfo . mValid = true ; } else if ( focused != null && ( mOrientationHelper . getDecoratedStart ( focused ) >= mOrientationHelper . getEndAfterPadding ( ) || mOrientationHelper . getDecoratedEnd ( focused ) <= mOrientationHelper . getStartAfterPadding ( ) ) ) { mAnchorInfo . assignFromViewAndKeepVisibleRect ( focused , getPosition ( focused ) ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mAnchorInfo ) ; } mLayoutState . mLayoutDirection = mLayoutState . mLastScrollDelta >= <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; calculateExtraLayoutSpace ( state , mReusableIntPair ) ; int extraForStart = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) + mOrientationHelper . getStartAfterPadding ( ) ; int extraForEnd = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) + mOrientationHelper . getEndPadding ( ) ; if ( state . isPreLayout ( ) && mPendingScrollPosition != RecyclerView . NO_POSITION && mPendingScrollPositionOffset != INVALID_OFFSET ) { final View existing = findViewByPosition ( mPendingScrollPosition ) ; if ( existing != null ) { final int current ; final int upcomingOffset ; if ( mShouldReverseLayout ) { current = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( existing ) ; upcomingOffset = current - mPendingScrollPositionOffset ; } else { current = mOrientationHelper . getDecoratedStart ( existing ) - mOrientationHelper . getStartAfterPadding ( ) ; upcomingOffset = mPendingScrollPositionOffset - current ; } if ( upcomingOffset > <NUM_LIT> ) { extraForStart += upcomingOffset ; } else { extraForEnd -= upcomingOffset ; } } } int startOffset ; int endOffset ; final int firstLayoutDirection ; if ( mAnchorInfo . mLayoutFromEnd ) { firstLayoutDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; } else { firstLayoutDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; } onAnchorReady ( recycler , state , mAnchorInfo , firstLayoutDirection ) ; detachAndScrapAttachedViews ( recycler ) ; mLayoutState . mInfinite = resolveIsInfinite ( ) ; mLayoutState . mIsPreLayout = state . isPreLayout ( ) ; mLayoutState . mNoRecycleSpace = <NUM_LIT> ; if ( mAnchorInfo . mLayoutFromEnd ) { updateLayoutStateToFillStart ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForStart ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; final int firstElement = mLayoutState . mCurrentPosition ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForEnd += mLayoutState . mAvailable ; } updateLayoutStateToFillEnd ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForEnd ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForStart = mLayoutState . mAvailable ; updateLayoutStateToFillStart ( firstElement , startOffset ) ; mLayoutState . mExtraFillSpace = extraForStart ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; } } else { updateLayoutStateToFillEnd ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForEnd ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; final int lastElement = mLayoutState . mCurrentPosition ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForStart += mLayoutState . mAvailable ; } updateLayoutStateToFillStart ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForStart ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForEnd = mLayoutState . mAvailable ; updateLayoutStateToFillEnd ( lastElement , endOffset ) ; mLayoutState . mExtraFillSpace = extraForEnd ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; } } if ( getChildCount ( ) > <NUM_LIT> ) { if ( mShouldReverseLayout ^ mStackFromEnd ) { int fixOffset = fixLayoutEndGap ( endOffset , recycler , state , true ) ; startOffset += fixOffset ; endOffset += fixOffset ; fixOffset = fixLayoutStartGap ( startOffset , recycler , state , false ) ; startOffset += fixOffset ; endOffset += fixOffset ; } else { int fixOffset = fixLayoutStartGap ( startOffset , recycler , state , true ) ; startOffset += fixOffset ; endOffset += fixOffset ; fixOffset = fixLayoutEndGap ( endOffset , recycler , state , false ) ; startOffset += fixOffset ; endOffset += fixOffset ; } } layoutForPredictiveAnimations ( recycler , state , startOffset , endOffset ) ; if ( ! state . isPreLayout ( ) ) { mOrientationHelper . onLayoutComplete ( ) ; } else { mAnchorInfo . reset ( ) ; } mLastStackFromEnd = mStackFromEnd ; if ( DEBUG ) { validateChildOrder ( ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingSavedState = null ; mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; mAnchorInfo . reset ( ) ; } void onAnchorReady ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int firstLayoutItemDirection ) { } private void layoutForPredictiveAnimations ( RecyclerView . Recycler recycler , RecyclerView . State state , int startOffset , int endOffset ) { if ( ! state . willRunPredictiveAnimations ( ) || getChildCount ( ) == <NUM_LIT> || state . isPreLayout ( ) || ! supportsPredictiveItemAnimations ( ) ) { return ; } int scrapExtraStart = <NUM_LIT> , scrapExtraEnd = <NUM_LIT> ; final List < RecyclerView . ViewHolder > scrapList = recycler . getScrapList ( ) ; final int scrapSize = scrapList . size ( ) ; final int firstChildPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; for ( int i = <NUM_LIT> ; i < scrapSize ; i ++ ) { RecyclerView . ViewHolder scrap = scrapList . get ( i ) ; if ( scrap . isRemoved ( ) ) { continue ; } final int position = scrap . getLayoutPosition ( ) ; final int direction = position < firstChildPos != mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; if ( direction == LayoutState . LAYOUT_START ) { scrapExtraStart += mOrientationHelper . getDecoratedMeasurement ( scrap . itemView ) ; } else { scrapExtraEnd += mOrientationHelper . getDecoratedMeasurement ( scrap . itemView ) ; } } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + scrapExtraStart + "<STR_LIT>" + scrapExtraEnd + "<STR_LIT>" ) ; } mLayoutState . mScrapList = scrapList ; if ( scrapExtraStart > <NUM_LIT> ) { View anchor = getChildClosestToStart ( ) ; updateLayoutStateToFillStart ( getPosition ( anchor ) , startOffset ) ; mLayoutState . mExtraFillSpace = scrapExtraStart ; mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . assignPositionFromScrapList ( ) ; fill ( recycler , mLayoutState , state , false ) ; } if ( scrapExtraEnd > <NUM_LIT> ) { View anchor = getChildClosestToEnd ( ) ; updateLayoutStateToFillEnd ( getPosition ( anchor ) , endOffset ) ; mLayoutState . mExtraFillSpace = scrapExtraEnd ; mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . assignPositionFromScrapList ( ) ; fill ( recycler , mLayoutState , state , false ) ; } mLayoutState . mScrapList = null ; } private void updateAnchorInfoForLayout ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo ) { if ( updateAnchorFromPendingData ( state , anchorInfo ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return ; } if ( updateAnchorFromChildren ( recycler , state , anchorInfo ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } anchorInfo . assignCoordinateFromPadding ( ) ; anchorInfo . mPosition = mStackFromEnd ? state . getItemCount ( ) - <NUM_LIT> : <NUM_LIT> ; } private boolean updateAnchorFromChildren ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo ) { if ( getChildCount ( ) == <NUM_LIT> ) { return false ; } final View focused = getFocusedChild ( ) ; if ( focused != null && anchorInfo . isViewValidAsAnchor ( focused , state ) ) { anchorInfo . assignFromViewAndKeepVisibleRect ( focused , getPosition ( focused ) ) ; return true ; } if ( mLastStackFromEnd != mStackFromEnd ) { return false ; } View referenceChild = findReferenceChild ( recycler , state , anchorInfo . mLayoutFromEnd , mStackFromEnd ) ; if ( referenceChild != null ) { anchorInfo . assignFromView ( referenceChild , getPosition ( referenceChild ) ) ; if ( ! state . isPreLayout ( ) && supportsPredictiveItemAnimations ( ) ) { final int childStart = mOrientationHelper . getDecoratedStart ( referenceChild ) ; final int childEnd = mOrientationHelper . getDecoratedEnd ( referenceChild ) ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; boolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart ; boolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd ; if ( outOfBoundsBefore || outOfBoundsAfter ) { anchorInfo . mCoordinate = anchorInfo . mLayoutFromEnd ? boundsEnd : boundsStart ; } } return true ; } return false ; } private boolean updateAnchorFromPendingData ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( state . isPreLayout ( ) || mPendingScrollPosition == RecyclerView . NO_POSITION ) { return false ; } if ( mPendingScrollPosition < <NUM_LIT> || mPendingScrollPosition >= state . getItemCount ( ) ) { mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; if ( DEBUG ) { Log . e ( TAG , "<STR_LIT>" + mPendingScrollPosition ) ; } return false ; } anchorInfo . mPosition = mPendingScrollPosition ; if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { anchorInfo . mLayoutFromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; if ( anchorInfo . mLayoutFromEnd ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - mPendingSavedState . mAnchorOffset ; } else { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) + mPendingSavedState . mAnchorOffset ; } return true ; } if ( mPendingScrollPositionOffset == INVALID_OFFSET ) { View child = findViewByPosition ( mPendingScrollPosition ) ; if ( child != null ) { final int childSize = mOrientationHelper . getDecoratedMeasurement ( child ) ; if ( childSize > mOrientationHelper . getTotalSpace ( ) ) { anchorInfo . assignCoordinateFromPadding ( ) ; return true ; } final int startGap = mOrientationHelper . getDecoratedStart ( child ) - mOrientationHelper . getStartAfterPadding ( ) ; if ( startGap < <NUM_LIT> ) { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) ; anchorInfo . mLayoutFromEnd = false ; return true ; } final int endGap = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( child ) ; if ( endGap < <NUM_LIT> ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) ; anchorInfo . mLayoutFromEnd = true ; return true ; } anchorInfo . mCoordinate = anchorInfo . mLayoutFromEnd ? ( mOrientationHelper . getDecoratedEnd ( child ) + mOrientationHelper . getTotalSpaceChange ( ) ) : mOrientationHelper . getDecoratedStart ( child ) ; } else { if ( getChildCount ( ) > <NUM_LIT> ) { int pos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; anchorInfo . mLayoutFromEnd = mPendingScrollPosition < pos == mShouldReverseLayout ; } anchorInfo . assignCoordinateFromPadding ( ) ; } return true ; } anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; if ( mShouldReverseLayout ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - mPendingScrollPositionOffset ; } else { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) + mPendingScrollPositionOffset ; } return true ; } private int fixLayoutEndGap ( int endOffset , RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { int gap = mOrientationHelper . getEndAfterPadding ( ) - endOffset ; int fixOffset = <NUM_LIT> ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( - gap , recycler , state ) ; } else { return <NUM_LIT> ; } endOffset += fixOffset ; if ( canOffsetChildren ) { gap = mOrientationHelper . getEndAfterPadding ( ) - endOffset ; if ( gap > <NUM_LIT> ) { mOrientationHelper . offsetChildren ( gap ) ; return gap + fixOffset ; } } return fixOffset ; } private int fixLayoutStartGap ( int startOffset , RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { int gap = startOffset - mOrientationHelper . getStartAfterPadding ( ) ; int fixOffset = <NUM_LIT> ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( gap , recycler , state ) ; } else { return <NUM_LIT> ; } startOffset += fixOffset ; if ( canOffsetChildren ) { gap = startOffset - mOrientationHelper . getStartAfterPadding ( ) ; if ( gap > <NUM_LIT> ) { mOrientationHelper . offsetChildren ( - gap ) ; return fixOffset - gap ; } } return fixOffset ; } private void updateLayoutStateToFillEnd ( AnchorInfo anchorInfo ) { updateLayoutStateToFillEnd ( anchorInfo . mPosition , anchorInfo . mCoordinate ) ; } private void updateLayoutStateToFillEnd ( int itemPosition , int offset ) { mLayoutState . mAvailable = mOrientationHelper . getEndAfterPadding ( ) - offset ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; mLayoutState . mCurrentPosition = itemPosition ; mLayoutState . mLayoutDirection = LayoutState . LAYOUT_END ; mLayoutState . mOffset = offset ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; } private void updateLayoutStateToFillStart ( AnchorInfo anchorInfo ) { updateLayoutStateToFillStart ( anchorInfo . mPosition , anchorInfo . mCoordinate ) ; } private void updateLayoutStateToFillStart ( int itemPosition , int offset ) { mLayoutState . mAvailable = offset - mOrientationHelper . getStartAfterPadding ( ) ; mLayoutState . mCurrentPosition = itemPosition ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; mLayoutState . mLayoutDirection = LayoutState . LAYOUT_START ; mLayoutState . mOffset = offset ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; } protected boolean isLayoutRTL ( ) { return getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } void ensureLayoutState ( ) { if ( mLayoutState == null ) { mLayoutState = createLayoutState ( ) ; } } LayoutState createLayoutState ( ) { return new LayoutState ( ) ; } @ Override public void scrollToPosition ( int position ) { mPendingScrollPosition = position ; mPendingScrollPositionOffset = INVALID_OFFSET ; if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; } public void scrollToPositionWithOffset ( int position , int offset ) { mPendingScrollPosition = position ; mPendingScrollPositionOffset = offset ; if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == VERTICAL ) { return <NUM_LIT> ; } return scrollBy ( dx , recycler , state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == HORIZONTAL ) { return <NUM_LIT> ; } return scrollBy ( dy , recycler , state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private int computeScrollOffset ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollOffset ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled , mShouldReverseLayout ) ; } private int computeScrollExtent ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollExtent ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled ) ; } private int computeScrollRange ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollRange ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled ) ; } public void setSmoothScrollbarEnabled ( boolean enabled ) { mSmoothScrollbarEnabled = enabled ; } public boolean isSmoothScrollbarEnabled ( ) { return mSmoothScrollbarEnabled ; } private void updateLayoutState ( int layoutDirection , int requiredSpace , boolean canUseExistingSpace , RecyclerView . State state ) { mLayoutState . mInfinite = resolveIsInfinite ( ) ; mLayoutState . mLayoutDirection = layoutDirection ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; calculateExtraLayoutSpace ( state , mReusableIntPair ) ; int extraForStart = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) ; int extraForEnd = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) ; boolean layoutToEnd = layoutDirection == LayoutState . LAYOUT_END ; mLayoutState . mExtraFillSpace = layoutToEnd ? extraForEnd : extraForStart ; mLayoutState . mNoRecycleSpace = layoutToEnd ? extraForStart : extraForEnd ; int scrollingOffset ; if ( layoutToEnd ) { mLayoutState . mExtraFillSpace += mOrientationHelper . getEndPadding ( ) ; final View child = getChildClosestToEnd ( ) ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; mLayoutState . mCurrentPosition = getPosition ( child ) + mLayoutState . mItemDirection ; mLayoutState . mOffset = mOrientationHelper . getDecoratedEnd ( child ) ; scrollingOffset = mOrientationHelper . getDecoratedEnd ( child ) - mOrientationHelper . getEndAfterPadding ( ) ; } else { final View child = getChildClosestToStart ( ) ; mLayoutState . mExtraFillSpace += mOrientationHelper . getStartAfterPadding ( ) ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; mLayoutState . mCurrentPosition = getPosition ( child ) + mLayoutState . mItemDirection ; mLayoutState . mOffset = mOrientationHelper . getDecoratedStart ( child ) ; scrollingOffset = - mOrientationHelper . getDecoratedStart ( child ) + mOrientationHelper . getStartAfterPadding ( ) ; } mLayoutState . mAvailable = requiredSpace ; if ( canUseExistingSpace ) { mLayoutState . mAvailable -= scrollingOffset ; } mLayoutState . mScrollingOffset = scrollingOffset ; } boolean resolveIsInfinite ( ) { return mOrientationHelper . getMode ( ) == View . MeasureSpec . UNSPECIFIED && mOrientationHelper . getEnd ( ) == <NUM_LIT> ; } void collectPrefetchPositionsForLayoutState ( RecyclerView . State state , LayoutState layoutState , LayoutPrefetchRegistry layoutPrefetchRegistry ) { final int pos = layoutState . mCurrentPosition ; if ( pos >= <NUM_LIT> && pos < state . getItemCount ( ) ) { layoutPrefetchRegistry . addPosition ( pos , Math . max ( <NUM_LIT> , layoutState . mScrollingOffset ) ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void collectInitialPrefetchPositions ( int adapterItemCount , LayoutPrefetchRegistry layoutPrefetchRegistry ) { final boolean fromEnd ; final int anchorPos ; if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { fromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; anchorPos = mPendingSavedState . mAnchorPosition ; } else { resolveShouldLayoutReverse ( ) ; fromEnd = mShouldReverseLayout ; if ( mPendingScrollPosition == RecyclerView . NO_POSITION ) { anchorPos = fromEnd ? adapterItemCount - <NUM_LIT> : <NUM_LIT> ; } else { anchorPos = mPendingScrollPosition ; } } final int direction = fromEnd ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; int targetPos = anchorPos ; for ( int i = <NUM_LIT> ; i < mInitialPrefetchItemCount ; i ++ ) { if ( targetPos >= <NUM_LIT> && targetPos < adapterItemCount ) { layoutPrefetchRegistry . addPosition ( targetPos , <NUM_LIT> ) ; } else { break ; } targetPos += direction ; } } public void setInitialPrefetchItemCount ( int itemCount ) { mInitialPrefetchItemCount = itemCount ; } public int getInitialPrefetchItemCount ( ) { return mInitialPrefetchItemCount ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void collectAdjacentPrefetchPositions ( int dx , int dy , RecyclerView . State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int delta = ( mOrientation == HORIZONTAL ) ? dx : dy ; if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return ; } ensureLayoutState ( ) ; final int layoutDirection = delta > <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; final int absDelta = Math . abs ( delta ) ; updateLayoutState ( layoutDirection , absDelta , true , state ) ; collectPrefetchPositionsForLayoutState ( state , mLayoutState , layoutPrefetchRegistry ) ; } int scrollBy ( int delta , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; mLayoutState . mRecycle = true ; final int layoutDirection = delta > <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; final int absDelta = Math . abs ( delta ) ; updateLayoutState ( layoutDirection , absDelta , true , state ) ; final int consumed = mLayoutState . mScrollingOffset + fill ( recycler , mLayoutState , state , false ) ; if ( consumed < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return <NUM_LIT> ; } final int scrolled = absDelta > consumed ? layoutDirection * consumed : delta ; mOrientationHelper . offsetChildren ( - scrolled ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + delta + "<STR_LIT>" + scrolled ) ; } mLayoutState . mLastScrollDelta = scrolled ; return scrolled ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void assertNotInLayoutOrScroll ( String message ) { if ( mPendingSavedState == null ) { super . assertNotInLayoutOrScroll ( message ) ; } } private void recycleChildren ( RecyclerView . Recycler recycler , int startIndex , int endIndex ) { if ( startIndex == endIndex ) { return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + Math . abs ( startIndex - endIndex ) + "<STR_LIT>" ) ; } if ( endIndex > startIndex ) { for ( int i = endIndex - <NUM_LIT> ; i >= startIndex ; i -- ) { removeAndRecycleViewAt ( i , recycler ) ; } } else { for ( int i = startIndex ; i > endIndex ; i -- ) { removeAndRecycleViewAt ( i , recycler ) ; } } } private void recycleViewsFromStart ( RecyclerView . Recycler recycler , int scrollingOffset , int noRecycleSpace ) { if ( scrollingOffset < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } return ; } final int limit = scrollingOffset - noRecycleSpace ; final int childCount = getChildCount ( ) ; if ( mShouldReverseLayout ) { for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedEnd ( child ) > limit || mOrientationHelper . getTransformedEndWithDecoration ( child ) > limit ) { recycleChildren ( recycler , childCount - <NUM_LIT> , i ) ; return ; } } } else { for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedEnd ( child ) > limit || mOrientationHelper . getTransformedEndWithDecoration ( child ) > limit ) { recycleChildren ( recycler , <NUM_LIT> , i ) ; return ; } } } } private void recycleViewsFromEnd ( RecyclerView . Recycler recycler , int scrollingOffset , int noRecycleSpace ) { final int childCount = getChildCount ( ) ; if ( scrollingOffset < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } return ; } final int limit = mOrientationHelper . getEnd ( ) - scrollingOffset + noRecycleSpace ; if ( mShouldReverseLayout ) { for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit || mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { recycleChildren ( recycler , <NUM_LIT> , i ) ; return ; } } } else { for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit || mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { recycleChildren ( recycler , childCount - <NUM_LIT> , i ) ; return ; } } } } private void recycleByLayoutState ( RecyclerView . Recycler recycler , LayoutState layoutState ) { if ( ! layoutState . mRecycle || layoutState . mInfinite ) { return ; } int scrollingOffset = layoutState . mScrollingOffset ; int noRecycleSpace = layoutState . mNoRecycleSpace ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { recycleViewsFromEnd ( recycler , scrollingOffset , noRecycleSpace ) ; } else { recycleViewsFromStart ( recycler , scrollingOffset , noRecycleSpace ) ; } } int fill ( RecyclerView . Recycler recycler , LayoutState layoutState , RecyclerView . State state , boolean stopOnFocusable ) { final int start = layoutState . mAvailable ; if ( layoutState . mScrollingOffset != LayoutState . SCROLLING_OFFSET_NaN ) { if ( layoutState . mAvailable < <NUM_LIT> ) { layoutState . mScrollingOffset += layoutState . mAvailable ; } recycleByLayoutState ( recycler , layoutState ) ; } int remainingSpace = layoutState . mAvailable + layoutState . mExtraFillSpace ; LayoutChunkResult layoutChunkResult = mLayoutChunkResult ; while ( ( layoutState . mInfinite || remainingSpace > <NUM_LIT> ) && layoutState . hasMore ( state ) ) { layoutChunkResult . resetInternal ( ) ; if ( RecyclerView . VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } layoutChunk ( recycler , state , layoutState , layoutChunkResult ) ; if ( RecyclerView . VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } if ( layoutChunkResult . mFinished ) { break ; } layoutState . mOffset += layoutChunkResult . mConsumed * layoutState . mLayoutDirection ; if ( ! layoutChunkResult . mIgnoreConsumed || layoutState . mScrapList != null || ! state . isPreLayout ( ) ) { layoutState . mAvailable -= layoutChunkResult . mConsumed ; remainingSpace -= layoutChunkResult . mConsumed ; } if ( layoutState . mScrollingOffset != LayoutState . SCROLLING_OFFSET_NaN ) { layoutState . mScrollingOffset += layoutChunkResult . mConsumed ; if ( layoutState . mAvailable < <NUM_LIT> ) { layoutState . mScrollingOffset += layoutState . mAvailable ; } recycleByLayoutState ( recycler , layoutState ) ; } if ( stopOnFocusable && layoutChunkResult . mFocusable ) { break ; } } if ( DEBUG ) { validateChildOrder ( ) ; } return start - layoutState . mAvailable ; } void layoutChunk ( RecyclerView . Recycler recycler , RecyclerView . State state , LayoutState layoutState , LayoutChunkResult result ) { View view = layoutState . next ( recycler ) ; if ( view == null ) { if ( DEBUG && layoutState . mScrapList == null ) { throw new RuntimeException ( "<STR_LIT>" ) ; } result . mFinished = true ; return ; } RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( layoutState . mScrapList == null ) { if ( mShouldReverseLayout == ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } } else { if ( mShouldReverseLayout == ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) ) { addDisappearingView ( view ) ; } else { addDisappearingView ( view , <NUM_LIT> ) ; } } measureChildWithMargins ( view , <NUM_LIT> , <NUM_LIT> ) ; result . mConsumed = mOrientationHelper . getDecoratedMeasurement ( view ) ; int left , top , right , bottom ; if ( mOrientation == VERTICAL ) { if ( isLayoutRTL ( ) ) { right = getWidth ( ) - getPaddingRight ( ) ; left = right - mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } else { left = getPaddingLeft ( ) ; right = left + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { bottom = layoutState . mOffset ; top = layoutState . mOffset - result . mConsumed ; } else { top = layoutState . mOffset ; bottom = layoutState . mOffset + result . mConsumed ; } } else { top = getPaddingTop ( ) ; bottom = top + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { right = layoutState . mOffset ; left = layoutState . mOffset - result . mConsumed ; } else { left = layoutState . mOffset ; right = layoutState . mOffset + result . mConsumed ; } } layoutDecoratedWithMargins ( view , left , top , right , bottom ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + getPosition ( view ) + "<STR_LIT>" + ( left + params . leftMargin ) + "<STR_LIT>" + ( top + params . topMargin ) + "<STR_LIT>" + ( right - params . rightMargin ) + "<STR_LIT>" + ( bottom - params . bottomMargin ) ) ; } if ( params . isItemRemoved ( ) || params . isItemChanged ( ) ) { result . mIgnoreConsumed = true ; } result . mFocusable = view . hasFocusable ( ) ; } @ Override boolean shouldMeasureTwice ( ) { return getHeightMode ( ) != View . MeasureSpec . EXACTLY && getWidthMode ( ) != View . MeasureSpec . EXACTLY && hasFlexibleChildInBothOrientations ( ) ; } int convertFocusDirectionToLayoutDirection ( int focusDirection ) { switch ( focusDirection ) { case View . FOCUS_BACKWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_START ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_END ; } else { return LayoutState . LAYOUT_START ; } case View . FOCUS_FORWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_END ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_START ; } else { return LayoutState . LAYOUT_END ; } case View . FOCUS_UP : return mOrientation == VERTICAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_DOWN : return mOrientation == VERTICAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; case View . FOCUS_LEFT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_RIGHT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; default : if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + focusDirection ) ; } return LayoutState . INVALID_LAYOUT ; } } private View getChildClosestToStart ( ) { return getChildAt ( mShouldReverseLayout ? getChildCount ( ) - <NUM_LIT> : <NUM_LIT> ) ; } private View getChildClosestToEnd ( ) { return getChildAt ( mShouldReverseLayout ? <NUM_LIT> : getChildCount ( ) - <NUM_LIT> ) ; } View findFirstVisibleChildClosestToStart ( boolean completelyVisible , boolean acceptPartiallyVisible ) { if ( mShouldReverseLayout ) { return findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , completelyVisible , acceptPartiallyVisible ) ; } else { return findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , completelyVisible , acceptPartiallyVisible ) ; } } View findFirstVisibleChildClosestToEnd ( boolean completelyVisible , boolean acceptPartiallyVisible ) { if ( mShouldReverseLayout ) { return findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , completelyVisible , acceptPartiallyVisible ) ; } else { return findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , completelyVisible , acceptPartiallyVisible ) ; } } View findReferenceChild ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean layoutFromEnd , boolean traverseChildrenInReverseOrder ) { ensureLayoutState ( ) ; int start = <NUM_LIT> ; int end = getChildCount ( ) ; int diff = <NUM_LIT> ; if ( traverseChildrenInReverseOrder ) { start = getChildCount ( ) - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } int itemCount = state . getItemCount ( ) ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; View invalidMatch = null ; View bestFirstFind = null ; View bestSecondFind = null ; for ( int i = start ; i != end ; i += diff ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; final int childStart = mOrientationHelper . getDecoratedStart ( view ) ; final int childEnd = mOrientationHelper . getDecoratedEnd ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { if ( ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . isItemRemoved ( ) ) { if ( invalidMatch == null ) { invalidMatch = view ; } } else { boolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart ; boolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd ; if ( outOfBoundsBefore || outOfBoundsAfter ) { if ( layoutFromEnd ) { if ( outOfBoundsAfter ) { bestFirstFind = view ; } else if ( bestSecondFind == null ) { bestSecondFind = view ; } } else { if ( outOfBoundsBefore ) { bestFirstFind = view ; } else if ( bestSecondFind == null ) { bestSecondFind = view ; } } } else { return view ; } } } } return bestSecondFind != null ? bestSecondFind : ( bestFirstFind != null ? bestFirstFind : invalidMatch ) ; } private View findPartiallyOrCompletelyInvisibleChildClosestToEnd ( ) { return mShouldReverseLayout ? findFirstPartiallyOrCompletelyInvisibleChild ( ) : findLastPartiallyOrCompletelyInvisibleChild ( ) ; } private View findPartiallyOrCompletelyInvisibleChildClosestToStart ( ) { return mShouldReverseLayout ? findLastPartiallyOrCompletelyInvisibleChild ( ) : findFirstPartiallyOrCompletelyInvisibleChild ( ) ; } private View findFirstPartiallyOrCompletelyInvisibleChild ( ) { return findOnePartiallyOrCompletelyInvisibleChild ( <NUM_LIT> , getChildCount ( ) ) ; } private View findLastPartiallyOrCompletelyInvisibleChild ( ) { return findOnePartiallyOrCompletelyInvisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> ) ; } public int findFirstVisibleItemPosition ( ) { final View child = findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , false , true ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findFirstCompletelyVisibleItemPosition ( ) { final View child = findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , true , false ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findLastVisibleItemPosition ( ) { final View child = findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , false , true ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findLastCompletelyVisibleItemPosition ( ) { final View child = findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , true , false ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } View findOneVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible , boolean acceptPartiallyVisible ) { ensureLayoutState ( ) ; @ ViewBoundsCheck . ViewBounds int preferredBoundsFlag = <NUM_LIT> ; @ ViewBoundsCheck . ViewBounds int acceptableBoundsFlag = <NUM_LIT> ; if ( completelyVisible ) { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_EQ_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_EQ_PVE ) ; } else { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; } if ( acceptPartiallyVisible ) { acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; } return ( mOrientation == HORIZONTAL ) ? mHorizontalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) : mVerticalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) ; } View findOnePartiallyOrCompletelyInvisibleChild ( int fromIndex , int toIndex ) { ensureLayoutState ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : ( toIndex < fromIndex ? - <NUM_LIT> : <NUM_LIT> ) ; if ( next == <NUM_LIT> ) { return getChildAt ( fromIndex ) ; } @ ViewBoundsCheck . ViewBounds int preferredBoundsFlag = <NUM_LIT> ; @ ViewBoundsCheck . ViewBounds int acceptableBoundsFlag = <NUM_LIT> ; if ( mOrientationHelper . getDecoratedStart ( getChildAt ( fromIndex ) ) < mOrientationHelper . getStartAfterPadding ( ) ) { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE ) ; } else { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVE_GT_PVE | ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_LT_PVE ) ; acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVE_GT_PVE | ViewBoundsCheck . FLAG_CVS_GT_PVS ) ; } return ( mOrientation == HORIZONTAL ) ? mHorizontalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) : mVerticalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { resolveShouldLayoutReverse ( ) ; if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; if ( layoutDir == LayoutState . INVALID_LAYOUT ) { return null ; } ensureLayoutState ( ) ; final int maxScroll = ( int ) ( MAX_SCROLL_FACTOR * mOrientationHelper . getTotalSpace ( ) ) ; updateLayoutState ( layoutDir , maxScroll , false , state ) ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; mLayoutState . mRecycle = false ; fill ( recycler , mLayoutState , state , true ) ; final View nextCandidate ; if ( layoutDir == LayoutState . LAYOUT_START ) { nextCandidate = findPartiallyOrCompletelyInvisibleChildClosestToStart ( ) ; } else { nextCandidate = findPartiallyOrCompletelyInvisibleChildClosestToEnd ( ) ; } final View nextFocus ; if ( layoutDir == LayoutState . LAYOUT_START ) { nextFocus = getChildClosestToStart ( ) ; } else { nextFocus = getChildClosestToEnd ( ) ; } if ( nextFocus . hasFocusable ( ) ) { if ( nextCandidate == null ) { return null ; } return nextFocus ; } return nextCandidate ; } private void logChildren ( ) { Log . d ( TAG , "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; Log . d ( TAG , "<STR_LIT>" + getPosition ( child ) + "<STR_LIT>" + mOrientationHelper . getDecoratedStart ( child ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } void validateChildOrder ( ) { Log . d ( TAG , "<STR_LIT>" + getChildCount ( ) ) ; if ( getChildCount ( ) < <NUM_LIT> ) { return ; } int lastPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; int lastScreenLoc = mOrientationHelper . getDecoratedStart ( getChildAt ( <NUM_LIT> ) ) ; if ( mShouldReverseLayout ) { for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int pos = getPosition ( child ) ; int screenLoc = mOrientationHelper . getDecoratedStart ( child ) ; if ( pos < lastPos ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" + ( screenLoc < lastScreenLoc ) ) ; } if ( screenLoc > lastScreenLoc ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } } } else { for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int pos = getPosition ( child ) ; int screenLoc = mOrientationHelper . getDecoratedStart ( child ) ; if ( pos < lastPos ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" + ( screenLoc < lastScreenLoc ) ) ; } if ( screenLoc < lastScreenLoc ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } } } } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd ; } @ Override public void prepareForDrop ( @ NonNull View view , @ NonNull View target , int x , int y ) { assertNotInLayoutOrScroll ( "<STR_LIT>" ) ; ensureLayoutState ( ) ; resolveShouldLayoutReverse ( ) ; final int myPos = getPosition ( view ) ; final int targetPos = getPosition ( target ) ; final int dropDirection = myPos < targetPos ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; if ( mShouldReverseLayout ) { if ( dropDirection == LayoutState . ITEM_DIRECTION_TAIL ) { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getEndAfterPadding ( ) - ( mOrientationHelper . getDecoratedStart ( target ) + mOrientationHelper . getDecoratedMeasurement ( view ) ) ) ; } else { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( target ) ) ; } } else { if ( dropDirection == LayoutState . ITEM_DIRECTION_HEAD ) { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getDecoratedStart ( target ) ) ; } else { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getDecoratedEnd ( target ) - mOrientationHelper . getDecoratedMeasurement ( view ) ) ; } } } static class LayoutState { static final String TAG = "<STR_LIT>" ; static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; static final int SCROLLING_OFFSET_NaN = Integer . MIN_VALUE ; boolean mRecycle = true ; int mOffset ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mScrollingOffset ; int mExtraFillSpace = <NUM_LIT> ; int mNoRecycleSpace = <NUM_LIT> ; boolean mIsPreLayout = false ; int mLastScrollDelta ; List < RecyclerView . ViewHolder > mScrapList = null ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { if ( mScrapList != null ) { return nextViewFromScrapList ( ) ; } final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } private View nextViewFromScrapList ( ) { final int size = mScrapList . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { final View view = mScrapList . get ( i ) . itemView ; final RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( lp . isItemRemoved ( ) ) { continue ; } if ( mCurrentPosition == lp . getViewLayoutPosition ( ) ) { assignPositionFromScrapList ( view ) ; return view ; } } return null ; } public void assignPositionFromScrapList ( ) { assignPositionFromScrapList ( null ) ; } public void assignPositionFromScrapList ( View ignore ) { final View closest = nextViewInLimitedList ( ignore ) ; if ( closest == null ) { mCurrentPosition = RecyclerView . NO_POSITION ; } else { mCurrentPosition = ( ( RecyclerView . LayoutParams ) closest . getLayoutParams ( ) ) . getViewLayoutPosition ( ) ; } } public View nextViewInLimitedList ( View ignore ) { int size = mScrapList . size ( ) ; View closest = null ; int closestDistance = Integer . MAX_VALUE ; if ( DEBUG && mIsPreLayout ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } for ( int i = <NUM_LIT> ; i < size ; i ++ ) { View view = mScrapList . get ( i ) . itemView ; final RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( view == ignore || lp . isItemRemoved ( ) ) { continue ; } final int distance = ( lp . getViewLayoutPosition ( ) - mCurrentPosition ) * mItemDirection ; if ( distance < <NUM_LIT> ) { continue ; } if ( distance < closestDistance ) { closest = view ; closestDistance = distance ; if ( distance == <NUM_LIT> ) { break ; } } } return closest ; } void log ( ) { Log . d ( TAG , "<STR_LIT>" + mAvailable + "<STR_LIT>" + mCurrentPosition + "<STR_LIT>" + mItemDirection + "<STR_LIT>" + mOffset + "<STR_LIT>" + mLayoutDirection ) ; } } @ RestrictTo ( LIBRARY ) @ SuppressLint ( "<STR_LIT>" ) public static class SavedState implements Parcelable { int mAnchorPosition ; int mAnchorOffset ; boolean mAnchorLayoutFromEnd ; public SavedState ( ) { } SavedState ( Parcel in ) { mAnchorPosition = in . readInt ( ) ; mAnchorOffset = in . readInt ( ) ; mAnchorLayoutFromEnd = in . readInt ( ) == <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public SavedState ( SavedState other ) { mAnchorPosition = other . mAnchorPosition ; mAnchorOffset = other . mAnchorOffset ; mAnchorLayoutFromEnd = other . mAnchorLayoutFromEnd ; } boolean hasValidAnchor ( ) { return mAnchorPosition >= <NUM_LIT> ; } void invalidateAnchor ( ) { mAnchorPosition = RecyclerView . NO_POSITION ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mAnchorPosition ) ; dest . writeInt ( mAnchorOffset ) ; dest . writeInt ( mAnchorLayoutFromEnd ? <NUM_LIT> : <NUM_LIT> ) ; } public static final Parcelable . Creator < SavedState > CREATOR = new Parcelable . Creator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } static class AnchorInfo { OrientationHelper mOrientationHelper ; int mPosition ; int mCoordinate ; boolean mLayoutFromEnd ; boolean mValid ; AnchorInfo ( ) { reset ( ) ; } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mCoordinate = INVALID_OFFSET ; mLayoutFromEnd = false ; mValid = false ; } void assignCoordinateFromPadding ( ) { mCoordinate = mLayoutFromEnd ? mOrientationHelper . getEndAfterPadding ( ) : mOrientationHelper . getStartAfterPadding ( ) ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mPosition + "<STR_LIT>" + mCoordinate + "<STR_LIT>" + mLayoutFromEnd + "<STR_LIT>" + mValid + '<STR_LIT>' ; } boolean isViewValidAsAnchor ( View child , RecyclerView . State state ) { RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; return ! lp . isItemRemoved ( ) && lp . getViewLayoutPosition ( ) >= <NUM_LIT> && lp . getViewLayoutPosition ( ) < state . getItemCount ( ) ; } public void assignFromViewAndKeepVisibleRect ( View child , int position ) { final int spaceChange = mOrientationHelper . getTotalSpaceChange ( ) ; if ( spaceChange >= <NUM_LIT> ) { assignFromView ( child , position ) ; return ; } mPosition = position ; if ( mLayoutFromEnd ) { final int prevLayoutEnd = mOrientationHelper . getEndAfterPadding ( ) - spaceChange ; final int childEnd = mOrientationHelper . getDecoratedEnd ( child ) ; final int previousEndMargin = prevLayoutEnd - childEnd ; mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - previousEndMargin ; if ( previousEndMargin > <NUM_LIT> ) { final int childSize = mOrientationHelper . getDecoratedMeasurement ( child ) ; final int estimatedChildStart = mCoordinate - childSize ; final int layoutStart = mOrientationHelper . getStartAfterPadding ( ) ; final int previousStartMargin = mOrientationHelper . getDecoratedStart ( child ) - layoutStart ; final int startReference = layoutStart + Math . min ( previousStartMargin , <NUM_LIT> ) ; final int startMargin = estimatedChildStart - startReference ; if ( startMargin < <NUM_LIT> ) { mCoordinate += Math . min ( previousEndMargin , - startMargin ) ; } } } else { final int childStart = mOrientationHelper . getDecoratedStart ( child ) ; final int startMargin = childStart - mOrientationHelper . getStartAfterPadding ( ) ; mCoordinate = childStart ; if ( startMargin > <NUM_LIT> ) { final int estimatedEnd = childStart + mOrientationHelper . getDecoratedMeasurement ( child ) ; final int previousLayoutEnd = mOrientationHelper . getEndAfterPadding ( ) - spaceChange ; final int previousEndMargin = previousLayoutEnd - mOrientationHelper . getDecoratedEnd ( child ) ; final int endReference = mOrientationHelper . getEndAfterPadding ( ) - Math . min ( <NUM_LIT> , previousEndMargin ) ; final int endMargin = endReference - estimatedEnd ; if ( endMargin < <NUM_LIT> ) { mCoordinate -= Math . min ( startMargin , - endMargin ) ; } } } } public void assignFromView ( View child , int position ) { if ( mLayoutFromEnd ) { mCoordinate = mOrientationHelper . getDecoratedEnd ( child ) + mOrientationHelper . getTotalSpaceChange ( ) ; } else { mCoordinate = mOrientationHelper . getDecoratedStart ( child ) ; } mPosition = position ; } } protected static class LayoutChunkResult { public int mConsumed ; public boolean mFinished ; public boolean mIgnoreConsumed ; public boolean mFocusable ; void resetInternal ( ) { mConsumed = <NUM_LIT> ; mFinished = false ; mIgnoreConsumed = false ; mFocusable = false ; } } } </s>
<s> package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( "<STR_LIT>" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; } setActiveThumbIndex ( <NUM_LIT> ) ; return true ; } public interface OnChangeListener extends BaseOnChangeListener < OverlaySlider > { @ Override void onValueChange ( @ NonNull OverlaySlider slider , float value , boolean fromUser ) ; } public interface OnSliderTouchListener extends BaseOnSliderTouchListener < OverlaySlider > { @ Override void onStartTrackingTouch ( @ NonNull OverlaySlider slider ) ; @ Override void onStopTrackingTouch ( @ NonNull OverlaySlider slider ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( "<STR_LIT>" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( "<STR_LIT>" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( "<STR_LIT>" ) void clearView ( View view ) ; @ SuppressLint ( "<STR_LIT>" ) void onSelected ( View view ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + hidden + "<STR_LIT>" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset + "<STR_LIT>" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset + "<STR_LIT>" + "<STR_LIT>" + hidden + "<STR_LIT>" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( "<STR_LIT>" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + view + "<STR_LIT>" + offset + "<STR_LIT>" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( "<STR_LIT>" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + "<STR_LIT>" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } } boolean get ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . get ( index - BITS_PER_WORD ) ; } else { return ( mData & ( <NUM_LIT> << index ) ) != <NUM_LIT> ; } } void reset ( ) { mData = <NUM_LIT> ; if ( mNext != null ) { mNext . reset ( ) ; } } void insert ( int index , boolean value ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . insert ( index - BITS_PER_WORD , value ) ; } else { final boolean lastBit = ( mData & LAST_BIT ) != <NUM_LIT> ; long mask = ( <NUM_LIT> << index ) - <NUM_LIT> ; final long before = mData & mask ; final long after = ( mData & ~ mask ) << <NUM_LIT> ; mData = before | after ; if ( value ) { set ( index ) ; } else { clear ( index ) ; } if ( lastBit || mNext != null ) { ensureNext ( ) ; mNext . insert ( <NUM_LIT> , lastBit ) ; } } } boolean remove ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . remove ( index - BITS_PER_WORD ) ; } else { long mask = ( <NUM_LIT> << index ) ; final boolean value = ( mData & mask ) != <NUM_LIT> ; mData &= ~ mask ; mask = mask - <NUM_LIT> ; final long before = mData & mask ; final long after = Long . rotateRight ( mData & ~ mask , <NUM_LIT> ) ; mData = before | after ; if ( mNext != null ) { if ( mNext . get ( <NUM_LIT> ) ) { set ( BITS_PER_WORD - <NUM_LIT> ) ; } mNext . remove ( <NUM_LIT> ) ; } return value ; } } int countOnesBefore ( int index ) { if ( mNext == null ) { if ( index >= BITS_PER_WORD ) { return Long . bitCount ( mData ) ; } return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } if ( index < BITS_PER_WORD ) { return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } else { return mNext . countOnesBefore ( index - BITS_PER_WORD ) + Long . bitCount ( mData ) ; } } @ Override public String toString ( ) { return mNext == null ? Long . toBinaryString ( mData ) : mNext . toString ( ) + "<STR_LIT>" + Long . toBinaryString ( mData ) ; } } interface Callback { int getChildCount ( ) ; void addView ( View child , int index ) ; int indexOfChild ( View view ) ; void removeViewAt ( int index ) ; View getChildAt ( int offset ) ; void removeAllViews ( ) ; RecyclerView . ViewHolder getChildViewHolder ( View view ) ; void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams ) ; void detachViewFromParent ( int offset ) ; void onEnteredHiddenState ( View child ) ; void onLeftHiddenState ( View child ) ; } } </s>
