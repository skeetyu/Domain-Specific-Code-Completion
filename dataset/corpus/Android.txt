<s> public class TestClass { protected boolean getBoolean ( ) { return false ; } protected void test ( ) { WebView webview2 = new WebView ( this ) ; String url = "<STR_LIT>" ; webview2 . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( false ) ; webview2 . getSettings ( ) . setAllowFileAccess ( true ) ; webview2 . getSettings ( ) . setAllowContentAccess ( true ) ; webview2 . getSettings ( ) . setAllowFileAccessFromFileURLs ( this . getBoolean ( ) ) ; webview2 . loadUrl ( url ) ; } protected void test2 ( ) { WebView webview2 = new WebView ( this ) ; WebSettings settings = webView . getSettings ( ) ; settings . setJavaScriptEnabled ( true ) ; String url = "<STR_LIT>" ; settings . setAllowUniversalAccessFromFileURLs ( false ) ; settings . setAllowFileAccess ( true ) ; settings . setAllowContentAccess ( true ) ; settings . setAllowFileAccessFromFileURLs ( this . getBoolean ( ) ) ; webview2 . loadUrl ( url ) ; } public class WebAppInnnerCalss extends WebView { Context mContext ; public void test4 ( ) { getSettings ( ) . setAllowUniversalAccessFromFileURLs ( true ) ; getSettings ( ) . setAllowFileAccess ( false ) ; getSettings ( ) . setAllowContentAccess ( true ) ; getSettings ( ) . setAllowFileAccessFromFileURLs ( false ) ; } } } </s>
<s> public class MainActivity extends AppCompatActivity { private void test ( ) { getWindow ( ) . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; } private void test2 ( ) { Window window = activity . getWindow ( ) ; window . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; window . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; } } public class MainActivity2 extends AppCompatActivity { private void test ( ) { } } public class MainActivity3 extends AppCompatActivity { private void test ( ) { getWindow ( ) . addFlags ( <NUM_LIT> ) ; } } </s>
<s> package com . example . mycontentprovider ; import android . content . ContentProvider ; import android . content . ContentUris ; import android . content . ContentValues ; import android . content . Context ; import android . content . UriMatcher ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteException ; import android . database . sqlite . SQLiteOpenHelper ; import android . database . sqlite . SQLiteQueryBuilder ; import android . net . Uri ; import java . util . HashMap ; public class MyProvider extends ContentProvider { public MyProvider ( ) { } static final String PROVIDER_NAME = "<STR_LIT>" ; static final String URL = "<STR_LIT>" + PROVIDER_NAME + "<STR_LIT>" ; static final Uri CONTENT_URI = Uri . parse ( URL ) ; static final String id = "<STR_LIT>" ; static final String name = "<STR_LIT>" ; static final int uriCode = <NUM_LIT> ; static final UriMatcher uriMatcher ; private static HashMap < String , String > values ; static { uriMatcher = new UriMatcher ( UriMatcher . NO_MATCH ) ; uriMatcher . addURI ( PROVIDER_NAME , "<STR_LIT>" , uriCode ) ; uriMatcher . addURI ( PROVIDER_NAME , "<STR_LIT>" , uriCode ) ; } @ Override public String getType ( Uri uri ) { switch ( uriMatcher . match ( uri ) ) { case uriCode : return "<STR_LIT>" ; default : throw new IllegalArgumentException ( "<STR_LIT>" + uri ) ; } } @ Override public boolean onCreate ( ) { Context context = getContext ( ) ; DatabaseHelper dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; if ( db != null ) { return true ; } return false ; } @ Override public Cursor query ( Uri uri , String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { SQLiteQueryBuilder qb = new SQLiteQueryBuilder ( ) ; qb . setTables ( TABLE_NAME ) ; switch ( uriMatcher . match ( uri ) ) { case uriCode : qb . setProjectionMap ( values ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + uri ) ; } String s = "<STR_LIT>" + projection [ <NUM_LIT> ] ; if ( sortOrder == null || sortOrder == "<STR_LIT>" ) { sortOrder = id ; } Cursor c = qb . query ( db , projection , selection , selectionArgs , null , null , sortOrder ) ; c . setNotificationUri ( getContext ( ) . getContentResolver ( ) , uri ) ; return c ; } @ Override public Uri insert ( Uri uri , ContentValues values ) { long rowID = db . insert ( TABLE_NAME , "<STR_LIT>" , values ) ; if ( rowID > <NUM_LIT> ) { Uri _uri = ContentUris . withAppendedId ( CONTENT_URI , rowID ) ; getContext ( ) . getContentResolver ( ) . notifyChange ( _uri , null ) ; return _uri ; } throw new SQLiteException ( "<STR_LIT>" + uri ) ; } @ Override public int update ( Uri uri , ContentValues values , String selection , String [ ] selectionArgs ) { int count = <NUM_LIT> ; switch ( uriMatcher . match ( uri ) ) { case uriCode : count = db . update ( TABLE_NAME , values , selection , selectionArgs ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; } @ Override public int delete ( Uri uri , String selection , String [ ] selectionArgs ) { int count = <NUM_LIT> ; switch ( uriMatcher . match ( uri ) ) { case uriCode : count = db . delete ( TABLE_NAME , selection , selectionArgs ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; } private SQLiteDatabase db ; static final String DATABASE_NAME = "<STR_LIT>" ; static final String TABLE_NAME = "<STR_LIT>" ; static final int DATABASE_VERSION = <NUM_LIT> ; static final String CREATE_DB_TABLE = "<STR_LIT>" + TABLE_NAME + "<STR_LIT>" + "<STR_LIT>" ; private static class DatabaseHelper extends SQLiteOpenHelper { DatabaseHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( CREATE_DB_TABLE ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( "<STR_LIT>" + TABLE_NAME ) ; onCreate ( db ) ; } } } </s>
<s> public class ThreadReferenceLeakActivity extends AppCompatActivity { private static LeakyThread thread ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; createThread ( ) ; redirectToNewScreen ( ) ; } private void createThread ( ) { thread = new LeakyThread ( ) ; thread . start ( ) ; } private void redirectToNewScreen ( ) { startActivity ( new Intent ( this , SecondActivity . class ) ) ; } private class LeakyThread extends Thread { @ Override public void run ( ) { while ( true ) { } } } </s>
<s> public class WebAppInterface { Context mContext ; WebAppInterface ( Context c ) { mContext = c ; } @ JavascriptInterface public void showToast ( String toast ) { Toast . makeText ( mContext , toast , Toast . LENGTH_SHORT ) . show ( ) ; } public void showToast2 ( String toast ) { Toast . makeText ( mContext , toast , Toast . LENGTH_SHORT ) . show ( ) ; } } </s>
<s> import java . io . BufferedWriter ; import java . util . logging . Logger ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { Log . v ( "<STR_LIT>" , "<STR_LIT>" + variable ) ; Log . i ( "<STR_LIT>" , "<STR_LIT>" + password_secret_key + sec ) ; Log . w ( "<STR_LIT>" , "<STR_LIT>" + IV ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + iv ) ; Log . e ( "<STR_LIT>" , "<STR_LIT>" + variable ) ; Log . wtf ( "<STR_LIT>" , "<STR_LIT>" + variable ) ; System . out . print ( "<STR_LIT>" ) ; System . err . print ( "<STR_LIT>" ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( FileDescriptor . out ) , "<STR_LIT>" ) , <NUM_LIT> ) ; out . write ( "<STR_LIT>" ) ; out . write ( '<STR_LIT>' ) ; out . flush ( ) ; Logger x = new Logger ( ) ; x . severe ( "<STR_LIT>" ) ; } } </s>
<s> public class StaticReferenceLeakActivity extends AppCompatActivity { private static TextView textView ; private static Activity activity ; private static String a ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; textView = findViewById ( R . id . activity_text ) ; textView . setText ( "<STR_LIT>" ) ; activity = this ; } } </s>
<s> public class Test { public void test1 ( ) { Intent intent = new Intent ( applicationContext , SomeActivity . class ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( applicationContext , <NUM_LIT> , intent , <NUM_LIT> ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( applicationContext , <NUM_LIT> , intent , <NUM_LIT> ) ; Intent anotherIntent = new Intent ( ) ; anotherIntent . setClassName ( "<STR_LIT>" , "<STR_LIT>" ) ; anotherIntent . putExtra ( "<STR_LIT>" , pendingIntent ) ; startActivity ( anotherIntent ) ; } } </s>
<s> public class A { public void onCreate ( ) { StrictMode . setThreadPolicy ( new StrictMode . ThreadPolicy . Builder ( ) . detectDiskReads ( ) . detectDiskWrites ( ) . detectNetwork ( ) . penaltyLog ( ) . build ( ) ) ; StrictMode . setVmPolicy ( new StrictMode . VmPolicy . Builder ( ) . detectLeakedSqlLiteObjects ( ) . detectLeakedClosableObjects ( ) . penaltyLog ( ) . penaltyDeath ( ) . build ( ) ) ; super . onCreate ( ) ; } } </s>
<s> public class A { private void encrypt ( String a , String c ) { byte three = one ^ two ; byte [ ] b = xorArrayBytes ( operador1 , operador2 ) ; } private void test ( String a , String c ) { byte three = one ^ two ; byte [ ] b = xorArrayBytes ( operador1 , operador2 ) ; } } </s>
<s> public class A { byte [ ] key = new byte [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( this . key , "<STR_LIT>" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( data ) ; } } public class B { String key = "<STR_LIT>" ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( this . key . getBytes ( ) , "<STR_LIT>" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( data ) ; } } public class C { String key ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { key = getString ( R . string . key ) ; Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( key . toByteArray ( ) , "<STR_LIT>" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( data ) ; } } </s>
<s> public class MainActivity extends AppCompatActivity { public Socket createSocket ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { String [ ] weakCiphers = { "<STR_LIT>" } ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( weakCiphers ) ; return s ; } public Socket createSocket1 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { String [ ] a = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < a . length ; i ++ ) { a [ i ] = "<STR_LIT>" ; } if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( a ) ; return s ; } public Socket createSocket2 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > weakCiphers = new ArrayList < > ( ) ; weakCiphers . add ( "<STR_LIT>" ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( weakCiphers . toArray ( ) ) ; return s ; } public Socket createSocket3 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > mixCiphers = new ArrayList < > ( ) ; String [ ] mixedStrenghtCiphers = { "<STR_LIT>" , "<STR_LIT>" , } ; mixCiphers . addAll ( mixedStrenghtCiphers ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( mixCiphers . toArray ( ) ) ; return s ; } public Socket createSocket4 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > weakCiphers = new ArrayList < > ( ) ; String [ ] b = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < a . length ; i ++ ) { b [ i ] = "<STR_LIT>" ; } if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( b ) ; return s ; } public Socket createSocket5 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > strongCiphers = new ArrayList < > ( ) ; strongCiphers . add ( "<STR_LIT>" ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( strongCiphers ) ; return s ; } } </s>
<s> public class MainActivity extends AppCompatActivity { private void test ( ) { ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , "<STR_LIT>" ) ; clipboard . setPrimaryClip ( clip ) ; } } </s>
<s> public class WebAppInterface { Context mContext ; public void test1 ( ) { MSTG_ENV_008_JS_Interface jsInterface = new MSTG_ENV_008_JS_Interface ( this ) ; myWebView . addJavascriptInterface ( jsInterface , "<STR_LIT>" ) ; } } public class WebAppInterface extends WebView { Context mContext ; public void test2 ( ) { addJavascriptInterface ( new MSTG_ENV_008_JS_Interface ( this ) , "<STR_LIT>" ) ; } public void test3 ( ) { this . addJavascriptInterface ( new MSTG_ENV_008_JS_Interface ( this ) , "<STR_LIT>" ) ; } } </s>
<s> import android . security . keystore . KeyGenParameterSpec . Builder ; import javax . crypto . Cipher ; public class TestCryptoAndroid { private void vuln_generateKey1 ( ) { KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , "<STR_LIT>" ) ; keyGenerator . initialize ( new KeyGenParameterSpec . Builder ( "<STR_LIT>" , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_ECB ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . build ( ) ) ; SecretKey key = keyGenerator . generateKey ( ) ; } private void vuln_generateKey2 ( ) { KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , "<STR_LIT>" ) ; keyGenerator . initialize ( new KeyGenParameterSpec . Builder ( "<STR_LIT>" , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_CBC ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_PKCS7 ) . build ( ) ) ; SecretKey key = keyGenerator . generateKey ( ) ; } private void good_generateKey ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_GCM ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; } private void vuln_generateKey3 ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_CBC ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_PKCS7 ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; } private void vuln_generateKey4 ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_ECB ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; } public String vuln_encrypt ( String toEncrypt ) throws NoSuchPaddingException , NoSuchAlgorithmException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { final Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; } public String good_encrypt ( String toEncrypt ) throws NoSuchPaddingException , NoSuchAlgorithmException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { final Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; } public static String vuln_decrypt ( String key , String data ) { DESKeySpec dks = new DESKeySpec ( key . getBytes ( ) ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "<STR_LIT>" ) ; Key secretKey = keyFactory . generateSecret ( dks ) ; } } </s>
<s> public class MyPreferences extends PreferenceActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } } public class OtherPreferences extends PreferenceActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override protected boolean isValidFragment ( String fragmentName ) { return true ; } } </s>
<s> public class MainActivity extends AppCompatActivity { private SSLSocketFactory defaultSslSocketFactory ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory1 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory2 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory3 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory4 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory5 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( "<STR_LIT>" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } } </s>
<s> import java . io . BufferedWriter ; import java . util . logging . Logger ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } @ Override public boolean onFilterTouchEventForSecurity ( MotionEvent event ) { if ( ( event . getFlags ( ) & MotionEvent . FLAG_WINDOW_IS_OBSCURED ) == MotionEvent . FLAG_WINDOW_IS_OBSCURED ) { return false ; } return super . onFilterTouchEventForSecurity ( event ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; View v = findViewById ( android . R . id . content ) ; v . setFilterTouchesWhenObscured ( true ) ; } } public class Activity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } @ Override public boolean asdf ( MotionEvent event ) { if ( ( event . getFlags ( ) & MotionEvent . FLAG_WINDOW_IS_OBSCURED ) == MotionEvent . FLAG_WINDOW_IS_OBSCURED ) { v . setFilterTouchesWhenObscured ( false ) ; return false ; } return super . onFilterTouchEventForSecurity ( event ) ; } } </s>
<s> public class Test { String pincard ; public void test ( ) { String pwdVar = "<STR_LIT>" ; builder . getBuilder ( ) . setContentTitle ( this . pincard ) ; builder2 . setContentText ( pwdVar ) ; } } </s>
<s> public class SplashScreen extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { } } public class SplashScreen extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { AppUpdateManager appUpdateManager = AppUpdateManagerFactory . create ( context ) ; appUpdateManager . startUpdateFlowForResult ( appUpdateInfo , AppUpdateType . IMMEDIATE , this , MY_REQUEST_CODE ) ; } } </s>
<s> public class MyActivity extends FragmentActivity { @ Override protected void onCreate ( Bundle savedInstance ) { String fragmentName = this . getActivity ( ) . getIntent ( ) . getDataString ( ) ; getFragmentManager ( ) . beginTransaction ( ) . replace ( com . android . internal . R . id . prefs , Fragment . instantiate ( this , fragmentName , null ) ) . commit ( ) ; getFragmentManager ( ) . beginTransaction ( ) . replace ( com . android . internal . R . id . prefs , Fragment . instantiate ( this , anotherName , null ) ) . commit ( ) ; } } </s>
<s> public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { SharedPreferences sp = getContext ( ) . getSharedPreferences ( OLD_PREFS_NAME , <NUM_LIT> ) ; int a = <NUM_LIT> ; String s = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public void test2 ( ) { FileOutputStream fos = openFileOutput ( FILENAME , <NUM_LIT> ) ; fos . write ( string . getBytes ( ) ) ; fos . close ( ) ; } public void test3 ( ) { File temp = File . createTempFile ( "<STR_LIT>" , null ) ; FileOutputStream transfer = new FileOutputStream ( temp ) ; transfer . write ( memory . getBuffer ( ) , <NUM_LIT> , memory . getCount ( ) ) ; transfer . flush ( ) ; } public void test4 ( ) { File file = new File ( context . getFilesDir ( ) , "<STR_LIT>" ) ; EncryptedFile encryptedFile = EncryptedFile . Builder ( context , file , masterKey , EncryptedFile . FileEncryptionScheme . AES256_GCM_HKDF_4KB ) . build ( ) ; FileOutputStream encryptedOutputStream = encryptedFile . openFileOutput ( ) ; FileInputStream encryptedInputStream = encryptedFile . openFileInput ( ) ; } public void test5 ( ) { MasterKey masterKey = new MasterKey . Builder ( context ) . setKeyScheme ( MasterKey . KeyScheme . AES256_GCM ) . build ( ) ; SharedPreferences sharedPreferences = EncryptedSharedPreferences . create ( context , "<STR_LIT>" , masterKey , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; SharedPreferences . Editor editor = sharedPreferences . edit ( ) ; } public void test6 ( ) { File outFile = new File ( ctx . getExternalFilesDir ( null ) , filename ) ; } public void test7 ( ) { SQLiteDatabase database = dbHelper . getWritableDatabase ( ) ; ContentValues testValues = new ContentValues ( ) ; testValues . put ( WaitlistContract . WaitlistEntry . COLUMN_GUEST_NAME , "<STR_LIT>" ) ; testValues . put ( WaitlistContract . WaitlistEntry . COLUMN_PARTY_SIZE , <NUM_LIT> ) ; long firstRowId = database . insert ( WaitlistContract . WaitlistEntry . TABLE_NAME , null , testValues ) ; Cursor c = database . rawQuery ( "<STR_LIT>" , tableColumns , whereClause , whereArgs , null , null , orderBy ) ; } public void test8 ( ) { SharedPreferences sharedPref = context . getSharedPreferences ( getString ( R . string . preference_file_key ) , <NUM_LIT> ) ; } } </s>
<s> public class InnerClassReferenceLeakActivity extends AppCompatActivity { private static LeakyClass leakyClass ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; new LeakyClass ( this ) . redirectToSecondScreen ( ) ; leakyClass = new LeakyClass ( this ) ; leakyClass . redirectToSecondScreen ( ) ; } private class LeakyClass { private Activity activity ; public LeakyClass ( Activity activity ) { this . activity = activity ; } public void redirectToSecondScreen ( ) { this . activity . startActivity ( new Intent ( activity , SecondActivity . class ) ) ; } } } public class T { public class C { private void set ( Activity a ) { int b = <NUM_LIT> ; } } } </s>
<s> import android . content . Intent ; class A extends Activity { static void method ( ) { Intent i = getIntent ( ) ; db . query ( "<STR_LIT>" + i . getData ( ) ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; if ( intent . getStringExtra ( "<STR_LIT>" ) . equals ( "<STR_LIT>" ) { db . query ( "<STR_LIT>" + this . getActivity ( ) . getIntent ( ) . getDataString ( ) ) ; myMethod ( ) ; } } } public class MyBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String data = intent . getStringExtra ( "<STR_LIT>" ) ; db . query ( "<STR_LIT>" + data ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + data ) ; } } </s>
<s> import androidx . biometric . BiometricPrompt ; import android . hardware . fingerprint . FingerprintManager ; import android . hardware . fingerprint . FingerprintManagerCompat ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test_vulnBiometricPrompt ( ) ; test_vulnFingerprintManager ( ) ; test_vulnFingerprintManagerCompat ( ) ; test_goodBiometricPrompt ( ) ; } private void test_vulnBiometricPrompt ( ) { biometricPrompt = new BiometricPrompt ( MainActivity . this , executor , new BiometricPrompt . AuthenticationCallback ( ) { @ Override public void onAuthenticationSucceeded ( @ NonNull BiometricPrompt . AuthenticationResult result ) { Toast . makeText ( MainActivity . this , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; setContentView ( R . layout . fingerprint_normal ) ; } @ Override public void onAuthenticationError ( int errorCode , @ NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; Toast . makeText ( MainActivity . this , errString , Toast . LENGTH_LONG ) . show ( ) ; MainActivity . this . finish ( ) ; } @ Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( MainActivity . this , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } public void Authentication ( FingerprintManager manager , FingerprintManager . CryptoObject cryptoObject ) { CancellationSignal cancellationSignal = new CancellationSignal ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . USE_FINGERPRINT ) != PackageManager . PERMISSION_GRANTED ) { return ; } manager . authenticate ( cryptoObject , cancellationSignal , <NUM_LIT> , this , null ) ; } @ Override public void onAuthenticationFailed ( ) { this . update ( "<STR_LIT>" , false ) ; } @ Override public void onAuthenticationSucceeded ( FingerprintManager . AuthenticationResult result ) { this . update ( "<STR_LIT>" , true ) ; } public void update ( String e , Boolean success ) { TextView textView = ( TextView ) ( ( Activity ) context ) . findViewById ( R . id . textMsg ) ; textView . setText ( e ) ; if ( success ) { textView . setTextColor ( ContextCompat . getColor ( context , R . color . black ) ) ; } } private void test_vulnFingerprintManagerCompat ( ) { fingerprintManager . authenticate ( null , <NUM_LIT> , cancellationSignal , new FingerprintManagerCompat . AuthenticationCallback ( ) { @ Override public void onAuthenticationError ( int errMsgId , CharSequence errString ) { if ( ! selfCancelled ) { showFingerprintError ( errString ) ; } } @ Override public void onAuthenticationHelp ( int helpMsgId , CharSequence helpString ) { showFingerprintError ( helpString ) ; } @ Override public void onAuthenticationFailed ( ) { showFingerprintError ( LocaleController . getString ( "<STR_LIT>" , R . string . FingerprintNotRecognized ) ) ; } @ Override public void onAuthenticationSucceeded ( FingerprintManagerCompat . AuthenticationResult result ) { try { if ( fingerprintDialog . isShowing ( ) ) { fingerprintDialog . dismiss ( ) ; } } catch ( Exception e ) { FileLog . e ( "<STR_LIT>" , e ) ; } fingerprintDialog = null ; processDone ( true ) ; } } , null ) ; } private void test_goodBiometricPrompt ( ) { biometricPrompt = new BiometricPrompt ( MainActivity . this , executor , new BiometricPrompt . AuthenticationCallback ( ) { @ Override public void onAuthenticationSucceeded ( @ NonNull BiometricPrompt . AuthenticationResult result ) { if ( result . getCryptoObject ( ) != null && result . getCryptoObject ( ) . getCrypto ( ) != null ) { try { Cipher cipher = result . getCryptoObject ( ) . getCipher ( ) ; byte [ ] decrypted = cipher . doFinal ( encrypted ) ; } catch ( CipherException e ) { throw new RuntimeException ( ) ; } } else { } } @ Override public void onAuthenticationError ( int errorCode , @ NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; Toast . makeText ( MainActivity . this , errString , Toast . LENGTH_LONG ) . show ( ) ; MainActivity . this . finish ( ) ; } @ Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( MainActivity . this , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } } </s>
<s> public class MainActivity extends AppCompatActivity { WebView webView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; webView = new WebView ( this ) ; WebSettings settings = webView . getSettings ( ) ; settings . setJavaScriptEnabled ( true ) ; setContentView ( webView ) ; WebView webview2 = new WebView ( this ) ; setContentView ( webview2 ) ; webview2 . getSettings ( ) . setJavaScriptEnabled ( true ) ; } } </s>
<s> public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { EditText edtView = ( EditText ) findViewById ( R . id . editTextConvertValue ) ; edtView . setInputType ( <NUM_LIT> ) ; editor . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText key = ( EditText ) findViewById ( R . id . editTextConvertValue ) ; key . setInputType ( <NUM_LIT> ) ; key . setInputType ( InputType . TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ; abc . setInputType ( InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ; abc . setInputType ( <NUM_LIT> ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ; abc . setInputType ( <NUM_LIT> ) ; } } </s>
<s> package com . cgutman . adblib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . security . GeneralSecurityException ; import java . security . KeyFactory ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . NoSuchAlgorithmException ; import java . security . interfaces . RSAPublicKey ; import java . security . spec . EncodedKeySpec ; import java . security . spec . InvalidKeySpecException ; import java . security . spec . PKCS8EncodedKeySpec ; import java . security . spec . X509EncodedKeySpec ; import javax . crypto . Cipher ; public class AdbCrypto { private KeyPair keyPair ; private AdbBase64 base64 ; public static final int KEY_LENGTH_BITS = <NUM_LIT> ; public static final int KEY_LENGTH_BYTES = KEY_LENGTH_BITS / <NUM_LIT> ; public static final int KEY_LENGTH_WORDS = KEY_LENGTH_BYTES / <NUM_LIT> ; public static final int [ ] SIGNATURE_PADDING_AS_INT = new int [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static byte [ ] SIGNATURE_PADDING ; static { SIGNATURE_PADDING = new byte [ SIGNATURE_PADDING_AS_INT . length ] ; for ( int i = <NUM_LIT> ; i < SIGNATURE_PADDING . length ; i ++ ) SIGNATURE_PADDING [ i ] = ( byte ) SIGNATURE_PADDING_AS_INT [ i ] ; } private static byte [ ] convertRsaPublicKeyToAdbFormat ( RSAPublicKey pubkey ) { BigInteger r32 , r , rr , rem , n , n0inv ; r32 = BigInteger . ZERO . setBit ( <NUM_LIT> ) ; n = pubkey . getModulus ( ) ; r = BigInteger . ZERO . setBit ( KEY_LENGTH_WORDS * <NUM_LIT> ) ; rr = r . modPow ( BigInteger . valueOf ( <NUM_LIT> ) , n ) ; rem = n . remainder ( r32 ) ; n0inv = rem . modInverse ( r32 ) ; int myN [ ] = new int [ KEY_LENGTH_WORDS ] ; int myRr [ ] = new int [ KEY_LENGTH_WORDS ] ; BigInteger res [ ] ; for ( int i = <NUM_LIT> ; i < KEY_LENGTH_WORDS ; i ++ ) { res = rr . divideAndRemainder ( r32 ) ; rr = res [ <NUM_LIT> ] ; rem = res [ <NUM_LIT> ] ; myRr [ i ] = rem . intValue ( ) ; res = n . divideAndRemainder ( r32 ) ; n = res [ <NUM_LIT> ] ; rem = res [ <NUM_LIT> ] ; myN [ i ] = rem . intValue ( ) ; } ByteBuffer bbuf = ByteBuffer . allocate ( <NUM_LIT> ) . order ( ByteOrder . LITTLE_ENDIAN ) ; bbuf . putInt ( KEY_LENGTH_WORDS ) ; bbuf . putInt ( n0inv . negate ( ) . intValue ( ) ) ; for ( int i : myN ) bbuf . putInt ( i ) ; for ( int i : myRr ) bbuf . putInt ( i ) ; bbuf . putInt ( pubkey . getPublicExponent ( ) . intValue ( ) ) ; return bbuf . array ( ) ; } public static AdbCrypto loadAdbKeyPair ( AdbBase64 base64 , File privateKey , File publicKey ) throws IOException , NoSuchAlgorithmException , InvalidKeySpecException { AdbCrypto crypto = new AdbCrypto ( ) ; int privKeyLength = ( int ) privateKey . length ( ) ; int pubKeyLength = ( int ) publicKey . length ( ) ; byte [ ] privKeyBytes = new byte [ privKeyLength ] ; byte [ ] pubKeyBytes = new byte [ pubKeyLength ] ; FileInputStream privIn = new FileInputStream ( privateKey ) ; FileInputStream pubIn = new FileInputStream ( publicKey ) ; privIn . read ( privKeyBytes ) ; pubIn . read ( pubKeyBytes ) ; privIn . close ( ) ; pubIn . close ( ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec ( privKeyBytes ) ; EncodedKeySpec publicKeySpec = new X509EncodedKeySpec ( pubKeyBytes ) ; crypto . keyPair = new KeyPair ( keyFactory . generatePublic ( publicKeySpec ) , keyFactory . generatePrivate ( privateKeySpec ) ) ; crypto . base64 = base64 ; return crypto ; } public static AdbCrypto generateAdbKeyPair ( AdbBase64 base64 ) throws NoSuchAlgorithmException { AdbCrypto crypto = new AdbCrypto ( ) ; KeyPairGenerator rsaKeyPg = KeyPairGenerator . getInstance ( "<STR_LIT>" ) ; rsaKeyPg . initialize ( KEY_LENGTH_BITS ) ; crypto . keyPair = rsaKeyPg . genKeyPair ( ) ; crypto . base64 = base64 ; return crypto ; } public byte [ ] signAdbTokenPayload ( byte [ ] payload ) throws GeneralSecurityException { Cipher c = Cipher . getInstance ( "<STR_LIT>" ) ; c . init ( Cipher . ENCRYPT_MODE , keyPair . getPrivate ( ) ) ; c . update ( SIGNATURE_PADDING ) ; return c . doFinal ( payload ) ; } public byte [ ] getAdbPublicKeyPayload ( ) throws IOException { byte [ ] convertedKey = convertRsaPublicKeyToAdbFormat ( ( RSAPublicKey ) keyPair . getPublic ( ) ) ; StringBuilder keyString = new StringBuilder ( <NUM_LIT> ) ; keyString . append ( base64 . encodeToString ( convertedKey ) ) ; keyString . append ( "<STR_LIT>" ) ; keyString . append ( '<STR_LIT>' ) ; return keyString . toString ( ) . getBytes ( "<STR_LIT>" ) ; } public void saveAdbKeyPair ( File privateKey , File publicKey ) throws IOException { FileOutputStream privOut = new FileOutputStream ( privateKey ) ; FileOutputStream pubOut = new FileOutputStream ( publicKey ) ; privOut . write ( keyPair . getPrivate ( ) . getEncoded ( ) ) ; pubOut . write ( keyPair . getPublic ( ) . getEncoded ( ) ) ; privOut . close ( ) ; pubOut . close ( ) ; } } </s>
<s> package in . hridayan . ashell . fragments ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . appcompat . widget . LinearLayoutCompat ; import androidx . fragment . app . Fragment ; import androidx . preference . PreferenceManager ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import rikka . shizuku . Shizuku ; public class StartFragment extends Fragment { public StartFragment ( ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_start , container , false ) ; initViews ( view ) ; return view ; } private void initViews ( View view ) { LinearLayoutCompat mStartLayout = view . findViewById ( R . id . fragment_start ) ; MaterialButton mStartButton = view . findViewById ( R . id . start_button ) ; MaterialTextView mAboutText = view . findViewById ( R . id . about_text ) ; if ( Shizuku . pingBinder ( ) ) { Shizuku . requestPermission ( <NUM_LIT> ) ; } mStartLayout . setVisibility ( View . VISIBLE ) ; mAboutText . setText ( getString ( R . string . app_summary ) ) ; mStartButton . setOnClickListener ( v -> { PreferenceManager . getDefaultSharedPreferences ( requireContext ( ) ) . edit ( ) . putBoolean ( "<STR_LIT>" , false ) . apply ( ) ; getParentFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . fragment_container , new aShellFragment ( ) ) . commit ( ) ; } ) ; } } </s>
<s> package in . hridayan . ashell . UI ; import android . content . Context ; import android . util . AttributeSet ; import android . widget . EditText ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . search . SearchView ; public class CustomSearchView extends SearchView { public CustomSearchView ( @ NonNull Context context ) { super ( context ) ; } public CustomSearchView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public CustomSearchView ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } public EditText getSearchEditText ( ) { return findViewById ( R . id . open_search_view_edit_text ) ; } } </s>
<s> package in . hridayan . ashell . utils ; public class ChangelogItem { private String title ; private String description ; public ChangelogItem ( String title , String description ) { this . title = title ; this . description = description ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } } </s>
<s> package in . hridayan . ashell . adapters ; import static in . hridayan . ashell . utils . Preferences . SORT_A_TO_Z ; import static in . hridayan . ashell . utils . Preferences . SORT_LEAST_USED ; import static in . hridayan . ashell . utils . Preferences . SORT_MOST_USED ; import static in . hridayan . ashell . utils . Preferences . SORT_Z_TO_A ; import android . animation . ObjectAnimator ; import android . content . Context ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Build ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . animation . AnimationUtils ; import androidx . annotation . NonNull ; import androidx . appcompat . widget . AppCompatImageButton ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . card . MaterialCardView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . stream . IntStream ; public class ExamplesAdapter extends RecyclerView . Adapter < ExamplesAdapter . ViewHolder > { public final List < CommandItems > data ; public List < CommandItems > selectedItems = new ArrayList < > ( ) ; private Context context ; private CommandItems commands ; private OnItemClickListener listener ; public ExamplesAdapter ( List < CommandItems > data , Context context ) { this . data = data ; this . context = context ; } public void setOnItemClickListener ( OnItemClickListener listener ) { this . listener = listener ; } public interface OnItemClickListener { void onItemClick ( int position ) ; void onItemLongClick ( int position ) ; } @ NonNull @ Override public ExamplesAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_examples , parent , false ) ; return new ExamplesAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull ExamplesAdapter . ViewHolder holder , int position ) { CommandItems currentItem = this . data . get ( position ) ; holder . pin . setVisibility ( currentItem . isPinned ( ) ? View . VISIBLE : View . GONE ) ; if ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ) { holder . pin . setColorFilter ( Utils . getColor ( pinColor ( ) , context ) ) ; } holder . card . setStrokeWidth ( currentItem . isPinned ( ) ? <NUM_LIT> : <NUM_LIT> ) ; holder . card . setChecked ( currentItem . isChecked ( ) ) ; holder . itemView . startAnimation ( AnimationUtils . loadAnimation ( context , R . anim . on_scroll_animator ) ) ; holder . mTitle . setText ( currentItem . getTitle ( ) ) ; if ( currentItem . getSummary ( ) != null ) { holder . mSummary . setText ( currentItem . getSummary ( ) ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == data . size ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; holder . itemView . setLayoutParams ( layoutParams ) ; translatePinIcon ( holder . card . isChecked ( ) , holder . pin ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener , View . OnLongClickListener { private final MaterialTextView mTitle , mSummary ; private MaterialCardView card ; private AppCompatImageButton pin ; private float pinTranslation = <NUM_LIT> ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; view . setOnLongClickListener ( this ) ; this . card = view . findViewById ( R . id . commands_card ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; this . pin = view . findViewById ( R . id . pin ) ; } @ Override public void onClick ( View view ) { if ( data . get ( getAdapterPosition ( ) ) . getExample ( ) != null && ! isAtLeastOneItemChecked ( ) ) { String sanitizedText = sanitizeText ( data . get ( getAdapterPosition ( ) ) . getTitle ( ) ) ; String string = String . valueOf ( data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ) ; Context context = view . getContext ( ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . example ) . setMessage ( data . get ( getAdapterPosition ( ) ) . getExample ( ) ) . setPositiveButton ( R . string . use , ( dialogInterface , i ) -> { int counter = data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ; data . get ( getAdapterPosition ( ) ) . setUseCounter ( counter + <NUM_LIT> ) ; Intent intent = new Intent ( context , MainActivity . class ) ; intent . putExtra ( "<STR_LIT>" , sanitizedText ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; context . startActivity ( intent ) ; } ) . setNegativeButton ( R . string . copy , ( dialogInterface , i ) -> { Utils . copyToClipboard ( sanitizedText , context ) ; } ) . show ( ) ; } else { startItemSelecting ( ) ; } } @ Override public boolean onLongClick ( View view ) { startItemSelecting ( ) ; return true ; } public void startItemSelecting ( ) { card . setChecked ( ! card . isChecked ( ) ) ; data . get ( getAdapterPosition ( ) ) . setChecked ( card . isChecked ( ) ) ; updateSelectedItems ( data . get ( getAdapterPosition ( ) ) , card . isChecked ( ) ) ; listener . onItemLongClick ( getAdapterPosition ( ) ) ; translatePinIcon ( card . isChecked ( ) , pin ) ; } public boolean isAtLeastOneItemChecked ( ) { for ( CommandItems item : data ) { if ( item . isChecked ( ) ) { return true ; } } return false ; } } public void updateSelectedItems ( CommandItems item , boolean isChecked ) { if ( isChecked ) { selectedItems . add ( item ) ; } else { selectedItems . remove ( item ) ; } } public List < CommandItems > getSelectedItems ( ) { return selectedItems ; } public int getSelectedItemsSize ( ) { return selectedItems . size ( ) ; } public void selectAll ( ) { for ( CommandItems item : data ) { if ( ! item . isChecked ( ) ) { item . setChecked ( true ) ; updateSelectedItems ( item , true ) ; } notifyDataSetChanged ( ) ; } } public void deselectAll ( ) { for ( CommandItems item : data ) { if ( item . isChecked ( ) ) { item . setChecked ( false ) ; updateSelectedItems ( item , false ) ; } notifyDataSetChanged ( ) ; } } public void addSelectedToBookmarks ( ) { int totalItems = selectedItems . size ( ) ; int numBatches = ( totalItems < <NUM_LIT> ) ? totalItems : <NUM_LIT> ; int batchSize = totalItems / numBatches ; int remainingItems = totalItems % numBatches ; AtomicInteger counter = new AtomicInteger ( <NUM_LIT> ) ; IntStream . range ( <NUM_LIT> , numBatches ) . parallel ( ) . forEach ( i -> { int startIndex = i * batchSize ; int endIndex = ( i == numBatches - <NUM_LIT> ) ? totalItems : ( startIndex + batchSize ) ; List < CommandItems > batch = selectedItems . subList ( startIndex , endIndex ) ; Set < String > bookmarksSet = new HashSet < > ( Utils . getBookmarks ( context ) ) ; batch . forEach ( item -> { String command = sanitizeText ( item . getTitle ( ) ) ; if ( ! bookmarksSet . contains ( command ) ) { Utils . addToBookmark ( command , context ) ; } else { counter . incrementAndGet ( ) ; } } ) ; } ) ; } public void deleteSelectedFromBookmarks ( ) { for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; Utils . deleteFromBookmark ( command , context ) ; } } public boolean isAllItemsBookmarked ( ) { int i = <NUM_LIT> ; for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; if ( ! Utils . isBookmarked ( command , context ) ) { return false ; } } return true ; } public boolean isAllItemsPinned ( ) { int i = <NUM_LIT> ; for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; if ( ! item . isPinned ( ) ) { return false ; } } return true ; } public String sanitizeText ( String text ) { String sanitizedText = text . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; return sanitizedText . trim ( ) ; } public void pinUnpinSelectedItems ( boolean isAllPinned ) { if ( ! selectedItems . isEmpty ( ) ) { List < CommandItems > pinnedItems = new ArrayList < > ( selectedItems ) ; for ( CommandItems selectedItem : pinnedItems ) { if ( ! isAllPinned ) { selectedItem . setPinned ( true ) ; data . remove ( selectedItem ) ; data . add ( <NUM_LIT> , selectedItem ) ; } else { selectedItem . setPinned ( false ) ; } sortData ( ) ; selectedItem . setChecked ( false ) ; updateSelectedItems ( selectedItem , false ) ; } notifyDataSetChanged ( ) ; } } public void sortData ( ) { Collections . sort ( data , new Comparator < CommandItems > ( ) { @ Override public int compare ( CommandItems item1 , CommandItems item2 ) { if ( item1 . isPinned ( ) && ! item2 . isPinned ( ) ) { return - <NUM_LIT> ; } else if ( ! item1 . isPinned ( ) && item2 . isPinned ( ) ) { return <NUM_LIT> ; } int sortOption = Preferences . getSortingExamples ( context ) ; int counter1 = item1 . getUseCounter ( ) ; int counter2 = item2 . getUseCounter ( ) ; switch ( sortOption ) { case SORT_A_TO_Z : return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; case SORT_Z_TO_A : return item2 . getTitle ( ) . compareToIgnoreCase ( item1 . getTitle ( ) ) ; case SORT_MOST_USED : if ( counter1 != counter2 ) { return counter2 - counter1 ; } else { return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; } case SORT_LEAST_USED : if ( counter1 != counter2 ) { return counter1 - counter2 ; } else { return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; } default : return <NUM_LIT> ; } } } ) ; notifyDataSetChanged ( ) ; } private int pinColor ( ) { int currentMode = context . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; return currentMode == Configuration . UI_MODE_NIGHT_YES ? android . R . color . system_accent3_100 : android . R . color . system_accent3_500 ; } private void translatePinIcon ( boolean isChecked , AppCompatImageButton pin ) { float translationX = isChecked ? - Utils . convertDpToPixel ( <NUM_LIT> , context ) : <NUM_LIT> ; if ( pin . getTranslationX ( ) != translationX ) { ObjectAnimator animator = ObjectAnimator . ofFloat ( pin , "<STR_LIT>" , translationX ) ; animator . setDuration ( <NUM_LIT> ) ; animator . start ( ) ; pin . setTranslationX ( translationX ) ; } } } </s>
<s> package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class MainViewModel extends ViewModel { private static final int nullValue = <NUM_LIT> ; private int currentFragment = nullValue ; public int currentFragment ( ) { return currentFragment ; } public void setCurrentFragment ( int fragment ) { currentFragment = fragment ; } public boolean isFragmentSaved ( ) { return currentFragment != nullValue ; } } </s>
<s> package in . hridayan . ashell . UI ; import android . app . Activity ; import android . content . Context ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewTreeObserver ; import android . view . WindowManager ; import android . view . inputmethod . InputMethodManager ; import com . google . android . material . textfield . TextInputEditText ; import in . hridayan . ashell . utils . Preferences ; public class KeyboardUtils { public interface KeyboardVisibilityListener { void onKeyboardVisibilityChanged ( boolean isVisible ) ; } public static void attachVisibilityListener ( Activity activity , final KeyboardVisibilityListener listener ) { final View contentView = activity . findViewById ( android . R . id . content ) ; contentView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new ViewTreeObserver . OnGlobalLayoutListener ( ) { private boolean wasOpened ; @ Override public void onGlobalLayout ( ) { Rect r = new Rect ( ) ; contentView . getWindowVisibleDisplayFrame ( r ) ; int screenHeight = contentView . getRootView ( ) . getHeight ( ) ; int heightDiff = screenHeight - ( r . bottom - r . top ) ; boolean isVisible = heightDiff > <NUM_LIT> ; if ( isVisible != wasOpened ) { wasOpened = isVisible ; listener . onKeyboardVisibilityChanged ( isVisible ) ; } } } ) ; } public static void disableKeyboard ( Context context , Activity activity , View view ) { InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; boolean disableSoftKey = Preferences . getDisableSoftkey ( context ) ; if ( disableSoftKey ) { if ( imm != null ) imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; activity . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM , WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM ) ; } else { activity . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM ) ; } } public static void showKeyboard ( TextInputEditText editText , Context context ) { editText . requestFocus ( ) ; InputMethodManager imm = ( InputMethodManager ) context . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . toggleSoftInput ( InputMethodManager . SHOW_FORCED , <NUM_LIT> ) ; } public static void closeKeyboard ( Activity activity , View v ) { InputMethodManager inputMethodManager = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; inputMethodManager . hideSoftInputFromWindow ( v . getWindowToken ( ) , <NUM_LIT> ) ; } } </s>
<s> package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class AboutViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) { return isToolbarExpanded ; } public void setToolbarExpanded ( boolean toolbarExpanded ) { isToolbarExpanded = toolbarExpanded ; } } </s>
<s> package in . hridayan . ashell . UI ; public class Category { private String name ; public Category ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public static class LeadDeveloperItem { private String title ; private String description ; private int imageResource ; public LeadDeveloperItem ( String title , String description , int imageResource ) { this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ; } } public static class ContributorsItem { private String id , title , description ; private int imageResource ; public ContributorsItem ( String id , String title , String description , int imageResource ) { this . id = id ; this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getId ( ) { return id ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ; } } public static class AppItem { private String id , title , description ; private int imageResource ; public AppItem ( String id , String title , String description , int imageResource ) { this . id = id ; this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getId ( ) { return id ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ; } } } </s>
<s> package in . hridayan . ashell . UI ; import android . content . Context ; import android . os . Handler ; import android . os . Looper ; import android . view . View ; import android . view . ViewTreeObserver ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . floatingactionbutton . ExtendedFloatingActionButton ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import com . google . android . material . textfield . TextInputEditText ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . Objects ; public class BehaviorFAB { private static final int FAST_SCROLL_THRESHOLD = <NUM_LIT> ; private static final int VISIBILITY_DELAY_MILLIS = <NUM_LIT> ; private static final int FAST_SCROLL_THRESHOLD_EXTENDED = <NUM_LIT> ; public static class FabLocalScrollUpListener extends RecyclerView . OnScrollListener { private final FloatingActionButton fab ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabLocalScrollUpListener ( FloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; LinearLayoutManager layoutManager = ( LinearLayoutManager ) recyclerView . getLayoutManager ( ) ; int firstVisibleItemPosition = layoutManager . findFirstVisibleItemPosition ( ) ; if ( firstVisibleItemPosition == <NUM_LIT> ) { fab . hide ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= <NUM_LIT> ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } } } public static class FabOtgScrollUpListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabOtgScrollUpListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } private FabLocalScrollUpListener FabLocalScrollUpListener ; public BehaviorFAB ( FloatingActionButton fab ) { FabLocalScrollUpListener = new FabLocalScrollUpListener ( fab ) ; } public static class OtgShareButtonListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable showFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . show ( ) ; } } ; public OtgShareButtonListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy != <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( showFabRunnable ) ; fab . hide ( ) ; } else if ( dy == <NUM_LIT> ) { fab . show ( ) ; } else { visibilityHandler . postDelayed ( showFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } public static class FabLocalScrollDownListener extends RecyclerView . OnScrollListener { private final FloatingActionButton fab ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabLocalScrollDownListener ( FloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; LinearLayoutManager layoutManager = ( LinearLayoutManager ) recyclerView . getLayoutManager ( ) ; int lastVisibleItemPosition = layoutManager . findLastVisibleItemPosition ( ) ; int totalItemCount = layoutManager . getItemCount ( ) ; if ( lastVisibleItemPosition == totalItemCount - <NUM_LIT> ) { fab . hide ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= <NUM_LIT> ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } } } public static class FabOtgScrollDownListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabOtgScrollDownListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; int scrollRange = scrollView . getChildAt ( <NUM_LIT> ) . getHeight ( ) - scrollView . getHeight ( ) ; int scrollDiff = scrollRange - scrollY ; if ( scrollDiff <= <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } public static class FabExtendingOnScrollListener extends RecyclerView . OnScrollListener { private final ExtendedFloatingActionButton fab ; public FabExtendingOnScrollListener ( ExtendedFloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE ) { if ( recyclerView . computeVerticalScrollOffset ( ) == <NUM_LIT> ) { fab . extend ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( dy > <NUM_LIT> && fab . isExtended ( ) && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { fab . shrink ( ) ; } else if ( dy < <NUM_LIT> && ! fab . isExtended ( ) && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { fab . extend ( ) ; } } } public static class FabExtendingOnScrollViewListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final ExtendedFloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; public FabExtendingOnScrollViewListener ( CoordinatedNestedScrollView scrollView , ExtendedFloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . extend ( ) ; } else { int dy = scrollY - lastScrollY ; if ( Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { if ( dy > <NUM_LIT> && fab . isExtended ( ) ) { fab . shrink ( ) ; } else if ( dy < <NUM_LIT> && ! fab . isExtended ( ) ) { fab . extend ( ) ; } } } lastScrollY = scrollY ; } } public static void handleTopAndBottomArrow ( FloatingActionButton topButton , FloatingActionButton bottomButton , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView , Context context , String fragment ) { topButton . setOnClickListener ( new View . OnClickListener ( ) { private long lastClickTime = <NUM_LIT> ; @ Override public void onClick ( View v ) { long currentTime = System . currentTimeMillis ( ) ; long timeDifference = currentTime - lastClickTime ; if ( timeDifference < <NUM_LIT> ) { topScroll ( fragment , recyclerView , scrollView ) ; } else { boolean switchState = Preferences . getSmoothScroll ( context ) ; if ( switchState ) { smoothTopScroll ( fragment , recyclerView , scrollView ) ; } else { topScroll ( fragment , recyclerView , scrollView ) ; } } lastClickTime = currentTime ; } } ) ; bottomButton . setOnClickListener ( new View . OnClickListener ( ) { private long lastClickTime = <NUM_LIT> ; @ Override public void onClick ( View v ) { long currentTime = System . currentTimeMillis ( ) ; long timeDifference = currentTime - lastClickTime ; if ( timeDifference < <NUM_LIT> ) { bottomScroll ( fragment , recyclerView , scrollView ) ; } else { boolean switchState = Preferences . getSmoothScroll ( context ) ; if ( switchState ) { smoothBottomScroll ( fragment , recyclerView , scrollView ) ; } else { bottomScroll ( fragment , recyclerView , scrollView ) ; } } lastClickTime = currentTime ; } } ) ; } private static void topScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == "<STR_LIT>" ) { recyclerView . scrollToPosition ( <NUM_LIT> ) ; } else { scrollView . scrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } } private static void smoothTopScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == "<STR_LIT>" ) { recyclerView . smoothScrollToPosition ( <NUM_LIT> ) ; } else { scrollView . smoothScrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } } private static void bottomScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == "<STR_LIT>" ) { recyclerView . scrollToPosition ( Objects . requireNonNull ( recyclerView . getAdapter ( ) ) . getItemCount ( ) - <NUM_LIT> ) ; } else { scrollView . fullScroll ( View . FOCUS_DOWN ) ; } } private static void smoothBottomScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == "<STR_LIT>" ) { recyclerView . smoothScrollToPosition ( Objects . requireNonNull ( recyclerView . getAdapter ( ) ) . getItemCount ( ) - <NUM_LIT> ) ; } else { scrollView . smoothScrollTo ( <NUM_LIT> , scrollView . getChildAt ( <NUM_LIT> ) . getBottom ( ) ) ; } } public static void pasteAndUndo ( ExtendedFloatingActionButton paste , FloatingActionButton undo , TextInputEditText editText ) { Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; paste . setOnClickListener ( v -> { undo . show ( ) ; mHandler . postDelayed ( ( ) -> { undo . hide ( ) ; mHandler . removeCallbacksAndMessages ( null ) ; } , <NUM_LIT> ) ; Utils . pasteFromClipboard ( editText ) ; } ) ; undo . setOnClickListener ( v -> { editText . setText ( null ) ; undo . hide ( ) ; mHandler . removeCallbacksAndMessages ( null ) ; } ) ; } } </s>
<s> package in . hridayan . ashell . activities ; import android . app . Activity ; import android . content . Context ; import android . content . res . Configuration ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . EditText ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . lifecycle . ViewModel ; import androidx . recyclerview . widget . GridLayoutManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import com . google . android . material . chip . Chip ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . search . SearchBar ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . CustomSearchView ; import in . hridayan . ashell . UI . ExamplesViewModel ; import in . hridayan . ashell . adapters . CommandsSearchAdapter ; import in . hridayan . ashell . adapters . ExamplesAdapter ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Commands ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; public class ExamplesActivity extends AppCompatActivity implements ExamplesAdapter . OnItemClickListener { private ExamplesViewModel viewModel ; private AppBarLayout appBarLayout ; private CustomSearchView searchView ; private RecyclerView mRecyclerView , mSearchRecyclerView ; private EditText editText ; private MaterialTextView noCommandFoundText ; private List < CommandItems > itemList ; private SearchBar mSearchBar ; private ExamplesAdapter mExamplesAdapter ; private Chip mSummaryChip ; private MenuItem sort , pin , selectAll , addBookmark , deselectAll ; private Menu searchBarMenu ; private View parent ; private int isSortingOptionSame ; private boolean isSummaryChipClicked = false , isAllItemsSelected ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( Utils . recyclerViewPosition ( mRecyclerView ) == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_examples ) ; parent = findViewById ( android . R . id . content ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; searchView = findViewById ( R . id . search_view ) ; mSearchBar = findViewById ( R . id . search_bar ) ; mSearchRecyclerView = findViewById ( R . id . search_recycler_view ) ; mSummaryChip = findViewById ( R . id . search_summary ) ; editText = searchView . getSearchEditText ( ) ; searchBarMenu = mSearchBar . getMenu ( ) ; sort = searchBarMenu . findItem ( R . id . sort ) ; addBookmark = searchBarMenu . findItem ( R . id . add_bookmark ) ; pin = searchBarMenu . findItem ( R . id . pin ) ; selectAll = searchBarMenu . findItem ( R . id . select_all ) ; deselectAll = searchBarMenu . findItem ( R . id . deselect_all ) ; noCommandFoundText = findViewById ( R . id . no_command_found ) ; itemList = Commands . commandList ( this ) ; viewModel = new ViewModelProvider ( this ) . get ( ExamplesViewModel . class ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; mSearchBar . clearFocus ( ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_search ) ; mSearchBar . setOnMenuItemClickListener ( item -> { switch ( item . getItemId ( ) ) { case R . id . sort : sortingDialog ( this , this ) ; return true ; case R . id . select_all : mExamplesAdapter . selectAll ( ) ; updateSearchBar ( ) ; return true ; case R . id . deselect_all : mExamplesAdapter . deselectAll ( ) ; updateSearchBar ( ) ; return true ; case R . id . add_bookmark : manageBookmarkAddOrRemove ( ) ; return true ; case R . id . pin : managePinUnpin ( ) ; return true ; default : return false ; } } ) ; mRecyclerView = findViewById ( R . id . recycler_view ) ; mSearchRecyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; mRecyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; GridLayoutManager mLayoutManager = new GridLayoutManager ( this , getResources ( ) . getConfiguration ( ) . orientation == Configuration . ORIENTATION_LANDSCAPE ? <NUM_LIT> : <NUM_LIT> ) ; mRecyclerView . setLayoutManager ( mLayoutManager ) ; mExamplesAdapter = new ExamplesAdapter ( Commands . commandList ( this ) , this ) ; mExamplesAdapter . sortData ( ) ; mExamplesAdapter . setOnItemClickListener ( this ) ; mRecyclerView . setAdapter ( mExamplesAdapter ) ; mRecyclerView . setVisibility ( View . VISIBLE ) ; editText . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence text , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence text , int i , int i1 , int i2 ) { } @ Override public void afterTextChanged ( Editable text ) { filterList ( text ) ; mSummaryChip . setOnClickListener ( v -> { isSummaryChipClicked = true ; filterList ( text ) ; } ) ; } } ) ; } private void filterList ( CharSequence text ) { List < CommandItems > filteredList = new ArrayList < > ( ) ; mSummaryChip . setVisibility ( View . GONE ) ; noCommandFoundText . setVisibility ( View . GONE ) ; if ( text != null && ! text . toString ( ) . isEmpty ( ) ) { searchTitle ( text , filteredList ) ; if ( filteredList . isEmpty ( ) ) { noCommandFoundText . setVisibility ( View . VISIBLE ) ; mSummaryChip . setVisibility ( View . VISIBLE ) ; if ( isSummaryChipClicked ) { chipSummaryOnClick ( text , filteredList ) ; } } if ( filteredList . isEmpty ( ) ) { noCommandFoundText . setVisibility ( View . VISIBLE ) ; } } mSearchRecyclerView . setVisibility ( View . VISIBLE ) ; CommandsSearchAdapter adapter = new CommandsSearchAdapter ( filteredList , this ) ; mSearchRecyclerView . setAdapter ( adapter ) ; } private void searchTitle ( CharSequence text , List < CommandItems > filteredList ) { for ( CommandItems item : itemList ) { if ( item . getTitle ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) ) { filteredList . add ( item ) ; } } } private void searchTitleAndSummary ( CharSequence text , List < CommandItems > filteredList ) { for ( CommandItems item : itemList ) { if ( item . getTitle ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) || item . getSummary ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) ) { filteredList . add ( item ) ; } } } private void chipSummaryOnClick ( CharSequence text , List < CommandItems > filteredList ) { noCommandFoundText . setVisibility ( View . GONE ) ; searchTitleAndSummary ( text , filteredList ) ; mSummaryChip . setVisibility ( View . GONE ) ; } private void sortingDialog ( Context context , Activity activity ) { CharSequence [ ] sortingOptions = { getString ( R . string . sort_A_Z ) , getString ( R . string . sort_Z_A ) , getString ( R . string . most_used ) , getString ( R . string . least_used ) } ; int currentSortingOption = Preferences . getSortingExamples ( context ) ; isSortingOptionSame = currentSortingOption ; final int [ ] sortingOption = { currentSortingOption } ; new MaterialAlertDialogBuilder ( activity ) . setTitle ( getString ( R . string . sort ) ) . setSingleChoiceItems ( sortingOptions , currentSortingOption , ( dialog , which ) -> { sortingOption [ <NUM_LIT> ] = which ; } ) . setPositiveButton ( getString ( R . string . ok ) , ( dialog , which ) -> { Preferences . setSortingExamples ( context , sortingOption [ <NUM_LIT> ] ) ; if ( isSortingOptionSame != sortingOption [ <NUM_LIT> ] ) { mExamplesAdapter . sortData ( ) ; } } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } private void updateSearchBar ( ) { int numSelectedItems = mExamplesAdapter . getSelectedItemsSize ( ) ; isAllItemsSelected = numSelectedItems == mExamplesAdapter . getItemCount ( ) ; if ( numSelectedItems > <NUM_LIT> ) { startSelection ( numSelectedItems ) ; } else { endSelection ( ) ; } } private void mSearchBarNavigationIconOnClickListener ( int numSelectedItems ) { mSearchBar . setNavigationOnClickListener ( v -> { if ( numSelectedItems > <NUM_LIT> ) { endSelection ( ) ; mExamplesAdapter . deselectAll ( ) ; } } ) ; } private void endSelection ( ) { mSearchBar . setHint ( R . string . search_command ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_search ) ; mSearchBar . setClickable ( true ) ; mSearchBarNavigationIconOnClickListener ( <NUM_LIT> ) ; updateMenuItemVisibility ( false , isAllItemsSelected ) ; } private void startSelection ( int numSelectedItems ) { String hint = getString ( R . string . selected ) + "<STR_LIT>" + "<STR_LIT>" + Integer . toString ( numSelectedItems ) + "<STR_LIT>" ; mSearchBar . setHint ( hint ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_cross ) ; mSearchBar . setClickable ( false ) ; mSearchBarNavigationIconOnClickListener ( numSelectedItems ) ; updateMenuItemVisibility ( true , isAllItemsSelected ) ; } private void updateMenuItemVisibility ( boolean isItemSelecting , boolean isAllSelected ) { sort . setVisible ( ! isItemSelecting ) ; pin . setVisible ( isItemSelecting ) ; selectAll . setVisible ( isItemSelecting && ! isAllSelected ) ; deselectAll . setVisible ( isItemSelecting && isAllSelected ) ; if ( isItemSelecting ) { addBookmark . setVisible ( true ) ; addBookmark . setIcon ( mExamplesAdapter . isAllItemsBookmarked ( ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark ) ; pin . setIcon ( mExamplesAdapter . isAllItemsPinned ( ) ? R . drawable . ic_pinned : R . drawable . ic_pin ) ; } else { addBookmark . setVisible ( false ) ; } } private void batchBookmarkDialog ( int selectedCount , boolean isAllItemBookmarked , boolean isLimitReached , boolean isBatch ) { String message = isAllItemBookmarked ? getString ( R . string . confirm_batch_remove_bookmark , selectedCount ) : getString ( R . string . confirm_batch_add_bookmark , selectedCount ) ; new MaterialAlertDialogBuilder ( this ) . setTitle ( getString ( R . string . confirm ) ) . setMessage ( message ) . setPositiveButton ( getString ( R . string . ok ) , ( dialog , i ) -> { if ( isAllItemBookmarked ) { mExamplesAdapter . deleteSelectedFromBookmarks ( ) ; } else if ( ! isLimitReached ) { mExamplesAdapter . addSelectedToBookmarks ( ) ; } updateSearchBar ( ) ; bookmarksAddedOrRemovedMessage ( ! isAllItemBookmarked , isBatch , isLimitReached , selectedCount ) ; } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } private void manageBookmarkAddOrRemove ( ) { int selectedItems = mExamplesAdapter . getSelectedItemsSize ( ) ; boolean isAllItemBookmarked = mExamplesAdapter . isAllItemsBookmarked ( ) , isLimitReached = selectedItems + Utils . getBookmarks ( this ) . size ( ) > Preferences . MAX_BOOKMARKS_LIMIT && ! Preferences . getOverrideBookmarks ( this ) ; boolean isBatch = selectedItems > <NUM_LIT> ; if ( isBatch ) { batchBookmarkDialog ( selectedItems , isAllItemBookmarked , isLimitReached , isBatch ) ; } else { if ( isAllItemBookmarked ) { mExamplesAdapter . deleteSelectedFromBookmarks ( ) ; } else if ( ! isLimitReached ) { mExamplesAdapter . addSelectedToBookmarks ( ) ; } updateSearchBar ( ) ; bookmarksAddedOrRemovedMessage ( ! isAllItemBookmarked , isBatch , isLimitReached , selectedItems ) ; } } private void bookmarksAddedOrRemovedMessage ( boolean isAdded , boolean isBatch , boolean isLimitReached , int selectedCount ) { if ( isLimitReached && isAdded ) { Utils . snackBar ( parent , getString ( R . string . bookmark_limit_reached ) ) . show ( ) ; } else if ( isBatch ) { int message = isAdded ? R . string . batch_bookmark_added_message : R . string . batch_bookmark_removed_message ; Utils . snackBar ( parent , getString ( message , selectedCount ) ) . show ( ) ; } else { String command = mExamplesAdapter . sanitizeText ( mExamplesAdapter . selectedItems . get ( <NUM_LIT> ) . getTitle ( ) ) ; int message = isAdded ? R . string . bookmark_added_message : R . string . bookmark_removed_message ; Utils . snackBar ( parent , getString ( message , command ) ) . show ( ) ; } } private void managePinUnpin ( ) { int size = mExamplesAdapter . getSelectedItemsSize ( ) ; String title = mExamplesAdapter . selectedItems . get ( <NUM_LIT> ) . getTitle ( ) ; boolean isBatch = size > <NUM_LIT> ; boolean isAllItemsPinned = mExamplesAdapter . isAllItemsPinned ( ) ; String confirmPin = isBatch ? getString ( R . string . confirm_pin ) : getString ( R . string . confirm_pin_single , title ) ; String confirmUnpin = isBatch ? getString ( R . string . confirm_unpin ) : getString ( R . string . confirm_unpin_single , title ) ; String message = isAllItemsPinned ? confirmUnpin : confirmPin ; String positiveButtonText = isAllItemsPinned ? getString ( R . string . unpin ) : getString ( R . string . pin ) ; String snackBarMessage ; if ( isBatch ) { snackBarMessage = isAllItemsPinned ? getString ( R . string . batch_unpinned_message , size ) : getString ( R . string . batch_pinned_message , size ) ; } else { snackBarMessage = isAllItemsPinned ? getString ( R . string . unpinned_message , title ) : getString ( R . string . pinned_message , title ) ; } new MaterialAlertDialogBuilder ( this ) . setTitle ( getString ( R . string . confirm ) ) . setMessage ( message ) . setPositiveButton ( positiveButtonText , ( dialog , i ) -> { mExamplesAdapter . pinUnpinSelectedItems ( isAllItemsPinned ) ; endSelection ( ) ; updateSearchBar ( ) ; Utils . snackBar ( parent , snackBarMessage ) . show ( ) ; } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } @ Override public void onItemClick ( int position ) { updateSearchBar ( ) ; } @ Override public void onItemLongClick ( int position ) { updateSearchBar ( ) ; } } </s>
<s> package in . hridayan . ashell . fragments ; import static in . hridayan . ashell . utils . OtgUtils . MessageOtg . CONNECTING ; import static in . hridayan . ashell . utils . OtgUtils . MessageOtg . DEVICE_FOUND ; import static in . hridayan . ashell . utils . OtgUtils . MessageOtg . DEVICE_NOT_FOUND ; import static in . hridayan . ashell . utils . OtgUtils . MessageOtg . FLASHING ; import static in . hridayan . ashell . utils . OtgUtils . MessageOtg . INSTALLING_PROGRESS ; import android . app . PendingIntent ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . hardware . usb . UsbDevice ; import android . hardware . usb . UsbDeviceConnection ; import android . hardware . usb . UsbInterface ; import android . hardware . usb . UsbManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . View ; import android . view . ViewGroup ; import android . view . inputmethod . EditorInfo ; import android . widget . ProgressBar ; import android . widget . ScrollView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . widget . AppCompatImageButton ; import androidx . appcompat . widget . LinearLayoutCompat ; import androidx . appcompat . widget . PopupMenu ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . cgutman . adblib . AdbBase64 ; import com . cgutman . adblib . AdbConnection ; import com . cgutman . adblib . AdbCrypto ; import com . cgutman . adblib . AdbStream ; import com . cgutman . adblib . UsbChannel ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . card . MaterialCardView ; import com . google . android . material . chip . Chip ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . floatingactionbutton . ExtendedFloatingActionButton ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import com . google . android . material . textfield . TextInputEditText ; import com . google . android . material . textfield . TextInputLayout ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . BehaviorFAB ; import in . hridayan . ashell . UI . BehaviorFAB . FabExtendingOnScrollListener ; import in . hridayan . ashell . UI . BehaviorFAB . FabExtendingOnScrollViewListener ; import in . hridayan . ashell . UI . BehaviorFAB . FabOtgScrollDownListener ; import in . hridayan . ashell . UI . BehaviorFAB . FabOtgScrollUpListener ; import in . hridayan . ashell . UI . BehaviorFAB . OtgShareButtonListener ; import in . hridayan . ashell . UI . CoordinatedNestedScrollView ; import in . hridayan . ashell . UI . KeyboardUtils ; import in . hridayan . ashell . activities . ExamplesActivity ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . activities . SettingsActivity ; import in . hridayan . ashell . adapters . CommandsAdapter ; import in . hridayan . ashell . adapters . SettingsAdapter ; import in . hridayan . ashell . utils . Commands ; import in . hridayan . ashell . utils . OtgUtils ; import in . hridayan . ashell . utils . OtgUtils . Const ; import in . hridayan . ashell . utils . OtgUtils . MessageOtg ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . Utils ; import java . io . File ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class otgShellFragment extends Fragment implements TextView . OnEditorActionListener , View . OnKeyListener { private Handler handler ; private UsbDevice mDevice ; private TextView tvStatus ; private MaterialTextView logs ; private AppCompatImageButton mCable , dismissCard ; private AdbCrypto adbCrypto ; private AdbConnection adbConnection ; private UsbManager mManager ; private BottomNavigationView mNav ; private CommandsAdapter mCommandsAdapter ; private Chip mChip ; private LinearLayoutCompat terminalView ; private MaterialButton mSettingsButton , mBookMarks , mHistoryButton , mClearButton , instructionsButton ; private RecyclerView mRecyclerViewCommands ; private SettingsAdapter adapter ; private MaterialCardView mShellCard , mWarningUsbDebugging ; private TextInputLayout mCommandInput ; private TextInputEditText mCommand ; private FloatingActionButton mSendButton , mUndoButton , mTopButton , mBottomButton , mShareButton ; private ExtendedFloatingActionButton mPasteButton , mSaveButton ; private CoordinatedNestedScrollView scrollView ; private AlertDialog mWaitingDialog ; private String user = null , deviceName ; private final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; private boolean isKeyboardVisible , sendButtonClicked = false , isSendDrawable = false ; private List < String > mHistory = null , shellOutput , history ; private View view ; private AdbStream stream ; private Context context ; private OnFragmentInteractionListener mListener ; public interface OnFragmentInteractionListener { void onRequestReset ( ) ; } @ Override public void onDetach ( ) { super . onDetach ( ) ; mListener = null ; } @ Override public void onAttach ( @ NonNull Context mContext ) { super . onAttach ( mContext ) ; context = mContext ; if ( context instanceof OnFragmentInteractionListener ) { mListener = ( OnFragmentInteractionListener ) context ; } else { throw new RuntimeException ( context . toString ( ) + "<STR_LIT>" ) ; } } @ Override public void onResume ( ) { super . onResume ( ) ; KeyboardUtils . disableKeyboard ( context , requireActivity ( ) , view ) ; if ( Preferences . getSpecificCardVisibility ( context , "<STR_LIT>" ) && adbConnection == null ) { mWarningUsbDebugging . setVisibility ( View . VISIBLE ) ; } else if ( mWarningUsbDebugging . getVisibility ( ) == View . VISIBLE ) { mWarningUsbDebugging . setVisibility ( View . GONE ) ; } MainActivity activity = ( MainActivity ) getActivity ( ) ; if ( activity != null ) { String pendingSharedText = activity . getPendingSharedText ( ) ; if ( pendingSharedText != null ) { updateInputField ( pendingSharedText ) ; activity . clearPendingSharedText ( ) ; } } } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mUsbReceiver != null ) { requireContext ( ) . unregisterReceiver ( mUsbReceiver ) ; } try { if ( adbConnection != null ) { adbConnection . close ( ) ; adbConnection = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } BroadcastReceiver mUsbReceiver = new BroadcastReceiver ( ) { public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; Log . d ( Const . TAG , "<STR_LIT>" + action ) ; if ( UsbManager . ACTION_USB_DEVICE_DETACHED . equals ( action ) ) { UsbDevice device = intent . getParcelableExtra ( UsbManager . EXTRA_DEVICE ) ; deviceName = device . getDeviceName ( ) ; if ( mDevice != null && mDevice . getDeviceName ( ) . equals ( deviceName ) ) { try { Log . d ( Const . TAG , "<STR_LIT>" ) ; setAdbInterface ( null , null ) ; } catch ( Exception e ) { Log . w ( Const . TAG , "<STR_LIT>" , e ) ; } } } else if ( UsbManager . ACTION_USB_DEVICE_ATTACHED . equals ( action ) ) { UsbDevice device = intent . getParcelableExtra ( UsbManager . EXTRA_DEVICE ) ; asyncRefreshAdbConnection ( device ) ; mListener . onRequestReset ( ) ; } else if ( MessageOtg . USB_PERMISSION . equals ( action ) ) { System . out . println ( "<STR_LIT>" ) ; UsbDevice usbDevice = intent . getParcelableExtra ( UsbManager . EXTRA_DEVICE ) ; handler . sendEmptyMessage ( CONNECTING ) ; if ( mManager . hasPermission ( usbDevice ) ) asyncRefreshAdbConnection ( usbDevice ) ; else mManager . requestPermission ( usbDevice , PendingIntent . getBroadcast ( requireContext ( ) . getApplicationContext ( ) , <NUM_LIT> , new Intent ( MessageOtg . USB_PERMISSION ) , PendingIntent . FLAG_IMMUTABLE ) ) ; } } } ; @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { context = getContext ( ) ; if ( context == null ) { return view ; } view = inflater . inflate ( R . layout . fragment_otg , container , false ) ; List < SettingsItem > settingsList = new ArrayList < > ( ) ; adapter = new SettingsAdapter ( settingsList , requireContext ( ) ) ; logs = view . findViewById ( R . id . logs ) ; mBookMarks = view . findViewById ( R . id . bookmarks ) ; mBottomButton = view . findViewById ( R . id . fab_down ) ; mCable = view . findViewById ( R . id . otg_cable ) ; mClearButton = view . findViewById ( R . id . clear ) ; mChip = view . findViewById ( R . id . chip ) ; mCommand = view . findViewById ( R . id . shell_command ) ; mCommandInput = view . findViewById ( R . id . shell_command_layout ) ; dismissCard = view . findViewById ( R . id . dimiss_card ) ; mHistoryButton = view . findViewById ( R . id . history ) ; mManager = ( UsbManager ) requireActivity ( ) . getSystemService ( Context . USB_SERVICE ) ; mNav = requireActivity ( ) . findViewById ( R . id . bottom_nav_bar ) ; mPasteButton = view . findViewById ( R . id . paste_button ) ; mRecyclerViewCommands = view . findViewById ( R . id . rv_commands ) ; mSaveButton = view . findViewById ( R . id . save_button ) ; mSendButton = view . findViewById ( R . id . send ) ; mSettingsButton = view . findViewById ( R . id . settings ) ; mShellCard = view . findViewById ( R . id . otg_shell_card ) ; scrollView = view . findViewById ( R . id . scrollView ) ; mShareButton = view . findViewById ( R . id . fab_share ) ; terminalView = view . findViewById ( R . id . terminalView ) ; mTopButton = view . findViewById ( R . id . fab_up ) ; mUndoButton = view . findViewById ( R . id . fab_undo ) ; mWarningUsbDebugging = view . findViewById ( R . id . warning_usb_debugging ) ; instructionsButton = view . findViewById ( R . id . instructions_button ) ; mRecyclerViewCommands . addOnScrollListener ( new FabExtendingOnScrollListener ( mPasteButton ) ) ; mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; new FabExtendingOnScrollViewListener ( scrollView , mSaveButton ) ; new FabOtgScrollUpListener ( scrollView , mTopButton ) ; new FabOtgScrollDownListener ( scrollView , mBottomButton ) ; new OtgShareButtonListener ( scrollView , mShareButton ) ; BehaviorFAB . pasteAndUndo ( mPasteButton , mUndoButton , mCommand ) ; BehaviorFAB . handleTopAndBottomArrow ( mTopButton , mBottomButton , null , scrollView , context , "<STR_LIT>" ) ; KeyboardUtils . attachVisibilityListener ( requireActivity ( ) , new KeyboardUtils . KeyboardVisibilityListener ( ) { public void onKeyboardVisibilityChanged ( boolean visible ) { isKeyboardVisible = visible ; if ( isKeyboardVisible ) { mPasteButton . setVisibility ( View . GONE ) ; mUndoButton . setVisibility ( View . GONE ) ; mSaveButton . setVisibility ( View . GONE ) ; mShareButton . setVisibility ( View . GONE ) ; } else { if ( mPasteButton . getVisibility ( ) == View . GONE ) { if ( ! sendButtonClicked ) { setVisibilityWithDelay ( mPasteButton , <NUM_LIT> ) ; } else if ( scrollView . getChildAt ( <NUM_LIT> ) . getHeight ( ) != <NUM_LIT> ) { setVisibilityWithDelay ( mSaveButton , <NUM_LIT> ) ; setVisibilityWithDelay ( mShareButton , <NUM_LIT> ) ; } } } } } ) ; mNav . setVisibility ( View . VISIBLE ) ; if ( Preferences . getSpecificCardVisibility ( context , "<STR_LIT>" ) && adbConnection == null ) { mWarningUsbDebugging . setVisibility ( View . VISIBLE ) ; } else if ( mWarningUsbDebugging . getVisibility ( ) == View . VISIBLE ) { mWarningUsbDebugging . setVisibility ( View . GONE ) ; } instructionsButton . setOnClickListener ( v -> { Utils . openUrl ( context , "<STR_LIT>" ) ; } ) ; dismissCard . setOnClickListener ( v -> { mWarningUsbDebugging . setVisibility ( View . GONE ) ; Preferences . setSpecificCardVisibility ( context , "<STR_LIT>" , false ) ; } ) ; mChipOnClickListener ( ) ; if ( isSendDrawable ) { mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; } else { mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . setOnClickListener ( v -> { Intent examples = new Intent ( requireActivity ( ) , ExamplesActivity . class ) ; startActivity ( examples ) ; } ) ; } mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; mCommand . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { isSendDrawable = mCommand . getText ( ) != null ; mCommandInput . setError ( null ) ; mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; } @ Override public void afterTextChanged ( Editable s ) { mCommand . requestFocus ( ) ; String inputText = s . toString ( ) ; if ( inputText . isEmpty ( ) ) { mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; mCommandInput . setEndIconVisible ( false ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent examples = new Intent ( requireActivity ( ) , ExamplesActivity . class ) ; startActivity ( examples ) ; } } ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> { if ( s . toString ( ) . contains ( "<STR_LIT>" ) && s . toString ( ) . contains ( "<STR_LIT>" ) ) { String [ ] splitCommands = { s . toString ( ) . substring ( <NUM_LIT> , lastIndexOf ( s . toString ( ) , "<STR_LIT>" ) ) , s . toString ( ) . substring ( lastIndexOf ( s . toString ( ) , "<STR_LIT>" ) ) } ; String packageNamePrefix ; if ( splitCommands [ <NUM_LIT> ] . contains ( "<STR_LIT>" ) ) { packageNamePrefix = splitPrefix ( splitCommands [ <NUM_LIT> ] , <NUM_LIT> ) ; } else { packageNamePrefix = splitCommands [ <NUM_LIT> ] ; } mCommandsAdapter = new CommandsAdapter ( Commands . getPackageInfo ( packageNamePrefix + "<STR_LIT>" , context ) ) ; if ( isAdded ( ) ) { mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; } if ( isAdded ( ) ) { mRecyclerViewCommands . setAdapter ( mCommandsAdapter ) ; } mRecyclerViewCommands . setVisibility ( View . VISIBLE ) ; mCommandsAdapter . setOnItemClickListener ( ( command , v ) -> { mCommand . setText ( splitCommands [ <NUM_LIT> ] . contains ( "<STR_LIT>" ) ? splitPrefix ( splitCommands [ <NUM_LIT> ] , <NUM_LIT> ) + "<STR_LIT>" + command : command ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; mRecyclerViewCommands . setVisibility ( View . GONE ) ; } ) ; } else { mCommandsAdapter = new CommandsAdapter ( Commands . getCommand ( s . toString ( ) , context ) ) ; if ( isAdded ( ) ) { mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; } mRecyclerViewCommands . setAdapter ( mCommandsAdapter ) ; mRecyclerViewCommands . setVisibility ( View . VISIBLE ) ; mCommandsAdapter . setOnItemClickListener ( ( command , v ) -> { mCommand . setText ( command . contains ( "<STR_LIT>" ) ? command . split ( "<STR_LIT>" ) [ <NUM_LIT> ] : command ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } ) ; } } ) ; mCommandInput . setEndIconDrawable ( Utils . getDrawable ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark , requireActivity ( ) ) ) ; mCommandInput . setEndIconVisible ( true ) ; mCommandInput . setEndIconOnClickListener ( v -> { if ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ) { Utils . deleteFromBookmark ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ; Utils . snackBar ( view , getString ( R . string . bookmark_removed_message , s . toString ( ) . trim ( ) ) ) . show ( ) ; } else { Utils . addBookmarkIconOnClickListener ( s . toString ( ) . trim ( ) , view , context ) ; } mCommandInput . setEndIconDrawable ( Utils . getDrawable ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark , requireActivity ( ) ) ) ; mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; } ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; mSendButton . setOnClickListener ( v -> { KeyboardUtils . closeKeyboard ( requireActivity ( ) , v ) ; mChipOnClickListener ( ) ; sendButtonClicked = true ; mPasteButton . hide ( ) ; mUndoButton . hide ( ) ; if ( mRecyclerViewCommands . getVisibility ( ) == View . VISIBLE ) { mRecyclerViewCommands . setVisibility ( View . GONE ) ; } if ( adbConnection != null ) { mHistoryButton . setVisibility ( View . VISIBLE ) ; if ( mHistory == null ) { mHistory = new ArrayList < > ( ) ; } mHistory . add ( mCommand . getText ( ) . toString ( ) ) ; putCommand ( ) ; } else { mCommandInput . setError ( getString ( R . string . device_not_connected ) ) ; mCommandInput . setErrorIconDrawable ( Utils . getDrawable ( R . drawable . ic_cancel , requireActivity ( ) ) ) ; mCommandInput . setErrorIconOnClickListener ( t -> { mCommand . setText ( null ) ; } ) ; Utils . alignMargin ( mSendButton ) ; Utils . alignMargin ( mCable ) ; new MaterialAlertDialogBuilder ( requireActivity ( ) ) . setTitle ( requireActivity ( ) . getString ( R . string . error ) ) . setMessage ( requireActivity ( ) . getString ( R . string . otg_not_connected ) ) . setPositiveButton ( requireActivity ( ) . getString ( R . string . ok ) , ( dialogInterface , i ) -> { } ) . show ( ) ; } } ) ; } } } ) ; mClearButton . setTooltipText ( getString ( R . string . clear_screen ) ) ; mClearButton . setOnClickListener ( v -> { boolean switchState = Preferences . getClear ( context ) ; if ( switchState ) { new MaterialAlertDialogBuilder ( requireActivity ( ) ) . setTitle ( getString ( R . string . clear_everything ) ) . setMessage ( getString ( R . string . clear_all_message ) ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setPositiveButton ( getString ( R . string . yes ) , ( dialogInterface , i ) -> { clearAll ( ) ; } ) . show ( ) ; } else { clearAll ( ) ; } } ) ; mBookMarks . setTooltipText ( getString ( R . string . bookmarks ) ) ; mBookMarks . setOnClickListener ( v -> { Utils . bookmarksDialog ( context , requireActivity ( ) , mCommand , mCommandInput , mBookMarks ) ; } ) ; mHistoryButton . setTooltipText ( getString ( R . string . history ) ) ; mHistoryButton . setOnClickListener ( v -> { PopupMenu popupMenu = new PopupMenu ( requireContext ( ) , mCommand ) ; Menu menu = popupMenu . getMenu ( ) ; for ( int i = <NUM_LIT> ; i < getRecentCommands ( ) . size ( ) ; i ++ ) { menu . add ( Menu . NONE , i , Menu . NONE , getRecentCommands ( ) . get ( i ) ) ; } popupMenu . setOnMenuItemClickListener ( item -> { for ( int i = <NUM_LIT> ; i < getRecentCommands ( ) . size ( ) ; i ++ ) { if ( item . getItemId ( ) == i ) { mCommand . setText ( getRecentCommands ( ) . get ( i ) ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } } return false ; } ) ; popupMenu . show ( ) ; } ) ; mSettingsButton . setTooltipText ( getString ( R . string . settings ) ) ; mSettingsButton . setOnClickListener ( v -> { Intent settingsIntent = new Intent ( requireActivity ( ) , SettingsActivity . class ) ; startActivity ( settingsIntent ) ; } ) ; handler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( @ NonNull android . os . Message msg ) { if ( ! isAdded ( ) ) { return ; } switch ( msg . what ) { case DEVICE_FOUND : initCommand ( ) ; if ( adbConnection != null ) { mCable . setColorFilter ( Utils . getColor ( R . color . green , requireActivity ( ) ) ) ; } Toast . makeText ( context , getString ( R . string . connected ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; case CONNECTING : if ( adbConnection == null ) { mWarningUsbDebugging . setVisibility ( View . GONE ) ; waitingDialog ( context ) ; } break ; case DEVICE_NOT_FOUND : mCable . clearColorFilter ( ) ; adbConnection = null ; break ; case FLASHING : Toast . makeText ( requireContext ( ) , getString ( R . string . flashing ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; case INSTALLING_PROGRESS : Toast . makeText ( requireContext ( ) , getString ( R . string . progress ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; } } } ; AdbBase64 base64 = new OtgUtils . MyAdbBase64 ( ) ; try { adbCrypto = AdbCrypto . loadAdbKeyPair ( base64 , new File ( requireActivity ( ) . getFilesDir ( ) , "<STR_LIT>" ) , new File ( requireActivity ( ) . getFilesDir ( ) , "<STR_LIT>" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( adbCrypto == null ) { try { adbCrypto = AdbCrypto . generateAdbKeyPair ( base64 ) ; adbCrypto . saveAdbKeyPair ( new File ( requireActivity ( ) . getFilesDir ( ) , "<STR_LIT>" ) , new File ( requireActivity ( ) . getFilesDir ( ) , "<STR_LIT>" ) ) ; } catch ( Exception e ) { Log . w ( Const . TAG , getString ( R . string . generate_key_failed ) , e ) ; } } IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( UsbManager . ACTION_USB_DEVICE_DETACHED ) ; filter . addAction ( UsbManager . ACTION_USB_DEVICE_ATTACHED ) ; filter . addAction ( MessageOtg . USB_PERMISSION ) ; ContextCompat . registerReceiver ( requireContext ( ) , mUsbReceiver , filter , ContextCompat . RECEIVER_NOT_EXPORTED ) ; UsbDevice device = requireActivity ( ) . getIntent ( ) . getParcelableExtra ( UsbManager . EXTRA_DEVICE ) ; if ( device != null ) { System . out . println ( "<STR_LIT>" ) ; asyncRefreshAdbConnection ( device ) ; } else { System . out . println ( "<STR_LIT>" ) ; for ( String k : mManager . getDeviceList ( ) . keySet ( ) ) { UsbDevice usbDevice = mManager . getDeviceList ( ) . get ( k ) ; handler . sendEmptyMessage ( CONNECTING ) ; if ( mManager . hasPermission ( usbDevice ) ) { asyncRefreshAdbConnection ( usbDevice ) ; } else { mManager . requestPermission ( usbDevice , PendingIntent . getBroadcast ( requireActivity ( ) . getApplicationContext ( ) , <NUM_LIT> , new Intent ( MessageOtg . USB_PERMISSION ) , PendingIntent . FLAG_IMMUTABLE ) ) ; } } } mSaveButton . setOnClickListener ( v -> { history = mHistory ; String shellOutput = Utils . lastCommandOutput ( logs . getText ( ) . toString ( ) ) ; boolean saved = Utils . saveToFile ( shellOutput , requireActivity ( ) , mHistory ) ; Utils . outputSavedDialog ( requireActivity ( ) , context , saved ) ; } ) ; mShareButton . setOnClickListener ( v -> { Utils . shareOutput ( requireActivity ( ) , context , mHistory , Utils . lastCommandOutput ( logs . getText ( ) . toString ( ) ) ) ; } ) ; mCommand . setOnEditorActionListener ( this ) ; mCommand . setOnKeyListener ( this ) ; return view ; } private void waitingDialog ( Context context ) { if ( isAdded ( ) ) { View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . loading_dialog_layout , null ) ; ProgressBar progressBar = dialogView . findViewById ( R . id . progressBar ) ; mWaitingDialog = new MaterialAlertDialogBuilder ( context ) . setCancelable ( false ) . setView ( dialogView ) . setTitle ( context . getString ( R . string . waiting_device ) ) . setPositiveButton ( getString ( R . string . ok ) , ( dialogInterface , i ) -> { if ( mListener != null ) { mListener . onRequestReset ( ) ; } } ) . show ( ) ; progressBar . setVisibility ( View . VISIBLE ) ; } } private void closeWaiting ( ) { if ( mWaitingDialog != null && mWaitingDialog . isShowing ( ) ) { mWaitingDialog . dismiss ( ) ; } } public void asyncRefreshAdbConnection ( final UsbDevice device ) { if ( device != null ) { new Thread ( ) { @ Override public void run ( ) { final UsbInterface intf = findAdbInterface ( device ) ; try { setAdbInterface ( device , intf ) ; } catch ( Exception e ) { Log . w ( Const . TAG , getString ( R . string . set_adb_interface_fail ) , e ) ; } } } . start ( ) ; } } private UsbInterface findAdbInterface ( UsbDevice device ) { int count = device . getInterfaceCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UsbInterface intf = device . getInterface ( i ) ; if ( intf . getInterfaceClass ( ) == <NUM_LIT> && intf . getInterfaceSubclass ( ) == <NUM_LIT> && intf . getInterfaceProtocol ( ) == <NUM_LIT> ) { return intf ; } } return null ; } private synchronized boolean setAdbInterface ( UsbDevice device , UsbInterface intf ) throws IOException , InterruptedException { if ( adbConnection != null ) { adbConnection . close ( ) ; adbConnection = null ; mDevice = null ; } if ( device != null && intf != null ) { UsbDeviceConnection connection = mManager . openDevice ( device ) ; if ( connection != null ) { if ( connection . claimInterface ( intf , false ) ) { handler . sendEmptyMessage ( CONNECTING ) ; adbConnection = AdbConnection . create ( new UsbChannel ( connection , intf ) , adbCrypto ) ; adbConnection . connect ( ) ; adbConnection . open ( "<STR_LIT>" ) ; mDevice = device ; handler . sendEmptyMessage ( DEVICE_FOUND ) ; return true ; } else { connection . close ( ) ; } } } handler . sendEmptyMessage ( DEVICE_NOT_FOUND ) ; mDevice = null ; return false ; } private void initCommand ( ) { try { stream = adbConnection . open ( "<STR_LIT>" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return ; } new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( ! stream . isClosed ( ) ) { try { final String [ ] output = { new String ( stream . read ( ) , "<STR_LIT>" ) } ; handler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( user == null ) { user = output [ <NUM_LIT> ] . substring ( <NUM_LIT> , output [ <NUM_LIT> ] . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; } else if ( output [ <NUM_LIT> ] . contains ( user ) ) { System . out . println ( "<STR_LIT>" + user ) ; } logs . append ( output [ <NUM_LIT> ] ) ; scrollView . post ( new Runnable ( ) { @ Override public void run ( ) { scrollView . fullScroll ( ScrollView . FOCUS_DOWN ) ; mCommand . requestFocus ( ) ; } } ) ; } } ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; return ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } } } } ) . start ( ) ; mClearButton . setVisibility ( View . VISIBLE ) ; logs . setText ( "<STR_LIT>" ) ; mShellCard . setVisibility ( View . VISIBLE ) ; mChipOnClickListener ( ) ; } private void putCommand ( ) { if ( ! mCommand . getText ( ) . toString ( ) . isEmpty ( ) ) { mShellCard . setVisibility ( View . VISIBLE ) ; mClearButton . setVisibility ( View . VISIBLE ) ; try { String cmd = mCommand . getText ( ) . toString ( ) ; if ( cmd . equalsIgnoreCase ( "<STR_LIT>" ) ) { clearAll ( ) ; } else if ( cmd . equalsIgnoreCase ( "<STR_LIT>" ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) ; } else if ( cmd . equalsIgnoreCase ( "<STR_LIT>" ) ) { requireActivity ( ) . finish ( ) ; } else { stream . write ( ( cmd + "<STR_LIT>" ) . getBytes ( "<STR_LIT>" ) ) ; } mCommand . setText ( "<STR_LIT>" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } else Toast . makeText ( requireContext ( ) , getString ( R . string . no_command ) , Toast . LENGTH_SHORT ) . show ( ) ; } public void open ( View view ) { } @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( adbConnection != null && actionId == EditorInfo . IME_ACTION_DONE ) { putCommand ( ) ; } return true ; } @ Override public boolean onKey ( View v , int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_ENTER ) { return onEditorAction ( ( TextView ) v , EditorInfo . IME_ACTION_DONE , event ) ; } else { return false ; } } private List < String > getRecentCommands ( ) { List < String > mRecentCommands = new ArrayList < > ( mHistory ) ; Collections . reverse ( mRecentCommands ) ; return mRecentCommands ; } private int lastIndexOf ( String s , String splitTxt ) { return s . lastIndexOf ( splitTxt ) ; } private String splitPrefix ( String s , int i ) { String [ ] splitPrefix = { s . substring ( <NUM_LIT> , lastIndexOf ( s , "<STR_LIT>" ) ) , s . substring ( lastIndexOf ( s , "<STR_LIT>" ) ) } ; return splitPrefix [ i ] . trim ( ) ; } private void setVisibilityWithDelay ( View view , int delayMillis ) { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( ( ) -> { view . setVisibility ( View . VISIBLE ) ; } , delayMillis ) ; } public void updateInputField ( String sharedText ) { if ( sharedText != null ) { mCommand . setText ( sharedText ) ; mCommand . requestFocus ( ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } } private void clearAll ( ) { String log = logs . getText ( ) . toString ( ) ; String [ ] logSplit = log . split ( "<STR_LIT>" ) ; logs . setText ( logSplit [ logSplit . length - <NUM_LIT> ] ) ; if ( mTopButton . getVisibility ( ) == View . VISIBLE ) { mTopButton . setVisibility ( View . GONE ) ; } if ( mBottomButton . getVisibility ( ) == View . VISIBLE ) { mBottomButton . setVisibility ( View . GONE ) ; } mClearButton . setVisibility ( View . GONE ) ; mSaveButton . setVisibility ( View . GONE ) ; mShareButton . setVisibility ( View . GONE ) ; showBottomNav ( ) ; } private void mChipOnClickListener ( ) { mChip . setOnClickListener ( v -> { String connectedDevice = mDevice . getProductName ( ) ; Utils . connectedDeviceDialog ( context , mDevice == null ? getString ( R . string . none ) : connectedDevice ) ; mChip . setChecked ( ! mChip . isChecked ( ) ) ; } ) ; } private void showBottomNav ( ) { if ( getActivity ( ) != null && getActivity ( ) instanceof MainActivity ) { ( ( MainActivity ) getActivity ( ) ) . mNav . animate ( ) . translationY ( <NUM_LIT> ) ; } } } </s>
<s> package in . hridayan . ashell . utils ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . List ; import rikka . shizuku . Shizuku ; import rikka . shizuku . ShizukuRemoteProcess ; public class ShizukuShell { private static List < String > mOutput ; private static ShizukuRemoteProcess mProcess = null ; private static String mCommand ; private static String mDir = "<STR_LIT>" ; public ShizukuShell ( List < String > output , String command ) { mOutput = output ; mCommand = command ; } public boolean isBusy ( ) { return mOutput != null && mOutput . size ( ) > <NUM_LIT> && ! mOutput . get ( mOutput . size ( ) - <NUM_LIT> ) . equals ( "<STR_LIT>" ) ; } public void exec ( ) { try { mProcess = Shizuku . newProcess ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , mCommand } , null , mDir ) ; BufferedReader mInput = new BufferedReader ( new InputStreamReader ( mProcess . getInputStream ( ) ) ) ; BufferedReader mError = new BufferedReader ( new InputStreamReader ( mProcess . getErrorStream ( ) ) ) ; String line ; while ( ( line = mInput . readLine ( ) ) != null ) { mOutput . add ( line ) ; } while ( ( line = mError . readLine ( ) ) != null ) { mOutput . add ( "<STR_LIT>" + line + "<STR_LIT>" ) ; } if ( mCommand . startsWith ( "<STR_LIT>" ) && ! mOutput . get ( mOutput . size ( ) - <NUM_LIT> ) . endsWith ( "<STR_LIT>" ) ) { String [ ] array = mCommand . split ( "<STR_LIT>" ) ; String dir ; if ( array [ array . length - <NUM_LIT> ] . equals ( "<STR_LIT>" ) ) { dir = "<STR_LIT>" ; } else if ( array [ array . length - <NUM_LIT> ] . startsWith ( "<STR_LIT>" ) ) { dir = array [ array . length - <NUM_LIT> ] ; } else { dir = mDir + array [ array . length - <NUM_LIT> ] ; } if ( ! dir . endsWith ( "<STR_LIT>" ) ) { dir = dir + "<STR_LIT>" ; } mDir = dir ; } mProcess . waitFor ( ) ; } catch ( Exception ignored ) { } } public void destroy ( ) { if ( mProcess != null ) mProcess . destroy ( ) ; } } </s>
<s> package in . hridayan . ashell . activities ; import android . os . Bundle ; import android . widget . ImageView ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . SettingsViewModel ; import in . hridayan . ashell . adapters . SettingsAdapter ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class SettingsActivity extends AppCompatActivity { private RecyclerView settingsList ; private List < SettingsItem > settingsData ; private SettingsAdapter adapter ; private int currentTheme ; private SettingsViewModel viewModel ; private AppBarLayout appBarLayout ; @ Override protected void onPause ( ) { super . onPause ( ) ; if ( settingsList != null ) { viewModel . setScrollPosition ( ( ( LinearLayoutManager ) settingsList . getLayoutManager ( ) ) . findFirstVisibleItemPosition ( ) ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( settingsList ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_settings ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( SettingsViewModel . class ) ; setupRecyclerView ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; settingsList = findViewById ( R . id . settings_list ) ; settingsData = new ArrayList < > ( ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_amoled_theme , getString ( R . string . amoled_theme ) , getString ( R . string . des_amoled_theme ) , true , Preferences . getAmoledTheme ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_clear , getString ( R . string . ask_to_clean ) , getString ( R . string . des_ask_to_clean ) , true , Preferences . getClear ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_share , getString ( R . string . share_and_run ) , getString ( R . string . des_share_and_run ) , true , Preferences . getShareAndRun ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_auto_update , getString ( R . string . auto_update_check ) , getString ( R . string . des_auto_update_check ) , true , Preferences . getAutoUpdateCheck ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_mode , getString ( R . string . default_working_mode ) , getString ( R . string . des_default_working_mode ) , false , false ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_disable_keyboard , getString ( R . string . disable_softkey ) , getString ( R . string . des_disable_softkey ) , true , Preferences . getDisableSoftkey ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_warning , getString ( R . string . override_bookmarks_limit ) , getString ( R . string . des_override_bookmarks ) , true , Preferences . getOverrideBookmarks ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_scroll , getString ( R . string . smooth_scrolling ) , getString ( R . string . des_smooth_scroll ) , true , Preferences . getSmoothScroll ( this ) ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_cards , getString ( R . string . unhide_cards ) , getString ( R . string . des_unhide_cards ) , false , false ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_numbers , getString ( R . string . commands ) , getString ( R . string . des_examples ) , false , false ) ) ; settingsData . add ( new SettingsItem ( "<STR_LIT>" , R . drawable . ic_info , getString ( R . string . about ) , getString ( R . string . des_about ) , false , false ) ) ; adapter = new SettingsAdapter ( settingsData , this , currentTheme ) ; settingsList . setAdapter ( adapter ) ; settingsList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; } private void setupRecyclerView ( ) { settingsList = findViewById ( R . id . settings_list ) ; settingsList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; List < SettingsItem > settingsData = viewModel . getSettingsData ( ) ; int scrollPosition = viewModel . getScrollPosition ( ) ; adapter = new SettingsAdapter ( settingsData , this , currentTheme ) ; settingsList . setAdapter ( adapter ) ; settingsList . scrollToPosition ( scrollPosition ) ; } } </s>
<s> package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class ExamplesViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) { return isToolbarExpanded ; } public void setToolbarExpanded ( boolean toolbarExpanded ) { isToolbarExpanded = toolbarExpanded ; } } </s>
<s> package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . ConnectException ; import java . util . HashMap ; public class AdbConnection implements Closeable { AdbChannel channel ; private int lastLocalId ; private Thread connectionThread ; private boolean connectAttempted ; private boolean connected ; private int maxData ; private AdbCrypto crypto ; private boolean sentSignature ; private HashMap < Integer , AdbStream > openStreams ; private AdbConnection ( ) { openStreams = new HashMap < Integer , AdbStream > ( ) ; lastLocalId = <NUM_LIT> ; connectionThread = createConnectionThread ( ) ; } public static AdbConnection create ( AdbChannel channel , AdbCrypto crypto ) throws IOException { AdbConnection newConn = new AdbConnection ( ) ; newConn . crypto = crypto ; newConn . channel = channel ; return newConn ; } private Thread createConnectionThread ( ) { @ SuppressWarnings ( "<STR_LIT>" ) final AdbConnection conn = this ; return new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( ! connectionThread . isInterrupted ( ) ) { try { AdbMessage msg = AdbMessage . parseAdbMessage ( channel ) ; if ( ! AdbProtocol . validateMessage ( msg ) ) continue ; switch ( msg . getCommand ( ) ) { case AdbProtocol . CMD_OKAY : case AdbProtocol . CMD_WRTE : case AdbProtocol . CMD_CLSE : if ( ! conn . connected ) continue ; AdbStream waitingStream = openStreams . get ( msg . getArg1 ( ) ) ; if ( waitingStream == null ) continue ; synchronized ( waitingStream ) { if ( msg . getCommand ( ) == AdbProtocol . CMD_OKAY ) { waitingStream . updateRemoteId ( msg . getArg0 ( ) ) ; waitingStream . readyForWrite ( ) ; waitingStream . notify ( ) ; } else if ( msg . getCommand ( ) == AdbProtocol . CMD_WRTE ) { waitingStream . addPayload ( msg . getPayload ( ) ) ; waitingStream . sendReady ( ) ; } else if ( msg . getCommand ( ) == AdbProtocol . CMD_CLSE ) { conn . openStreams . remove ( msg . getArg1 ( ) ) ; waitingStream . notifyClose ( ) ; } } break ; case AdbProtocol . CMD_AUTH : AdbMessage packet ; if ( msg . getArg0 ( ) == AdbProtocol . AUTH_TYPE_TOKEN ) { if ( conn . sentSignature ) { packet = AdbProtocol . generateAuth ( AdbProtocol . AUTH_TYPE_RSA_PUBLIC , conn . crypto . getAdbPublicKeyPayload ( ) ) ; } else { packet = AdbProtocol . generateAuth ( AdbProtocol . AUTH_TYPE_SIGNATURE , conn . crypto . signAdbTokenPayload ( msg . getPayload ( ) ) ) ; conn . sentSignature = true ; } conn . channel . writex ( packet ) ; } break ; case AdbProtocol . CMD_CNXN : synchronized ( conn ) { conn . maxData = msg . getArg1 ( ) ; conn . connected = true ; conn . notifyAll ( ) ; } break ; default : break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; break ; } } synchronized ( conn ) { cleanupStreams ( ) ; conn . notifyAll ( ) ; conn . connectAttempted = false ; } } } ) ; } public int getMaxData ( ) throws InterruptedException , IOException { if ( ! connectAttempted ) throw new IllegalStateException ( "<STR_LIT>" ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( "<STR_LIT>" ) ; } } return maxData ; } public void connect ( ) throws IOException , InterruptedException { if ( connected ) throw new IllegalStateException ( "<STR_LIT>" ) ; channel . writex ( AdbProtocol . generateConnect ( ) ) ; connectAttempted = true ; connectionThread . start ( ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( "<STR_LIT>" ) ; } } } public AdbStream open ( String destination ) throws UnsupportedEncodingException , IOException , InterruptedException { int localId = ++ lastLocalId ; if ( ! connectAttempted ) throw new IllegalStateException ( "<STR_LIT>" ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( "<STR_LIT>" ) ; } } AdbStream stream = new AdbStream ( this , localId ) ; openStreams . put ( localId , stream ) ; channel . writex ( AdbProtocol . generateOpen ( localId , destination ) ) ; synchronized ( stream ) { stream . wait ( ) ; } if ( stream . isClosed ( ) ) throw new ConnectException ( "<STR_LIT>" ) ; return stream ; } private void cleanupStreams ( ) { for ( AdbStream s : openStreams . values ( ) ) { try { s . close ( ) ; } catch ( IOException e ) { } } openStreams . clear ( ) ; } @ Override public void close ( ) throws IOException { if ( connectionThread == null ) return ; channel . close ( ) ; connectionThread . interrupt ( ) ; try { connectionThread . join ( ) ; } catch ( InterruptedException e ) { } } } </s>
<s> package in . hridayan . ashell . adapters ; import android . graphics . Typeface ; import android . util . TypedValue ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . textview . MaterialTextView ; import java . util . List ; import in . hridayan . ashell . R ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Utils ; public class CommandsAdapter extends RecyclerView . Adapter < CommandsAdapter . ViewHolder > { private final List < CommandItems > data ; private static ClickListener mClickListener ; public CommandsAdapter ( List < CommandItems > data ) { this . data = data ; } @ NonNull @ Override public CommandsAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_commands , parent , false ) ; return new CommandsAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull CommandsAdapter . ViewHolder holder , int position ) { holder . mTitle . setText ( this . data . get ( position ) . getTitle ( ) ) ; if ( this . data . get ( position ) . getSummary ( ) != null ) { holder . mSummary . setText ( this . data . get ( position ) . getSummary ( ) ) ; } else { holder . mSummary . setVisibility ( View . GONE ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener { private final MaterialTextView mTitle , mSummary ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; } @ Override public void onClick ( View view ) { mClickListener . onItemClick ( this . mTitle . getText ( ) . toString ( ) , view ) ; } } public void setOnItemClickListener ( ClickListener clickListener ) { CommandsAdapter . mClickListener = clickListener ; } public interface ClickListener { void onItemClick ( String command , View v ) ; } } </s>
<s> package com . cgutman . adblib ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . Socket ; public class TcpChannel implements AdbChannel { private Socket socket ; private InputStream inputStream ; private OutputStream outputStream ; @ Override public void readx ( byte [ ] buffer , int length ) throws IOException { int dataRead = <NUM_LIT> ; do { int bytesRead = inputStream . read ( buffer , dataRead , length - dataRead ) ; if ( bytesRead < <NUM_LIT> ) throw new IOException ( "<STR_LIT>" ) ; else dataRead += bytesRead ; } while ( dataRead < length ) ; } private void writex ( byte [ ] buffer ) throws IOException { outputStream . write ( buffer ) ; outputStream . flush ( ) ; } @ Override public void writex ( AdbMessage message ) throws IOException { writex ( message . getMessage ( ) ) ; if ( message . getPayload ( ) != null ) { writex ( message . getPayload ( ) ) ; } } @ Override public void close ( ) throws IOException { socket . close ( ) ; } public TcpChannel ( Socket socket ) { try { socket . setTcpNoDelay ( true ) ; this . socket = socket ; this . inputStream = socket . getInputStream ( ) ; this . outputStream = socket . getOutputStream ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } </s>
<s> package in . hridayan . ashell . utils ; import androidx . annotation . Nullable ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . annotation . DrawableRes ; import androidx . core . content . ContextCompat ; import androidx . preference . PreferenceManager ; public class SettingsItem { private int symbolResId ; private String description , title , id ; private boolean hasSwitch , isChecked ; public SettingsItem ( String id , @ Nullable @ DrawableRes int symbolResId , String title , String description , boolean hasSwitch , boolean isChecked ) { this . id = id ; this . symbolResId = symbolResId ; this . title = title ; this . description = description ; this . hasSwitch = hasSwitch ; this . isChecked = isChecked ; } public String getId ( ) { return id ; } public Drawable getSymbol ( Context context ) { return ContextCompat . getDrawable ( context , symbolResId ) ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public boolean hasSwitch ( ) { return hasSwitch ; } public boolean isChecked ( ) { return isChecked ; } public void setChecked ( boolean isChecked ) { this . isChecked = isChecked ; } public void saveSwitchState ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( id , isChecked ) ; editor . apply ( ) ; } public void loadSwitchState ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; isChecked = prefs . getBoolean ( id , false ) ; } } </s>
<s> package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . card . MaterialCardView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . activities . ChangelogActivity ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; public class AboutAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { private static final int CATEGORY = <NUM_LIT> ; private static final int CATEGORY_LEAD_DEV_ITEM = <NUM_LIT> ; private static final int CATEGORY_CONTRIBUTORS_ITEM = <NUM_LIT> ; private static final int CATEGORY_APP_ITEM = <NUM_LIT> ; private AdapterListener mListener ; private List < Object > items ; private Context context ; public AboutAdapter ( List < Object > items , Context context ) { this . items = items ; this . context = context ; } public interface AdapterListener { void onCheckUpdate ( ) ; } public void setAdapterListener ( AdapterListener listener ) { mListener = listener ; } @ Override public int getItemViewType ( int position ) { Object item = items . get ( position ) ; if ( item instanceof Category ) { return CATEGORY ; } else if ( item instanceof Category . LeadDeveloperItem ) { return CATEGORY_LEAD_DEV_ITEM ; } else if ( item instanceof Category . ContributorsItem ) { return CATEGORY_CONTRIBUTORS_ITEM ; } else if ( item instanceof Category . AppItem ) { return CATEGORY_APP_ITEM ; } return - <NUM_LIT> ; } @ NonNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; switch ( viewType ) { case CATEGORY : View categoryView = inflater . inflate ( R . layout . category_about , parent , false ) ; return new CategoryViewHolder ( categoryView ) ; case CATEGORY_LEAD_DEV_ITEM : View leadDevItemView = inflater . inflate ( R . layout . category_lead_dev , parent , false ) ; return new LeadDeveloperItemViewHolder ( leadDevItemView ) ; case CATEGORY_CONTRIBUTORS_ITEM : View contributorsItemView = inflater . inflate ( R . layout . category_contributors , parent , false ) ; return new contributorsItemViewHolder ( contributorsItemView ) ; case CATEGORY_APP_ITEM : View appItemView = inflater . inflate ( R . layout . category_app , parent , false ) ; return new AppItemViewHolder ( appItemView ) ; default : throw new IllegalArgumentException ( "<STR_LIT>" ) ; } } @ Override public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position ) { Object item = items . get ( position ) ; if ( holder instanceof CategoryViewHolder ) { Category category = ( Category ) item ; CategoryViewHolder categoryViewHolder = ( CategoryViewHolder ) holder ; categoryViewHolder . categoryTextView . setText ( category . getName ( ) ) ; } else if ( holder instanceof LeadDeveloperItemViewHolder ) { Category . LeadDeveloperItem categoryAItem = ( Category . LeadDeveloperItem ) item ; LeadDeveloperItemViewHolder viewHolder = ( LeadDeveloperItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( categoryAItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( categoryAItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( categoryAItem . getDescription ( ) ) ; Map < View , String > buttonUrlMap = new HashMap < > ( ) ; buttonUrlMap . put ( viewHolder . mXButton , "<STR_LIT>" ) ; buttonUrlMap . put ( viewHolder . mGithubButton , "<STR_LIT>" ) ; buttonUrlMap . put ( viewHolder . mMailButton , "<STR_LIT>" ) ; buttonUrlMap . put ( viewHolder . mSupportButton , "<STR_LIT>" ) ; for ( Map . Entry < View , String > entry : buttonUrlMap . entrySet ( ) ) { entry . getKey ( ) . setOnClickListener ( v -> Utils . openUrl ( context , entry . getValue ( ) ) ) ; } } else if ( holder instanceof contributorsItemViewHolder ) { Category . ContributorsItem ContributorsItem = ( Category . ContributorsItem ) item ; contributorsItemViewHolder viewHolder = ( contributorsItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( ContributorsItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( ContributorsItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( ContributorsItem . getDescription ( ) ) ; View . OnClickListener clickListener = v -> { Map < String , String > idUrlMap = new HashMap < > ( ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; String id = ContributorsItem . getId ( ) ; String url = idUrlMap . get ( id ) ; if ( url != null ) { Utils . openUrl ( context , url ) ; } } ; viewHolder . buttonView . setOnClickListener ( clickListener ) ; viewHolder . categoryContributorsLayout . setOnClickListener ( v -> { } ) ; viewHolder . categoryContributorsLayout . setStrokeWidth ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? <NUM_LIT> : <NUM_LIT> ) ; } else if ( holder instanceof AppItemViewHolder ) { Category . AppItem categoryCItem = ( Category . AppItem ) item ; AppItemViewHolder viewHolder = ( AppItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( categoryCItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( categoryCItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( categoryCItem . getDescription ( ) ) ; View . OnClickListener clickListener = v -> { Map < String , String > idUrlMap = new HashMap < > ( ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; idUrlMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; String id = categoryCItem . getId ( ) ; String url = idUrlMap . get ( id ) ; if ( url != null ) { Utils . openUrl ( context , url ) ; } Intent intent ; switch ( id ) { case "<STR_LIT>" : intent = new Intent ( context , ChangelogActivity . class ) ; break ; default : return ; } context . startActivity ( intent ) ; } ; if ( categoryCItem . getId ( ) . equals ( "<STR_LIT>" ) ) { viewHolder . button . setVisibility ( View . VISIBLE ) ; viewHolder . button . setOnClickListener ( v -> { if ( mListener != null ) { mListener . onCheckUpdate ( ) ; } } ) ; } else { viewHolder . button . setVisibility ( View . GONE ) ; } viewHolder . categoryAppLayout . setOnClickListener ( clickListener ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == items . size ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; viewHolder . itemView . setLayoutParams ( layoutParams ) ; } } @ Override public int getItemCount ( ) { return items . size ( ) ; } private static class CategoryViewHolder extends RecyclerView . ViewHolder { TextView categoryTextView ; public CategoryViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; categoryTextView = itemView . findViewById ( R . id . category_text_view ) ; } } private static class LeadDeveloperItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; Button mMailButton , mXButton , mGithubButton , mSupportButton ; public LeadDeveloperItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; mMailButton = itemView . findViewById ( R . id . mail ) ; mGithubButton = itemView . findViewById ( R . id . github ) ; mXButton = itemView . findViewById ( R . id . x ) ; mSupportButton = itemView . findViewById ( R . id . support ) ; } } private static class contributorsItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; Button buttonView ; MaterialCardView categoryContributorsLayout ; public contributorsItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; buttonView = itemView . findViewById ( R . id . github_handle ) ; categoryContributorsLayout = itemView . findViewById ( R . id . category_contributors_layout ) ; } } private static class AppItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; LinearLayout categoryAppLayout ; MaterialButton button ; public AppItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; button = itemView . findViewById ( R . id . button ) ; categoryAppLayout = itemView . findViewById ( R . id . category_app_layout ) ; } } } </s>
<s> package in . hridayan . ashell . utils ; import android . content . Context ; import android . content . res . Configuration ; import android . os . Build ; import android . util . TypedValue ; import androidx . appcompat . app . AppCompatActivity ; import in . hridayan . ashell . R ; public class ThemeUtils { private static boolean isAmoledTheme ; public static void updateTheme ( AppCompatActivity activity ) { isAmoledTheme = Preferences . getAmoledTheme ( activity ) ; int currentMode = activity . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; if ( isAmoledTheme && currentMode == Configuration . UI_MODE_NIGHT_YES ) { activity . setTheme ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? R . style . ThemeOverlay_aShellYou_AmoledTheme : R . style . ThemeOverlay_aShellYou_AmoledThemeBelowV31 ) ; } else { activity . setTheme ( R . style . aShellYou_AppTheme ) ; } } public static int colorError ( Context context ) { TypedValue typedValue = new TypedValue ( ) ; context . getTheme ( ) . resolveAttribute ( android . R . attr . colorError , typedValue , true ) ; int colorError = typedValue . data ; return colorError ; } } </s>
<s> package com . cgutman . adblib ; import android . hardware . usb . UsbConstants ; import android . hardware . usb . UsbDeviceConnection ; import android . hardware . usb . UsbEndpoint ; import android . hardware . usb . UsbInterface ; import android . hardware . usb . UsbRequest ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . LinkedList ; public class UsbChannel implements AdbChannel { private final UsbDeviceConnection mDeviceConnection ; private final UsbEndpoint mEndpointOut ; private final UsbEndpoint mEndpointIn ; private final UsbInterface mInterface ; private final int defaultTimeout = <NUM_LIT> ; private final LinkedList < UsbRequest > mInRequestPool = new LinkedList < UsbRequest > ( ) ; public void releaseInRequest ( UsbRequest request ) { synchronized ( mInRequestPool ) { mInRequestPool . add ( request ) ; } } public UsbRequest getInRequest ( ) { synchronized ( mInRequestPool ) { if ( mInRequestPool . isEmpty ( ) ) { UsbRequest request = new UsbRequest ( ) ; request . initialize ( mDeviceConnection , mEndpointIn ) ; return request ; } else { return mInRequestPool . removeFirst ( ) ; } } } @ Override public void readx ( byte [ ] buffer , int length ) throws IOException { UsbRequest usbRequest = getInRequest ( ) ; ByteBuffer expected = ByteBuffer . allocate ( length ) . order ( ByteOrder . LITTLE_ENDIAN ) ; usbRequest . setClientData ( expected ) ; if ( ! usbRequest . queue ( expected , length ) ) { throw new IOException ( "<STR_LIT>" ) ; } while ( true ) { UsbRequest wait = mDeviceConnection . requestWait ( ) ; if ( wait == null ) { throw new IOException ( "<STR_LIT>" ) ; } ByteBuffer clientData = ( ByteBuffer ) wait . getClientData ( ) ; wait . setClientData ( null ) ; if ( wait . getEndpoint ( ) == mEndpointOut ) { } else if ( expected == clientData ) { releaseInRequest ( wait ) ; break ; } else { throw new IOException ( "<STR_LIT>" ) ; } } expected . flip ( ) ; expected . get ( buffer ) ; } private void writex ( byte [ ] buffer ) throws IOException { int offset = <NUM_LIT> ; int transferred = <NUM_LIT> ; byte [ ] tmp = new byte [ buffer . length ] ; System . arraycopy ( buffer , <NUM_LIT> , tmp , <NUM_LIT> , buffer . length ) ; while ( ( transferred = mDeviceConnection . bulkTransfer ( mEndpointOut , tmp , buffer . length - offset , defaultTimeout ) ) >= <NUM_LIT> ) { offset += transferred ; if ( offset >= buffer . length ) { break ; } else { System . arraycopy ( buffer , offset , tmp , <NUM_LIT> , buffer . length - offset ) ; } } if ( transferred < <NUM_LIT> ) { throw new IOException ( "<STR_LIT>" ) ; } } @ Override public void writex ( AdbMessage message ) throws IOException { writex ( message . getMessage ( ) ) ; if ( message . getPayload ( ) != null ) { writex ( message . getPayload ( ) ) ; } } @ Override public void close ( ) throws IOException { mDeviceConnection . releaseInterface ( mInterface ) ; mDeviceConnection . close ( ) ; } public UsbChannel ( UsbDeviceConnection connection , UsbInterface intf ) { mDeviceConnection = connection ; mInterface = intf ; UsbEndpoint epOut = null ; UsbEndpoint epIn = null ; for ( int i = <NUM_LIT> ; i < intf . getEndpointCount ( ) ; i ++ ) { UsbEndpoint ep = intf . getEndpoint ( i ) ; if ( ep . getType ( ) == UsbConstants . USB_ENDPOINT_XFER_BULK ) { if ( ep . getDirection ( ) == UsbConstants . USB_DIR_OUT ) { epOut = ep ; } else { epIn = ep ; } } } if ( epOut == null || epIn == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mEndpointOut = epOut ; mEndpointIn = epIn ; } } </s>
<s> package com . cgutman . adblib ; import java . io . UnsupportedEncodingException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; public class AdbProtocol { public static final int ADB_HEADER_LENGTH = <NUM_LIT> ; public static final int CMD_SYNC = <NUM_LIT> ; public static final int CMD_CNXN = <NUM_LIT> ; public static final int CONNECT_VERSION = <NUM_LIT> ; public static final int CONNECT_MAXDATA = <NUM_LIT> ; public static byte [ ] CONNECT_PAYLOAD ; static { try { CONNECT_PAYLOAD = "<STR_LIT>" . getBytes ( "<STR_LIT>" ) ; } catch ( UnsupportedEncodingException e ) { } } public static final int CMD_AUTH = <NUM_LIT> ; public static final int AUTH_TYPE_TOKEN = <NUM_LIT> ; public static final int AUTH_TYPE_SIGNATURE = <NUM_LIT> ; public static final int AUTH_TYPE_RSA_PUBLIC = <NUM_LIT> ; public static final int CMD_OPEN = <NUM_LIT> ; public static final int CMD_OKAY = <NUM_LIT> ; public static final int CMD_CLSE = <NUM_LIT> ; public static final int CMD_WRTE = <NUM_LIT> ; public static boolean validateMessage ( AdbMessage msg ) { if ( msg . getCommand ( ) != ( msg . getMagic ( ) ^ <NUM_LIT> ) ) return false ; if ( msg . getPayloadLength ( ) != <NUM_LIT> ) { if ( AdbMessage . checksum ( msg . getPayload ( ) ) != msg . getChecksum ( ) ) return false ; } return true ; } public static AdbMessage generateMessage ( int cmd , int arg0 , int arg1 , byte [ ] payload ) { return new AdbMessage ( cmd , arg0 , arg1 , payload ) ; } public static AdbMessage generateConnect ( ) { return generateMessage ( CMD_CNXN , CONNECT_VERSION , CONNECT_MAXDATA , CONNECT_PAYLOAD ) ; } public static AdbMessage generateAuth ( int type , byte [ ] data ) { return generateMessage ( CMD_AUTH , type , <NUM_LIT> , data ) ; } public static AdbMessage generateOpen ( int localId , String dest ) throws UnsupportedEncodingException { ByteBuffer bbuf = ByteBuffer . allocate ( dest . length ( ) + <NUM_LIT> ) ; bbuf . put ( dest . getBytes ( "<STR_LIT>" ) ) ; bbuf . put ( ( byte ) <NUM_LIT> ) ; return generateMessage ( CMD_OPEN , localId , <NUM_LIT> , bbuf . array ( ) ) ; } public static AdbMessage generateWrite ( int localId , int remoteId , byte [ ] data ) { return generateMessage ( CMD_WRTE , localId , remoteId , data ) ; } public static AdbMessage generateClose ( int localId , int remoteId ) { return generateMessage ( CMD_CLSE , localId , remoteId , null ) ; } public static AdbMessage generateReady ( int localId , int remoteId ) { return generateMessage ( CMD_OKAY , localId , remoteId , null ) ; } } </s>
<s> package in . hridayan . ashell . utils ; import static in . hridayan . ashell . utils . Preferences . SORT_A_TO_Z ; import static in . hridayan . ashell . utils . Preferences . SORT_NEWEST ; import static in . hridayan . ashell . utils . Preferences . SORT_OLDEST ; import static in . hridayan . ashell . utils . Preferences . SORT_Z_TO_A ; import android . app . Activity ; import android . content . ActivityNotFoundException ; import android . content . ClipData ; import android . content . ClipDescription ; import android . content . ClipboardManager ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . graphics . drawable . Drawable ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . provider . MediaStore ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import androidx . core . content . FileProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import com . google . android . material . bottomsheet . BottomSheetDialog ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . chip . Chip ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . snackbar . Snackbar ; import com . google . android . material . textfield . TextInputEditText ; import com . google . android . material . textfield . TextInputLayout ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . BuildConfig ; import in . hridayan . ashell . R ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Objects ; import rikka . shizuku . Shizuku ; public class Utils { public static Intent intent ; public static int savedVersionCode ; private static boolean isValidFilename ( String s ) { return ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) && ! s . contains ( "<STR_LIT>" ) ; } public static Drawable getDrawable ( int drawable , Context context ) { return ContextCompat . getDrawable ( context , drawable ) ; } public static int getColor ( int color , Context context ) { return ContextCompat . getColor ( context , color ) ; } public static Snackbar snackBar ( View view , String message ) { Snackbar snackbar = Snackbar . make ( view , message , Snackbar . LENGTH_LONG ) ; snackbar . setAction ( R . string . dismiss , v -> snackbar . dismiss ( ) ) ; return snackbar ; } public static int androidVersion ( ) { return Build . VERSION . SDK_INT ; } public static String getDeviceName ( ) { return Build . MODEL ; } private static String read ( File file ) { BufferedReader buf = null ; try { buf = new BufferedReader ( new FileReader ( file ) ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; String line ; while ( ( line = buf . readLine ( ) ) != null ) { stringBuilder . append ( line ) . append ( "<STR_LIT>" ) ; } return stringBuilder . toString ( ) . trim ( ) ; } catch ( IOException ignored ) { } finally { try { if ( buf != null ) buf . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return null ; } public static void copyToClipboard ( String text , Context context ) { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( context . getString ( R . string . copied_to_clipboard ) , text ) ; clipboard . setPrimaryClip ( clip ) ; Toast . makeText ( context , context . getString ( R . string . copied_to_clipboard ) , Toast . LENGTH_SHORT ) . show ( ) ; } public static void create ( String text , File path ) { try { FileWriter writer = new FileWriter ( path ) ; writer . write ( text ) ; writer . close ( ) ; } catch ( IOException ignored ) { } } public static void openUrl ( Context context , String url ) { try { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; context . startActivity ( intent ) ; } catch ( ActivityNotFoundException ignored ) { } } public static void pasteFromClipboard ( TextInputEditText editText ) { if ( editText == null ) { return ; } ClipboardManager clipboard = ( ClipboardManager ) editText . getContext ( ) . getSystemService ( Context . CLIPBOARD_SERVICE ) ; if ( clipboard == null ) { return ; } if ( clipboard . hasPrimaryClip ( ) && clipboard . getPrimaryClipDescription ( ) . hasMimeType ( ClipDescription . MIMETYPE_TEXT_PLAIN ) ) { ClipData . Item item = clipboard . getPrimaryClip ( ) . getItemAt ( <NUM_LIT> ) ; if ( item != null && item . getText ( ) != null ) { String clipboardText = item . getText ( ) . toString ( ) ; editText . setText ( clipboardText ) ; editText . setSelection ( editText . getText ( ) . length ( ) ) ; } } else { Toast . makeText ( editText . getContext ( ) . getApplicationContext ( ) , editText . getContext ( ) . getString ( R . string . clipboard_empty ) , Toast . LENGTH_SHORT ) . show ( ) ; } } public static void alignMargin ( View component ) { ViewGroup . MarginLayoutParams params = ( ViewGroup . MarginLayoutParams ) component . getLayoutParams ( ) ; params . bottomMargin = <NUM_LIT> ; component . setLayoutParams ( params ) ; component . requestLayout ( ) ; } public static boolean isToolbarExpanded ( AppBarLayout appBarLayout ) { return appBarLayout . getTop ( ) == <NUM_LIT> ; } public static void expandToolbar ( AppBarLayout appBarLayout ) { appBarLayout . setExpanded ( true ) ; } public static void collapseToolbar ( AppBarLayout appBarLayout ) { appBarLayout . setExpanded ( false ) ; } public static int recyclerViewPosition ( RecyclerView recyclerView ) { LinearLayoutManager layoutManager = ( LinearLayoutManager ) recyclerView . getLayoutManager ( ) ; int firstVisibleItemPosition = layoutManager . findFirstVisibleItemPosition ( ) ; return firstVisibleItemPosition ; } public static int currentVersion ( ) { int versionCode = BuildConfig . VERSION_CODE ; return versionCode ; } public static boolean isAppUpdated ( Context context ) { savedVersionCode = Preferences . getSavedVersionCode ( context ) ; if ( savedVersionCode != currentVersion ( ) && savedVersionCode != <NUM_LIT> ) { return true ; } else { return false ; } } public static List < String > getBookmarks ( Context context ) { List < String > mBookmarks = new ArrayList < > ( ) ; for ( File file : Objects . requireNonNull ( context . getExternalFilesDir ( "<STR_LIT>" ) . listFiles ( ) ) ) { if ( ! file . getName ( ) . equalsIgnoreCase ( "<STR_LIT>" ) ) { mBookmarks . add ( file . getName ( ) ) ; } } if ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) . exists ( ) ) { for ( String commands : Objects . requireNonNull ( read ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ) . split ( "<STR_LIT>" ) ) { if ( ! commands . trim ( ) . isEmpty ( ) ) { mBookmarks . add ( commands . trim ( ) ) ; } } } switch ( Preferences . getSortingOption ( context ) ) { case SORT_A_TO_Z : Collections . sort ( mBookmarks ) ; break ; case SORT_Z_TO_A : Collections . sort ( mBookmarks , Collections . reverseOrder ( ) ) ; break ; case SORT_NEWEST : break ; case SORT_OLDEST : Collections . reverse ( mBookmarks ) ; break ; } return mBookmarks ; } public static boolean isBookmarked ( String command , Context context ) { if ( isValidFilename ( command ) ) { return new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , command ) . exists ( ) ; } else { if ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) . exists ( ) ) { for ( String commands : Objects . requireNonNull ( read ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ) . split ( "<STR_LIT>" ) ) { if ( commands . trim ( ) . equals ( command ) ) { return true ; } } } } return false ; } public static void addToBookmark ( String command , Context context ) { if ( isValidFilename ( command ) ) { create ( command , new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , command ) ) ; } else { StringBuilder sb = new StringBuilder ( ) ; if ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) . exists ( ) ) { for ( String commands : Objects . requireNonNull ( read ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ) . split ( "<STR_LIT>" ) ) { sb . append ( commands ) . append ( "<STR_LIT>" ) ; } sb . append ( command ) . append ( "<STR_LIT>" ) ; } else { sb . append ( command ) . append ( "<STR_LIT>" ) ; } create ( sb . toString ( ) , new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ; } } public static boolean deleteFromBookmark ( String command , Context context ) { if ( isValidFilename ( command ) ) { return new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , command ) . delete ( ) ; } else { StringBuilder sb = new StringBuilder ( ) ; for ( String commands : Objects . requireNonNull ( read ( new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ) . split ( "<STR_LIT>" ) ) { if ( ! commands . equals ( command ) ) { sb . append ( commands ) . append ( "<STR_LIT>" ) ; } } create ( sb . toString ( ) , new File ( context . getExternalFilesDir ( "<STR_LIT>" ) , "<STR_LIT>" ) ) ; return true ; } } public static void bookmarksDialog ( Context context , Activity activity , TextInputEditText mCommand , TextInputLayout mCommandInput , MaterialButton button ) { List < String > bookmarks = Utils . getBookmarks ( activity ) ; int totalBookmarks = bookmarks . size ( ) ; String title = context . getString ( R . string . bookmarks ) + "<STR_LIT>" + totalBookmarks + "<STR_LIT>" ; CharSequence [ ] bookmarkItems = new CharSequence [ bookmarks . size ( ) ] ; for ( int i = <NUM_LIT> ; i < bookmarks . size ( ) ; i ++ ) { bookmarkItems [ i ] = bookmarks . get ( i ) ; } new MaterialAlertDialogBuilder ( activity ) . setTitle ( title ) . setItems ( bookmarkItems , ( dialog , which ) -> { mCommand . setText ( bookmarks . get ( which ) ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } ) . setPositiveButton ( context . getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setNegativeButton ( context . getString ( R . string . sort ) , ( dialogInterface , i ) -> { Utils . sortingDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . setNeutralButton ( context . getString ( R . string . delete_all ) , ( DialogInterface , i ) -> { Utils . deleteDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . show ( ) ; } public static void deleteDialog ( Context context , Activity activity , TextInputEditText mCommand , TextInputLayout mCommandInput , MaterialButton button ) { new MaterialAlertDialogBuilder ( activity ) . setTitle ( context . getString ( R . string . confirm_delete ) ) . setMessage ( context . getString ( R . string . confirm_delete_message ) ) . setPositiveButton ( context . getString ( R . string . ok ) , ( dialogInterface , i ) -> { List < String > bookmarks = Utils . getBookmarks ( activity ) ; for ( String item : bookmarks ) { Utils . deleteFromBookmark ( item , context ) ; } button . setVisibility ( View . GONE ) ; String s = mCommand . getText ( ) . toString ( ) ; if ( ! s . equals ( "<STR_LIT>" ) ) { mCommandInput . setEndIconDrawable ( R . drawable . ic_add_bookmark ) ; } else { mCommandInput . setEndIconVisible ( false ) ; } } ) . setNegativeButton ( context . getString ( R . string . cancel ) , ( dialogInterface , i ) -> { Utils . bookmarksDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . setOnCancelListener ( v -> { List < String > bookmarks = Utils . getBookmarks ( activity ) ; if ( bookmarks . size ( ) != <NUM_LIT> ) { Utils . bookmarksDialog ( context , activity , mCommand , mCommandInput , button ) ; } } ) . show ( ) ; } public static void sortingDialog ( Context context , Activity activity , TextInputEditText mCommand , TextInputLayout mCommandInput , MaterialButton button ) { CharSequence [ ] sortingOptions = { context . getString ( R . string . sort_A_Z ) , context . getString ( R . string . sort_Z_A ) , context . getString ( R . string . sort_newest ) , context . getString ( R . string . sort_oldest ) } ; int currentSortingOption = Preferences . getSortingOption ( context ) ; final int [ ] sortingOption = { currentSortingOption } ; new MaterialAlertDialogBuilder ( activity ) . setTitle ( context . getString ( R . string . sort ) ) . setSingleChoiceItems ( sortingOptions , currentSortingOption , ( dialog , which ) -> { sortingOption [ <NUM_LIT> ] = which ; } ) . setPositiveButton ( context . getString ( R . string . ok ) , ( dialog , which ) -> { Preferences . setSortingOption ( context , sortingOption [ <NUM_LIT> ] ) ; Utils . bookmarksDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . setNegativeButton ( context . getString ( R . string . cancel ) , ( dialog , i ) -> { Utils . bookmarksDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . setOnCancelListener ( v -> { Utils . bookmarksDialog ( context , activity , mCommand , mCommandInput , button ) ; } ) . show ( ) ; } public static void addBookmarkIconOnClickListener ( String bookmark , View view , Context context ) { boolean switchState = Preferences . getOverrideBookmarks ( context ) ; if ( Utils . getBookmarks ( context ) . size ( ) <= Preferences . MAX_BOOKMARKS_LIMIT - <NUM_LIT> || switchState ) { Utils . addToBookmark ( bookmark , context ) ; Utils . snackBar ( view , context . getString ( R . string . bookmark_added_message , bookmark ) ) . show ( ) ; } else { Utils . snackBar ( view , context . getString ( R . string . bookmark_limit_reached ) ) . show ( ) ; } } public static void defaultWorkingModeDialog ( Context context ) { final CharSequence [ ] workingModes = { context . getString ( R . string . local_adb ) , context . getString ( R . string . otg ) , context . getString ( R . string . remember_working_mode ) } ; int defaultWorkingMode = Preferences . getWorkingMode ( context ) ; final int [ ] workingMode = { defaultWorkingMode } ; new MaterialAlertDialogBuilder ( context ) . setTitle ( context . getString ( R . string . working_mode ) ) . setSingleChoiceItems ( workingModes , defaultWorkingMode , ( dialog , which ) -> { workingMode [ <NUM_LIT> ] = which ; } ) . setPositiveButton ( context . getString ( R . string . choose ) , ( dialog , which ) -> { Preferences . setWorkingMode ( context , workingMode [ <NUM_LIT> ] ) ; } ) . setNegativeButton ( context . getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } public static void connectedDeviceDialog ( Context context , String connectedDevice ) { String device = connectedDevice ; new MaterialAlertDialogBuilder ( context ) . setTitle ( context . getString ( R . string . connected_device ) ) . setMessage ( device ) . show ( ) ; } public static void chipOnClickListener ( Context context , Chip mChip , String device ) { mChip . setOnClickListener ( v -> { boolean hasShizuku = Shizuku . pingBinder ( ) && Shizuku . checkSelfPermission ( ) == PackageManager . PERMISSION_GRANTED ; Utils . connectedDeviceDialog ( context , hasShizuku ? device : context . getString ( R . string . none ) ) ; mChip . setChecked ( ! mChip . isChecked ( ) ) ; } ) ; } public static float convertDpToPixel ( float dp , Context context ) { float scale = context . getResources ( ) . getDisplayMetrics ( ) . density ; return dp * scale + <NUM_LIT> ; } public static void outputSavedDialog ( Activity activity , Context context , boolean saved ) { String message = saved ? context . getString ( R . string . shell_output_saved_message , Environment . DIRECTORY_DOWNLOADS ) : context . getString ( R . string . shell_output_not_saved_message ) ; String title = saved ? context . getString ( R . string . success ) : context . getString ( R . string . failed ) ; new MaterialAlertDialogBuilder ( activity ) . setTitle ( title ) . setMessage ( message ) . setPositiveButton ( context . getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . show ( ) ; } public static String generateFileName ( List < String > mHistory ) { return mHistory . get ( mHistory . size ( ) - <NUM_LIT> ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) + "<STR_LIT>" ; } public static String lastCommandOutput ( String text ) { int lastDollarIndex = text . lastIndexOf ( '<STR_LIT>' ) ; if ( lastDollarIndex == - <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } int secondLastDollarIndex = text . lastIndexOf ( '<STR_LIT>' , lastDollarIndex - <NUM_LIT> ) ; if ( secondLastDollarIndex == - <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } int startOfFirstLine = text . lastIndexOf ( '<STR_LIT>' , secondLastDollarIndex ) + <NUM_LIT> ; int startOfSecondLine = text . lastIndexOf ( '<STR_LIT>' , lastDollarIndex - <NUM_LIT> ) + <NUM_LIT> ; if ( startOfSecondLine == - <NUM_LIT> ) { startOfSecondLine = <NUM_LIT> ; } return text . substring ( startOfFirstLine , startOfSecondLine ) ; } public static boolean saveToFile ( String sb , Activity activity , List < String > mHistory ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return Utils . saveToFileApi29AndAbove ( sb , activity , mHistory ) ; } else { return Utils . saveToFileBelowApi29 ( sb , activity , mHistory ) ; } } public static boolean saveToFileApi29AndAbove ( String sb , Activity activity , List < String > mHistory ) { try { ContentValues values = new ContentValues ( ) ; String fileName = Utils . generateFileName ( mHistory ) ; values . put ( MediaStore . MediaColumns . DISPLAY_NAME , fileName ) ; values . put ( MediaStore . MediaColumns . MIME_TYPE , "<STR_LIT>" ) ; values . put ( MediaStore . MediaColumns . RELATIVE_PATH , Environment . DIRECTORY_DOWNLOADS ) ; Uri uri = activity . getContentResolver ( ) . insert ( MediaStore . Files . getContentUri ( "<STR_LIT>" ) , values ) ; if ( uri != null ) { try ( OutputStream outputStream = activity . getContentResolver ( ) . openOutputStream ( uri ) ) { outputStream . write ( sb . toString ( ) . getBytes ( ) ) ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } public static boolean saveToFileBelowApi29 ( String sb , Activity activity , List < String > mHistory ) { if ( activity . checkSelfPermission ( android . Manifest . permission . WRITE_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( activity , new String [ ] { android . Manifest . permission . WRITE_EXTERNAL_STORAGE } , <NUM_LIT> ) ; return false ; } try { String fileName = Utils . generateFileName ( mHistory ) ; File file = new File ( Environment . DIRECTORY_DOWNLOADS , fileName ) ; Utils . create ( sb . toString ( ) , file ) ; return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } public static void shareOutput ( Activity activity , Context context , List < String > mHistory , String sb ) { try { String fileName = Utils . generateFileName ( mHistory ) ; File file = new File ( activity . getCacheDir ( ) , fileName ) ; FileOutputStream outputStream = new FileOutputStream ( file ) ; outputStream . write ( sb . getBytes ( ) ) ; outputStream . close ( ) ; Uri fileUri = FileProvider . getUriForFile ( context , context . getPackageName ( ) + "<STR_LIT>" , file ) ; Intent shareIntent = new Intent ( Intent . ACTION_SEND ) ; shareIntent . setType ( "<STR_LIT>" ) ; shareIntent . putExtra ( Intent . EXTRA_STREAM , fileUri ) ; shareIntent . addFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION ) ; activity . startActivity ( Intent . createChooser ( shareIntent , "<STR_LIT>" ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static String getAppVersionName ( Context context ) { String versionName = "<STR_LIT>" ; try { PackageManager packageManager = context . getPackageManager ( ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) ; versionName = packageInfo . versionName ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return versionName ; } public static String loadChangelogText ( String versionNumber , Context context ) { int resourceId = context . getResources ( ) . getIdentifier ( "<STR_LIT>" + versionNumber . replace ( "<STR_LIT>" , "<STR_LIT>" ) , "<STR_LIT>" , context . getPackageName ( ) ) ; if ( resourceId != <NUM_LIT> ) { String changeLog = context . getString ( resourceId ) ; if ( changeLog != null && ! changeLog . isEmpty ( ) ) { return changeLog ; } } return context . getString ( R . string . no_changelog ) ; } public static int extractVersionCode ( String text ) { String [ ] lines = text . split ( "<STR_LIT>" ) ; int versionCode = - <NUM_LIT> ; for ( String line : lines ) { if ( line . contains ( "<STR_LIT>" ) ) { String trimmedLine = line . trim ( ) ; String integerSeparated = trimmedLine . replace ( "<STR_LIT>" , "<STR_LIT>" ) . trim ( ) ; int latestVersionCode = Integer . parseInt ( integerSeparated ) ; return latestVersionCode ; } } return versionCode ; } public static boolean isUpdateAvailable ( int latestVersionCode ) { int currentVersionCode = BuildConfig . VERSION_CODE ; return currentVersionCode < latestVersionCode ; } public static interface FetchLatestVersionCodeCallback { void onResult ( int result ) ; } public static void showBottomSheetChangelog ( Activity activity ) { BottomSheetDialog bottomSheetDialog = new BottomSheetDialog ( activity ) ; View bottomSheetView = LayoutInflater . from ( activity ) . inflate ( R . layout . bottom_sheet_changelog , null ) ; bottomSheetDialog . setContentView ( bottomSheetView ) ; bottomSheetDialog . show ( ) ; MaterialTextView changelog , version ; version = bottomSheetView . findViewById ( R . id . version ) ; changelog = bottomSheetView . findViewById ( R . id . changelog ) ; version . setText ( Utils . getAppVersionName ( activity ) ) ; String versionName = Utils . getAppVersionName ( activity ) ; changelog . setText ( Utils . loadChangelogText ( versionName , activity ) ) ; } public static void showBottomSheetUpdate ( Activity activity ) { BottomSheetDialog bottomSheetDialog = new BottomSheetDialog ( activity ) ; View bottomSheetView = LayoutInflater . from ( activity ) . inflate ( R . layout . bottom_sheet_update_checker , null ) ; bottomSheetDialog . setContentView ( bottomSheetView ) ; bottomSheetDialog . show ( ) ; MaterialButton downloadButton = bottomSheetView . findViewById ( R . id . download_button ) ; MaterialButton cancelButton = bottomSheetView . findViewById ( R . id . cancel_button ) ; downloadButton . setOnClickListener ( v -> { Utils . openUrl ( activity , "<STR_LIT>" ) ; } ) ; cancelButton . setOnClickListener ( v -> { bottomSheetDialog . dismiss ( ) ; } ) ; } } </s>
<s> package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; public interface AdbChannel extends Closeable { void readx ( byte [ ] buffer , int length ) throws IOException ; void writex ( AdbMessage message ) throws IOException ; } </s>
<s> package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class CommandsSearchAdapter extends RecyclerView . Adapter < CommandsSearchAdapter . ViewHolder > { private final List < CommandItems > data ; private Context context ; public CommandsSearchAdapter ( @ Nullable List < CommandItems > data , Context context ) { this . data = data != null ? data : new ArrayList < > ( ) ; this . context = context ; } public void setFilteredList ( List < CommandItems > filteredList ) { this . data . clear ( ) ; this . data . addAll ( filteredList ) ; notifyDataSetChanged ( ) ; } @ NonNull @ Override public CommandsSearchAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_examples , parent , false ) ; return new CommandsSearchAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull CommandsSearchAdapter . ViewHolder holder , int position ) { holder . mTitle . setText ( this . data . get ( position ) . getTitle ( ) ) ; if ( this . data . get ( position ) . getSummary ( ) != null ) { holder . mSummary . setText ( this . data . get ( position ) . getSummary ( ) ) ; int paddingInDp ; if ( position == data . size ( ) - <NUM_LIT> && data . size ( ) != <NUM_LIT> ) { paddingInDp = <NUM_LIT> ; } else if ( position == <NUM_LIT> ) { paddingInDp = <NUM_LIT> ; } else { paddingInDp = <NUM_LIT> ; } int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; if ( position == data . size ( ) - <NUM_LIT> && data . size ( ) != <NUM_LIT> ) { layoutParams . bottomMargin = paddingInPixels ; } else if ( position == <NUM_LIT> || data . size ( ) == <NUM_LIT> ) { layoutParams . topMargin = paddingInPixels ; } else { layoutParams . bottomMargin = <NUM_LIT> ; } holder . itemView . setLayoutParams ( layoutParams ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener { private final MaterialTextView mTitle , mSummary ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; } @ Override public void onClick ( View view ) { if ( data . get ( getAdapterPosition ( ) ) . getExample ( ) != null ) { String sanitizedText = sanitizeText ( data . get ( getAdapterPosition ( ) ) . getTitle ( ) ) ; Context context = view . getContext ( ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . example ) . setMessage ( data . get ( getAdapterPosition ( ) ) . getExample ( ) ) . setPositiveButton ( R . string . use , ( dialogInterface , i ) -> { int counter = data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ; data . get ( getAdapterPosition ( ) ) . setUseCounter ( counter + <NUM_LIT> ) ; Intent intent = new Intent ( context , MainActivity . class ) ; intent . putExtra ( "<STR_LIT>" , sanitizedText ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; context . startActivity ( intent ) ; } ) . setNegativeButton ( R . string . copy , ( dialogInterface , i ) -> { Utils . copyToClipboard ( sanitizedText , context ) ; } ) . show ( ) ; } } private String sanitizeText ( String text ) { String sanitizedText = text . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; return sanitizedText . trim ( ) ; } } } </s>
<s> package in . hridayan . ashell . UI ; import android . app . Activity ; import android . content . Context ; import android . util . AttributeSet ; import android . view . View ; import androidx . core . view . ViewCompat ; import androidx . core . widget . NestedScrollView ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import in . hridayan . ashell . R ; public class CoordinatedNestedScrollView extends NestedScrollView { public CoordinatedNestedScrollView ( Context context ) { super ( context ) ; } public CoordinatedNestedScrollView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public CoordinatedNestedScrollView ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override public boolean onStartNestedScroll ( View child , View target , int axes , int type ) { return ( axes & ViewCompat . SCROLL_AXIS_VERTICAL ) != <NUM_LIT> ; } @ Override public void onNestedScroll ( View target , int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int type ) { if ( dyConsumed > <NUM_LIT> ) { BottomNavigationView bottomNavigationView = ( ( Activity ) getContext ( ) ) . findViewById ( R . id . bottom_nav_bar ) ; if ( bottomNavigationView != null ) { bottomNavigationView . setVisibility ( View . GONE ) ; } } else if ( dyConsumed < <NUM_LIT> ) { BottomNavigationView bottomNavigationView = ( ( Activity ) getContext ( ) ) . findViewById ( R . id . bottom_nav_bar ) ; if ( bottomNavigationView != null ) { bottomNavigationView . setVisibility ( View . VISIBLE ) ; } } } } </s>
<s> package in . hridayan . ashell . activities ; import android . os . Bundle ; import android . widget . ImageView ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . ChangelogViewModel ; import in . hridayan . ashell . adapters . ChangelogAdapter ; import in . hridayan . ashell . utils . ChangelogItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class ChangelogActivity extends AppCompatActivity { private ChangelogViewModel viewModel ; private AppBarLayout appBarLayout ; private RecyclerView recyclerViewChangelogs ; private final String [ ] versionNames = { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerViewChangelogs ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_changelog ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( ChangelogViewModel . class ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; recyclerViewChangelogs = findViewById ( R . id . recycler_view_changelogs ) ; List < ChangelogItem > changelogItems = new ArrayList < > ( ) ; for ( String versionName : versionNames ) { changelogItems . add ( new ChangelogItem ( getString ( R . string . version ) + "<STR_LIT>" + versionName , Utils . loadChangelogText ( versionName , this ) ) ) ; } ChangelogAdapter adapter = new ChangelogAdapter ( changelogItems , this ) ; recyclerViewChangelogs . setAdapter ( adapter ) ; recyclerViewChangelogs . setLayoutManager ( new LinearLayoutManager ( this ) ) ; } } </s>
<s> package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; import java . util . Queue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicBoolean ; public class AdbStream implements Closeable { private AdbConnection adbConn ; private int localId ; private int remoteId ; private AtomicBoolean writeReady ; private Queue < byte [ ] > readQueue ; private boolean isClosed ; public AdbStream ( AdbConnection adbConn , int localId ) { this . adbConn = adbConn ; this . localId = localId ; this . readQueue = new ConcurrentLinkedQueue < byte [ ] > ( ) ; this . writeReady = new AtomicBoolean ( false ) ; this . isClosed = false ; } void addPayload ( byte [ ] payload ) { synchronized ( readQueue ) { readQueue . add ( payload ) ; readQueue . notifyAll ( ) ; } } void sendReady ( ) throws IOException { adbConn . channel . writex ( AdbProtocol . generateReady ( localId , remoteId ) ) ; } void updateRemoteId ( int remoteId ) { this . remoteId = remoteId ; } void readyForWrite ( ) { writeReady . set ( true ) ; } void notifyClose ( ) { isClosed = true ; synchronized ( this ) { notifyAll ( ) ; } synchronized ( readQueue ) { readQueue . notifyAll ( ) ; } } public byte [ ] read ( ) throws InterruptedException , IOException { byte [ ] data = null ; synchronized ( readQueue ) { while ( ! isClosed && ( data = readQueue . poll ( ) ) == null ) { readQueue . wait ( ) ; } if ( isClosed ) { throw new IOException ( "<STR_LIT>" ) ; } } return data ; } public void write ( String payload ) throws IOException , InterruptedException { write ( ( payload + "<STR_LIT>" ) . getBytes ( "<STR_LIT>" ) ) ; } public void write ( byte [ ] payload ) throws IOException , InterruptedException { synchronized ( this ) { while ( ! isClosed && ! writeReady . compareAndSet ( true , false ) ) wait ( ) ; if ( isClosed ) { throw new IOException ( "<STR_LIT>" ) ; } } adbConn . channel . writex ( AdbProtocol . generateWrite ( localId , remoteId , payload ) ) ; } @ Override public void close ( ) throws IOException { synchronized ( this ) { if ( isClosed ) return ; notifyClose ( ) ; } adbConn . channel . writex ( AdbProtocol . generateClose ( localId , remoteId ) ) ; } public boolean isClosed ( ) { return isClosed ; } } </s>
<s> package com . cgutman . adblib ; public interface AdbBase64 { public String encodeToString ( byte [ ] data ) ; } </s>
<s> package in . hridayan . ashell . activities ; import static in . hridayan . ashell . utils . Preferences . LOCAL_FRAGMENT ; import static in . hridayan . ashell . utils . Preferences . MODE_REMEMBER_LAST_MODE ; import static in . hridayan . ashell . utils . Preferences . OTG_FRAGMENT ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . view . View ; import androidx . activity . EdgeToEdge ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . lifecycle . ViewModelProvider ; import androidx . preference . PreferenceManager ; import com . google . android . material . badge . BadgeDrawable ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . KeyboardUtils ; import in . hridayan . ashell . UI . MainViewModel ; import in . hridayan . ashell . adapters . SettingsAdapter ; import in . hridayan . ashell . fragments . StartFragment ; import in . hridayan . ashell . fragments . aShellFragment ; import in . hridayan . ashell . fragments . otgShellFragment ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class MainActivity extends AppCompatActivity implements otgShellFragment . OnFragmentInteractionListener , FetchLatestVersionCodeCallback { private boolean isKeyboardVisible , hasAppRestarted = true ; public BottomNavigationView mNav ; private SettingsAdapter adapter ; private SettingsItem settingsList ; private static int currentFragment ; private boolean isBlackThemeEnabled , isAmoledTheme ; private MainViewModel viewModel ; private String pendingSharedText = null ; @ Override public void onRequestReset ( ) { if ( ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof otgShellFragment ) ) { currentFragment = OTG_FRAGMENT ; mNav . setSelectedItemId ( R . id . nav_otgShell ) ; replaceFragment ( new otgShellFragment ( ) ) ; } } @ Override public void onResult ( int result ) { if ( result == Preferences . UPDATE_AVAILABLE ) { Utils . showBottomSheetUpdate ( this ) ; } } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; handleIncomingIntent ( intent ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; setCurrentFragment ( ) ; viewModel . setCurrentFragment ( currentFragment ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; isAmoledTheme = Preferences . getAmoledTheme ( this ) ; boolean currentTheme = isAmoledTheme ; if ( currentTheme != isBlackThemeEnabled ) { recreate ( ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; List < SettingsItem > settingsList = new ArrayList < > ( ) ; adapter = new SettingsAdapter ( settingsList , this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; viewModel = new ViewModelProvider ( this ) . get ( MainViewModel . class ) ; isAmoledTheme = Preferences . getAmoledTheme ( this ) ; mNav = findViewById ( R . id . bottom_nav_bar ) ; KeyboardUtils . attachVisibilityListener ( this , new KeyboardUtils . KeyboardVisibilityListener ( ) { @ Override public void onKeyboardVisibilityChanged ( boolean visible ) { isKeyboardVisible = visible ; if ( isKeyboardVisible ) { mNav . setVisibility ( View . GONE ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( ( ) -> { mNav . setVisibility ( View . VISIBLE ) ; } , <NUM_LIT> ) ; } } } ) ; setupNavigation ( ) ; if ( Utils . isAppUpdated ( this ) ) { Utils . showBottomSheetChangelog ( this ) ; } Preferences . setSavedVersionCode ( this , Utils . currentVersion ( ) ) ; isBlackThemeEnabled = isAmoledTheme ; setBadge ( R . id . nav_wireless , "<STR_LIT>" ) ; if ( Preferences . getAutoUpdateCheck ( this ) && hasAppRestarted && ! ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean ( "<STR_LIT>" , true ) ) ) { new FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ; } hasAppRestarted = false ; } private void handleSharedTextIntent ( String sharedText , Intent intent ) { setTextOnEditText ( sharedText , intent ) ; } private void handleUseCommandIntent ( String useCommand , Intent intent ) { setTextOnEditText ( useCommand , intent ) ; } private void setTextOnEditText ( String text , Intent intent ) { int currentFragment = Preferences . getCurrentFragment ( this ) ; switch ( currentFragment ) { case LOCAL_FRAGMENT : aShellFragment fragmentLocalAdb = ( aShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentLocalAdb != null ) { if ( intent . hasExtra ( Intent . EXTRA_TEXT ) ) { fragmentLocalAdb . handleSharedTextIntent ( getIntent ( ) , text ) ; } else { fragmentLocalAdb . updateInputField ( text ) ; } } break ; case OTG_FRAGMENT : otgShellFragment fragmentOtg = ( otgShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentOtg != null ) { fragmentOtg . updateInputField ( text ) ; } break ; default : break ; } } private void handlePendingSharedText ( ) { if ( pendingSharedText != null ) { switch ( Preferences . getCurrentFragment ( this ) ) { case LOCAL_FRAGMENT : aShellFragment fragmentLocalAdb = ( aShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentLocalAdb != null ) { fragmentLocalAdb . updateInputField ( pendingSharedText ) ; clearPendingSharedText ( ) ; } break ; case OTG_FRAGMENT : otgShellFragment fragmentOtg = ( otgShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentOtg != null ) { fragmentOtg . updateInputField ( pendingSharedText ) ; clearPendingSharedText ( ) ; } break ; default : break ; } } } private void setupNavigation ( ) { mNav . setVisibility ( View . VISIBLE ) ; mNav . setOnItemSelectedListener ( item -> { switch ( item . getItemId ( ) ) { case R . id . nav_localShell : showaShellFragment ( ) ; Preferences . setCurrentFragment ( this , LOCAL_FRAGMENT ) ; return true ; case R . id . nav_otgShell : showotgShellFragment ( ) ; Preferences . setCurrentFragment ( this , OTG_FRAGMENT ) ; return true ; default : return false ; } } ) ; initialFragment ( ) ; handleIncomingIntent ( getIntent ( ) ) ; } public void replaceFragment ( Fragment fragment ) { if ( ! getSupportFragmentManager ( ) . isStateSaved ( ) ) { setCurrentFragment ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . fragment_container , fragment ) . commit ( ) ; } } private void showotgShellFragment ( ) { if ( ! ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof otgShellFragment ) ) { currentFragment = OTG_FRAGMENT ; replaceFragment ( new otgShellFragment ( ) ) ; } } private void showaShellFragment ( ) { if ( ! ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof aShellFragment ) ) { currentFragment = LOCAL_FRAGMENT ; replaceFragment ( new aShellFragment ( ) ) ; } } private void showBetaWarning ( ) { MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( this ) ; builder . setCancelable ( false ) . setTitle ( getString ( R . string . warning ) ) . setMessage ( getString ( R . string . beta_warning ) ) . setPositiveButton ( getString ( R . string . accept ) , ( dialogInterface , i ) -> { replaceFragment ( new otgShellFragment ( ) ) ; } ) . setNegativeButton ( getString ( R . string . go_back ) , ( dialogInterface , i ) -> { mNav . setSelectedItemId ( R . id . nav_localShell ) ; } ) . setNeutralButton ( getString ( R . string . donot_show_again ) , ( dialogInterface , i ) -> { PreferenceManager . getDefaultSharedPreferences ( this ) . edit ( ) . putBoolean ( "<STR_LIT>" , false ) . apply ( ) ; replaceFragment ( new otgShellFragment ( ) ) ; } ) . show ( ) ; } private void setBadge ( int id , String text ) { BadgeDrawable badge = mNav . getOrCreateBadge ( id ) ; badge . setVisible ( true ) ; badge . setText ( text ) ; badge . setHorizontalOffset ( <NUM_LIT> ) ; } private void initialFragment ( ) { if ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean ( "<STR_LIT>" , true ) ) { mNav . setVisibility ( View . GONE ) ; replaceFragment ( new StartFragment ( ) ) ; } else { boolean isFragmentSaved = viewModel . isFragmentSaved ( ) ; if ( isFragmentSaved ) { int currentFragment = viewModel . currentFragment ( ) ; switchFragments ( currentFragment ) ; } else { int currentFragment = Preferences . getCurrentFragment ( this ) ; int workingMode = Preferences . getWorkingMode ( this ) ; switchFragments ( workingMode == MODE_REMEMBER_LAST_MODE ? currentFragment : workingMode + <NUM_LIT> ) ; } handlePendingSharedText ( ) ; } } private void setCurrentFragment ( ) { Fragment fragment = getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragment instanceof aShellFragment ) { currentFragment = LOCAL_FRAGMENT ; } else if ( fragment instanceof otgShellFragment ) { currentFragment = OTG_FRAGMENT ; } } private void switchFragments ( int currentFragment ) { switch ( currentFragment ) { case LOCAL_FRAGMENT : mNav . setSelectedItemId ( R . id . nav_localShell ) ; replaceFragment ( new aShellFragment ( ) ) ; break ; case OTG_FRAGMENT : mNav . setSelectedItemId ( R . id . nav_otgShell ) ; replaceFragment ( new otgShellFragment ( ) ) ; break ; default : break ; } } public void onUsbDetached ( ) { onRequestReset ( ) ; } private void handleIncomingIntent ( Intent intent ) { if ( Intent . ACTION_SEND . equals ( intent . getAction ( ) ) && intent . hasExtra ( Intent . EXTRA_TEXT ) ) { String sharedText = intent . getStringExtra ( Intent . EXTRA_TEXT ) ; if ( sharedText != null ) { sharedText = sharedText . trim ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; pendingSharedText = sharedText ; handleSharedTextIntent ( sharedText , intent ) ; } } else if ( intent . hasExtra ( "<STR_LIT>" ) ) { String useCommand = intent . getStringExtra ( "<STR_LIT>" ) ; handleUseCommandIntent ( useCommand , intent ) ; } else if ( "<STR_LIT>" . equals ( intent . getAction ( ) ) ) { onUsbDetached ( ) ; } } public String getPendingSharedText ( ) { return pendingSharedText ; } public void clearPendingSharedText ( ) { pendingSharedText = null ; } } </s>
<s> package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . materialswitch . MaterialSwitch ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . AboutActivity ; import in . hridayan . ashell . activities . ExamplesActivity ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . Utils ; import java . util . List ; public class SettingsAdapter extends RecyclerView . Adapter < SettingsAdapter . ViewHolder > { private List < SettingsItem > settingsList ; private Context context ; private int currentTheme ; public SettingsAdapter ( List < SettingsItem > settingsList , Context context , int currentTheme ) { this . settingsList = settingsList ; this . context = context ; this . currentTheme = currentTheme ; } public SettingsAdapter ( List < SettingsItem > settingsList , Context context ) { this . settingsList = settingsList ; this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . item_settings , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ViewHolder holder , int position ) { SettingsItem settingsItem = settingsList . get ( position ) ; Drawable symbolDrawable = settingsItem . getSymbol ( context ) ; holder . symbolImageView . setImageDrawable ( symbolDrawable ) ; holder . titleTextView . setText ( settingsItem . getTitle ( ) ) ; holder . descriptionTextView . setText ( settingsItem . getDescription ( ) ) ; holder . descriptionTextView . setVisibility ( TextUtils . isEmpty ( settingsItem . getDescription ( ) ) ? View . GONE : View . VISIBLE ) ; holder . switchView . setVisibility ( settingsItem . hasSwitch ( ) ? View . VISIBLE : View . GONE ) ; holder . switchView . setChecked ( settingsItem . isChecked ( ) ) ; holder . switchView . setOnCheckedChangeListener ( ( buttonView , isChecked ) -> { settingsItem . setChecked ( isChecked ) ; settingsItem . saveSwitchState ( context ) ; switch ( settingsItem . getId ( ) ) { case "<STR_LIT>" : if ( ( context . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ) == Configuration . UI_MODE_NIGHT_YES ) { applyTheme ( isChecked ) ; } break ; default : break ; } } ) ; View . OnClickListener clickListener = new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent intent ; switch ( settingsItem . getId ( ) ) { case "<STR_LIT>" : Preferences . setSpecificCardVisibility ( context , "<STR_LIT>" , true ) ; Toast . makeText ( context , context . getString ( R . string . unhide_cards_message ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; case "<STR_LIT>" : intent = new Intent ( context , ExamplesActivity . class ) ; context . startActivity ( intent ) ; break ; case "<STR_LIT>" : intent = new Intent ( context , AboutActivity . class ) ; context . startActivity ( intent ) ; break ; case "<STR_LIT>" : Utils . defaultWorkingModeDialog ( context ) ; break ; default : return ; } } } ; holder . settingsItemLayout . setOnClickListener ( clickListener ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == getItemCount ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; holder . itemView . setLayoutParams ( layoutParams ) ; } private void applyTheme ( boolean isAmoledTheme ) { int themeId = isAmoledTheme ? R . style . ThemeOverlay_aShellYou_AmoledTheme : R . style . aShellYou_AppTheme ; context . setTheme ( themeId ) ; currentTheme = themeId ; ( ( AppCompatActivity ) context ) . recreate ( ) ; } @ Override public int getItemCount ( ) { return settingsList . size ( ) ; } public boolean getSavedSwitchState ( String id ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; return prefs . getBoolean ( id , false ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { ImageView symbolImageView ; TextView titleTextView , descriptionTextView ; MaterialSwitch switchView ; ConstraintLayout settingsItemLayout ; public ViewHolder ( View itemView ) { super ( itemView ) ; symbolImageView = itemView . findViewById ( R . id . symbol_image_view ) ; titleTextView = itemView . findViewById ( R . id . setting_title ) ; descriptionTextView = itemView . findViewById ( R . id . setting_description ) ; switchView = itemView . findViewById ( R . id . setting_switch ) ; settingsItemLayout = itemView . findViewById ( R . id . settings_item_layout ) ; } } } </s>
<s> package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class ChangelogViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) { return isToolbarExpanded ; } public void setToolbarExpanded ( boolean toolbarExpanded ) { isToolbarExpanded = toolbarExpanded ; } } </s>
<s> package in . hridayan . ashell . utils ; import android . content . Context ; import java . io . Serializable ; import in . hridayan . ashell . utils . Preferences ; public class CommandItems implements Serializable { private final String mTitle , mSummary , mExample ; private int mUseCounter ; private Context context ; private boolean isChecked , isPinned ; public CommandItems ( String title , String example , Context context ) { this . mTitle = title ; this . mSummary = summary ( title , context ) ; this . mExample = example ; this . context = context ; this . mUseCounter = Preferences . getUseCounter ( context , mTitle ) ; this . isPinned = Preferences . getPinned ( context , mTitle ) ; } public String getTitle ( ) { return mTitle ; } public String getSummary ( ) { return mSummary ; } public String getExample ( ) { return mExample ; } public int getUseCounter ( ) { return mUseCounter ; } public void setUseCounter ( int counter ) { this . mUseCounter = counter ; Preferences . setUseCounter ( context , mTitle , counter ) ; } public boolean isPinned ( ) { return isPinned ; } public void setPinned ( boolean pinned ) { this . isPinned = pinned ; Preferences . setPinned ( context , mTitle , pinned ) ; } public boolean isChecked ( ) { return isChecked ; } public void setChecked ( boolean checked ) { isChecked = checked ; } private String summary ( String title , Context context ) { String trimmedTitle = title . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . trim ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; int resourceId = context . getResources ( ) . getIdentifier ( trimmedTitle , "<STR_LIT>" , context . getPackageName ( ) ) ; return context . getResources ( ) . getString ( resourceId ) ; } } </s>
<s> package in . hridayan . ashell . adapters ; import android . text . Html ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import java . util . List ; public class ShellOutputAdapter extends RecyclerView . Adapter < ShellOutputAdapter . ViewHolder > { private final List < String > data ; public ShellOutputAdapter ( List < String > data ) { this . data = data ; } @ NonNull @ Override public ShellOutputAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_shell_output , parent , false ) ; return new ShellOutputAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull ShellOutputAdapter . ViewHolder holder , int position ) { holder . mOutput . setText ( Html . fromHtml ( this . data . get ( position ) , Html . FROM_HTML_MODE_LEGACY ) ) ; } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { private final MaterialTextView mOutput ; public ViewHolder ( View view ) { super ( view ) ; this . mOutput = view . findViewById ( R . id . shell_output ) ; } } } </s>
<s> package in . hridayan . ashell . fragments ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . ActivityInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . text . Editable ; import android . text . TextUtils ; import android . text . TextWatcher ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewTreeObserver ; import android . view . inputmethod . EditorInfo ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatImageButton ; import androidx . appcompat . widget . PopupMenu ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . fragment . app . Fragment ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . chip . Chip ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . floatingactionbutton . ExtendedFloatingActionButton ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import com . google . android . material . textfield . TextInputEditText ; import com . google . android . material . textfield . TextInputLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . BehaviorFAB ; import in . hridayan . ashell . UI . BehaviorFAB . FabExtendingOnScrollListener ; import in . hridayan . ashell . UI . BehaviorFAB . FabLocalScrollDownListener ; import in . hridayan . ashell . UI . BehaviorFAB . FabLocalScrollUpListener ; import in . hridayan . ashell . UI . KeyboardUtils ; import in . hridayan . ashell . UI . aShellFragmentViewModel ; import in . hridayan . ashell . activities . ExamplesActivity ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . activities . SettingsActivity ; import in . hridayan . ashell . adapters . CommandsAdapter ; import in . hridayan . ashell . adapters . ShellOutputAdapter ; import in . hridayan . ashell . utils . Commands ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ShizukuShell ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . List ; import java . util . Locale ; import java . util . Objects ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import rikka . shizuku . Shizuku ; public class aShellFragment extends Fragment { private AppCompatImageButton localShellSymbol ; private ExtendedFloatingActionButton mSaveButton , mPasteButton ; private FloatingActionButton mBottomButton , mSendButton , mTopButton , mShareButton , mUndoButton ; private MaterialButton mClearButton , mHistoryButton , mSearchButton , mBookMarks , mSettingsButton ; private FrameLayout mAppNameLayout ; private BottomNavigationView mNav ; private CommandsAdapter mCommandsAdapter ; private ShellOutputAdapter mShellOutputAdapter ; private RecyclerView mRecyclerViewOutput , mRecyclerViewCommands ; private ShizukuShell mShizukuShell ; private TextInputLayout mCommandInput ; private TextInputEditText mCommand , mSearchWord ; private boolean mExit , isKeyboardVisible , isSaveButtonVisible , sendButtonClicked = false , isEndIconVisible = false ; private final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; private int mPosition = <NUM_LIT> , sendDrawable ; private final int ic_help = <NUM_LIT> , ic_send = <NUM_LIT> , ic_stop = <NUM_LIT> ; private List < String > mHistory = null , mResult = null , mRecentCommands , shellOutput , history ; private View view ; private Context context ; private aShellFragmentViewModel viewModel ; private Chip mChip ; public aShellFragment ( ) { } @ Override public void onPause ( ) { super . onPause ( ) ; viewModel . setSendDrawable ( viewModel . isSendDrawableSaved ( ) ? viewModel . getSendDrawable ( ) : sendDrawable ) ; viewModel . setEditTextFocused ( isEditTextFocused ( ) ) ; viewModel . setSaveButtonVisible ( isSaveButtonVisible ( ) ) ; viewModel . setScrollPosition ( ( ( LinearLayoutManager ) mRecyclerViewOutput . getLayoutManager ( ) ) . findFirstVisibleItemPosition ( ) ) ; List < String > shellOutput = viewModel . getShellOutput ( ) ; List < String > history = viewModel . getHistory ( ) ; viewModel . setHistory ( mHistory == null && history != null ? history : mHistory ) ; viewModel . setShellOutput ( mResult == null ? shellOutput : mResult ) ; if ( mCommand . getText ( ) . toString ( ) != null ) { viewModel . setCommandText ( mCommand . getText ( ) . toString ( ) ) ; } if ( mCommandInput . isEndIconVisible ( ) ) { viewModel . setEndIconVisible ( true ) ; } else { isEndIconVisible = false ; } } @ Override public void onResume ( ) { super . onResume ( ) ; KeyboardUtils . disableKeyboard ( context , requireActivity ( ) , view ) ; mBookMarks . setVisibility ( Utils . getBookmarks ( context ) . size ( ) != <NUM_LIT> ? View . VISIBLE : View . GONE ) ; updateHistoryAndBookMarksConstraints ( ) ; if ( viewModel . isEditTextFocused ( ) ) { mCommand . requestFocus ( ) ; } else { mCommand . clearFocus ( ) ; } switch ( viewModel . getSendDrawable ( ) ) { case ic_help : mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; break ; case ic_send : mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; break ; case ic_stop : mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_stop , requireActivity ( ) ) ) ; break ; default : break ; } if ( viewModel . isSaveButtonVisible ( ) ) { mSaveButton . setVisibility ( View . VISIBLE ) ; if ( mSearchWord . getVisibility ( ) == View . GONE ) { mClearButton . setVisibility ( View . VISIBLE ) ; mSearchButton . setVisibility ( View . VISIBLE ) ; mHistoryButton . setVisibility ( View . VISIBLE ) ; } mShareButton . setVisibility ( View . VISIBLE ) ; mPasteButton . setVisibility ( View . GONE ) ; } else { mSaveButton . setVisibility ( View . GONE ) ; } mRecyclerViewOutput = view . findViewById ( R . id . recycler_view_output ) ; mRecyclerViewOutput . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; int scrollPosition = viewModel . getScrollPosition ( ) ; mRecyclerViewOutput . scrollToPosition ( scrollPosition ) ; isEndIconVisible = viewModel . isEndIconVisible ( ) ; String s = mCommand . getText ( ) . toString ( ) . trim ( ) ; if ( ! s . equals ( "<STR_LIT>" ) && isEndIconVisible ) { mCommandInput . setEndIconDrawable ( Utils . getDrawable ( Utils . isBookmarked ( s , requireActivity ( ) ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark , requireActivity ( ) ) ) ; } MainActivity activity = ( MainActivity ) getActivity ( ) ; if ( activity != null ) { String pendingSharedText = activity . getPendingSharedText ( ) ; if ( pendingSharedText != null ) { updateInputField ( pendingSharedText ) ; activity . clearPendingSharedText ( ) ; } } } @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { context = requireContext ( ) ; view = inflater . inflate ( R . layout . fragment_ashell , container , false ) ; localShellSymbol = view . findViewById ( R . id . local_shell_symbol ) ; mAppNameLayout = view . findViewById ( R . id . app_name_layout ) ; mBookMarks = view . findViewById ( R . id . bookmarks ) ; mBottomButton = view . findViewById ( R . id . fab_down ) ; mClearButton = view . findViewById ( R . id . clear ) ; mChip = view . findViewById ( R . id . local_adb_chip ) ; mPasteButton = view . findViewById ( R . id . paste_button ) ; mCommand = view . findViewById ( R . id . shell_command ) ; mCommandInput = view . findViewById ( R . id . shell_command_layout ) ; mNav = requireActivity ( ) . findViewById ( R . id . bottom_nav_bar ) ; mHistoryButton = view . findViewById ( R . id . history ) ; mRecyclerViewCommands = view . findViewById ( R . id . recycler_view_commands ) ; mRecyclerViewOutput = view . findViewById ( R . id . recycler_view_output ) ; mSaveButton = view . findViewById ( R . id . save_button ) ; mSearchButton = view . findViewById ( R . id . search ) ; mSearchWord = view . findViewById ( R . id . search_word ) ; mSendButton = view . findViewById ( R . id . send ) ; mSettingsButton = view . findViewById ( R . id . settings ) ; mShareButton = view . findViewById ( R . id . fab_share ) ; mTopButton = view . findViewById ( R . id . fab_up ) ; mUndoButton = view . findViewById ( R . id . fab_undo ) ; viewModel = new ViewModelProvider ( requireActivity ( ) ) . get ( aShellFragmentViewModel . class ) ; mRecyclerViewOutput . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; mRecyclerViewCommands . addOnScrollListener ( new FabExtendingOnScrollListener ( mPasteButton ) ) ; mRecyclerViewOutput . addOnScrollListener ( new FabExtendingOnScrollListener ( mPasteButton ) ) ; mRecyclerViewOutput . addOnScrollListener ( new FabExtendingOnScrollListener ( mSaveButton ) ) ; mRecyclerViewOutput . addOnScrollListener ( new FabLocalScrollUpListener ( mTopButton ) ) ; mRecyclerViewOutput . addOnScrollListener ( new FabLocalScrollDownListener ( mBottomButton ) ) ; mRecyclerViewOutput . setAdapter ( mShellOutputAdapter ) ; setupRecyclerView ( ) ; mNav . setVisibility ( View . VISIBLE ) ; BehaviorFAB . pasteAndUndo ( mPasteButton , mUndoButton , mCommand ) ; KeyboardUtils . attachVisibilityListener ( requireActivity ( ) , new KeyboardUtils . KeyboardVisibilityListener ( ) { public void onKeyboardVisibilityChanged ( boolean visible ) { isKeyboardVisible = visible ; if ( isKeyboardVisible ) { mPasteButton . setVisibility ( View . GONE ) ; mUndoButton . setVisibility ( View . GONE ) ; mSaveButton . setVisibility ( View . GONE ) ; mShareButton . setVisibility ( View . GONE ) ; } else { if ( mRecyclerViewOutput . getHeight ( ) != <NUM_LIT> ) { setVisibilityWithDelay ( mSaveButton , <NUM_LIT> ) ; } if ( mShareButton . getVisibility ( ) == View . GONE && mRecyclerViewOutput . getHeight ( ) != <NUM_LIT> ) { setVisibilityWithDelay ( mShareButton , <NUM_LIT> ) ; } if ( mPasteButton . getVisibility ( ) == View . GONE && ! sendButtonClicked && mResult == null ) { setVisibilityWithDelay ( mPasteButton , <NUM_LIT> ) ; } } } } ) ; BehaviorFAB . handleTopAndBottomArrow ( mTopButton , mBottomButton , mRecyclerViewOutput , null , context , "<STR_LIT>" ) ; Utils . chipOnClickListener ( context , mChip , Utils . getDeviceName ( ) ) ; if ( ! mCommand . getText ( ) . toString ( ) . isEmpty ( ) ) { mCommand . requestFocus ( ) ; } mCommand . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { mCommandInput . setError ( null ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void afterTextChanged ( Editable s ) { mCommand . requestFocus ( ) ; if ( mShizukuShell != null && mShizukuShell . isBusy ( ) ) { return ; } else { if ( ! s . toString ( ) . trim ( ) . isEmpty ( ) ) { viewModel . setSendDrawable ( ic_send ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; mCommandInput . setEndIconDrawable ( Utils . getDrawable ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark , requireActivity ( ) ) ) ; mCommandInput . setEndIconVisible ( true ) ; mCommandInput . setEndIconOnClickListener ( v -> { if ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ) { Utils . deleteFromBookmark ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ; Utils . snackBar ( view , getString ( R . string . bookmark_removed_message , s . toString ( ) . trim ( ) ) ) . show ( ) ; } else { Utils . addBookmarkIconOnClickListener ( s . toString ( ) . trim ( ) , view , context ) ; } mCommandInput . setEndIconDrawable ( Utils . getDrawable ( Utils . isBookmarked ( s . toString ( ) . trim ( ) , requireActivity ( ) ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark , requireActivity ( ) ) ) ; if ( mSearchWord . getVisibility ( ) == View . GONE ) { mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; } } ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> { if ( s . toString ( ) . contains ( "<STR_LIT>" ) && s . toString ( ) . contains ( "<STR_LIT>" ) ) { String [ ] splitCommands = { s . toString ( ) . substring ( <NUM_LIT> , lastIndexOf ( s . toString ( ) , "<STR_LIT>" ) ) , s . toString ( ) . substring ( lastIndexOf ( s . toString ( ) , "<STR_LIT>" ) ) } ; String packageNamePrefix ; if ( splitCommands [ <NUM_LIT> ] . contains ( "<STR_LIT>" ) ) { packageNamePrefix = splitPrefix ( splitCommands [ <NUM_LIT> ] , <NUM_LIT> ) ; } else { packageNamePrefix = splitCommands [ <NUM_LIT> ] ; } mCommandsAdapter = new CommandsAdapter ( Commands . getPackageInfo ( packageNamePrefix + "<STR_LIT>" , context ) ) ; if ( isAdded ( ) ) { mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; } if ( isAdded ( ) ) { mRecyclerViewCommands . setAdapter ( mCommandsAdapter ) ; } mRecyclerViewCommands . setVisibility ( View . VISIBLE ) ; mCommandsAdapter . setOnItemClickListener ( ( command , v ) -> { mCommand . setText ( splitCommands [ <NUM_LIT> ] . contains ( "<STR_LIT>" ) ? splitPrefix ( splitCommands [ <NUM_LIT> ] , <NUM_LIT> ) + "<STR_LIT>" + command : command ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; mRecyclerViewCommands . setVisibility ( View . GONE ) ; } ) ; } else { mCommandsAdapter = new CommandsAdapter ( Commands . getCommand ( s . toString ( ) , context ) ) ; if ( isAdded ( ) ) { mRecyclerViewCommands . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; } mRecyclerViewCommands . setAdapter ( mCommandsAdapter ) ; mRecyclerViewCommands . setVisibility ( View . VISIBLE ) ; mCommandsAdapter . setOnItemClickListener ( ( command , v ) -> { if ( command . contains ( "<STR_LIT>" ) ) { mCommand . setText ( command . split ( "<STR_LIT>" ) [ <NUM_LIT> ] ) ; } else { mCommand . setText ( command ) ; } mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } ) ; } } ) ; } else { mCommandInput . setEndIconVisible ( false ) ; mRecyclerViewCommands . setVisibility ( View . GONE ) ; viewModel . setSendDrawable ( ic_help ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . clearColorFilter ( ) ; } } } } ) ; mCommand . setOnEditorActionListener ( new TextView . OnEditorActionListener ( ) { public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_SEND ) { if ( mShizukuShell != null && mShizukuShell . isBusy ( ) ) { mShizukuShell . destroy ( ) ; viewModel . setSendDrawable ( ic_help ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . clearColorFilter ( ) ; } else if ( mCommand . getText ( ) == null || mCommand . getText ( ) . toString ( ) . trim ( ) . isEmpty ( ) ) { Intent examples = new Intent ( requireActivity ( ) , ExamplesActivity . class ) ; startActivity ( examples ) ; } else { if ( isAdded ( ) ) { initializeShell ( requireActivity ( ) ) ; } } return true ; } return false ; } } ) ; mSendButton . setOnClickListener ( v -> { sendButtonClicked = true ; if ( mShizukuShell != null && mShizukuShell . isBusy ( ) ) { mShizukuShell . destroy ( ) ; viewModel . setSendDrawable ( ic_help ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . clearColorFilter ( ) ; } else if ( mCommand . getText ( ) == null || mCommand . getText ( ) . toString ( ) . trim ( ) . isEmpty ( ) ) { Intent examples = new Intent ( requireActivity ( ) , ExamplesActivity . class ) ; startActivity ( examples ) ; } else if ( ! Shizuku . pingBinder ( ) ) { handleShizukuAvailability ( context ) ; } else { mPasteButton . hide ( ) ; mUndoButton . hide ( ) ; if ( isAdded ( ) ) { mCommandInput . setError ( null ) ; initializeShell ( requireActivity ( ) ) ; KeyboardUtils . closeKeyboard ( requireActivity ( ) , v ) ; return ; } } } ) ; mSettingsButton . setTooltipText ( getString ( R . string . settings ) ) ; mSettingsButton . setOnClickListener ( v -> { Intent settingsIntent = new Intent ( requireActivity ( ) , SettingsActivity . class ) ; startActivity ( settingsIntent ) ; } ) ; mClearButton . setTooltipText ( getString ( R . string . clear_screen ) ) ; mClearButton . setOnClickListener ( v -> { viewModel . setShellOutput ( null ) ; boolean switchState = Preferences . getClear ( context ) ; if ( switchState ) { new MaterialAlertDialogBuilder ( requireActivity ( ) ) . setTitle ( getString ( R . string . clear_everything ) ) . setMessage ( getString ( R . string . clear_all_message ) ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setPositiveButton ( getString ( R . string . yes ) , ( dialogInterface , i ) -> { clearAll ( ) ; } ) . show ( ) ; } else { clearAll ( ) ; } } ) ; mSearchButton . setTooltipText ( getString ( R . string . search ) ) ; mSearchButton . setOnClickListener ( v -> { if ( mHistoryButton . getVisibility ( ) == View . VISIBLE ) { mHistoryButton . setVisibility ( View . GONE ) ; } if ( mClearButton . getVisibility ( ) == View . VISIBLE ) { mClearButton . setVisibility ( View . GONE ) ; } mBookMarks . setVisibility ( View . GONE ) ; mSettingsButton . setVisibility ( View . GONE ) ; mSearchButton . setVisibility ( View . GONE ) ; mSearchWord . setVisibility ( View . VISIBLE ) ; mSearchWord . requestFocus ( ) ; mCommand . setText ( null ) ; } ) ; mSearchWord . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable s ) { if ( s == null || s . toString ( ) . trim ( ) . isEmpty ( ) ) { updateUI ( mResult ) ; } else { List < String > mResultSorted = new ArrayList < > ( ) ; for ( int i = mPosition ; i < mResult . size ( ) ; i ++ ) { if ( mResult . get ( i ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( s . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) ) { mResultSorted . add ( mResult . get ( i ) ) ; } } updateUI ( mResultSorted ) ; } } } ) ; if ( mSearchWord . getVisibility ( ) == View . GONE ) { mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; } ViewTreeObserver . OnGlobalLayoutListener historyListener = new ViewTreeObserver . OnGlobalLayoutListener ( ) { @ Override public void onGlobalLayout ( ) { updateHistoryAndBookMarksConstraints ( ) ; } } ; ViewTreeObserver . OnGlobalLayoutListener clearButtonListener = new ViewTreeObserver . OnGlobalLayoutListener ( ) { @ Override public void onGlobalLayout ( ) { updateHistoryAndBookMarksConstraints ( ) ; } } ; mHistoryButton . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( historyListener ) ; mClearButton . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( clearButtonListener ) ; mBookMarks . setTooltipText ( getString ( R . string . bookmarks ) ) ; mBookMarks . setOnClickListener ( v -> { Utils . bookmarksDialog ( context , requireActivity ( ) , mCommand , mCommandInput , mBookMarks ) ; } ) ; mHistoryButton . setTooltipText ( getString ( R . string . history ) ) ; mHistoryButton . setOnClickListener ( v -> { PopupMenu popupMenu = new PopupMenu ( context , mCommand ) ; Menu menu = popupMenu . getMenu ( ) ; for ( int i = <NUM_LIT> ; i < getRecentCommands ( ) . size ( ) ; i ++ ) { menu . add ( Menu . NONE , i , Menu . NONE , getRecentCommands ( ) . get ( i ) ) ; } popupMenu . setOnMenuItemClickListener ( item -> { for ( int i = <NUM_LIT> ; i < getRecentCommands ( ) . size ( ) ; i ++ ) { if ( item . getItemId ( ) == i ) { mCommand . setText ( getRecentCommands ( ) . get ( i ) ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; } } return false ; } ) ; popupMenu . show ( ) ; } ) ; mAppNameLayout . setOnClickListener ( v -> { if ( mSearchWord . getVisibility ( ) == View . VISIBLE ) { mSearchWord . setVisibility ( View . GONE ) ; mBookMarks . setVisibility ( Utils . getBookmarks ( requireActivity ( ) ) . size ( ) > <NUM_LIT> ? View . VISIBLE : View . GONE ) ; mSettingsButton . setVisibility ( View . VISIBLE ) ; mSearchButton . setVisibility ( View . VISIBLE ) ; mHistoryButton . setVisibility ( View . VISIBLE ) ; mClearButton . setVisibility ( View . VISIBLE ) ; } } ) ; mShareButton . setOnClickListener ( v -> { shellOutput = viewModel . getShellOutput ( ) ; history = viewModel . getHistory ( ) ; initializeResults ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = mPosition ; i < mResult . size ( ) ; i ++ ) { String result = mResult . get ( i ) ; if ( ! "<STR_LIT>" . equals ( result ) && ! "<STR_LIT>" . equals ( result ) ) { sb . append ( result ) . append ( "<STR_LIT>" ) ; } } Utils . shareOutput ( requireActivity ( ) , context , mHistory , sb . toString ( ) ) ; } ) ; mRecyclerViewOutput . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { private final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; private final int delayMillis = <NUM_LIT> ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE ) { handler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { if ( ! isKeyboardVisible ) mShareButton . show ( ) ; } } , delayMillis ) ; } else { handler . removeCallbacksAndMessages ( null ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( dy > <NUM_LIT> || dy < <NUM_LIT> && mShareButton . isShown ( ) ) { if ( Math . abs ( dy ) >= <NUM_LIT> ) mShareButton . hide ( ) ; } } } ) ; mSaveButton . setOnClickListener ( v -> { shellOutput = viewModel . getShellOutput ( ) ; history = viewModel . getHistory ( ) ; initializeResults ( ) ; String sb = buildResultsString ( ) . toString ( ) ; boolean saved = Utils . saveToFile ( sb , requireActivity ( ) , mHistory ) ; Utils . outputSavedDialog ( requireActivity ( ) , context , saved ) ; } ) ; ScheduledExecutorService executor = Executors . newSingleThreadScheduledExecutor ( ) ; executor . scheduleAtFixedRate ( ( ) -> { if ( mResult != null && mResult . size ( ) > <NUM_LIT> && ! mResult . get ( mResult . size ( ) - <NUM_LIT> ) . equals ( "<STR_LIT>" ) ) { updateUI ( mResult ) ; } } , <NUM_LIT> , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; return view ; } private int lastIndexOf ( String s , String splitTxt ) { return s . lastIndexOf ( splitTxt ) ; } private List < String > getRecentCommands ( ) { if ( mHistory == null && viewModel . getHistory ( ) != null ) { mRecentCommands = viewModel . getHistory ( ) ; mHistory = mRecentCommands ; } else { mRecentCommands = new ArrayList < > ( mHistory ) ; Collections . reverse ( mRecentCommands ) ; } return mRecentCommands ; } private String splitPrefix ( String s , int i ) { String [ ] splitPrefix = { s . substring ( <NUM_LIT> , lastIndexOf ( s , "<STR_LIT>" ) ) , s . substring ( lastIndexOf ( s , "<STR_LIT>" ) ) } ; return splitPrefix [ i ] . trim ( ) ; } private void initializeShell ( Activity activity ) { if ( mCommand . getText ( ) == null || mCommand . getText ( ) . toString ( ) . trim ( ) . isEmpty ( ) ) { return ; } if ( mShizukuShell != null && mShizukuShell . isBusy ( ) ) { new MaterialAlertDialogBuilder ( activity ) . setCancelable ( false ) . setTitle ( getString ( R . string . shell_working ) ) . setMessage ( getString ( R . string . app_working_message ) ) . setPositiveButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . show ( ) ; return ; } if ( Shizuku . checkSelfPermission ( ) == PackageManager . PERMISSION_GRANTED ) { runShellCommand ( mCommand . getText ( ) . toString ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) , activity ) ; } else { new MaterialAlertDialogBuilder ( activity ) . setCancelable ( false ) . setTitle ( getString ( R . string . access_denied ) ) . setMessage ( getString ( R . string . shizuku_access_denied_message ) ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setPositiveButton ( getString ( R . string . request_permission ) , ( dialogInterface , i ) -> Shizuku . requestPermission ( <NUM_LIT> ) ) . show ( ) ; } } private void runShellCommand ( String command , Activity activity ) { if ( ! isAdded ( ) ) { return ; } if ( mRecyclerViewOutput . getAdapter ( ) == null ) { mRecyclerViewOutput . setAdapter ( mShellOutputAdapter ) ; } activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LOCKED ) ; mCommand . setText ( null ) ; mCommand . clearFocus ( ) ; if ( mSearchWord . getVisibility ( ) == View . VISIBLE ) { mSearchWord . setText ( null ) ; mSearchWord . setVisibility ( View . GONE ) ; mBookMarks . setVisibility ( View . VISIBLE ) ; mSettingsButton . setVisibility ( View . VISIBLE ) ; } else { mHistoryButton . setVisibility ( View . GONE ) ; mClearButton . setVisibility ( View . GONE ) ; mSearchButton . setVisibility ( View . GONE ) ; } String finalCommand = command . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( finalCommand . equals ( "<STR_LIT>" ) && mResult != null ) { clearAll ( ) ; return ; } if ( finalCommand . equals ( "<STR_LIT>" ) && mResult != null ) { mRecyclerViewOutput . scrollToPosition ( <NUM_LIT> ) ; return ; } if ( finalCommand . equals ( "<STR_LIT>" ) && mResult != null ) { mRecyclerViewOutput . scrollToPosition ( Objects . requireNonNull ( mRecyclerViewOutput . getAdapter ( ) ) . getItemCount ( ) - <NUM_LIT> ) ; return ; } if ( finalCommand . equals ( "<STR_LIT>" ) ) { new MaterialAlertDialogBuilder ( activity ) . setCancelable ( false ) . setTitle ( "<STR_LIT>" ) . setMessage ( getString ( R . string . quit_app_message ) ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setPositiveButton ( getString ( R . string . quit ) , ( dialogInterface , i ) -> activity . finish ( ) ) . show ( ) ; return ; } if ( finalCommand . startsWith ( "<STR_LIT>" ) ) { mCommandInput . setError ( getString ( R . string . su_warning ) ) ; mCommandInput . setErrorIconDrawable ( Utils . getDrawable ( R . drawable . ic_error , requireActivity ( ) ) ) ; Utils . alignMargin ( mSendButton ) ; Utils . alignMargin ( localShellSymbol ) ; mCommand . requestFocus ( ) ; Utils . snackBar ( activity . findViewById ( android . R . id . content ) , getString ( R . string . su_warning_message ) ) . show ( ) ; if ( mResult != null && mResult . size ( ) > <NUM_LIT> ) { mClearButton . setVisibility ( View . VISIBLE ) ; mSearchButton . setVisibility ( View . VISIBLE ) ; } return ; } if ( mHistory == null ) { mHistory = new ArrayList < > ( ) ; } mHistory . add ( finalCommand ) ; mSaveButton . hide ( ) ; mShareButton . hide ( ) ; viewModel . setSendDrawable ( ic_stop ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_stop , requireActivity ( ) ) ) ; mSendButton . setColorFilter ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? ThemeUtils . colorError ( context ) : Utils . getColor ( R . color . red , context ) ) ; String mTitleText = "<STR_LIT>" + Utils . getColor ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? android . R . color . system_accent1_500 : R . color . blue , activity ) + "<STR_LIT>" + Utils . getDeviceName ( ) + "<STR_LIT>" + "<STR_LIT>" + Utils . getColor ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? android . R . color . system_accent3_500 : R . color . green , activity ) + "<STR_LIT>" + finalCommand ; if ( mResult == null ) { mResult = new ArrayList < > ( ) ; } mResult . add ( mTitleText ) ; ExecutorService mExecutors = Executors . newSingleThreadExecutor ( ) ; mExecutors . execute ( ( ) -> { if ( Shizuku . checkSelfPermission ( ) == PackageManager . PERMISSION_GRANTED ) { mPosition = mResult . size ( ) ; mShizukuShell = new ShizukuShell ( mResult , finalCommand ) ; mShizukuShell . exec ( ) ; try { TimeUnit . MILLISECONDS . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException ignored ) { } } new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> { if ( Shizuku . checkSelfPermission ( ) == PackageManager . PERMISSION_GRANTED ) { if ( mHistory != null && mHistory . size ( ) > <NUM_LIT> && mHistoryButton . getVisibility ( ) != View . VISIBLE ) { mHistoryButton . setVisibility ( View . VISIBLE ) ; } if ( mResult != null && mResult . size ( ) > <NUM_LIT> ) { mClearButton . setVisibility ( View . VISIBLE ) ; mSearchButton . setVisibility ( View . VISIBLE ) ; mResult . add ( "<STR_LIT>" ) ; mResult . add ( "<STR_LIT>" ) ; if ( ! isKeyboardVisible ) { mSaveButton . show ( ) ; mShareButton . show ( ) ; } } } else { new MaterialAlertDialogBuilder ( activity ) . setCancelable ( false ) . setTitle ( getString ( R . string . access_denied ) ) . setMessage ( getString ( R . string . shizuku_access_denied_message ) ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialogInterface , i ) -> { } ) . setPositiveButton ( getString ( R . string . request_permission ) , ( dialogInterface , i ) -> Shizuku . requestPermission ( <NUM_LIT> ) ) . show ( ) ; } if ( mCommand . getText ( ) == null || mCommand . getText ( ) . toString ( ) . trim ( ) . isEmpty ( ) ) { viewModel . setSendDrawable ( ic_help ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_help , requireActivity ( ) ) ) ; mSendButton . clearColorFilter ( ) ; } else { viewModel . setSendDrawable ( ic_send ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; mSendButton . clearColorFilter ( ) ; } activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_UNSPECIFIED ) ; if ( ! mCommand . isFocused ( ) ) mCommand . requestFocus ( ) ; } ) ; if ( ! mExecutors . isShutdown ( ) ) mExecutors . shutdown ( ) ; } ) ; } private void updateUI ( List < String > data ) { if ( data == null ) { return ; } List < String > mData = new ArrayList < > ( ) ; try { for ( String result : data ) { if ( ! TextUtils . isEmpty ( result ) && ! result . equals ( "<STR_LIT>" ) ) { mData . add ( result ) ; } } } catch ( ConcurrentModificationException ignored ) { } ExecutorService mExecutors = Executors . newSingleThreadExecutor ( ) ; mExecutors . execute ( ( ) -> { ShellOutputAdapter mShellOutputAdapter = new ShellOutputAdapter ( mData ) ; new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> { if ( isAdded ( ) && mRecyclerViewOutput != null ) { mRecyclerViewOutput . setAdapter ( mShellOutputAdapter ) ; mRecyclerViewOutput . scrollToPosition ( mData . size ( ) - <NUM_LIT> ) ; } } ) ; if ( ! mExecutors . isShutdown ( ) ) mExecutors . shutdown ( ) ; } ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mShizukuShell != null ) mShizukuShell . destroy ( ) ; } private void clearAll ( ) { if ( mShizukuShell != null ) mShizukuShell . destroy ( ) ; mResult = null ; if ( mTopButton . getVisibility ( ) == View . VISIBLE ) { mTopButton . setVisibility ( View . GONE ) ; } if ( mBottomButton . getVisibility ( ) == View . VISIBLE ) { mBottomButton . setVisibility ( View . GONE ) ; } mRecyclerViewOutput . setAdapter ( null ) ; mSearchButton . setVisibility ( View . GONE ) ; mSaveButton . setVisibility ( View . GONE ) ; mShareButton . setVisibility ( View . GONE ) ; mClearButton . setVisibility ( View . GONE ) ; showBottomNav ( ) ; mCommand . clearFocus ( ) ; if ( ! mCommand . isFocused ( ) ) mCommand . requestFocus ( ) ; } private void hideSearchBar ( ) { mSearchWord . setText ( null ) ; mSearchWord . setVisibility ( View . GONE ) ; if ( ! mCommand . isFocused ( ) ) mCommand . requestFocus ( ) ; mBookMarks . setVisibility ( View . VISIBLE ) ; mSettingsButton . setVisibility ( View . VISIBLE ) ; if ( mHistory != null && mHistory . size ( ) > <NUM_LIT> ) { mHistoryButton . setVisibility ( View . VISIBLE ) ; } if ( mResult != null && mResult . size ( ) > <NUM_LIT> && ! mShizukuShell . isBusy ( ) ) { mClearButton . setVisibility ( View . VISIBLE ) ; mSearchButton . setVisibility ( View . VISIBLE ) ; } } private void showBottomNav ( ) { if ( getActivity ( ) != null && getActivity ( ) instanceof MainActivity ) { ( ( MainActivity ) getActivity ( ) ) . mNav . animate ( ) . translationY ( <NUM_LIT> ) ; } } private void setVisibilityWithDelay ( View view , int delayMillis ) { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( ( ) -> { view . setVisibility ( View . VISIBLE ) ; } , delayMillis ) ; } public void handleSharedTextIntent ( Intent intent , String sharedText ) { if ( sharedText != null ) { boolean switchState = Preferences . getShareAndRun ( context ) ; updateInputField ( sharedText ) ; if ( switchState ) { if ( ! Shizuku . pingBinder ( ) ) { handleShizukuAvailability ( context ) ; } else { mCommand . setText ( sharedText ) ; initializeShell ( requireActivity ( ) ) ; } } } return ; } public void updateInputField ( String text ) { if ( text != null ) { mCommand . setText ( text ) ; mCommand . requestFocus ( ) ; mCommand . setSelection ( mCommand . getText ( ) . length ( ) ) ; viewModel . setSendDrawable ( ic_send ) ; mSendButton . setImageDrawable ( Utils . getDrawable ( R . drawable . ic_send , requireActivity ( ) ) ) ; viewModel . setEditTextFocused ( true ) ; viewModel . setSendDrawable ( ic_send ) ; } } private void handleShizukuAvailability ( Context context ) { mCommandInput . setError ( getString ( R . string . shizuku_unavailable ) ) ; if ( mCommand . getText ( ) != null ) { mCommandInput . setErrorIconDrawable ( Utils . getDrawable ( R . drawable . ic_cancel , requireActivity ( ) ) ) ; mCommandInput . setErrorIconOnClickListener ( t -> { mCommand . setText ( null ) ; } ) ; } Utils . alignMargin ( mSendButton ) ; Utils . alignMargin ( localShellSymbol ) ; new MaterialAlertDialogBuilder ( requireActivity ( ) ) . setTitle ( getString ( R . string . warning ) ) . setMessage ( getString ( R . string . shizuku_unavailable_message ) ) . setNegativeButton ( getString ( R . string . shizuku_about ) , ( dialogInterface , i ) -> { Utils . openUrl ( context , "<STR_LIT>" ) ; } ) . setPositiveButton ( getString ( R . string . ok ) , ( dialogInterface , i ) -> { } ) . show ( ) ; } private boolean isEditTextFocused ( ) { return mCommand . hasFocus ( ) ; } private boolean isSaveButtonVisible ( ) { return mSaveButton . getVisibility ( ) == View . VISIBLE ; } private void setupRecyclerView ( ) { mRecyclerViewOutput = view . findViewById ( R . id . recycler_view_output ) ; mRecyclerViewOutput . setLayoutManager ( new LinearLayoutManager ( requireActivity ( ) ) ) ; List < String > shellOutput = viewModel . getShellOutput ( ) ; int scrollPosition = viewModel . getScrollPosition ( ) ; if ( shellOutput != null ) { mShellOutputAdapter = new ShellOutputAdapter ( shellOutput ) ; mResult = shellOutput ; } mRecyclerViewOutput . setAdapter ( mShellOutputAdapter ) ; mRecyclerViewOutput . scrollToPosition ( scrollPosition ) ; String mCommandText = viewModel . getCommandText ( ) ; if ( mCommandText != null ) { mCommand . setText ( mCommandText ) ; } } private void updateHistoryAndBookMarksConstraints ( ) { boolean isHistoryButtonVisible = mHistoryButton . getVisibility ( ) == View . VISIBLE ; boolean isBookMarksVisible = mBookMarks . getVisibility ( ) == View . VISIBLE ; boolean isClearVisible = mClearButton . getVisibility ( ) == View . VISIBLE ; boolean isOthersGone = mClearButton . getVisibility ( ) == View . GONE && mSearchButton . getVisibility ( ) == View . GONE ; ConstraintLayout . LayoutParams layoutParamsBookMarks = ( ConstraintLayout . LayoutParams ) mBookMarks . getLayoutParams ( ) ; ConstraintLayout . LayoutParams layoutParamsHistory = ( ConstraintLayout . LayoutParams ) mHistoryButton . getLayoutParams ( ) ; if ( isOthersGone && isBookMarksVisible && isHistoryButtonVisible ) { layoutParamsBookMarks . startToEnd = R . id . settings ; layoutParamsBookMarks . endToStart = R . id . history ; layoutParamsHistory . startToEnd = R . id . bookmarks ; layoutParamsHistory . endToEnd = ConstraintLayout . LayoutParams . PARENT_ID ; layoutParamsHistory . setMarginEnd ( <NUM_LIT> ) ; } else { layoutParamsHistory . endToStart = isClearVisible ? R . id . clear : ConstraintLayout . LayoutParams . UNSET ; layoutParamsHistory . startToEnd = isBookMarksVisible ? R . id . bookmarks : R . id . settings ; layoutParamsHistory . setMarginStart ( isBookMarksVisible ? <NUM_LIT> : <NUM_LIT> ) ; layoutParamsBookMarks . endToStart = isHistoryButtonVisible ? R . id . history : ConstraintLayout . LayoutParams . UNSET ; layoutParamsBookMarks . setMarginStart ( isHistoryButtonVisible ? <NUM_LIT> : <NUM_LIT> ) ; } mBookMarks . setLayoutParams ( layoutParamsBookMarks ) ; mBookMarks . requestLayout ( ) ; mBookMarks . invalidate ( ) ; mHistoryButton . setLayoutParams ( layoutParamsHistory ) ; mHistoryButton . requestLayout ( ) ; mHistoryButton . invalidate ( ) ; } private void initializeResults ( ) { if ( mResult == null ) { mResult = shellOutput ; } if ( mHistory == null ) { mHistory = history ; } } private StringBuilder buildResultsString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = mPosition ; i < mResult . size ( ) ; i ++ ) { String result = mResult . get ( i ) ; if ( ! "<STR_LIT>" . equals ( result ) && ! "<STR_LIT>" . equals ( result ) ) { sb . append ( result ) . append ( "<STR_LIT>" ) ; } } return sb ; } } </s>
<s> package in . hridayan . ashell . adapters ; import android . content . Context ; import android . graphics . PorterDuff ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . core . content . ContextCompat ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . divider . MaterialDivider ; import in . hridayan . ashell . R ; import in . hridayan . ashell . utils . ChangelogItem ; import java . util . List ; public class ChangelogAdapter extends RecyclerView . Adapter < ChangelogAdapter . ViewHolder > { private List < ChangelogItem > changelogList ; private Context context ; public ChangelogAdapter ( List < ChangelogItem > changelogList , Context context ) { this . changelogList = changelogList ; this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . item_changelog , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ChangelogItem changelogItem = changelogList . get ( position ) ; holder . titleTextView . setText ( changelogItem . getTitle ( ) ) ; holder . descriptionTextView . setText ( changelogItem . getDescription ( ) ) ; holder . divider . setVisibility ( position == changelogList . size ( ) - <NUM_LIT> ? View . GONE : View . VISIBLE ) ; holder . titleTextView . setTextAppearance ( position == <NUM_LIT> ? R . style . LatestVersionTitle : R . style . OtherVersionTitle ) ; } @ Override public int getItemCount ( ) { return changelogList . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { TextView titleTextView ; TextView descriptionTextView ; MaterialDivider divider ; public ViewHolder ( View itemView ) { super ( itemView ) ; titleTextView = itemView . findViewById ( R . id . changelog_title ) ; descriptionTextView = itemView . findViewById ( R . id . changelog_description ) ; divider = itemView . findViewById ( R . id . divider ) ; } } } </s>
<s> package in . hridayan . ashell . utils ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . preference . PreferenceManager ; public class Preferences { public static final String buildGradleUrl = "<STR_LIT>" ; private static final String PREF_AMOLED_THEME = "<STR_LIT>" , PREF_COUNTER_PREFIX = "<STR_LIT>" , PREF_PINNED_PREFIX = "<STR_LIT>" , PREF_CLEAR = "<STR_LIT>" , PREF_SHARE_AND_RUN = "<STR_LIT>" , PREF_DISABLE_SOFTKEY = "<STR_LIT>" , PREF_OVERRIDE_BOOKMARKS = "<STR_LIT>" , PREF_SMOOTH_SCROLL = "<STR_LIT>" , PREF_SAVED_VERSION_CODE = "<STR_LIT>" , PREF_SORTING_OPTION = "<STR_LIT>" , PREF_SORTING_EXAMPLES = "<STR_LIT>" , PREF_CURRENT_FRAGMENT = "<STR_LIT>" , PREF_DEFAULT_WORKING_MODE = "<STR_LIT>" , PREF_SPECIFIC_CARD_VISIBILITY = "<STR_LIT>" , PREF_AUTO_UPDATE_CHECK = "<STR_LIT>" ; public static final int SORT_A_TO_Z = <NUM_LIT> , SORT_Z_TO_A = <NUM_LIT> , SORT_MOST_USED = <NUM_LIT> , SORT_OLDEST = <NUM_LIT> , SORT_NEWEST = <NUM_LIT> , SORT_LEAST_USED = <NUM_LIT> , LOCAL_FRAGMENT = <NUM_LIT> , OTG_FRAGMENT = <NUM_LIT> , MODE_LOCAL_ADB = <NUM_LIT> , MODE_OTG = <NUM_LIT> , MODE_REMEMBER_LAST_MODE = <NUM_LIT> , MAX_BOOKMARKS_LIMIT = <NUM_LIT> , UPDATE_AVAILABLE = <NUM_LIT> , UPDATE_NOT_AVAILABLE = <NUM_LIT> , CONNECTION_ERROR = <NUM_LIT> ; private static SharedPreferences getSharedPreferences ( Context context ) { return PreferenceManager . getDefaultSharedPreferences ( context ) ; } public static boolean getAmoledTheme ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_AMOLED_THEME , false ) ; } public static void setAmoledTheme ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_AMOLED_THEME , value ) . apply ( ) ; } public static boolean getClear ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_CLEAR , true ) ; } public static void setClear ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_CLEAR , value ) . apply ( ) ; } public static boolean getShareAndRun ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_SHARE_AND_RUN , false ) ; } public static void setShareAndRun ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_SHARE_AND_RUN , value ) . apply ( ) ; } public static boolean getDisableSoftkey ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_DISABLE_SOFTKEY , false ) ; } public static void setDisableSoftkey ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_DISABLE_SOFTKEY , value ) . apply ( ) ; } public static boolean getOverrideBookmarks ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_OVERRIDE_BOOKMARKS , false ) ; } public static void setOverrideBookmarks ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_OVERRIDE_BOOKMARKS , value ) . apply ( ) ; } public static boolean getSmoothScroll ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_SMOOTH_SCROLL , true ) ; } public static void setSmoothScroll ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_SMOOTH_SCROLL , value ) . apply ( ) ; } public static boolean getAutoUpdateCheck ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_AUTO_UPDATE_CHECK , true ) ; } public static void setAutoUpdateCheck ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_AUTO_UPDATE_CHECK , value ) . apply ( ) ; } public static int getSavedVersionCode ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_SAVED_VERSION_CODE , <NUM_LIT> ) ; } public static void setSavedVersionCode ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SAVED_VERSION_CODE , value ) . apply ( ) ; } public static int getSortingOption ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_SORTING_OPTION , SORT_A_TO_Z ) ; } public static void setSortingOption ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SORTING_OPTION , value ) . apply ( ) ; } public static int getSortingExamples ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_SORTING_EXAMPLES , SORT_A_TO_Z ) ; } public static void setSortingExamples ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SORTING_EXAMPLES , value ) . apply ( ) ; } public static void setWorkingMode ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_DEFAULT_WORKING_MODE , value ) . apply ( ) ; } public static int getWorkingMode ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_DEFAULT_WORKING_MODE , MODE_LOCAL_ADB ) ; } public static int getCurrentFragment ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_CURRENT_FRAGMENT , LOCAL_FRAGMENT ) ; } public static void setCurrentFragment ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_CURRENT_FRAGMENT , value ) . apply ( ) ; } public static int getUseCounter ( Context context , String title ) { return getSharedPreferences ( context ) . getInt ( getCounterKey ( title ) , <NUM_LIT> ) ; } public static void setUseCounter ( Context context , String title , int counter ) { getSharedPreferences ( context ) . edit ( ) . putInt ( getCounterKey ( title ) , counter ) . apply ( ) ; } public static boolean getPinned ( Context context , String title ) { return getSharedPreferences ( context ) . getBoolean ( getPinnedKey ( title ) , false ) ; } public static void setPinned ( Context context , String title , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( getPinnedKey ( title ) , value ) . apply ( ) ; } public static boolean getSpecificCardVisibility ( Context context , String title ) { return getSharedPreferences ( context ) . getBoolean ( getCardKey ( title ) , true ) ; } public static void setSpecificCardVisibility ( Context context , String title , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( getCardKey ( title ) , value ) . apply ( ) ; } private static String getCounterKey ( String title ) { return PREF_COUNTER_PREFIX + title ; } private static String getPinnedKey ( String title ) { return PREF_PINNED_PREFIX + title ; } private static String getCardKey ( String title ) { return PREF_SPECIFIC_CARD_VISIBILITY + title ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; public interface ResultCallback { void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . graphics . Point ; import android . util . DisplayMetrics ; import android . view . Display ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . google . mlkit . vision . barcode . common . Barcode ; import com . google . mlkit . vision . common . InputImage ; import org . json . JSONArray ; import org . json . JSONException ; public class BarcodeScannerHelper { public static JSObject createBarcodeResultForBarcode ( @ NonNull Barcode barcode , @ Nullable Point imageSize , @ Nullable Point screenSize ) { Point [ ] cornerPoints = barcode . getCornerPoints ( ) ; JSArray cornerPointsResult = new JSArray ( ) ; if ( cornerPoints != null && imageSize != null && screenSize != null ) { Point [ ] normalizedCornerPoints = normalizeCornerPoints ( cornerPoints , imageSize , screenSize ) ; for ( int i = <NUM_LIT> ; i < normalizedCornerPoints . length ; i ++ ) { JSArray cornerPointResult = new JSArray ( ) ; cornerPointResult . put ( normalizedCornerPoints [ i ] . x ) ; cornerPointResult . put ( normalizedCornerPoints [ i ] . y ) ; cornerPointsResult . put ( cornerPointResult ) ; } } JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , convertByteArrayToJsonArray ( barcode . getRawBytes ( ) ) ) ; if ( cornerPoints != null ) { result . put ( "<STR_LIT>" , cornerPointsResult ) ; } result . put ( "<STR_LIT>" , barcode . getDisplayValue ( ) ) ; result . put ( "<STR_LIT>" , convertBarcodeScannerFormatToString ( barcode . getFormat ( ) ) ) ; result . put ( "<STR_LIT>" , barcode . getRawValue ( ) ) ; result . put ( "<STR_LIT>" , convertBarcodeValueTypeToString ( barcode . getValueType ( ) ) ) ; return result ; } public static int [ ] convertStringsToBarcodeScannerFormats ( String [ ] values ) throws JSONException { int [ ] formats = new int [ values . length ] ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { Integer format = convertStringToBarcodeScannerFormat ( values [ i ] ) ; if ( format == null ) { continue ; } formats [ i ] = format ; } return formats ; } @ Nullable public static Integer convertStringToBarcodeScannerFormat ( String value ) { switch ( value ) { case "<STR_LIT>" : return Barcode . FORMAT_AZTEC ; case "<STR_LIT>" : return Barcode . FORMAT_CODABAR ; case "<STR_LIT>" : return Barcode . FORMAT_CODE_39 ; case "<STR_LIT>" : return Barcode . FORMAT_CODE_93 ; case "<STR_LIT>" : return Barcode . FORMAT_CODE_128 ; case "<STR_LIT>" : return Barcode . FORMAT_DATA_MATRIX ; case "<STR_LIT>" : return Barcode . FORMAT_EAN_8 ; case "<STR_LIT>" : return Barcode . FORMAT_EAN_13 ; case "<STR_LIT>" : return Barcode . FORMAT_ITF ; case "<STR_LIT>" : return Barcode . FORMAT_PDF417 ; case "<STR_LIT>" : return Barcode . FORMAT_QR_CODE ; case "<STR_LIT>" : return Barcode . FORMAT_UPC_A ; case "<STR_LIT>" : return Barcode . FORMAT_UPC_E ; default : return null ; } } @ Nullable public static String convertBarcodeScannerFormatToString ( int format ) { switch ( format ) { case Barcode . FORMAT_AZTEC : return "<STR_LIT>" ; case Barcode . FORMAT_CODABAR : return "<STR_LIT>" ; case Barcode . FORMAT_CODE_39 : return "<STR_LIT>" ; case Barcode . FORMAT_CODE_93 : return "<STR_LIT>" ; case Barcode . FORMAT_CODE_128 : return "<STR_LIT>" ; case Barcode . FORMAT_DATA_MATRIX : return "<STR_LIT>" ; case Barcode . FORMAT_EAN_8 : return "<STR_LIT>" ; case Barcode . FORMAT_EAN_13 : return "<STR_LIT>" ; case Barcode . FORMAT_ITF : return "<STR_LIT>" ; case Barcode . FORMAT_PDF417 : return "<STR_LIT>" ; case Barcode . FORMAT_QR_CODE : return "<STR_LIT>" ; case Barcode . FORMAT_UPC_A : return "<STR_LIT>" ; case Barcode . FORMAT_UPC_E : return "<STR_LIT>" ; default : return null ; } } @ Nullable public static String convertBarcodeValueTypeToString ( int format ) { switch ( format ) { case Barcode . TYPE_CALENDAR_EVENT : return "<STR_LIT>" ; case Barcode . TYPE_CONTACT_INFO : return "<STR_LIT>" ; case Barcode . TYPE_DRIVER_LICENSE : return "<STR_LIT>" ; case Barcode . TYPE_EMAIL : return "<STR_LIT>" ; case Barcode . TYPE_GEO : return "<STR_LIT>" ; case Barcode . TYPE_ISBN : return "<STR_LIT>" ; case Barcode . TYPE_PHONE : return "<STR_LIT>" ; case Barcode . TYPE_PRODUCT : return "<STR_LIT>" ; case Barcode . TYPE_SMS : return "<STR_LIT>" ; case Barcode . TYPE_TEXT : return "<STR_LIT>" ; case Barcode . TYPE_URL : return "<STR_LIT>" ; case Barcode . TYPE_WIFI : return "<STR_LIT>" ; default : return "<STR_LIT>" ; } } private static JSONArray convertByteArrayToJsonArray ( byte [ ] bytes ) { JSONArray ret = new JSONArray ( ) ; for ( byte _byte : bytes ) { ret . put ( _byte ) ; } return ret ; } private static Point [ ] normalizeCornerPoints ( @ NonNull Point [ ] cornerPoints , @ NonNull Point imageSize , @ NonNull Point screenSize ) { double screenWidth = screenSize . x ; double screenHeight = screenSize . y ; double imageWidth = imageSize . x ; double imageHeight = imageSize . y ; if ( screenWidth > screenHeight ) { imageWidth = imageSize . y ; imageHeight = imageSize . x ; } double scale = Math . max ( screenHeight / imageWidth , screenWidth / imageHeight ) ; double invisibleWidth = imageHeight * scale - screenWidth ; double invisibleHeight = imageWidth * scale - screenHeight ; Point [ ] normalizedCornerPoints = new Point [ cornerPoints . length ] ; for ( int i = <NUM_LIT> ; i < cornerPoints . length ; i ++ ) { int x = ( int ) ( ( cornerPoints [ i ] . x * scale ) - ( invisibleWidth / <NUM_LIT> ) ) ; int y = ( int ) ( ( cornerPoints [ i ] . y * scale ) - ( invisibleHeight / <NUM_LIT> ) ) ; normalizedCornerPoints [ i ] = new Point ( x , y ) ; } return normalizedCornerPoints ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; import com . getcapacitor . JSObject ; public interface Result { JSObject toJSObject ( ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; import androidx . annotation . NonNull ; public interface NonEmptyResultCallback < T extends Result > extends ResultCallback { void success ( @ NonNull T result ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces . Result ; public class GetMaxZoomRatioResult implements Result { private float zoomRatio ; public GetMaxZoomRatioResult ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , zoomRatio ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . translation ; import androidx . annotation . NonNull ; import com . google . android . gms . tasks . OnFailureListener ; import com . google . android . gms . tasks . OnSuccessListener ; import com . google . mlkit . common . model . DownloadConditions ; import com . google . mlkit . common . model . RemoteModelManager ; import com . google . mlkit . nl . translate . TranslateRemoteModel ; import com . google . mlkit . nl . translate . Translator ; import com . google . mlkit . nl . translate . TranslatorOptions ; import java . util . Set ; public class Translation { private RemoteModelManager modelManager ; public Translation ( ) { this . modelManager = RemoteModelManager . getInstance ( ) ; } public void deleteDownloadedModel ( String language , final DeleteDownloadedModelResultCallback resultCallback ) { TranslateRemoteModel frenchModel = new TranslateRemoteModel . Builder ( language ) . build ( ) ; modelManager . deleteDownloadedModel ( frenchModel ) . addOnSuccessListener ( ( OnSuccessListener ) result -> { resultCallback . success ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void downloadModel ( String language , final DownloadModelResultCallback resultCallback ) { TranslateRemoteModel frenchModel = new TranslateRemoteModel . Builder ( language ) . build ( ) ; DownloadConditions conditions = new DownloadConditions . Builder ( ) . requireWifi ( ) . build ( ) ; modelManager . download ( frenchModel , conditions ) . addOnSuccessListener ( ( OnSuccessListener ) result -> { resultCallback . success ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void getDownloadedModels ( final GetDownloadedModelsResultCallback resultCallback ) { modelManager . getDownloadedModels ( TranslateRemoteModel . class ) . addOnSuccessListener ( ( OnSuccessListener < Set < TranslateRemoteModel > > ) models -> { resultCallback . success ( models ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void translate ( String text , String sourceLanguage , String targetLanguage , final TranslateResultCallback resultCallback ) { TranslatorOptions options = new TranslatorOptions . Builder ( ) . setSourceLanguage ( sourceLanguage ) . setTargetLanguage ( targetLanguage ) . build ( ) ; final Translator translator = com . google . mlkit . nl . translate . Translation . getClient ( options ) ; DownloadConditions conditions = new DownloadConditions . Builder ( ) . requireWifi ( ) . build ( ) ; translator . downloadModelIfNeeded ( conditions ) . addOnSuccessListener ( ( OnSuccessListener ) downloadModelIfNeededResult -> { translator . translate ( text ) . addOnSuccessListener ( ( OnSuccessListener < String > ) translateResult -> { resultCallback . success ( translateResult ) ; translator . close ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; translator . close ( ) ; } ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; translator . close ( ) ; } ) ; } } </s>
<s> package com . getcapacitor . android ; import static org . junit . Assert . * ; import android . content . Context ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import androidx . test . platform . app . InstrumentationRegistry ; import org . junit . Test ; import org . junit . runner . RunWith ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) throws Exception { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( "<STR_LIT>" , appContext . getPackageName ( ) ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes ; import com . getcapacitor . JSObject ; public class ProcessImageResult { private final String imagePath ; private final int width ; private final int height ; public ProcessImageResult ( String imagePath , int width , int height ) { this . imagePath = imagePath ; this . width = width ; this . height = height ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , imagePath ) ; result . put ( "<STR_LIT>" , width ) ; result . put ( "<STR_LIT>" , height ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . FaceDetectorOptions ; public class ProcessImageOptions { private InputImage inputImage ; @ FaceDetectorOptions . PerformanceMode private int performanceMode ; @ FaceDetectorOptions . LandmarkMode private int landmarkMode ; @ FaceDetectorOptions . ContourMode private int contourMode ; @ FaceDetectorOptions . ClassificationMode private int classificationMode ; private float minFaceSize ; private boolean enableTracking ; public ProcessImageOptions ( InputImage inputImage , @ FaceDetectorOptions . PerformanceMode int performanceMode , @ FaceDetectorOptions . LandmarkMode int landmarkMode , @ FaceDetectorOptions . ContourMode int contourMode , @ FaceDetectorOptions . ClassificationMode int classificationMode , float minFaceSize , boolean enableTracking ) { this . inputImage = inputImage ; this . performanceMode = performanceMode ; this . landmarkMode = landmarkMode ; this . contourMode = contourMode ; this . classificationMode = classificationMode ; this . minFaceSize = minFaceSize ; this . enableTracking = enableTracking ; } public InputImage getInputImage ( ) { return inputImage ; } public int getPerformanceMode ( ) { return performanceMode ; } public int getLandmarkMode ( ) { return landmarkMode ; } public int getContourMode ( ) { return contourMode ; } public int getClassificationMode ( ) { return classificationMode ; } public float getMinFaceSize ( ) { return minFaceSize ; } public boolean isTrackingEnabled ( ) { return enableTracking ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import android . annotation . SuppressLint ; import android . graphics . Bitmap ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . segmentation . Segmentation ; import com . google . mlkit . vision . segmentation . Segmenter ; import com . google . mlkit . vision . segmentation . selfie . SelfieSegmenterOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Objects ; public class SelfieSegmentation { @ NonNull private final SelfieSegmentationPlugin plugin ; public SelfieSegmentation ( @ NonNull SelfieSegmentationPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ; Float threshold = options . getConfidence ( ) ; SelfieSegmenterOptions . Builder builder = new SelfieSegmenterOptions . Builder ( ) ; builder . setDetectorMode ( SelfieSegmenterOptions . SINGLE_IMAGE_MODE ) ; SelfieSegmenterOptions selfieSegmenterOptions = builder . build ( ) ; final Segmenter segmenter = Segmentation . getClient ( selfieSegmenterOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> segmenter . process ( inputImage ) . addOnSuccessListener ( segmentationMask -> { segmenter . close ( ) ; ByteBuffer mask = segmentationMask . getBuffer ( ) ; Bitmap bitmap = inputImage . getBitmapInternal ( ) ; Objects . requireNonNull ( bitmap ) . setHasAlpha ( true ) ; ByteBuffer pixels = ByteBuffer . allocateDirect ( bitmap . getAllocationByteCount ( ) ) ; bitmap . copyPixelsToBuffer ( pixels ) ; final boolean bigEndian = pixels . order ( ) == ByteOrder . BIG_ENDIAN ; final int ALPHA = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int RED = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int GREEN = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int BLUE = bigEndian ? <NUM_LIT> : <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < pixels . capacity ( ) > > <NUM_LIT> ; i ++ ) { float confidence = mask . getFloat ( ) ; if ( confidence >= threshold ) { byte red = pixels . get ( ( i << <NUM_LIT> ) + RED ) ; byte green = pixels . get ( ( i << <NUM_LIT> ) + GREEN ) ; byte blue = pixels . get ( ( i << <NUM_LIT> ) + BLUE ) ; pixels . put ( ( i << <NUM_LIT> ) + ALPHA , ( byte ) ( <NUM_LIT> ) ) ; pixels . put ( ( i << <NUM_LIT> ) + RED , ( byte ) ( red * confidence ) ) ; pixels . put ( ( i << <NUM_LIT> ) + GREEN , ( byte ) ( green * confidence ) ) ; pixels . put ( ( i << <NUM_LIT> ) + BLUE , ( byte ) ( blue * confidence ) ) ; } else { pixels . putInt ( i << <NUM_LIT> , <NUM_LIT> ) ; } } bitmap . copyPixelsFromBuffer ( pixels . rewind ( ) ) ; @ SuppressLint ( "<STR_LIT>" ) String timeStamp = new SimpleDateFormat ( "<STR_LIT>" ) . format ( new Date ( ) ) ; String imageFileName = "<STR_LIT>" + timeStamp + "<STR_LIT>" ; try { File image = File . createTempFile ( imageFileName , "<STR_LIT>" ) ; OutputStream stream = new FileOutputStream ( image ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , stream ) ; stream . close ( ) ; ProcessImageResult result = new ProcessImageResult ( image . getAbsolutePath ( ) , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; callback . success ( result ) ; } catch ( Exception exception ) { callback . error ( exception ) ; } } ) . addOnCanceledListener ( ( ) -> { segmenter . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { segmenter . close ( ) ; callback . error ( exception ) ; } ) ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . google . mlkit . vision . barcode . common . Barcode ; public class ScanSettings { @ Barcode . BarcodeFormat public int [ ] formats = new int [ ] { } ; @ Nullable @ CameraSelector . LensFacing public Integer lensFacing ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import com . google . mlkit . vision . barcode . common . Barcode ; import java . util . List ; public interface ReadBarcodesFromImageResultCallback { void success ( List < Barcode > barcodes ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface IsGoogleBarodeScannerModuleAvailableResultCallback { void success ( boolean isAvailable ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . facemesh . FaceMeshDetector ; import com . google . mlkit . vision . facemesh . FaceMeshDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; public class FaceMeshDetection { @ NonNull private final FaceMeshDetectionPlugin plugin ; public FaceMeshDetection ( @ NonNull FaceMeshDetectionPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ; int useCase = options . getUseCase ( ) ; FaceMeshDetectorOptions . Builder builder = new FaceMeshDetectorOptions . Builder ( ) ; builder . setUseCase ( useCase ) ; builder . build ( ) ; FaceMeshDetectorOptions faceMeshDetectorOptions = builder . build ( ) ; final FaceMeshDetector faceMeshDetector = com . google . mlkit . vision . facemesh . FaceMeshDetection . getClient ( faceMeshDetectorOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> { faceMeshDetector . process ( inputImage ) . addOnSuccessListener ( faceMeshs -> { faceMeshDetector . close ( ) ; ProcessImageResult result = new ProcessImageResult ( faceMeshs ) ; callback . success ( result ) ; } ) . addOnCanceledListener ( ( ) -> { faceMeshDetector . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { faceMeshDetector . close ( ) ; callback . error ( exception ) ; } ) ; } ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface StartScanResultCallback { void success ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; public interface ProcessImageResultCallback { void success ( ProcessImageResult result ) ; void cancel ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . translation ; public interface TranslateResultCallback { void success ( String text ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . translation ; public interface DownloadModelResultCallback { void success ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes ; import android . graphics . Bitmap ; import com . google . mlkit . vision . common . InputImage ; import java . util . Objects ; public class ProcessImageOptions { private final InputImage inputImage ; private final Float confidence ; public ProcessImageOptions ( InputImage inputImage , Integer width , Integer height , Float confidence ) { this . inputImage = scaledImage ( inputImage , width , height ) ; this . confidence = confidence ; } public InputImage getInputImage ( ) { return inputImage ; } public Float getConfidence ( ) { return confidence ; } private InputImage scaledImage ( InputImage inputImage , Integer width , Integer height ) { float scaleX = ( width != null ) ? width * <NUM_LIT> / inputImage . getWidth ( ) : <NUM_LIT> ; float scaleY = ( height != null ) ? height * <NUM_LIT> / inputImage . getHeight ( ) : <NUM_LIT> ; if ( scaleX > <NUM_LIT> || scaleY > <NUM_LIT> ) { if ( scaleX > <NUM_LIT> && scaleY == <NUM_LIT> ) scaleY = scaleX ; else if ( scaleY > <NUM_LIT> && scaleX == <NUM_LIT> ) scaleX = scaleY ; return InputImage . fromBitmap ( Bitmap . createScaledBitmap ( Objects . requireNonNull ( inputImage . getBitmapInternal ( ) ) , ( int ) ( inputImage . getWidth ( ) * scaleX ) , ( int ) ( inputImage . getHeight ( ) * scaleY ) , false ) , inputImage . getRotationDegrees ( ) ) ; } return inputImage ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . facemesh . FaceMeshDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class FaceMeshDetectionPlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = "<STR_LIT>" ; public static final String ERROR_PATH_MISSING = "<STR_LIT>" ; public static final String ERROR_LOAD_IMAGE_FAILED = "<STR_LIT>" ; private FaceMeshDetection implementation ; @ Override public void load ( ) { try { implementation = new FaceMeshDetection ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( "<STR_LIT>" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer useCase = call . getInt ( "<STR_LIT>" , FaceMeshDetectorOptions . FACE_MESH ) ; InputImage image = implementation . createInputImageFromFilePath ( path ) ; if ( image == null ) { call . reject ( ERROR_LOAD_IMAGE_FAILED ) ; return ; } ProcessImageOptions options = new ProcessImageOptions ( image , useCase ) ; implementation . processImage ( options , new ProcessImageResultCallback ( ) { @ Override public void success ( ProcessImageResult result ) { try { call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } @ Override public void cancel ( ) { call . reject ( ERROR_PROCESS_IMAGE_CANCELED ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } } </s>
<s> package com . getcapacitor ; import static org . junit . Assert . * ; import org . junit . Test ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; public interface ProcessImageResultCallback { void success ( ProcessImageResult result ) ; void cancel ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; public interface EmptyResultCallback extends ResultCallback { void success ( ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . Point ; import android . media . Image ; import android . net . Uri ; import android . provider . Settings ; import android . view . Display ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . Camera ; import androidx . camera . core . CameraSelector ; import androidx . camera . core . ImageAnalysis ; import androidx . camera . core . ImageProxy ; import androidx . camera . core . Preview ; import androidx . camera . lifecycle . ProcessCameraProvider ; import androidx . camera . view . PreviewView ; import androidx . core . content . ContextCompat ; import androidx . lifecycle . LifecycleOwner ; import com . getcapacitor . PermissionState ; import com . getcapacitor . PluginCall ; import com . google . android . gms . common . moduleinstall . InstallStatusListener ; import com . google . android . gms . common . moduleinstall . ModuleInstall ; import com . google . android . gms . common . moduleinstall . ModuleInstallClient ; import com . google . android . gms . common . moduleinstall . ModuleInstallRequest ; import com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . mlkit . vision . barcode . BarcodeScannerOptions ; import com . google . mlkit . vision . barcode . BarcodeScanning ; import com . google . mlkit . vision . barcode . common . Barcode ; import com . google . mlkit . vision . codescanner . GmsBarcodeScanner ; import com . google . mlkit . vision . codescanner . GmsBarcodeScannerOptions ; import com . google . mlkit . vision . codescanner . GmsBarcodeScanning ; import com . google . mlkit . vision . common . InputImage ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; public class BarcodeScanner implements ImageAnalysis . Analyzer { @ NonNull private final BarcodeScannerPlugin plugin ; private final Point displaySize ; @ Nullable private com . google . mlkit . vision . barcode . BarcodeScanner barcodeScannerInstance ; @ Nullable private Camera camera ; @ Nullable private ProcessCameraProvider processCameraProvider ; @ Nullable private PreviewView previewView ; @ Nullable private ScanSettings scanSettings ; @ Nullable private ModuleInstallProgressListener moduleInstallProgressListener ; private boolean isTorchEnabled = false ; public BarcodeScanner ( BarcodeScannerPlugin plugin ) { this . plugin = plugin ; this . displaySize = this . getDisplaySize ( ) ; } public void startScan ( ScanSettings scanSettings , StartScanResultCallback callback ) { stopScan ( ) ; hideWebViewBackground ( ) ; this . scanSettings = scanSettings ; BarcodeScannerOptions options = buildBarcodeScannerOptions ( scanSettings ) ; barcodeScannerInstance = BarcodeScanning . getClient ( options ) ; ImageAnalysis imageAnalysis = new ImageAnalysis . Builder ( ) . setBackpressureStrategy ( ImageAnalysis . STRATEGY_KEEP_ONLY_LATEST ) . build ( ) ; imageAnalysis . setAnalyzer ( ContextCompat . getMainExecutor ( plugin . getContext ( ) ) , this ) ; ListenableFuture < ProcessCameraProvider > cameraProviderFuture = ProcessCameraProvider . getInstance ( plugin . getContext ( ) ) ; cameraProviderFuture . addListener ( ( ) -> { try { processCameraProvider = cameraProviderFuture . get ( ) ; CameraSelector cameraSelector = new CameraSelector . Builder ( ) . requireLensFacing ( this . scanSettings . lensFacing ) . build ( ) ; previewView = plugin . getActivity ( ) . findViewById ( R . id . preview_view ) ; previewView . setScaleType ( PreviewView . ScaleType . FILL_CENTER ) ; Preview preview = new Preview . Builder ( ) . build ( ) ; preview . setSurfaceProvider ( previewView . getSurfaceProvider ( ) ) ; camera = processCameraProvider . bindToLifecycle ( ( LifecycleOwner ) plugin . getContext ( ) , cameraSelector , preview , imageAnalysis ) ; callback . success ( ) ; } catch ( Exception exception ) { callback . error ( exception ) ; } } , ContextCompat . getMainExecutor ( plugin . getContext ( ) ) ) ; } public void stopScan ( ) { showWebViewBackground ( ) ; disableTorch ( ) ; if ( processCameraProvider != null ) { processCameraProvider . unbindAll ( ) ; } processCameraProvider = null ; camera = null ; barcodeScannerInstance = null ; scanSettings = null ; } public void readBarcodesFromImage ( String path , ScanSettings scanSettings , ReadBarcodesFromImageResultCallback callback ) throws Exception { InputImage inputImage ; try { inputImage = InputImage . fromFilePath ( plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { throw new Exception ( BarcodeScannerPlugin . ERROR_LOAD_IMAGE_FAILED ) ; } BarcodeScannerOptions options = buildBarcodeScannerOptions ( scanSettings ) ; com . google . mlkit . vision . barcode . BarcodeScanner barcodeScannerInstance = BarcodeScanning . getClient ( options ) ; barcodeScannerInstance . process ( inputImage ) . addOnSuccessListener ( barcodes -> { callback . success ( barcodes ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void scan ( ScanSettings scanSettings , ScanResultCallback callback ) { GmsBarcodeScannerOptions options = buildGmsBarcodeScannerOptions ( scanSettings ) ; GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) , options ) ; scanner . startScan ( ) . addOnSuccessListener ( barcode -> { callback . success ( barcode ) ; } ) . addOnCanceledListener ( ( ) -> { callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void isGoogleBarcodeScannerModuleAvailable ( IsGoogleBarodeScannerModuleAvailableResultCallback callback ) { GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) ) ; ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . areModulesAvailable ( scanner ) . addOnSuccessListener ( response -> { boolean isAvailable = response . areModulesAvailable ( ) ; callback . success ( isAvailable ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void installGoogleBarcodeScannerModule ( InstallGoogleBarcodeScannerModuleResultCallback callback ) { GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) ) ; InstallStatusListener listener = new ModuleInstallProgressListener ( this ) ; ModuleInstallRequest moduleInstallRequest = ModuleInstallRequest . newBuilder ( ) . addApi ( scanner ) . setListener ( listener ) . build ( ) ; ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . installModules ( moduleInstallRequest ) . addOnSuccessListener ( moduleInstallResponse -> { if ( moduleInstallResponse . areModulesAlreadyInstalled ( ) ) { callback . error ( new Exception ( BarcodeScannerPlugin . ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED ) ) ; } else { callback . success ( ) ; } } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public boolean isSupported ( ) { return plugin . getContext ( ) . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_CAMERA_ANY ) ; } public void enableTorch ( ) { if ( camera == null ) { return ; } camera . getCameraControl ( ) . enableTorch ( true ) ; isTorchEnabled = true ; } public void disableTorch ( ) { if ( camera == null ) { return ; } camera . getCameraControl ( ) . enableTorch ( false ) ; isTorchEnabled = false ; } public void toggleTorch ( ) { if ( isTorchEnabled ) { disableTorch ( ) ; } else { enableTorch ( ) ; } } public boolean isTorchEnabled ( ) { return isTorchEnabled ; } public boolean isTorchAvailable ( ) { return plugin . getContext ( ) . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_CAMERA_FLASH ) ; } public void setZoomRatio ( SetZoomRatioOptions options ) { float zoomRatio = options . getZoomRatio ( ) ; if ( camera == null ) { return ; } camera . getCameraControl ( ) . setZoomRatio ( zoomRatio ) ; } @ Nullable public GetZoomRatioResult getZoomRatio ( ) { if ( camera == null ) { return null ; } float zoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getZoomRatio ( ) ; return new GetZoomRatioResult ( zoomRatio ) ; } @ Nullable public GetMinZoomRatioResult getMinZoomRatio ( ) { if ( camera == null ) { return null ; } float minZoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getMinZoomRatio ( ) ; return new GetMinZoomRatioResult ( minZoomRatio ) ; } @ Nullable public GetMaxZoomRatioResult getMaxZoomRatio ( ) { if ( camera == null ) { return null ; } float maxZoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getMaxZoomRatio ( ) ; return new GetMaxZoomRatioResult ( maxZoomRatio ) ; } public void openSettings ( PluginCall call ) { Uri uri = Uri . fromParts ( "<STR_LIT>" , plugin . getAppId ( ) , null ) ; Intent intent = new Intent ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS , uri ) ; plugin . startActivityForResult ( call , intent , "<STR_LIT>" ) ; } public PermissionState getCameraPermission ( ) { return plugin . getPermissionState ( BarcodeScannerPlugin . CAMERA ) ; } public void requestCameraPermission ( PluginCall call ) { plugin . requestPermissionForAlias ( BarcodeScannerPlugin . CAMERA , call , "<STR_LIT>" ) ; } public boolean requestCameraPermissionIfNotDetermined ( PluginCall call ) throws Exception { PermissionState state = getCameraPermission ( ) ; if ( state == PermissionState . GRANTED ) { return true ; } else if ( state == PermissionState . DENIED ) { throw new Exception ( BarcodeScannerPlugin . ERROR_PERMISSION_DENIED ) ; } else { requestCameraPermission ( call ) ; return false ; } } public boolean isCameraActive ( ) { return camera != null ; } @ Override public void analyze ( @ NonNull ImageProxy imageProxy ) { @ SuppressLint ( "<STR_LIT>" ) Image image = imageProxy . getImage ( ) ; if ( image == null || barcodeScannerInstance == null ) { return ; } InputImage inputImage = InputImage . fromMediaImage ( image , imageProxy . getImageInfo ( ) . getRotationDegrees ( ) ) ; Point imageSize = new Point ( inputImage . getWidth ( ) , inputImage . getHeight ( ) ) ; barcodeScannerInstance . process ( inputImage ) . addOnSuccessListener ( barcodes -> { if ( scanSettings == null ) { return ; } for ( Barcode barcode : barcodes ) { handleScannedBarcode ( barcode , imageSize ) ; } } ) . addOnFailureListener ( exception -> { handleScanError ( exception ) ; } ) . addOnCompleteListener ( task -> { imageProxy . close ( ) ; image . close ( ) ; } ) ; } public void handleGoogleBarcodeScannerModuleInstallProgress ( @ ModuleInstallStatusUpdate . InstallState int state , @ Nullable Integer progress ) { plugin . notifyGoogleBarcodeScannerModuleInstallProgressListener ( state , progress ) ; boolean isTerminateState = ModuleInstallProgressListener . isTerminateState ( state ) ; if ( isTerminateState && moduleInstallProgressListener != null ) { ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . unregisterListener ( moduleInstallProgressListener ) ; moduleInstallProgressListener = null ; } } private Point getDisplaySize ( ) { WindowManager wm = ( WindowManager ) plugin . getContext ( ) . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = wm . getDefaultDisplay ( ) ; Point size = new Point ( ) ; display . getRealSize ( size ) ; return size ; } private void hideWebViewBackground ( ) { plugin . getBridge ( ) . getWebView ( ) . setBackgroundColor ( Color . TRANSPARENT ) ; } private void showWebViewBackground ( ) { plugin . getBridge ( ) . getWebView ( ) . setBackgroundColor ( Color . WHITE ) ; } private void handleScannedBarcode ( Barcode barcode , Point imageSize ) { plugin . notifyBarcodeScannedListener ( barcode , imageSize ) ; } private void handleScanError ( Exception exception ) { plugin . notifyScanErrorListener ( exception . getMessage ( ) ) ; } private BarcodeScannerOptions buildBarcodeScannerOptions ( ScanSettings scanSettings ) { int [ ] formats = scanSettings . formats . length == <NUM_LIT> ? new int [ ] { Barcode . FORMAT_ALL_FORMATS } : scanSettings . formats ; BarcodeScannerOptions options = new BarcodeScannerOptions . Builder ( ) . setBarcodeFormats ( formats [ <NUM_LIT> ] , formats ) . build ( ) ; return options ; } private GmsBarcodeScannerOptions buildGmsBarcodeScannerOptions ( ScanSettings scanSettings ) { int [ ] formats = scanSettings . formats . length == <NUM_LIT> ? new int [ ] { Barcode . FORMAT_ALL_FORMATS } : scanSettings . formats ; GmsBarcodeScannerOptions options = new GmsBarcodeScannerOptions . Builder ( ) . setBarcodeFormats ( formats [ <NUM_LIT> ] , formats ) . build ( ) ; return options ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facedetection ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . FaceDetector ; import com . google . mlkit . vision . face . FaceDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageResult ; public class FaceDetection { @ NonNull private final FaceDetectionPlugin plugin ; public FaceDetection ( @ NonNull FaceDetectionPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ; int performanceMode = options . getPerformanceMode ( ) ; int landmarkMode = options . getLandmarkMode ( ) ; int contourMode = options . getContourMode ( ) ; int classificationMode = options . getClassificationMode ( ) ; float minFaceSize = options . getMinFaceSize ( ) ; boolean enableTracking = options . isTrackingEnabled ( ) ; FaceDetectorOptions . Builder builder = new FaceDetectorOptions . Builder ( ) ; builder . setPerformanceMode ( performanceMode ) ; builder . setLandmarkMode ( landmarkMode ) ; builder . setContourMode ( contourMode ) ; builder . setClassificationMode ( classificationMode ) ; builder . setMinFaceSize ( minFaceSize ) ; if ( enableTracking ) { builder . enableTracking ( ) ; } FaceDetectorOptions faceDetectorOptions = builder . build ( ) ; final FaceDetector faceDetector = com . google . mlkit . vision . face . FaceDetection . getClient ( faceDetectorOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> { faceDetector . process ( inputImage ) . addOnSuccessListener ( faces -> { faceDetector . close ( ) ; ProcessImageResult result = new ProcessImageResult ( faces ) ; callback . success ( result ) ; } ) . addOnCanceledListener ( ( ) -> { faceDetector . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { faceDetector . close ( ) ; callback . error ( exception ) ; } ) ; } ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes ; import android . graphics . PointF ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . face . Face ; import com . google . mlkit . vision . face . FaceContour ; import com . google . mlkit . vision . face . FaceLandmark ; import java . util . List ; public class ProcessImageResult { private List < Face > faces ; public ProcessImageResult ( List < Face > faces ) { this . faces = faces ; } public JSObject toJSObject ( ) { JSArray facesResult = this . createFacesResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , facesResult ) ; return result ; } private JSArray createFacesResult ( ) { JSArray result = new JSArray ( ) ; for ( Face face : faces ) { JSObject faceResult = this . createFaceResult ( face ) ; result . put ( faceResult ) ; } return result ; } private JSObject createFaceResult ( Face face ) { JSObject result = new JSObject ( ) ; Rect boundingBox = face . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( "<STR_LIT>" , boundsResult ) ; JSArray landmarksResult = new JSArray ( ) ; for ( FaceLandmark landmark : face . getAllLandmarks ( ) ) { JSObject landmarkResult = this . createLandmarkResult ( landmark ) ; landmarksResult . put ( landmarkResult ) ; } if ( landmarksResult . length ( ) > <NUM_LIT> ) { result . put ( "<STR_LIT>" , landmarksResult ) ; } JSArray contoursResult = new JSArray ( ) ; for ( FaceContour contour : face . getAllContours ( ) ) { List < PointF > points = contour . getPoints ( ) ; JSArray pointsResult = new JSArray ( ) ; for ( PointF point : points ) { JSObject positionResult = this . createPositionResult ( point ) ; pointsResult . put ( positionResult ) ; } if ( pointsResult . length ( ) > <NUM_LIT> ) { JSObject contourResult = this . createContourResult ( contour , pointsResult ) ; contoursResult . put ( contourResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( "<STR_LIT>" , contoursResult ) ; } Integer trackingId = face . getTrackingId ( ) ; if ( trackingId != null ) { result . put ( "<STR_LIT>" , trackingId ) ; } result . put ( "<STR_LIT>" , face . getHeadEulerAngleX ( ) ) ; result . put ( "<STR_LIT>" , face . getHeadEulerAngleY ( ) ) ; result . put ( "<STR_LIT>" , face . getHeadEulerAngleZ ( ) ) ; Float smilingProbability = face . getSmilingProbability ( ) ; if ( smilingProbability != null ) { result . put ( "<STR_LIT>" , smilingProbability ) ; } Float leftEyeOpenProbability = face . getLeftEyeOpenProbability ( ) ; if ( leftEyeOpenProbability != null ) { result . put ( "<STR_LIT>" , leftEyeOpenProbability ) ; } Float rightEyeOpenProbability = face . getRightEyeOpenProbability ( ) ; if ( rightEyeOpenProbability != null ) { result . put ( "<STR_LIT>" , rightEyeOpenProbability ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , boundingBox . left ) ; result . put ( "<STR_LIT>" , boundingBox . top ) ; result . put ( "<STR_LIT>" , boundingBox . right ) ; result . put ( "<STR_LIT>" , boundingBox . bottom ) ; return result ; } private JSObject createLandmarkResult ( FaceLandmark landmark ) { JSObject positionResult = this . createPositionResult ( landmark . getPosition ( ) ) ; JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , landmark . getLandmarkType ( ) ) ; result . put ( "<STR_LIT>" , positionResult ) ; return result ; } private JSObject createPositionResult ( PointF point ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , point . x ) ; result . put ( "<STR_LIT>" , point . y ) ; return result ; } private JSObject createContourResult ( FaceContour contour , JSArray pointsResult ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , contour . getFaceContourType ( ) ) ; result . put ( "<STR_LIT>" , pointsResult ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import com . google . mlkit . vision . barcode . common . Barcode ; public interface ScanResultCallback { void success ( Barcode barcode ) ; void cancel ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options ; public class SetZoomRatioOptions { private float zoomRatio ; public SetZoomRatioOptions ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public float getZoomRatio ( ) { return zoomRatio ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class SelfieSegmentationPlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = "<STR_LIT>" ; public static final String ERROR_PATH_MISSING = "<STR_LIT>" ; public static final String ERROR_LOAD_IMAGE_FAILED = "<STR_LIT>" ; public static final float CONFIDENCE = <NUM_LIT> ; private SelfieSegmentation implementation ; @ Override public void load ( ) { try { implementation = new SelfieSegmentation ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( "<STR_LIT>" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer width = call . getInt ( "<STR_LIT>" , null ) ; Integer height = call . getInt ( "<STR_LIT>" , null ) ; Float confidence = call . getFloat ( "<STR_LIT>" , CONFIDENCE ) ; InputImage image = implementation . createInputImageFromFilePath ( path ) ; if ( image == null ) { call . reject ( ERROR_LOAD_IMAGE_FAILED ) ; return ; } ProcessImageOptions options = new ProcessImageOptions ( image , width , height , confidence ) ; implementation . processImage ( options , new ProcessImageResultCallback ( ) { @ Override public void success ( ProcessImageResult result ) { try { call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } @ Override public void cancel ( ) { call . reject ( ERROR_PROCESS_IMAGE_CANCELED ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces . Result ; public class GetZoomRatioResult implements Result { private float zoomRatio ; public GetZoomRatioResult ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , zoomRatio ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_CANCELED ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_COMPLETED ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_FAILED ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . gms . common . moduleinstall . InstallStatusListener ; import com . google . android . gms . common . moduleinstall . ModuleInstall ; import com . google . android . gms . common . moduleinstall . ModuleInstallClient ; import com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate ; public class ModuleInstallProgressListener implements InstallStatusListener { @ NonNull private final BarcodeScanner implementation ; public ModuleInstallProgressListener ( BarcodeScanner implementation ) { this . implementation = implementation ; } public static boolean isTerminateState ( @ ModuleInstallStatusUpdate . InstallState int state ) { return state == STATE_CANCELED || state == STATE_COMPLETED || state == STATE_FAILED ; } @ Override public void onInstallStatusUpdated ( ModuleInstallStatusUpdate update ) { ModuleInstallStatusUpdate . ProgressInfo progressInfo = update . getProgressInfo ( ) ; @ ModuleInstallStatusUpdate . InstallState int state = update . getInstallState ( ) ; Integer progress = null ; if ( progressInfo != null ) { progress = ( int ) ( <NUM_LIT> * ( progressInfo . getBytesDownloaded ( ) / progressInfo . getTotalBytesToDownload ( ) ) ) ; } implementation . handleGoogleBarcodeScannerModuleInstallProgress ( state , progress ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface InstallGoogleBarcodeScannerModuleResultCallback { void success ( ) ; void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . mlkit . translation ; import com . google . mlkit . nl . translate . TranslateRemoteModel ; import java . util . Set ; public interface GetDownloadedModelsResultCallback { void success ( Set < TranslateRemoteModel > models ) ; void error ( Exception exception ) ; } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) public @ interface Field { int STATIC = <NUM_LIT> ; int OBJECT = <NUM_LIT> ; int ANY = - <NUM_LIT> ; String value ( ) default "<STR_LIT>" ; int type ( ) default OBJECT ; } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( "<STR_LIT>" ) public interface IVMRuntime { @ Method ( value = "<STR_LIT>" , type = Method . STATIC ) Object getRuntime ( ) ; @ Method ( value = "<STR_LIT>" ) boolean is64Bit ( ) ; @ Method ( value = "<STR_LIT>" , type = Method . STATIC ) String getCurrentInstructionSet ( ) ; } </s>
<s> package com . norman . webviewup . lib ; public interface UpgradeCallback { void onUpgradeProcess ( float percent ) ; void onUpgradeComplete ( ) ; void onUpgradeError ( Throwable throwable ) ; } </s>
<s> package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . FileUtils ; import com . norman . webviewup . lib . util . HandlerUtils ; import java . util . HashSet ; public abstract class UpgradeSource { private final HashSet < OnPrepareCallback > prepareCallbackSet = new HashSet < > ( ) ; private final Context context ; private boolean success ; private boolean running ; private Throwable errorThrowable ; public UpgradeSource ( @ NonNull Context context ) { this . context = context . getApplicationContext ( ) ; } public synchronized boolean isSuccess ( ) { return success ; } public synchronized boolean isProcess ( ) { return running ; } public synchronized final Throwable getError ( ) { return errorThrowable ; } public synchronized void prepare ( OnPrepareCallback prepareCallback ) { prepare ( prepareCallback , null ) ; } public synchronized void prepare ( OnPrepareCallback prepareCallback , Object params ) { if ( isSuccess ( ) ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareSuccess ( this ) ; } ) ; } else if ( errorThrowable != null ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareError ( this , errorThrowable ) ; } ) ; } else { prepareCallbackSet . add ( prepareCallback ) ; if ( ! running ) { running = true ; try { onPrepare ( params ) ; } catch ( Throwable throwable ) { error ( throwable ) ; } } } } protected abstract void onPrepare ( Object params ) ; protected synchronized final void success ( ) { if ( success || errorThrowable != null ) { return ; } success = true ; running = false ; onSuccess ( ) ; for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareSuccess ( this ) ; } ) ; } prepareCallbackSet . clear ( ) ; } protected synchronized final void error ( @ NonNull Throwable throwable ) { if ( isSuccess ( ) || errorThrowable != null ) { return ; } errorThrowable = throwable ; running = false ; for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareError ( this , throwable ) ; } ) ; } prepareCallbackSet . clear ( ) ; onError ( throwable ) ; } protected synchronized final void process ( float percent ) { if ( isSuccess ( ) || errorThrowable != null ) { return ; } for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareProcess ( this , percent ) ; } ) ; } onProcess ( percent ) ; } protected void onSuccess ( ) { } protected void onError ( Throwable throwable ) { } protected void onProcess ( float percent ) { } public Context getContext ( ) { return context ; } public interface OnPrepareCallback { void onPrepareSuccess ( UpgradeSource webViewSource ) ; void onPrepareProcess ( UpgradeSource webViewSource , float percent ) ; void onPrepareError ( UpgradeSource webViewSource , Throwable throwable ) ; } } </s>
<s> package com . norman . webviewup . lib ; import android . content . Context ; import android . content . pm . ApplicationInfo ; import android . content . pm . PackageInfo ; import android . os . Build ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Looper ; import android . text . TextUtils ; import android . webkit . WebView ; import com . norman . webviewup . lib . hook . PackageManagerServiceHook ; import com . norman . webviewup . lib . hook . WebViewUpdateServiceHook ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewFactory ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . util . FileUtils ; public class WebViewReplace { private static PackageInfo SYSTEM_WEB_VIEW_PACKAGE_INFO ; private static PackageInfo REPLACE_WEB_VIEW_PACKAGE_INFO ; public synchronized static void replace ( Context context , String apkPath , String libsPath ) throws WebViewReplaceException { PackageManagerServiceHook managerHook = null ; WebViewUpdateServiceHook updateServiceHook = null ; try { if ( context == null ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } if ( ! FileUtils . existFile ( apkPath ) ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } if ( Looper . myLooper ( ) != Looper . getMainLooper ( ) ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } PackageInfo packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , <NUM_LIT> ) ; if ( packageInfo == null ) { throw new WebViewReplaceException ( apkPath + "<STR_LIT>" ) ; } int sdkVersion = Build . VERSION . SDK_INT ; ApplicationInfo applicationInfo = packageInfo . applicationInfo ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { if ( sdkVersion < applicationInfo . minSdkVersion ) { throw new WebViewReplaceException ( "<STR_LIT>" + sdkVersion + "<STR_LIT>" + applicationInfo . minSdkVersion + "<STR_LIT>" + apkPath ) ; } } managerHook = new PackageManagerServiceHook ( context , packageInfo . packageName , apkPath , libsPath ) ; updateServiceHook = new WebViewUpdateServiceHook ( context , packageInfo . packageName ) ; managerHook . hook ( ) ; updateServiceHook . hook ( ) ; if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } checkWebView ( context ) ; REPLACE_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } catch ( Throwable throwable ) { if ( throwable instanceof WebViewReplaceException ) { throw throwable ; } else { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = "<STR_LIT>" ; } throw new WebViewReplaceException ( message , throwable ) ; } } finally { try { if ( managerHook != null ) { managerHook . restore ( ) ; } if ( updateServiceHook != null ) { updateServiceHook . restore ( ) ; } } catch ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = "<STR_LIT>" ; } throw new WebViewReplaceException ( message , throwable ) ; } } } public synchronized static void replace ( Context context , PackageInfo packageInfo ) throws WebViewReplaceException { WebViewUpdateServiceHook updateServiceHook = null ; try { if ( context == null ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } if ( packageInfo == null ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } if ( Looper . myLooper ( ) != Looper . getMainLooper ( ) ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } updateServiceHook = new WebViewUpdateServiceHook ( context , packageInfo . packageName ) ; updateServiceHook . hook ( ) ; if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } checkWebView ( context ) ; REPLACE_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } catch ( Throwable throwable ) { if ( throwable instanceof WebViewReplaceException ) { throw throwable ; } else { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = "<STR_LIT>" ; } throw new WebViewReplaceException ( message , throwable ) ; } } finally { try { if ( updateServiceHook != null ) { updateServiceHook . restore ( ) ; } } catch ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = "<STR_LIT>" ; } throw new WebViewReplaceException ( message , throwable ) ; } } } public synchronized static String getSystemWebViewPackageName ( ) { if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } return SYSTEM_WEB_VIEW_PACKAGE_INFO != null ? SYSTEM_WEB_VIEW_PACKAGE_INFO . packageName : null ; } public synchronized static String getSystemWebViewPackageVersion ( ) { if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } return SYSTEM_WEB_VIEW_PACKAGE_INFO != null ? SYSTEM_WEB_VIEW_PACKAGE_INFO . versionName : null ; } public synchronized static String getReplaceWebViewPackageName ( ) { return REPLACE_WEB_VIEW_PACKAGE_INFO != null ? REPLACE_WEB_VIEW_PACKAGE_INFO . packageName : null ; } public synchronized static String getReplaceWebViewVersion ( ) { return REPLACE_WEB_VIEW_PACKAGE_INFO != null ? REPLACE_WEB_VIEW_PACKAGE_INFO . versionName : null ; } private static void checkWebView ( Context context ) throws WebViewReplaceException { IWebViewFactory webViewFactory = RuntimeAccess . staticAccess ( IWebViewFactory . class ) ; Object providerInstance = webViewFactory . getProviderInstance ( ) ; if ( providerInstance != null ) { throw new WebViewReplaceException ( "<STR_LIT>" ) ; } new WebView ( context ) ; } private static PackageInfo loadCurrentWebViewPackageInfo ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { try { return WebView . getCurrentWebViewPackage ( ) ; } catch ( Throwable ignore ) { } } try { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IBinder binder = serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IInterface iInterface = service . asInterface ( binder ) ; service = RuntimeAccess . objectAccess ( IWebViewUpdateService . class , iInterface ) ; return service . getCurrentWebViewPackage ( ) ; } catch ( Throwable ignore ) { } return null ; } } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) public @ interface Constructor { } </s>
<s> package com . norman . webviewup . demo ; import android . app . Activity ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . text . TextUtils ; import android . util . Log ; import android . view . View ; import android . webkit . WebView ; import android . widget . ProgressBar ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import com . norman . webviewup . lib . UpgradeCallback ; import com . norman . webviewup . lib . WebViewUpgrade ; import com . norman . webviewup . lib . source . UpgradeAssetSource ; import com . norman . webviewup . lib . source . UpgradePackageSource ; import com . norman . webviewup . lib . source . UpgradeSource ; import com . norman . webviewup . lib . source . download . UpgradeDownloadSource ; import com . norman . webviewup . lib . util . ProcessUtils ; import com . norman . webviewup . lib . util . VersionUtils ; import java . io . File ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class MainActivity extends Activity implements UpgradeCallback { private static final Map < String , List < UpgradeInfo > > UPGRADE_PACKAGE_MAP = new HashMap < > ( ) ; static { UPGRADE_PACKAGE_MAP . put ( "<STR_LIT>" , Arrays . asList ( new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) , new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ) ; UPGRADE_PACKAGE_MAP . put ( "<STR_LIT>" , Arrays . asList ( new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ) ; UPGRADE_PACKAGE_MAP . put ( "<STR_LIT>" , Arrays . asList ( new UpgradeInfo ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ) ; } ProgressBar progressBar ; TextView systemWebViewPackageTextView ; TextView upgradeWebViewPackageTextView ; TextView upgradeStatusTextView ; TextView upgradeErrorTextView ; TextView upgradeProgressTextView ; UpgradeInfo selectUpgradeInfo ; protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; WebViewUpgrade . addUpgradeCallback ( this ) ; progressBar = findViewById ( R . id . upgradeProgressBar ) ; systemWebViewPackageTextView = findViewById ( R . id . systemWebViewPackageTextView ) ; upgradeWebViewPackageTextView = findViewById ( R . id . upgradeWebViewPackageTextView ) ; upgradeStatusTextView = findViewById ( R . id . upgradeStatusTextView ) ; upgradeErrorTextView = findViewById ( R . id . upgradeErrorTextView ) ; upgradeProgressTextView = findViewById ( R . id . upgradeProgressTextView ) ; updateSystemWebViewPackageInfo ( ) ; updateSystemWebViewPackageInfo ( ) ; updateUpgradeWebViewStatus ( ) ; findViewById ( R . id . upgradeButton ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { showChooseWebViewDialog ( ) ; } } ) ; findViewById ( R . id . webViewButton ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { startActivity ( new Intent ( MainActivity . this , WebViewActivity . class ) ) ; } } ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; WebViewUpgrade . removeUpgradeCallback ( this ) ; } @ Override public void onUpgradeProcess ( float percent ) { updateUpgradeWebViewStatus ( ) ; } @ Override public void onUpgradeComplete ( ) { updateUpgradeWebViewStatus ( ) ; Toast . makeText ( getApplicationContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onUpgradeError ( Throwable throwable ) { Toast . makeText ( getApplicationContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; Log . e ( "<STR_LIT>" , "<STR_LIT>" + throwable . getMessage ( ) + "<STR_LIT>" + Log . getStackTraceString ( throwable ) ) ; updateUpgradeWebViewStatus ( ) ; } private void showChooseWebViewDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( "<STR_LIT>" ) ; List < UpgradeInfo > upgradeInfoList = UPGRADE_PACKAGE_MAP . get ( ProcessUtils . getCurrentInstruction ( ) ) ; String [ ] items = new String [ upgradeInfoList . size ( ) ] ; for ( int i = <NUM_LIT> ; i < items . length ; i ++ ) { items [ i ] = upgradeInfoList . get ( i ) . title ; } builder . setItems ( items , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( WebViewUpgrade . isProcessing ( ) ) { Toast . makeText ( getApplicationContext ( ) , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } else if ( WebViewUpgrade . isCompleted ( ) ) { Toast . makeText ( getApplicationContext ( ) , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } else { UpgradeInfo upgradeInfo = upgradeInfoList . get ( which ) ; String systemWebViewPackageName = WebViewUpgrade . getSystemWebViewPackageName ( ) ; if ( systemWebViewPackageName != null && systemWebViewPackageName . equals ( upgradeInfo . packageName ) && VersionUtils . compareVersion ( WebViewUpgrade . getSystemWebViewPackageVersion ( ) , upgradeInfo . versionName ) >= <NUM_LIT> ) { Toast . makeText ( getApplicationContext ( ) , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; return ; } selectUpgradeInfo = upgradeInfo ; UpgradeSource upgradeSource = getUpgradeSource ( upgradeInfo ) ; if ( upgradeSource == null ) { return ; } WebViewUpgrade . upgrade ( upgradeSource ) ; updateUpgradeWebViewPackageInfo ( ) ; updateUpgradeWebViewStatus ( ) ; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } @ Nullable private UpgradeSource getUpgradeSource ( UpgradeInfo upgradeInfo ) { UpgradeSource upgradeSource = null ; if ( upgradeInfo . extraInfo . equals ( "<STR_LIT>" ) ) { upgradeSource = new UpgradeDownloadSource ( getApplicationContext ( ) , upgradeInfo . url , new File ( getApplicationContext ( ) . getFilesDir ( ) , upgradeInfo . packageName + "<STR_LIT>" + upgradeInfo . versionName + "<STR_LIT>" ) ) ; } else if ( upgradeInfo . extraInfo . equals ( "<STR_LIT>" ) ) { upgradeSource = new UpgradeAssetSource ( getApplicationContext ( ) , upgradeInfo . url , new File ( getApplicationContext ( ) . getFilesDir ( ) , upgradeInfo . packageName + "<STR_LIT>" + upgradeInfo . versionName + "<STR_LIT>" ) ) ; } else if ( upgradeInfo . extraInfo . equals ( "<STR_LIT>" ) ) { upgradeSource = new UpgradePackageSource ( getApplicationContext ( ) , upgradeInfo . packageName ) ; } return upgradeSource ; } private void updateSystemWebViewPackageInfo ( ) { String systemWebViewPackageName = WebViewUpgrade . getSystemWebViewPackageName ( ) ; String systemWebViewPackageVersion = WebViewUpgrade . getSystemWebViewPackageVersion ( ) ; String systemWebViewPackageInfo = "<STR_LIT>" ; if ( ! TextUtils . isEmpty ( systemWebViewPackageName ) || ! TextUtils . isEmpty ( systemWebViewPackageVersion ) ) { systemWebViewPackageInfo = ( ! TextUtils . isEmpty ( systemWebViewPackageName ) ? systemWebViewPackageName : "<STR_LIT>" ) + "<STR_LIT>" + ( ! TextUtils . isEmpty ( systemWebViewPackageVersion ) ? systemWebViewPackageVersion : "<STR_LIT>" ) ; } systemWebViewPackageTextView . setText ( systemWebViewPackageInfo ) ; } private void updateUpgradeWebViewPackageInfo ( ) { String upgradeWebViewPackageName = selectUpgradeInfo != null ? selectUpgradeInfo . packageName : null ; String upgradeWebViewPackageVersion = selectUpgradeInfo != null ? selectUpgradeInfo . versionName : null ; String upgradeWebViewPackageInfo = "<STR_LIT>" ; if ( ! TextUtils . isEmpty ( upgradeWebViewPackageName ) || ! TextUtils . isEmpty ( upgradeWebViewPackageVersion ) ) { upgradeWebViewPackageInfo = ( ! TextUtils . isEmpty ( upgradeWebViewPackageName ) ? upgradeWebViewPackageName : "<STR_LIT>" ) + "<STR_LIT>" + ( ! TextUtils . isEmpty ( upgradeWebViewPackageVersion ) ? upgradeWebViewPackageVersion : "<STR_LIT>" ) ; } else { upgradeWebViewPackageInfo = "<STR_LIT>" ; } upgradeWebViewPackageTextView . setText ( upgradeWebViewPackageInfo ) ; } private void updateUpgradeWebViewStatus ( ) { if ( WebViewUpgrade . isProcessing ( ) ) { upgradeStatusTextView . setText ( "<STR_LIT>" ) ; } else if ( WebViewUpgrade . isFailed ( ) ) { upgradeStatusTextView . setText ( "<STR_LIT>" ) ; } else if ( WebViewUpgrade . isCompleted ( ) ) { upgradeStatusTextView . setText ( "<STR_LIT>" ) ; } else { upgradeStatusTextView . setText ( "<STR_LIT>" ) ; } int process = ( int ) ( WebViewUpgrade . getUpgradeProcess ( ) * <NUM_LIT> ) ; progressBar . setProgress ( process ) ; upgradeProgressTextView . setText ( process + "<STR_LIT>" ) ; Throwable throwable = WebViewUpgrade . getUpgradeError ( ) ; if ( throwable == null ) { upgradeErrorTextView . setText ( "<STR_LIT>" ) ; } else { upgradeErrorTextView . setText ( "<STR_LIT>" + throwable . getMessage ( ) + "<STR_LIT>" + Log . getStackTraceString ( throwable ) ) ; } } static class UpgradeInfo { public UpgradeInfo ( String packageName , String versionName , String url , String extraInfo ) { this . title = packageName + "<STR_LIT>" + versionName ; this . extraInfo = ! TextUtils . isEmpty ( extraInfo ) ? extraInfo : "<STR_LIT>" ; if ( ! extraInfo . isEmpty ( ) ) { this . title = this . title + "<STR_LIT>" + extraInfo ; } this . url = url ; this . packageName = packageName ; this . versionName = versionName ; } public UpgradeInfo ( String packageName , String versionName , String url ) { this ( packageName , versionName , url , "<STR_LIT>" ) ; } String title ; String url ; String packageName ; String versionName ; String extraInfo ; } } </s>
<s> package com . norman . webviewup . demo ; import android . app . Application ; public class MyApp extends Application { @ Override public void onCreate ( ) { super . onCreate ( ) ; } } </s>
<s> package com . norman . webviewup . lib ; public class WebViewReplaceException extends Exception { public WebViewReplaceException ( String message ) { super ( message ) ; } public WebViewReplaceException ( String message , Throwable cause ) { super ( message , cause ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } } </s>
<s> package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; class ReflectField { private final Object mFiledLock = new Object ( ) ; private String mName ; private String mClassName ; private Class < ? > mClass ; private Object mObject ; private Field mFiled ; private Field assessfield ; private int staticType ; public ReflectField ( Field field ) { this ( null , field ) ; } public ReflectField ( Object object , Field field ) { this . mFiled = field ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public ReflectField ( String className , String name ) { this . mName = name ; this . mClassName = className ; } public ReflectField ( Class < ? > cls , String name ) { this . mName = name ; this . mClass = cls ; } public ReflectField ( Object object , String name ) { this . mName = name ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public void setStaticType ( int staticValue ) { this . staticType = staticValue ; } public void set ( Object value ) throws ReflectException { synchronized ( mFiledLock ) { prepareFiled ( ) ; try { assessfield . set ( mObject , value ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public Object get ( ) throws ReflectException { synchronized ( mFiledLock ) { prepareFiled ( ) ; try { return assessfield . get ( mObject ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareFiled ( ) throws ReflectException { synchronized ( mFiledLock ) { try { if ( assessfield != null ) { return ; } Field findFiled = mFiled ; if ( findFiled == null ) { String className = null ; String filedName = mName ; if ( ! TextUtils . isEmpty ( mName ) ) { int lastDotIndex = mName . lastIndexOf ( "<STR_LIT>" ) ; if ( lastDotIndex >= <NUM_LIT> && lastDotIndex < mName . length ( ) - <NUM_LIT> ) { className = mName . substring ( <NUM_LIT> , lastDotIndex ) ; filedName = mName . substring ( lastDotIndex + <NUM_LIT> ) ; } } if ( className != null ) { try { Class < ? > relfectClass = Class . forName ( className ) ; findFiled = findField ( relfectClass , filedName ) ; } catch ( Throwable ignore ) { } } if ( findFiled == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } findFiled = findField ( findClass , filedName ) ; } } if ( findFiled == null ) { throw new NoSuchFieldException ( "<STR_LIT>" + mName ) ; } int modifiers = findFiled . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findFiled . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findFiled . isAccessible ( ) ) { findFiled . setAccessible ( true ) ; } } if ( Modifier . isFinal ( modifiers ) ) { try { Field modifiersField = Field . class . getDeclaredField ( "<STR_LIT>" ) ; if ( ! modifiersField . isAccessible ( ) ) { modifiersField . setAccessible ( true ) ; } modifiersField . setInt ( findFiled , modifiers & ~ Modifier . FINAL ) ; } catch ( Throwable ignore ) { } try { Field modifiersField = Field . class . getDeclaredField ( "<STR_LIT>" ) ; if ( ! modifiersField . isAccessible ( ) ) { modifiersField . setAccessible ( true ) ; } modifiersField . setInt ( findFiled , modifiers & ~ Modifier . FINAL ) ; } catch ( Throwable ignore ) { } } assessfield = findFiled ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private Field findField ( Class < ? > findClass , String filedName ) { for ( Class < ? > clazz = findClass ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( filedName ) ; boolean staticModifiers = Modifier . isStatic ( field . getModifiers ( ) ) ; if ( ( staticType == <NUM_LIT> && staticModifiers ) || ( staticType == <NUM_LIT> && ! staticModifiers ) ) { continue ; } return field ; } catch ( Exception ignore ) { } } return null ; } } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( "<STR_LIT>" ) public interface IApplicationInfo { @ Field ( "<STR_LIT>" ) void setPrimaryCpuAbi ( String cpuAbi ) ; @ Field ( "<STR_LIT>" ) void setNativeLibraryRootDir ( String nativeLibraryRootDir ) ; } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . TYPE ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { TYPE } ) @ Inherited public @ interface ClassType { Class < ? > value ( ) ; } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . PARAMETER ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { PARAMETER } ) public @ interface ParameterName { String value ( ) ; } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) @ Inherited public @ interface Method { int STATIC = <NUM_LIT> ; int OBJECT = <NUM_LIT> ; int ANY = - <NUM_LIT> ; String value ( ) default "<STR_LIT>" ; int type ( ) default OBJECT ; } </s>
<s> package com . norman . webviewup . lib . util ; public class VersionUtils { public static int compareVersion ( String version1 , String version2 ) { if ( version1 == null || version2 == null ) { return <NUM_LIT> ; } String [ ] versionArray1 = version1 . split ( "<STR_LIT>" ) ; String [ ] versionArray2 = version2 . split ( "<STR_LIT>" ) ; int idx = <NUM_LIT> ; int minLength = Math . min ( versionArray1 . length , versionArray2 . length ) ; int diff = <NUM_LIT> ; while ( idx < minLength && ( diff = versionArray1 [ idx ] . length ( ) - versionArray2 [ idx ] . length ( ) ) == <NUM_LIT> && ( diff = versionArray1 [ idx ] . compareTo ( versionArray2 [ idx ] ) ) == <NUM_LIT> ) { ++ idx ; } diff = ( diff != <NUM_LIT> ) ? diff : versionArray1 . length - versionArray2 . length ; return diff ; } } </s>
<s> package com . norman . webviewup . lib . util ; import android . os . Build ; import android . os . Process ; import android . util . Log ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . interfaces . IVMRuntime ; import java . lang . reflect . Method ; import java . util . Arrays ; public class ProcessUtils { private static String currentInstructionSet = null ; public static boolean is64Bit ( ) { boolean process64bit = false ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { process64bit = Process . is64Bit ( ) ; } else { try { IVMRuntime vmRuntime = RuntimeAccess . staticAccess ( IVMRuntime . class ) ; vmRuntime = RuntimeAccess . objectAccess ( IVMRuntime . class , vmRuntime . getRuntime ( ) ) ; process64bit = vmRuntime . is64Bit ( ) ; } catch ( Throwable ignore ) { } } return process64bit ; } public static String getCurrentInstruction ( ) { if ( currentInstructionSet != null ) { return currentInstructionSet ; } try { IVMRuntime ivmRuntime = RuntimeAccess . staticAccess ( IVMRuntime . class ) ; currentInstructionSet = ivmRuntime . getCurrentInstructionSet ( ) ; } catch ( Throwable throwable ) { String [ ] abiSearchArr = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; Arrays . sort ( abiSearchArr ) ; for ( String search : abiSearchArr ) { int result = Arrays . binarySearch ( Build . SUPPORTED_ABIS , search ) ; if ( result >= <NUM_LIT> ) { if ( search . equals ( "<STR_LIT>" ) || search . equals ( "<STR_LIT>" ) ) { currentInstructionSet = "<STR_LIT>" ; } else if ( search . equals ( "<STR_LIT>" ) ) { currentInstructionSet = "<STR_LIT>" ; } else { currentInstructionSet = search ; } break ; } } } return currentInstructionSet ; } } </s>
<s> package com . norman . webviewup . lib . service . proxy ; import com . norman . webviewup . lib . reflect . RuntimeProxy ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( value = "<STR_LIT>" ) public abstract class WebViewUpdateServiceProxy extends RuntimeProxy { public WebViewUpdateServiceProxy ( ) { super ( ) ; } @ Method ( "<STR_LIT>" ) protected abstract Object waitForAndGetProvider ( ) ; @ Method ( "<STR_LIT>" ) protected abstract android . os . IBinder asBinder ( ) ; @ Method ( "<STR_LIT>" ) protected abstract boolean isMultiProcessEnabled ( ) ; } </s>
<s> package com . norman . webviewup . lib . source . download ; import android . content . Context ; import com . arialyy . aria . core . Aria ; import com . arialyy . aria . core . AriaManager ; import com . arialyy . aria . core . config . DownloadConfig ; import com . arialyy . aria . core . download . DownloadEntity ; import com . arialyy . aria . core . download . DownloadReceiver ; import com . arialyy . aria . core . download . DownloadTaskListener ; import com . arialyy . aria . core . inf . IEntity ; import com . arialyy . aria . core . task . DownloadTask ; import com . norman . webviewup . lib . source . UpgradePathSource ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Objects ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class UpgradeDownloadSource extends UpgradePathSource implements DownloadTaskListener { public static final int MAX_DOWNLOAD_THREAD_NUM = <NUM_LIT> ; private final String url ; private final int threadNum ; private DownloadReceiver downloadReceiver ; private String tempPath ; private DownloadEntity downloadEntity ; public UpgradeDownloadSource ( Context context , String url , File file , int threadNum ) { super ( context , file . getPath ( ) ) ; this . url = url ; this . threadNum = threadNum ; } public UpgradeDownloadSource ( Context context , String url , File file ) { this ( context , url , file , MAX_DOWNLOAD_THREAD_NUM ) ; } @ Override protected void onPrepare ( Object params ) { AriaManager ariaManager = Aria . init ( getContext ( ) ) ; DownloadConfig downloadConfig = ariaManager . getDownloadConfig ( ) ; downloadConfig . setThreadNum ( threadNum ) ; downloadReceiver = Aria . download ( this ) ; downloadEntity = downloadReceiver . getFirstDownloadEntity ( url ) ; tempPath = getApkPath ( ) + "<STR_LIT>" ; this . downloadReceiver . register ( ) ; if ( downloadEntity == null || downloadEntity . getState ( ) == IEntity . STATE_CANCEL ) { FileUtils . createFile ( tempPath ) ; long taskId = downloadReceiver . load ( url ) . setFilePath ( tempPath ) . ignoreCheckPermissions ( ) . ignoreFilePathOccupy ( ) . create ( ) ; downloadEntity = downloadReceiver . getDownloadEntity ( taskId ) ; } else if ( downloadEntity . getState ( ) == IEntity . STATE_WAIT || downloadEntity . getState ( ) == IEntity . STATE_OTHER || downloadEntity . getState ( ) == IEntity . STATE_FAIL || downloadEntity . getState ( ) == IEntity . STATE_STOP ) { downloadReceiver . load ( downloadEntity . getId ( ) ) . ignoreCheckPermissions ( ) . resume ( ) ; } else if ( downloadEntity . getState ( ) == IEntity . STATE_COMPLETE ) { copyApk ( ) ; } } private void copyApk ( ) { new Thread ( ( ) -> { BufferedInputStream bufferedInput = null ; BufferedOutputStream bufferedOutput = null ; ZipFile zipFile = null ; try { if ( isValidApk ( tempPath ) ) { bufferedInput = new BufferedInputStream ( new FileInputStream ( tempPath ) ) ; } else { zipFile = new ZipFile ( tempPath ) ; bufferedInput = findStreamInZip ( zipFile ) ; } Objects . requireNonNull ( bufferedInput ) ; FileUtils . createFile ( getApkPath ( ) ) ; bufferedOutput = new BufferedOutputStream ( new FileOutputStream ( getApkPath ( ) ) ) ; copyBufferStream ( bufferedInput , bufferedOutput ) ; success ( ) ; deleteDownload ( ) ; } catch ( Throwable e ) { FileUtils . delete ( getApkPath ( ) ) ; error ( e ) ; } finally { try { if ( bufferedInput != null ) { bufferedInput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( bufferedOutput != null ) { bufferedOutput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( zipFile != null ) { zipFile . close ( ) ; } } catch ( IOException ignore ) { } } } ) . start ( ) ; } private BufferedInputStream findStreamInZip ( ZipFile zipFile ) throws IOException { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . endsWith ( "<STR_LIT>" ) ) { return new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; } } return null ; } private void copyBufferStream ( BufferedInputStream bufferedInput , BufferedOutputStream bufferedOutput ) throws IOException { int count ; int readCount = <NUM_LIT> ; int availableByteCount = bufferedInput . available ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( ( count = bufferedInput . read ( buffer ) ) > <NUM_LIT> ) { bufferedOutput . write ( buffer , <NUM_LIT> , count ) ; readCount = readCount + count ; process ( <NUM_LIT> * readCount / availableByteCount + <NUM_LIT> ) ; } bufferedOutput . flush ( ) ; } private void deleteDownload ( ) { try { downloadReceiver . load ( downloadEntity . getId ( ) ) . ignoreCheckPermissions ( ) . cancel ( true ) ; } catch ( Throwable ignore ) { } } @ Override public void onWait ( DownloadTask task ) { } @ Override public void onPre ( DownloadTask task ) { downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskPre ( DownloadTask task ) { } @ Override public void onTaskResume ( DownloadTask task ) { } @ Override public void onTaskStart ( DownloadTask task ) { } @ Override public void onTaskStop ( DownloadTask task ) { downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskCancel ( DownloadTask task ) { downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskFail ( DownloadTask task , Exception e ) { if ( e == null ) { error ( new RuntimeException ( "<STR_LIT>" ) ) ; } else { error ( e ) ; } } @ Override public void onTaskComplete ( DownloadTask task ) { copyApk ( ) ; } @ Override public void onTaskRunning ( DownloadTask task ) { float percent = task . getPercent ( ) / <NUM_LIT> * <NUM_LIT> ; process ( percent ) ; } @ Override public void onNoSupportBreakPoint ( DownloadTask task ) { } private boolean isValidApk ( String path ) { try { return getContext ( ) . getPackageManager ( ) . getPackageArchiveInfo ( path , <NUM_LIT> ) != null ; } catch ( Throwable ignore ) { } return false ; } } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . PARAMETER ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { PARAMETER } ) public @ interface ParameterType { Class < ? > value ( ) ; } </s>
<s> package com . norman . webviewup . lib . reflect ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; public class ReflectConstructor { private final Object mConstructorLock = new Object ( ) ; private String mClassName ; private Class < ? > mClass ; private Constructor < ? > mConstructor ; private Class < ? > [ ] mParameterTypes ; private Constructor < ? > assessConstructor ; public ReflectConstructor ( Constructor < ? > constructor ) { this . mConstructor = constructor ; this . mParameterTypes = constructor . getParameterTypes ( ) ; } public ReflectConstructor ( String className , Class < ? > ... parameterTypes ) { this . mClassName = className ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectConstructor ( Class < ? > cls , Class < ? > ... parameterTypes ) { this . mClass = cls ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectConstructor ( Object obj , Class < ? > ... parameterTypes ) { if ( obj != null ) { if ( obj instanceof Class < ? > ) { this . mClass = ( Class < ? > ) obj ; } else { this . mClass = obj . getClass ( ) ; } } this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public Object newInstance ( Object ... args ) throws ReflectException { synchronized ( mConstructorLock ) { prepareConstructor ( ) ; try { return assessConstructor . newInstance ( args ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareConstructor ( ) throws ReflectException { synchronized ( mConstructorLock ) { try { if ( assessConstructor != null ) { return ; } Constructor < ? > findConstructor = mConstructor ; if ( findConstructor == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } if ( findClass != null ) { findConstructor = findClass . getDeclaredConstructor ( mParameterTypes ) ; } } if ( findConstructor == null ) { throw new NoSuchMethodException ( "<STR_LIT>" ) ; } int modifiers = findConstructor . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findConstructor . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findConstructor . isAccessible ( ) ) { findConstructor . setAccessible ( true ) ; } } assessConstructor = findConstructor ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( "<STR_LIT>" ) public interface IWebViewFactory { @ Field ( value = "<STR_LIT>" , type = Field . STATIC ) Object getProviderLock ( ) ; @ Field ( value = "<STR_LIT>" , type = Field . STATIC ) Object getProviderInstance ( ) ; @ Field ( value = "<STR_LIT>" , type = Field . STATIC ) void setProviderInstance ( Object instance ) ; } </s>
<s> package com . norman . webviewup . lib . source ; import android . content . Context ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . File ; import java . io . IOException ; public class UpgradeFileSource extends UpgradePathSource { public UpgradeFileSource ( Context context , File file ) { super ( context , file . getPath ( ) ) ; } @ Override protected void onPrepare ( Object params ) { new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( ! FileUtils . existFile ( getApkPath ( ) ) ) { error ( new IOException ( "<STR_LIT>" + getApkPath ( ) ) ) ; } else { success ( ) ; } } } ) . start ( ) ; } } </s>
<s> package com . norman . webviewup . lib . hook ; import android . content . ComponentName ; import android . content . Context ; import android . content . ContextWrapper ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . IBinder ; import android . os . IInterface ; import android . os . RemoteException ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IActivityThread ; import com . norman . webviewup . lib . service . interfaces . IApplicationInfo ; import com . norman . webviewup . lib . service . interfaces . IContextImpl ; import com . norman . webviewup . lib . service . interfaces . IPackageManager ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . PackageManagerProxy ; import com . norman . webviewup . lib . util . FileUtils ; import com . norman . webviewup . lib . util . ProcessUtils ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . Arrays ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Map ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class PackageManagerServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; private final String apkPath ; private final String libsPath ; private Map < String , IBinder > binderCacheMap ; public PackageManagerServiceHook ( @ NonNull Context context , @ NonNull String packageName , @ NonNull String apkPath , @ NonNull String libsPath ) { this . context = context ; this . webViewPackageName = packageName ; this . apkPath = apkPath ; this . libsPath = libsPath ; } private final PackageManagerProxy proxy = new PackageManagerProxy ( ) { @ Override protected PackageInfo getPackageInfo ( String packageName , long flags , int userId ) { return getPackageInfo ( packageName , ( int ) flags ) ; } @ Override protected PackageInfo getPackageInfo ( String packageName , int flags , int userId ) { return getPackageInfo ( packageName , flags ) ; } @ Override protected int getComponentEnabledSetting ( ComponentName componentName , int userId ) { return getComponentEnabledSetting ( componentName ) ; } @ Override protected PackageInfo getPackageInfo ( String packageName , int flags ) { if ( packageName . equals ( webViewPackageName ) ) { PackageInfo packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , flags ) ; if ( packageInfo == null ) { flags &= ~ PackageManager . GET_SIGNATURES ; packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , flags ) ; } if ( packageInfo == null ) { throw new RuntimeException ( "<STR_LIT>" + apkPath ) ; } boolean is64Bit = ProcessUtils . is64Bit ( ) ; String [ ] supportBitAbis = is64Bit ? Build . SUPPORTED_64_BIT_ABIS : Build . SUPPORTED_32_BIT_ABIS ; Arrays . sort ( supportBitAbis , Collections . reverseOrder ( ) ) ; String nativeLibraryDir = null ; File libsDir = new File ( libsPath ) ; if ( ! FileUtils . exist ( libsDir ) ) { throw new RuntimeException ( "<STR_LIT>" + libsPath ) ; } String [ ] list = libsDir . list ( ) ; if ( list == null ) { throw new RuntimeException ( "<STR_LIT>" + libsPath ) ; } Arrays . sort ( supportBitAbis ) ; String cpuAbi = null ; for ( String name : list ) { if ( Arrays . binarySearch ( supportBitAbis , name ) >= <NUM_LIT> ) { cpuAbi = name ; nativeLibraryDir = new File ( libsDir , name ) . getAbsolutePath ( ) ; break ; } } if ( nativeLibraryDir == null ) { throw new NullPointerException ( "<STR_LIT>" + Arrays . toString ( supportBitAbis ) + "<STR_LIT>" + libsPath ) ; } try { IApplicationInfo iApplicationInfo = RuntimeAccess . objectAccess ( IApplicationInfo . class , packageInfo . applicationInfo ) ; iApplicationInfo . setPrimaryCpuAbi ( cpuAbi ) ; } catch ( Throwable ignore ) { } try { IApplicationInfo iApplicationInfo = RuntimeAccess . objectAccess ( IApplicationInfo . class , packageInfo . applicationInfo ) ; iApplicationInfo . setNativeLibraryRootDir ( libsPath ) ; } catch ( Throwable ignore ) { } packageInfo . applicationInfo . nativeLibraryDir = nativeLibraryDir ; if ( TextUtils . isEmpty ( packageInfo . applicationInfo . sourceDir ) ) { packageInfo . applicationInfo . sourceDir = apkPath ; } if ( TextUtils . isEmpty ( packageInfo . applicationInfo . publicSourceDir ) ) { packageInfo . applicationInfo . publicSourceDir = apkPath ; } return packageInfo ; } return ( PackageInfo ) invoke ( ) ; } @ Override protected int getComponentEnabledSetting ( ComponentName componentName ) { if ( componentName . getPackageName ( ) . equals ( webViewPackageName ) ) { return PackageManager . COMPONENT_ENABLED_STATE_DISABLED ; } else { return ( int ) invoke ( ) ; } } @ Override protected String getInstallerPackageName ( String packageName ) { if ( packageName . equals ( webViewPackageName ) ) { return "<STR_LIT>" ; } else { return ( String ) invoke ( ) ; } } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } } ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IPackageManager . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IPackageManager service = RuntimeAccess . staticAccess ( IPackageManager . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface targetInterface = service . asInterface ( binder ) ; proxy . setTarget ( targetInterface ) ; IInterface proxyInterface = ( IInterface ) proxy . get ( ) ; ProxyBinder proxyBinder = new ProxyBinder ( targetInterface , proxyInterface ) ; binderCacheMap = serviceManager . getServiceCache ( ) ; return proxyBinder ; } @ Override protected void onTargetBinderRestore ( IBinder binder ) { IInterface targetInterface ; try { targetInterface = binder . queryLocalInterface ( binder . getInterfaceDescriptor ( ) ) ; } catch ( RemoteException e ) { throw new RuntimeException ( e ) ; } binderCacheMap . put ( IPackageManager . SERVICE , binder ) ; updateActivityThreadPackageManager ( targetInterface ) ; flushContextImplPackageManager ( ) ; } @ Override protected void onProxyBinderReplace ( ProxyBinder binder ) { binderCacheMap . put ( IPackageManager . SERVICE , binder ) ; updateActivityThreadPackageManager ( binder . getProxyIInterface ( ) ) ; flushContextImplPackageManager ( ) ; } private static void updateActivityThreadPackageManager ( IInterface iInterface ) { IActivityThread activityThread = RuntimeAccess . staticAccess ( IActivityThread . class ) ; activityThread . setPackageManager ( iInterface ) ; } private void flushContextImplPackageManager ( ) { Context baseContext = context . getApplicationContext ( ) ; while ( baseContext instanceof ContextWrapper ) { baseContext = ( ( ContextWrapper ) context ) . getBaseContext ( ) ; } IContextImpl contextImpl = RuntimeAccess . objectAccess ( IContextImpl . class , baseContext ) ; contextImpl . setPackageManager ( null ) ; } } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import android . os . IBinder ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; import java . util . Map ; @ ClassName ( value = "<STR_LIT>" ) public interface IServiceManager { @ Method ( value = "<STR_LIT>" , type = Method . STATIC ) IBinder getService ( String name ) ; @ Field ( value = "<STR_LIT>" , type = Field . STATIC ) Map < String , IBinder > getServiceCache ( ) ; } </s>
<s> package com . norman . webviewup . lib ; import android . content . Context ; import androidx . test . platform . app . InstrumentationRegistry ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( "<STR_LIT>" , appContext . getPackageName ( ) ) ; } } </s>
<s> package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . res . AssetFileDescriptor ; import android . content . res . AssetManager ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . ApksUtils ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . channels . FileChannel ; public class UpgradeAssetSource extends UpgradePathSource { private final String assetName ; public UpgradeAssetSource ( Context context , @ NonNull String assetName , @ NonNull File file ) { super ( context , file . getPath ( ) ) ; this . assetName = assetName ; } private final Runnable copyAssetRunnable = new Runnable ( ) { @ Override public void run ( ) { FileOutputStream outputStream = null ; FileInputStream inputStream = null ; try { FileUtils . createFile ( getApkPath ( ) ) ; outputStream = new FileOutputStream ( getApkPath ( ) ) ; FileChannel dstChannel = outputStream . getChannel ( ) ; AssetManager assetManager = getContext ( ) . getAssets ( ) ; AssetFileDescriptor assetFileDescriptor = assetManager . openFd ( assetName ) ; inputStream = assetFileDescriptor . createInputStream ( ) ; FileChannel fileChannel = inputStream . getChannel ( ) ; long startOffset = assetFileDescriptor . getStartOffset ( ) ; long declaredLength = assetFileDescriptor . getDeclaredLength ( ) ; int size = <NUM_LIT> ; long partSize = ( long ) Math . ceil ( declaredLength * <NUM_LIT> / size ) ; long position = startOffset ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { long count = i != size - <NUM_LIT> ? partSize : declaredLength - i * partSize ; fileChannel . transferTo ( position , count , dstChannel ) ; process ( i * <NUM_LIT> / size ) ; position = position + count ; } success ( ) ; } catch ( Throwable e ) { FileUtils . delete ( getApkPath ( ) ) ; error ( e ) ; } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException ignore ) { } } if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ignore ) { } } } } } ; @ Override protected void onPrepare ( Object params ) { new Thread ( copyAssetRunnable ) . start ( ) ; } } </s>
<s> package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . ClassType ; import com . norman . webviewup . lib . reflect . annotation . Constructor ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; import com . norman . webviewup . lib . reflect . annotation . ParameterName ; import com . norman . webviewup . lib . reflect . annotation . ParameterType ; import java . lang . annotation . Annotation ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . ConcurrentHashMap ; public class RuntimeAccess < T > { private final static Map < Class < ? > , Object > STATIC_ACCESS_MAP = new ConcurrentHashMap < > ( ) ; private volatile Object assessObject ; private final Class < T > buildClass ; private T proxy ; private boolean staticAccess ; public RuntimeAccess ( Class < T > buildClass ) { this . buildClass = buildClass ; } public RuntimeAccess ( Class < T > buildClass , Object obj ) { this . buildClass = buildClass ; this . assessObject = obj ; } public void setAssessObject ( Object assessObject ) { this . assessObject = assessObject ; } public static < T > T staticAccess ( Class < T > buildClass ) { Object access = STATIC_ACCESS_MAP . get ( buildClass ) ; if ( access != null ) { return ( T ) access ; } RuntimeAccess < T > runtimeAccess = new RuntimeAccess < > ( buildClass ) ; access = runtimeAccess . get ( ) ; STATIC_ACCESS_MAP . put ( buildClass , access ) ; return ( T ) access ; } public static < T > T objectAccess ( Class < T > buildClass , Object object ) { RuntimeAccess < T > runtimeAccess = new RuntimeAccess < > ( buildClass , object ) ; return runtimeAccess . get ( ) ; } boolean isStaticAccess ( ) { return staticAccess ; } public T get ( ) throws ReflectException { try { if ( proxy != null ) { return proxy ; } if ( ! buildClass . isInterface ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } ClassType classTypeAnnotation = buildClass . getAnnotation ( ClassType . class ) ; ClassName classNameAnnotation = buildClass . getAnnotation ( ClassName . class ) ; Class < ? > annotationClass = null ; if ( classNameAnnotation != null ) { annotationClass = Class . forName ( classNameAnnotation . value ( ) ) ; } else if ( classTypeAnnotation != null ) { annotationClass = classTypeAnnotation . value ( ) ; } final Class < ? > reflectClass = annotationClass ; if ( reflectClass == null ) { throw new NullPointerException ( buildClass + "<STR_LIT>" + ClassType . class + "<STR_LIT>" + ClassName . class ) ; } ReflectProxy reflectProxy = new ReflectProxy ( buildClass ) ; boolean allStaticAnnotation = true ; for ( java . lang . reflect . Method method : buildClass . getMethods ( ) ) { Method methodAnnotation = method . getAnnotation ( Method . class ) ; Constructor constructorAnnotation = method . getAnnotation ( Constructor . class ) ; Field filedAnnotation = method . getAnnotation ( Field . class ) ; ReflectProxy . Invoke invoke = null ; if ( methodAnnotation != null ) { if ( methodAnnotation . type ( ) != Method . STATIC ) { allStaticAnnotation = false ; } invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { Class < ? > [ ] methodParameterTypes = findParameterTypes ( invokeContext ) ; String methodName = methodAnnotation . value ( ) ; if ( TextUtils . isEmpty ( methodName ) ) { methodName = invokeContext . getName ( ) ; } Object assessObj = checkAssessObject ( reflectClass ) ; ReflectMethod reflectMethod = new ReflectMethod ( reflectClass , methodName , methodParameterTypes ) ; if ( assessObj != null ) { reflectMethod = new ReflectMethod ( assessObj , methodName , methodParameterTypes ) ; } reflectMethod . setStaticType ( methodAnnotation . type ( ) ) ; Object result = reflectMethod . invoke ( invokeContext . args ) ; invokeContext . setResult ( result ) ; } } ; } else if ( constructorAnnotation != null ) { invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { Class < ? > [ ] constructorParameterTypes = findParameterTypes ( invokeContext ) ; ReflectConstructor reflectMethod = new ReflectConstructor ( reflectClass , constructorParameterTypes ) ; Object result = reflectMethod . newInstance ( invokeContext . args ) ; invokeContext . setResult ( result ) ; } } ; } else if ( filedAnnotation != null ) { if ( filedAnnotation . type ( ) != Field . STATIC ) { allStaticAnnotation = false ; } Class < ? > returnType = method . getReturnType ( ) ; if ( returnType == Void . TYPE && method . getParameterTypes ( ) . length == <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { String filedName = filedAnnotation . value ( ) ; if ( TextUtils . isEmpty ( filedName ) ) { filedName = invokeContext . getName ( ) ; } Object assessObj = checkAssessObject ( reflectClass ) ; ReflectField reflectField = new ReflectField ( reflectClass , filedName ) ; if ( assessObj != null ) { reflectField = new ReflectField ( assessObj , filedName ) ; } reflectField . setStaticType ( filedAnnotation . type ( ) ) ; Class < ? > returnType = method . getReturnType ( ) ; if ( returnType == Void . TYPE ) { reflectField . set ( invokeContext . args [ <NUM_LIT> ] ) ; invokeContext . setResult ( null ) ; } else { Object kkk = reflectField . get ( ) ; invokeContext . setResult ( kkk ) ; } } } ; } if ( invoke != null ) { reflectProxy . addInvoke ( invoke ) ; } } proxy = ( T ) reflectProxy . newProxyInstance ( ) ; staticAccess = allStaticAnnotation ; return proxy ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } private Object checkAssessObject ( Class < ? > reflectCls ) { Object obj = assessObject ; if ( obj != null && ! Objects . equals ( obj . getClass ( ) , reflectCls ) ) { throw new IllegalArgumentException ( reflectCls + "<STR_LIT>" + assessObject . getClass ( ) ) ; } return obj ; } @ NonNull private static Class < ? > [ ] findParameterTypes ( ReflectProxy . InvokeContext invokeContext ) { Annotation [ ] [ ] invokeAnnotations = invokeContext . getParameterAnnotations ( ) ; Class < ? > [ ] invokeTypes = invokeContext . getParameterTypes ( ) ; Class < ? > [ ] methodParameterTypes = new Class < ? > [ invokeTypes . length ] ; for ( int i = <NUM_LIT> ; i < methodParameterTypes . length ; i ++ ) { Annotation [ ] annotations = invokeAnnotations [ i ] ; ParameterName parameterNameAnnotation = null ; ParameterType parameterTypeAnnotation = null ; if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( annotation instanceof ParameterName ) { parameterNameAnnotation = ( ParameterName ) annotation ; break ; } else if ( annotation instanceof ParameterType ) { parameterTypeAnnotation = ( ParameterType ) annotation ; break ; } } } Class < ? > parameterClass = null ; if ( parameterNameAnnotation != null ) { String className = parameterNameAnnotation . value ( ) ; if ( ! TextUtils . isEmpty ( className ) ) { try { parameterClass = Class . forName ( className ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } else if ( parameterTypeAnnotation != null ) { parameterClass = parameterTypeAnnotation . value ( ) ; } if ( parameterClass == null ) { parameterClass = invokeTypes [ i ] ; } methodParameterTypes [ i ] = parameterClass ; } return methodParameterTypes ; } } </s>
<s> package com . norman . webviewup . lib . reflect ; import java . lang . reflect . InvocationTargetException ; public class ReflectException extends RuntimeException { public ReflectException ( String message , Throwable cause ) { super ( message , getCause ( cause ) ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } public ReflectException ( Throwable cause ) { super ( getCause ( cause ) ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } public ReflectException ( String message ) { super ( message ) ; } private static Throwable getCause ( Throwable throwable ) { if ( throwable instanceof InvocationTargetException ) { InvocationTargetException invocationTargetException = ( InvocationTargetException ) throwable ; Throwable cause = invocationTargetException . getCause ( ) ; if ( cause != null ) { return cause ; } else { return invocationTargetException ; } } return throwable instanceof ReflectException ? throwable . getCause ( ) : throwable ; } } </s>
<s> package com . norman . webviewup . lib ; import com . norman . webviewup . lib . source . UpgradePackageSource ; import com . norman . webviewup . lib . source . UpgradePathSource ; import com . norman . webviewup . lib . source . UpgradeSource ; import com . norman . webviewup . lib . util . HandlerUtils ; import java . util . HashSet ; import java . util . Set ; public class WebViewUpgrade { private static final Set < UpgradeCallback > UPGRADE_CALLBACK_SET = new HashSet < > ( ) ; private static final int STATUS_NEW = <NUM_LIT> ; private static final int STATUS_RUNNING = <NUM_LIT> ; private static final int STATUS_FAIL = <NUM_LIT> ; private static final int STATUS_COMPLETE = <NUM_LIT> ; private static int UPGRADE_STATUS = STATUS_NEW ; private static float UPGRADE_PROCESS ; private static Throwable UPGRADE_THROWABLE ; public synchronized static boolean isProcessing ( ) { return UPGRADE_STATUS == STATUS_RUNNING ; } public synchronized static boolean isCompleted ( ) { return UPGRADE_STATUS == STATUS_COMPLETE ; } public synchronized static boolean isFailed ( ) { return UPGRADE_STATUS == STATUS_FAIL ; } public synchronized static Throwable getUpgradeError ( ) { return UPGRADE_THROWABLE ; } public synchronized static float getUpgradeProcess ( ) { return UPGRADE_PROCESS ; } public synchronized static void addUpgradeCallback ( UpgradeCallback upgradeCallback ) { UPGRADE_CALLBACK_SET . add ( upgradeCallback ) ; } public synchronized static void removeUpgradeCallback ( UpgradeCallback upgradeCallback ) { UPGRADE_CALLBACK_SET . remove ( upgradeCallback ) ; } public static String getSystemWebViewPackageName ( ) { return WebViewReplace . getSystemWebViewPackageName ( ) ; } public static String getSystemWebViewPackageVersion ( ) { return WebViewReplace . getSystemWebViewPackageVersion ( ) ; } public static String getUpgradeWebViewPackageName ( ) { return WebViewReplace . getReplaceWebViewPackageName ( ) ; } public static String getUpgradeWebViewVersion ( ) { return WebViewReplace . getReplaceWebViewVersion ( ) ; } public synchronized static void upgrade ( UpgradeSource webViewSource ) { try { if ( UPGRADE_STATUS == STATUS_RUNNING || UPGRADE_STATUS == STATUS_COMPLETE ) { return ; } UPGRADE_STATUS = STATUS_RUNNING ; UPGRADE_THROWABLE = null ; UPGRADE_PROCESS = <NUM_LIT> ; webViewSource . prepare ( new UpgradeSource . OnPrepareCallback ( ) { @ Override public void onPrepareSuccess ( UpgradeSource webViewSource ) { HandlerUtils . runInMainThread ( ( ) -> { try { if ( webViewSource instanceof UpgradePathSource ) { UpgradePathSource upgradePathSource = ( UpgradePathSource ) webViewSource ; WebViewReplace . replace ( webViewSource . getContext ( ) , upgradePathSource . getApkPath ( ) , upgradePathSource . getLibsPath ( ) ) ; } else if ( webViewSource instanceof UpgradePackageSource ) { UpgradePackageSource upgradePackageSource = ( UpgradePackageSource ) webViewSource ; WebViewReplace . replace ( webViewSource . getContext ( ) , upgradePackageSource . getPackageInfo ( ) ) ; } callProcessCallback ( <NUM_LIT> ) ; callCompleteCallback ( ) ; } catch ( WebViewReplaceException e ) { callErrorCallback ( e ) ; } } ) ; } @ Override public void onPrepareProcess ( UpgradeSource webViewSource , float percent ) { callProcessCallback ( percent * <NUM_LIT> ) ; } @ Override public void onPrepareError ( UpgradeSource webViewSource , Throwable throwable ) { callErrorCallback ( throwable ) ; } } ) ; } catch ( Throwable throwable ) { callErrorCallback ( throwable ) ; } } private static void callErrorCallback ( Throwable throwable ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_STATUS = STATUS_FAIL ; UPGRADE_THROWABLE = throwable ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( ( ) -> upgradeCallback . onUpgradeError ( throwable ) ) ; } } } private static void callCompleteCallback ( ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_STATUS = STATUS_COMPLETE ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( upgradeCallback :: onUpgradeComplete ) ; } } } private static void callProcessCallback ( float percent ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_PROCESS = percent ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( ( ) -> upgradeCallback . onUpgradeProcess ( percent ) ) ; } } } } </s>
<s> package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . TYPE ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { TYPE } ) @ Inherited public @ interface ClassName { String value ( ) ; } </s>
<s> package com . norman . webviewup . lib . util ; import android . text . TextUtils ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class FileUtils { public static void delete ( String path ) { delete ( new File ( path ) ) ; } public static void delete ( File file ) { if ( file . isFile ( ) ) { file . delete ( ) ; return ; } if ( file . isDirectory ( ) ) { File [ ] childFile = file . listFiles ( ) ; if ( childFile == null || childFile . length == <NUM_LIT> ) { file . delete ( ) ; return ; } for ( File f : childFile ) { delete ( f ) ; } file . delete ( ) ; } } public static void cleanDirectory ( String path ) { cleanDirectory ( new File ( path ) ) ; } public static void cleanDirectory ( File file ) { if ( file . isDirectory ( ) ) { File [ ] childFile = file . listFiles ( ) ; if ( childFile == null || childFile . length == <NUM_LIT> ) { return ; } for ( File f : childFile ) { delete ( f ) ; } } } public static void makeDirectory ( String path ) { makeDirectory ( new File ( path ) ) ; } public static void makeDirectory ( File file ) { if ( file != null && ! file . exists ( ) ) { file . mkdirs ( ) ; } } public static void moveFile ( File srcFile , File outputFile ) { boolean rename = srcFile . renameTo ( outputFile ) ; if ( ! rename ) { copyFile ( srcFile , outputFile ) ; delete ( srcFile ) ; } } public static void copyFile ( File srcFile , File outputFile ) { FileInputStream fileInputStream ; try { fileInputStream = new FileInputStream ( srcFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( fileInputStream , outputFile , true ) ; } public static void copyFile ( String srcPath , String outputPath ) { copyFile ( new File ( srcPath ) , new File ( outputPath ) ) ; } public static void copyFile ( File srcFile , FileOutputStream fileOutputStream , boolean close ) { FileInputStream fileInputStream ; try { fileInputStream = new FileInputStream ( srcFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( fileInputStream , fileOutputStream , true , close ) ; } public static void copyFile ( InputStream inputStream , File outputFile , boolean close ) { FileUtils . makeDirectory ( outputFile . getParentFile ( ) ) ; if ( ! outputFile . exists ( ) ) { try { outputFile . createNewFile ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } FileOutputStream fileOutputStream ; try { fileOutputStream = new FileOutputStream ( outputFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( inputStream , fileOutputStream , close , true ) ; } public static void copyFile ( InputStream inputStream , OutputStream outputStream , boolean close ) { copyFile ( inputStream , outputStream , close , close ) ; } public static void copyFile ( InputStream inputStream , OutputStream outputStream , boolean inputClose , boolean outputClose ) { BufferedInputStream bufferedInput = null ; BufferedOutputStream bufferedOutput = null ; try { byte [ ] buffer = new byte [ <NUM_LIT> ] ; bufferedInput = new BufferedInputStream ( inputStream ) ; bufferedOutput = new BufferedOutputStream ( outputStream ) ; int count ; while ( ( count = bufferedInput . read ( buffer ) ) > <NUM_LIT> ) { bufferedOutput . write ( buffer , <NUM_LIT> , count ) ; } bufferedOutput . flush ( ) ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } finally { try { if ( inputClose && bufferedInput != null ) { bufferedInput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( outputClose && bufferedOutput != null ) { bufferedOutput . close ( ) ; } } catch ( IOException ignore ) { } } } public static boolean existDirectory ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isDirectory ( ) && file . exists ( ) ; } public static boolean existFile ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isFile ( ) && file . exists ( ) ; } public static boolean exist ( File file ) { if ( file == null ) { return false ; } return file . exists ( ) ; } public static boolean isNotEmpty ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isFile ( ) && file . exists ( ) && file . length ( ) != <NUM_LIT> ; } public static boolean createFile ( File file ) { if ( file != null && ! file . exists ( ) ) { makeDirectory ( file . getParentFile ( ) ) ; try { return file . createNewFile ( ) ; } catch ( IOException ignore ) { return false ; } } return true ; } public static boolean createFile ( String path ) { return createFile ( new File ( path ) ) ; } } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import android . content . pm . PackageInfo ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( value = "<STR_LIT>" ) public interface IWebViewProviderResponse { @ Field ( value = "<STR_LIT>" ) void setPackageInfo ( PackageInfo packageInfo ) ; @ Field ( value = "<STR_LIT>" ) PackageInfo getPackageInfo ( ) ; } </s>
<s> package com . norman . webviewup . lib . util ; import android . text . TextUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class ApksUtils { public static void extractNativeLibrary ( String apkPath , String libsDir ) { ZipFile zipFile = null ; try { if ( TextUtils . isEmpty ( apkPath ) ) { throw new NullPointerException ( "<STR_LIT>" ) ; } if ( TextUtils . isEmpty ( libsDir ) ) { throw new NullPointerException ( "<STR_LIT>" ) ; } zipFile = new ZipFile ( new File ( apkPath ) ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; List < ZipEntry > libsEntryList = new ArrayList < > ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . contains ( "<STR_LIT>" ) || entry . isDirectory ( ) ) { continue ; } if ( ! entryName . startsWith ( "<STR_LIT>" ) && ! entryName . endsWith ( "<STR_LIT>" ) ) { continue ; } libsEntryList . add ( entry ) ; } for ( ZipEntry zipEntry : libsEntryList ) { String [ ] split = zipEntry . getName ( ) . split ( "<STR_LIT>" ) ; File targetFile = new File ( libsDir , split [ <NUM_LIT> ] + "<STR_LIT>" + split [ split . length - <NUM_LIT> ] ) ; FileUtils . copyFile ( zipFile . getInputStream ( zipEntry ) , targetFile , true ) ; } } catch ( IOException ioException ) { FileUtils . cleanDirectory ( libsDir ) ; throw new RuntimeException ( ioException ) ; } finally { if ( zipFile != null ) { try { zipFile . close ( ) ; } catch ( IOException ignore ) { } } } } } </s>
<s> package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . ApksUtils ; import com . norman . webviewup . lib . util . FileUtils ; public abstract class UpgradePathSource extends UpgradeSource { private static final String PREFERENCE_NAME = "<STR_LIT>" ; private final SharedPreferences sharedPreferences ; private final String libsPath ; private final String path ; public UpgradePathSource ( @ NonNull Context context , String path ) { super ( context ) ; this . path = path ; this . libsPath = path + "<STR_LIT>" ; this . sharedPreferences = context . getSharedPreferences ( PREFERENCE_NAME , Context . MODE_PRIVATE ) ; } public synchronized void delete ( ) { this . sharedPreferences . edit ( ) . remove ( this . path ) . commit ( ) ; FileUtils . delete ( path ) ; FileUtils . delete ( this . libsPath ) ; } public String getApkPath ( ) { return path ; } public String getLibsPath ( ) { return libsPath ; } @ Override protected void onSuccess ( ) { super . onSuccess ( ) ; ApksUtils . extractNativeLibrary ( path , libsPath ) ; sharedPreferences . edit ( ) . putBoolean ( getApkPath ( ) , true ) . commit ( ) ; } @ Override public synchronized boolean isSuccess ( ) { if ( super . isSuccess ( ) ) { return true ; } if ( sharedPreferences . getBoolean ( getApkPath ( ) , false ) ) { if ( FileUtils . isNotEmpty ( getApkPath ( ) ) ) { success ( ) ; return true ; } sharedPreferences . edit ( ) . putBoolean ( getApkPath ( ) , false ) . commit ( ) ; } return false ; } } </s>
<s> package com . norman . webviewup . lib . service . binder ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . RemoteException ; import java . io . FileDescriptor ; public class ProxyBinder implements IBinder { private final IBinder mRemoteBinder ; private final IInterface mStubIInterface ; private IInterface mProxyIInterface ; public ProxyBinder ( IInterface stubIInterface ) { this . mStubIInterface = stubIInterface ; this . mRemoteBinder = stubIInterface . asBinder ( ) ; } public ProxyBinder ( IInterface stubIInterface , IInterface proxyIInterface ) { this ( stubIInterface ) ; setProxyInterface ( proxyIInterface ) ; } public synchronized void setProxyInterface ( IInterface proxyIInterface ) { this . mProxyIInterface = proxyIInterface ; } public synchronized IInterface getProxyIInterface ( ) { return mProxyIInterface ; } @ Override public String getInterfaceDescriptor ( ) throws RemoteException { return mRemoteBinder . getInterfaceDescriptor ( ) ; } @ Override public boolean pingBinder ( ) { return mRemoteBinder . pingBinder ( ) ; } @ Override public boolean isBinderAlive ( ) { return mRemoteBinder . isBinderAlive ( ) ; } @ Override public synchronized IInterface queryLocalInterface ( String descriptor ) { return mProxyIInterface != null ? mProxyIInterface : mStubIInterface ; } @ Override public void dump ( FileDescriptor fd , String [ ] args ) throws RemoteException { mRemoteBinder . dump ( fd , args ) ; } @ Override public void dumpAsync ( FileDescriptor fd , String [ ] args ) throws RemoteException { mRemoteBinder . dumpAsync ( fd , args ) ; } @ Override public boolean transact ( int code , Parcel data , Parcel reply , int flags ) throws RemoteException { return mRemoteBinder . transact ( code , data , reply , flags ) ; } @ Override public void linkToDeath ( DeathRecipient recipient , int flags ) throws RemoteException { mRemoteBinder . linkToDeath ( recipient , flags ) ; } @ Override public boolean unlinkToDeath ( DeathRecipient recipient , int flags ) { return mRemoteBinder . unlinkToDeath ( recipient , flags ) ; } } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import android . content . pm . PackageManager ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( "<STR_LIT>" ) public interface IContextImpl { @ Field ( "<STR_LIT>" ) void setPackageManager ( PackageManager packageManager ) ; } </s>
<s> package com . norman . webviewup . lib . service . binder ; import android . os . IBinder ; public abstract class BinderHook { private final Object sync = new Object ( ) ; private IBinder originalBinder ; private ProxyBinder proxyBinder ; private boolean currentHook ; private boolean recentHook ; public BinderHook ( ) { } public final void hook ( ) { synchronized ( sync ) { if ( currentHook ) { return ; } if ( recentHook ) { onProxyBinderReplace ( proxyBinder ) ; } else { IBinder original = onTargetBinderObtain ( ) ; ProxyBinder proxy = onProxyBinderCreate ( original ) ; onProxyBinderReplace ( proxy ) ; this . originalBinder = original ; this . proxyBinder = proxy ; this . recentHook = true ; } currentHook = true ; } } public boolean isHook ( ) { synchronized ( sync ) { return currentHook ; } } public final boolean restore ( ) { synchronized ( sync ) { if ( ! currentHook ) { return false ; } onTargetBinderRestore ( originalBinder ) ; currentHook = false ; return true ; } } protected ProxyBinder getProxyBinder ( ) { return proxyBinder ; } protected abstract IBinder onTargetBinderObtain ( ) ; protected abstract ProxyBinder onProxyBinderCreate ( IBinder binder ) ; protected abstract void onTargetBinderRestore ( IBinder binder ) ; protected abstract void onProxyBinderReplace ( ProxyBinder binder ) ; } </s>
<s> package com . norman . webviewup . lib . service . interfaces ; import android . os . IInterface ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( "<STR_LIT>" ) public interface IPackageManager { String SERVICE = "<STR_LIT>" ; @ Method ( value = "<STR_LIT>" , type = Method . STATIC ) IInterface asInterface ( android . os . IBinder obj ) ; } </s>
<s> package com . norman . webviewup . lib . service . proxy ; import android . content . ComponentName ; import android . content . pm . PackageInfo ; import com . norman . webviewup . lib . reflect . RuntimeProxy ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( "<STR_LIT>" ) public abstract class PackageManagerProxy extends RuntimeProxy { public PackageManagerProxy ( ) { super ( ) ; } @ Method ( "<STR_LIT>" ) protected abstract PackageInfo getPackageInfo ( String packageName , long flags , int userId ) ; @ Method ( "<STR_LIT>" ) protected abstract PackageInfo getPackageInfo ( String packageName , int flags , int userId ) ; @ Method ( "<STR_LIT>" ) protected abstract PackageInfo getPackageInfo ( String packageName , int flags ) ; @ Method ( "<STR_LIT>" ) protected abstract int getComponentEnabledSetting ( ComponentName componentName , int userId ) ; @ Method ( "<STR_LIT>" ) protected abstract int getComponentEnabledSetting ( ComponentName componentName ) ; @ Method ( "<STR_LIT>" ) protected abstract String getInstallerPackageName ( String packageName ) ; @ Method ( "<STR_LIT>" ) protected abstract android . os . IBinder asBinder ( ) ; } </s>
<s> package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; class ReflectMethod { private final Object mMethodLock = new Object ( ) ; private String mName ; private Class < ? > mClass ; private String mClassName ; private Object mObject ; private Class < ? > [ ] mParameterTypes ; private Method mMethod ; private Method assessMethod ; private int staticType ; public ReflectMethod ( Method method ) { this ( null , method ) ; } public ReflectMethod ( Object object , Method method ) { this . mMethod = method ; this . mParameterTypes = method . getParameterTypes ( ) ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public ReflectMethod ( String className , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mClassName = className ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectMethod ( Class < ? > cls , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mClass = cls ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectMethod ( Object object , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public Object invoke ( Object ... args ) throws ReflectException { synchronized ( mMethodLock ) { prepareMethod ( ) ; try { return assessMethod . invoke ( mObject , args ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setStaticType ( int staticValue ) { this . staticType = staticValue ; } private void prepareMethod ( ) throws ReflectException { synchronized ( mMethodLock ) { try { if ( assessMethod != null ) { return ; } Method findMethod = mMethod ; if ( findMethod == null ) { String className = null ; String filedName = mName ; if ( ! TextUtils . isEmpty ( mName ) ) { int lastDotIndex = mName . lastIndexOf ( "<STR_LIT>" ) ; if ( lastDotIndex >= <NUM_LIT> && lastDotIndex < mName . length ( ) - <NUM_LIT> ) { className = mName . substring ( <NUM_LIT> , lastDotIndex ) ; filedName = mName . substring ( lastDotIndex + <NUM_LIT> ) ; } } if ( className != null ) { try { Class < ? > relfectClass = Class . forName ( className ) ; findMethod = findMethod ( relfectClass , filedName ) ; } catch ( Throwable ignore ) { } } if ( findMethod == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } findMethod = findMethod ( findClass , filedName ) ; } } if ( findMethod == null ) { throw new NoSuchMethodException ( "<STR_LIT>" + mName ) ; } int modifiers = findMethod . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findMethod . isAccessible ( ) ) { findMethod . setAccessible ( true ) ; } } assessMethod = findMethod ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private Method findMethod ( Class < ? > findClass , String filedName ) { for ( Class < ? > clazz = findClass ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Method method = clazz . getDeclaredMethod ( filedName , mParameterTypes ) ; boolean staticModifiers = Modifier . isStatic ( method . getModifiers ( ) ) ; if ( ( staticType == <NUM_LIT> && staticModifiers ) || ( staticType == <NUM_LIT> && ! staticModifiers ) ) { continue ; } return method ; } catch ( Throwable ignore ) { } } return null ; } } </s>
<s> package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . ClassType ; import com . norman . webviewup . lib . reflect . annotation . Method ; public abstract class RuntimeProxy { private final Object mProxyLock = new Object ( ) ; private final ThreadLocal < ReflectProxy . InvokeContext > mInvokeContextThreadLocal = new ThreadLocal < > ( ) ; private volatile Object target ; private Object proxy ; private ReflectProxy reflectProxy ; private final Class < ? > proxyClass ; public RuntimeProxy ( ) { this ( null ) ; } public RuntimeProxy ( Class < ? > proxyClass ) { this . proxyClass = proxyClass ; } public void setTarget ( Object target ) { synchronized ( mProxyLock ) { this . target = target ; if ( reflectProxy != null ) { reflectProxy . setTarget ( target ) ; } } } public Object get ( ) throws ReflectException { try { synchronized ( mProxyLock ) { if ( proxy != null ) { return proxy ; } Class < ? > reflectClass = proxyClass ; if ( reflectClass == null ) { ClassType classTypeAnnotation = getClass ( ) . getAnnotation ( ClassType . class ) ; ClassName classNameAnnotation = getClass ( ) . getAnnotation ( ClassName . class ) ; Class < ? > annotationClass = null ; if ( classNameAnnotation != null ) { annotationClass = Class . forName ( classNameAnnotation . value ( ) ) ; } else if ( classTypeAnnotation != null ) { annotationClass = classTypeAnnotation . value ( ) ; } reflectClass = annotationClass ; } ReflectProxy reflectProxy = new ReflectProxy ( reflectClass ) ; for ( Class < ? > clazz = getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { java . lang . reflect . Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( java . lang . reflect . Method method : methods ) { Method methodAnnotation = method . getAnnotation ( Method . class ) ; if ( methodAnnotation != null ) { String methodName = methodAnnotation . value ( ) ; if ( TextUtils . isEmpty ( methodName ) ) { methodName = method . getName ( ) ; } ReflectProxy . Invoke invoke = new ReflectProxy . Invoke ( methodName , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { try { if ( invokeContext . target == null ) return ; if ( ! method . isAccessible ( ) ) { method . setAccessible ( true ) ; } mInvokeContextThreadLocal . set ( invokeContext ) ; Object result = method . invoke ( RuntimeProxy . this , invokeContext . args ) ; invokeContext . setResult ( result ) ; } catch ( Throwable e ) { throw new ReflectException ( e ) ; } finally { mInvokeContextThreadLocal . set ( null ) ; } } } ; reflectProxy . addInvoke ( invoke , false ) ; } } } reflectProxy . setTarget ( target ) ; proxy = reflectProxy . newProxyInstance ( ) ; this . reflectProxy = reflectProxy ; return proxy ; } } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } protected Object invoke ( ) { ReflectProxy . InvokeContext invokeContext = mInvokeContextThreadLocal . get ( ) ; if ( invokeContext == null ) { return null ; } return invokeContext . invoke ( ) ; } protected Object getTarget ( ) { ReflectProxy . InvokeContext invokeContext = mInvokeContextThreadLocal . get ( ) ; if ( invokeContext == null ) { return null ; } return invokeContext . target ; } } </s>
<s> package com . skythinker . gptassistant ; import java . io . Serializable ; import java . util . Arrays ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; public class PromptTabData implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String tabTitle ; private String prompt ; public PromptTabData ( String tabTitle , String prompt ) { this . tabTitle = tabTitle ; this . prompt = prompt ; } public String getTitle ( ) { return tabTitle ; } public void setTitle ( String tabTitle ) { this . tabTitle = tabTitle ; } public String getPrompt ( ) { return prompt ; } public void setPrompt ( String prompt ) { this . prompt = prompt ; } public JSONObject parseParams ( ) { JSONObject params = new JSONObject ( ) ; try { Matcher headerMatcher = Pattern . compile ( "<STR_LIT>" ) . matcher ( prompt ) ; if ( headerMatcher . find ( ) ) { Matcher lineMatcher = Pattern . compile ( "<STR_LIT>" , Pattern . MULTILINE ) . matcher ( headerMatcher . group ( <NUM_LIT> ) ) ; JSONObject inputObject = new JSONObject ( ) ; while ( lineMatcher . find ( ) ) { String name = lineMatcher . group ( <NUM_LIT> ) ; String value = lineMatcher . group ( <NUM_LIT> ) ; if ( name == null || value == null ) continue ; value = value . trim ( ) ; if ( name . equals ( "<STR_LIT>" ) ) { params . putOpt ( name , value ) ; } else if ( Arrays . asList ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) . contains ( name ) ) { params . putOpt ( name , value . equals ( "<STR_LIT>" ) ) ; } else if ( name . equals ( "<STR_LIT>" ) ) { inputObject . putOpt ( value , new JSONObject ( ) . putOpt ( "<STR_LIT>" , "<STR_LIT>" ) ) ; } else if ( name . equals ( "<STR_LIT>" ) ) { String [ ] selectParams = value . split ( "<STR_LIT>" ) ; if ( selectParams . length > <NUM_LIT> ) { JSONArray itemsArray = new JSONArray ( ) ; for ( int i = <NUM_LIT> ; i < selectParams . length ; i ++ ) { String item = selectParams [ i ] . trim ( ) ; JSONObject itemObject = new JSONObject ( ) ; Matcher itemMatcher = Pattern . compile ( "<STR_LIT>" ) . matcher ( item ) ; if ( itemMatcher . find ( ) ) { itemObject . putOpt ( "<STR_LIT>" , itemMatcher . group ( <NUM_LIT> ) ) ; itemObject . putOpt ( "<STR_LIT>" , itemMatcher . group ( <NUM_LIT> ) ) ; } else { itemObject . putOpt ( "<STR_LIT>" , item ) ; itemObject . putOpt ( "<STR_LIT>" , item ) ; } itemsArray . put ( itemObject ) ; } inputObject . putOpt ( selectParams [ <NUM_LIT> ] . trim ( ) , new JSONObject ( ) . putOpt ( "<STR_LIT>" , "<STR_LIT>" ) . putOpt ( "<STR_LIT>" , itemsArray ) ) ; } } } if ( inputObject . size ( ) > <NUM_LIT> ) params . putOpt ( "<STR_LIT>" , inputObject ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return params ; } public String getContentWithoutParams ( ) { return prompt . replaceFirst ( "<STR_LIT>" , "<STR_LIT>" ) ; } public String getFormattedPrompt ( JSONObject inputValues ) { JSONObject inputParams = parseParams ( ) . getJSONObject ( "<STR_LIT>" ) ; String template = getContentWithoutParams ( ) ; if ( inputParams != null ) { for ( String key : inputValues . keySet ( ) ) { JSONObject paramObject = inputParams . getJSONObject ( key ) ; if ( paramObject != null ) { if ( paramObject . getStr ( "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) { JSONArray items = paramObject . getJSONArray ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < items . size ( ) ; i ++ ) { JSONObject item = items . getJSONObject ( i ) ; if ( item . getStr ( "<STR_LIT>" ) . equals ( inputValues . getStr ( key ) ) ) { template = template . replace ( "<STR_LIT>" + key + "<STR_LIT>" , item . getStr ( "<STR_LIT>" ) ) ; break ; } } } else if ( paramObject . getStr ( "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) { template = template . replace ( "<STR_LIT>" + key + "<STR_LIT>" , inputValues . getStr ( key ) ) ; } } } } return template ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog . listener ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; import java . util . ArrayList ; public class ChainRecogListener implements IRecogListener { private ArrayList < IRecogListener > listeners ; public ChainRecogListener ( ) { listeners = new ArrayList < IRecogListener > ( ) ; } public void addListener ( IRecogListener listener ) { listeners . add ( listener ) ; } @ Override public void onAsrReady ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrReady ( ) ; } } @ Override public void onAsrBegin ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrBegin ( ) ; } } @ Override public void onAsrEnd ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrEnd ( ) ; } } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrPartialResult ( results , recogResult ) ; } } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinalResult ( results , recogResult ) ; } } @ Override public void onAsrFinish ( RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinish ( recogResult ) ; } } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinishError ( errorCode , subErrorCode , descMessage , recogResult ) ; } } @ Override public void onAsrLongFinish ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrLongFinish ( ) ; } } @ Override public void onAsrVolume ( int volumePercent , int volume ) { for ( IRecogListener listener : listeners ) { listener . onAsrVolume ( volumePercent , volume ) ; } } @ Override public void onAsrAudio ( byte [ ] data , int offset , int length ) { for ( IRecogListener listener : listeners ) { listener . onAsrAudio ( data , offset , length ) ; } } @ Override public void onAsrExit ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrExit ( ) ; } } @ Override public void onAsrOnlineNluResult ( String nluResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrOnlineNluResult ( nluResult ) ; } } @ Override public void onOfflineLoaded ( ) { for ( IRecogListener listener : listeners ) { listener . onOfflineLoaded ( ) ; } } @ Override public void onOfflineUnLoaded ( ) { for ( IRecogListener listener : listeners ) { listener . onOfflineUnLoaded ( ) ; } } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . media . MediaRecorder ; import android . util . Log ; import java . io . File ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; public class WhisperAsrClient extends AsrClientBase { MediaRecorder recorder = null ; File recordFile = null ; IAsrCallback callback = null ; WhisperApiClient apiClient = null ; double amplitude = <NUM_LIT> ; boolean isRecording = false ; boolean autoStop = false ; public WhisperAsrClient ( Context context , String url , String apiKey ) { recordFile = new File ( context . getFilesDir ( ) . getAbsolutePath ( ) + "<STR_LIT>" ) ; apiClient = new WhisperApiClient ( context , url , apiKey ) ; } public void setApiInfo ( String url , String apiKey ) { apiClient . setApiInfo ( url , apiKey ) ; } @ Override public void startRecognize ( ) { try { recorder = new MediaRecorder ( ) ; recorder . setAudioSource ( MediaRecorder . AudioSource . MIC ) ; recorder . setOutputFormat ( MediaRecorder . OutputFormat . MPEG_4 ) ; recorder . setOutputFile ( recordFile . getAbsolutePath ( ) ) ; recorder . setAudioEncoder ( MediaRecorder . AudioEncoder . AAC ) ; recorder . prepare ( ) ; recorder . start ( ) ; isRecording = true ; if ( autoStop ) { new Thread ( ( ) -> { boolean speechDetected = false ; final int SILENCE_THRESHOLD = <NUM_LIT> ; final int SILENCE_AFTER_SPEECH = <NUM_LIT> ; long lastSpeechTime = <NUM_LIT> ; while ( isRecording ) { try { if ( recorder != null ) { final double lpfRatio = <NUM_LIT> ; double ratio = recorder . getMaxAmplitude ( ) ; if ( ratio < <NUM_LIT> ) ratio = <NUM_LIT> ; double db = <NUM_LIT> * Math . log10 ( ratio ) ; amplitude = ( <NUM_LIT> - lpfRatio ) * amplitude + lpfRatio * db ; if ( amplitude > SILENCE_THRESHOLD ) { speechDetected = true ; lastSpeechTime = System . currentTimeMillis ( ) ; } if ( speechDetected && amplitude < SILENCE_THRESHOLD && System . currentTimeMillis ( ) - lastSpeechTime > SILENCE_AFTER_SPEECH ) { speechDetected = false ; stopRecognize ( true ) ; } } Thread . sleep ( <NUM_LIT> ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } public void stopRecognize ( boolean callAutoStop ) { try { if ( recorder != null && isRecording ) { isRecording = false ; recorder . stop ( ) ; recorder . reset ( ) ; recorder . release ( ) ; new Thread ( ( ) -> { try { callback . onResult ( apiClient . getWhisperResult ( recordFile ) ) ; if ( callAutoStop ) { callback . onAutoStop ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } ) . start ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } @ Override public void stopRecognize ( ) { stopRecognize ( false ) ; } @ Override public void cancelRecognize ( ) { try { if ( recorder != null && isRecording ) { isRecording = false ; recorder . stop ( ) ; recorder . reset ( ) ; recorder . release ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { cancelRecognize ( ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothAdapter ; import android . bluetooth . BluetoothDevice ; import android . bluetooth . BluetoothHeadset ; import android . bluetooth . BluetoothProfile ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . media . AudioManager ; import android . util . Log ; import java . util . List ; import static android . media . AudioManager . STREAM_VOICE_CALL ; public class AndroidAudioManager { private static volatile AndroidAudioManager instance ; private BluetoothAdapter mBluetoothAdapter ; private AudioManager mAudioManager ; private boolean mIsBluetoothHeadsetConnected ; private boolean mIsBluetoothHeadsetScoConnected ; private BluetoothReceiver mBluetoothReceiver ; private HeadsetReceiver mHeadsetReceiver ; private boolean mAudioFocused ; private Context mContext ; private BluetoothHeadset mBluetoothHeadset ; private AndroidAudioManager ( Context context ) { mAudioManager = ( ( AudioManager ) context . getSystemService ( Context . AUDIO_SERVICE ) ) ; this . mContext = context . getApplicationContext ( ) ; } public AudioManager getAudioManager ( ) { return mAudioManager ; } public static AndroidAudioManager getInstance ( Context context ) { if ( instance == null ) { synchronized ( AndroidAudioManager . class ) { if ( instance == null ) { instance = new AndroidAudioManager ( context ) ; } } } return instance ; } public void startBluetooth ( ) { mBluetoothAdapter = BluetoothAdapter . getDefaultAdapter ( ) ; if ( mBluetoothAdapter != null ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( mAudioManager . isBluetoothScoAvailableOffCall ( ) ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; } else { Log . w ( "<STR_LIT>" , "<STR_LIT>" ) ; } if ( mBluetoothAdapter . isEnabled ( ) ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; mBluetoothReceiver = new BluetoothReceiver ( ) ; mIsBluetoothHeadsetConnected = false ; mIsBluetoothHeadsetScoConnected = false ; BluetoothProfile . ServiceListener bluetoothServiceListener = new BluetoothProfile . ServiceListener ( ) { public void onServiceConnected ( int profile , BluetoothProfile proxy ) { if ( profile == BluetoothProfile . HEADSET ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; mBluetoothHeadset = ( BluetoothHeadset ) proxy ; List < BluetoothDevice > devices = mBluetoothHeadset . getConnectedDevices ( ) ; if ( devices . size ( ) > <NUM_LIT> ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; bluetoothHeadetConnectionChanged ( true ) ; } Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ; filter . addAction ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ; filter . addAction ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ; filter . addAction ( BluetoothHeadset . ACTION_VENDOR_SPECIFIC_HEADSET_EVENT ) ; Intent sticky = mContext . registerReceiver ( mBluetoothReceiver , filter ) ; int state = sticky . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; bluetoothHeadetScoConnectionChanged ( false ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTING ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_ERROR ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; } else { Log . w ( "<STR_LIT>" , "<STR_LIT>" + "<STR_LIT>" + state ) ; } } } public void onServiceDisconnected ( int profile ) { if ( profile == BluetoothProfile . HEADSET ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; mBluetoothHeadset = null ; mIsBluetoothHeadsetConnected = false ; mIsBluetoothHeadsetScoConnected = false ; } } } ; mBluetoothAdapter . getProfileProxy ( mContext , bluetoothServiceListener , BluetoothProfile . HEADSET ) ; } } } public synchronized void bluetoothHeadetConnectionChanged ( boolean connected ) { mIsBluetoothHeadsetConnected = connected ; mAudioManager . setBluetoothScoOn ( connected ) ; mAudioManager . startBluetoothSco ( ) ; routeAudioToBluetooth ( ) ; } public synchronized boolean isBluetoothHeadsetConnected ( ) { return mIsBluetoothHeadsetConnected ; } public synchronized void bluetoothHeadetScoConnectionChanged ( boolean connected ) { mIsBluetoothHeadsetScoConnected = connected ; } public synchronized boolean isUsingBluetoothAudioRoute ( ) { return mIsBluetoothHeadsetScoConnected ; } public synchronized void routeAudioToBluetooth ( ) { if ( ! isBluetoothHeadsetConnected ( ) ) { Log . w ( "<STR_LIT>" , "<STR_LIT>" ) ; return ; } if ( mAudioManager . getMode ( ) != AudioManager . MODE_IN_COMMUNICATION ) { Log . w ( "<STR_LIT>" , "<STR_LIT>" + "<STR_LIT>" ) ; mAudioManager . setMode ( AudioManager . MODE_IN_COMMUNICATION ) ; requestAudioFocus ( STREAM_VOICE_CALL ) ; } changeBluetoothSco ( true ) ; } private void requestAudioFocus ( int stream ) { if ( ! mAudioFocused ) { int res = mAudioManager . requestAudioFocus ( null , stream , AudioManager . AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + ( res == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ? "<STR_LIT>" : "<STR_LIT>" ) ) ; if ( res == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ) { mAudioFocused = true ; } } } private synchronized void changeBluetoothSco ( final boolean enable ) { if ( enable && mIsBluetoothHeadsetScoConnected ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; return ; } else if ( ! enable && ! mIsBluetoothHeadsetScoConnected ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; return ; } new Thread ( ) { @ Override public void run ( ) { boolean resultAcknoledged ; int retries = <NUM_LIT> ; do { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { Log . e ( "<STR_LIT>" , e . getMessage ( ) , e ) ; } synchronized ( AndroidAudioManager . this ) { if ( enable ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + retries ) ; mAudioManager . startBluetoothSco ( ) ; } else { Log . i ( "<STR_LIT>" , "<STR_LIT>" + retries ) ; mAudioManager . stopBluetoothSco ( ) ; } resultAcknoledged = isUsingBluetoothAudioRoute ( ) == enable ; retries ++ ; } } while ( ! resultAcknoledged && retries < <NUM_LIT> ) ; } } . start ( ) ; } public void destroy ( ) { if ( mBluetoothAdapter != null && mBluetoothHeadset != null ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; mBluetoothAdapter . closeProfileProxy ( BluetoothProfile . HEADSET , mBluetoothHeadset ) ; } Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( mBluetoothReceiver != null ) { mContext . unregisterReceiver ( mBluetoothReceiver ) ; } synchronized ( AndroidAudioManager . class ) { mContext = null ; instance = null ; } } public void startSimpleBluetooth ( ) { mAudioManager . setBluetoothScoOn ( true ) ; mAudioManager . startBluetoothSco ( ) ; } public void destorySimpleBluetooth ( ) { mAudioManager . setBluetoothScoOn ( false ) ; mAudioManager . stopBluetoothSco ( ) ; } public void enableHeadsetReceiver ( ) { mHeadsetReceiver = new HeadsetReceiver ( ) ; Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; mContext . registerReceiver ( mHeadsetReceiver , new IntentFilter ( AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) ; mContext . registerReceiver ( mHeadsetReceiver , new IntentFilter ( AudioManager . ACTION_HEADSET_PLUG ) ) ; } public void routeAudioToEarPiece ( ) { routeAudioToSpeakerHelper ( false ) ; } public void routeAudioToSpeakerHelper ( boolean speakerOn ) { Log . w ( "<STR_LIT>" , "<STR_LIT>" + ( speakerOn ? "<STR_LIT>" : "<STR_LIT>" ) ) ; if ( mIsBluetoothHeadsetScoConnected ) { Log . w ( "<STR_LIT>" , "<STR_LIT>" ) ; changeBluetoothSco ( false ) ; } mAudioManager . setSpeakerphoneOn ( speakerOn ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . recog . IStatus ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public class StatusRecogListener implements IRecogListener , IStatus { private static final String TAG = "<STR_LIT>" ; protected int status = STATUS_NONE ; @ Override public void onAsrReady ( ) { status = STATUS_READY ; } @ Override public void onAsrBegin ( ) { status = STATUS_SPEAKING ; } @ Override public void onAsrEnd ( ) { status = STATUS_RECOGNITION ; } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrFinish ( RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrLongFinish ( ) { status = STATUS_LONG_SPEECH_FINISHED ; } @ Override public void onAsrVolume ( int volumePercent , int volume ) { Log . i ( TAG , "<STR_LIT>" + volumePercent + "<STR_LIT>" + volume ) ; } @ Override public void onAsrAudio ( byte [ ] data , int offset , int length ) { if ( offset != <NUM_LIT> || data . length != length ) { byte [ ] actualData = new byte [ length ] ; System . arraycopy ( data , <NUM_LIT> , actualData , <NUM_LIT> , length ) ; data = actualData ; } Log . i ( TAG , "<STR_LIT>" + data . length ) ; } @ Override public void onAsrExit ( ) { status = STATUS_NONE ; } @ Override public void onAsrOnlineNluResult ( String nluResult ) { status = STATUS_FINISHED ; } @ Override public void onOfflineLoaded ( ) { } @ Override public void onOfflineUnLoaded ( ) { } } </s>
<s> package com . skythinker . gptassistant ; public abstract class AsrClientBase { public interface IAsrCallback { void onError ( String msg ) ; void onResult ( String result ) ; void onAutoStop ( ) ; } public abstract void startRecognize ( ) ; public abstract void stopRecognize ( ) ; public abstract void cancelRecognize ( ) ; public abstract void setCallback ( IAsrCallback callback ) ; public abstract void setParam ( String key , Object value ) ; public abstract void setEnableAutoStop ( boolean enable ) ; public abstract void destroy ( ) ; } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; import com . baidu . speech . asr . SpeechConstant ; public class MessageStatusRecogListener extends StatusRecogListener { private Handler handler ; private long speechEndTime = <NUM_LIT> ; private boolean needTime = true ; private static final String TAG = "<STR_LIT>" ; public MessageStatusRecogListener ( Handler handler ) { this . handler = handler ; } @ Override public void onAsrReady ( ) { super . onAsrReady ( ) ; speechEndTime = <NUM_LIT> ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_WAKEUP_READY , "<STR_LIT>" ) ; } @ Override public void onAsrBegin ( ) { super . onAsrBegin ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_BEGIN , "<STR_LIT>" ) ; } @ Override public void onAsrEnd ( ) { super . onAsrEnd ( ) ; speechEndTime = System . currentTimeMillis ( ) ; sendMessage ( "<STR_LIT>" ) ; } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , "<STR_LIT>" + results [ <NUM_LIT> ] + "<STR_LIT>" + recogResult . getOrigalJson ( ) ) ; super . onAsrPartialResult ( results , recogResult ) ; } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { super . onAsrFinalResult ( results , recogResult ) ; String message = "<STR_LIT>" + results [ <NUM_LIT> ] + "<STR_LIT>" ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , message + "<STR_LIT>" + recogResult . getOrigalJson ( ) ) ; if ( speechEndTime > <NUM_LIT> ) { long currentTime = System . currentTimeMillis ( ) ; long diffTime = currentTime - speechEndTime ; message += "<STR_LIT>" + diffTime + "<STR_LIT>" + currentTime ; } speechEndTime = <NUM_LIT> ; sendMessage ( message , status , true ) ; } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { super . onAsrFinishError ( errorCode , subErrorCode , descMessage , recogResult ) ; String message = "<STR_LIT>" + errorCode + "<STR_LIT>" + subErrorCode + "<STR_LIT>" + descMessage ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , message ) ; if ( speechEndTime > <NUM_LIT> ) { long diffTime = System . currentTimeMillis ( ) - speechEndTime ; message += "<STR_LIT>" + diffTime + "<STR_LIT>" ; } speechEndTime = <NUM_LIT> ; sendMessage ( message , status , true ) ; speechEndTime = <NUM_LIT> ; } @ Override public void onAsrOnlineNluResult ( String nluResult ) { super . onAsrOnlineNluResult ( nluResult ) ; if ( ! nluResult . isEmpty ( ) ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , "<STR_LIT>" + nluResult ) ; } } @ Override public void onAsrFinish ( RecogResult recogResult ) { super . onAsrFinish ( recogResult ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH , "<STR_LIT>" ) ; } @ Override public void onAsrLongFinish ( ) { super . onAsrLongFinish ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_LONG_SPEECH , "<STR_LIT>" ) ; } @ Override public void onOfflineLoaded ( ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_LOADED , "<STR_LIT>" ) ; } @ Override public void onOfflineUnLoaded ( ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_UNLOADED , "<STR_LIT>" ) ; } @ Override public void onAsrExit ( ) { super . onAsrExit ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_EXIT , "<STR_LIT>" ) ; } private void sendStatusMessage ( String eventName , String message ) { message = "<STR_LIT>" + eventName + "<STR_LIT>" + message ; sendMessage ( message , status ) ; } private void sendMessage ( String message ) { sendMessage ( message , WHAT_MESSAGE_STATUS ) ; } private void sendMessage ( String message , int what ) { sendMessage ( message , what , false ) ; } private void sendMessage ( String message , int what , boolean highlight ) { if ( needTime && what != STATUS_FINISHED ) { message += "<STR_LIT>" + System . currentTimeMillis ( ) ; } if ( handler == null ) { Log . i ( TAG , message ) ; return ; } Message msg = Message . obtain ( ) ; msg . what = what ; msg . arg1 = status ; if ( highlight ) { msg . arg2 = <NUM_LIT> ; } msg . obj = message + "<STR_LIT>" ; handler . sendMessage ( msg ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . Context ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import androidx . core . content . ContextCompat ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . TreeSet ; import javax . net . ssl . HttpsURLConnection ; public class AutoCheck { public static final boolean isOnlineLited = false ; private LinkedHashMap < String , Check > checks ; private Context context ; private Handler handler ; private boolean hasError ; private boolean enableOffline ; private boolean isFinished = false ; private String name ; private static final String TAG = "<STR_LIT>" ; public AutoCheck ( Context context , final Handler handler , boolean enableOffline ) { this . context = context ; checks = new LinkedHashMap < > ( ) ; this . handler = handler ; this . enableOffline = enableOffline ; } public void checkAsr ( final Map < String , Object > params ) { Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { AutoCheck obj = checkAsrInternal ( params ) ; name = "<STR_LIT>" ; synchronized ( obj ) { isFinished = true ; Message msg = handler . obtainMessage ( <NUM_LIT> , obj ) ; handler . sendMessage ( msg ) ; } } } ) ; t . start ( ) ; } public String obtainErrorMessage ( ) { PrintConfig config = new PrintConfig ( ) ; return formatString ( config ) ; } public String obtainDebugMessage ( ) { PrintConfig config = new PrintConfig ( ) ; config . withInfo = true ; return formatString ( config ) ; } public String obtainAllMessage ( ) { PrintConfig config = new PrintConfig ( ) ; config . withLog = true ; config . withInfo = true ; config . withLogOnSuccess = true ; return formatString ( config ) ; } private String formatString ( PrintConfig config ) { StringBuilder sb = new StringBuilder ( ) ; hasError = false ; for ( HashMap . Entry < String , Check > entry : checks . entrySet ( ) ) { Check check = entry . getValue ( ) ; String testName = entry . getKey ( ) ; if ( check . hasError ( ) ) { if ( ! hasError ) { hasError = true ; } sb . append ( "<STR_LIT>" ) . append ( testName ) . append ( "<STR_LIT>" ) . append ( check . getErrorMessage ( ) ) . append ( "<STR_LIT>" ) ; Log . e ( "<STR_LIT>" , sb . toString ( ) ) ; if ( check . hasFix ( ) ) { sb . append ( "<STR_LIT>" ) . append ( testName ) . append ( "<STR_LIT>" ) . append ( check . getFixMessage ( ) ) . append ( "<STR_LIT>" ) ; } } else if ( config . withEachCheckInfo ) { sb . append ( "<STR_LIT>" ) . append ( testName ) . append ( "<STR_LIT>" ) . append ( "<STR_LIT>" ) ; } if ( config . withInfo && check . hasInfo ( ) ) { sb . append ( "<STR_LIT>" ) . append ( testName ) . append ( "<STR_LIT>" ) . append ( check . getInfoMessage ( ) ) . append ( "<STR_LIT>" ) ; } if ( config . withLog && ( config . withLogOnSuccess || hasError ) && check . hasLog ( ) ) { sb . append ( "<STR_LIT>" + check . getLogMessage ( ) ) . append ( "<STR_LIT>" ) ; } } if ( ! hasError ) { sb . append ( "<STR_LIT>" + name + "<STR_LIT>" ) ; } return sb . toString ( ) ; } private AutoCheck checkAsrInternal ( Map < String , Object > params ) { commonSetting ( params ) ; checks . put ( "<STR_LIT>" , new FileCheck ( context , params , SpeechConstant . IN_FILE ) ) ; checks . put ( "<STR_LIT>" , new FileCheck ( context , params , SpeechConstant . ASR_OFFLINE_ENGINE_GRAMMER_FILE_PATH ) ) ; for ( Map . Entry < String , Check > e : checks . entrySet ( ) ) { Check check = e . getValue ( ) ; check . check ( ) ; if ( check . hasError ( ) ) { break ; } } return this ; } private void commonSetting ( Map < String , Object > params ) { checks . put ( "<STR_LIT>" , new PermissionCheck ( context ) ) ; checks . put ( "<STR_LIT>" , new JniCheck ( context ) ) ; AppInfoCheck infoCheck = null ; try { infoCheck = new AppInfoCheck ( context , params ) ; checks . put ( "<STR_LIT>" , infoCheck ) ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; Log . e ( TAG , "<STR_LIT>" , e ) ; return ; } if ( enableOffline ) { checks . put ( "<STR_LIT>" , new ApplicationIdCheck ( context , infoCheck . appId ) ) ; } } private static class PrintConfig { public boolean withEachCheckInfo = false ; public boolean withInfo = false ; public boolean withLog = false ; public boolean withLogOnSuccess = false ; } private static class PermissionCheck extends Check { private Context context ; public PermissionCheck ( Context context ) { this . context = context ; } @ Override public void check ( ) { String [ ] permissions = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( context , perm ) ) { toApplyList . add ( perm ) ; } } if ( ! toApplyList . isEmpty ( ) ) { errorMessage = "<STR_LIT>" + toApplyList ; fixMessage = "<STR_LIT>" ; } } } private static class JniCheck extends Check { private Context context ; private String [ ] soNames ; public JniCheck ( Context context ) { this . context = context ; if ( isOnlineLited ) { soNames = new String [ ] { "<STR_LIT>" , "<STR_LIT>" } ; } else { soNames = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; } } @ Override public void check ( ) { String path = context . getApplicationInfo ( ) . nativeLibraryDir ; appendLogMessage ( "<STR_LIT>" + path ) ; File [ ] files = new File ( path ) . listFiles ( ) ; TreeSet < String > set = new TreeSet < > ( ) ; if ( files != null ) { for ( File file : files ) { set . add ( file . getName ( ) ) ; } } for ( String name : soNames ) { if ( ! set . contains ( name ) ) { errorMessage = "<STR_LIT>" + path + "<STR_LIT>" + name + "<STR_LIT>" + set . toString ( ) ; fixMessage = "<STR_LIT>" + "<STR_LIT>" ; break ; } } } } private static class AppInfoCheck extends Check { private String appId ; private String appKey ; private String secretKey ; public AppInfoCheck ( Context context , Map < String , Object > params ) throws PackageManager . NameNotFoundException { if ( params . get ( SpeechConstant . APP_ID ) != null ) { appId = params . get ( SpeechConstant . APP_ID ) . toString ( ) ; } if ( params . get ( SpeechConstant . APP_KEY ) != null ) { appKey = params . get ( SpeechConstant . APP_KEY ) . toString ( ) ; } if ( params . get ( SpeechConstant . SECRET ) != null ) { secretKey = params . get ( SpeechConstant . SECRET ) . toString ( ) ; } } public void check ( ) { do { appendLogMessage ( "<STR_LIT>" + appId + "<STR_LIT>" + appKey + "<STR_LIT>" + secretKey ) ; if ( appId == null || appId . isEmpty ( ) ) { errorMessage = "<STR_LIT>" ; fixMessage = "<STR_LIT>" ; break ; } if ( appKey == null || appKey . isEmpty ( ) ) { errorMessage = "<STR_LIT>" ; fixMessage = "<STR_LIT>" ; break ; } if ( secretKey == null || secretKey . isEmpty ( ) ) { errorMessage = "<STR_LIT>" ; fixMessage = "<STR_LIT>" ; break ; } try { checkOnline ( ) ; } catch ( UnknownHostException e ) { infoMessage = "<STR_LIT>" + e . getMessage ( ) ; } catch ( Exception e ) { errorMessage = e . getClass ( ) . getCanonicalName ( ) + "<STR_LIT>" + e . getMessage ( ) ; fixMessage = "<STR_LIT>" ; } } while ( false ) ; } public void checkOnline ( ) throws Exception { String urlpath = "<STR_LIT>" + appKey + "<STR_LIT>" + secretKey + "<STR_LIT>" ; Log . i ( "<STR_LIT>" , "<STR_LIT>" + urlpath ) ; URL url = new URL ( urlpath ) ; HttpsURLConnection conn = ( HttpsURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( "<STR_LIT>" ) ; conn . setConnectTimeout ( <NUM_LIT> ) ; InputStream is = conn . getInputStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; StringBuilder result = new StringBuilder ( ) ; String line = "<STR_LIT>" ; do { line = reader . readLine ( ) ; if ( line != null ) { result . append ( line ) ; } } while ( line != null ) ; String res = result . toString ( ) ; if ( ! res . contains ( "<STR_LIT>" ) ) { errorMessage = "<STR_LIT>" + appId + "<STR_LIT>" ; fixMessage = "<STR_LIT>" ; return ; } appendLogMessage ( "<STR_LIT>" + res ) ; JSONObject jsonObject = new JSONObject ( res ) ; String error = jsonObject . optString ( "<STR_LIT>" ) ; if ( error != null && ! error . isEmpty ( ) ) { errorMessage = "<STR_LIT>" + "<STR_LIT>" + error + "<STR_LIT>" + result ; fixMessage = "<STR_LIT>" ; return ; } String token = jsonObject . getString ( "<STR_LIT>" ) ; if ( token == null || ! token . endsWith ( "<STR_LIT>" + appId ) ) { errorMessage = "<STR_LIT>" + appId + "<STR_LIT>" + token ; fixMessage = "<STR_LIT>" ; } } } private static class ApplicationIdCheck extends Check { private String appId ; private Context context ; public ApplicationIdCheck ( Context context , String appId ) { this . appId = appId ; this . context = context ; } @ Override public void check ( ) { infoMessage = "<STR_LIT>" + appId + "<STR_LIT>" + getApplicationId ( ) ; } private String getApplicationId ( ) { return context . getPackageName ( ) ; } } private static class FileCheck extends Check { private Map < String , Object > params ; private String key ; private Context context ; private boolean allowRes = false ; private boolean allowAssets = true ; public FileCheck ( Context context , Map < String , Object > params , String key ) { this . context = context ; this . params = params ; this . key = key ; if ( key . equals ( SpeechConstant . IN_FILE ) ) { allowRes = true ; allowAssets = false ; } } @ Override public void check ( ) { if ( ! params . containsKey ( key ) ) { return ; } String value = params . get ( key ) . toString ( ) ; if ( allowAssets ) { int len = "<STR_LIT>" . length ( ) ; int totalLen = len + "<STR_LIT>" . length ( ) ; if ( value . startsWith ( "<STR_LIT>" ) ) { String filename = value . substring ( totalLen ) ; if ( ! "<STR_LIT>" . equals ( value . substring ( len , totalLen ) ) || filename . isEmpty ( ) ) { errorMessage = "<STR_LIT>" + key + "<STR_LIT>" + value ; fixMessage = "<STR_LIT>" + "<STR_LIT>" ; } try { context . getAssets ( ) . open ( filename ) ; } catch ( IOException e ) { errorMessage = "<STR_LIT>" + filename ; fixMessage = "<STR_LIT>" ; e . printStackTrace ( ) ; } appendLogMessage ( "<STR_LIT>" + filename ) ; } } if ( allowRes ) { int len = "<STR_LIT>" . length ( ) ; int totalLen = len + "<STR_LIT>" . length ( ) ; if ( value . startsWith ( "<STR_LIT>" ) ) { String filename = value . substring ( totalLen ) ; if ( ! "<STR_LIT>" . equals ( value . substring ( len , totalLen ) ) || filename . isEmpty ( ) ) { errorMessage = "<STR_LIT>" + key + "<STR_LIT>" + value ; fixMessage = "<STR_LIT>" + "<STR_LIT>" ; } InputStream is = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ; if ( is == null ) { errorMessage = "<STR_LIT>" + filename ; fixMessage = "<STR_LIT>" ; } else { try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } appendLogMessage ( "<STR_LIT>" + filename ) ; } } if ( value . startsWith ( "<STR_LIT>" ) ) { if ( ! new File ( value ) . canRead ( ) ) { errorMessage = "<STR_LIT>" + value ; fixMessage = "<STR_LIT>" ; } appendLogMessage ( "<STR_LIT>" + value ) ; } } } private abstract static class Check { protected String errorMessage = null ; protected String fixMessage = null ; protected String infoMessage = null ; protected StringBuilder logMessage ; public Check ( ) { logMessage = new StringBuilder ( ) ; } public abstract void check ( ) ; public boolean hasError ( ) { return errorMessage != null ; } public boolean hasFix ( ) { return fixMessage != null ; } public boolean hasInfo ( ) { return infoMessage != null ; } public boolean hasLog ( ) { return ! logMessage . toString ( ) . isEmpty ( ) ; } public void appendLogMessage ( String message ) { logMessage . append ( message + "<STR_LIT>" ) ; } public String getErrorMessage ( ) { return errorMessage ; } public String getFixMessage ( ) { return fixMessage ; } public String getInfoMessage ( ) { return infoMessage ; } public String getLogMessage ( ) { return logMessage . toString ( ) ; } } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . wakeup ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; public class WakeUpResult { private String name ; private String origalJson ; private String word ; private String desc ; private int errorCode ; private static int ERROR_NONE = <NUM_LIT> ; private static final String TAG = "<STR_LIT>" ; public boolean hasError ( ) { return errorCode != ERROR_NONE ; } public String getOrigalJson ( ) { return origalJson ; } public void setOrigalJson ( String origalJson ) { this . origalJson = origalJson ; } public String getWord ( ) { return word ; } public void setWord ( String word ) { this . word = word ; } public String getDesc ( ) { return desc ; } public void setDesc ( String desc ) { this . desc = desc ; } public int getErrorCode ( ) { return errorCode ; } public void setErrorCode ( int errorCode ) { this . errorCode = errorCode ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public static WakeUpResult parseJson ( String name , String jsonStr ) { WakeUpResult result = new WakeUpResult ( ) ; result . setOrigalJson ( jsonStr ) ; try { JSONObject json = new JSONObject ( jsonStr ) ; if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_SUCCESS . equals ( name ) ) { int error = json . optInt ( "<STR_LIT>" ) ; result . setErrorCode ( error ) ; result . setDesc ( json . optString ( "<STR_LIT>" ) ) ; if ( ! result . hasError ( ) ) { result . setWord ( json . optString ( "<STR_LIT>" ) ) ; } } else { int error = json . optInt ( "<STR_LIT>" ) ; result . setErrorCode ( error ) ; result . setDesc ( json . optString ( "<STR_LIT>" ) ) ; } } catch ( JSONException e ) { MyLogger . error ( TAG , "<STR_LIT>" + jsonStr ) ; e . printStackTrace ( ) ; } return result ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . provider . Settings ; import android . speech . RecognitionListener ; import android . speech . RecognizerIntent ; import android . speech . SpeechRecognizer ; import android . util . Log ; import android . widget . Toast ; import java . util . ArrayList ; import java . util . Locale ; public class GoogleAsrClient extends AsrClientBase { SpeechRecognizer speechRecognizer = null ; IAsrCallback callback = null ; Context context = null ; boolean autoStop = false ; public GoogleAsrClient ( Context context ) { this . context = context ; if ( ! SpeechRecognizer . isRecognitionAvailable ( context . getApplicationContext ( ) ) ) return ; speechRecognizer = SpeechRecognizer . createSpeechRecognizer ( context ) ; speechRecognizer . setRecognitionListener ( new RecognitionListener ( ) { @ Override public void onReadyForSpeech ( Bundle params ) { } @ Override public void onBeginningOfSpeech ( ) { } @ Override public void onRmsChanged ( float rmsdB ) { } @ Override public void onBufferReceived ( byte [ ] buffer ) { } @ Override public void onEndOfSpeech ( ) { } @ Override public void onError ( int error ) { String errorStr = "<STR_LIT>" + error ; if ( error == SpeechRecognizer . ERROR_INSUFFICIENT_PERMISSIONS ) errorStr = context . getString ( R . string . text_google_asr_permission_error ) ; callback . onError ( errorStr ) ; } @ Override public void onResults ( Bundle results ) { ArrayList < String > data = results . getStringArrayList ( SpeechRecognizer . RESULTS_RECOGNITION ) ; if ( data != null && ! data . isEmpty ( ) ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + data . get ( <NUM_LIT> ) ) ; callback . onResult ( data . get ( <NUM_LIT> ) ) ; if ( autoStop ) callback . onAutoStop ( ) ; } } @ Override public void onPartialResults ( Bundle partialResults ) { ArrayList < String > data = partialResults . getStringArrayList ( SpeechRecognizer . RESULTS_RECOGNITION ) ; if ( data != null && ! data . isEmpty ( ) ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + data . get ( <NUM_LIT> ) ) ; callback . onResult ( data . get ( <NUM_LIT> ) ) ; } } @ Override public void onEvent ( int eventType , Bundle params ) { } } ) ; } @ Override public void startRecognize ( ) { if ( speechRecognizer != null ) { Intent speechRecognizerIntent = new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_LANGUAGE_MODEL , RecognizerIntent . LANGUAGE_MODEL_FREE_FORM ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_LANGUAGE , Locale . getDefault ( ) ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_PARTIAL_RESULTS , true ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_MAX_RESULTS , <NUM_LIT> ) ; try { speechRecognizer . startListening ( speechRecognizerIntent ) ; } catch ( SecurityException e ) { callback . onError ( context . getString ( R . string . text_google_asr_typing_error ) ) ; new ConfirmDialog ( context ) . setContent ( context . getString ( R . string . text_google_asr_typing_error ) ) . setOnConfirmListener ( ( ) -> { context . startActivity ( new Intent ( Settings . ACTION_VOICE_INPUT_SETTINGS ) . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ) ) ; } ) . show ( ) ; e . printStackTrace ( ) ; } } else { callback . onError ( context . getString ( R . string . text_google_asr_unavailable ) ) ; } } @ Override public void stopRecognize ( ) { if ( speechRecognizer != null ) { speechRecognizer . cancel ( ) ; } } @ Override public void cancelRecognize ( ) { if ( speechRecognizer != null ) { speechRecognizer . cancel ( ) ; } } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { if ( speechRecognizer != null ) { speechRecognizer . destroy ( ) ; } } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import com . huawei . hms . mlsdk . asr . MLAsrConstants ; import com . huawei . hms . mlsdk . asr . MLAsrListener ; import com . huawei . hms . mlsdk . asr . MLAsrRecognizer ; import com . huawei . hms . mlsdk . common . MLApplication ; public class HmsAsrClient extends AsrClientBase { Context context = null ; MLAsrRecognizer hwAsrRecognizer = null ; IAsrCallback callback = null ; boolean autoStop = false ; public HmsAsrClient ( Context context ) { this . context = context ; MLApplication . getInstance ( ) . setApiKey ( context . getString ( R . string . hms_api_key ) ) ; hwAsrRecognizer = MLAsrRecognizer . createAsrRecognizer ( context ) ; hwAsrRecognizer . setAsrListener ( new MLAsrListener ( ) { @ Override public void onResults ( Bundle bundle ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + bundle . getString ( "<STR_LIT>" ) ) ; String result = bundle . getString ( "<STR_LIT>" ) ; callback . onResult ( result ) ; if ( autoStop && result == null ) callback . onAutoStop ( ) ; } @ Override public void onRecognizingResults ( Bundle bundle ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + bundle . getString ( "<STR_LIT>" ) ) ; callback . onResult ( bundle . getString ( "<STR_LIT>" ) ) ; } @ Override public void onError ( int code , String msg ) { msg = "<STR_LIT>" + code + "<STR_LIT>" + msg ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + msg ) ; if ( code == <NUM_LIT> || code == <NUM_LIT> ) msg += context . getString ( R . string . text_hms_asr_failed_error ) ; callback . onError ( msg ) ; } @ Override public void onStartListening ( ) { } @ Override public void onStartingOfSpeech ( ) { } @ Override public void onVoiceDataReceived ( byte [ ] bytes , float v , Bundle bundle ) { } @ Override public void onState ( int i , Bundle bundle ) { } } ) ; } @ Override public void startRecognize ( ) { if ( Build . CPU_ABI . contains ( "<STR_LIT>" ) ) { callback . onError ( context . getString ( R . string . text_hms_asr_unsupported ) ) ; return ; } Intent hwAsrIntent = new Intent ( MLAsrConstants . ACTION_HMS_ASR_SPEECH ) ; hwAsrIntent . putExtra ( MLAsrConstants . LANGUAGE , "<STR_LIT>" ) ; hwAsrIntent . putExtra ( MLAsrConstants . FEATURE , MLAsrConstants . FEATURE_WORDFLUX ) ; hwAsrIntent . putExtra ( MLAsrConstants . VAD_START_MUTE_DURATION , <NUM_LIT> ) ; if ( autoStop ) hwAsrIntent . putExtra ( MLAsrConstants . VAD_END_MUTE_DURATION , <NUM_LIT> ) ; else hwAsrIntent . putExtra ( MLAsrConstants . VAD_END_MUTE_DURATION , <NUM_LIT> ) ; hwAsrIntent . putExtra ( MLAsrConstants . PUNCTUATION_ENABLE , true ) ; hwAsrRecognizer . startRecognizing ( hwAsrIntent ) ; } @ Override public void stopRecognize ( ) { hwAsrRecognizer . destroy ( ) ; } @ Override public void cancelRecognize ( ) { hwAsrRecognizer . destroy ( ) ; } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { hwAsrRecognizer . destroy ( ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . app . Activity ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public class InFileStream { private static Context context ; private static final String TAG = "<STR_LIT>" ; private static volatile String filename ; private static volatile InputStream is ; public static void setContext ( Context context ) { InFileStream . context = context ; } public static void setContext ( Context context , String filename ) { InFileStream . context = context ; InFileStream . filename = filename ; } public static void setContext ( Context context , InputStream is ) { InFileStream . context = context ; InFileStream . is = is ; } public static Context getContext ( ) { return context ; } public static void reset ( ) { filename = null ; is = null ; } public static InputStream createMyPipedInputStream ( ) { return InPipedStream . createAndStart ( context ) ; } public static InputStream create16kStream ( ) { if ( is == null && filename == null ) { return new FileAudioInputStream ( createFileStream ( ) ) ; } if ( is != null ) { return new FileAudioInputStream ( is ) ; } else if ( filename != null ) { try { return new FileAudioInputStream ( filename ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } return null ; } private static InputStream createFileStream ( ) { try { InputStream is = context . getAssets ( ) . open ( "<STR_LIT>" ) ; MyLogger . info ( TAG , "<STR_LIT>" + is . available ( ) ) ; return is ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import com . unfbx . chatgpt . OpenAiClient ; import com . unfbx . chatgpt . entity . whisper . WhisperResponse ; import java . io . File ; import java . util . Arrays ; import okhttp3 . ConnectionSpec ; import okhttp3 . OkHttpClient ; public class WhisperApiClient { String url = "<STR_LIT>" ; String apiKey = "<STR_LIT>" ; OkHttpClient httpClient = null ; OpenAiClient chatGPT = null ; Context context = null ; public WhisperApiClient ( Context context , String url , String apiKey ) { this . context = context ; httpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . readTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . writeTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . connectionSpecs ( Arrays . asList ( ConnectionSpec . CLEARTEXT , ConnectionSpec . COMPATIBLE_TLS ) ) . build ( ) ; setApiInfo ( url , apiKey ) ; } public void setApiInfo ( String url , String apiKey ) { if ( this . url . equals ( url ) && this . apiKey . equals ( apiKey ) ) { return ; } this . url = url ; this . apiKey = apiKey ; chatGPT = new OpenAiClient . Builder ( ) . apiKey ( Arrays . asList ( apiKey ) ) . apiHost ( url ) . okHttpClient ( httpClient ) . build ( ) ; } public String getWhisperResult ( File file ) throws Exception { if ( chatGPT == null ) { throw new Exception ( context . getString ( R . string . text_whisper_param_error ) ) ; } WhisperResponse whisperResponse = chatGPT . speechToTextTranscriptions ( file ) ; return whisperResponse . getText ( ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . util . Log ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; import java . util . LinkedHashMap ; import java . util . Map ; public class BaiduAsrClient extends AsrClientBase { private EventManager asr = null ; String asrBuffer = "<STR_LIT>" ; IAsrCallback callback = null ; EventListener listener = null ; boolean autoStop = false ; public BaiduAsrClient ( Context context ) { asr = EventManagerFactory . create ( context , "<STR_LIT>" ) ; listener = new EventListener ( ) { @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { Log . d ( "<STR_LIT>" , params ) ; try { JSONObject json = new JSONObject ( params ) ; String resultType = json . getString ( "<STR_LIT>" ) ; if ( resultType . equals ( "<STR_LIT>" ) ) { String bestResult = json . getString ( "<STR_LIT>" ) ; asrBuffer += bestResult ; callback . onResult ( asrBuffer ) ; } else if ( resultType . equals ( "<STR_LIT>" ) ) { String bestResult = json . getString ( "<STR_LIT>" ) ; callback . onResult ( String . format ( "<STR_LIT>" , asrBuffer , bestResult ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH ) ) { Log . d ( "<STR_LIT>" , params ) ; try { JSONObject json = new JSONObject ( params ) ; int errorCode = json . getInt ( "<STR_LIT>" ) ; if ( errorCode == <NUM_LIT> && autoStop ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; callback . onAutoStop ( ) ; } else if ( errorCode == <NUM_LIT> ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; startRecognize ( ) ; } else if ( errorCode != <NUM_LIT> ) { String errorMessage = json . getString ( "<STR_LIT>" ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + errorCode + "<STR_LIT>" + errorMessage ) ; callback . onError ( errorMessage ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } } ; asr . registerListener ( listener ) ; } @ Override public void startRecognize ( ) { Map < String , Object > params = new LinkedHashMap < > ( ) ; params . put ( SpeechConstant . APP_ID , GlobalDataHolder . getAsrAppId ( ) ) ; params . put ( SpeechConstant . APP_KEY , GlobalDataHolder . getAsrApiKey ( ) ) ; params . put ( SpeechConstant . SECRET , GlobalDataHolder . getAsrSecretKey ( ) ) ; if ( autoStop ) { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , false ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_DNN ) ; params . put ( SpeechConstant . VAD_ENDPOINT_TIMEOUT , <NUM_LIT> ) ; } else { if ( GlobalDataHolder . getAsrUseRealTime ( ) ) { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , true ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_DNN ) ; } else { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , false ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_TOUCH ) ; } } params . put ( SpeechConstant . PID , <NUM_LIT> ) ; asr . send ( SpeechConstant . ASR_START , ( new JSONObject ( params ) ) . toString ( ) , null , <NUM_LIT> , <NUM_LIT> ) ; asrBuffer = "<STR_LIT>" ; } @ Override public void stopRecognize ( ) { asr . send ( SpeechConstant . ASR_STOP , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void cancelRecognize ( ) { asr . send ( SpeechConstant . ASR_CANCEL , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { cancelRecognize ( ) ; asr . unregisterListener ( listener ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . TextView ; public class ConfirmDialog { Dialog dialog ; View dialogView ; public ConfirmDialog ( Context context ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; LayoutInflater inflater = LayoutInflater . from ( context ) ; dialogView = inflater . inflate ( R . layout . confirm_dialog , null ) ; dialog = builder . create ( ) ; setOnConfirmListener ( ( ) -> { } ) ; setOnCancelListener ( ( ) -> { } ) ; } public void show ( ) { dialog . show ( ) ; dialog . getWindow ( ) . setContentView ( dialogView ) ; } public void dismiss ( ) { dialog . dismiss ( ) ; } public View getContentView ( ) { return dialogView ; } public ConfirmDialog setOnConfirmListener ( Runnable listener ) { ( dialogView . findViewById ( R . id . cv_dialog_ok ) ) . setOnClickListener ( v -> { listener . run ( ) ; dialog . dismiss ( ) ; } ) ; return this ; } public ConfirmDialog setOnCancelListener ( Runnable listener ) { ( dialogView . findViewById ( R . id . cv_dialog_cancel ) ) . setOnClickListener ( v -> { listener . run ( ) ; dialog . dismiss ( ) ; } ) ; return this ; } public ConfirmDialog setContent ( String content ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_content ) ) . setText ( content ) ; return this ; } public ConfirmDialog setContentAlignment ( int alignment ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_content ) ) . setTextAlignment ( alignment ) ; return this ; } public ConfirmDialog setTitle ( String title ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_title ) ) . setText ( title ) ; return this ; } public ConfirmDialog setOkText ( String text ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_ok ) ) . setText ( text ) ; return this ; } public ConfirmDialog setCancelText ( String text ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_cancel ) ) . setText ( text ) ; return this ; } public ConfirmDialog setOkButtonVisibility ( int visibility ) { ( dialogView . findViewById ( R . id . cv_dialog_ok ) ) . setVisibility ( visibility ) ; return this ; } public ConfirmDialog setCancelButtonVisibility ( int visibility ) { ( dialogView . findViewById ( R . id . cv_dialog_cancel ) ) . setVisibility ( visibility ) ; return this ; } } </s>
<s> package com . skythinker . gptassistant ; import android . accessibilityservice . AccessibilityService ; import android . app . ActivityManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Intent ; import android . media . AudioManager ; import android . os . Handler ; import android . os . Vibrator ; import android . util . Log ; import android . view . KeyEvent ; import android . view . accessibility . AccessibilityEvent ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; import java . util . List ; public class MyAccessbilityService extends AccessibilityService { private static boolean isConnected = false ; private Handler handler = new Handler ( ) ; private int keyDownTime = <NUM_LIT> , keyUpTime = <NUM_LIT> ; private boolean isWaitingConfirm = false ; private int pressCount = <NUM_LIT> ; private boolean isPressing = false ; private boolean isBaned = false ; private boolean isInStartDelay = false ; AudioManager audioManager ; Vibrator vibrator ; final private int longPressTime = <NUM_LIT> ; final private int maxConfirmTime = <NUM_LIT> ; final private int banCancelInterval = <NUM_LIT> ; public MyAccessbilityService ( ) { } @ Override public void onAccessibilityEvent ( AccessibilityEvent accessibilityEvent ) { } @ Override public void onInterrupt ( ) { } @ Override protected boolean onKeyEvent ( KeyEvent event ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + event . toString ( ) ) ; if ( event . getKeyCode ( ) != KeyEvent . KEYCODE_VOLUME_DOWN ) { return super . onKeyEvent ( event ) ; } int eventTime = ( int ) event . getEventTime ( ) ; int eventAction = event . getAction ( ) ; if ( isBaned ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { keyDownTime = eventTime ; if ( eventTime - keyUpTime < banCancelInterval ) { return super . onKeyEvent ( event ) ; } else { isBaned = false ; } } else if ( eventAction == KeyEvent . ACTION_UP ) { keyUpTime = eventTime ; return super . onKeyEvent ( event ) ; } } if ( pressCount == <NUM_LIT> ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { keyDownTime = eventTime ; isPressing = true ; handler . postDelayed ( ( ) -> { if ( isPressing ) { if ( ! MainActivity . isAlive ( ) || ! MainActivity . isRunning ( ) ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; isInStartDelay = true ; handler . postDelayed ( ( ) -> { if ( isInStartDelay ) { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } } , <NUM_LIT> ) ; } else { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } vibrator . vibrate ( <NUM_LIT> ) ; } } , longPressTime ) ; return true ; } else if ( eventAction == KeyEvent . ACTION_UP ) { keyUpTime = eventTime ; isPressing = false ; isInStartDelay = false ; if ( eventTime - keyDownTime < longPressTime ) { isBaned = true ; audioManager . adjustVolume ( AudioManager . ADJUST_LOWER , AudioManager . FLAG_SHOW_UI ) ; return true ; } else { pressCount ++ ; Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; isWaitingConfirm = true ; handler . postDelayed ( ( ) -> { if ( isWaitingConfirm ) { pressCount = <NUM_LIT> ; } } , maxConfirmTime ) ; return true ; } } } else if ( pressCount == <NUM_LIT> ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { isWaitingConfirm = false ; keyDownTime = eventTime ; if ( eventTime - keyUpTime < maxConfirmTime ) { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; return true ; } else { return super . onKeyEvent ( event ) ; } } else if ( eventAction == KeyEvent . ACTION_UP ) { if ( keyDownTime - keyUpTime < maxConfirmTime ) { keyUpTime = eventTime ; pressCount = <NUM_LIT> ; return true ; } else { keyUpTime = eventTime ; pressCount = <NUM_LIT> ; return super . onKeyEvent ( event ) ; } } } return super . onKeyEvent ( event ) ; } @ Override protected void onServiceConnected ( ) { super . onServiceConnected ( ) ; isConnected = true ; audioManager = ( AudioManager ) getSystemService ( AUDIO_SERVICE ) ; vibrator = ( Vibrator ) getSystemService ( Service . VIBRATOR_SERVICE ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; isConnected = false ; } public static boolean isConnected ( ) { return isConnected ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . graphics . Bitmap ; import android . os . Handler ; import android . util . Log ; import android . view . View ; import android . webkit . RenderProcessGoneDetail ; import android . webkit . ValueCallback ; import android . webkit . WebResourceError ; import android . webkit . WebResourceRequest ; import android . webkit . WebSettings ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . LinearLayout ; import java . util . Arrays ; import java . util . List ; public class WebScraper { public interface Callback { void onLoadResult ( String result ) ; void onLoadFail ( String message ) ; } private class WebsiteRule { public String urlPattern = "<STR_LIT>" ; public String jsCode = "<STR_LIT>" ; public boolean desktopMode = false ; public int extraDelay = <NUM_LIT> ; public int timeout = <NUM_LIT> ; public WebsiteRule url ( String url ) { this . urlPattern = url ; return this ; } public WebsiteRule js ( String js ) { this . jsCode = js ; return this ; } public WebsiteRule desktopMode ( boolean desktopMode ) { this . desktopMode = desktopMode ; return this ; } public WebsiteRule extraDelay ( int extraDelay ) { this . extraDelay = extraDelay ; return this ; } public WebsiteRule timeout ( int timeout ) { this . timeout = timeout ; return this ; } } private class SearchListJsBuilder { private String outerSelector = "<STR_LIT>" ; private boolean outerAsInner = false ; private String innerSelector = "<STR_LIT>" ; private int innerIndex = <NUM_LIT> ; private String innerProperty = "<STR_LIT>" ; private int maxTextLength = Integer . MAX_VALUE ; private int maxLinkLength = Integer . MAX_VALUE ; public SearchListJsBuilder outerSelector ( String outerSelector ) { this . outerSelector = outerSelector ; return this ; } public SearchListJsBuilder outerAsInner ( boolean outerAsInner ) { this . outerAsInner = outerAsInner ; return this ; } public SearchListJsBuilder innerSelector ( String innerSelector ) { this . innerSelector = innerSelector ; return this ; } public SearchListJsBuilder innerIndex ( int innerIndex ) { this . innerIndex = innerIndex ; return this ; } public SearchListJsBuilder innerProperty ( String innerProperty ) { this . innerProperty = innerProperty ; return this ; } public SearchListJsBuilder maxTextLength ( int maxTextLength ) { this . maxTextLength = maxTextLength ; return this ; } public SearchListJsBuilder maxLinkLength ( int maxLinkLength ) { this . maxLinkLength = maxLinkLength ; return this ; } public String build ( ) { String js = "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; return js . replaceAll ( "<STR_LIT>" , outerSelector ) . replaceAll ( "<STR_LIT>" , String . valueOf ( outerAsInner ) ) . replaceAll ( "<STR_LIT>" , innerSelector ) . replaceAll ( "<STR_LIT>" , String . valueOf ( innerIndex ) ) . replaceAll ( "<STR_LIT>" , innerProperty ) . replaceAll ( "<STR_LIT>" , String . valueOf ( maxTextLength ) ) . replaceAll ( "<STR_LIT>" , String . valueOf ( maxLinkLength ) ) ; } } List < WebsiteRule > websiteRules = Arrays . asList ( new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . innerSelector ( "<STR_LIT>" ) . innerProperty ( "<STR_LIT>" ) . maxLinkLength ( <NUM_LIT> ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . outerAsInner ( true ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . outerAsInner ( true ) . maxTextLength ( <NUM_LIT> ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . extraDelay ( <NUM_LIT> ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) . url ( "<STR_LIT>" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( "<STR_LIT>" ) . build ( ) ) , new WebsiteRule ( ) ) ; Handler handler = null ; private WebView webView = null ; private WebViewClient webViewClient = null ; private String loadingUrl = "<STR_LIT>" ; private Callback callback = null ; private boolean isLoading = false ; private int jumpCount = <NUM_LIT> ; WebsiteRule websiteRule = null ; public WebScraper ( Context context , LinearLayout parentLayout ) { handler = new Handler ( context . getMainLooper ( ) ) ; webViewClient = new WebViewClient ( ) { private void endLoading ( ) { callback = null ; isLoading = false ; jumpCount = <NUM_LIT> ; loadingUrl = "<STR_LIT>" ; webView . stopLoading ( ) ; } @ Override public boolean shouldOverrideUrlLoading ( WebView view , WebResourceRequest request ) { String url = request . getUrl ( ) . toString ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + url ) ; if ( url . startsWith ( "<STR_LIT>" ) || url . startsWith ( "<STR_LIT>" ) || ! url . contains ( "<STR_LIT>" ) ) { view . loadUrl ( url ) ; jumpCount ++ ; loadingUrl = url ; } return true ; } @ Override public void onPageStarted ( WebView view , String url , Bitmap favicon ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; super . onPageStarted ( view , url , favicon ) ; } @ Override public void onPageFinished ( WebView view , String url ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" + url ) ; if ( jumpCount == <NUM_LIT> || url . equals ( loadingUrl ) ) { handler . postDelayed ( ( ) -> { if ( callback != null ) { webView . evaluateJavascript ( websiteRule . jsCode , new ValueCallback < String > ( ) { @ Override public void onReceiveValue ( String responseText ) { responseText = responseText . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( responseText . length ( ) > GlobalDataHolder . getWebMaxCharCount ( ) ) responseText = responseText . substring ( <NUM_LIT> , GlobalDataHolder . getWebMaxCharCount ( ) ) ; if ( responseText . isEmpty ( ) ) responseText = "<STR_LIT>" ; if ( callback != null ) callback . onLoadResult ( responseText ) ; else Log . e ( "<STR_LIT>" , "<STR_LIT>" ) ; endLoading ( ) ; } } ) ; } } , websiteRule . extraDelay ) ; loadingUrl = "<STR_LIT>" ; } if ( jumpCount > <NUM_LIT> ) jumpCount -- ; super . onPageFinished ( view , url ) ; } @ Override public void onReceivedError ( WebView view , WebResourceRequest request , WebResourceError error ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" + error . getErrorCode ( ) + "<STR_LIT>" + error . getDescription ( ) ) ; super . onReceivedError ( view , request , error ) ; } @ Override public boolean onRenderProcessGone ( WebView view , RenderProcessGoneDetail detail ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" + detail ) ; if ( callback != null ) callback . onLoadFail ( detail . toString ( ) ) ; endLoading ( ) ; return true ; } } ; try { WebView . setWebContentsDebuggingEnabled ( true ) ; webView = new WebView ( context ) ; WebSettings webSettings = webView . getSettings ( ) ; webSettings . setJavaScriptEnabled ( true ) ; webView . setWebViewClient ( webViewClient ) ; parentLayout . addView ( webView , <NUM_LIT> ) ; webView . setVisibility ( View . INVISIBLE ) ; webView . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , <NUM_LIT> ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void load ( String url , Callback callback ) { if ( webView == null ) return ; if ( isLoading ) stopLoading ( ) ; isLoading = true ; this . callback = callback ; jumpCount = <NUM_LIT> ; loadingUrl = url ; for ( WebsiteRule rule : websiteRules ) { if ( url . matches ( rule . urlPattern ) ) { websiteRule = rule ; break ; } } if ( websiteRule . desktopMode ) webView . getSettings ( ) . setUserAgentString ( "<STR_LIT>" + "<STR_LIT>" ) ; else webView . getSettings ( ) . setUserAgentString ( null ) ; new Thread ( ( ) -> { int timeout = websiteRule . timeout ; int waitTime = <NUM_LIT> ; while ( waitTime < timeout && isLoading ) { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException ignored ) { } waitTime += <NUM_LIT> ; } if ( isLoading ) { handler . post ( ( ) -> { if ( callback != null ) callback . onLoadFail ( "<STR_LIT>" ) ; stopLoading ( ) ; } ) ; Log . e ( "<STR_LIT>" , "<STR_LIT>" ) ; } } ) . start ( ) ; webView . loadUrl ( url ) ; } public void stopLoading ( ) { if ( webView == null ) return ; webView . stopLoading ( ) ; isLoading = false ; callback = null ; jumpCount = <NUM_LIT> ; loadingUrl = "<STR_LIT>" ; } public boolean isLoading ( ) { return isLoading ; } public void destroy ( ) { if ( webView == null ) return ; webView . destroy ( ) ; webView = null ; webViewClient = null ; callback = null ; isLoading = false ; jumpCount = <NUM_LIT> ; } } </s>
<s> package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . TextView ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import com . google . android . material . internal . TextWatcherAdapter ; import com . skythinker . gptassistant . ChatManager . Conversation ; import com . skythinker . gptassistant . ChatManager . ChatMessage ; public class HistoryActivity extends Activity { static private class HistoryListAdapter extends RecyclerView . Adapter < HistoryListAdapter . ViewHolder > { HistoryActivity historyActivity ; public HistoryListAdapter ( HistoryActivity historyActivity ) { this . historyActivity = historyActivity ; } @ Override public ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . history_list_item , parent , false ) ; return new HistoryListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ViewHolder holder , int position ) { Conversation conversation = historyActivity . chatManager . getConversationAtPosition ( position , historyActivity . searchKeyword ) ; holder . tvTitle . setText ( conversation . title ) ; holder . tvDetail . setText ( "<STR_LIT>" ) ; for ( ChatMessage message : conversation . messages ) { if ( message . role == ChatMessage . ChatRole . ASSISTANT && message . functionName == null ) { holder . tvDetail . setText ( message . contentText . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ) ; break ; } } LocalDateTime now = LocalDateTime . now ( ) ; if ( now . getYear ( ) == conversation . time . getYear ( ) && now . getMonthValue ( ) == conversation . time . getMonthValue ( ) && now . getDayOfMonth ( ) == conversation . time . getDayOfMonth ( ) ) holder . tvTime . setText ( conversation . time . format ( DateTimeFormatter . ofPattern ( "<STR_LIT>" ) ) ) ; else holder . tvTime . setText ( conversation . time . format ( DateTimeFormatter . ofPattern ( "<STR_LIT>" ) ) ) ; } @ Override public int getItemCount ( ) { return ( int ) historyActivity . chatManager . getConversationCount ( historyActivity . searchKeyword ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDetail , tvTime ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_history_item_title ) ; tvDetail = itemView . findViewById ( R . id . tv_history_item_detail ) ; tvTime = itemView . findViewById ( R . id . tv_history_item_time ) ; llOuter = itemView . findViewById ( R . id . ll_history_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . putExtra ( "<STR_LIT>" , historyActivity . chatManager . getConversationAtPosition ( getAdapterPosition ( ) , historyActivity . searchKeyword ) . id ) ; historyActivity . setResult ( RESULT_OK , intent ) ; historyActivity . finish ( ) ; } ) ; } } } private ChatManager chatManager ; private RecyclerView rvHistoryList ; private HistoryListAdapter historyListAdapter ; private String searchKeyword = null ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_history ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( "<STR_LIT>" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; chatManager = new ChatManager ( this ) ; chatManager . removeEmptyConversations ( ) ; rvHistoryList = findViewById ( R . id . rv_history_list ) ; rvHistoryList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; historyListAdapter = new HistoryListAdapter ( this ) ; rvHistoryList . setAdapter ( historyListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . LEFT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; chatManager . removeConversation ( chatManager . getConversationAtPosition ( position , searchKeyword ) . id ) ; historyListAdapter . notifyItemRemoved ( position ) ; } } ) . attachToRecyclerView ( rvHistoryList ) ; ( ( EditText ) findViewById ( R . id . et_history_search ) ) . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable editable ) { searchKeyword = editable . toString ( ) ; if ( searchKeyword . length ( ) == <NUM_LIT> ) searchKeyword = null ; historyListAdapter . notifyDataSetChanged ( ) ; } } ) ; ( findViewById ( R . id . bt_history_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ; ( findViewById ( R . id . bt_history_clear_all ) ) . setOnClickListener ( ( view ) -> { new ConfirmDialog ( this ) . setContent ( getString ( R . string . dialog_clear_history ) ) . setOnConfirmListener ( ( ) -> { chatManager . removeAllConversations ( ) ; historyListAdapter . notifyDataSetChanged ( ) ; } ) . show ( ) ; } ) ; } @ Override protected void onDestroy ( ) { chatManager . destroy ( ) ; super . onDestroy ( ) ; } @ Override public void finish ( ) { super . finish ( ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . util ; import com . baidu . speech . asr . SpeechConstant ; import java . util . LinkedHashMap ; import java . util . Map ; public class AuthUtil { public static String getAk ( ) { return "<STR_LIT>" ; } public static String getSk ( ) { return "<STR_LIT>" ; } public static String getAppId ( ) { return "<STR_LIT>" ; } public static Map < String , Object > getParam ( ) { Map < String , Object > params = new LinkedHashMap < String , Object > ( ) ; params . put ( SpeechConstant . APP_ID , getAppId ( ) ) ; params . put ( SpeechConstant . APP_KEY , getAk ( ) ) ; params . put ( SpeechConstant . SECRET , getSk ( ) ) ; return params ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import com . baidu . aip . asrwakeup3 . core . recog . listener . IRecogListener ; import com . baidu . aip . asrwakeup3 . core . recog . listener . RecogEventAdapter ; import java . util . Map ; public class MyRecognizer { private EventManager asr ; private EventListener eventListener ; private static boolean isOfflineEngineLoaded = false ; private static volatile boolean isInited = false ; private static final String TAG = "<STR_LIT>" ; public MyRecognizer ( Context context , IRecogListener recogListener ) { this ( context , new RecogEventAdapter ( recogListener ) ) ; } public MyRecognizer ( Context context , EventListener eventListener ) { if ( isInited ) { MyLogger . error ( TAG , "<STR_LIT>" ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } isInited = true ; this . eventListener = eventListener ; asr = EventManagerFactory . create ( context , "<STR_LIT>" ) ; asr . registerListener ( eventListener ) ; } public void loadOfflineEngine ( Map < String , Object > params ) { String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + "<STR_LIT>" , "<STR_LIT>" + json ) ; asr . send ( SpeechConstant . ASR_KWS_LOAD_ENGINE , json , null , <NUM_LIT> , <NUM_LIT> ) ; isOfflineEngineLoaded = true ; } public void start ( Map < String , Object > params ) { if ( ! isInited ) { throw new RuntimeException ( "<STR_LIT>" ) ; } String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + "<STR_LIT>" , "<STR_LIT>" + json ) ; asr . send ( SpeechConstant . ASR_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; } public void stop ( ) { MyLogger . info ( TAG , "<STR_LIT>" ) ; if ( ! isInited ) { throw new RuntimeException ( "<STR_LIT>" ) ; } asr . send ( SpeechConstant . ASR_STOP , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; } public void cancel ( ) { MyLogger . info ( TAG , "<STR_LIT>" ) ; if ( ! isInited ) { throw new RuntimeException ( "<STR_LIT>" ) ; } asr . send ( SpeechConstant . ASR_CANCEL , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; } public void release ( ) { if ( asr == null ) { return ; } cancel ( ) ; if ( isOfflineEngineLoaded ) { asr . send ( SpeechConstant . ASR_KWS_UNLOAD_ENGINE , null , null , <NUM_LIT> , <NUM_LIT> ) ; isOfflineEngineLoaded = false ; } asr . unregisterListener ( eventListener ) ; asr = null ; isInited = false ; } public void setEventListener ( IRecogListener recogListener ) { if ( ! isInited ) { throw new RuntimeException ( "<STR_LIT>" ) ; } this . eventListener = new RecogEventAdapter ( recogListener ) ; asr . registerListener ( eventListener ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . EventListener ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public class RecogEventAdapter implements EventListener { private IRecogListener listener ; private static final String TAG = "<STR_LIT>" ; public RecogEventAdapter ( IRecogListener listener ) { this . listener = listener ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String currentJson = params ; String logMessage = "<STR_LIT>" + name + "<STR_LIT>" + params ; Log . i ( TAG , logMessage ) ; if ( false ) { return ; } if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_LOADED ) ) { listener . onOfflineLoaded ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_UNLOADED ) ) { listener . onOfflineUnLoaded ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_READY ) ) { listener . onAsrReady ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_BEGIN ) ) { listener . onAsrBegin ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_END ) ) { listener . onAsrEnd ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { RecogResult recogResult = RecogResult . parseJson ( params ) ; String [ ] results = recogResult . getResultsRecognition ( ) ; if ( recogResult . isFinalResult ( ) ) { listener . onAsrFinalResult ( results , recogResult ) ; } else if ( recogResult . isPartialResult ( ) ) { listener . onAsrPartialResult ( results , recogResult ) ; } else if ( recogResult . isNluResult ( ) ) { listener . onAsrOnlineNluResult ( new String ( data , offset , length ) ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH ) ) { RecogResult recogResult = RecogResult . parseJson ( params ) ; if ( recogResult . hasError ( ) ) { int errorCode = recogResult . getError ( ) ; int subErrorCode = recogResult . getSubError ( ) ; MyLogger . error ( TAG , "<STR_LIT>" + params ) ; listener . onAsrFinishError ( errorCode , subErrorCode , recogResult . getDesc ( ) , recogResult ) ; } else { listener . onAsrFinish ( recogResult ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_LONG_SPEECH ) ) { listener . onAsrLongFinish ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_EXIT ) ) { listener . onAsrExit ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_VOLUME ) ) { Volume vol = parseVolumeJson ( params ) ; listener . onAsrVolume ( vol . volumePercent , vol . volume ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_AUDIO ) ) { if ( data . length != length ) { MyLogger . error ( TAG , "<STR_LIT>" ) ; } listener . onAsrAudio ( data , offset , length ) ; } } private Volume parseVolumeJson ( String jsonStr ) { Volume vol = new Volume ( ) ; vol . origalJson = jsonStr ; try { JSONObject json = new JSONObject ( jsonStr ) ; vol . volumePercent = json . getInt ( "<STR_LIT>" ) ; vol . volume = json . getInt ( "<STR_LIT>" ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return vol ; } private class Volume { private int volumePercent = - <NUM_LIT> ; private int volume = - <NUM_LIT> ; private String origalJson ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog . listener ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public interface IRecogListener { void onAsrReady ( ) ; void onAsrBegin ( ) ; void onAsrEnd ( ) ; void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) ; void onAsrOnlineNluResult ( String nluResult ) ; void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) ; void onAsrFinish ( RecogResult recogResult ) ; void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) ; void onAsrLongFinish ( ) ; void onAsrVolume ( int volumePercent , int volume ) ; void onAsrAudio ( byte [ ] data , int offset , int length ) ; void onAsrExit ( ) ; void onOfflineLoaded ( ) ; void onOfflineUnLoaded ( ) ; } </s>
<s> package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class HeadsetReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( AudioManager . ACTION_HEADSET_PLUG ) ) { int state = intent . getIntExtra ( "<STR_LIT>" , <NUM_LIT> ) ; String name = intent . getStringExtra ( "<STR_LIT>" ) ; int hasMicrophone = intent . getIntExtra ( "<STR_LIT>" , <NUM_LIT> ) ; if ( state == <NUM_LIT> ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + name ) ; } else if ( state == <NUM_LIT> ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + name ) ; if ( hasMicrophone == <NUM_LIT> ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + name + "<STR_LIT>" ) ; } } else { Log . w ( "<STR_LIT>" , "<STR_LIT>" + state ) ; } AndroidAudioManager . getInstance ( context ) . routeAudioToEarPiece ( ) ; } else if ( action . equals ( AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; AndroidAudioManager . getInstance ( context ) . routeAudioToEarPiece ( ) ; } else { Log . w ( "<STR_LIT>" , "<STR_LIT>" + action ) ; } } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . util . Log ; import android . util . Pair ; import androidx . annotation . Nullable ; import com . unfbx . chatgpt . OpenAiStreamClient ; import com . unfbx . chatgpt . entity . chat . BaseChatCompletion ; import com . unfbx . chatgpt . entity . chat . ChatCompletionWithPicture ; import com . unfbx . chatgpt . entity . chat . Content ; import com . unfbx . chatgpt . entity . chat . FunctionCall ; import com . unfbx . chatgpt . entity . chat . Functions ; import com . unfbx . chatgpt . entity . chat . ImageUrl ; import com . unfbx . chatgpt . entity . chat . Message ; import com . unfbx . chatgpt . entity . chat . ChatCompletion ; import com . unfbx . chatgpt . entity . chat . MessagePicture ; import com . unfbx . chatgpt . entity . chat . Parameters ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import cn . hutool . json . JSONObject ; import okhttp3 . ConnectionSpec ; import okhttp3 . OkHttpClient ; import okhttp3 . Response ; import okhttp3 . internal . http2 . StreamResetException ; import okhttp3 . sse . EventSource ; import okhttp3 . sse . EventSourceListener ; import com . skythinker . gptassistant . ChatManager . ChatMessage . ChatRole ; import com . skythinker . gptassistant . ChatManager . ChatMessage ; import com . unfbx . chatgpt . entity . whisper . WhisperResponse ; public class ChatApiClient { public interface OnReceiveListener { void onMsgReceive ( String message ) ; void onError ( String message ) ; void onFunctionCall ( String name , String arg ) ; void onFinished ( boolean completed ) ; } String url = "<STR_LIT>" ; String apiKey = "<STR_LIT>" ; String model = "<STR_LIT>" ; OnReceiveListener listener = null ; OkHttpClient httpClient = null ; OpenAiStreamClient chatGPT = null ; List < Functions > functions = new ArrayList < > ( ) ; String callingFuncName = "<STR_LIT>" ; String callingFuncArg = "<STR_LIT>" ; Context context = null ; public ChatApiClient ( Context context , String url , String apiKey , String model , OnReceiveListener listener ) { this . context = context ; this . listener = listener ; this . model = model ; httpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . readTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . writeTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . connectionSpecs ( Arrays . asList ( ConnectionSpec . CLEARTEXT , ConnectionSpec . COMPATIBLE_TLS ) ) . build ( ) ; setApiInfo ( url , apiKey ) ; } public void sendPromptList ( List < ChatMessage > promptList ) { if ( url . isEmpty ( ) ) { listener . onError ( "<STR_LIT>" ) ; return ; } else if ( apiKey . isEmpty ( ) ) { listener . onError ( "<STR_LIT>" ) ; return ; } else if ( chatGPT == null ) { listener . onError ( "<STR_LIT>" ) ; return ; } BaseChatCompletion chatCompletion = null ; if ( ! GlobalUtils . checkVisionSupport ( model ) ) { ArrayList < Message > messageList = new ArrayList < > ( ) ; for ( ChatMessage message : promptList ) { if ( message . role == ChatRole . SYSTEM ) { messageList . add ( Message . builder ( ) . role ( Message . Role . SYSTEM ) . content ( message . contentText ) . build ( ) ) ; } else if ( message . role == ChatRole . USER ) { messageList . add ( Message . builder ( ) . role ( Message . Role . USER ) . content ( message . contentText ) . build ( ) ) ; } else if ( message . role == ChatRole . ASSISTANT ) { if ( message . functionName != null ) { FunctionCall functionCall = FunctionCall . builder ( ) . name ( message . functionName ) . arguments ( message . contentText ) . build ( ) ; messageList . add ( Message . builder ( ) . role ( Message . Role . ASSISTANT ) . functionCall ( functionCall ) . build ( ) ) ; } else { messageList . add ( Message . builder ( ) . role ( Message . Role . ASSISTANT ) . content ( message . contentText ) . build ( ) ) ; } } else if ( message . role == ChatRole . FUNCTION ) { messageList . add ( Message . builder ( ) . role ( Message . Role . FUNCTION ) . name ( message . functionName ) . content ( message . contentText ) . build ( ) ) ; } } if ( ! functions . isEmpty ( ) ) { chatCompletion = ChatCompletion . builder ( ) . messages ( messageList ) . model ( model ) . functions ( functions ) . functionCall ( "<STR_LIT>" ) . build ( ) ; } else { chatCompletion = ChatCompletion . builder ( ) . messages ( messageList ) . model ( model ) . build ( ) ; } } else { ArrayList < MessagePicture > messageList = new ArrayList < > ( ) ; for ( ChatMessage message : promptList ) { List < Content > contentList = new ArrayList < > ( ) ; if ( message . contentText != null ) { contentList . add ( Content . builder ( ) . type ( Content . Type . TEXT . getName ( ) ) . text ( message . contentText ) . build ( ) ) ; } if ( message . contentImageBase64 != null ) { ImageUrl imageUrl = ImageUrl . builder ( ) . url ( "<STR_LIT>" + message . contentImageBase64 ) . build ( ) ; contentList . add ( Content . builder ( ) . type ( Content . Type . IMAGE_URL . getName ( ) ) . imageUrl ( imageUrl ) . build ( ) ) ; } if ( message . role == ChatRole . SYSTEM ) { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . SYSTEM ) . content ( contentList ) . build ( ) ) ; } else if ( message . role == ChatRole . USER ) { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . USER ) . content ( contentList ) . build ( ) ) ; } else if ( message . role == ChatRole . ASSISTANT ) { if ( message . functionName != null ) { FunctionCall functionCall = FunctionCall . builder ( ) . name ( message . functionName ) . arguments ( message . contentText ) . build ( ) ; messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . ASSISTANT ) . functionCall ( functionCall ) . build ( ) ) ; } else { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . ASSISTANT ) . content ( contentList ) . build ( ) ) ; } } else if ( message . role == ChatRole . FUNCTION ) { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . FUNCTION ) . name ( message . functionName ) . content ( contentList ) . build ( ) ) ; } } chatCompletion = ChatCompletionWithPicture . builder ( ) . messages ( messageList ) . model ( model . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ) . build ( ) ; } callingFuncName = callingFuncArg = "<STR_LIT>" ; chatGPT . streamChatCompletion ( chatCompletion , new EventSourceListener ( ) { @ Override public void onOpen ( EventSource eventSource , Response response ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } @ Override public void onEvent ( EventSource eventSource , @ Nullable String id , @ Nullable String type , String data ) { if ( data . equals ( "<STR_LIT>" ) ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( callingFuncName . isEmpty ( ) ) { listener . onFinished ( true ) ; } else { listener . onFunctionCall ( callingFuncName , callingFuncArg ) ; } } else { JSONObject json = new JSONObject ( data ) ; if ( json . containsKey ( "<STR_LIT>" ) && json . getJSONArray ( "<STR_LIT>" ) . size ( ) > <NUM_LIT> ) { JSONObject delta = ( ( JSONObject ) json . getJSONArray ( "<STR_LIT>" ) . get ( <NUM_LIT> ) ) . getJSONObject ( "<STR_LIT>" ) ; if ( delta != null ) { if ( delta . containsKey ( "<STR_LIT>" ) ) { JSONObject functionCall = delta . getJSONObject ( "<STR_LIT>" ) ; if ( functionCall . containsKey ( "<STR_LIT>" ) ) callingFuncName = functionCall . getStr ( "<STR_LIT>" ) ; callingFuncArg += functionCall . getStr ( "<STR_LIT>" ) ; } else if ( delta . containsKey ( "<STR_LIT>" ) ) { String msg = delta . getStr ( "<STR_LIT>" ) ; if ( msg != null ) listener . onMsgReceive ( msg ) ; } } } } } @ Override public void onClosed ( EventSource eventSource ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } @ Override public void onFailure ( EventSource eventSource , @ Nullable Throwable throwable , @ Nullable Response response ) { if ( throwable != null ) { if ( throwable instanceof StreamResetException ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; listener . onFinished ( false ) ; } else { String err = throwable . toString ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + err + "<STR_LIT>" + Log . getStackTraceString ( throwable ) ) ; if ( err . equals ( "<STR_LIT>" ) ) { err = context . getString ( R . string . text_gpt_cancel ) ; } else if ( err . equals ( "<STR_LIT>" ) ) { err = context . getString ( R . string . text_gpt_timeout ) ; } listener . onError ( err ) ; } } else { if ( response != null && response . body ( ) != null ) { try { String err = response . body ( ) . string ( ) ; if ( err . length ( ) > <NUM_LIT> ) { err = err . substring ( <NUM_LIT> , <NUM_LIT> ) ; err += "<STR_LIT>" ; } listener . onError ( err ) ; } catch ( IOException ignore ) { } } else { listener . onError ( context . getString ( R . string . text_gpt_unknown_error ) ) ; } } } } ) ; } public void setApiInfo ( String url , String apiKey ) { if ( this . url . equals ( url ) && this . apiKey . equals ( apiKey ) ) { return ; } this . url = url ; this . apiKey = apiKey ; chatGPT = new OpenAiStreamClient . Builder ( ) . apiKey ( Arrays . asList ( apiKey ) ) . apiHost ( url ) . okHttpClient ( httpClient ) . build ( ) ; } public boolean isStreaming ( ) { return httpClient . connectionPool ( ) . connectionCount ( ) - httpClient . connectionPool ( ) . idleConnectionCount ( ) > <NUM_LIT> ; } public void stop ( ) { httpClient . dispatcher ( ) . cancelAll ( ) ; } public void setModel ( String model ) { this . model = model ; } public void addFunction ( String name , String desc , String params , String [ ] required ) { removeFunction ( name ) ; Parameters parameters = Parameters . builder ( ) . type ( "<STR_LIT>" ) . properties ( new JSONObject ( params ) ) . required ( Arrays . asList ( required ) ) . build ( ) ; Functions functions = Functions . builder ( ) . name ( name ) . description ( desc ) . parameters ( parameters ) . build ( ) ; this . functions . add ( functions ) ; } public void removeFunction ( String name ) { for ( int i = <NUM_LIT> ; i < this . functions . size ( ) ; i ++ ) { if ( this . functions . get ( i ) . getName ( ) . equals ( name ) ) { this . functions . remove ( i ) ; break ; } } } public void clearAllFunctions ( ) { this . functions . clear ( ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . Manifest ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . BroadcastReceiver ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . pm . PackageManager ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Color ; import android . graphics . Rect ; import android . graphics . Typeface ; import android . graphics . drawable . PaintDrawable ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . provider . MediaStore ; import android . provider . Settings ; import android . speech . tts . TextToSpeech ; import android . speech . tts . UtteranceProgressListener ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . method . LinkMovementMethod ; import android . text . style . ImageSpan ; import android . util . Base64 ; import android . util . Log ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . view . inputmethod . InputMethodManager ; import android . widget . AdapterView ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . PopupWindow ; import android . widget . ScrollView ; import android . widget . Spinner ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . cardview . widget . CardView ; import androidx . core . content . ContextCompat ; import androidx . core . content . FileProvider ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . net . URLDecoder ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Locale ; import java . util . UUID ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONException ; import cn . hutool . json . JSONObject ; import io . noties . markwon . AbstractMarkwonPlugin ; import io . noties . markwon . Markwon ; import io . noties . markwon . MarkwonConfiguration ; import io . noties . markwon . ext . latex . JLatexMathPlugin ; import io . noties . markwon . ext . tables . TableAwareMovementMethod ; import io . noties . markwon . ext . tables . TablePlugin ; import io . noties . markwon . image . ImageSize ; import io . noties . markwon . image . ImageSizeResolverDef ; import io . noties . markwon . image . ImagesPlugin ; import io . noties . markwon . inlineparser . MarkwonInlineParserPlugin ; import io . noties . markwon . linkify . LinkifyPlugin ; import io . noties . markwon . movement . MovementMethodPlugin ; import io . noties . markwon . syntax . Prism4jThemeDefault ; import io . noties . markwon . syntax . SyntaxHighlightPlugin ; import io . noties . prism4j . Prism4j ; import io . noties . prism4j . annotations . PrismBundle ; import com . skythinker . gptassistant . ChatManager . ChatMessage . ChatRole ; import com . skythinker . gptassistant . ChatManager . ChatMessage ; import com . skythinker . gptassistant . ChatManager . MessageList ; import com . skythinker . gptassistant . ChatManager . Conversation ; @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ) @ PrismBundle ( includeAll = true ) public class MainActivity extends Activity { private int selectedTab = <NUM_LIT> ; private TextView tvGptReply ; private EditText etUserInput ; private ImageButton btSend , btImage ; private ScrollView svChatArea ; private LinearLayout llChatList ; private PopupWindow pwMenu ; private Handler handler ; private MarkdownRenderer markdownRenderer ; private long asrStartTime = <NUM_LIT> ; BroadcastReceiver localReceiver = null ; private static boolean isAlive = false ; private static boolean isRunning = false ; ChatApiClient chatApiClient = null ; private String chatApiBuffer = "<STR_LIT>" ; private TextToSpeech tts = null ; private boolean ttsEnabled = true ; final private List < String > ttsSentenceSeparator = Arrays . asList ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; private int ttsSentenceEndIndex = <NUM_LIT> ; private String ttsLastId = "<STR_LIT>" ; private boolean multiChat = false ; ChatManager chatManager = null ; private Conversation currentConversation = null ; private MessageList multiChatList = null ; private boolean multiVoice = false ; private JSONObject currentTemplateParams = null ; AsrClientBase asrClient = null ; AsrClientBase . IAsrCallback asrCallback = null ; WebScraper webScraper = null ; Bitmap selectedImageBitmap = null ; Uri photoUri = null ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Thread . setDefaultUncaughtExceptionHandler ( new Thread . UncaughtExceptionHandler ( ) { @ Override public void uncaughtException ( @ NonNull Thread thread , @ NonNull Throwable throwable ) { Log . e ( "<STR_LIT>" , thread . getClass ( ) . getName ( ) + "<STR_LIT>" + throwable . getMessage ( ) ) ; throwable . printStackTrace ( ) ; System . exit ( - <NUM_LIT> ) ; } } ) ; handler = new Handler ( ) ; GlobalDataHolder . init ( this ) ; markdownRenderer = new MarkdownRenderer ( this ) ; tts = new TextToSpeech ( this , status -> { if ( status == TextToSpeech . SUCCESS ) { int res = tts . setLanguage ( Locale . getDefault ( ) ) ; if ( res == TextToSpeech . LANG_MISSING_DATA || res == TextToSpeech . LANG_NOT_SUPPORTED ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" ) ; } else { tts . setOnUtteranceProgressListener ( new UtteranceProgressListener ( ) { @ Override public void onStart ( String utteranceId ) { } @ Override public void onDone ( String utteranceId ) { if ( ttsLastId . equals ( utteranceId ) && ! chatApiClient . isStreaming ( ) ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( multiVoice ) { Intent intent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( MainActivity . this ) . sendBroadcast ( intent ) ; } } } @ Override public void onError ( String utteranceId ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" + utteranceId ) ; } } ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } } else { Log . e ( "<STR_LIT>" , "<STR_LIT>" + status ) ; } } ) ; setContentView ( R . layout . activity_main ) ; overridePendingTransition ( R . anim . translate_up_in , R . anim . translate_down_out ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . TRANSPARENT ) ; tvGptReply = findViewById ( R . id . tv_chat_notice ) ; tvGptReply . setTextIsSelectable ( true ) ; tvGptReply . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; etUserInput = findViewById ( R . id . et_user_input ) ; btSend = findViewById ( R . id . bt_send ) ; btImage = findViewById ( R . id . bt_image ) ; svChatArea = findViewById ( R . id . sv_chat_list ) ; llChatList = findViewById ( R . id . ll_chat_list ) ; Intent activityIntent = getIntent ( ) ; if ( activityIntent != null ) { String action = activityIntent . getAction ( ) ; if ( Intent . ACTION_PROCESS_TEXT . equals ( action ) ) { String text = activityIntent . getStringExtra ( Intent . EXTRA_PROCESS_TEXT ) ; if ( text != null ) { etUserInput . setText ( text ) ; } } else if ( Intent . ACTION_SEND . equals ( action ) ) { String type = activityIntent . getType ( ) ; if ( type != null && type . startsWith ( "<STR_LIT>" ) ) { Uri imageUri = activityIntent . getParcelableExtra ( Intent . EXTRA_STREAM ) ; if ( imageUri != null ) { try { Bitmap bitmap = ( Bitmap ) BitmapFactory . decodeStream ( getContentResolver ( ) . openInputStream ( imageUri ) ) ; selectedImageBitmap = bitmap ; if ( GlobalDataHolder . getLimitVisionSize ( ) ) { if ( bitmap . getWidth ( ) < bitmap . getHeight ( ) ) selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; else selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; } else { selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; } btImage . setImageResource ( R . drawable . image_enabled ) ; if ( ! GlobalUtils . checkVisionSupport ( GlobalDataHolder . getGptModel ( ) ) ) Toast . makeText ( this , R . string . toast_use_vision_model , Toast . LENGTH_LONG ) . show ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } } else if ( type != null && type . equals ( "<STR_LIT>" ) ) { String text = activityIntent . getStringExtra ( Intent . EXTRA_TEXT ) ; if ( text != null ) { etUserInput . setText ( text ) ; } } } } chatManager = new ChatManager ( this ) ; ChatMessage . setContext ( this ) ; webScraper = new WebScraper ( this , findViewById ( R . id . ll_main_base ) ) ; chatApiClient = new ChatApiClient ( this , GlobalDataHolder . getGptApiHost ( ) , GlobalDataHolder . getGptApiKey ( ) , GlobalDataHolder . getGptModel ( ) , new ChatApiClient . OnReceiveListener ( ) { private long lastRenderTime = <NUM_LIT> ; @ Override public void onMsgReceive ( String message ) { chatApiBuffer += message ; handler . post ( ( ) -> { if ( System . currentTimeMillis ( ) - lastRenderTime > <NUM_LIT> ) { boolean isBottom = svChatArea . getChildAt ( <NUM_LIT> ) . getBottom ( ) <= svChatArea . getHeight ( ) + svChatArea . getScrollY ( ) ; markdownRenderer . render ( tvGptReply , chatApiBuffer ) ; if ( isBottom ) { scrollChatAreaToBottom ( ) ; } lastRenderTime = System . currentTimeMillis ( ) ; } if ( currentTemplateParams . getBool ( "<STR_LIT>" , ttsEnabled ) ) { String wholeText = tvGptReply . getText ( ) . toString ( ) ; if ( ttsSentenceEndIndex < wholeText . length ( ) ) { int nextSentenceEndIndex = wholeText . length ( ) ; boolean found = false ; for ( String separator : ttsSentenceSeparator ) { int index = wholeText . indexOf ( separator , ttsSentenceEndIndex ) ; if ( index != - <NUM_LIT> && index < nextSentenceEndIndex ) { nextSentenceEndIndex = index + separator . length ( ) ; found = true ; } } if ( found ) { String sentence = wholeText . substring ( ttsSentenceEndIndex , nextSentenceEndIndex ) ; ttsSentenceEndIndex = nextSentenceEndIndex ; String id = UUID . randomUUID ( ) . toString ( ) ; tts . speak ( sentence , TextToSpeech . QUEUE_ADD , null , id ) ; ttsLastId = id ; } } } } ) ; } @ Override public void onFinished ( boolean completed ) { handler . post ( ( ) -> { String referenceStr = "<STR_LIT>" + getString ( R . string . text_ref_web_prefix ) ; int referenceCount = <NUM_LIT> ; if ( completed ) { int questionIndex = multiChatList . size ( ) - <NUM_LIT> ; while ( questionIndex >= <NUM_LIT> && multiChatList . get ( questionIndex ) . role != ChatRole . USER ) { questionIndex -- ; } for ( int i = questionIndex + <NUM_LIT> ; i < multiChatList . size ( ) ; i ++ ) { if ( multiChatList . get ( i ) . role == ChatRole . FUNCTION && multiChatList . get ( i - <NUM_LIT> ) . role == ChatRole . ASSISTANT && multiChatList . get ( i - <NUM_LIT> ) . functionName != null ) { String funcName = multiChatList . get ( i - <NUM_LIT> ) . functionName ; String funcArgs = multiChatList . get ( i - <NUM_LIT> ) . contentText ; if ( funcName . equals ( "<STR_LIT>" ) ) { String url = new JSONObject ( funcArgs ) . getStr ( "<STR_LIT>" ) ; referenceStr += String . format ( "<STR_LIT>" , ++ referenceCount , url ) ; } } } } try { markdownRenderer . render ( tvGptReply , chatApiBuffer ) ; String ttsText = tvGptReply . getText ( ) . toString ( ) ; if ( currentTemplateParams . getBool ( "<STR_LIT>" , ttsEnabled ) && ttsText . length ( ) > ttsSentenceEndIndex ) { String id = UUID . randomUUID ( ) . toString ( ) ; tts . speak ( ttsText . substring ( ttsSentenceEndIndex ) , TextToSpeech . QUEUE_ADD , null , id ) ; ttsLastId = id ; } if ( referenceCount > <NUM_LIT> ) chatApiBuffer += referenceStr ; multiChatList . add ( new ChatMessage ( ChatRole . ASSISTANT ) . setText ( chatApiBuffer ) ) ; ( ( LinearLayout ) tvGptReply . getParent ( ) ) . setTag ( multiChatList . get ( multiChatList . size ( ) - <NUM_LIT> ) ) ; markdownRenderer . render ( tvGptReply , chatApiBuffer ) ; btSend . setImageResource ( R . drawable . send_btn ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ; } @ Override public void onError ( String message ) { handler . post ( ( ) -> { String errText = String . format ( getString ( R . string . text_gpt_error_prefix ) + "<STR_LIT>" , message ) ; if ( tvGptReply != null ) { tvGptReply . setText ( errText ) ; } else { Toast . makeText ( MainActivity . this , errText , Toast . LENGTH_LONG ) . show ( ) ; } btSend . setImageResource ( R . drawable . send_btn ) ; } ) ; } @ Override public void onFunctionCall ( String name , String arg ) { Log . d ( "<STR_LIT>" , String . format ( "<STR_LIT>" , name , arg ) ) ; multiChatList . add ( new ChatMessage ( ChatRole . ASSISTANT ) . setFunction ( name ) . setText ( arg ) ) ; if ( name . equals ( "<STR_LIT>" ) ) { try { JSONObject argJson = new JSONObject ( arg ) ; String url = argJson . getStr ( "<STR_LIT>" ) ; runOnUiThread ( ( ) -> { markdownRenderer . render ( tvGptReply , String . format ( getString ( R . string . text_visiting_web_prefix ) + "<STR_LIT>" , URLDecoder . decode ( url ) , url ) ) ; webScraper . load ( url , new WebScraper . Callback ( ) { @ Override public void onLoadResult ( String result ) { postSendFunctionReply ( name , result ) ; } @ Override public void onLoadFail ( String message ) { postSendFunctionReply ( name , "<STR_LIT>" ) ; } } ) ; Log . d ( "<STR_LIT>" , String . format ( "<STR_LIT>" , url ) ) ; } ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; postSendFunctionReply ( name , "<STR_LIT>" ) ; } } else if ( name . equals ( "<STR_LIT>" ) ) { if ( multiVoice ) runOnUiThread ( ( ) -> findViewById ( R . id . cv_voice_chat ) . performClick ( ) ) ; } else { postSendFunctionReply ( name , "<STR_LIT>" ) ; Log . d ( "<STR_LIT>" , String . format ( "<STR_LIT>" , name ) ) ; } } } ) ; btSend . setOnClickListener ( view -> { if ( chatApiClient . isStreaming ( ) ) { chatApiClient . stop ( ) ; } else if ( webScraper . isLoading ( ) ) { webScraper . stopLoading ( ) ; if ( tvGptReply != null ) tvGptReply . setText ( R . string . text_cancel_web ) ; btSend . setImageResource ( R . drawable . send_btn ) ; } else { tts . stop ( ) ; sendQuestion ( null ) ; etUserInput . setText ( "<STR_LIT>" ) ; } } ) ; btImage . setOnClickListener ( view -> { if ( selectedImageBitmap != null ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; LayoutInflater inflater = LayoutInflater . from ( this ) ; View dialogView = inflater . inflate ( R . layout . image_preview_dialog , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; dialog . getWindow ( ) . setContentView ( dialogView ) ; ( ( ImageView ) dialogView . findViewById ( R . id . iv_image_preview ) ) . setImageBitmap ( selectedImageBitmap ) ; ( ( TextView ) dialogView . findViewById ( R . id . tv_image_preview_size ) ) . setText ( String . format ( "<STR_LIT>" , selectedImageBitmap . getWidth ( ) , selectedImageBitmap . getHeight ( ) ) ) ; dialogView . findViewById ( R . id . bt_image_preview_cancel ) . setOnClickListener ( view1 -> dialog . dismiss ( ) ) ; dialogView . findViewById ( R . id . bt_image_preview_del ) . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; selectedImageBitmap = null ; btImage . setImageResource ( R . drawable . image ) ; } ) ; dialogView . findViewById ( R . id . bt_image_preview_reselect ) . setOnClickListener ( view1 -> { dialogView . findViewById ( R . id . bt_image_preview_del ) . performClick ( ) ; btImage . performClick ( ) ; } ) ; } else { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; LayoutInflater inflater = LayoutInflater . from ( this ) ; View dialogView = inflater . inflate ( R . layout . image_method_dialog , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; dialog . getWindow ( ) . setContentView ( dialogView ) ; dialogView . findViewById ( R . id . bt_take_photo ) . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; photoUri = FileProvider . getUriForFile ( MainActivity . this , BuildConfig . APPLICATION_ID + "<STR_LIT>" , new File ( getCacheDir ( ) , "<STR_LIT>" ) ) ; Intent intent = new Intent ( ) ; intent . setAction ( MediaStore . ACTION_IMAGE_CAPTURE ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , photoUri ) ; startActivityForResult ( intent , <NUM_LIT> ) ; } ) ; dialogView . findViewById ( R . id . bt_select_from_album ) . setOnClickListener ( view1 -> { dialog . dismiss ( ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . setType ( "<STR_LIT>" ) ; startActivityForResult ( intent , <NUM_LIT> ) ; } ) ; dialogView . findViewById ( R . id . bt_image_cancel ) . setOnClickListener ( view1 -> dialog . dismiss ( ) ) ; } } ) ; etUserInput . setOnLongClickListener ( view -> { if ( etUserInput . getText ( ) . toString ( ) . equals ( "<STR_LIT>" ) ) { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; view . setTag ( "<STR_LIT>" ) ; } else { etUserInput . setText ( "<STR_LIT>" ) ; } return true ; } ) ; etUserInput . setOnTouchListener ( ( view , motionEvent ) -> { if ( motionEvent . getAction ( ) == MotionEvent . ACTION_UP ) { if ( "<STR_LIT>" . equals ( view . getTag ( ) ) ) { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; view . setTag ( null ) ; } } return false ; } ) ; ( findViewById ( R . id . cv_multi_chat ) ) . setOnClickListener ( view -> { multiChat = ! multiChat ; if ( multiChat ) { ( ( CardView ) findViewById ( R . id . cv_multi_chat ) ) . setForeground ( getDrawable ( R . drawable . chat_btn_enabled ) ) ; GlobalUtils . showToast ( this , R . string . toast_multi_chat_on , false ) ; } else { ( ( CardView ) findViewById ( R . id . cv_multi_chat ) ) . setForeground ( getDrawable ( R . drawable . chat_btn ) ) ; GlobalUtils . showToast ( this , R . string . toast_multi_chat_off , false ) ; } } ) ; ( findViewById ( R . id . cv_new_chat ) ) . setOnClickListener ( view -> { clearChatListView ( ) ; if ( currentConversation != null && ( ( multiChatList . size ( ) > <NUM_LIT> && multiChatList . get ( <NUM_LIT> ) . role != ChatRole . SYSTEM ) || ( multiChatList . size ( ) > <NUM_LIT> && multiChatList . get ( <NUM_LIT> ) . role == ChatRole . SYSTEM ) ) && GlobalDataHolder . getAutoSaveHistory ( ) ) chatManager . addConversation ( currentConversation ) ; currentConversation = new Conversation ( ) ; multiChatList = currentConversation . messages ; } ) ; View menuView = LayoutInflater . from ( this ) . inflate ( R . layout . main_popup_menu , null ) ; pwMenu = new PopupWindow ( menuView , ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT , true ) ; pwMenu . setOutsideTouchable ( true ) ; ( findViewById ( R . id . cv_new_chat ) ) . performClick ( ) ; ( findViewById ( R . id . cv_tts_off ) ) . setOnClickListener ( view -> { ttsEnabled = ! ttsEnabled ; if ( ttsEnabled ) { ( ( CardView ) findViewById ( R . id . cv_tts_off ) ) . setForeground ( getDrawable ( R . drawable . tts_off ) ) ; GlobalUtils . showToast ( this , R . string . toast_tts_on , false ) ; } else { ( ( CardView ) findViewById ( R . id . cv_tts_off ) ) . setForeground ( getDrawable ( R . drawable . tts_off_enable ) ) ; GlobalUtils . showToast ( this , R . string . toast_tts_off , false ) ; tts . stop ( ) ; } } ) ; ( findViewById ( R . id . cv_voice_chat ) ) . setOnClickListener ( view -> { if ( ! multiVoice && ! ttsEnabled ) { GlobalUtils . showToast ( this , R . string . toast_voice_chat_tts_off , false ) ; return ; } multiVoice = ! multiVoice ; if ( multiVoice ) { ( ( CardView ) findViewById ( R . id . cv_voice_chat ) ) . setForeground ( getDrawable ( R . drawable . voice_chat_btn_enabled ) ) ; asrClient . setEnableAutoStop ( true ) ; Intent intent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; GlobalUtils . showToast ( this , R . string . toast_multi_voice_on , false ) ; } else { ( ( CardView ) findViewById ( R . id . cv_voice_chat ) ) . setForeground ( getDrawable ( R . drawable . voice_chat_btn ) ) ; asrClient . setEnableAutoStop ( false ) ; Intent intent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; GlobalUtils . showToast ( this , R . string . toast_multi_voice_off , false ) ; } } ) ; ( menuView . findViewById ( R . id . cv_history ) ) . setOnClickListener ( view -> { pwMenu . dismiss ( ) ; Intent intent = new Intent ( MainActivity . this , HistoryActivity . class ) ; startActivityForResult ( intent , <NUM_LIT> ) ; } ) ; ( menuView . findViewById ( R . id . cv_settings ) ) . setOnClickListener ( view -> { pwMenu . dismiss ( ) ; startActivityForResult ( new Intent ( MainActivity . this , TabConfActivity . class ) , <NUM_LIT> ) ; } ) ; ( menuView . findViewById ( R . id . cv_close ) ) . setOnClickListener ( view -> { finish ( ) ; } ) ; ( findViewById ( R . id . cv_more ) ) . setOnClickListener ( view -> { pwMenu . showAsDropDown ( view , <NUM_LIT> , <NUM_LIT> ) ; } ) ; ( findViewById ( R . id . view_bg_empty ) ) . setOnClickListener ( view -> { finish ( ) ; } ) ; if ( GlobalDataHolder . getDefaultEnableMultiChat ( ) ) { multiChat = true ; ( ( CardView ) findViewById ( R . id . cv_multi_chat ) ) . setForeground ( getDrawable ( R . drawable . chat_btn_enabled ) ) ; } if ( ! GlobalDataHolder . getDefaultEnableTts ( ) ) { ttsEnabled = false ; ( ( CardView ) findViewById ( R . id . cv_tts_off ) ) . setForeground ( getDrawable ( R . drawable . tts_off_enable ) ) ; } if ( GlobalDataHolder . getSelectedTab ( ) != - <NUM_LIT> && GlobalDataHolder . getSelectedTab ( ) < GlobalDataHolder . getTabDataList ( ) . size ( ) ) selectedTab = GlobalDataHolder . getSelectedTab ( ) ; switchToTemplate ( selectedTab ) ; Button selectedTabBtn = ( Button ) ( ( LinearLayout ) findViewById ( R . id . tabs_layout ) ) . getChildAt ( selectedTab ) ; selectedTabBtn . getParent ( ) . requestChildFocus ( selectedTabBtn , selectedTabBtn ) ; updateModelSpinner ( ) ; updateImageButtonVisible ( ) ; isAlive = true ; requestPermission ( ) ; asrCallback = new AsrClientBase . IAsrCallback ( ) { @ Override public void onError ( String msg ) { if ( tvGptReply != null ) { runOnUiThread ( ( ) -> tvGptReply . setText ( getString ( R . string . text_asr_error_prefix ) + msg ) ) ; } else { Toast . makeText ( MainActivity . this , getString ( R . string . text_asr_error_prefix ) + msg , Toast . LENGTH_LONG ) . show ( ) ; } if ( multiVoice ) { ( findViewById ( R . id . cv_voice_chat ) ) . performClick ( ) ; } } @ Override public void onResult ( String result ) { if ( result != null ) { runOnUiThread ( ( ) -> etUserInput . setText ( result ) ) ; } } @ Override public void onAutoStop ( ) { if ( multiVoice ) { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( MainActivity . this ) . sendBroadcast ( broadcastIntent ) ; Intent broadcastIntent2 = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( MainActivity . this ) . sendBroadcast ( broadcastIntent2 ) ; } } } ; if ( GlobalDataHolder . getAsrUseBaidu ( ) ) { setAsrClient ( "<STR_LIT>" ) ; } else if ( GlobalDataHolder . getAsrUseWhisper ( ) ) { setAsrClient ( "<STR_LIT>" ) ; } else if ( GlobalDataHolder . getAsrUseGoogle ( ) ) { setAsrClient ( "<STR_LIT>" ) ; } else { setAsrClient ( "<STR_LIT>" ) ; } localReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( "<STR_LIT>" ) ) { tts . stop ( ) ; asrClient . startRecognize ( ) ; asrStartTime = System . currentTimeMillis ( ) ; etUserInput . setText ( "<STR_LIT>" ) ; etUserInput . setHint ( R . string . text_listening_hint ) ; } else if ( action . equals ( "<STR_LIT>" ) ) { etUserInput . setHint ( R . string . text_input_hint ) ; if ( System . currentTimeMillis ( ) - asrStartTime < <NUM_LIT> ) { asrClient . cancelRecognize ( ) ; } else { asrClient . stopRecognize ( ) ; } } else if ( action . equals ( "<STR_LIT>" ) ) { if ( ! chatApiClient . isStreaming ( ) ) sendQuestion ( null ) ; } else if ( action . equals ( "<STR_LIT>" ) ) { etUserInput . requestFocus ( ) ; InputMethodManager imm = ( InputMethodManager ) getSystemService ( INPUT_METHOD_SERVICE ) ; imm . showSoftInput ( findViewById ( R . id . et_user_input ) , InputMethodManager . RESULT_UNCHANGED_SHOWN ) ; } } } ; IntentFilter intentFilter = new IntentFilter ( ) ; intentFilter . addAction ( "<STR_LIT>" ) ; intentFilter . addAction ( "<STR_LIT>" ) ; intentFilter . addAction ( "<STR_LIT>" ) ; intentFilter . addAction ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . registerReceiver ( localReceiver , intentFilter ) ; if ( GlobalDataHolder . getCheckAccessOnStart ( ) ) { if ( ! MyAccessbilityService . isConnected ( ) ) { new ConfirmDialog ( this ) . setContent ( getString ( R . string . text_access_notice ) ) . setOnConfirmListener ( ( ) -> { Intent intent = new Intent ( Settings . ACTION_ACCESSIBILITY_SETTINGS ) ; startActivity ( intent ) ; } ) . setOnCancelListener ( ( ) -> { Toast . makeText ( MainActivity . this , getString ( R . string . toast_access_error ) , Toast . LENGTH_SHORT ) . show ( ) ; } ) . show ( ) ; } } } private void setAsrClient ( String type ) { if ( asrClient != null ) { asrClient . destroy ( ) ; } if ( type . equals ( "<STR_LIT>" ) ) { asrClient = new BaiduAsrClient ( this ) ; asrClient . setCallback ( asrCallback ) ; } else if ( type . equals ( "<STR_LIT>" ) ) { asrClient = new HmsAsrClient ( this ) ; asrClient . setCallback ( asrCallback ) ; } else if ( type . equals ( "<STR_LIT>" ) ) { asrClient = new WhisperAsrClient ( this , GlobalDataHolder . getGptApiHost ( ) , GlobalDataHolder . getGptApiKey ( ) ) ; asrClient . setCallback ( asrCallback ) ; } else if ( type . equals ( "<STR_LIT>" ) ) { asrClient = new GoogleAsrClient ( this ) ; asrClient . setCallback ( asrCallback ) ; } } private void setNetworkEnabled ( boolean enabled ) { if ( enabled ) { chatApiClient . addFunction ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , new String [ ] { "<STR_LIT>" } ) ; } else { chatApiClient . removeFunction ( "<STR_LIT>" ) ; } } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == <NUM_LIT> ) { int tabNum = GlobalDataHolder . getTabDataList ( ) . size ( ) ; if ( selectedTab >= tabNum ) selectedTab = tabNum - <NUM_LIT> ; switchToTemplate ( selectedTab ) ; updateModelSpinner ( ) ; updateImageButtonVisible ( ) ; chatApiClient . setApiInfo ( GlobalDataHolder . getGptApiHost ( ) , GlobalDataHolder . getGptApiKey ( ) ) ; chatApiClient . setModel ( currentTemplateParams . getStr ( "<STR_LIT>" , GlobalDataHolder . getGptModel ( ) ) ) ; if ( GlobalDataHolder . getAsrUseBaidu ( ) && ! ( asrClient instanceof BaiduAsrClient ) ) { setAsrClient ( "<STR_LIT>" ) ; } else if ( GlobalDataHolder . getAsrUseWhisper ( ) && ! ( asrClient instanceof WhisperAsrClient ) ) { setAsrClient ( "<STR_LIT>" ) ; } else if ( GlobalDataHolder . getAsrUseGoogle ( ) && ! ( asrClient instanceof GoogleAsrClient ) ) { setAsrClient ( "<STR_LIT>" ) ; } else if ( ! GlobalDataHolder . getAsrUseBaidu ( ) && ! GlobalDataHolder . getAsrUseWhisper ( ) && ! GlobalDataHolder . getAsrUseGoogle ( ) && ! ( asrClient instanceof HmsAsrClient ) ) { setAsrClient ( "<STR_LIT>" ) ; } if ( asrClient instanceof WhisperAsrClient ) { ( ( WhisperAsrClient ) asrClient ) . setApiInfo ( GlobalDataHolder . getGptApiHost ( ) , GlobalDataHolder . getGptApiKey ( ) ) ; } setNetworkEnabled ( currentTemplateParams . getBool ( "<STR_LIT>" , GlobalDataHolder . getEnableInternetAccess ( ) ) ) ; } else if ( ( requestCode == <NUM_LIT> || requestCode == <NUM_LIT> ) && resultCode == RESULT_OK ) { Uri uri = requestCode == <NUM_LIT> ? photoUri : data . getData ( ) ; try { Bitmap bitmap = ( Bitmap ) BitmapFactory . decodeStream ( getContentResolver ( ) . openInputStream ( uri ) ) ; selectedImageBitmap = bitmap ; if ( GlobalDataHolder . getLimitVisionSize ( ) ) { if ( bitmap . getWidth ( ) < bitmap . getHeight ( ) ) selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; else selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; } else { selectedImageBitmap = resizeBitmap ( bitmap , <NUM_LIT> , <NUM_LIT> ) ; } btImage . setImageResource ( R . drawable . image_enabled ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } else if ( requestCode == <NUM_LIT> && resultCode == RESULT_OK ) { if ( data . hasExtra ( "<STR_LIT>" ) ) { long id = data . getLongExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + id ) ; Conversation conversation = chatManager . getConversation ( id ) ; chatManager . removeConversation ( id ) ; conversation . updateTime ( ) ; reloadConversation ( conversation ) ; } } } private void scrollChatAreaToBottom ( ) { svChatArea . post ( ( ) -> { int delta = svChatArea . getChildAt ( <NUM_LIT> ) . getBottom ( ) - ( svChatArea . getHeight ( ) + svChatArea . getScrollY ( ) ) ; if ( delta != <NUM_LIT> ) svChatArea . smoothScrollBy ( <NUM_LIT> , delta ) ; } ) ; } private void updateImageButtonVisible ( ) { if ( GlobalUtils . checkVisionSupport ( currentTemplateParams . getStr ( "<STR_LIT>" , GlobalDataHolder . getGptModel ( ) ) ) ) btImage . setVisibility ( View . VISIBLE ) ; else btImage . setVisibility ( View . GONE ) ; } private void updateModelSpinner ( ) { Spinner spModels = findViewById ( R . id . sp_main_model ) ; List < String > models = new ArrayList < > ( Arrays . asList ( getResources ( ) . getStringArray ( R . array . models ) ) ) ; models . addAll ( GlobalDataHolder . getCustomModels ( ) ) ; ArrayAdapter < String > modelsAdapter = new ArrayAdapter < String > ( this , R . layout . main_model_spinner_item , models ) { @ Override public View getDropDownView ( int position , @ Nullable View convertView , @ NonNull ViewGroup parent ) { TextView tv = ( TextView ) super . getDropDownView ( position , convertView , parent ) ; if ( spModels . getSelectedItemPosition ( ) == position ) { tv . setTypeface ( Typeface . DEFAULT , Typeface . BOLD ) ; } else { tv . setTypeface ( Typeface . DEFAULT , Typeface . NORMAL ) ; } return tv ; } } ; modelsAdapter . setDropDownViewResource ( R . layout . model_spinner_dropdown_item ) ; spModels . setAdapter ( modelsAdapter ) ; spModels . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { GlobalDataHolder . saveGptApiInfo ( GlobalDataHolder . getGptApiHost ( ) , GlobalDataHolder . getGptApiKey ( ) , adapterView . getItemAtPosition ( i ) . toString ( ) , GlobalDataHolder . getCustomModels ( ) ) ; chatApiClient . setModel ( currentTemplateParams . getStr ( "<STR_LIT>" , GlobalDataHolder . getGptModel ( ) ) ) ; updateImageButtonVisible ( ) ; modelsAdapter . notifyDataSetChanged ( ) ; } public void onNothingSelected ( AdapterView < ? > adapterView ) { } } ) ; for ( int i = <NUM_LIT> ; i < modelsAdapter . getCount ( ) ; i ++ ) { if ( modelsAdapter . getItem ( i ) . equals ( GlobalDataHolder . getGptModel ( ) ) ) { spModels . setSelection ( i ) ; break ; } if ( i == modelsAdapter . getCount ( ) - <NUM_LIT> ) { spModels . setSelection ( <NUM_LIT> ) ; } } } private void updateTabListView ( ) { LinearLayout tabList = findViewById ( R . id . tabs_layout ) ; tabList . removeAllViews ( ) ; List < PromptTabData > tabDataList = GlobalDataHolder . getTabDataList ( ) ; for ( int i = <NUM_LIT> ; i < tabDataList . size ( ) ; i ++ ) { PromptTabData tabData = tabDataList . get ( i ) ; Button tabBtn = new Button ( this ) ; tabBtn . setText ( tabData . getTitle ( ) ) ; tabBtn . setTextSize ( <NUM_LIT> ) ; if ( i == selectedTab ) { tabBtn . setTypeface ( Typeface . DEFAULT , Typeface . BOLD ) ; tabBtn . setBackgroundResource ( R . drawable . tab_background_selected ) ; } else { tabBtn . setTypeface ( Typeface . DEFAULT , Typeface . NORMAL ) ; tabBtn . setBackgroundResource ( R . drawable . tab_background_unselected ) ; } ViewGroup . MarginLayoutParams params = new ViewGroup . MarginLayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; params . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; tabBtn . setLayoutParams ( params ) ; int finalI = i ; tabBtn . setOnClickListener ( view -> { if ( finalI != selectedTab ) { switchToTemplate ( finalI ) ; if ( multiChatList . size ( ) > <NUM_LIT> ) ( findViewById ( R . id . cv_new_chat ) ) . performClick ( ) ; } } ) ; tabList . addView ( tabBtn ) ; } } private void updateTemplateParamsView ( ) { LinearLayout llParams = findViewById ( R . id . ll_template_params ) ; llParams . removeAllViews ( ) ; if ( currentTemplateParams . containsKey ( "<STR_LIT>" ) ) { for ( String inputKey : currentTemplateParams . getJSONObject ( "<STR_LIT>" ) . keySet ( ) ) { LinearLayout llOuter = new LinearLayout ( this ) ; llOuter . setOrientation ( LinearLayout . HORIZONTAL ) ; llOuter . setGravity ( Gravity . CENTER ) ; llOuter . setPadding ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; TextView tv = new TextView ( this ) ; tv . setText ( inputKey ) ; tv . setTextColor ( Color . BLACK ) ; tv . setTextSize ( <NUM_LIT> ) ; tv . setPadding ( <NUM_LIT> , <NUM_LIT> , dpToPx ( <NUM_LIT> ) , <NUM_LIT> ) ; tv . setLayoutParams ( new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ) ; llOuter . addView ( tv ) ; JSONObject inputItem = currentTemplateParams . getJSONObject ( "<STR_LIT>" ) . getJSONObject ( inputKey ) ; if ( inputItem . getStr ( "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) { EditText et = new EditText ( this ) ; et . setBackgroundColor ( Color . TRANSPARENT ) ; et . setTextSize ( <NUM_LIT> ) ; et . setHint ( "<STR_LIT>" ) ; et . setTextColor ( Color . BLACK ) ; et . setSingleLine ( false ) ; et . setMaxHeight ( dpToPx ( <NUM_LIT> ) ) ; et . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; et . setLayoutParams ( new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ) ; et . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; llOuter . addView ( et ) ; } else if ( inputItem . getStr ( "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) { Spinner sp = new Spinner ( this , Spinner . MODE_DROPDOWN ) ; sp . setBackgroundColor ( Color . TRANSPARENT ) ; sp . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; sp . setLayoutParams ( new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ) ; sp . setPopupBackgroundDrawable ( ContextCompat . getDrawable ( this , R . drawable . spinner_dropdown_background ) ) ; List < String > options = new ArrayList < > ( ) ; JSONArray itemsArray = inputItem . getJSONArray ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < itemsArray . size ( ) ; i ++ ) { options . add ( itemsArray . getJSONObject ( i ) . getStr ( "<STR_LIT>" ) ) ; } ArrayAdapter < String > adapter = new ArrayAdapter < String > ( this , R . layout . param_spinner_item , options ) { @ Override public View getDropDownView ( int position , View convertView , ViewGroup parent ) { TextView tv = ( TextView ) super . getDropDownView ( position , convertView , parent ) ; if ( sp . getSelectedItemPosition ( ) == position ) { tv . setTypeface ( Typeface . DEFAULT , Typeface . BOLD ) ; } else { tv . setTypeface ( Typeface . DEFAULT , Typeface . NORMAL ) ; } return tv ; } } ; adapter . setDropDownViewResource ( R . layout . param_spinner_dropdown_item ) ; sp . setAdapter ( adapter ) ; llOuter . addView ( sp ) ; } llOuter . setTag ( inputKey ) ; llParams . addView ( llOuter ) ; } } if ( llParams . getChildCount ( ) == <NUM_LIT> ) { ( ( CardView ) llParams . getParent ( ) ) . setVisibility ( View . GONE ) ; } else { ( ( CardView ) llParams . getParent ( ) ) . setVisibility ( View . VISIBLE ) ; } } private JSONObject getTemplateParamsFromView ( ) { JSONObject params = new JSONObject ( ) ; LinearLayout llParams = findViewById ( R . id . ll_template_params ) ; for ( int i = <NUM_LIT> ; i < llParams . getChildCount ( ) ; i ++ ) { LinearLayout llOuter = ( LinearLayout ) llParams . getChildAt ( i ) ; String inputKey = ( String ) llOuter . getTag ( ) ; if ( llOuter . getChildAt ( <NUM_LIT> ) instanceof EditText ) { EditText et = ( EditText ) llOuter . getChildAt ( <NUM_LIT> ) ; params . putOpt ( inputKey , et . getText ( ) . toString ( ) ) ; } else if ( llOuter . getChildAt ( <NUM_LIT> ) instanceof Spinner ) { Spinner sp = ( Spinner ) llOuter . getChildAt ( <NUM_LIT> ) ; params . putOpt ( inputKey , sp . getSelectedItem ( ) ) ; } } return params ; } private void switchToTemplate ( int tabIndex ) { selectedTab = tabIndex ; if ( GlobalDataHolder . getSelectedTab ( ) != - <NUM_LIT> ) { GlobalDataHolder . saveSelectedTab ( selectedTab ) ; } currentTemplateParams = GlobalDataHolder . getTabDataList ( ) . get ( selectedTab ) . parseParams ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + currentTemplateParams ) ; chatApiClient . setModel ( currentTemplateParams . getStr ( "<STR_LIT>" , GlobalDataHolder . getGptModel ( ) ) ) ; setNetworkEnabled ( currentTemplateParams . getBool ( "<STR_LIT>" , GlobalDataHolder . getEnableInternetAccess ( ) ) ) ; updateTabListView ( ) ; updateTemplateParamsView ( ) ; updateImageButtonVisible ( ) ; } private LinearLayout addChatView ( ChatRole role , String content , String imageBase64 ) { ViewGroup . MarginLayoutParams iconParams = new ViewGroup . MarginLayoutParams ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; iconParams . setMargins ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; ViewGroup . MarginLayoutParams contentParams = new ViewGroup . MarginLayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; contentParams . setMargins ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; LinearLayout . LayoutParams popupIconParams = new LinearLayout . LayoutParams ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; popupIconParams . setMargins ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; LinearLayout llOuter = new LinearLayout ( this ) ; llOuter . setOrientation ( LinearLayout . HORIZONTAL ) ; if ( role == ChatRole . ASSISTANT ) llOuter . setBackgroundColor ( Color . parseColor ( "<STR_LIT>" ) ) ; ImageView ivIcon = new ImageView ( this ) ; if ( role == ChatRole . USER ) ivIcon . setImageResource ( R . drawable . chat_user_icon ) ; else ivIcon . setImageResource ( R . drawable . chat_gpt_icon ) ; ivIcon . setLayoutParams ( iconParams ) ; TextView tvContent = new TextView ( this ) ; SpannableString spannableString = null ; if ( role == ChatRole . USER ) { if ( imageBase64 != null ) { spannableString = new SpannableString ( content + "<STR_LIT>" ) ; Bitmap bitmap = base64ToBitmap ( imageBase64 ) ; int maxSize = dpToPx ( <NUM_LIT> ) ; bitmap = resizeBitmap ( bitmap , maxSize , maxSize ) ; ImageSpan imageSpan = new ImageSpan ( this , bitmap ) ; spannableString . setSpan ( imageSpan , content . length ( ) + <NUM_LIT> , content . length ( ) + <NUM_LIT> , Spannable . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } else { spannableString = new SpannableString ( content ) ; } tvContent . setText ( spannableString ) ; } else if ( role == ChatRole . ASSISTANT ) { markdownRenderer . render ( tvContent , content ) ; } tvContent . setTextSize ( <NUM_LIT> ) ; tvContent . setTextColor ( Color . BLACK ) ; tvContent . setLayoutParams ( contentParams ) ; tvContent . setTextIsSelectable ( true ) ; tvContent . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; LinearLayout llPopup = new LinearLayout ( this ) ; llPopup . setLayoutParams ( new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; PaintDrawable popupBackground = new PaintDrawable ( Color . TRANSPARENT ) ; llPopup . setBackground ( popupBackground ) ; llPopup . setOrientation ( LinearLayout . HORIZONTAL ) ; PopupWindow popupWindow = new PopupWindow ( llPopup , ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT , true ) ; popupWindow . setOutsideTouchable ( true ) ; ivIcon . setTag ( popupWindow ) ; CardView cvDelete = new CardView ( this ) ; cvDelete . setForeground ( getDrawable ( R . drawable . clear_btn ) ) ; cvDelete . setOnClickListener ( view -> { popupWindow . dismiss ( ) ; ChatMessage chat = ( ChatMessage ) llOuter . getTag ( ) ; if ( chat != null ) { int index = multiChatList . indexOf ( chat ) ; multiChatList . remove ( chat ) ; while ( -- index > <NUM_LIT> && ( multiChatList . get ( index ) . role == ChatRole . FUNCTION || multiChatList . get ( index ) . functionName != null && multiChatList . get ( index ) . functionName . equals ( "<STR_LIT>" ) ) ) multiChatList . remove ( index ) ; } if ( tvContent == tvGptReply ) { if ( chatApiClient . isStreaming ( ) ) chatApiClient . stop ( ) ; tts . stop ( ) ; } llChatList . removeView ( llOuter ) ; if ( llChatList . getChildCount ( ) == <NUM_LIT> ) clearChatListView ( ) ; } ) ; llPopup . addView ( cvDelete ) ; CardView cvDelBelow = new CardView ( this ) ; cvDelBelow . setForeground ( getDrawable ( R . drawable . del_below_btn ) ) ; cvDelBelow . setOnClickListener ( view -> { popupWindow . dismiss ( ) ; int index = llChatList . indexOfChild ( llOuter ) ; while ( llChatList . getChildCount ( ) > index && llChatList . getChildAt ( <NUM_LIT> ) instanceof LinearLayout ) { PopupWindow pw = ( PopupWindow ) ( ( LinearLayout ) llChatList . getChildAt ( llChatList . getChildCount ( ) - <NUM_LIT> ) ) . getChildAt ( <NUM_LIT> ) . getTag ( ) ; ( ( LinearLayout ) pw . getContentView ( ) ) . getChildAt ( <NUM_LIT> ) . performClick ( ) ; } } ) ; llPopup . addView ( cvDelBelow ) ; if ( role == ChatRole . USER ) { CardView cvEdit = new CardView ( this ) ; cvEdit . setForeground ( getDrawable ( R . drawable . edit_btn ) ) ; cvEdit . setOnClickListener ( view -> { popupWindow . dismiss ( ) ; ChatMessage chat = ( ChatMessage ) llOuter . getTag ( ) ; String text = chat . contentText ; if ( chat . contentImageBase64 != null ) { if ( text . endsWith ( "<STR_LIT>" ) ) text = text . substring ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; selectedImageBitmap = base64ToBitmap ( chat . contentImageBase64 ) ; btImage . setImageResource ( R . drawable . image_enabled ) ; } else { selectedImageBitmap = null ; btImage . setImageResource ( R . drawable . image ) ; } etUserInput . setText ( text ) ; cvDelBelow . performClick ( ) ; } ) ; llPopup . addView ( cvEdit ) ; CardView cvRetry = new CardView ( this ) ; cvRetry . setForeground ( getDrawable ( R . drawable . retry_btn ) ) ; cvRetry . setOnClickListener ( view -> { popupWindow . dismiss ( ) ; ChatMessage chat = ( ChatMessage ) llOuter . getTag ( ) ; String text = chat . contentText ; if ( chat . contentImageBase64 != null ) { if ( text . endsWith ( "<STR_LIT>" ) ) text = text . substring ( <NUM_LIT> , text . length ( ) - <NUM_LIT> ) ; selectedImageBitmap = base64ToBitmap ( chat . contentImageBase64 ) ; } else { selectedImageBitmap = null ; } cvDelBelow . performClick ( ) ; sendQuestion ( text ) ; } ) ; llPopup . addView ( cvRetry ) ; } CardView cvCopy = new CardView ( this ) ; cvCopy . setForeground ( getDrawable ( R . drawable . copy_btn ) ) ; cvCopy . setOnClickListener ( view -> { popupWindow . dismiss ( ) ; ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , tvContent . getText ( ) . toString ( ) ) ; clipboard . setPrimaryClip ( clip ) ; Toast . makeText ( this , R . string . toast_clipboard , Toast . LENGTH_SHORT ) . show ( ) ; } ) ; llPopup . addView ( cvCopy ) ; for ( int i = <NUM_LIT> ; i < llPopup . getChildCount ( ) ; i ++ ) { CardView cvBtn = ( CardView ) llPopup . getChildAt ( i ) ; cvBtn . setLayoutParams ( popupIconParams ) ; cvBtn . setCardBackgroundColor ( Color . WHITE ) ; cvBtn . setRadius ( dpToPx ( <NUM_LIT> ) ) ; } ivIcon . setOnClickListener ( view -> { popupWindow . showAsDropDown ( view , dpToPx ( <NUM_LIT> ) , - dpToPx ( <NUM_LIT> ) ) ; } ) ; llOuter . addView ( ivIcon ) ; llOuter . addView ( tvContent ) ; llChatList . addView ( llOuter ) ; return llOuter ; } private void sendQuestion ( String input ) { boolean isMultiChat = currentTemplateParams . getBool ( "<STR_LIT>" , multiChat ) ; if ( ! isMultiChat ) { ( ( CardView ) findViewById ( R . id . cv_new_chat ) ) . performClick ( ) ; } String userInput = ( input == null ) ? etUserInput . getText ( ) . toString ( ) : input ; if ( multiChatList . size ( ) == <NUM_LIT> && input == null ) { PromptTabData tabData = GlobalDataHolder . getTabDataList ( ) . get ( selectedTab ) ; String template = tabData . getFormattedPrompt ( getTemplateParamsFromView ( ) ) ; if ( currentTemplateParams . getBool ( "<STR_LIT>" , false ) ) { multiChatList . add ( new ChatMessage ( ChatRole . SYSTEM ) . setText ( template ) ) ; multiChatList . add ( new ChatMessage ( ChatRole . USER ) . setText ( userInput ) ) ; } else { if ( ! template . contains ( "<STR_LIT>" ) && ! template . contains ( "<STR_LIT>" ) ) template += "<STR_LIT>" ; String question = template . replace ( "<STR_LIT>" , userInput ) . replace ( "<STR_LIT>" , userInput ) ; multiChatList . add ( new ChatMessage ( ChatRole . USER ) . setText ( question ) ) ; } currentConversation . title = String . format ( "<STR_LIT>" , tabData . getTitle ( ) , ( ! tabData . getTitle ( ) . isEmpty ( ) && ! userInput . isEmpty ( ) ) ? "<STR_LIT>" : "<STR_LIT>" , userInput . substring ( <NUM_LIT> , Math . min ( <NUM_LIT> , userInput . length ( ) ) ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ) ; } else { multiChatList . add ( new ChatMessage ( ChatRole . USER ) . setText ( userInput ) ) ; } if ( selectedImageBitmap != null ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; selectedImageBitmap . compress ( Bitmap . CompressFormat . JPEG , <NUM_LIT> , baos ) ; byte [ ] bytes = baos . toByteArray ( ) ; String base64 = Base64 . encodeToString ( bytes , Base64 . NO_WRAP ) ; multiChatList . get ( multiChatList . size ( ) - <NUM_LIT> ) . setImage ( base64 ) ; } if ( llChatList . getChildCount ( ) > <NUM_LIT> && llChatList . getChildAt ( <NUM_LIT> ) instanceof TextView ) { llChatList . removeViewAt ( <NUM_LIT> ) ; } if ( isMultiChat && llChatList . getChildCount ( ) > <NUM_LIT> ) { LinearLayout llFirst = ( LinearLayout ) llChatList . getChildAt ( <NUM_LIT> ) ; TextView tvFirst = ( TextView ) llFirst . getChildAt ( <NUM_LIT> ) ; ChatMessage firstChat = ( ChatMessage ) llFirst . getTag ( ) ; if ( firstChat . role == ChatRole . USER ) { if ( firstChat . contentImageBase64 != null && tvFirst . getText ( ) . toString ( ) . endsWith ( "<STR_LIT>" ) ) { SpannableString oldText = ( SpannableString ) tvFirst . getText ( ) ; ImageSpan imgSpan = oldText . getSpans ( oldText . length ( ) - <NUM_LIT> , oldText . length ( ) , ImageSpan . class ) [ <NUM_LIT> ] ; SpannableString newText = new SpannableString ( firstChat . contentText + "<STR_LIT>" ) ; newText . setSpan ( imgSpan , newText . length ( ) - <NUM_LIT> , newText . length ( ) , Spannable . SPAN_EXCLUSIVE_EXCLUSIVE ) ; tvFirst . setText ( newText ) ; } else { tvFirst . setText ( firstChat . contentText ) ; } } } if ( GlobalDataHolder . getOnlyLatestWebResult ( ) ) { for ( int i = <NUM_LIT> ; i < multiChatList . size ( ) ; i ++ ) { ChatMessage chatItem = multiChatList . get ( i ) ; if ( chatItem . role == ChatRole . FUNCTION ) { multiChatList . remove ( i ) ; i -- ; if ( i > <NUM_LIT> && multiChatList . get ( i ) . role == ChatRole . ASSISTANT ) { multiChatList . remove ( i ) ; i -- ; } } } } LinearLayout llInput = addChatView ( ChatRole . USER , isMultiChat ? multiChatList . get ( multiChatList . size ( ) - <NUM_LIT> ) . contentText : userInput , multiChatList . get ( multiChatList . size ( ) - <NUM_LIT> ) . contentImageBase64 ) ; LinearLayout llReply = addChatView ( ChatRole . ASSISTANT , getString ( R . string . text_waiting_reply ) , null ) ; llInput . setTag ( multiChatList . get ( multiChatList . size ( ) - <NUM_LIT> ) ) ; tvGptReply = ( TextView ) llReply . getChildAt ( <NUM_LIT> ) ; scrollChatAreaToBottom ( ) ; chatApiBuffer = "<STR_LIT>" ; ttsSentenceEndIndex = <NUM_LIT> ; chatApiClient . sendPromptList ( multiChatList ) ; btImage . setImageResource ( R . drawable . image ) ; selectedImageBitmap = null ; btSend . setImageResource ( R . drawable . cancel_btn ) ; } private void postSendFunctionReply ( String funcName , String reply ) { handler . post ( ( ) -> { Log . d ( "<STR_LIT>" , "<STR_LIT>" + funcName ) ; multiChatList . add ( new ChatMessage ( ChatRole . FUNCTION ) . setFunction ( funcName ) . setText ( reply ) ) ; chatApiClient . sendPromptList ( multiChatList ) ; } ) ; } private void reloadConversation ( Conversation conversation ) { ( findViewById ( R . id . cv_new_chat ) ) . performClick ( ) ; currentConversation = conversation ; multiChatList = conversation . messages ; llChatList . removeViewAt ( <NUM_LIT> ) ; for ( ChatMessage chatItem : multiChatList ) { if ( chatItem . role == ChatRole . USER || ( chatItem . role == ChatRole . ASSISTANT && chatItem . functionName == null ) ) { LinearLayout llChatItem = addChatView ( chatItem . role , chatItem . contentText , chatItem . contentImageBase64 ) ; llChatItem . setTag ( chatItem ) ; } } scrollChatAreaToBottom ( ) ; } private void clearChatListView ( ) { if ( chatApiClient . isStreaming ( ) ) { chatApiClient . stop ( ) ; } llChatList . removeAllViews ( ) ; tts . stop ( ) ; TextView tv = new TextView ( this ) ; tv . setTextColor ( Color . parseColor ( "<STR_LIT>" ) ) ; tv . setTextSize ( <NUM_LIT> ) ; tv . setPadding ( dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) , dpToPx ( <NUM_LIT> ) ) ; tv . setText ( R . string . default_greeting ) ; tvGptReply = tv ; llChatList . addView ( tv ) ; } private int dpToPx ( int dp ) { return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dp , getResources ( ) . getDisplayMetrics ( ) ) ; } private Bitmap resizeBitmap ( Bitmap bitmap , int maxWidth , int maxHeight ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; float scale = <NUM_LIT> ; if ( width > maxWidth || height > maxHeight ) scale = Math . min ( ( float ) maxWidth / width , ( float ) maxHeight / height ) ; return Bitmap . createScaledBitmap ( bitmap , ( int ) ( width * scale ) , ( int ) ( height * scale ) , true ) ; } private Bitmap base64ToBitmap ( String base64 ) { byte [ ] bytes = Base64 . decode ( base64 , Base64 . NO_WRAP ) ; return BitmapFactory . decodeByteArray ( bytes , <NUM_LIT> , bytes . length ) ; } public static boolean isAlive ( ) { return isAlive ; } public static boolean isRunning ( ) { return isRunning ; } private void requestPermission ( ) { String [ ] permissions = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String [ ] tmpList = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { requestPermissions ( toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; } } @ Override protected void onResume ( ) { super . onResume ( ) ; isRunning = true ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; isRunning = false ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } @ Override protected void onDestroy ( ) { isAlive = false ; LocalBroadcastManager . getInstance ( this ) . unregisterReceiver ( localReceiver ) ; asrClient . destroy ( ) ; tts . stop ( ) ; tts . shutdown ( ) ; webScraper . destroy ( ) ; if ( ( ( multiChatList . size ( ) > <NUM_LIT> && multiChatList . get ( <NUM_LIT> ) . role != ChatRole . SYSTEM ) || ( multiChatList . size ( ) > <NUM_LIT> && multiChatList . get ( <NUM_LIT> ) . role == ChatRole . SYSTEM ) ) && GlobalDataHolder . getAutoSaveHistory ( ) ) chatManager . addConversation ( currentConversation ) ; chatManager . removeEmptyConversations ( ) ; chatManager . destroy ( ) ; super . onDestroy ( ) ; } @ Override public void finish ( ) { super . finish ( ) ; overridePendingTransition ( R . anim . translate_up_in , R . anim . translate_down_out ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . recog ; public interface IStatus { int STATUS_NONE = <NUM_LIT> ; int STATUS_READY = <NUM_LIT> ; int STATUS_SPEAKING = <NUM_LIT> ; int STATUS_RECOGNITION = <NUM_LIT> ; int STATUS_FINISHED = <NUM_LIT> ; int STATUS_LONG_SPEECH_FINISHED = <NUM_LIT> ; int STATUS_STOPPED = <NUM_LIT> ; int STATUS_WAITING_READY = <NUM_LIT> ; int WHAT_MESSAGE_STATUS = <NUM_LIT> ; int STATUS_WAKEUP_SUCCESS = <NUM_LIT> ; int STATUS_WAKEUP_EXIT = <NUM_LIT> ; } </s>
<s> package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public class SimpleWakeupListener implements IWakeupListener { private static final String TAG = "<STR_LIT>" ; @ Override public void onSuccess ( String word , WakeUpResult result ) { MyLogger . info ( TAG , "<STR_LIT>" + word ) ; } @ Override public void onStop ( ) { MyLogger . info ( TAG , "<STR_LIT>" ) ; } @ Override public void onError ( int errorCode , String errorMessge , WakeUpResult result ) { MyLogger . info ( TAG , "<STR_LIT>" + errorCode + "<STR_LIT>" + errorMessge + "<STR_LIT>" + result . getOrigalJson ( ) ) ; } @ Override public void onASrAudio ( byte [ ] data , int offset , int length ) { MyLogger . error ( TAG , "<STR_LIT>" + data . length ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . util . Base64 ; import android . util . TypedValue ; import android . widget . Toast ; import java . util . Arrays ; public class GlobalUtils { public static int dpToPx ( Context context , int dp ) { return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dp , context . getResources ( ) . getDisplayMetrics ( ) ) ; } public static Bitmap resizeBitmap ( Bitmap bitmap , int maxWidth , int maxHeight ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; float scale = <NUM_LIT> ; if ( width > maxWidth || height > maxHeight ) scale = Math . min ( ( float ) maxWidth / width , ( float ) maxHeight / height ) ; return Bitmap . createScaledBitmap ( bitmap , ( int ) ( width * scale ) , ( int ) ( height * scale ) , true ) ; } public static Bitmap base64ToBitmap ( String base64 ) { byte [ ] bytes = Base64 . decode ( base64 , Base64 . NO_WRAP ) ; return BitmapFactory . decodeByteArray ( bytes , <NUM_LIT> , bytes . length ) ; } public static void browseURL ( Context context , String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; context . startActivity ( intent ) ; } public static void copyToClipboard ( Context context , String text ) { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , text ) ; clipboard . setPrimaryClip ( clip ) ; } public static void showToast ( Context context , String text , boolean isLong ) { Toast . makeText ( context , text , isLong ? Toast . LENGTH_LONG : Toast . LENGTH_SHORT ) . show ( ) ; } public static void showToast ( Context context , int resId , boolean isLong ) { Toast . makeText ( context , resId , isLong ? Toast . LENGTH_LONG : Toast . LENGTH_SHORT ) . show ( ) ; } public static boolean checkVisionSupport ( String model ) { final String [ ] specialVisionModels = { "<STR_LIT>" , "<STR_LIT>" } ; return model . contains ( "<STR_LIT>" ) || Arrays . asList ( specialVisionModels ) . contains ( model ) || model . endsWith ( "<STR_LIT>" ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . content . Context ; import android . media . AudioFormat ; import android . media . AudioRecord ; import android . media . MediaRecorder ; import android . util . Log ; import java . io . IOException ; import java . io . InputStream ; public class MyMicrophoneInputStream extends InputStream { private static AudioRecord audioRecord ; private static MyMicrophoneInputStream is ; private boolean isStarted = false ; private static final String TAG = "<STR_LIT>" ; public MyMicrophoneInputStream ( ) { if ( audioRecord == null ) { int bufferSize = AudioRecord . getMinBufferSize ( <NUM_LIT> , AudioFormat . CHANNEL_IN_MONO , AudioFormat . ENCODING_PCM_16BIT ) * <NUM_LIT> ; audioRecord = new AudioRecord ( MediaRecorder . AudioSource . MIC , <NUM_LIT> , AudioFormat . CHANNEL_IN_MONO , AudioFormat . ENCODING_PCM_16BIT , bufferSize ) ; } } public static MyMicrophoneInputStream getInstance ( ) { if ( is == null ) { synchronized ( MyMicrophoneInputStream . class ) { if ( is == null ) { is = new MyMicrophoneInputStream ( ) ; } } } return is ; } public void start ( ) { Log . i ( TAG , "<STR_LIT>" ) ; try { if ( audioRecord == null || audioRecord . getState ( ) != AudioRecord . STATE_INITIALIZED ) { throw new IllegalStateException ( "<STR_LIT>" + ( audioRecord == null ) ) ; } Context context = InFileStream . getContext ( ) ; audioRecord . startRecording ( ) ; } catch ( Exception e ) { Log . e ( TAG , e . getClass ( ) . getSimpleName ( ) , e ) ; } Log . i ( TAG , "<STR_LIT>" ) ; } @ Override public int read ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( ! isStarted ) { start ( ) ; isStarted = true ; } try { int count = audioRecord . read ( b , off , len ) ; return count ; } catch ( Exception e ) { Log . e ( TAG , e . getClass ( ) . getSimpleName ( ) , e ) ; throw e ; } } @ Override public void close ( ) throws IOException { Log . i ( TAG , "<STR_LIT>" ) ; if ( audioRecord != null ) { audioRecord . stop ( ) ; isStarted = false ; } } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . content . SharedPreferences ; import android . util . Base64 ; import android . util . Log ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class GlobalDataHolder { private static List < PromptTabData > tabDataList = null ; private static boolean asrUseWhisper ; private static boolean asrUseGoogle ; private static boolean asrUseBaidu ; private static String asrAppId ; private static String asrApiKey ; private static String asrSecretKey ; private static boolean asrUseRealTime ; private static String gptApiHost ; private static String gptApiKey ; private static String gptModel ; private static List < String > customModels = null ; private static boolean checkAccessOnStart ; private static boolean defaultEnableTts ; private static boolean defaultEnableMultiChat ; private static int selectedTab ; private static boolean enableInternetAccess ; private static int webMaxCharCount ; private static boolean onlyLatestWebResult ; private static boolean limitVisionSize ; private static boolean autoSaveHistory ; private static SharedPreferences sp = null ; public static void init ( Context context ) { sp = context . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; loadTabDataList ( ) ; if ( tabDataList . size ( ) == <NUM_LIT> ) { tabDataList . add ( new PromptTabData ( context . getString ( R . string . text_default_tab_title ) , context . getString ( R . string . text_default_tab_content ) ) ) ; saveTabDataList ( ) ; } loadAsrSelection ( ) ; loadBaiduAsrInfo ( ) ; loadGptApiInfo ( ) ; loadStartUpSetting ( ) ; loadTtsSetting ( ) ; loadMultiChatSetting ( ) ; loadSelectedTab ( ) ; loadFunctionSetting ( ) ; loadVisionSetting ( ) ; loadHistorySetting ( ) ; } public static List < PromptTabData > getTabDataList ( ) { return tabDataList ; } public static void saveTabDataList ( ) { SharedPreferences . Editor editor = sp . edit ( ) ; try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( tabDataList ) ; String base64 = Base64 . encodeToString ( baos . toByteArray ( ) , Base64 . DEFAULT ) ; editor . putString ( "<STR_LIT>" , base64 ) ; editor . apply ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void loadTabDataList ( ) { String base64 = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( base64 . equals ( "<STR_LIT>" ) ) { tabDataList = new ArrayList < > ( ) ; return ; } byte [ ] bytes = Base64 . decode ( base64 , Base64 . DEFAULT ) ; try { ByteArrayInputStream bais = new ByteArrayInputStream ( bytes ) ; tabDataList = ( List < PromptTabData > ) ( new ObjectInputStream ( bais ) . readObject ( ) ) ; } catch ( ClassNotFoundException | IOException e ) { e . printStackTrace ( ) ; } } public static void loadAsrSelection ( ) { asrUseWhisper = sp . getBoolean ( "<STR_LIT>" , false ) ; asrUseBaidu = sp . getBoolean ( "<STR_LIT>" , false ) ; asrUseGoogle = sp . getBoolean ( "<STR_LIT>" , false ) ; } public static void saveAsrSelection ( boolean useWhisper , boolean useBaidu , boolean useGoogle ) { asrUseWhisper = useWhisper ; asrUseBaidu = useBaidu ; asrUseGoogle = useGoogle ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , asrUseWhisper ) ; editor . putBoolean ( "<STR_LIT>" , asrUseBaidu ) ; editor . putBoolean ( "<STR_LIT>" , asrUseGoogle ) ; editor . apply ( ) ; } public static void loadBaiduAsrInfo ( ) { asrAppId = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; asrApiKey = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; asrSecretKey = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; asrUseRealTime = sp . getBoolean ( "<STR_LIT>" , false ) ; } public static void saveBaiduAsrInfo ( String appId , String apiKey , String secretKey , boolean useRealTime ) { asrApiKey = apiKey ; asrAppId = appId ; asrSecretKey = secretKey ; asrUseRealTime = useRealTime ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( "<STR_LIT>" , asrAppId ) ; editor . putString ( "<STR_LIT>" , asrApiKey ) ; editor . putString ( "<STR_LIT>" , asrSecretKey ) ; editor . putBoolean ( "<STR_LIT>" , asrUseRealTime ) ; editor . apply ( ) ; } public static void loadGptApiInfo ( ) { gptApiHost = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; gptApiKey = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; gptModel = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; customModels = new ArrayList < > ( Arrays . asList ( sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) . split ( "<STR_LIT>" ) ) ) ; customModels . removeIf ( String :: isEmpty ) ; } public static void saveGptApiInfo ( String host , String key , String model , List < String > customModelList ) { gptApiHost = host ; gptApiKey = key ; gptModel = model ; customModels = customModelList ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( "<STR_LIT>" , gptApiHost ) ; editor . putString ( "<STR_LIT>" , gptApiKey ) ; editor . putString ( "<STR_LIT>" , gptModel ) ; editor . putString ( "<STR_LIT>" , String . join ( "<STR_LIT>" , customModels ) ) ; editor . apply ( ) ; } public static void loadStartUpSetting ( ) { checkAccessOnStart = sp . getBoolean ( "<STR_LIT>" , true ) ; } public static void saveStartUpSetting ( boolean checkAccess ) { checkAccessOnStart = checkAccess ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , checkAccessOnStart ) ; editor . apply ( ) ; } public static void loadTtsSetting ( ) { defaultEnableTts = sp . getBoolean ( "<STR_LIT>" , true ) ; } public static void saveTtsSetting ( boolean enable ) { defaultEnableTts = enable ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , defaultEnableTts ) ; editor . apply ( ) ; } public static void loadMultiChatSetting ( ) { defaultEnableMultiChat = sp . getBoolean ( "<STR_LIT>" , false ) ; } public static void saveMultiChatSetting ( boolean defaultEnable ) { defaultEnableMultiChat = defaultEnable ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , defaultEnableMultiChat ) ; editor . apply ( ) ; } public static void loadSelectedTab ( ) { selectedTab = sp . getInt ( "<STR_LIT>" , - <NUM_LIT> ) ; } public static void saveSelectedTab ( int tab ) { selectedTab = tab ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putInt ( "<STR_LIT>" , selectedTab ) ; editor . apply ( ) ; } public static void loadFunctionSetting ( ) { enableInternetAccess = sp . getBoolean ( "<STR_LIT>" , false ) ; webMaxCharCount = sp . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; onlyLatestWebResult = sp . getBoolean ( "<STR_LIT>" , false ) ; } public static void saveFunctionSetting ( boolean enableInternet , int maxCharCount , boolean onlyLatest ) { enableInternetAccess = enableInternet ; webMaxCharCount = maxCharCount ; onlyLatestWebResult = onlyLatest ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , enableInternetAccess ) ; editor . putInt ( "<STR_LIT>" , webMaxCharCount ) ; editor . putBoolean ( "<STR_LIT>" , onlyLatestWebResult ) ; editor . apply ( ) ; } public static void loadVisionSetting ( ) { limitVisionSize = sp . getBoolean ( "<STR_LIT>" , false ) ; } public static void saveVisionSetting ( boolean limitSize ) { limitVisionSize = limitSize ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , limitVisionSize ) ; editor . apply ( ) ; } public static void loadHistorySetting ( ) { autoSaveHistory = sp . getBoolean ( "<STR_LIT>" , true ) ; } public static void saveHistorySetting ( boolean autoSave ) { autoSaveHistory = autoSave ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , autoSaveHistory ) ; editor . apply ( ) ; } public static boolean getAsrUseWhisper ( ) { return asrUseWhisper ; } public static boolean getAsrUseGoogle ( ) { return asrUseGoogle ; } public static boolean getAsrUseBaidu ( ) { return asrUseBaidu ; } public static String getAsrAppId ( ) { return asrAppId ; } public static String getAsrApiKey ( ) { return asrApiKey ; } public static String getAsrSecretKey ( ) { return asrSecretKey ; } public static boolean getAsrUseRealTime ( ) { return asrUseRealTime ; } public static String getGptApiHost ( ) { return gptApiHost ; } public static String getGptApiKey ( ) { return gptApiKey ; } public static String getGptModel ( ) { return gptModel ; } public static List < String > getCustomModels ( ) { return customModels ; } public static boolean getCheckAccessOnStart ( ) { return checkAccessOnStart ; } public static boolean getDefaultEnableTts ( ) { return defaultEnableTts ; } public static boolean getDefaultEnableMultiChat ( ) { return defaultEnableMultiChat ; } public static int getSelectedTab ( ) { return selectedTab ; } public static boolean getEnableInternetAccess ( ) { return enableInternetAccess ; } public static int getWebMaxCharCount ( ) { return webMaxCharCount ; } public static boolean getOnlyLatestWebResult ( ) { return onlyLatestWebResult ; } public static boolean getLimitVisionSize ( ) { return limitVisionSize ; } public static boolean getAutoSaveHistory ( ) { return autoSaveHistory ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . content . Context ; import java . io . IOException ; import java . io . InputStream ; import java . io . PipedInputStream ; import java . io . PipedOutputStream ; public class InPipedStream { private PipedInputStream pipedInputStream ; private PipedOutputStream pipedOutputStream ; private Context context ; private InPipedStream ( Context context ) { pipedInputStream = new PipedInputStream ( ) ; pipedOutputStream = new PipedOutputStream ( ) ; this . context = context ; } private void start ( ) throws IOException { pipedInputStream . connect ( pipedOutputStream ) ; Runnable run = new Runnable ( ) { @ Override public void run ( ) { try { final InputStream is = context . getAssets ( ) . open ( "<STR_LIT>" ) ; int bytePerMs = <NUM_LIT> * <NUM_LIT> / <NUM_LIT> ; int count = bytePerMs * <NUM_LIT> ; int r = <NUM_LIT> ; byte [ ] buffer = new byte [ count ] ; do { r = is . read ( buffer ) ; int sleepTime = <NUM_LIT> ; if ( r > <NUM_LIT> ) { pipedOutputStream . write ( buffer , <NUM_LIT> , count ) ; sleepTime = r / bytePerMs ; } else if ( r == <NUM_LIT> ) { sleepTime = <NUM_LIT> ; } if ( sleepTime > <NUM_LIT> ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } while ( r >= <NUM_LIT> ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } } ; ( new Thread ( run ) ) . start ( ) ; } public static PipedInputStream createAndStart ( Context context ) { InPipedStream obj = new InPipedStream ( context ) ; try { obj . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } return obj . pipedInputStream ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Intent ; import android . service . quicksettings . TileService ; import android . util . Log ; import android . os . Handler ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; public class QuickStartService extends TileService { @ Override public void onClick ( ) { super . onClick ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( ! MainActivity . isAlive ( ) || ! MainActivity . isRunning ( ) ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivityAndCollapse ( intent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; new Handler ( ) . postDelayed ( ( ) -> { Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; } , <NUM_LIT> ) ; } } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . wakeup ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . listener . IWakeupListener ; import com . baidu . speech . EventListener ; import com . baidu . speech . asr . SpeechConstant ; public class WakeupEventAdapter implements EventListener { private IWakeupListener listener ; public WakeupEventAdapter ( IWakeupListener listener ) { this . listener = listener ; } private static final String TAG = "<STR_LIT>" ; @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { MyLogger . info ( TAG , "<STR_LIT>" + name + "<STR_LIT>" + params ) ; if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_SUCCESS . equals ( name ) ) { WakeUpResult result = WakeUpResult . parseJson ( name , params ) ; int errorCode = result . getErrorCode ( ) ; if ( result . hasError ( ) ) { listener . onError ( errorCode , "<STR_LIT>" , result ) ; } else { String word = result . getWord ( ) ; listener . onSuccess ( word , result ) ; } } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_ERROR . equals ( name ) ) { WakeUpResult result = WakeUpResult . parseJson ( name , params ) ; int errorCode = result . getErrorCode ( ) ; if ( result . hasError ( ) ) { listener . onError ( errorCode , "<STR_LIT>" , result ) ; } } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_STOPED . equals ( name ) ) { listener . onStop ( ) ; } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_AUDIO . equals ( name ) ) { listener . onASrAudio ( data , offset , length ) ; } } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . wakeup ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . listener . IWakeupListener ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . Map ; public class MyWakeup { private static boolean isInited = false ; private EventManager wp ; private EventListener eventListener ; private static final String TAG = "<STR_LIT>" ; public MyWakeup ( Context context , EventListener eventListener ) { if ( isInited ) { MyLogger . error ( TAG , "<STR_LIT>" ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } isInited = true ; this . eventListener = eventListener ; wp = EventManagerFactory . create ( context , "<STR_LIT>" ) ; wp . registerListener ( eventListener ) ; } public MyWakeup ( Context context , IWakeupListener eventListener ) { this ( context , new WakeupEventAdapter ( eventListener ) ) ; } public void start ( Map < String , Object > params ) { String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + "<STR_LIT>" , "<STR_LIT>" + json ) ; wp . send ( SpeechConstant . WAKEUP_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; } public void stop ( ) { MyLogger . info ( TAG , "<STR_LIT>" ) ; wp . send ( SpeechConstant . WAKEUP_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } public void setEventListener ( EventListener eventListener ) { this . eventListener = eventListener ; } public void setEventListener ( IWakeupListener eventListener ) { this . eventListener = new WakeupEventAdapter ( eventListener ) ; } public void release ( ) { stop ( ) ; wp . unregisterListener ( eventListener ) ; wp = null ; isInited = false ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . util ; import android . content . res . AssetManager ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; public class FileUtil { public static boolean makeDir ( String dirPath ) { File file = new File ( dirPath ) ; if ( ! file . exists ( ) ) { return file . mkdirs ( ) ; } else { return true ; } } public static String getContentFromAssetsFile ( AssetManager assets , String source ) { InputStream is = null ; FileOutputStream fos = null ; String result = "<STR_LIT>" ; try { is = assets . open ( source ) ; int lenght = is . available ( ) ; byte [ ] buffer = new byte [ lenght ] ; is . read ( buffer ) ; result = new String ( buffer , "<STR_LIT>" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static boolean copyFromAssets ( AssetManager assets , String source , String dest , boolean isCover ) throws IOException { File file = new File ( dest ) ; boolean isCopyed = false ; if ( isCover || ( ! isCover && ! file . exists ( ) ) ) { InputStream is = null ; FileOutputStream fos = null ; try { is = assets . open ( source ) ; String path = dest ; fos = new FileOutputStream ( path ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int size = <NUM_LIT> ; while ( ( size = is . read ( buffer , <NUM_LIT> , <NUM_LIT> ) ) >= <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , size ) ; } isCopyed = true ; } finally { if ( fos != null ) { try { fos . close ( ) ; } finally { if ( is != null ) { is . close ( ) ; } } } } } return isCopyed ; } } </s>
<s> package com . skythinker . gptassistant ; import org . junit . Test ; import static org . junit . Assert . * ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; public class TabDetailConfActivity extends Activity { private EditText etTitle , etPrompt ; private boolean isFromOnlineTemplates = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_tab_detail_conf ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( "<STR_LIT>" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; etTitle = findViewById ( R . id . et_tab_detail_title ) ; etPrompt = findViewById ( R . id . et_tab_detail_prompt ) ; Intent recv_intent = getIntent ( ) ; if ( recv_intent . hasExtra ( "<STR_LIT>" ) ) { etTitle . setText ( recv_intent . getStringExtra ( "<STR_LIT>" ) ) ; } else { etTitle . setText ( "<STR_LIT>" ) ; } if ( recv_intent . hasExtra ( "<STR_LIT>" ) ) { etPrompt . setText ( recv_intent . getStringExtra ( "<STR_LIT>" ) ) ; } else { etPrompt . setText ( "<STR_LIT>" ) ; } ( findViewById ( R . id . cv_tab_detail_cancel ) ) . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . putExtra ( "<STR_LIT>" , false ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } ) ; ( findViewById ( R . id . cv_tab_detail_ok ) ) . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . putExtra ( "<STR_LIT>" , true ) ; intent . putExtra ( "<STR_LIT>" , etTitle . getText ( ) . toString ( ) ) ; intent . putExtra ( "<STR_LIT>" , etPrompt . getText ( ) . toString ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , isFromOnlineTemplates ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } ) ; ( findViewById ( R . id . bt_tab_detail_help ) ) . setOnClickListener ( view -> { GlobalUtils . browseURL ( this , getString ( R . string . template_help_url ) ) ; } ) ; ( findViewById ( R . id . bt_online_templates ) ) . setOnClickListener ( view -> { startActivityForResult ( new Intent ( TabDetailConfActivity . this , OnlineTemplatesActivity . class ) , <NUM_LIT> ) ; } ) ; ( findViewById ( R . id . bt_tab_detail_back ) ) . setOnClickListener ( view -> { finish ( ) ; } ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == <NUM_LIT> && resultCode == RESULT_OK ) { etTitle . setText ( data . getStringExtra ( "<STR_LIT>" ) ) ; etPrompt . setText ( data . getStringExtra ( "<STR_LIT>" ) ) ; isFromOnlineTemplates = true ; } } @ Override public void finish ( ) { super . finish ( ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Intent ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageButton ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; import androidx . recyclerview . widget . RecyclerView ; public class TabConfListAdapter extends RecyclerView . Adapter < TabConfListAdapter . ViewHolder > { private TabConfActivity tabConfActivity ; public TabConfListAdapter ( TabConfActivity tabConfActivity ) { this . tabConfActivity = tabConfActivity ; } public static class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvPrompt ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_list_item_title ) ; tvPrompt = itemView . findViewById ( R . id . tv_list_item_prompt ) ; llOuter = itemView . findViewById ( R . id . ll_list_item_outer ) ; llOuter . setOnClickListener ( null ) ; llOuter . setOnClickListener ( view -> { PromptTabData tab = GlobalDataHolder . getTabDataList ( ) . get ( getAdapterPosition ( ) ) ; Intent broadcastIntent = new Intent ( "<STR_LIT>" ) ; broadcastIntent . putExtra ( "<STR_LIT>" , tab . getTitle ( ) ) ; broadcastIntent . putExtra ( "<STR_LIT>" , tab . getPrompt ( ) ) ; broadcastIntent . putExtra ( "<STR_LIT>" , getAdapterPosition ( ) ) ; LocalBroadcastManager . getInstance ( view . getContext ( ) ) . sendBroadcast ( broadcastIntent ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + tab . getTitle ( ) + "<STR_LIT>" + getAdapterPosition ( ) ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + GlobalDataHolder . getTabDataList ( ) . get ( <NUM_LIT> ) . getTitle ( ) ) ; } ) ; } } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . tab_conf_list_item , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { PromptTabData tab = GlobalDataHolder . getTabDataList ( ) . get ( position ) ; holder . tvTitle . setText ( tab . getTitle ( ) ) ; holder . tvPrompt . setText ( tab . getContentWithoutParams ( ) ) ; } @ Override public int getItemCount ( ) { return GlobalDataHolder . getTabDataList ( ) . size ( ) ; } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import com . baidu . aip . asrwakeup3 . core . R ; import com . baidu . aip . asrwakeup3 . core . util . AuthUtil ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . Map ; public class ActivityMiniRecog extends AppCompatActivity implements EventListener { protected TextView txtLog ; protected TextView txtResult ; protected Button btn ; protected Button stopBtn ; private static String DESC_TEXT = "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; private EventManager asr ; private boolean logTime = true ; protected boolean enableOffline = false ; private void start ( ) { txtLog . setText ( "<STR_LIT>" ) ; Map < String , Object > params = AuthUtil . getParam ( ) ; String event = null ; event = SpeechConstant . ASR_START ; if ( enableOffline ) { params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; } params . put ( SpeechConstant . ACCEPT_AUDIO_VOLUME , false ) ; ( new AutoCheck ( getApplicationContext ( ) , new Handler ( ) { public void handleMessage ( Message msg ) { if ( msg . what == <NUM_LIT> ) { AutoCheck autoCheck = ( AutoCheck ) msg . obj ; synchronized ( autoCheck ) { String message = autoCheck . obtainErrorMessage ( ) ; txtLog . append ( message + "<STR_LIT>" ) ; ; } } } } , enableOffline ) ) . checkAsr ( params ) ; String json = null ; json = new JSONObject ( params ) . toString ( ) ; asr . send ( event , json , null , <NUM_LIT> , <NUM_LIT> ) ; printLog ( "<STR_LIT>" + json ) ; } private void stop ( ) { printLog ( "<STR_LIT>" ) ; asr . send ( SpeechConstant . ASR_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } private void loadOfflineEngine ( ) { Map < String , Object > params = new LinkedHashMap < String , Object > ( ) ; params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; params . put ( SpeechConstant . ASR_OFFLINE_ENGINE_GRAMMER_FILE_PATH , "<STR_LIT>" ) ; asr . send ( SpeechConstant . ASR_KWS_LOAD_ENGINE , new JSONObject ( params ) . toString ( ) , null , <NUM_LIT> , <NUM_LIT> ) ; } private void unloadOfflineEngine ( ) { asr . send ( SpeechConstant . ASR_KWS_UNLOAD_ENGINE , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . common_mini ) ; initView ( ) ; initPermission ( ) ; asr = EventManagerFactory . create ( this , "<STR_LIT>" ) ; asr . registerListener ( this ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { start ( ) ; } } ) ; stopBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { stop ( ) ; } } ) ; if ( enableOffline ) { loadOfflineEngine ( ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; Log . i ( "<STR_LIT>" , "<STR_LIT>" ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; if ( enableOffline ) { unloadOfflineEngine ( ) ; } asr . unregisterListener ( this ) ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String logTxt = "<STR_LIT>" + name ; if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { if ( params == null || params . isEmpty ( ) ) { return ; } if ( params . contains ( "<STR_LIT>" ) ) { if ( length > <NUM_LIT> && data . length > <NUM_LIT> ) { logTxt += "<STR_LIT>" + new String ( data , offset , length ) ; } } else if ( params . contains ( "<STR_LIT>" ) ) { logTxt += "<STR_LIT>" + params ; } else if ( params . contains ( "<STR_LIT>" ) ) { logTxt += "<STR_LIT>" + params ; } else { logTxt += "<STR_LIT>" + params ; if ( data != null ) { logTxt += "<STR_LIT>" + data . length ; } } } else { if ( params != null && ! params . isEmpty ( ) ) { logTxt += "<STR_LIT>" + params ; } if ( data != null ) { logTxt += "<STR_LIT>" + data . length ; } } printLog ( logTxt ) ; } private void printLog ( String text ) { if ( logTime ) { text += "<STR_LIT>" + System . currentTimeMillis ( ) ; } text += "<STR_LIT>" ; Log . i ( getClass ( ) . getName ( ) , text ) ; txtLog . append ( text + "<STR_LIT>" ) ; } private void initView ( ) { txtResult = ( TextView ) findViewById ( R . id . txtResult ) ; txtLog = ( TextView ) findViewById ( R . id . txtLog ) ; btn = ( Button ) findViewById ( R . id . btn ) ; stopBtn = ( Button ) findViewById ( R . id . btn_stop ) ; txtLog . setText ( DESC_TEXT + "<STR_LIT>" ) ; } private void initPermission ( ) { String permissions [ ] = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String tmpList [ ] = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import com . baidu . aip . asrwakeup3 . core . R ; import com . baidu . aip . asrwakeup3 . core . inputstream . InFileStream ; import com . baidu . aip . asrwakeup3 . core . util . AuthUtil ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . ArrayList ; import java . util . Map ; import java . util . TreeMap ; public class ActivityMiniWakeUp extends AppCompatActivity implements EventListener { protected TextView txtLog ; protected TextView txtResult ; protected Button btn ; protected Button stopBtn ; private static String DESC_TEXT = "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; private EventManager wakeup ; private boolean logTime = true ; private void start ( ) { txtLog . setText ( "<STR_LIT>" ) ; Map < String , Object > params = AuthUtil . getParam ( ) ; params . put ( SpeechConstant . ACCEPT_AUDIO_VOLUME , false ) ; params . put ( SpeechConstant . WP_WORDS_FILE , "<STR_LIT>" ) ; InFileStream . setContext ( this ) ; String json = null ; json = new JSONObject ( params ) . toString ( ) ; wakeup . send ( SpeechConstant . WAKEUP_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; printLog ( "<STR_LIT>" + json ) ; } private void stop ( ) { wakeup . send ( SpeechConstant . WAKEUP_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . common_mini ) ; initView ( ) ; initPermission ( ) ; wakeup = EventManagerFactory . create ( this , "<STR_LIT>" ) ; wakeup . registerListener ( this ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { start ( ) ; } } ) ; stopBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { stop ( ) ; } } ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; wakeup . send ( SpeechConstant . WAKEUP_STOP , "<STR_LIT>" , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String logTxt = "<STR_LIT>" + name ; if ( params != null && ! params . isEmpty ( ) ) { logTxt += "<STR_LIT>" + params ; } else if ( data != null ) { logTxt += "<STR_LIT>" + data . length ; } printLog ( logTxt ) ; } private void printLog ( String text ) { if ( logTime ) { text += "<STR_LIT>" + System . currentTimeMillis ( ) ; } text += "<STR_LIT>" ; Log . i ( getClass ( ) . getName ( ) , text ) ; txtLog . append ( text + "<STR_LIT>" ) ; } private void initView ( ) { txtResult = ( TextView ) findViewById ( R . id . txtResult ) ; txtLog = ( TextView ) findViewById ( R . id . txtLog ) ; btn = ( Button ) findViewById ( R . id . btn ) ; stopBtn = ( Button ) findViewById ( R . id . btn_stop ) ; txtLog . setText ( DESC_TEXT + "<STR_LIT>" ) ; } private void initPermission ( ) { String [ ] permissions = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String [ ] tmpList = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { } } </s>
<s> package com . skythinker . gptassistant ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . graphics . Rect ; import android . text . Layout ; import android . text . Spanned ; import android . text . TextPaint ; import android . text . style . ClickableSpan ; import android . text . style . LeadingMarginSpan ; import android . util . Log ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import org . commonmark . node . FencedCodeBlock ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import io . noties . markwon . AbstractMarkwonPlugin ; import io . noties . markwon . Markwon ; import io . noties . markwon . MarkwonConfiguration ; import io . noties . markwon . MarkwonSpansFactory ; import io . noties . markwon . ext . latex . JLatexMathPlugin ; import io . noties . markwon . ext . tables . TableAwareMovementMethod ; import io . noties . markwon . ext . tables . TablePlugin ; import io . noties . markwon . image . ImageSize ; import io . noties . markwon . image . ImageSizeResolverDef ; import io . noties . markwon . image . ImagesPlugin ; import io . noties . markwon . inlineparser . MarkwonInlineParserPlugin ; import io . noties . markwon . linkify . LinkifyPlugin ; import io . noties . markwon . movement . MovementMethodPlugin ; import io . noties . markwon . syntax . Prism4jThemeDefault ; import io . noties . markwon . syntax . SyntaxHighlightPlugin ; import io . noties . markwon . utils . LeadingMarginUtils ; import io . noties . prism4j . Prism4j ; public class MarkdownRenderer { private final Context context ; private final Markwon markwon ; class ClickToCopySpan extends ClickableSpan { @ Override public void onClick ( @ NonNull View widget ) { if ( widget instanceof TextView ) { Spanned spanned = ( Spanned ) ( ( TextView ) widget ) . getText ( ) ; int start = spanned . getSpanStart ( this ) ; int end = spanned . getSpanEnd ( this ) ; String text = spanned . subSequence ( start , end ) . toString ( ) . trim ( ) ; GlobalUtils . copyToClipboard ( context , text ) ; GlobalUtils . showToast ( context , context . getString ( R . string . toast_code_clipboard ) , false ) ; } } @ Override public void updateDrawState ( @ NonNull TextPaint ds ) { } } class CopyIconSpan implements LeadingMarginSpan { @ Override public int getLeadingMargin ( boolean first ) { return <NUM_LIT> ; } @ Override public void drawLeadingMargin ( @ NonNull Canvas canvas , @ NonNull Paint p , int x , int dir , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , boolean first , @ NonNull Layout layout ) { if ( ! LeadingMarginUtils . selfStart ( start , text , this ) ) return ; int save = canvas . save ( ) ; try { Paint paint = new Paint ( ) ; String textToDraw = context . getString ( R . string . text_copy_code_notice ) ; paint . setTextSize ( GlobalUtils . dpToPx ( context , <NUM_LIT> ) ) ; paint . setColor ( <NUM_LIT> ) ; Rect bounds = new Rect ( ) ; paint . getTextBounds ( textToDraw , <NUM_LIT> , textToDraw . length ( ) , bounds ) ; int y = top + bounds . height ( ) + GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; int x1 = layout . getWidth ( ) - bounds . width ( ) - GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; if ( layout . getWidth ( ) > bounds . width ( ) + GlobalUtils . dpToPx ( context , <NUM_LIT> ) ) canvas . drawText ( textToDraw , x1 , y , paint ) ; } finally { canvas . restoreToCount ( save ) ; } } } public MarkdownRenderer ( Context context ) { this . context = context ; markwon = Markwon . builder ( context ) . usePlugin ( SyntaxHighlightPlugin . create ( new Prism4j ( new GrammarLocatorDef ( ) ) , Prism4jThemeDefault . create ( <NUM_LIT> ) ) ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ Override public void configureSpansFactory ( @ NonNull MarkwonSpansFactory . Builder builder ) { builder . appendFactory ( FencedCodeBlock . class , ( configuration , props ) -> new ClickToCopySpan ( ) ) ; } } ) . usePlugin ( JLatexMathPlugin . create ( <NUM_LIT> , builder -> builder . inlinesEnabled ( true ) ) ) . usePlugin ( ImagesPlugin . create ( ) ) . usePlugin ( MarkwonInlineParserPlugin . create ( ) ) . usePlugin ( LinkifyPlugin . create ( ) ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ NonNull @ Override public String processMarkdown ( @ NonNull String markdown ) { List < String > sepList = new ArrayList < > ( Arrays . asList ( markdown . split ( "<STR_LIT>" , - <NUM_LIT> ) ) ) ; for ( int i = <NUM_LIT> ; i < sepList . size ( ) ; i += <NUM_LIT> ) { String regexDollar = "<STR_LIT>" ; String regexBrackets = "<STR_LIT>" ; String regexParentheses = "<STR_LIT>" ; String latexReplacement = "<STR_LIT>" ; String regexImage = "<STR_LIT>" ; String imageReplacement = "<STR_LIT>" ; sepList . set ( i , sepList . get ( i ) . replaceAll ( regexDollar , latexReplacement ) . replaceAll ( regexBrackets , latexReplacement ) . replaceAll ( regexParentheses , latexReplacement ) . replaceAll ( regexImage , imageReplacement ) ) ; } return String . join ( "<STR_LIT>" , sepList ) ; } } ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ Override public void configureConfiguration ( @ NonNull MarkwonConfiguration . Builder builder ) { builder . imageSizeResolver ( new ImageSizeResolverDef ( ) { @ NonNull @ Override protected Rect resolveImageSize ( @ Nullable ImageSize imageSize , @ NonNull Rect imageBounds , int canvasWidth , float textSize ) { int maxSize = GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; if ( imageBounds . width ( ) > maxSize || imageBounds . height ( ) > maxSize ) { float ratio = Math . min ( ( float ) maxSize / imageBounds . width ( ) , ( float ) maxSize / imageBounds . height ( ) ) ; imageBounds . right = imageBounds . left + ( int ) ( imageBounds . width ( ) * ratio ) ; imageBounds . bottom = imageBounds . top + ( int ) ( imageBounds . height ( ) * ratio ) ; } return imageBounds ; } } ) ; } } ) . build ( ) ; } public void render ( TextView textView , String markdown ) { if ( textView != null && markdown != null ) { try { markwon . setMarkdown ( textView , markdown ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } </s>
<s> package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import android . os . Handler ; import com . baidu . aip . asrwakeup3 . core . recog . IStatus ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public class RecogWakeupListener extends SimpleWakeupListener implements IStatus { private static final String TAG = "<STR_LIT>" ; private Handler handler ; public RecogWakeupListener ( Handler handler ) { this . handler = handler ; } @ Override public void onSuccess ( String word , WakeUpResult result ) { super . onSuccess ( word , result ) ; handler . sendMessage ( handler . obtainMessage ( STATUS_WAKEUP_SUCCESS ) ) ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . recyclerview . widget . RecyclerView ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; public class RecyclerItemClickListener implements RecyclerView . OnItemTouchListener { private OnItemClickListener mListener ; public interface OnItemClickListener { void onItemClick ( View view , int position ) ; void onLongItemClick ( View view , int position ) ; } private GestureDetector mGestureDetector ; public RecyclerItemClickListener ( Context context , final RecyclerView recyclerView , OnItemClickListener listener ) { mListener = listener ; mGestureDetector = new GestureDetector ( context , new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onSingleTapUp ( MotionEvent e ) { return true ; } @ Override public void onLongPress ( MotionEvent e ) { View child = recyclerView . findChildViewUnder ( e . getX ( ) , e . getY ( ) ) ; if ( child != null && mListener != null ) { mListener . onLongItemClick ( child , recyclerView . getChildAdapterPosition ( child ) ) ; } } } ) ; } @ Override public boolean onInterceptTouchEvent ( RecyclerView view , MotionEvent e ) { View childView = view . findChildViewUnder ( e . getX ( ) , e . getY ( ) ) ; if ( childView != null && mListener != null && mGestureDetector . onTouchEvent ( e ) ) { mListener . onItemClick ( childView , view . getChildAdapterPosition ( childView ) ) ; return true ; } return false ; } @ Override public void onTouchEvent ( RecyclerView view , MotionEvent motionEvent ) { } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } } </s>
<s> package org . woheller69 . weather . preferences ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Handler ; import android . os . Looper ; import android . widget . Toast ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class AppPreferencesManager { SharedPreferences preferences ; public AppPreferencesManager ( SharedPreferences preferences ) { this . preferences = preferences ; } public boolean isFirstTimeLaunch ( Context context ) { boolean result = preferences . getBoolean ( "<STR_LIT>" , true ) ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , false ) ; editor . apply ( ) ; return result ; } public float convertTemperatureFromCelsius ( float temperature ) { int prefValue = Integer . parseInt ( preferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefValue == <NUM_LIT> ) { return temperature ; } else { return ( ( ( temperature * <NUM_LIT> ) / <NUM_LIT> ) + <NUM_LIT> ) ; } } public float convertPrecipitationFromMM ( float precipitation ) { int prefValue = Integer . parseInt ( preferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefValue == <NUM_LIT> ) { return precipitation ; } else { return ( float ) ( precipitation / <NUM_LIT> ) ; } } public String getTemperatureUnit ( ) { int prefValue = Integer . parseInt ( preferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefValue == <NUM_LIT> ) { return "<STR_LIT>" ; } else { return "<STR_LIT>" ; } } public String getPrecipitationUnit ( Context context ) { int prefValue = Integer . parseInt ( preferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefValue == <NUM_LIT> ) { return context . getString ( R . string . units_mm ) ; } else { return context . getString ( R . string . units_in ) ; } } public boolean showStarDialog ( Context context ) { int versionCode = preferences . getInt ( "<STR_LIT>" , BuildConfig . VERSION_CODE ) ; boolean askForStar = preferences . getBoolean ( "<STR_LIT>" , true ) ; if ( ! isFirstTimeLaunch ( context ) && BuildConfig . VERSION_CODE > versionCode && askForStar ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putInt ( "<STR_LIT>" , BuildConfig . VERSION_CODE ) ; editor . apply ( ) ; return true ; } else { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putInt ( "<STR_LIT>" , BuildConfig . VERSION_CODE ) ; editor . apply ( ) ; return false ; } } public void setAskForStar ( boolean askForStar ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , askForStar ) ; editor . apply ( ) ; } } </s>
<s> package org . woheller69 . weather . widget ; import android . Manifest ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import android . util . Log ; import android . view . View ; import android . widget . RemoteViews ; import android . widget . Toast ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import java . util . Locale ; import java . util . TimeZone ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; public class WeatherWidget extends AppWidgetProvider { private static LocationListener locationListenerGPS ; private LocationManager locationManager ; public void updateAppWidget ( Context context , final int appWidgetId ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) updateLocation ( context , cityID , false ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( "<STR_LIT>" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateLocation ( final Context context , int cityID , boolean manual ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; List < CityToWatch > cities = db . getAllCitiesToWatch ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { LocationManager locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; Location locationGPS = locationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( locationGPS != null ) { CityToWatch city ; double lat = locationGPS . getLatitude ( ) ; double lon = locationGPS . getLongitude ( ) ; for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { if ( cities . get ( i ) . getCityId ( ) == cityID ) { city = cities . get ( i ) ; city . setLatitude ( ( float ) lat ) ; city . setLongitude ( ( float ) lon ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , lat , lon ) ) ; db . updateCityToWatch ( city ) ; break ; } } } else { if ( manual ) Toast . makeText ( context . getApplicationContext ( ) , R . string . error_no_position , Toast . LENGTH_SHORT ) . show ( ) ; } } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , CurrentWeatherData weatherData , List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; long time = weatherData . getTimestamp ( ) ; int zoneseconds = weatherData . getTimeZoneSeconds ( ) ; int [ ] forecastIDs = { R . id . widget_hour12 , R . id . widget_hour1 , R . id . widget_hour2 , R . id . widget_hour3 , R . id . widget_hour4 , R . id . widget_hour5 , R . id . widget_hour6 , R . id . widget_hour7 , R . id . widget_hour8 , R . id . widget_hour9 , R . id . widget_hour10 , R . id . widget_hour11 } ; int [ ] windIDs = { R . id . widget_windicon_hour12 , R . id . widget_windicon_hour1 , R . id . widget_windicon_hour2 , R . id . widget_windicon_hour3 , R . id . widget_windicon_hour4 , R . id . widget_windicon_hour5 , R . id . widget_windicon_hour6 , R . id . widget_windicon_hour7 , R . id . widget_windicon_hour8 , R . id . widget_windicon_hour9 , R . id . widget_windicon_hour10 , R . id . widget_windicon_hour11 } ; long updateTime = ( time + zoneseconds ) * <NUM_LIT> ; long riseTime = ( weatherData . getTimeSunrise ( ) + zoneseconds ) * <NUM_LIT> ; long setTime = ( weatherData . getTimeSunset ( ) + zoneseconds ) * <NUM_LIT> ; boolean isDay = weatherData . isDay ( context ) ; if ( ! dbHelper . hasQuarterHourly ( weatherData . getCity_id ( ) ) ) { HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( nowCast . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , "<STR_LIT>" + StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) + "<STR_LIT>" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = dbHelper . getQuarterHourlyForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } views . setViewVisibility ( R . id . widget_attribution , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . INVISIBLE ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . INVISIBLE ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( next . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , "<STR_LIT>" + StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) + "<STR_LIT>" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; } SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) views . setViewVisibility ( R . id . location_on , View . VISIBLE ) ; else views . setViewVisibility ( R . id . location_on , View . GONE ) ; views . setTextViewText ( R . id . widget_updatetime , String . format ( "<STR_LIT>" , StringFormatUtils . formatTimeWithoutZone ( context , updateTime ) ) ) ; views . setViewPadding ( R . id . widget_temperature , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; views . setTextViewText ( R . id . widget_max_Temp , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_min_Temp , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_city_name , city . getCityName ( ) ) ; if ( riseTime == zoneseconds * <NUM_LIT> || setTime == zoneseconds * <NUM_LIT> ) views . setTextViewText ( R . id . widget_sunrise_sunset , "<STR_LIT>" + "<STR_LIT>" ) ; else { views . setTextViewText ( R . id . widget_sunrise_sunset , "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , riseTime ) + "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , setTime ) ) ; } if ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) == - <NUM_LIT> ) { views . setViewVisibility ( R . id . widget_UVindex , View . GONE ) ; } else { views . setViewVisibility ( R . id . widget_UVindex , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_UVindex , "<STR_LIT>" ) ; views . setInt ( R . id . widget_UVindex , "<STR_LIT>" , StringFormatUtils . widgetColorUVindex ( context , Math . round ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) ) ) ) ; } for ( int i = <NUM_LIT> ; i < forecastIDs . length ; i ++ ) { views . setImageViewBitmap ( forecastIDs [ i ] , null ) ; views . setImageViewBitmap ( windIDs [ i ] , null ) ; } if ( hourlyforecasts != null && ! hourlyforecasts . isEmpty ( ) ) { List < HourlyForecast > templist = new ArrayList < > ( ) ; for ( HourlyForecast f : hourlyforecasts ) { if ( f . getForecastTime ( ) >= System . currentTimeMillis ( ) - ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) templist . add ( f ) ; } hourlyforecasts = templist ; for ( int i = <NUM_LIT> ; i < forecastIDs . length ; i ++ ) { Calendar forecastTime = Calendar . getInstance ( ) ; forecastTime . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; forecastTime . setTimeInMillis ( hourlyforecasts . get ( i ) . getLocalForecastTime ( context ) ) ; int hour = forecastTime . get ( Calendar . HOUR ) % <NUM_LIT> ; if ( weatherData . getTimeSunrise ( ) == <NUM_LIT> || weatherData . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( hourlyforecasts . get ( i ) . getCity_id ( ) ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && forecastTime . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || forecastTime . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { Calendar sunSetTime = Calendar . getInstance ( ) ; sunSetTime . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; sunSetTime . setTimeInMillis ( weatherData . getTimeSunset ( ) * <NUM_LIT> + weatherData . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunSetTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunSetTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; Calendar sunRiseTime = Calendar . getInstance ( ) ; sunRiseTime . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; sunRiseTime . setTimeInMillis ( weatherData . getTimeSunrise ( ) * <NUM_LIT> + weatherData . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunRiseTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunRiseTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; isDay = forecastTime . after ( sunRiseTime ) && forecastTime . before ( sunSetTime ) ; } views . setImageViewResource ( forecastIDs [ hour ] , UiResourceProvider . getIconResourceForWeatherCategory ( hourlyforecasts . get ( i ) . getWeatherID ( ) , isDay ) ) ; views . setImageViewResource ( windIDs [ hour ] , StringFormatUtils . colorWindSpeedWidget ( hourlyforecasts . get ( i ) . getWindSpeed ( ) ) ) ; } } Intent intentUpdate = new Intent ( context , WeatherWidget . class ) ; intentUpdate . setAction ( AppWidgetManager . ACTION_APPWIDGET_UPDATE ) ; int [ ] idArray = new int [ ] { appWidgetId } ; intentUpdate . putExtra ( AppWidgetManager . EXTRA_APPWIDGET_IDS , idArray ) ; intentUpdate . putExtra ( "<STR_LIT>" , true ) ; PendingIntent pendingUpdate ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingUpdate = PendingIntent . getBroadcast ( context , appWidgetId , intentUpdate , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingUpdate = PendingIntent . getBroadcast ( context , appWidgetId , intentUpdate , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_update , pendingUpdate ) ; Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( "<STR_LIT>" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( final Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; PowerManager powerManager = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) && ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED && ! powerManager . isPowerSaveMode ( ) ) { if ( locationListenerGPS == null ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; locationListenerGPS = new LocationListener ( ) { @ Override public void onLocationChanged ( android . location . Location location ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; int [ ] appWidgetIds = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } else { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( widgetCityID ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; List < HourlyForecast > hourlyforecasts = dbHelper . getForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int widgetID : widgetIDs ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts , hourlyforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getBooleanExtra ( "<STR_LIT>" , false ) ) { int cityID = getWidgetCityID ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) updateLocation ( context , cityID , true ) ; } super . onReceive ( context , intent ) ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . core . content . ContextCompat ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . content . SharedPreferences ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import com . db . chart . Tools ; import com . db . chart . model . BarSet ; import com . db . chart . model . ChartSet ; import com . db . chart . model . LineSet ; import com . db . chart . view . AxisController ; import com . db . chart . view . BarChartView ; import com . db . chart . view . LineChartView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import java . util . TimeZone ; public class CityWeatherAdapter extends RecyclerView . Adapter < CityWeatherAdapter . ViewHolder > { private static final String TAG = "<STR_LIT>" ; private int [ ] dataSetTypes ; private List < HourlyForecast > courseDayList ; private List < WeekForecast > weekForecastList ; private Context context ; private ViewGroup mParent ; private RecyclerView mCourseOfDay ; private RecyclerView mWeekWeather ; private CurrentWeatherData currentWeatherDataList ; public static final int OVERVIEW = <NUM_LIT> ; public static final int DETAILS = <NUM_LIT> ; public static final int WEEK = <NUM_LIT> ; public static final int DAY = <NUM_LIT> ; public static final int CHART = <NUM_LIT> ; public static final int EMPTY = <NUM_LIT> ; public CityWeatherAdapter ( CurrentWeatherData currentWeatherDataList , int [ ] dataSetTypes , Context context ) { this . currentWeatherDataList = currentWeatherDataList ; this . dataSetTypes = dataSetTypes ; this . context = context ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; List < HourlyForecast > hourlyForecasts = database . getForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; List < WeekForecast > weekforecasts = database . getWeekForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; updateForecastData ( hourlyForecasts ) ; updateWeekForecastData ( weekforecasts ) ; } public void updateForecastData ( List < HourlyForecast > hourlyForecasts ) { if ( hourlyForecasts . isEmpty ( ) ) return ; courseDayList = new ArrayList < > ( ) ; long onehourago = System . currentTimeMillis ( ) - ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( f . getForecastTime ( ) >= onehourago ) { courseDayList . add ( f ) ; } } notifyDataSetChanged ( ) ; } public void updateWeekForecastData ( List < WeekForecast > forecasts ) { if ( forecasts . isEmpty ( ) ) return ; weekForecastList = forecasts ; notifyDataSetChanged ( ) ; } static class ViewHolder extends RecyclerView . ViewHolder { ViewHolder ( View v ) { super ( v ) ; } } public class OverViewHolder extends ViewHolder { TextView temperature ; ImageView weather ; ImageView windicon ; TextView updatetime ; TextView sun ; TextView precipforecast ; OverViewHolder ( View v ) { super ( v ) ; this . temperature = v . findViewById ( R . id . card_overview_temperature ) ; this . weather = v . findViewById ( R . id . card_overview_weather_image ) ; this . sun = v . findViewById ( R . id . card_overview_sunrise_sunset ) ; this . windicon = v . findViewById ( R . id . card_overview_windicon ) ; this . updatetime = v . findViewById ( R . id . card_overview_update_time ) ; this . precipforecast = v . findViewById ( R . id . card_overview_precipitation_forecast ) ; } } public class DetailViewHolder extends ViewHolder { TextView humidity ; TextView pressure ; TextView windspeed ; TextView rain60min ; TextView rain60minLegend ; TextView time ; ImageView winddirection ; DetailViewHolder ( View v ) { super ( v ) ; this . humidity = v . findViewById ( R . id . card_details_humidity_value ) ; this . pressure = v . findViewById ( R . id . card_details_pressure_value ) ; this . windspeed = v . findViewById ( R . id . card_details_wind_speed_value ) ; this . rain60min = v . findViewById ( R . id . card_details_rain60min_value ) ; this . rain60minLegend = v . findViewById ( R . id . card_details_legend_rain60min ) ; this . winddirection = v . findViewById ( ( R . id . card_details_wind_direction_value ) ) ; this . time = v . findViewById ( R . id . card_details_title ) ; } } public class WeekViewHolder extends ViewHolder { RecyclerView recyclerView ; WeekViewHolder ( View v ) { super ( v ) ; recyclerView = v . findViewById ( R . id . recycler_view_week ) ; mWeekWeather = recyclerView ; } } public class DayViewHolder extends ViewHolder { RecyclerView recyclerView ; TextView recyclerViewHeader ; DayViewHolder ( View v ) { super ( v ) ; recyclerView = v . findViewById ( R . id . recycler_view_course_day ) ; mCourseOfDay = recyclerView ; recyclerViewHeader = v . findViewById ( R . id . recycler_view_header ) ; } } public class ChartViewHolder extends ViewHolder { TextView temperatureunit ; TextView precipitationunit ; LineChartView lineChartView ; BarChartView barChartView ; BarChartView barChartViewAxis ; ChartViewHolder ( View v ) { super ( v ) ; this . lineChartView = v . findViewById ( R . id . graph_temperature ) ; this . barChartView = v . findViewById ( R . id . graph_precipitation ) ; this . temperatureunit = v . findViewById ( R . id . graph_temperatureunit ) ; this . barChartViewAxis = v . findViewById ( R . id . graph_axis ) ; this . precipitationunit = v . findViewById ( R . id . graph_precipitationunit ) ; } } @ Override public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) { View v ; mParent = viewGroup ; if ( viewType == OVERVIEW ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_overview , viewGroup , false ) ; return new OverViewHolder ( v ) ; } else if ( viewType == DETAILS ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_details , viewGroup , false ) ; return new DetailViewHolder ( v ) ; } else if ( viewType == WEEK ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_week , viewGroup , false ) ; return new WeekViewHolder ( v ) ; } else if ( viewType == DAY ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_day , viewGroup , false ) ; return new DayViewHolder ( v ) ; } else if ( viewType == CHART ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_chart , viewGroup , false ) ; return new ChartViewHolder ( v ) ; } else { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_empty , viewGroup , false ) ; return new ViewHolder ( v ) ; } } @ Override public void onBindViewHolder ( ViewHolder viewHolder , final int position ) { boolean isDay = currentWeatherDataList . isDay ( context ) ; if ( viewHolder . getItemViewType ( ) == OVERVIEW ) { OverViewHolder holder = ( OverViewHolder ) viewHolder ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; int zoneseconds = currentWeatherDataList . getTimeZoneSeconds ( ) ; long riseTime = ( currentWeatherDataList . getTimeSunrise ( ) + zoneseconds ) * <NUM_LIT> ; long setTime = ( currentWeatherDataList . getTimeSunset ( ) + zoneseconds ) * <NUM_LIT> ; if ( riseTime == zoneseconds * <NUM_LIT> || setTime == zoneseconds * <NUM_LIT> ) holder . sun . setText ( "<STR_LIT>" + "<STR_LIT>" ) ; else { holder . sun . setText ( "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , riseTime ) + "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , setTime ) ) ; } long time = currentWeatherDataList . getTimestamp ( ) ; long updateTime = ( ( time + zoneseconds ) * <NUM_LIT> ) ; holder . updatetime . setText ( "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , updateTime ) + "<STR_LIT>" ) ; if ( ! database . hasQuarterHourly ( currentWeatherDataList . getCity_id ( ) ) ) { holder . precipforecast . setVisibility ( View . INVISIBLE ) ; HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = database . getForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; setImage ( nowCast . getWeatherID ( ) , holder . weather , isDay ) ; holder . temperature . setText ( StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = database . getQuarterHourlyForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } holder . precipforecast . setVisibility ( View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { holder . precipforecast . setText ( "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; holder . precipforecast . setVisibility ( View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { holder . precipforecast . setText ( "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; holder . precipforecast . setVisibility ( View . VISIBLE ) ; } } holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; setImage ( next . getWeatherID ( ) , holder . weather , isDay ) ; holder . temperature . setText ( StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) ) ; } } else if ( viewHolder . getItemViewType ( ) == DETAILS ) { } else if ( viewHolder . getItemViewType ( ) == WEEK ) { final WeekViewHolder holder = ( WeekViewHolder ) viewHolder ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context , LinearLayoutManager . HORIZONTAL , false ) ; holder . recyclerView . setLayoutManager ( layoutManager ) ; final WeekWeatherAdapter adapter = new WeekWeatherAdapter ( context , weekForecastList , currentWeatherDataList . getCity_id ( ) ) ; holder . recyclerView . setAdapter ( adapter ) ; holder . recyclerView . setFocusable ( false ) ; if ( mCourseOfDay != null ) { CourseOfDayAdapter dayadapter = ( CourseOfDayAdapter ) mCourseOfDay . getAdapter ( ) ; dayadapter . setWeekRecyclerView ( holder . recyclerView ) ; adapter . setCourseOfDayHeaderDate ( dayadapter . getCourseOfDayHeaderDate ( ) ) ; } holder . recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( context , holder . recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; List < WeekForecast > weekforecasts = database . getWeekForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; long time = weekforecasts . get ( position ) . getForecastTime ( ) ; time = time - <NUM_LIT> * <NUM_LIT> ; if ( mCourseOfDay != null ) { LinearLayoutManager llm = ( LinearLayoutManager ) mCourseOfDay . getLayoutManager ( ) ; assert llm != null ; int num = llm . findLastVisibleItemPosition ( ) - llm . findFirstVisibleItemPosition ( ) ; int i ; for ( i = <NUM_LIT> ; i < courseDayList . size ( ) ; i ++ ) { if ( courseDayList . get ( i ) . getForecastTime ( ) > time ) { Calendar HeaderTime = Calendar . getInstance ( ) ; HeaderTime . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; HeaderTime . setTimeInMillis ( courseDayList . get ( i ) . getLocalForecastTime ( context ) ) ; adapter . setCourseOfDayHeaderDate ( HeaderTime . getTime ( ) ) ; break ; } } if ( i < courseDayList . size ( ) ) { if ( i > llm . findFirstVisibleItemPosition ( ) ) { int min = Math . min ( i + num , courseDayList . size ( ) - <NUM_LIT> ) ; mCourseOfDay . getLayoutManager ( ) . scrollToPosition ( min ) ; } else { mCourseOfDay . getLayoutManager ( ) . scrollToPosition ( i ) ; } } } } public void onLongItemClick ( View view , int position ) { } } ) ) ; } else if ( viewHolder . getItemViewType ( ) == DAY ) { DayViewHolder holder = ( DayViewHolder ) viewHolder ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context , LinearLayoutManager . HORIZONTAL , false ) ; holder . recyclerView . setLayoutManager ( layoutManager ) ; CourseOfDayAdapter adapter = new CourseOfDayAdapter ( courseDayList , context , holder . recyclerViewHeader , holder . recyclerView ) ; holder . recyclerView . setAdapter ( adapter ) ; holder . recyclerView . setFocusable ( false ) ; } else if ( viewHolder . getItemViewType ( ) == CHART ) { ChartViewHolder holder = ( ChartViewHolder ) viewHolder ; if ( weekForecastList == null || weekForecastList . isEmpty ( ) ) return ; AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this . context ) ) ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( this . context ) ; float tmin = <NUM_LIT> ; float tmax = - <NUM_LIT> ; float pmax = <NUM_LIT> ; LineSet datasetmax = new LineSet ( ) ; LineSet datasetmin = new LineSet ( ) ; LineSet xaxis = new LineSet ( ) ; BarSet precipitationDataset = new BarSet ( ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; int zonemilliseconds = currentWeatherDataList . getTimeZoneSeconds ( ) * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < weekForecastList . size ( ) ; i ++ ) { c . setTimeInMillis ( weekForecastList . get ( i ) . getForecastTime ( ) + zonemilliseconds ) ; int day = c . get ( Calendar . DAY_OF_WEEK ) ; float temp_max = weekForecastList . get ( i ) . getMaxTemperature ( ) ; float temp_min = weekForecastList . get ( i ) . getMinTemperature ( ) ; float precip = weekForecastList . get ( i ) . getPrecipitation ( ) ; String dayString = context . getResources ( ) . getString ( StringFormatUtils . getDayShort ( day ) ) ; if ( weekForecastList . size ( ) > <NUM_LIT> ) dayString = dayString . substring ( <NUM_LIT> , <NUM_LIT> ) ; if ( ( i == <NUM_LIT> ) || ( i == ( weekForecastList . size ( ) - <NUM_LIT> ) ) ) { precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; datasetmax . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_max ) ) ; datasetmin . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_min ) ) ; } else { precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; datasetmax . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_max ) ) ; datasetmin . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_min ) ) ; } if ( prefManager . convertTemperatureFromCelsius ( temp_max ) > tmax ) tmax = prefManager . convertTemperatureFromCelsius ( temp_max ) ; if ( prefManager . convertTemperatureFromCelsius ( temp_min ) < tmin ) tmin = prefManager . convertTemperatureFromCelsius ( temp_min ) ; if ( prefManager . convertPrecipitationFromMM ( precip ) > pmax ) pmax = prefManager . convertPrecipitationFromMM ( precip ) ; } tmax ++ ; tmin -- ; int mid = Math . round ( ( tmin + tmax ) / <NUM_LIT> ) ; int step = Math . max ( <NUM_LIT> , ( int ) Math . ceil ( Math . abs ( tmax - tmin ) / <NUM_LIT> ) ) ; for ( int i = <NUM_LIT> ; i < weekForecastList . size ( ) ; i ++ ) { xaxis . addPoint ( "<STR_LIT>" , mid - <NUM_LIT> * step ) ; } ArrayList < ChartSet > temperature = new ArrayList < > ( ) ; temperature . add ( datasetmax ) ; temperature . add ( datasetmin ) ; temperature . add ( xaxis ) ; datasetmax . setColor ( ContextCompat . getColor ( context , R . color . red ) ) ; datasetmax . setThickness ( <NUM_LIT> ) ; datasetmax . setSmooth ( true ) ; datasetmax . setFill ( ContextCompat . getColor ( context , R . color . middlegrey ) ) ; datasetmin . setColor ( ContextCompat . getColor ( context , R . color . lightblue ) ) ; datasetmin . setThickness ( <NUM_LIT> ) ; datasetmin . setSmooth ( true ) ; datasetmin . setFill ( ContextCompat . getColor ( context , R . color . backgroundBlue ) ) ; xaxis . setThickness ( <NUM_LIT> ) ; xaxis . setColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; ArrayList < ChartSet > precipitation = new ArrayList < > ( ) ; precipitation . add ( precipitationDataset ) ; precipitationDataset . setColor ( ContextCompat . getColor ( context , R . color . blue ) ) ; precipitationDataset . setAlpha ( <NUM_LIT> ) ; holder . lineChartView . addData ( temperature ) ; holder . lineChartView . setAxisBorderValues ( mid - <NUM_LIT> * step , mid + <NUM_LIT> * step ) ; holder . lineChartView . setStep ( step ) ; holder . lineChartView . setXAxis ( false ) ; holder . lineChartView . setYAxis ( false ) ; holder . lineChartView . setYLabels ( AxisController . LabelPosition . INSIDE ) ; holder . lineChartView . setLabelsColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . lineChartView . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . lineChartView . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . lineChartView . setBorderSpacing ( Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . lineChartView . show ( ) ; int stepnum = sp . getString ( "<STR_LIT>" , "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ? <NUM_LIT> : <NUM_LIT> ; step = ( int ) Math . ceil ( ( Math . max ( prefManager . convertPrecipitationFromMM ( <NUM_LIT> ) , pmax * <NUM_LIT> ) ) / stepnum ) ; holder . barChartView . addData ( precipitation ) ; holder . barChartView . setBarSpacing ( <NUM_LIT> ) ; holder . barChartView . setAxisBorderValues ( <NUM_LIT> , step * stepnum ) ; holder . barChartView . setXAxis ( false ) ; holder . barChartView . setYAxis ( false ) ; holder . barChartView . setYLabels ( AxisController . LabelPosition . NONE ) ; holder . barChartView . setLabelsColor ( <NUM_LIT> ) ; holder . barChartView . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartView . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartView . setBorderSpacing ( Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartView . show ( ) ; BarSet precipitationAxisData = new BarSet ( ) ; precipitationAxisData . addBar ( "<STR_LIT>" , <NUM_LIT> ) ; ArrayList < ChartSet > precipitationAxis = new ArrayList < > ( ) ; precipitationAxis . add ( precipitationAxisData ) ; precipitationAxisData . setColor ( <NUM_LIT> ) ; holder . barChartViewAxis . addData ( precipitationAxis ) ; holder . barChartViewAxis . setBarSpacing ( <NUM_LIT> ) ; holder . barChartViewAxis . setAxisBorderValues ( <NUM_LIT> , step * stepnum ) ; holder . barChartViewAxis . setStep ( step ) ; holder . barChartViewAxis . setXAxis ( false ) ; holder . barChartViewAxis . setYAxis ( false ) ; holder . barChartViewAxis . setYLabels ( AxisController . LabelPosition . OUTSIDE ) ; holder . barChartViewAxis . setLabelsColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartViewAxis . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartViewAxis . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartViewAxis . show ( ) ; holder . temperatureunit . setText ( "<STR_LIT>" + prefManager . getTemperatureUnit ( ) + "<STR_LIT>" ) ; holder . precipitationunit . setText ( "<STR_LIT>" + prefManager . getPrecipitationUnit ( context ) + "<STR_LIT>" ) ; } } public void setImage ( int value , ImageView imageView , boolean isDay ) { imageView . setImageResource ( UiResourceProvider . getImageResourceForWeatherCategory ( value , isDay ) ) ; } @ Override public int getItemCount ( ) { return dataSetTypes . length ; } @ Override public int getItemViewType ( int position ) { return dataSetTypes [ position ] ; } } </s>
<s> package org . woheller69 . weather . database ; import android . content . Context ; public class QuarterHourlyForecast { private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float windSpeed ; private float windDirection ; private float precipitation ; public QuarterHourlyForecast ( ) { } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getWindSpeed ( ) { return windSpeed ; } public void setWindSpeed ( float speed ) { this . windSpeed = speed ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; } public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } } </s>
<s> package org . woheller69 . weather . database ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . DatabaseUtils ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import java . util . ArrayList ; import java . util . List ; import static androidx . core . app . JobIntentService . enqueueWork ; public class SQLiteHelper extends SQLiteOpenHelper { private static final int DATABASE_VERSION = <NUM_LIT> ; private Context context ; private List < City > allCities = new ArrayList < > ( ) ; private static SQLiteHelper instance = null ; private static final String DATABASE_NAME = "<STR_LIT>" ; private static final String TABLE_CITIES_TO_WATCH = "<STR_LIT>" ; private static final String TABLE_HOURLY_FORECAST = "<STR_LIT>" ; private static final String TABLE_WEEKFORECAST = "<STR_LIT>" ; private static final String TABLE_CURRENT_WEATHER = "<STR_LIT>" ; private static final String TABLE_QUARTERHOURLYFORECAST = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_ID = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_CITY_ID = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_COLUMN_RANK = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_NAME = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_LONGITUDE = "<STR_LIT>" ; private static final String CITIES_TO_WATCH_LATITUDE = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_ID = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_CITY_ID = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_TIME_MEASUREMENT = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_FORECAST_FOR = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_WEATHER_ID = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_TEMPERATURE_CURRENT = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_PRECIPITATION = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_WIND_SPEED = "<STR_LIT>" ; private static final String QUARTERHOURLYFORECAST_COLUMN_WIND_DIRECTION = "<STR_LIT>" ; private static final String FORECAST_ID = "<STR_LIT>" ; private static final String FORECAST_CITY_ID = "<STR_LIT>" ; private static final String FORECAST_COLUMN_TIME_MEASUREMENT = "<STR_LIT>" ; private static final String FORECAST_COLUMN_FORECAST_FOR = "<STR_LIT>" ; private static final String FORECAST_COLUMN_WEATHER_ID = "<STR_LIT>" ; private static final String FORECAST_COLUMN_TEMPERATURE_CURRENT = "<STR_LIT>" ; private static final String FORECAST_COLUMN_HUMIDITY = "<STR_LIT>" ; private static final String FORECAST_COLUMN_PRESSURE = "<STR_LIT>" ; private static final String FORECAST_COLUMN_PRECIPITATION = "<STR_LIT>" ; private static final String FORECAST_COLUMN_WIND_SPEED = "<STR_LIT>" ; private static final String FORECAST_COLUMN_WIND_DIRECTION = "<STR_LIT>" ; private static final String WEEKFORECAST_ID = "<STR_LIT>" ; private static final String WEEKFORECAST_CITY_ID = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TIME_MEASUREMENT = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_FORECAST_FOR = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_WEATHER_ID = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TEMPERATURE_CURRENT = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TEMPERATURE_MIN = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TEMPERATURE_MAX = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_HUMIDITY = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_PRESSURE = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_PRECIPITATION = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_WIND_SPEED = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_WIND_DIRECTION = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_UV_INDEX = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TIME_SUNRISE = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_TIME_SUNSET = "<STR_LIT>" ; private static final String WEEKFORECAST_COLUMN_SUNSHINE_HOURS = "<STR_LIT>" ; private static final String CURRENT_WEATHER_ID = "<STR_LIT>" ; private static final String CURRENT_WEATHER_CITY_ID = "<STR_LIT>" ; private static final String COLUMN_TIME_MEASUREMENT = "<STR_LIT>" ; private static final String COLUMN_WEATHER_ID = "<STR_LIT>" ; private static final String COLUMN_TEMPERATURE_CURRENT = "<STR_LIT>" ; private static final String COLUMN_HUMIDITY = "<STR_LIT>" ; private static final String COLUMN_PRESSURE = "<STR_LIT>" ; private static final String COLUMN_WIND_SPEED = "<STR_LIT>" ; private static final String COLUMN_WIND_DIRECTION = "<STR_LIT>" ; private static final String COLUMN_CLOUDINESS = "<STR_LIT>" ; private static final String COLUMN_TIME_SUNRISE = "<STR_LIT>" ; private static final String COLUMN_TIME_SUNSET = "<STR_LIT>" ; private static final String COLUMN_TIMEZONE_SECONDS = "<STR_LIT>" ; private static final String COLUMN_RAIN60MIN = "<STR_LIT>" ; private static final String CREATE_CURRENT_WEATHER = "<STR_LIT>" + TABLE_CURRENT_WEATHER + "<STR_LIT>" + CURRENT_WEATHER_ID + "<STR_LIT>" + CURRENT_WEATHER_CITY_ID + "<STR_LIT>" + COLUMN_TIME_MEASUREMENT + "<STR_LIT>" + COLUMN_WEATHER_ID + "<STR_LIT>" + COLUMN_TEMPERATURE_CURRENT + "<STR_LIT>" + COLUMN_HUMIDITY + "<STR_LIT>" + COLUMN_PRESSURE + "<STR_LIT>" + COLUMN_WIND_SPEED + "<STR_LIT>" + COLUMN_WIND_DIRECTION + "<STR_LIT>" + COLUMN_CLOUDINESS + "<STR_LIT>" + COLUMN_TIME_SUNRISE + "<STR_LIT>" + COLUMN_TIME_SUNSET + "<STR_LIT>" + COLUMN_TIMEZONE_SECONDS + "<STR_LIT>" + COLUMN_RAIN60MIN + "<STR_LIT>" ; private static final String CREATE_TABLE_QUARTERHOURLYFORECASTS = "<STR_LIT>" + TABLE_QUARTERHOURLYFORECAST + "<STR_LIT>" + QUARTERHOURLYFORECAST_ID + "<STR_LIT>" + QUARTERHOURLYFORECAST_CITY_ID + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_TIME_MEASUREMENT + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_FORECAST_FOR + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_WEATHER_ID + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_TEMPERATURE_CURRENT + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_PRECIPITATION + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_WIND_SPEED + "<STR_LIT>" + QUARTERHOURLYFORECAST_COLUMN_WIND_DIRECTION + "<STR_LIT>" ; private static final String CREATE_TABLE_FORECASTS = "<STR_LIT>" + TABLE_HOURLY_FORECAST + "<STR_LIT>" + FORECAST_ID + "<STR_LIT>" + FORECAST_CITY_ID + "<STR_LIT>" + FORECAST_COLUMN_TIME_MEASUREMENT + "<STR_LIT>" + FORECAST_COLUMN_FORECAST_FOR + "<STR_LIT>" + FORECAST_COLUMN_WEATHER_ID + "<STR_LIT>" + FORECAST_COLUMN_TEMPERATURE_CURRENT + "<STR_LIT>" + FORECAST_COLUMN_HUMIDITY + "<STR_LIT>" + FORECAST_COLUMN_PRESSURE + "<STR_LIT>" + FORECAST_COLUMN_PRECIPITATION + "<STR_LIT>" + FORECAST_COLUMN_WIND_SPEED + "<STR_LIT>" + FORECAST_COLUMN_WIND_DIRECTION + "<STR_LIT>" ; private static final String CREATE_TABLE_WEEKFORECASTS = "<STR_LIT>" + TABLE_WEEKFORECAST + "<STR_LIT>" + WEEKFORECAST_ID + "<STR_LIT>" + WEEKFORECAST_CITY_ID + "<STR_LIT>" + WEEKFORECAST_COLUMN_TIME_MEASUREMENT + "<STR_LIT>" + WEEKFORECAST_COLUMN_FORECAST_FOR + "<STR_LIT>" + WEEKFORECAST_COLUMN_WEATHER_ID + "<STR_LIT>" + WEEKFORECAST_COLUMN_TEMPERATURE_CURRENT + "<STR_LIT>" + WEEKFORECAST_COLUMN_TEMPERATURE_MIN + "<STR_LIT>" + WEEKFORECAST_COLUMN_TEMPERATURE_MAX + "<STR_LIT>" + WEEKFORECAST_COLUMN_HUMIDITY + "<STR_LIT>" + WEEKFORECAST_COLUMN_PRESSURE + "<STR_LIT>" + WEEKFORECAST_COLUMN_PRECIPITATION + "<STR_LIT>" + WEEKFORECAST_COLUMN_WIND_SPEED + "<STR_LIT>" + WEEKFORECAST_COLUMN_WIND_DIRECTION + "<STR_LIT>" + WEEKFORECAST_COLUMN_UV_INDEX + "<STR_LIT>" + WEEKFORECAST_COLUMN_TIME_SUNRISE + "<STR_LIT>" + WEEKFORECAST_COLUMN_TIME_SUNSET + "<STR_LIT>" + WEEKFORECAST_COLUMN_SUNSHINE_HOURS + "<STR_LIT>" ; private static final String CREATE_TABLE_CITIES_TO_WATCH = "<STR_LIT>" + TABLE_CITIES_TO_WATCH + "<STR_LIT>" + CITIES_TO_WATCH_ID + "<STR_LIT>" + CITIES_TO_WATCH_CITY_ID + "<STR_LIT>" + CITIES_TO_WATCH_COLUMN_RANK + "<STR_LIT>" + CITIES_TO_WATCH_NAME + "<STR_LIT>" + CITIES_TO_WATCH_LONGITUDE + "<STR_LIT>" + CITIES_TO_WATCH_LATITUDE + "<STR_LIT>" ; public static SQLiteHelper getInstance ( Context context ) { if ( instance == null && context != null ) { instance = new SQLiteHelper ( context . getApplicationContext ( ) ) ; } return instance ; } private SQLiteHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; this . context = context . getApplicationContext ( ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( CREATE_TABLE_CITIES_TO_WATCH ) ; db . execSQL ( CREATE_CURRENT_WEATHER ) ; db . execSQL ( CREATE_TABLE_FORECASTS ) ; db . execSQL ( CREATE_TABLE_WEEKFORECASTS ) ; db . execSQL ( CREATE_TABLE_QUARTERHOURLYFORECASTS ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { switch ( oldVersion ) { case <NUM_LIT> : db . execSQL ( CREATE_TABLE_QUARTERHOURLYFORECASTS ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" + TABLE_WEEKFORECAST + "<STR_LIT>" + WEEKFORECAST_COLUMN_SUNSHINE_HOURS + "<STR_LIT>" ) ; } } public synchronized long addCityToWatch ( CityToWatch city ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( CITIES_TO_WATCH_CITY_ID , city . getCityId ( ) ) ; values . put ( CITIES_TO_WATCH_COLUMN_RANK , city . getRank ( ) ) ; values . put ( CITIES_TO_WATCH_NAME , city . getCityName ( ) ) ; values . put ( CITIES_TO_WATCH_LATITUDE , city . getLatitude ( ) ) ; values . put ( CITIES_TO_WATCH_LONGITUDE , city . getLongitude ( ) ) ; long id = database . insert ( TABLE_CITIES_TO_WATCH , null , values ) ; values . put ( CITIES_TO_WATCH_CITY_ID , id ) ; database . update ( TABLE_CITIES_TO_WATCH , values , CITIES_TO_WATCH_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( id ) } ) ; database . close ( ) ; return id ; } public synchronized CityToWatch getCityToWatch ( int id ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; String [ ] arguments = { String . valueOf ( id ) } ; Cursor cursor = database . rawQuery ( "<STR_LIT>" + CITIES_TO_WATCH_ID + "<STR_LIT>" + CITIES_TO_WATCH_CITY_ID + "<STR_LIT>" + CITIES_TO_WATCH_NAME + "<STR_LIT>" + CITIES_TO_WATCH_LONGITUDE + "<STR_LIT>" + CITIES_TO_WATCH_LATITUDE + "<STR_LIT>" + CITIES_TO_WATCH_COLUMN_RANK + "<STR_LIT>" + TABLE_CITIES_TO_WATCH + "<STR_LIT>" + CITIES_TO_WATCH_CITY_ID + "<STR_LIT>" , arguments ) ; CityToWatch cityToWatch = new CityToWatch ( ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { cityToWatch . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setCityId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setCityName ( cursor . getString ( <NUM_LIT> ) ) ; cityToWatch . setLongitude ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setLatitude ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setRank ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cursor . close ( ) ; } database . close ( ) ; return cityToWatch ; } public synchronized List < CityToWatch > getAllCitiesToWatch ( ) { List < CityToWatch > cityToWatchList = new ArrayList < > ( ) ; SQLiteDatabase database = this . getWritableDatabase ( ) ; Cursor cursor = database . rawQuery ( "<STR_LIT>" + CITIES_TO_WATCH_ID + "<STR_LIT>" + CITIES_TO_WATCH_CITY_ID + "<STR_LIT>" + CITIES_TO_WATCH_NAME + "<STR_LIT>" + CITIES_TO_WATCH_LONGITUDE + "<STR_LIT>" + CITIES_TO_WATCH_LATITUDE + "<STR_LIT>" + CITIES_TO_WATCH_COLUMN_RANK + "<STR_LIT>" + TABLE_CITIES_TO_WATCH , new String [ ] { } ) ; CityToWatch cityToWatch ; if ( cursor . moveToFirst ( ) ) { do { cityToWatch = new CityToWatch ( ) ; cityToWatch . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setCityId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setCityName ( cursor . getString ( <NUM_LIT> ) ) ; cityToWatch . setLongitude ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setLatitude ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatch . setRank ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; cityToWatchList . add ( cityToWatch ) ; } while ( cursor . moveToNext ( ) ) ; } cursor . close ( ) ; database . close ( ) ; return cityToWatchList ; } public synchronized void updateCityToWatch ( CityToWatch cityToWatch ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( CITIES_TO_WATCH_CITY_ID , cityToWatch . getCityId ( ) ) ; values . put ( CITIES_TO_WATCH_COLUMN_RANK , cityToWatch . getRank ( ) ) ; values . put ( CITIES_TO_WATCH_NAME , cityToWatch . getCityName ( ) ) ; values . put ( CITIES_TO_WATCH_LATITUDE , cityToWatch . getLatitude ( ) ) ; values . put ( CITIES_TO_WATCH_LONGITUDE , cityToWatch . getLongitude ( ) ) ; database . update ( TABLE_CITIES_TO_WATCH , values , CITIES_TO_WATCH_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityToWatch . getId ( ) ) } ) ; database . close ( ) ; } public synchronized void deleteCityToWatch ( CityToWatch cityToWatch ) { deleteCurrentWeatherByCityId ( cityToWatch . getCityId ( ) ) ; deleteForecastsByCityId ( cityToWatch . getCityId ( ) ) ; deleteWeekForecastsByCityId ( cityToWatch . getCityId ( ) ) ; deleteQuarterHourlyForecastsByCityId ( cityToWatch . getCityId ( ) ) ; SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_CITIES_TO_WATCH , CITIES_TO_WATCH_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( cityToWatch . getId ( ) ) } ) ; database . close ( ) ; } public synchronized int getWatchedCitiesCount ( ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; long count = DatabaseUtils . queryNumEntries ( database , TABLE_CITIES_TO_WATCH ) ; database . close ( ) ; return ( int ) count ; } public int getMaxRank ( ) { List < CityToWatch > cities = getAllCitiesToWatch ( ) ; int maxRank = <NUM_LIT> ; for ( CityToWatch ctw : cities ) { if ( ctw . getRank ( ) > maxRank ) maxRank = ctw . getRank ( ) ; } return maxRank ; } public synchronized boolean hasQuarterHourly ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_QUARTERHOURLYFORECAST , new String [ ] { QUARTERHOURLYFORECAST_CITY_ID } , QUARTERHOURLYFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityId ) } , null , null , null , null ) ; boolean result = false ; if ( cursor != null && cursor . moveToFirst ( ) ) { result = true ; cursor . close ( ) ; } database . close ( ) ; return result ; } public synchronized void replaceQuarterHourlyForecasts ( List < QuarterHourlyForecast > quarterHourlyForecasts ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_QUARTERHOURLYFORECAST , QUARTERHOURLYFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( quarterHourlyForecasts . get ( <NUM_LIT> ) . getCity_id ( ) ) } ) ; for ( QuarterHourlyForecast quarterHourlyForecast : quarterHourlyForecasts ) { ContentValues values = new ContentValues ( ) ; values . put ( QUARTERHOURLYFORECAST_CITY_ID , quarterHourlyForecast . getCity_id ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_TIME_MEASUREMENT , quarterHourlyForecast . getTimestamp ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_FORECAST_FOR , quarterHourlyForecast . getForecastTime ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_WEATHER_ID , quarterHourlyForecast . getWeatherID ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_TEMPERATURE_CURRENT , quarterHourlyForecast . getTemperature ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_PRECIPITATION , quarterHourlyForecast . getPrecipitation ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_WIND_SPEED , quarterHourlyForecast . getWindSpeed ( ) ) ; values . put ( QUARTERHOURLYFORECAST_COLUMN_WIND_DIRECTION , quarterHourlyForecast . getWindDirection ( ) ) ; database . insert ( TABLE_QUARTERHOURLYFORECAST , null , values ) ; } database . close ( ) ; } public synchronized void deleteQuarterHourlyForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_QUARTERHOURLYFORECAST , QUARTERHOURLYFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( cityId ) } ) ; database . close ( ) ; } public synchronized List < QuarterHourlyForecast > getQuarterHourlyForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_QUARTERHOURLYFORECAST , new String [ ] { QUARTERHOURLYFORECAST_ID , QUARTERHOURLYFORECAST_CITY_ID , QUARTERHOURLYFORECAST_COLUMN_TIME_MEASUREMENT , QUARTERHOURLYFORECAST_COLUMN_FORECAST_FOR , QUARTERHOURLYFORECAST_COLUMN_WEATHER_ID , QUARTERHOURLYFORECAST_COLUMN_TEMPERATURE_CURRENT , QUARTERHOURLYFORECAST_COLUMN_PRECIPITATION , QUARTERHOURLYFORECAST_COLUMN_WIND_SPEED , QUARTERHOURLYFORECAST_COLUMN_WIND_DIRECTION } , QUARTERHOURLYFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityId ) } , null , null , null , null ) ; List < QuarterHourlyForecast > list = new ArrayList < > ( ) ; QuarterHourlyForecast quarterHourlyForecast ; if ( cursor != null && cursor . moveToFirst ( ) ) { do { quarterHourlyForecast = new QuarterHourlyForecast ( ) ; quarterHourlyForecast . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setCity_id ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setTimestamp ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setForecastTime ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setWeatherID ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setTemperature ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setPrecipitation ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setWindSpeed ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; quarterHourlyForecast . setWindDirection ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; list . add ( quarterHourlyForecast ) ; } while ( cursor . moveToNext ( ) ) ; cursor . close ( ) ; } database . close ( ) ; return list ; } public synchronized void replaceForecasts ( List < HourlyForecast > hourlyForecasts ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_HOURLY_FORECAST , FORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( hourlyForecasts . get ( <NUM_LIT> ) . getCity_id ( ) ) } ) ; for ( HourlyForecast hourlyForecast : hourlyForecasts ) { ContentValues values = new ContentValues ( ) ; values . put ( FORECAST_CITY_ID , hourlyForecast . getCity_id ( ) ) ; values . put ( FORECAST_COLUMN_TIME_MEASUREMENT , hourlyForecast . getTimestamp ( ) ) ; values . put ( FORECAST_COLUMN_FORECAST_FOR , hourlyForecast . getForecastTime ( ) ) ; values . put ( FORECAST_COLUMN_WEATHER_ID , hourlyForecast . getWeatherID ( ) ) ; values . put ( FORECAST_COLUMN_TEMPERATURE_CURRENT , hourlyForecast . getTemperature ( ) ) ; values . put ( FORECAST_COLUMN_HUMIDITY , hourlyForecast . getHumidity ( ) ) ; values . put ( FORECAST_COLUMN_PRESSURE , hourlyForecast . getPressure ( ) ) ; values . put ( FORECAST_COLUMN_PRECIPITATION , hourlyForecast . getPrecipitation ( ) ) ; values . put ( FORECAST_COLUMN_WIND_SPEED , hourlyForecast . getWindSpeed ( ) ) ; values . put ( FORECAST_COLUMN_WIND_DIRECTION , hourlyForecast . getWindDirection ( ) ) ; database . insert ( TABLE_HOURLY_FORECAST , null , values ) ; } database . close ( ) ; } public synchronized void deleteForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_HOURLY_FORECAST , FORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( cityId ) } ) ; database . close ( ) ; } public synchronized List < HourlyForecast > getForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_HOURLY_FORECAST , new String [ ] { FORECAST_ID , FORECAST_CITY_ID , FORECAST_COLUMN_TIME_MEASUREMENT , FORECAST_COLUMN_FORECAST_FOR , FORECAST_COLUMN_WEATHER_ID , FORECAST_COLUMN_TEMPERATURE_CURRENT , FORECAST_COLUMN_HUMIDITY , FORECAST_COLUMN_PRESSURE , FORECAST_COLUMN_PRECIPITATION , FORECAST_COLUMN_WIND_SPEED , FORECAST_COLUMN_WIND_DIRECTION } , FORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityId ) } , null , null , null , null ) ; List < HourlyForecast > list = new ArrayList < > ( ) ; HourlyForecast hourlyForecast ; if ( cursor != null && cursor . moveToFirst ( ) ) { do { hourlyForecast = new HourlyForecast ( ) ; hourlyForecast . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setCity_id ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setTimestamp ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setForecastTime ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setWeatherID ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setTemperature ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setHumidity ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setPressure ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setPrecipitation ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setWindSpeed ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; hourlyForecast . setWindDirection ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; list . add ( hourlyForecast ) ; } while ( cursor . moveToNext ( ) ) ; cursor . close ( ) ; } database . close ( ) ; return list ; } public synchronized void replaceWeekForecasts ( List < WeekForecast > weekForecasts ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_WEEKFORECAST , WEEKFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( weekForecasts . get ( <NUM_LIT> ) . getCity_id ( ) ) } ) ; for ( WeekForecast weekForecast : weekForecasts ) { ContentValues values = new ContentValues ( ) ; values . put ( WEEKFORECAST_CITY_ID , weekForecast . getCity_id ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TIME_MEASUREMENT , weekForecast . getTimestamp ( ) ) ; values . put ( WEEKFORECAST_COLUMN_FORECAST_FOR , weekForecast . getForecastTime ( ) ) ; values . put ( WEEKFORECAST_COLUMN_WEATHER_ID , weekForecast . getWeatherID ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TEMPERATURE_CURRENT , weekForecast . getTemperature ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TEMPERATURE_MIN , weekForecast . getMinTemperature ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TEMPERATURE_MAX , weekForecast . getMaxTemperature ( ) ) ; values . put ( WEEKFORECAST_COLUMN_HUMIDITY , weekForecast . getHumidity ( ) ) ; values . put ( WEEKFORECAST_COLUMN_PRESSURE , weekForecast . getPressure ( ) ) ; values . put ( WEEKFORECAST_COLUMN_PRECIPITATION , weekForecast . getPrecipitation ( ) ) ; values . put ( WEEKFORECAST_COLUMN_WIND_SPEED , weekForecast . getWind_speed ( ) ) ; values . put ( WEEKFORECAST_COLUMN_WIND_DIRECTION , weekForecast . getWind_direction ( ) ) ; values . put ( WEEKFORECAST_COLUMN_UV_INDEX , weekForecast . getUv_index ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TIME_SUNRISE , weekForecast . getTimeSunrise ( ) ) ; values . put ( WEEKFORECAST_COLUMN_TIME_SUNSET , weekForecast . getTimeSunset ( ) ) ; values . put ( WEEKFORECAST_COLUMN_SUNSHINE_HOURS , weekForecast . getSunshineHours ( ) ) ; database . insert ( TABLE_WEEKFORECAST , null , values ) ; } database . close ( ) ; } public synchronized void deleteWeekForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_WEEKFORECAST , WEEKFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( cityId ) } ) ; database . close ( ) ; } public synchronized List < WeekForecast > getWeekForecastsByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_WEEKFORECAST , new String [ ] { WEEKFORECAST_ID , WEEKFORECAST_CITY_ID , WEEKFORECAST_COLUMN_TIME_MEASUREMENT , WEEKFORECAST_COLUMN_FORECAST_FOR , WEEKFORECAST_COLUMN_WEATHER_ID , WEEKFORECAST_COLUMN_TEMPERATURE_CURRENT , WEEKFORECAST_COLUMN_TEMPERATURE_MIN , WEEKFORECAST_COLUMN_TEMPERATURE_MAX , WEEKFORECAST_COLUMN_HUMIDITY , WEEKFORECAST_COLUMN_PRESSURE , WEEKFORECAST_COLUMN_PRECIPITATION , WEEKFORECAST_COLUMN_WIND_SPEED , WEEKFORECAST_COLUMN_WIND_DIRECTION , WEEKFORECAST_COLUMN_UV_INDEX , WEEKFORECAST_COLUMN_TIME_SUNRISE , WEEKFORECAST_COLUMN_TIME_SUNSET , WEEKFORECAST_COLUMN_SUNSHINE_HOURS } , WEEKFORECAST_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityId ) } , null , null , null , null ) ; List < WeekForecast > list = new ArrayList < > ( ) ; WeekForecast weekForecast ; if ( cursor != null && cursor . moveToFirst ( ) ) { do { weekForecast = new WeekForecast ( ) ; weekForecast . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setCity_id ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setTimestamp ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setForecastTime ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setWeatherID ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setTemperature ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setMinTemperature ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setMaxTemperature ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setHumidity ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setPressure ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setPrecipitation ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setWind_speed ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setWind_direction ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setUv_index ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setTimeSunrise ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setTimeSunset ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; weekForecast . setSunshineHours ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; list . add ( weekForecast ) ; } while ( cursor . moveToNext ( ) ) ; cursor . close ( ) ; } database . close ( ) ; return list ; } public synchronized void addCurrentWeather ( CurrentWeatherData currentWeather ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( CURRENT_WEATHER_CITY_ID , currentWeather . getCity_id ( ) ) ; values . put ( COLUMN_TIME_MEASUREMENT , currentWeather . getTimestamp ( ) ) ; values . put ( COLUMN_WEATHER_ID , currentWeather . getWeatherID ( ) ) ; values . put ( COLUMN_TEMPERATURE_CURRENT , currentWeather . getTemperatureCurrent ( ) ) ; values . put ( COLUMN_HUMIDITY , currentWeather . getHumidity ( ) ) ; values . put ( COLUMN_PRESSURE , currentWeather . getPressure ( ) ) ; values . put ( COLUMN_WIND_SPEED , currentWeather . getWindSpeed ( ) ) ; values . put ( COLUMN_WIND_DIRECTION , currentWeather . getWindDirection ( ) ) ; values . put ( COLUMN_CLOUDINESS , currentWeather . getCloudiness ( ) ) ; values . put ( COLUMN_TIME_SUNRISE , currentWeather . getTimeSunrise ( ) ) ; values . put ( COLUMN_TIME_SUNSET , currentWeather . getTimeSunset ( ) ) ; values . put ( COLUMN_TIMEZONE_SECONDS , currentWeather . getTimeZoneSeconds ( ) ) ; values . put ( COLUMN_RAIN60MIN , currentWeather . getRain60min ( ) ) ; database . insert ( TABLE_CURRENT_WEATHER , null , values ) ; database . close ( ) ; } public synchronized CurrentWeatherData getCurrentWeatherByCityId ( int cityId ) { SQLiteDatabase database = this . getReadableDatabase ( ) ; Cursor cursor = database . query ( TABLE_CURRENT_WEATHER , new String [ ] { CURRENT_WEATHER_ID , CURRENT_WEATHER_CITY_ID , COLUMN_TIME_MEASUREMENT , COLUMN_WEATHER_ID , COLUMN_TEMPERATURE_CURRENT , COLUMN_HUMIDITY , COLUMN_PRESSURE , COLUMN_WIND_SPEED , COLUMN_WIND_DIRECTION , COLUMN_CLOUDINESS , COLUMN_TIME_SUNRISE , COLUMN_TIME_SUNSET , COLUMN_TIMEZONE_SECONDS , COLUMN_RAIN60MIN } , CURRENT_WEATHER_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( cityId ) } , null , null , null , null ) ; CurrentWeatherData currentWeather = new CurrentWeatherData ( ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { currentWeather . setId ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setCity_id ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setTimestamp ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setWeatherID ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setTemperatureCurrent ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setHumidity ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setPressure ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setWindSpeed ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setWindDirection ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setCloudiness ( Float . parseFloat ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setTimeSunrise ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setTimeSunset ( Long . parseLong ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setTimeZoneSeconds ( Integer . parseInt ( cursor . getString ( <NUM_LIT> ) ) ) ; currentWeather . setRain60min ( cursor . getString ( <NUM_LIT> ) ) ; cursor . close ( ) ; } database . close ( ) ; return currentWeather ; } public synchronized void updateCurrentWeather ( CurrentWeatherData currentWeather ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( CURRENT_WEATHER_CITY_ID , currentWeather . getCity_id ( ) ) ; values . put ( COLUMN_TIME_MEASUREMENT , currentWeather . getTimestamp ( ) ) ; values . put ( COLUMN_WEATHER_ID , currentWeather . getWeatherID ( ) ) ; values . put ( COLUMN_TEMPERATURE_CURRENT , currentWeather . getTemperatureCurrent ( ) ) ; values . put ( COLUMN_HUMIDITY , currentWeather . getHumidity ( ) ) ; values . put ( COLUMN_PRESSURE , currentWeather . getPressure ( ) ) ; values . put ( COLUMN_WIND_SPEED , currentWeather . getWindSpeed ( ) ) ; values . put ( COLUMN_WIND_DIRECTION , currentWeather . getWindDirection ( ) ) ; values . put ( COLUMN_CLOUDINESS , currentWeather . getCloudiness ( ) ) ; values . put ( COLUMN_TIME_SUNRISE , currentWeather . getTimeSunrise ( ) ) ; values . put ( COLUMN_TIME_SUNSET , currentWeather . getTimeSunset ( ) ) ; values . put ( COLUMN_TIMEZONE_SECONDS , currentWeather . getTimeZoneSeconds ( ) ) ; values . put ( COLUMN_RAIN60MIN , currentWeather . getRain60min ( ) ) ; database . update ( TABLE_CURRENT_WEATHER , values , CURRENT_WEATHER_CITY_ID + "<STR_LIT>" , new String [ ] { String . valueOf ( currentWeather . getCity_id ( ) ) } ) ; } public synchronized void deleteCurrentWeather ( CurrentWeatherData currentWeather ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_CURRENT_WEATHER , CURRENT_WEATHER_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( currentWeather . getId ( ) ) } ) ; database . close ( ) ; } public synchronized void deleteCurrentWeatherByCityId ( int cityId ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . delete ( TABLE_CURRENT_WEATHER , CURRENT_WEATHER_CITY_ID + "<STR_LIT>" , new String [ ] { Integer . toString ( cityId ) } ) ; database . close ( ) ; } public static int getWidgetCityID ( Context context ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; int cityID = <NUM_LIT> ; List < CityToWatch > cities = db . getAllCitiesToWatch ( ) ; int rank = cities . get ( <NUM_LIT> ) . getRank ( ) ; for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { CityToWatch city = cities . get ( i ) ; if ( city . getRank ( ) <= rank ) { rank = city . getRank ( ) ; cityID = city . getCityId ( ) ; } } return cityID ; } public synchronized void deleteAllForecasts ( ) { SQLiteDatabase database = this . getWritableDatabase ( ) ; database . execSQL ( "<STR_LIT>" + TABLE_HOURLY_FORECAST ) ; database . execSQL ( "<STR_LIT>" + TABLE_WEEKFORECAST ) ; database . execSQL ( "<STR_LIT>" + TABLE_CURRENT_WEATHER ) ; database . execSQL ( "<STR_LIT>" + TABLE_QUARTERHOURLYFORECAST ) ; database . close ( ) ; } } </s>
<s> package org . woheller69 . weather . ui . updater ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . ArrayList ; import java . util . List ; public class ViewUpdater { private static List < IUpdateableCityUI > subscribers = new ArrayList < > ( ) ; public static void addSubscriber ( IUpdateableCityUI sub ) { if ( ! subscribers . contains ( sub ) ) { subscribers . add ( sub ) ; } } public static void removeSubscriber ( IUpdateableCityUI sub ) { subscribers . remove ( sub ) ; } public static void updateCurrentWeatherData ( CurrentWeatherData data ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) { sub . processNewCurrentWeatherData ( data ) ; } } public static void updateWeekForecasts ( List < WeekForecast > forecasts ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) { sub . processNewWeekForecasts ( forecasts ) ; } } public static void updateForecasts ( List < HourlyForecast > hourlyForecasts ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) { sub . processNewForecasts ( hourlyForecasts ) ; } } } </s>
<s> package org . woheller69 . weather . activities ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . SharedPreferences ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import androidx . appcompat . app . AlertDialog ; import androidx . preference . PreferenceManager ; import com . google . android . material . navigation . NavigationView ; import com . google . android . material . navigation . NavigationView . OnNavigationItemSelectedListener ; import androidx . appcompat . app . AppCompatDelegate ; import androidx . core . app . TaskStackBuilder ; import androidx . core . view . GravityCompat ; import androidx . drawerlayout . widget . DrawerLayout ; import androidx . appcompat . app . ActionBarDrawerToggle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import android . os . Looper ; import android . view . MenuItem ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import static java . lang . Boolean . TRUE ; public class NavigationActivity extends AppCompatActivity implements OnNavigationItemSelectedListener { static final int NAVDRAWER_LAUNCH_DELAY = <NUM_LIT> ; public static boolean isVisible = false ; private DrawerLayout mDrawerLayout ; private NavigationView mNavigationView ; private Handler mHandler ; protected SharedPreferences mSharedPreferences ; protected AppPreferencesManager prefManager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mSharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; mHandler = new Handler ( Looper . getMainLooper ( ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; if ( prefManager . showStarDialog ( this ) ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; alertDialogBuilder . setMessage ( R . string . dialog_StarOnGitHub ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( BuildConfig . GITHUB_URL ) ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } ) ; alertDialogBuilder . setNeutralButton ( getString ( R . string . dialog_Later_button ) , null ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } } @ Override public void onBackPressed ( ) { DrawerLayout drawer = ( DrawerLayout ) findViewById ( R . id . drawer_layout ) ; if ( drawer . isDrawerOpen ( GravityCompat . START ) ) { drawer . closeDrawer ( GravityCompat . START ) ; } else { if ( getNavigationDrawerID ( ) != R . id . nav_weather ) { Intent intent = new Intent ( this , ForecastCityActivity . class ) ; startActivity ( intent ) ; } else { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_MAIN ) ; intent . addCategory ( Intent . CATEGORY_HOME ) ; startActivity ( intent ) ; } } } protected int getNavigationDrawerID ( ) { return <NUM_LIT> ; } @ Override public boolean onNavigationItemSelected ( MenuItem item ) { final int itemId = item . getItemId ( ) ; return goToNavigationItem ( itemId ) ; } protected boolean goToNavigationItem ( final int itemId ) { if ( itemId == getNavigationDrawerID ( ) ) { mDrawerLayout . closeDrawer ( GravityCompat . START ) ; return true ; } mHandler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { callDrawerItem ( itemId ) ; } } , NAVDRAWER_LAUNCH_DELAY ) ; mDrawerLayout . closeDrawer ( GravityCompat . START ) ; selectNavigationItem ( itemId ) ; return true ; } private void selectNavigationItem ( int itemId ) { for ( int i = <NUM_LIT> ; i < mNavigationView . getMenu ( ) . size ( ) ; i ++ ) { boolean b = itemId == mNavigationView . getMenu ( ) . getItem ( i ) . getItemId ( ) ; mNavigationView . getMenu ( ) . getItem ( i ) . setChecked ( b ) ; } } private void callDrawerItem ( final int itemId ) { Intent intent ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( "<STR_LIT>" , false ) == TRUE ) { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; } else { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; } if ( itemId == R . id . nav_weather ) { intent = new Intent ( this , ForecastCityActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_manage ) { intent = new Intent ( this , ManageLocationsActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_about ) { intent = new Intent ( this , AboutActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_settings ) { intent = new Intent ( this , SettingsActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . star_on_github ) { startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( BuildConfig . GITHUB_URL ) ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { super . onPostCreate ( savedInstanceState ) ; Toolbar toolbar = findViewById ( R . id . toolbar ) ; if ( getSupportActionBar ( ) == null ) { setSupportActionBar ( toolbar ) ; } mDrawerLayout = findViewById ( R . id . drawer_layout ) ; ActionBarDrawerToggle toggle = new ActionBarDrawerToggle ( this , mDrawerLayout , toolbar , R . string . navigation_drawer_open , R . string . navigation_drawer_close ) ; mDrawerLayout . addDrawerListener ( toggle ) ; toggle . syncState ( ) ; mNavigationView = findViewById ( R . id . nav_view ) ; mNavigationView . setNavigationItemSelectedListener ( this ) ; selectNavigationItem ( getNavigationDrawerID ( ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; isVisible = true ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( "<STR_LIT>" , false ) == TRUE ) { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; } else { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; isVisible = false ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; public class OnSwipeDownListener implements View . OnTouchListener { private final GestureDetector gestureDetector ; public OnSwipeDownListener ( Context context ) { gestureDetector = new GestureDetector ( context , new GestureListener ( ) ) ; } @ SuppressLint ( "<STR_LIT>" ) public boolean onTouch ( final View view , final MotionEvent motionEvent ) { return gestureDetector . onTouchEvent ( motionEvent ) ; } private final class GestureListener extends GestureDetector . SimpleOnGestureListener { private static final int SWIPE_THRESHOLD = <NUM_LIT> ; private static final int SWIPE_VELOCITY_THRESHOLD = <NUM_LIT> ; @ Override public boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) { boolean result = false ; try { float diffY = e2 . getY ( ) - e1 . getY ( ) ; if ( Math . abs ( diffY ) > SWIPE_THRESHOLD && Math . abs ( velocityY ) > SWIPE_VELOCITY_THRESHOLD ) { if ( diffY > <NUM_LIT> ) { onSwipeDown ( ) ; } } } catch ( Exception exception ) { exception . printStackTrace ( ) ; } return result ; } } public void onSwipeDown ( ) { } } </s>
<s> package org . woheller69 . weather . weather_api ; public abstract class IApiToDatabaseConversion { public enum WeatherCategories { ERROR ( - <NUM_LIT> ) , CLEAR_SKY ( <NUM_LIT> ) , FEW_CLOUDS ( <NUM_LIT> ) , SCATTERED_CLOUDS ( <NUM_LIT> ) , OVERCAST_CLOUDS ( <NUM_LIT> ) , MIST ( <NUM_LIT> ) , DRIZZLE_RAIN ( <NUM_LIT> ) , FREEZING_DRIZZLE_RAIN ( <NUM_LIT> ) , LIGHT_RAIN ( <NUM_LIT> ) , MODERATE_RAIN ( <NUM_LIT> ) , HEAVY_RAIN ( <NUM_LIT> ) , LIGHT_FREEZING_RAIN ( <NUM_LIT> ) , FREEZING_RAIN ( <NUM_LIT> ) , LIGHT_SNOW ( <NUM_LIT> ) , MODERATE_SNOW ( <NUM_LIT> ) , HEAVY_SNOW ( <NUM_LIT> ) , LIGHT_SHOWER_RAIN ( <NUM_LIT> ) , SHOWER_RAIN ( <NUM_LIT> ) , SHOWER_RAIN_SNOW ( <NUM_LIT> ) , LIGHT_SHOWER_SNOW ( <NUM_LIT> ) , SHOWER_SNOW ( <NUM_LIT> ) , THUNDERSTORM ( <NUM_LIT> ) , THUNDERSTORM_HAIL ( <NUM_LIT> ) ; private int numVal ; WeatherCategories ( int numVal ) { this . numVal = numVal ; } public int getNumVal ( ) { return numVal ; } } public abstract int convertWeatherCategory ( String category ) ; } </s>
<s> package org . woheller69 . weather . database ; import android . content . Context ; public class HourlyForecast { public static final float NO_RAIN_VALUE = <NUM_LIT> ; private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float humidity ; private float pressure ; private float windSpeed ; private float windDirection ; private float precipitation ; public HourlyForecast ( ) { } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getWindSpeed ( ) { return windSpeed ; } public void setWindSpeed ( float speed ) { this . windSpeed = speed ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; } public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; public class SimpleItemTouchHelperCallback extends ItemTouchHelper . Callback { private final ItemTouchHelperAdapter adapter ; public SimpleItemTouchHelperCallback ( ItemTouchHelperAdapter adapter ) { this . adapter = adapter ; } @ Override public boolean isLongPressDragEnabled ( ) { return true ; } @ Override public boolean isItemViewSwipeEnabled ( ) { return true ; } @ Override public int getMovementFlags ( RecyclerView recyclerView , RecyclerView . ViewHolder viewHolder ) { int dragFlags = ItemTouchHelper . UP | ItemTouchHelper . DOWN ; int swipeFlags = ItemTouchHelper . START | ItemTouchHelper . END ; return makeMovementFlags ( dragFlags , swipeFlags ) ; } @ Override public boolean onMove ( RecyclerView recyclerView , RecyclerView . ViewHolder viewHolder , RecyclerView . ViewHolder target ) { adapter . onItemMove ( viewHolder . getBindingAdapterPosition ( ) , target . getBindingAdapterPosition ( ) ) ; return true ; } @ Override public void onSwiped ( RecyclerView . ViewHolder viewHolder , int direction ) { adapter . onItemDismiss ( viewHolder . getBindingAdapterPosition ( ) ) ; } } </s>
<s> package org . woheller69 . weather . ui . util ; public interface MyConsumer < T > { void accept ( T t ) ; } </s>
<s> package org . woheller69 . weather . widget ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; import static java . lang . Boolean . TRUE ; import android . Manifest ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import android . util . Log ; import android . view . View ; import android . widget . RemoteViews ; import android . widget . Toast ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . List ; import java . util . Locale ; import java . util . TimeZone ; public class WeatherDigitalClockWidget extends AppWidgetProvider { private static LocationListener locationListenerGPS ; private LocationManager locationManager ; public void updateAppWidget ( Context context , final int appWidgetId ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) updateLocation ( context , cityID , false ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( "<STR_LIT>" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateLocation ( final Context context , int cityID , boolean manual ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; List < CityToWatch > cities = db . getAllCitiesToWatch ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { LocationManager locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; Location locationGPS = locationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( locationGPS != null ) { CityToWatch city ; double lat = locationGPS . getLatitude ( ) ; double lon = locationGPS . getLongitude ( ) ; for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { if ( cities . get ( i ) . getCityId ( ) == cityID ) { city = cities . get ( i ) ; city . setLatitude ( ( float ) lat ) ; city . setLongitude ( ( float ) lon ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , lat , lon ) ) ; db . updateCityToWatch ( city ) ; break ; } } } else { if ( manual ) Toast . makeText ( context . getApplicationContext ( ) , R . string . error_no_position , Toast . LENGTH_SHORT ) . show ( ) ; } } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , CurrentWeatherData weatherData , List < WeekForecast > weekforecasts ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) == TRUE ) views . setCharSequence ( R . id . textClockTime , "<STR_LIT>" , "<STR_LIT>" ) ; else views . setCharSequence ( R . id . textClockTime , "<STR_LIT>" , "<STR_LIT>" ) ; DateFormat df = DateFormat . getDateInstance ( DateFormat . LONG ) ; df . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; String pattern = ( ( SimpleDateFormat ) df ) . toPattern ( ) ; views . setCharSequence ( R . id . textClockDate , "<STR_LIT>" , pattern ) ; views . setCharSequence ( R . id . textClockDate , "<STR_LIT>" , pattern ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) views . setViewVisibility ( R . id . location_on , View . VISIBLE ) ; else views . setViewVisibility ( R . id . location_on , View . INVISIBLE ) ; views . setTextViewText ( R . id . widget_city_name , city . getCityName ( ) ) ; views . setTextViewText ( R . id . widget_UVindex , "<STR_LIT>" ) ; views . setInt ( R . id . widget_UVindex , "<STR_LIT>" , StringFormatUtils . widgetColorUVindex ( context , Math . round ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) ) ) ) ; boolean isDay = weatherData . isDay ( context ) ; if ( ! dbHelper . hasQuarterHourly ( weatherData . getCity_id ( ) ) ) { HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( nowCast . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , "<STR_LIT>" + StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) + "<STR_LIT>" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = dbHelper . getQuarterHourlyForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , "<STR_LIT>" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( next . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , "<STR_LIT>" + StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) + "<STR_LIT>" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; } Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( "<STR_LIT>" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_digital_clock_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( final Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; PowerManager powerManager = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) && ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED && ! powerManager . isPowerSaveMode ( ) ) { if ( locationListenerGPS == null ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; locationListenerGPS = new LocationListener ( ) { @ Override public void onLocationChanged ( Location location ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; int [ ] appWidgetIds = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } else { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( widgetCityID ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int widgetID : widgetIDs ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_digital_clock_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherDigitalClockWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getBooleanExtra ( "<STR_LIT>" , false ) ) { int cityID = getWidgetCityID ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) && ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) updateLocation ( context , cityID , true ) ; } super . onReceive ( context , intent ) ; } } </s>
<s> package org . woheller69 . weather . weather_api ; public interface IHttpRequestForWeatherAPI { void perform ( float lat , float lon , int cityId ) ; } </s>
<s> package org . woheller69 . weather . dialogs ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . res . Resources ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . text . Editable ; import android . text . InputType ; import android . text . TextUtils ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . view . inputmethod . InputMethodManager ; import android . webkit . WebView ; import android . widget . AdapterView ; import android . widget . AutoCompleteTextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . os . ConfigurationCompat ; import androidx . fragment . app . DialogFragment ; import com . android . volley . Response ; import com . android . volley . VolleyError ; import org . json . JSONArray ; import org . json . JSONObject ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ManageLocationsActivity ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . util . geocodingApiCall ; import org . woheller69 . weather . ui . util . AutoSuggestAdapter ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; public class AddLocationDialogOmGeocodingAPI extends DialogFragment { Activity activity ; View rootView ; SQLiteHelper database ; private WebView webview ; private AutoCompleteTextView autoCompleteTextView ; City selectedCity ; private static final int TRIGGER_AUTO_COMPLETE = <NUM_LIT> ; private static final long AUTO_COMPLETE_DELAY = <NUM_LIT> ; private static final int TRIGGER_HIDE_KEYBOARD = <NUM_LIT> ; private static final long HIDE_KEYBOARD_DELAY = <NUM_LIT> ; private Handler handler ; private AutoSuggestAdapter autoSuggestAdapter ; String url = "<STR_LIT>" ; String lang = "<STR_LIT>" ; public AddLocationDialogOmGeocodingAPI ( ) { setRetainInstance ( true ) ; } @ Override public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof Activity ) { this . activity = ( Activity ) context ; } } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( savedInstanceState != null ) dismiss ( ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; if ( selectedCity != null && webview != null ) webview . loadUrl ( "<STR_LIT>" + selectedCity . getLatitude ( ) + "<STR_LIT>" + selectedCity . getLongitude ( ) ) ; } @ NonNull @ SuppressLint ( "<STR_LIT>" ) @ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { Locale locale = ConfigurationCompat . getLocales ( Resources . getSystem ( ) . getConfiguration ( ) ) . get ( <NUM_LIT> ) ; if ( locale != null ) lang = locale . getLanguage ( ) ; LayoutInflater inflater = activity . getLayoutInflater ( ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( activity ) ; View view = inflater . inflate ( R . layout . dialog_add_location , null ) ; rootView = view ; builder . setView ( view ) ; builder . setTitle ( activity . getString ( R . string . dialog_add_label ) ) ; this . database = SQLiteHelper . getInstance ( activity ) ; webview = rootView . findViewById ( R . id . webViewAddLocation ) ; webview . getSettings ( ) . setJavaScriptEnabled ( true ) ; webview . getSettings ( ) . setUserAgentString ( BuildConfig . APPLICATION_ID + "<STR_LIT>" + BuildConfig . VERSION_NAME ) ; webview . setBackgroundColor ( <NUM_LIT> ) ; webview . setBackgroundResource ( R . drawable . map_back ) ; autoCompleteTextView = ( AutoCompleteTextView ) rootView . findViewById ( R . id . autoCompleteTvAddDialog ) ; autoSuggestAdapter = new AutoSuggestAdapter ( requireContext ( ) , R . layout . list_item_autocomplete ) ; autoCompleteTextView . setThreshold ( <NUM_LIT> ) ; autoCompleteTextView . setInputType ( InputType . TYPE_TEXT_FLAG_NO_SUGGESTIONS ) ; autoCompleteTextView . setAdapter ( autoSuggestAdapter ) ; autoCompleteTextView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { selectedCity = autoSuggestAdapter . getObject ( position ) ; final InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( rootView . getWindowToken ( ) , <NUM_LIT> ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; webview . loadUrl ( "<STR_LIT>" + selectedCity . getLatitude ( ) + "<STR_LIT>" + selectedCity . getLongitude ( ) ) ; } } ) ; autoCompleteTextView . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { handler . removeMessages ( TRIGGER_AUTO_COMPLETE ) ; handler . sendEmptyMessageDelayed ( TRIGGER_AUTO_COMPLETE , AUTO_COMPLETE_DELAY ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; handler . sendEmptyMessageDelayed ( TRIGGER_HIDE_KEYBOARD , HIDE_KEYBOARD_DELAY ) ; } @ Override public void afterTextChanged ( Editable s ) { } } ) ; handler = new Handler ( Looper . getMainLooper ( ) , msg -> { if ( msg . what == TRIGGER_AUTO_COMPLETE ) { if ( ! TextUtils . isEmpty ( autoCompleteTextView . getText ( ) ) ) { try { makeApiCall ( URLEncoder . encode ( autoCompleteTextView . getText ( ) . toString ( ) , StandardCharsets . UTF_8 . name ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } } } else if ( msg . what == TRIGGER_HIDE_KEYBOARD ) { final InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( rootView . getWindowToken ( ) , <NUM_LIT> ) ; } return false ; } ) ; builder . setPositiveButton ( activity . getString ( R . string . dialog_add_add_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { performDone ( ) ; } } ) ; builder . setNegativeButton ( activity . getString ( R . string . dialog_add_close_button ) , null ) ; return builder . create ( ) ; } private void makeApiCall ( String text ) { geocodingApiCall . make ( getContext ( ) , text , url , lang , new Response . Listener < String > ( ) { @ Override public void onResponse ( String response ) { List < String > stringList = new ArrayList < > ( ) ; List < City > cityList = new ArrayList < > ( ) ; try { JSONObject responseObject = new JSONObject ( response ) ; JSONArray array = responseObject . getJSONArray ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < array . length ( ) ; i ++ ) { City city = new City ( ) ; String citystring = "<STR_LIT>" ; JSONObject jsonFeatures = array . getJSONObject ( i ) ; String name = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { name = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + name ; } String countrycode = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { countrycode = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + "<STR_LIT>" + countrycode ; } String admin1 = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { admin1 = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + "<STR_LIT>" + admin1 ; } String admin2 = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { admin2 = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + "<STR_LIT>" + admin2 ; } String admin3 = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { admin3 = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + "<STR_LIT>" + admin3 ; } String admin4 = "<STR_LIT>" ; if ( jsonFeatures . has ( "<STR_LIT>" ) ) { admin4 = jsonFeatures . getString ( "<STR_LIT>" ) ; citystring = citystring + "<STR_LIT>" + admin4 ; } city . setCityName ( name ) ; city . setCountryCode ( countrycode ) ; city . setLatitude ( ( float ) jsonFeatures . getDouble ( "<STR_LIT>" ) ) ; city . setLongitude ( ( float ) jsonFeatures . getDouble ( "<STR_LIT>" ) ) ; cityList . add ( city ) ; stringList . add ( citystring ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } autoSuggestAdapter . setData ( stringList , cityList ) ; autoSuggestAdapter . notifyDataSetChanged ( ) ; } } , new Response . ErrorListener ( ) { @ Override public void onErrorResponse ( VolleyError error ) { Handler h = new Handler ( activity . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( activity , error . toString ( ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } } ) ; } private void performDone ( ) { if ( selectedCity == null ) { Toast . makeText ( activity , R . string . dialog_add_no_city_found , Toast . LENGTH_SHORT ) . show ( ) ; } else { ( ( ManageLocationsActivity ) activity ) . addCityToList ( selectedCity ) ; dismiss ( ) ; } } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import androidx . core . content . ContextCompat ; import androidx . recyclerview . widget . RecyclerView ; import android . util . Log ; import android . view . View ; import org . woheller69 . weather . R ; public class SimpleDividerItemDecoration extends RecyclerView . ItemDecoration { private Drawable mDivider ; public SimpleDividerItemDecoration ( Context context ) { mDivider = ContextCompat . getDrawable ( context , R . drawable . recycle_view_line_divider ) ; } @ Override public void onDrawOver ( Canvas c , RecyclerView parent , RecyclerView . State state ) { int left = parent . getPaddingLeft ( ) ; int right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount - <NUM_LIT> ; i ++ ) { View child = parent . getChildAt ( i ) ; RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; int top = child . getBottom ( ) + params . bottomMargin ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + top ) ; int bottom = top + mDivider . getIntrinsicHeight ( ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + top ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( c ) ; } } } </s>
<s> package org . woheller69 . weather . weather_api . open_meteo ; import android . content . Context ; import org . woheller69 . weather . http . HttpRequestType ; import org . woheller69 . weather . http . IHttpRequest ; import org . woheller69 . weather . http . VolleyHttpRequest ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; public class OMHttpRequestForWeatherAPI extends OMHttpRequest implements IHttpRequestForWeatherAPI { private final Context context ; public OMHttpRequestForWeatherAPI ( Context context ) { this . context = context ; } @ Override public void perform ( float lat , float lon , int cityId ) { IHttpRequest httpRequest = new VolleyHttpRequest ( context , cityId ) ; final String URL = getUrlForQueryingOMweatherAPI ( context , lat , lon ) ; httpRequest . make ( URL , HttpRequestType . GET , new ProcessOMweatherAPIRequest ( context ) ) ; } } </s>
<s> package org . woheller69 . weather . weather_api ; import com . android . volley . VolleyError ; public interface IProcessHttpRequest { void processSuccessScenario ( String response , int cityId ) ; void processFailScenario ( VolleyError error ) ; } </s>
<s> package org . woheller69 . weather . weather_api . open_meteo ; import android . appwidget . AppWidgetManager ; import android . content . ComponentName ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Handler ; import android . widget . RemoteViews ; import android . widget . Toast ; import com . android . volley . VolleyError ; import org . json . JSONException ; import org . json . JSONObject ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . weather_api . IDataExtractor ; import org . woheller69 . weather . weather_api . IProcessHttpRequest ; import org . woheller69 . weather . widget . WeatherDigitalClockWidget ; import org . woheller69 . weather . widget . WeatherWidget ; import org . woheller69 . weather . widget . WeatherWidget5day ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion . WeatherCategories ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class ProcessOMweatherAPIRequest implements IProcessHttpRequest { private final String DEBUG_TAG = "<STR_LIT>" ; private Context context ; private SQLiteHelper dbHelper ; public ProcessOMweatherAPIRequest ( Context context ) { this . context = context ; this . dbHelper = SQLiteHelper . getInstance ( context ) ; } @ Override public void processSuccessScenario ( String response , int cityId ) { IDataExtractor extractor = new OMDataExtractor ( context ) ; try { JSONObject json = new JSONObject ( response ) ; List < WeekForecast > weekforecasts = new ArrayList < > ( ) ; weekforecasts = extractor . extractWeekForecast ( json . getString ( "<STR_LIT>" ) ) ; if ( weekforecasts != null && ! weekforecasts . isEmpty ( ) ) { for ( WeekForecast weekForecast : weekforecasts ) { weekForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } String rain60min = context . getResources ( ) . getString ( R . string . error_no_rain60min_data ) ; CurrentWeatherData weatherData = extractor . extractCurrentWeather ( json . getString ( "<STR_LIT>" ) ) ; if ( weatherData == null ) { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } else { weatherData . setCity_id ( cityId ) ; weatherData . setRain60min ( rain60min ) ; weatherData . setTimeSunrise ( weekforecasts . get ( <NUM_LIT> ) . getTimeSunrise ( ) ) ; weatherData . setTimeSunset ( weekforecasts . get ( <NUM_LIT> ) . getTimeSunset ( ) ) ; weatherData . setTimeZoneSeconds ( json . getInt ( "<STR_LIT>" ) ) ; CurrentWeatherData current = dbHelper . getCurrentWeatherByCityId ( cityId ) ; if ( current != null && current . getCity_id ( ) == cityId ) { dbHelper . updateCurrentWeather ( weatherData ) ; } else { dbHelper . addCurrentWeather ( weatherData ) ; } } List < HourlyForecast > hourlyforecasts = new ArrayList < > ( ) ; hourlyforecasts = extractor . extractHourlyForecast ( json . getString ( "<STR_LIT>" ) ) ; if ( hourlyforecasts != null && ! hourlyforecasts . isEmpty ( ) ) { for ( HourlyForecast hourlyForecast : hourlyforecasts ) { hourlyForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } dbHelper . replaceForecasts ( hourlyforecasts ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , false ) ) { weekforecasts = reanalyzeWeekIDs ( weekforecasts , hourlyforecasts ) ; } dbHelper . replaceWeekForecasts ( weekforecasts ) ; if ( json . has ( "<STR_LIT>" ) ) { List < QuarterHourlyForecast > quarterHourlyForecasts = new ArrayList < > ( ) ; quarterHourlyForecasts = extractor . extractQuarterHourlyForecast ( json . getString ( "<STR_LIT>" ) ) ; if ( quarterHourlyForecasts != null && ! quarterHourlyForecasts . isEmpty ( ) ) { for ( QuarterHourlyForecast quarterHourlyForecast : quarterHourlyForecasts ) { quarterHourlyForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } dbHelper . replaceQuarterHourlyForecasts ( quarterHourlyForecasts ) ; } possiblyUpdateWidgets ( cityId , weatherData , weekforecasts , hourlyforecasts ) ; ViewUpdater . updateCurrentWeatherData ( weatherData ) ; ViewUpdater . updateWeekForecasts ( weekforecasts ) ; ViewUpdater . updateForecasts ( hourlyforecasts ) ; } catch ( JSONException e ) { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; } } private List < WeekForecast > reanalyzeWeekIDs ( List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { Map < Integer , Integer > mappingTable = new HashMap < > ( ) ; mappingTable . put ( WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) , WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MIST . getNumVal ( ) , WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MODERATE_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . HEAVY_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . FREEZING_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_SNOW . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MODERATE_SNOW . getNumVal ( ) , WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . HEAVY_SNOW . getNumVal ( ) , WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) ; Map < Integer , Integer > sunTable = new HashMap < > ( ) ; sunTable . put ( WeatherCategories . CLEAR_SKY . getNumVal ( ) , <NUM_LIT> ) ; sunTable . put ( WeatherCategories . FEW_CLOUDS . getNumVal ( ) , <NUM_LIT> ) ; sunTable . put ( WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) , <NUM_LIT> ) ; for ( WeekForecast weekForecast : weekforecasts ) { Integer ID = weekForecast . getWeatherID ( ) ; if ( mappingTable . containsKey ( ID ) ) { int totalCount = <NUM_LIT> ; int sunCount = <NUM_LIT> ; long sunrise = weekForecast . getTimeSunrise ( ) * <NUM_LIT> ; long sunset = weekForecast . getTimeSunset ( ) * <NUM_LIT> ; for ( HourlyForecast hourlyForecast : hourlyforecasts ) { if ( hourlyForecast . getForecastTime ( ) >= sunrise && hourlyForecast . getForecastTime ( ) <= sunset ) { totalCount ++ ; if ( sunTable . containsKey ( hourlyForecast . getWeatherID ( ) ) ) sunCount ++ ; } } if ( totalCount > <NUM_LIT> && ( float ) sunCount / totalCount > <NUM_LIT> ) weekForecast . setWeatherID ( mappingTable . get ( ID ) ) ; } } return weekforecasts ; } @ Override public void processFailScenario ( final VolleyError error ) { Handler h = new Handler ( this . context . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( context , context . getResources ( ) . getString ( R . string . error_fetch_forecast ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } private void possiblyUpdateWidgets ( int cityID , CurrentWeatherData currentWeather , List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { int widgetCityID = getWidgetCityID ( context ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int widgetID : widgetIDs ) { if ( cityID == widgetCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts , hourlyforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } int widgetDigitalClockCityID = getWidgetCityID ( context ) ; int [ ] widgetDigitalClockIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int widgetID : widgetDigitalClockIDs ) { if ( cityID == widgetDigitalClockCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_digital_clock_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherDigitalClockWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } int widget5dayCityID = getWidgetCityID ( context ) ; int [ ] widget5dayIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget5day . class ) ) ; for ( int widgetID : widget5dayIDs ) { if ( cityID == widget5dayCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget_5day ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherWidget5day . updateView ( context , appWidgetManager , views , widgetID , city , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } } } </s>
<s> package org . woheller69 . weather . activities ; import static java . lang . Boolean . TRUE ; import android . annotation . SuppressLint ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . os . Bundle ; import android . view . View ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . ImageButton ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class RainViewerActivity extends AppCompatActivity { private WebView webView ; private ImageButton btnPrev , btnNext , btnStartStop ; @ Override protected void onPause ( ) { super . onPause ( ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_rain_viewer ) ; float latitude = getIntent ( ) . getFloatExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; float longitude = getIntent ( ) . getFloatExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; int timezoneseconds = getIntent ( ) . getIntExtra ( "<STR_LIT>" , <NUM_LIT> ) ; int nightmode = <NUM_LIT> ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( "<STR_LIT>" , false ) == TRUE ) { int nightModeFlags = getApplicationContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; if ( nightModeFlags == Configuration . UI_MODE_NIGHT_YES ) nightmode = <NUM_LIT> ; } int hour12 = <NUM_LIT> ; if ( android . text . format . DateFormat . is24HourFormat ( this ) || sharedPreferences . getBoolean ( "<STR_LIT>" , true ) == TRUE ) { hour12 = <NUM_LIT> ; } webView = findViewById ( R . id . webView ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . getSettings ( ) . setUserAgentString ( BuildConfig . APPLICATION_ID + "<STR_LIT>" + BuildConfig . VERSION_NAME ) ; webView . loadUrl ( "<STR_LIT>" + latitude + "<STR_LIT>" + longitude + "<STR_LIT>" + nightmode + "<STR_LIT>" + hour12 + "<STR_LIT>" + timezoneseconds ) ; webView . setWebViewClient ( new WebViewClient ( ) { @ Override public void onPageFinished ( WebView view , String url ) { super . onPageFinished ( webView , url ) ; btnNext = findViewById ( R . id . rainviewer_next ) ; btnPrev = findViewById ( R . id . rainviewer_prev ) ; btnStartStop = findViewById ( R . id . rainviewer_startstop ) ; btnNext . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( "<STR_LIT>" ) ; } } ) ; btnPrev . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( "<STR_LIT>" ) ; } } ) ; btnStartStop . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( "<STR_LIT>" ) ; } } ) ; } } ) ; Toolbar toolbar = findViewById ( R . id . toolbar ) ; if ( getSupportActionBar ( ) == null ) { setSupportActionBar ( toolbar ) ; } getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; getSupportActionBar ( ) . setDisplayShowHomeEnabled ( true ) ; } } </s>
<s> package org . woheller69 . weather . activities ; import android . content . Intent ; import android . os . Bundle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . firststart . TutorialActivity ; import org . woheller69 . weather . preferences . AppPreferencesManager ; public class SplashActivity extends AppCompatActivity { private AppPreferencesManager prefManager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; if ( prefManager . isFirstTimeLaunch ( this ) ) { Intent mainIntent = new Intent ( SplashActivity . this , TutorialActivity . class ) ; SplashActivity . this . startActivity ( mainIntent ) ; } else { Intent mainIntent = new Intent ( SplashActivity . this , ForecastCityActivity . class ) ; SplashActivity . this . startActivity ( mainIntent ) ; } SplashActivity . this . finish ( ) ; } } </s>
<s> package org . woheller69 . weather . database ; import android . content . Context ; import java . util . Calendar ; import java . util . TimeZone ; public class CurrentWeatherData { private int id ; private int city_id ; private long timestamp ; private int weatherID ; private float temperatureCurrent ; private float humidity ; private float pressure ; private float windSpeed ; private float windDirection ; private float cloudiness ; private long timeSunrise ; private long timeSunset ; private int timeZoneSeconds ; private String Rain60min ; private String city_name ; public CurrentWeatherData ( ) { this . city_id = Integer . MIN_VALUE ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperatureCurrent ( ) { return temperatureCurrent ; } public void setTemperatureCurrent ( float temperatureCurrent ) { this . temperatureCurrent = temperatureCurrent ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getWindSpeed ( ) { return windSpeed ; } public void setWindSpeed ( float windSpeed ) { this . windSpeed = windSpeed ; } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getCloudiness ( ) { return cloudiness ; } public void setCloudiness ( float cloudiness ) { this . cloudiness = cloudiness ; } public boolean isDay ( Context context ) { Calendar timeStamp = Calendar . getInstance ( ) ; timeStamp . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; timeStamp . setTimeInMillis ( ( timestamp + timeZoneSeconds ) * <NUM_LIT> ) ; SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; if ( timeSunrise == <NUM_LIT> || timeSunset == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( city_id ) . getLatitude ( ) ) > <NUM_LIT> ) { return timeStamp . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && timeStamp . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { return timeStamp . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || timeStamp . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { return timestamp > timeSunrise && timestamp < timeSunset ; } } public long getTimeSunrise ( ) { return timeSunrise ; } public void setTimeSunrise ( long timeSunrise ) { this . timeSunrise = timeSunrise ; } public long getTimeSunset ( ) { return timeSunset ; } public void setTimeSunset ( long timeSunset ) { this . timeSunset = timeSunset ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public int getTimeZoneSeconds ( ) { return timeZoneSeconds ; } public void setTimeZoneSeconds ( int timeZoneSeconds ) { this . timeZoneSeconds = timeZoneSeconds ; } public String getRain60min ( ) { return Rain60min ; } public void setRain60min ( String Rain60min ) { this . Rain60min = Rain60min ; } } </s>
<s> package org . woheller69 . weather . database ; public class CityToWatch { private int id ; private int cityId ; private String cityName ; private float lon ; private float lat ; private int rank ; public CityToWatch ( ) { } public CityToWatch ( int rank , int id , int cityId , float lon , float lat , String cityName ) { this . rank = rank ; this . lon = lon ; this . lat = lat ; this . id = id ; this . cityId = cityId ; this . cityName = cityName ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public int getCityId ( ) { return cityId ; } public void setCityId ( int cityId ) { this . cityId = cityId ; } public String getCityName ( ) { return cityName ; } public void setCityName ( String cityName ) { this . cityName = cityName ; } public int getRank ( ) { return rank ; } public void setRank ( int rank ) { this . rank = rank ; } public void setLongitude ( float lon ) { this . lon = lon ; } public float getLongitude ( ) { return lon ; } public float getLatitude ( ) { return lat ; } public void setLatitude ( float lat ) { this . lat = lat ; } } </s>
<s> package org . woheller69 . weather . http ; public enum HttpRequestType { POST , GET , PUT , DELETE } </s>
<s> package org . woheller69 . weather . ui ; import org . woheller69 . weather . R ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion . WeatherCategories ; public class UiResourceProvider { private UiResourceProvider ( ) { } public static int getIconResourceForWeatherCategory ( int categoryNumber , boolean isDay ) { if ( categoryNumber == WeatherCategories . CLEAR_SKY . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_00d ; } else { return R . drawable . wmo_icon_00n ; } } else if ( categoryNumber == WeatherCategories . FEW_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_01d ; } else { return R . drawable . wmo_icon_01n ; } } else if ( categoryNumber == WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_02d ; } else { return R . drawable . wmo_icon_02n ; } } else if ( categoryNumber == WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_03d ; } else { return R . drawable . wmo_icon_03n ; } } else if ( categoryNumber == WeatherCategories . MIST . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_45d ; } else { return R . drawable . wmo_icon_45n ; } } else if ( categoryNumber == WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_53d ; } else { return R . drawable . wmo_icon_53n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_57d ; } else { return R . drawable . wmo_icon_57n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_61d ; } else { return R . drawable . wmo_icon_61n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_63d ; } else { return R . drawable . wmo_icon_63n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_65d ; } else { return R . drawable . wmo_icon_65n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_80d ; } else { return R . drawable . wmo_icon_80n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_81d ; } else { return R . drawable . wmo_icon_81n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_71d ; } else { return R . drawable . wmo_icon_71n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_73d ; } else { return R . drawable . wmo_icon_73n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_75d ; } else { return R . drawable . wmo_icon_75n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_66d ; } else { return R . drawable . wmo_icon_66n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_67d ; } else { return R . drawable . wmo_icon_67n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_85d ; } else { return R . drawable . wmo_icon_85n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_86d ; } else { return R . drawable . wmo_icon_86n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_84d ; } else { return R . drawable . wmo_icon_84n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_95d ; } else { return R . drawable . wmo_icon_95n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_96d ; } else { return R . drawable . wmo_icon_96n ; } } else { return R . drawable . wmo_icon_error ; } } public static int getImageResourceForWeatherCategory ( int categoryNumber , boolean isDay ) { if ( categoryNumber == WeatherCategories . CLEAR_SKY . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_00d ; } else { return R . drawable . wmo_image_00n ; } } else if ( categoryNumber == WeatherCategories . FEW_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_01d ; } else { return R . drawable . wmo_image_01n ; } } else if ( categoryNumber == WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_02d ; } else { return R . drawable . wmo_image_02n ; } } else if ( categoryNumber == WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_03d ; } else { return R . drawable . wmo_image_03n ; } } else if ( categoryNumber == WeatherCategories . MIST . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_45d ; } else { return R . drawable . wmo_image_45n ; } } else if ( categoryNumber == WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_53d ; } else { return R . drawable . wmo_image_53n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_57d ; } else { return R . drawable . wmo_image_57n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_61d ; } else { return R . drawable . wmo_image_61n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_63d ; } else { return R . drawable . wmo_image_63n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_65d ; } else { return R . drawable . wmo_image_65n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_80d ; } else { return R . drawable . wmo_image_80n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_81d ; } else { return R . drawable . wmo_image_81n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_71d ; } else { return R . drawable . wmo_image_71n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_73d ; } else { return R . drawable . wmo_image_73n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_75d ; } else { return R . drawable . wmo_image_75n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_66d ; } else { return R . drawable . wmo_image_66n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_67d ; } else { return R . drawable . wmo_image_67n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_85d ; } else { return R . drawable . wmo_image_85n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_86d ; } else { return R . drawable . wmo_image_86n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_84d ; } else { return R . drawable . wmo_image_84n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_95d ; } else { return R . drawable . wmo_image_95n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_96d ; } else { return R . drawable . wmo_image_96n ; } } else { return R . drawable . wmo_image_error ; } } } </s>
<s> package org . woheller69 . weather . ui . updater ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . List ; public interface IUpdateableCityUI { void processNewCurrentWeatherData ( CurrentWeatherData data ) ; void processNewForecasts ( List < HourlyForecast > hourlyForecasts ) ; void processNewWeekForecasts ( List < WeekForecast > forecasts ) ; } </s>
<s> package org . woheller69 . weather . weather_api ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . List ; public interface IDataExtractor { CurrentWeatherData extractCurrentWeather ( String data ) ; List < WeekForecast > extractWeekForecast ( String data ) ; List < HourlyForecast > extractHourlyForecast ( String data ) ; List < QuarterHourlyForecast > extractQuarterHourlyForecast ( String data ) ; } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; public interface ItemTouchHelperAdapter { void onItemDismiss ( int position ) ; void onItemMove ( int fromPosition , int toPosition ) ; } </s>
<s> package org . woheller69 . weather . activities ; import android . os . Bundle ; import android . text . method . LinkMovementMethod ; import android . widget . TextView ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class AboutActivity extends NavigationActivity { protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; ( ( TextView ) findViewById ( R . id . rainviewerURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . openmeteoURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . githubURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . textFieldVersionName ) ) . setText ( BuildConfig . VERSION_NAME ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_about ; } } </s>
<s> package org . woheller69 . weather . http ; import android . content . Context ; import android . util . Log ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . Response ; import com . android . volley . VolleyError ; import com . android . volley . toolbox . HurlStack ; import com . android . volley . toolbox . StringRequest ; import com . android . volley . toolbox . Volley ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . weather_api . IProcessHttpRequest ; import java . io . BufferedInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . security . KeyManagementException ; import java . security . KeyStore ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . Certificate ; import java . security . cert . CertificateException ; import java . security . cert . CertificateFactory ; import java . security . cert . X509Certificate ; import java . util . HashMap ; import java . util . Map ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLSocketFactory ; import javax . net . ssl . TrustManagerFactory ; public class VolleyHttpRequest implements IHttpRequest { private Context context ; private int cityId ; public VolleyHttpRequest ( Context context , int cityId ) { this . context = context ; this . cityId = cityId ; } @ Override public void make ( String URL , HttpRequestType method , final IProcessHttpRequest requestProcessor ) { RequestQueue queue = Volley . newRequestQueue ( context ) ; int requestMethod ; switch ( method ) { case POST : requestMethod = Request . Method . POST ; break ; case GET : requestMethod = Request . Method . GET ; break ; case PUT : requestMethod = Request . Method . PUT ; break ; case DELETE : requestMethod = Request . Method . DELETE ; break ; default : requestMethod = Request . Method . GET ; } StringRequest stringRequest = new StringRequest ( requestMethod , URL , new Response . Listener < String > ( ) { @ Override public void onResponse ( String response ) { requestProcessor . processSuccessScenario ( response , cityId ) ; } } , new Response . ErrorListener ( ) { @ Override public void onErrorResponse ( VolleyError error ) { requestProcessor . processFailScenario ( error ) ; } } ) { @ Override public Map < String , String > getHeaders ( ) { Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( "<STR_LIT>" , BuildConfig . APPLICATION_ID + "<STR_LIT>" + BuildConfig . VERSION_NAME ) ; return params ; } } ; queue . add ( stringRequest ) ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . recyclerview . widget . RecyclerView ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import java . util . Collections ; import java . util . List ; public class RecyclerOverviewListAdapter extends RecyclerView . Adapter < ItemViewHolder > implements ItemTouchHelperAdapter { private Context context ; private final List < CityToWatch > cities ; SQLiteHelper database ; public RecyclerOverviewListAdapter ( Context context , List < CityToWatch > cities ) { this . context = context ; this . cities = cities ; this . database = SQLiteHelper . getInstance ( context ) ; } @ Override public ItemViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . list_item_city_list , parent , false ) ; return new ItemViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ItemViewHolder holder , int position ) { holder . getTvInformation ( ) . setText ( cities . get ( position ) . getCityName ( ) ) ; } @ Override public int getItemCount ( ) { return cities . size ( ) ; } @ Override public void onItemDismiss ( int position ) { CityToWatch city = cities . get ( position ) ; database . deleteCityToWatch ( city ) ; cities . remove ( position ) ; notifyItemRemoved ( position ) ; } @ Override public void onItemMove ( int fromPosition , int toPosition ) { CityToWatch fromCityToWatch = cities . get ( fromPosition ) ; int fromRank = fromCityToWatch . getRank ( ) ; CityToWatch toCityToWatch = cities . get ( toPosition ) ; int toRank = toCityToWatch . getRank ( ) ; fromCityToWatch . setRank ( toRank ) ; toCityToWatch . setRank ( fromRank ) ; database . updateCityToWatch ( fromCityToWatch ) ; database . updateCityToWatch ( toCityToWatch ) ; Collections . swap ( cities , fromPosition , toPosition ) ; notifyItemMoved ( fromPosition , toPosition ) ; } public String getCityName ( int position ) { CityToWatch cityToWatch = cities . get ( position ) ; return cityToWatch . getCityName ( ) ; } public void renameCity ( int position , String s ) { CityToWatch cityToWatch = cities . get ( position ) ; cityToWatch . setCityName ( s ) ; database . updateCityToWatch ( cityToWatch ) ; notifyItemChanged ( position ) ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . core . content . ContextCompat ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . database . WeekForecast ; import androidx . recyclerview . widget . RecyclerView ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . TimeZone ; public class WeekWeatherAdapter extends RecyclerView . Adapter < WeekWeatherAdapter . WeekForecastViewHolder > { private Context context ; private List < WeekForecast > weekForecastList ; private int cityID ; private Date courseOfDayHeaderDate ; WeekWeatherAdapter ( Context context , List < WeekForecast > weekForecastList , int cityID ) { this . context = context ; this . cityID = cityID ; this . weekForecastList = weekForecastList ; if ( weekForecastList != null && ! weekForecastList . isEmpty ( ) ) { this . courseOfDayHeaderDate = new Date ( weekForecastList . get ( <NUM_LIT> ) . getLocalForecastTime ( context ) ) ; } else this . courseOfDayHeaderDate = new Date ( ) ; } public void setCourseOfDayHeaderDate ( Date courseOfDayHeaderDate ) { Date oldDate = this . courseOfDayHeaderDate ; this . courseOfDayHeaderDate = courseOfDayHeaderDate ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; c . setTime ( oldDate ) ; int oldDay = c . get ( Calendar . DAY_OF_MONTH ) ; c . setTime ( courseOfDayHeaderDate ) ; int newDay = c . get ( Calendar . DAY_OF_MONTH ) ; if ( newDay != oldDay ) { notifyDataSetChanged ( ) ; } } @ Override public WeekForecastViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . list_item_week_forecast , parent , false ) ; return new WeekForecastViewHolder ( view ) ; } @ Override public void onBindViewHolder ( WeekForecastViewHolder holder , int position ) { WeekForecast weekForecast = weekForecastList . get ( position ) ; SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( cityID ) ; Calendar forecastTime = Calendar . getInstance ( ) ; forecastTime . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; forecastTime . setTimeInMillis ( weekForecast . getLocalForecastTime ( context ) ) ; boolean isDay ; if ( currentWeather . getTimeSunrise ( ) == <NUM_LIT> || currentWeather . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( cityID ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && forecastTime . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || forecastTime . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { isDay = true ; } setIcon ( weekForecast . getWeatherID ( ) , holder . weather , isDay ) ; holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( weekForecast . getWind_speed ( ) ) ) ; if ( weekForecast . getPrecipitation ( ) == <NUM_LIT> ) holder . precipitation . setText ( "<STR_LIT>" ) ; else holder . precipitation . setText ( StringFormatUtils . formatPrecipitation ( context , weekForecast . getPrecipitation ( ) ) ) ; if ( weekForecast . getUv_index ( ) == - <NUM_LIT> ) { holder . uv_index . setVisibility ( View . GONE ) ; } else { holder . uv_index . setVisibility ( View . VISIBLE ) ; holder . uv_index . setText ( String . format ( "<STR_LIT>" , StringFormatUtils . formatInt ( Math . round ( weekForecast . getUv_index ( ) ) ) ) ) ; holder . uv_index . setBackground ( StringFormatUtils . colorUVindex ( context , Math . round ( weekForecast . getUv_index ( ) ) ) ) ; } holder . wind_speed . setText ( StringFormatUtils . formatWindSpeed ( context , weekForecast . getWind_speed ( ) ) ) ; holder . wind_speed . setBackground ( StringFormatUtils . colorWindSpeed ( context , weekForecast . getWind_speed ( ) ) ) ; holder . sunshine_hours . setText ( "<STR_LIT>" + Math . round ( weekForecast . getSunshineHours ( ) ) + "<STR_LIT>" + context . getString ( R . string . units_hours ) ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; c . setTimeInMillis ( weekForecast . getLocalForecastTime ( context ) ) ; int day = c . get ( Calendar . DAY_OF_WEEK ) ; holder . day . setText ( StringFormatUtils . getDayShort ( day ) ) ; holder . temperature_max . setText ( StringFormatUtils . formatTemperature ( context , weekForecast . getMaxTemperature ( ) ) ) ; holder . temperature_min . setText ( StringFormatUtils . formatTemperature ( context , weekForecast . getMinTemperature ( ) ) ) ; day = c . get ( Calendar . DAY_OF_MONTH ) ; c . setTimeInMillis ( courseOfDayHeaderDate . getTime ( ) ) ; int dayheader = c . get ( Calendar . DAY_OF_MONTH ) ; if ( dayheader == day ) { holder . itemView . setBackground ( ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_highlight , null ) ) ; } else { holder . itemView . setBackground ( ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ) ; } } @ Override public int getItemCount ( ) { if ( weekForecastList != null && ! weekForecastList . isEmpty ( ) ) return weekForecastList . size ( ) ; else return <NUM_LIT> ; } class WeekForecastViewHolder extends RecyclerView . ViewHolder { TextView day ; ImageView weather ; TextView temperature_max ; TextView temperature_min ; TextView wind_speed ; TextView precipitation ; TextView uv_index ; TextView sunshine_hours ; ImageView windicon ; WeekForecastViewHolder ( View itemView ) { super ( itemView ) ; day = itemView . findViewById ( R . id . week_forecast_day ) ; weather = itemView . findViewById ( R . id . week_forecast_weather ) ; temperature_max = itemView . findViewById ( R . id . week_forecast_temperature_max ) ; temperature_max . setTextColor ( ContextCompat . getColor ( context , R . color . red ) ) ; temperature_min = itemView . findViewById ( R . id . week_forecast_temperature_min ) ; temperature_min . setTextColor ( ContextCompat . getColor ( context , R . color . midblue ) ) ; wind_speed = itemView . findViewById ( R . id . week_forecast_wind_speed ) ; precipitation = itemView . findViewById ( R . id . week_forecast_precipitation ) ; uv_index = itemView . findViewById ( R . id . week_forecast_uv_index ) ; windicon = itemView . findViewById ( R . id . week_forecast_wind_icon ) ; sunshine_hours = itemView . findViewById ( R . id . week_forecast_sunshine_hours ) ; } } @ Override public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { super . onAttachedToRecyclerView ( recyclerView ) ; } public void setIcon ( int value , ImageView imageView , boolean isDay ) { imageView . setImageResource ( UiResourceProvider . getIconResourceForWeatherCategory ( value , isDay ) ) ; } } </s>
<s> package org . woheller69 . weather . activities ; import android . Manifest ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . annotation . RequiresApi ; import androidx . appcompat . app . AlertDialog ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceFragmentCompat ; import androidx . preference . PreferenceManager ; import androidx . preference . SeekBarPreference ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . SQLiteHelper ; import static java . lang . Boolean . TRUE ; public class SettingsActivity extends NavigationActivity implements SharedPreferences . OnSharedPreferenceChangeListener { @ Override protected void onRestart ( ) { super . onRestart ( ) ; recreate ( ) ; } @ RequiresApi ( api = Build . VERSION_CODES . Q ) @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == <NUM_LIT> ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { if ( ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_FINE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) && ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_BACKGROUND_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; String message = getString ( R . string . rationale_background_location ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { message = message + "<STR_LIT>" + getPackageManager ( ) . getBackgroundPermissionOptionLabel ( ) . toString ( ) + "<STR_LIT>" ; } alertDialogBuilder . setMessage ( message ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , ( dialog , which ) -> requestBackgroundLocation ( ) ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , ( dialog , which ) -> { } ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } } } } } @ RequiresApi ( api = Build . VERSION_CODES . Q ) private void requestBackgroundLocation ( ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_BACKGROUND_LOCATION } , <NUM_LIT> ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; PreferenceManager . getDefaultSharedPreferences ( this . getApplicationContext ( ) ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_settings ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_settings ; } @ RequiresApi ( api = Build . VERSION_CODES . Q ) @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String s ) { if ( s . equals ( "<STR_LIT>" ) ) { if ( sharedPreferences . getBoolean ( "<STR_LIT>" , true ) == TRUE ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_COARSE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION } , <NUM_LIT> ) ; } else { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_COARSE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION , Manifest . permission . ACCESS_BACKGROUND_LOCATION } , <NUM_LIT> ) ; } } } } else if ( s . equals ( "<STR_LIT>" ) ) { SQLiteHelper database = SQLiteHelper . getInstance ( getApplicationContext ( ) . getApplicationContext ( ) ) ; database . deleteAllForecasts ( ) ; } } public static class GeneralPreferenceFragment extends PreferenceFragmentCompat implements SharedPreferences . OnSharedPreferenceChangeListener { @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . pref_general , rootKey ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; getPreferenceManager ( ) . getSharedPreferences ( ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override public void onPause ( ) { getPreferenceManager ( ) . getSharedPreferences ( ) . unregisterOnSharedPreferenceChangeListener ( this ) ; super . onPause ( ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { if ( key . equals ( "<STR_LIT>" ) ) { SeekBarPreference numberDays = findPreference ( "<STR_LIT>" ) ; if ( numberDays . getValue ( ) < <NUM_LIT> ) numberDays . setValue ( <NUM_LIT> ) ; } } } } </s>
<s> package org . woheller69 . weather . widget ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . widget . RemoteViews ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . util . Calendar ; import java . util . List ; import java . util . TimeZone ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; public class WeatherWidget5day extends AppWidgetProvider { public void updateAppWidget ( Context context , final int appWidgetId ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( "<STR_LIT>" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , List < WeekForecast > weekforecasts ) { int cityId = getWidgetCityID ( context ) ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; int zonemilliseconds = database . getCurrentWeatherByCityId ( cityId ) . getTimeZoneSeconds ( ) * <NUM_LIT> ; CurrentWeatherData currentWeather = database . getCurrentWeatherByCityId ( cityId ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( "<STR_LIT>" ) ) ; int [ ] forecastData = new int [ <NUM_LIT> ] ; boolean [ ] isDay = new boolean [ <NUM_LIT> ] ; String [ ] weekday = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { c . setTimeInMillis ( weekforecasts . get ( i ) . getForecastTime ( ) + zonemilliseconds ) ; if ( currentWeather . getTimeSunrise ( ) == <NUM_LIT> || currentWeather . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( database . getCityToWatch ( cityId ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay [ i ] = c . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && c . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay [ i ] = c . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || c . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { isDay [ i ] = true ; } int day = c . get ( Calendar . DAY_OF_WEEK ) ; weekday [ i ] = context . getResources ( ) . getString ( StringFormatUtils . getDayShort ( day ) ) ; forecastData [ i ] = weekforecasts . get ( i ) . getWeatherID ( ) ; } views . setImageViewResource ( R . id . widget_5day_image1 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image2 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image3 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image4 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image5 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setTextViewText ( R . id . widget_5day_day1 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day2 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day3 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day4 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day5 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_temp_max1 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max2 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max3 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max4 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max5 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min1 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min2 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min3 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min4 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min5 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind1 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind2 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind3 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind4 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind5 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( "<STR_LIT>" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget5day_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget5day . class ) ) ; for ( int widgetID : widgetIDs ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget_5day ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherWidget5day . updateView ( context , appWidgetManager , views , widgetID , city , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { } } </s>
<s> package org . woheller69 . weather . database ; import android . content . Context ; public class WeekForecast { public static final float NO_RAIN_VALUE = <NUM_LIT> ; private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float temperature_min ; private float temperature_max ; private float humidity ; private float pressure ; private float precipitation ; private float wind_speed ; private float wind_direction ; private float uv_index ; private long timeSunrise ; private long timeSunset ; private float sunshineHours ; public WeekForecast ( ) { } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; } public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getMinTemperature ( ) { return temperature_min ; } public void setMinTemperature ( float temperature_min ) { this . temperature_min = temperature_min ; } public float getMaxTemperature ( ) { return temperature_max ; } public void setMaxTemperature ( float temperature_max ) { this . temperature_max = temperature_max ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } public float getWind_speed ( ) { return wind_speed ; } public void setWind_speed ( float wind_speed ) { this . wind_speed = wind_speed ; } public float getWind_direction ( ) { return wind_direction ; } public void setWind_direction ( float wind_direction ) { this . wind_direction = wind_direction ; } public float getUv_index ( ) { return uv_index ; } public void setUv_index ( float uv_index ) { this . uv_index = uv_index ; } public long getTimeSunrise ( ) { return timeSunrise ; } public void setTimeSunrise ( long timeSunrise ) { this . timeSunrise = timeSunrise ; } public long getTimeSunset ( ) { return timeSunset ; } public void setTimeSunset ( long timeSunset ) { this . timeSunset = timeSunset ; } public float getSunshineHours ( ) { return sunshineHours ; } public void setSunshineHours ( float sunshineHours ) { this . sunshineHours = sunshineHours ; } } </s>
<s> package org . woheller69 . weather . database ; import java . util . Locale ; public class City { private int cityId ; private String cityName ; private String countryCode ; private float lon ; private float lat ; public City ( ) { } public int getCityId ( ) { return cityId ; } public void setCityId ( int cityId ) { this . cityId = cityId ; } public String getCityName ( ) { return cityName ; } public void setCityName ( String cityName ) { this . cityName = cityName ; } public String getCountryCode ( ) { return countryCode ; } public void setCountryCode ( String countryCode ) { this . countryCode = countryCode ; } @ Override public String toString ( ) { return String . format ( Locale . getDefault ( ) , "<STR_LIT>" , cityName , countryCode , lat , lon ) ; } public void setLatitude ( float latitude ) { lat = latitude ; } public float getLatitude ( ) { return lat ; } public float getLongitude ( ) { return lon ; } public void setLongitude ( float lon ) { this . lon = lon ; } } </s>
<s> package org . woheller69 . weather . activities ; import static java . lang . Boolean . TRUE ; import android . Manifest ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Bundle ; import androidx . appcompat . app . AlertDialog ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import com . google . android . material . tabs . TabLayout ; import com . google . android . material . tabs . TabLayoutMediator ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager2 . widget . ViewPager2 ; import android . util . Log ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . LinearInterpolator ; import android . view . animation . RotateAnimation ; import android . widget . TextView ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . ui . viewPager . WeatherPagerAdapter ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . lang . reflect . Field ; import java . util . List ; import java . util . Locale ; public class ForecastCityActivity extends NavigationActivity implements IUpdateableCityUI { private WeatherPagerAdapter pagerAdapter ; private static LocationListener locationListenerGPS ; private LocationManager locationManager ; private static MenuItem updateLocationButton ; private static MenuItem refreshActionButton ; private MenuItem rainviewerButton ; private int cityId = - <NUM_LIT> ; private ViewPager2 viewPager2 ; private TabLayout tabLayout ; private TextView noCityText ; private static Boolean isRefreshing = false ; Context context ; @ Override protected void onPause ( ) { super . onPause ( ) ; ViewUpdater . removeSubscriber ( this ) ; ViewUpdater . removeSubscriber ( pagerAdapter ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { viewPager2 . setVisibility ( View . GONE ) ; noCityText . setVisibility ( View . VISIBLE ) ; } else { noCityText . setVisibility ( View . GONE ) ; viewPager2 . setVisibility ( View . VISIBLE ) ; pagerAdapter . loadCities ( ) ; viewPager2 . setAdapter ( pagerAdapter ) ; TabLayoutMediator tabLayoutMediator = new TabLayoutMediator ( tabLayout , viewPager2 , false , false , ( tab , position ) -> tab . setText ( pagerAdapter . getPageTitle ( position ) ) ) ; tabLayoutMediator . attach ( ) ; } ViewUpdater . addSubscriber ( this ) ; ViewUpdater . addSubscriber ( pagerAdapter ) ; if ( pagerAdapter . getItemCount ( ) > <NUM_LIT> ) { if ( pagerAdapter . getPosForCityID ( cityId ) == - <NUM_LIT> ) cityId = pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ; if ( viewPager2 . getCurrentItem ( ) != pagerAdapter . getPosForCityID ( cityId ) ) viewPager2 . setCurrentItem ( pagerAdapter . getPosForCityID ( cityId ) , false ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; context = this ; setContentView ( R . layout . activity_forecast_city ) ; initResources ( ) ; viewPager2 . registerOnPageChangeCallback ( new ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; SQLiteHelper database = SQLiteHelper . getInstance ( getApplicationContext ( ) . getApplicationContext ( ) ) ; CurrentWeatherData currentWeather = database . getCurrentWeatherByCityId ( pagerAdapter . getCityIDForPos ( position ) ) ; long timestamp = currentWeather . getTimestamp ( ) ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) * <NUM_LIT> * <NUM_LIT> ) ; if ( timestamp + updateInterval - systemTime <= <NUM_LIT> ) { if ( pagerAdapter . getCityIDForPos ( position ) != getWidgetCityID ( context ) || locationListenerGPS == null ) { WeatherPagerAdapter . refreshSingleData ( getApplicationContext ( ) , true , pagerAdapter . getCityIDForPos ( position ) ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } viewPager2 . post ( ( ) -> { pagerAdapter . notifyItemChanged ( position ) ; } ) ; cityId = pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ; } } ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; setIntent ( intent ) ; if ( intent . hasExtra ( "<STR_LIT>" ) ) { cityId = intent . getIntExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; if ( pagerAdapter . getItemCount ( ) > <NUM_LIT> ) viewPager2 . setCurrentItem ( pagerAdapter . getPosForCityID ( cityId ) , false ) ; } } private void initResources ( ) { viewPager2 = findViewById ( R . id . viewPager2 ) ; viewPager2 . setUserInputEnabled ( false ) ; tabLayout = findViewById ( R . id . tab_layout ) ; pagerAdapter = new WeatherPagerAdapter ( this , getSupportFragmentManager ( ) , getLifecycle ( ) ) ; noCityText = findViewById ( R . id . noCitySelectedText ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_weather ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . activity_forecast_city , menu ) ; final Menu m = menu ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; updateLocationButton = menu . findItem ( R . id . menu_update_location ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) == TRUE && ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { updateLocationButton . setVisible ( true ) ; updateLocationButton . setActionView ( R . layout . menu_update_location_view ) ; updateLocationButton . getActionView ( ) . clearAnimation ( ) ; if ( locationListenerGPS != null ) { removeLocationListener ( ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { locationListenerGPS = getNewLocationListener ( ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { startUpdateLocatationAnimation ( ) ; } } } updateLocationButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( updateLocationButton . getItemId ( ) , <NUM_LIT> ) ) ; } else { removeLocationListener ( ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { updateLocationButton . getActionView ( ) . clearAnimation ( ) ; } SharedPreferences . Editor editor = prefManager . edit ( ) ; editor . putBoolean ( "<STR_LIT>" , false ) ; editor . apply ( ) ; } refreshActionButton = menu . findItem ( R . id . menu_refresh ) ; refreshActionButton . setActionView ( R . layout . menu_refresh_action_view ) ; refreshActionButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( refreshActionButton . getItemId ( ) , <NUM_LIT> ) ) ; if ( isRefreshing ) startRefreshAnimation ( ) ; rainviewerButton = menu . findItem ( R . id . menu_rainviewer ) ; rainviewerButton . setActionView ( R . layout . menu_rainviewer_view ) ; rainviewerButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( rainviewerButton . getItemId ( ) , <NUM_LIT> ) ) ; return true ; } @ Override public boolean onOptionsItemSelected ( final MenuItem item ) { int id = item . getItemId ( ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( id == R . id . menu_rainviewer ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( ! prefManager . getBoolean ( "<STR_LIT>" , false ) ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; alertDialogBuilder . setMessage ( R . string . nonFreeNet ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivity ( new Intent ( context , SettingsActivity . class ) ) ; } } ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } else { if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { Intent intent = new Intent ( this , RainViewerActivity . class ) ; intent . putExtra ( "<STR_LIT>" , pagerAdapter . getLatForPos ( ( viewPager2 . getCurrentItem ( ) ) ) ) ; intent . putExtra ( "<STR_LIT>" , pagerAdapter . getLonForPos ( ( viewPager2 . getCurrentItem ( ) ) ) ) ; CurrentWeatherData currentWeather = db . getCurrentWeatherByCityId ( pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ) ; intent . putExtra ( "<STR_LIT>" , currentWeather . getTimeZoneSeconds ( ) ) ; startActivity ( intent ) ; } } } else if ( id == R . id . menu_refresh ) { if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { WeatherPagerAdapter . refreshSingleData ( getApplicationContext ( ) , true , pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } else if ( id == R . id . menu_update_location ) { locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( ! locationManager . isProviderEnabled ( LocationManager . GPS_PROVIDER ) ) { Toast . makeText ( this , R . string . error_no_gps , Toast . LENGTH_LONG ) . show ( ) ; } else { if ( db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { CityToWatch newCity = new CityToWatch ( db . getMaxRank ( ) + <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" ) ; cityId = ( int ) db . addCityToWatch ( newCity ) ; initResources ( ) ; noCityText . setVisibility ( View . GONE ) ; viewPager2 . setVisibility ( View . VISIBLE ) ; viewPager2 . setAdapter ( pagerAdapter ) ; TabLayoutMediator tabLayoutMediator = new TabLayoutMediator ( tabLayout , viewPager2 , false , false , ( tab , position ) -> tab . setText ( pagerAdapter . getPageTitle ( position ) ) ) ; tabLayoutMediator . attach ( ) ; } SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( "<STR_LIT>" , true ) == TRUE && ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { if ( locationListenerGPS == null ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; locationListenerGPS = getNewLocationListener ( ) ; ForecastCityActivity . startUpdateLocatationAnimation ( ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } } } return super . onOptionsItemSelected ( item ) ; } @ Override protected void onPostResume ( ) { super . onPostResume ( ) ; } @ Override public void processNewCurrentWeatherData ( CurrentWeatherData data ) { stopRefreshAnimation ( ) ; } @ Override public void processNewWeekForecasts ( List < WeekForecast > forecasts ) { stopRefreshAnimation ( ) ; } @ Override public void processNewForecasts ( List < HourlyForecast > hourlyForecasts ) { stopRefreshAnimation ( ) ; } public static void stopRefreshAnimation ( ) { if ( refreshActionButton != null && refreshActionButton . getActionView ( ) != null ) { refreshActionButton . getActionView ( ) . clearAnimation ( ) ; } isRefreshing = false ; } public static void startRefreshAnimation ( ) { isRefreshing = true ; if ( refreshActionButton != null && refreshActionButton . getActionView ( ) != null ) { RotateAnimation rotate = new RotateAnimation ( <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; rotate . setDuration ( <NUM_LIT> ) ; rotate . setRepeatCount ( <NUM_LIT> ) ; rotate . setInterpolator ( new LinearInterpolator ( ) ) ; rotate . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) { refreshActionButton . getActionView ( ) . setActivated ( false ) ; refreshActionButton . getActionView ( ) . setEnabled ( false ) ; refreshActionButton . getActionView ( ) . setClickable ( false ) ; } @ Override public void onAnimationEnd ( Animation animation ) { refreshActionButton . getActionView ( ) . setActivated ( true ) ; refreshActionButton . getActionView ( ) . setEnabled ( true ) ; refreshActionButton . getActionView ( ) . setClickable ( true ) ; isRefreshing = false ; } @ Override public void onAnimationRepeat ( Animation animation ) { } } ) ; refreshActionButton . getActionView ( ) . startAnimation ( rotate ) ; } } public static void startUpdateLocatationAnimation ( ) { { if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { Animation blink = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; blink . setDuration ( <NUM_LIT> ) ; blink . setRepeatCount ( Animation . INFINITE ) ; blink . setInterpolator ( new LinearInterpolator ( ) ) ; blink . setRepeatMode ( Animation . REVERSE ) ; blink . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) { updateLocationButton . getActionView ( ) . setActivated ( false ) ; updateLocationButton . getActionView ( ) . setEnabled ( false ) ; updateLocationButton . getActionView ( ) . setClickable ( false ) ; } @ Override public void onAnimationEnd ( Animation animation ) { updateLocationButton . getActionView ( ) . setActivated ( true ) ; updateLocationButton . getActionView ( ) . setEnabled ( true ) ; updateLocationButton . getActionView ( ) . setClickable ( true ) ; } @ Override public void onAnimationRepeat ( Animation animation ) { } } ) ; updateLocationButton . getActionView ( ) . startAnimation ( blink ) ; } } } private void reduceViewpager2DragSensitivity ( ViewPager2 viewPager , int sensitivity ) { try { Field ff = ViewPager2 . class . getDeclaredField ( "<STR_LIT>" ) ; ff . setAccessible ( true ) ; RecyclerView recyclerView = ( RecyclerView ) ff . get ( viewPager ) ; Field touchSlopField = RecyclerView . class . getDeclaredField ( "<STR_LIT>" ) ; touchSlopField . setAccessible ( true ) ; int touchSlop = ( int ) touchSlopField . get ( recyclerView ) ; touchSlopField . set ( recyclerView , touchSlop * sensitivity ) ; } catch ( NoSuchFieldException | IllegalAccessException e ) { e . printStackTrace ( ) ; } } private LocationListener getNewLocationListener ( ) { return new LocationListener ( ) { @ Override public void onLocationChanged ( android . location . Location location ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; CityToWatch city = db . getCityToWatch ( getWidgetCityID ( context ) ) ; city . setLatitude ( ( float ) location . getLatitude ( ) ) ; city . setLongitude ( ( float ) location . getLongitude ( ) ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , location . getLatitude ( ) , location . getLongitude ( ) ) ) ; db . updateCityToWatch ( city ) ; db . deleteWeekForecastsByCityId ( getWidgetCityID ( context ) ) ; db . deleteCurrentWeatherByCityId ( getWidgetCityID ( context ) ) ; db . deleteForecastsByCityId ( getWidgetCityID ( context ) ) ; db . deleteQuarterHourlyForecastsByCityId ( getWidgetCityID ( context ) ) ; pagerAdapter . loadCities ( ) ; viewPager2 . setAdapter ( pagerAdapter ) ; tabLayout . getTabAt ( <NUM_LIT> ) . setText ( city . getCityName ( ) ) ; removeLocationListener ( ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { updateLocationButton . getActionView ( ) . clearAnimation ( ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; } private void removeLocationListener ( ) { if ( locationListenerGPS != null ) { locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; } locationListenerGPS = null ; } } </s>
<s> package org . woheller69 . weather . ui . RecycleList ; import androidx . recyclerview . widget . RecyclerView ; import android . view . View ; import android . widget . TextView ; import org . woheller69 . weather . R ; public class ItemViewHolder extends RecyclerView . ViewHolder { private TextView tvInformation ; public ItemViewHolder ( View itemView ) { super ( itemView ) ; tvInformation = ( TextView ) itemView . findViewById ( R . id . city_overview_list_item_text ) ; } public TextView getTvInformation ( ) { return tvInformation ; } } </s>
<s> package org . woheller69 . weather . weather_api . open_meteo ; import android . content . Context ; import androidx . preference . PreferenceManager ; import android . content . SharedPreferences ; import android . text . TextUtils ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . util . ArrayList ; import java . util . List ; public class OMHttpRequest { protected String getUrlForQueryingOMweatherAPI ( Context context , float lat , float lon ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context ) ) ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ) { return String . format ( "<STR_LIT>" , BuildConfig . BASE_URL , lat , lon , sharedPreferences . getInt ( "<STR_LIT>" , <NUM_LIT> ) , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" ) ; } else { return String . format ( "<STR_LIT>" , BuildConfig . BASE_URL , lat , lon , sharedPreferences . getInt ( "<STR_LIT>" , <NUM_LIT> ) , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" , sharedPreferences . getBoolean ( "<STR_LIT>" , false ) ? "<STR_LIT>" : "<STR_LIT>" ) ; } } } </s>
<s> package org . woheller69 . weather . weather_api . open_meteo ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion ; public class OMToDatabaseConversion extends IApiToDatabaseConversion { @ Override public int convertWeatherCategory ( String category ) { int value = Integer . parseInt ( category ) ; if ( value == <NUM_LIT> ) { return WeatherCategories . CLEAR_SKY . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . FEW_CLOUDS . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . MIST . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . LIGHT_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . MODERATE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . HEAVY_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . FREEZING_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SNOW . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . MODERATE_SNOW . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . HEAVY_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . SHOWER_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . SHOWER_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . THUNDERSTORM . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ; } return WeatherCategories . ERROR . getNumVal ( ) ; } } </s>
<s> package org . woheller69 . weather . ui . util ; import android . content . Context ; import android . widget . ArrayAdapter ; import android . widget . Filter ; import android . widget . Filterable ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import org . woheller69 . weather . database . City ; import java . util . ArrayList ; import java . util . List ; public class AutoSuggestAdapter extends ArrayAdapter < String > implements Filterable { private final List < String > mlistData ; private final List < City > mlistCity ; public AutoSuggestAdapter ( @ NonNull Context context , int resource ) { super ( context , resource ) ; mlistData = new ArrayList < > ( ) ; mlistCity = new ArrayList < > ( ) ; } public void setData ( List < String > list , List < City > cityList ) { mlistData . clear ( ) ; mlistCity . clear ( ) ; mlistData . addAll ( list ) ; mlistCity . addAll ( cityList ) ; } @ Override public int getCount ( ) { return mlistData . size ( ) ; } @ Nullable @ Override public String getItem ( int position ) { return mlistData . get ( position ) ; } public City getObject ( int position ) { return mlistCity . get ( position ) ; } @ NonNull @ Override public Filter getFilter ( ) { Filter dataFilter = new Filter ( ) { @ Override protected FilterResults performFiltering ( CharSequence constraint ) { FilterResults filterResults = new FilterResults ( ) ; if ( constraint != null ) { filterResults . values = mlistData ; filterResults . count = mlistData . size ( ) ; } return filterResults ; } @ Override protected void publishResults ( CharSequence constraint , FilterResults results ) { if ( results != null && ( results . count > <NUM_LIT> ) ) { notifyDataSetChanged ( ) ; } else { notifyDataSetInvalidated ( ) ; } } } ; return dataFilter ; } } </s>
<s> package com . appspa . demo ; import android . content . Context ; import androidx . test . InstrumentationRegistry ; import androidx . test . runner . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . assertEquals ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) { Context appContext = InstrumentationRegistry . getTargetContext ( ) ; assertEquals ( "<STR_LIT>" , appContext . getPackageName ( ) ) ; } } </s>
<s> package com . appspa . update . service ; import java . io . File ; public interface OnFileDownloadListener { void onStart ( ) ; void onProgress ( float progress , long total ) ; boolean onCompleted ( File file ) ; void onError ( Throwable throwable ) ; } </s>
<s> package com . appspa . update . widget ; import android . Manifest ; import android . app . Dialog ; import android . content . pm . PackageManager ; import android . content . res . Configuration ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . os . Bundle ; import android . util . DisplayMetrics ; import android . view . Gravity ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . app . ActivityCompat ; import androidx . fragment . app . DialogFragment ; import androidx . fragment . app . FragmentManager ; import com . appspa . update . R ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . _AppSpace ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DialogUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; public class UpdateDialogFragment extends DialogFragment implements View . OnClickListener , IDownloadEventHandler { public final static String KEY_UPDATE_ENTITY = "<STR_LIT>" ; public final static String KEY_UPDATE_PROMPT_ENTITY = "<STR_LIT>" ; public final static int REQUEST_CODE_REQUEST_PERMISSIONS = <NUM_LIT> ; private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private static IPrompterProxy sIPrompterProxy ; private PromptEntity mPromptEntity ; private int mCurrentOrientation ; public static void show ( @ NonNull FragmentManager fragmentManager , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , @ NonNull PromptEntity promptEntity ) { UpdateDialogFragment fragment = new UpdateDialogFragment ( ) ; Bundle args = new Bundle ( ) ; args . putParcelable ( KEY_UPDATE_ENTITY , updateEntity ) ; args . putParcelable ( KEY_UPDATE_PROMPT_ENTITY , promptEntity ) ; fragment . setArguments ( args ) ; setIPrompterProxy ( prompterProxy ) ; fragment . show ( fragmentManager ) ; } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; setStyle ( DialogFragment . STYLE_NO_TITLE , R . style . XUpdate_Fragment_Dialog ) ; mCurrentOrientation = getResources ( ) . getConfiguration ( ) . orientation ; } @ Override public void onStart ( ) { Dialog dialog = getDialog ( ) ; if ( dialog == null ) { return ; } Window window = dialog . getWindow ( ) ; if ( window == null ) { return ; } window . addFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; super . onStart ( ) ; DialogUtils . syncSystemUiVisibility ( getActivity ( ) , window ) ; window . clearFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; initDialog ( ) ; } private void initDialog ( ) { Dialog dialog = getDialog ( ) ; if ( dialog == null ) { return ; } dialog . setCanceledOnTouchOutside ( false ) ; setCancelable ( false ) ; Window window = dialog . getWindow ( ) ; if ( window == null ) { return ; } PromptEntity promptEntity = getPromptEntity ( ) ; window . setGravity ( Gravity . CENTER ) ; WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getResources ( ) . getDisplayMetrics ( ) ; if ( promptEntity . getWidthRatio ( ) > <NUM_LIT> && promptEntity . getWidthRatio ( ) < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * promptEntity . getWidthRatio ( ) ) ; } if ( promptEntity . getHeightRatio ( ) > <NUM_LIT> && promptEntity . getHeightRatio ( ) < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * promptEntity . getHeightRatio ( ) ) ; } window . setAttributes ( lp ) ; } @ Nullable @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { return inflater . inflate ( R . layout . spa_layout_update_prompter , container ) ; } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; initView ( view ) ; initData ( ) ; } private void initView ( View view ) { mIvTop = view . findViewById ( R . id . iv_top ) ; mTvTitle = view . findViewById ( R . id . tv_title ) ; mTvUpdateInfo = view . findViewById ( R . id . tv_update_info ) ; mBtnUpdate = view . findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = view . findViewById ( R . id . btn_background_update ) ; mTvIgnore = view . findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = view . findViewById ( R . id . npb_progress ) ; mLlClose = view . findViewById ( R . id . ll_close ) ; mIvClose = view . findViewById ( R . id . iv_close ) ; } private void initData ( ) { Bundle bundle = getArguments ( ) ; if ( bundle == null ) { return ; } mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } initTheme ( mPromptEntity . getThemeColor ( ) , mPromptEntity . getTopResId ( ) , mPromptEntity . getButtonTextColor ( ) ) ; mUpdateEntity = bundle . getParcelable ( KEY_UPDATE_ENTITY ) ; if ( mUpdateEntity != null ) { initUpdateInfo ( mUpdateEntity ) ; initListeners ( ) ; } } private PromptEntity getPromptEntity ( ) { if ( mPromptEntity == null ) { Bundle bundle = getArguments ( ) ; if ( bundle != null ) { mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; } } if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } return mPromptEntity ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( getContext ( ) , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( getContext ( ) , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; } private void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( getActivity ( ) , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { requestPermissions ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . backgroundDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . iv_close ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . cancelDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( getActivity ( ) , mUpdateEntity . getVersionName ( ) ) ; dismissDialog ( ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == REQUEST_CODE_REQUEST_PERMISSIONS ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { installApp ( ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . DOWNLOAD_PERMISSION_DENIED ) ; dismissDialog ( ) ; } } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismissDialog ( ) ; } else { showInstallButton ( ) ; } } else { if ( sIPrompterProxy != null ) { sIPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { doStart ( ) ; } } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismissDialog ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismissDialog ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } private void dismissDialog ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; dismissAllowingStateLoss ( ) ; } @ Override public void show ( @ NonNull FragmentManager manager , @ Nullable String tag ) { if ( Build . VERSION . SDK_INT > Build . VERSION_CODES . JELLY_BEAN ) { if ( manager . isDestroyed ( ) || manager . isStateSaved ( ) ) { return ; } } try { super . show ( manager , tag ) ; } catch ( Exception e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . PROMPT_UNKNOWN , e . getMessage ( ) ) ; } } public void show ( FragmentManager manager ) { show ( manager , "<STR_LIT>" ) ; } @ Override public void onDestroyView ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; super . onDestroyView ( ) ; } private static void setIPrompterProxy ( IPrompterProxy prompterProxy ) { UpdateDialogFragment . sIPrompterProxy = prompterProxy ; } private static void clearIPrompterProxy ( ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . recycle ( ) ; sIPrompterProxy = null ; } } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; if ( newConfig . orientation != mCurrentOrientation ) { reloadView ( ) ; } mCurrentOrientation = newConfig . orientation ; } private void reloadView ( ) { View view = LayoutInflater . from ( getContext ( ) ) . inflate ( R . layout . spa_layout_update_prompter , null ) ; ViewGroup root = ( ViewGroup ) getView ( ) ; if ( root != null ) { root . removeAllViews ( ) ; root . addView ( view ) ; initView ( root ) ; initData ( ) ; } } private String getUrl ( ) { return sIPrompterProxy != null ? sIPrompterProxy . getUrl ( ) : "<STR_LIT>" ; } } </s>
<s> package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . service . DownloadService ; import com . appspa . update . utils . UpdateUtils ; import java . util . Map ; public class DefaultUpdateChecker implements IUpdateChecker { @ Override public void onBeforeCheck ( ) { } @ Override public void checkVersion ( boolean isGet , @ NonNull final String url , @ NonNull Map < String , Object > params , final @ NonNull IUpdateProxy updateProxy ) { if ( DownloadService . isRunning ( ) || _AppSpace . getCheckUrlStatus ( url ) || _AppSpace . isPrompterShow ( url ) ) { updateProxy . onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_UPDATING ) ; return ; } _AppSpace . setCheckUrlStatus ( url , true ) ; if ( isGet ) { updateProxy . getIUpdateHttpService ( ) . asyncGet ( url , params , new IUpdateHttpService . Callback ( ) { @ Override public void onSuccess ( String result ) { onCheckSuccess ( url , result , updateProxy ) ; } @ Override public void onError ( Throwable error ) { onCheckError ( url , updateProxy , error ) ; } } ) ; } else { updateProxy . getIUpdateHttpService ( ) . asyncPost ( url , params , new IUpdateHttpService . Callback ( ) { @ Override public void onSuccess ( String result ) { onCheckSuccess ( url , result , updateProxy ) ; } @ Override public void onError ( Throwable error ) { onCheckError ( url , updateProxy , error ) ; } } ) ; } } @ Override public void onAfterCheck ( ) { } private void onCheckSuccess ( String url , String result , @ NonNull IUpdateProxy updateProxy ) { _AppSpace . setCheckUrlStatus ( url , false ) ; updateProxy . onAfterCheck ( ) ; if ( ! TextUtils . isEmpty ( result ) ) { processCheckResult ( result , updateProxy ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_JSON_EMPTY ) ; } } private void onCheckError ( String url , @ NonNull IUpdateProxy updateProxy , Throwable error ) { _AppSpace . setCheckUrlStatus ( url , false ) ; updateProxy . onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NET_REQUEST , error . getMessage ( ) ) ; } @ Override public void processCheckResult ( final @ NonNull String result , final @ NonNull IUpdateProxy updateProxy ) { try { if ( updateProxy . isAsyncParser ( ) ) { updateProxy . parseJson ( result , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { try { UpdateUtils . processUpdateEntity ( updateEntity , result , updateProxy ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , e . getMessage ( ) ) ; } } } ) ; } else { UpdateUtils . processUpdateEntity ( updateProxy . parseJson ( result ) , result , updateProxy ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , e . getMessage ( ) ) ; } } @ Override public void noNewVersion ( Throwable throwable ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_NEW_VERSION , throwable != null ? throwable . getMessage ( ) : null ) ; } } </s>
<s> package com . appspa . demo . activity ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . View ; import android . widget . EditText ; import com . appspa . demo . Constants ; import com . appspa . demo . R ; import com . appspa . demo . custom . CustomUpdateParser ; import com . appspa . demo . utils . NotifyUtils ; import com . appspa . demo . utils . SettingSPUtils ; import com . appspa . update . AppSpace ; import java . util . List ; import okhttp3 . HttpUrl ; public class MainActivity extends Activity implements View . OnClickListener { private EditText mEtServiceUrl ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; if ( ! NotifyUtils . isNotifyPermissionOpen ( this ) ) { new AlertDialog . Builder ( this ) . setCancelable ( false ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface d , int w ) { NotifyUtils . openNotifyPermissionSetting ( MainActivity . this ) ; } } ) . setNegativeButton ( "<STR_LIT>" , null ) . show ( ) ; } initView ( ) ; } void initView ( ) { mEtServiceUrl = findViewById ( R . id . et_service_url ) ; mEtServiceUrl . setText ( Constants . CUSTOM_UPDATE_URL ) ; } @ Override public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . btn_save : String url = mEtServiceUrl . getText ( ) . toString ( ) . trim ( ) ; if ( parseBaseUrl ( url ) ) { SettingSPUtils . get ( ) . setServiceURL ( url ) ; } break ; case R . id . btn_update : AppSpace . newBuild ( this ) . updateUrl ( Constants . CUSTOM_UPDATE_URL ) . updateParser ( new CustomUpdateParser ( ) ) . update ( ) ; break ; case R . id . btn_auto_update : AppSpace . newBuild ( this ) . isGet ( false ) . isAutoMode ( true ) . update ( ) ; break ; case R . id . btn_force_update : AppSpace . newBuild ( this ) . isGet ( false ) . param ( "<STR_LIT>" , "<STR_LIT>" ) . update ( ) ; break ; default : break ; } } public static boolean parseBaseUrl ( String baseUrl ) { if ( ! TextUtils . isEmpty ( baseUrl ) ) { HttpUrl httpUrl = HttpUrl . parse ( baseUrl ) ; if ( httpUrl != null ) { List < String > pathSegments = httpUrl . pathSegments ( ) ; return "<STR_LIT>" . equals ( pathSegments . get ( pathSegments . size ( ) - <NUM_LIT> ) ) ; } } return false ; } } </s>
<s> package com . appspa . demo . utils ; import android . app . NotificationManager ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . provider . Settings ; import androidx . core . app . NotificationManagerCompat ; public final class NotifyUtils { private NotifyUtils ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static boolean isNotifyPermissionOpen ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { return NotificationManagerCompat . from ( context ) . getImportance ( ) != NotificationManager . IMPORTANCE_NONE ; } return NotificationManagerCompat . from ( context ) . areNotificationsEnabled ( ) ; } public static void openNotifyPermissionSetting ( Context context ) { try { Intent intent = new Intent ( ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { intent . setAction ( Settings . ACTION_APP_NOTIFICATION_SETTINGS ) ; intent . putExtra ( Settings . EXTRA_APP_PACKAGE , context . getPackageName ( ) ) ; intent . putExtra ( Settings . EXTRA_CHANNEL_ID , context . getApplicationInfo ( ) . uid ) ; context . startActivity ( intent ) ; return ; } if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { intent . setAction ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , context . getPackageName ( ) ) ; intent . putExtra ( "<STR_LIT>" , context . getApplicationInfo ( ) . uid ) ; context . startActivity ( intent ) ; return ; } if ( android . os . Build . VERSION . SDK_INT == Build . VERSION_CODES . KITKAT ) { intent . setAction ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS ) ; intent . addCategory ( Intent . CATEGORY_DEFAULT ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + context . getPackageName ( ) ) ) ; context . startActivity ( intent ) ; return ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { intent . setAction ( "<STR_LIT>" ) ; intent . setData ( Uri . fromParts ( "<STR_LIT>" , context . getPackageName ( ) , null ) ) ; context . startActivity ( intent ) ; return ; } intent . setAction ( Intent . ACTION_VIEW ) ; intent . setClassName ( "<STR_LIT>" , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , context . getPackageName ( ) ) ; context . startActivity ( intent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } </s>
<s> package com . appspa . demo ; public final class Constants { public static final String DEFAULT_UPDATE_URL = "<STR_LIT>" ; public static final String FORCED_UPDATE_URL = "<STR_LIT>" ; public static final String CUSTOM_UPDATE_URL = "<STR_LIT>" ; public static final String IGNORE_UPDATE_URL = "<STR_LIT>" ; public static final String XUPDATE_DEMO_DOWNLOAD_URL = "<STR_LIT>" ; } </s>
<s> package com . appspa . update . proxy . impl ; import android . content . ComponentName ; import android . content . Intent ; import android . content . ServiceConnection ; import android . net . Uri ; import android . os . IBinder ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . service . DownloadService ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . utils . UpdateUtils ; public class DefaultUpdateDownloader implements IUpdateDownloader { private DownloadService . DownloadBinder mDownloadBinder ; private ServiceConnection mServiceConnection ; private boolean mIsBound ; @ Override public void startDownload ( final @ NonNull UpdateEntity updateEntity , final @ Nullable OnFileDownloadListener downloadListener ) { if ( isDownloadUrl ( updateEntity ) ) { startDownloadService ( updateEntity , downloadListener ) ; } else { startOpenHtml ( updateEntity , downloadListener ) ; } } protected boolean isDownloadUrl ( @ NonNull UpdateEntity updateEntity ) { return ! isStaticHtmlUrl ( updateEntity ) ; } protected boolean isStaticHtmlUrl ( @ NonNull UpdateEntity updateEntity ) { String downloadUrl = updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ; if ( TextUtils . isEmpty ( downloadUrl ) ) { return false ; } String urlContent = downloadUrl . substring ( downloadUrl . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; return urlContent . contains ( "<STR_LIT>" ) || urlContent . contains ( "<STR_LIT>" ) ; } protected void startDownloadService ( @ NonNull final UpdateEntity updateEntity , @ Nullable final OnFileDownloadListener downloadListener ) { DownloadService . bindService ( mServiceConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mIsBound = true ; startDownload ( ( DownloadService . DownloadBinder ) service , updateEntity , downloadListener ) ; } @ Override public void onServiceDisconnected ( ComponentName name ) { mIsBound = false ; } } ) ; } protected void startOpenHtml ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ) ) ; boolean result = UpdateUtils . startActivity ( intent ) ; if ( downloadListener != null ) { if ( result ) { if ( ! updateEntity . isForce ( ) ) { downloadListener . onCompleted ( null ) ; } } else { downloadListener . onError ( null ) ; } } } private void startDownload ( DownloadService . DownloadBinder binder , @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { mDownloadBinder = binder ; mDownloadBinder . start ( updateEntity , downloadListener ) ; } @ Override public void cancelDownload ( ) { if ( mDownloadBinder != null ) { mDownloadBinder . stop ( "<STR_LIT>" ) ; } if ( mIsBound && mServiceConnection != null ) { AppSpace . getContext ( ) . unbindService ( mServiceConnection ) ; mIsBound = false ; } } @ Override public void backgroundDownload ( ) { if ( mDownloadBinder != null ) { mDownloadBinder . showNotification ( ) ; } } } </s>
<s> package com . appspa . update . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . RectF ; import android . os . Bundle ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . view . View ; import com . appspa . update . R ; public class NumberProgressBar extends View { private static final String INSTANCE_STATE = "<STR_LIT>" ; private static final String INSTANCE_TEXT_COLOR = "<STR_LIT>" ; private static final String INSTANCE_TEXT_SIZE = "<STR_LIT>" ; private static final String INSTANCE_REACHED_BAR_HEIGHT = "<STR_LIT>" ; private static final String INSTANCE_REACHED_BAR_COLOR = "<STR_LIT>" ; private static final String INSTANCE_UNREACHED_BAR_HEIGHT = "<STR_LIT>" ; private static final String INSTANCE_UNREACHED_BAR_COLOR = "<STR_LIT>" ; private static final String INSTANCE_MAX = "<STR_LIT>" ; private static final String INSTANCE_PROGRESS = "<STR_LIT>" ; private static final String INSTANCE_SUFFIX = "<STR_LIT>" ; private static final String INSTANCE_PREFIX = "<STR_LIT>" ; private static final String INSTANCE_TEXT_VISIBILITY = "<STR_LIT>" ; private static final int PROGRESS_TEXT_VISIBLE = <NUM_LIT> ; private int mMaxProgress = <NUM_LIT> ; private int mCurrentProgress = <NUM_LIT> ; private int mReachedBarColor ; private int mUnreachedBarColor ; private int mTextColor ; private float mTextSize ; private float mReachedBarHeight ; private float mUnreachedBarHeight ; private String mSuffix = "<STR_LIT>" ; private String mPrefix = "<STR_LIT>" ; private float mDrawTextStart ; private float mDrawTextEnd ; private String mCurrentDrawText ; private Paint mReachedBarPaint ; private Paint mUnreachedBarPaint ; private Paint mTextPaint ; private RectF mUnreachedRectF = new RectF ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private RectF mReachedRectF = new RectF ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private float mOffset ; private boolean mDrawUnreachedBar = true ; private boolean mDrawReachedBar = true ; private boolean mIfDrawText = true ; private OnProgressBarListener mListener ; public NumberProgressBar ( Context context ) { this ( context , null ) ; } public NumberProgressBar ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public NumberProgressBar ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; float defaultReachedBarHeight = dp2px ( <NUM_LIT> ) ; float defaultUnreachedBarHeight = dp2px ( <NUM_LIT> ) ; float defaultTextSize = sp2px ( <NUM_LIT> ) ; float defaultProgressTextOffset = dp2px ( <NUM_LIT> ) ; final TypedArray attributes = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . XNumberProgressBar , defStyleAttr , <NUM_LIT> ) ; int defaultReachedColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mReachedBarColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_reached_color , defaultReachedColor ) ; int defaultUnreachedColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mUnreachedBarColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_unreached_color , defaultUnreachedColor ) ; int defaultTextColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mTextColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_text_color , defaultTextColor ) ; mTextSize = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_text_size , defaultTextSize ) ; mReachedBarHeight = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_reached_bar_height , defaultReachedBarHeight ) ; mUnreachedBarHeight = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_unreached_bar_height , defaultUnreachedBarHeight ) ; mOffset = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_text_offset , defaultProgressTextOffset ) ; int textVisible = attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_text_visibility , PROGRESS_TEXT_VISIBLE ) ; if ( textVisible != PROGRESS_TEXT_VISIBLE ) { mIfDrawText = false ; } setProgress ( attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_current , <NUM_LIT> ) ) ; setMax ( attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_max , <NUM_LIT> ) ) ; attributes . recycle ( ) ; initializePainters ( ) ; } @ Override protected int getSuggestedMinimumWidth ( ) { return ( int ) mTextSize ; } @ Override protected int getSuggestedMinimumHeight ( ) { return Math . max ( ( int ) mTextSize , Math . max ( ( int ) mReachedBarHeight , ( int ) mUnreachedBarHeight ) ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( measure ( widthMeasureSpec , true ) , measure ( heightMeasureSpec , false ) ) ; } private int measure ( int measureSpec , boolean isWidth ) { int result ; int mode = MeasureSpec . getMode ( measureSpec ) ; int size = MeasureSpec . getSize ( measureSpec ) ; int padding = isWidth ? getPaddingLeft ( ) + getPaddingRight ( ) : getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mode == MeasureSpec . EXACTLY ) { result = size ; } else { result = isWidth ? getSuggestedMinimumWidth ( ) : getSuggestedMinimumHeight ( ) ; result += padding ; if ( mode == MeasureSpec . AT_MOST ) { if ( isWidth ) { result = Math . max ( result , size ) ; } else { result = Math . min ( result , size ) ; } } } return result ; } @ Override protected void onDraw ( Canvas canvas ) { if ( mIfDrawText ) { calculateDrawRectF ( ) ; } else { calculateDrawRectFWithoutProgressText ( ) ; } if ( mDrawReachedBar ) { canvas . drawRect ( mReachedRectF , mReachedBarPaint ) ; } if ( mDrawUnreachedBar ) { canvas . drawRect ( mUnreachedRectF , mUnreachedBarPaint ) ; } if ( mIfDrawText ) { canvas . drawText ( mCurrentDrawText , mDrawTextStart , mDrawTextEnd , mTextPaint ) ; } } private void initializePainters ( ) { mReachedBarPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mReachedBarPaint . setColor ( mReachedBarColor ) ; mUnreachedBarPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mUnreachedBarPaint . setColor ( mUnreachedBarColor ) ; mTextPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mTextPaint . setColor ( mTextColor ) ; mTextPaint . setTextSize ( mTextSize ) ; } private void calculateDrawRectFWithoutProgressText ( ) { mReachedRectF . left = getPaddingLeft ( ) ; mReachedRectF . top = getHeight ( ) / <NUM_LIT> - mReachedBarHeight / <NUM_LIT> ; mReachedRectF . right = ( getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ) / ( getMax ( ) * <NUM_LIT> ) * getProgress ( ) + getPaddingLeft ( ) ; mReachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mReachedBarHeight / <NUM_LIT> ; mUnreachedRectF . left = mReachedRectF . right ; mUnreachedRectF . right = getWidth ( ) - getPaddingRight ( ) ; mUnreachedRectF . top = getHeight ( ) / <NUM_LIT> + - mUnreachedBarHeight / <NUM_LIT> ; mUnreachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mUnreachedBarHeight / <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) private void calculateDrawRectF ( ) { mCurrentDrawText = String . format ( "<STR_LIT>" , getProgress ( ) * <NUM_LIT> / getMax ( ) ) ; mCurrentDrawText = mPrefix + mCurrentDrawText + mSuffix ; float drawTextWidth = mTextPaint . measureText ( mCurrentDrawText ) ; if ( getProgress ( ) == <NUM_LIT> ) { mDrawReachedBar = false ; mDrawTextStart = getPaddingLeft ( ) ; } else { mDrawReachedBar = true ; mReachedRectF . left = getPaddingLeft ( ) ; mReachedRectF . top = getHeight ( ) / <NUM_LIT> - mReachedBarHeight / <NUM_LIT> ; mReachedRectF . right = ( getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ) / ( getMax ( ) * <NUM_LIT> ) * getProgress ( ) - mOffset + getPaddingLeft ( ) ; mReachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mReachedBarHeight / <NUM_LIT> ; mDrawTextStart = ( mReachedRectF . right + mOffset ) ; } mDrawTextEnd = ( int ) ( ( getHeight ( ) / <NUM_LIT> ) - ( ( mTextPaint . descent ( ) + mTextPaint . ascent ( ) ) / <NUM_LIT> ) ) ; if ( ( mDrawTextStart + drawTextWidth ) >= getWidth ( ) - getPaddingRight ( ) ) { mDrawTextStart = getWidth ( ) - getPaddingRight ( ) - drawTextWidth ; mReachedRectF . right = mDrawTextStart - mOffset ; } float unreachedBarStart = mDrawTextStart + drawTextWidth + mOffset ; if ( unreachedBarStart >= getWidth ( ) - getPaddingRight ( ) ) { mDrawUnreachedBar = false ; } else { mDrawUnreachedBar = true ; mUnreachedRectF . left = unreachedBarStart ; mUnreachedRectF . right = getWidth ( ) - getPaddingRight ( ) ; mUnreachedRectF . top = getHeight ( ) / <NUM_LIT> + - mUnreachedBarHeight / <NUM_LIT> ; mUnreachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mUnreachedBarHeight / <NUM_LIT> ; } } public int getTextColor ( ) { return mTextColor ; } public float getProgressTextSize ( ) { return mTextSize ; } public void setProgressTextSize ( float textSize ) { mTextSize = textSize ; mTextPaint . setTextSize ( mTextSize ) ; postInvalidate ( ) ; } public int getUnreachedBarColor ( ) { return mUnreachedBarColor ; } public void setUnreachedBarColor ( int barColor ) { mUnreachedBarColor = barColor ; mUnreachedBarPaint . setColor ( mUnreachedBarColor ) ; postInvalidate ( ) ; } public int getReachedBarColor ( ) { return mReachedBarColor ; } public void setReachedBarColor ( int progressColor ) { mReachedBarColor = progressColor ; mReachedBarPaint . setColor ( mReachedBarColor ) ; postInvalidate ( ) ; } public int getProgress ( ) { return mCurrentProgress ; } public void setProgress ( int progress ) { if ( progress <= getMax ( ) && progress >= <NUM_LIT> ) { mCurrentProgress = progress ; postInvalidate ( ) ; } } public int getMax ( ) { return mMaxProgress ; } public void setMax ( int maxProgress ) { if ( maxProgress > <NUM_LIT> ) { mMaxProgress = maxProgress ; postInvalidate ( ) ; } } public float getReachedBarHeight ( ) { return mReachedBarHeight ; } public void setReachedBarHeight ( float height ) { mReachedBarHeight = height ; } public float getUnreachedBarHeight ( ) { return mUnreachedBarHeight ; } public void setUnreachedBarHeight ( float height ) { mUnreachedBarHeight = height ; } public void setProgressTextColor ( int textColor ) { this . mTextColor = textColor ; mTextPaint . setColor ( mTextColor ) ; postInvalidate ( ) ; } public String getSuffix ( ) { return mSuffix ; } public void setSuffix ( String suffix ) { if ( suffix == null ) { mSuffix = "<STR_LIT>" ; } else { mSuffix = suffix ; } } public String getPrefix ( ) { return mPrefix ; } public void setPrefix ( String prefix ) { if ( prefix == null ) { mPrefix = "<STR_LIT>" ; } else { mPrefix = prefix ; } } public void incrementProgressBy ( int by ) { if ( by > <NUM_LIT> ) { setProgress ( getProgress ( ) + by ) ; } if ( mListener != null ) { mListener . onProgressChange ( getProgress ( ) , getMax ( ) ) ; } } @ Override protected Parcelable onSaveInstanceState ( ) { final Bundle bundle = new Bundle ( ) ; bundle . putParcelable ( INSTANCE_STATE , super . onSaveInstanceState ( ) ) ; bundle . putInt ( INSTANCE_TEXT_COLOR , getTextColor ( ) ) ; bundle . putFloat ( INSTANCE_TEXT_SIZE , getProgressTextSize ( ) ) ; bundle . putFloat ( INSTANCE_REACHED_BAR_HEIGHT , getReachedBarHeight ( ) ) ; bundle . putFloat ( INSTANCE_UNREACHED_BAR_HEIGHT , getUnreachedBarHeight ( ) ) ; bundle . putInt ( INSTANCE_REACHED_BAR_COLOR , getReachedBarColor ( ) ) ; bundle . putInt ( INSTANCE_UNREACHED_BAR_COLOR , getUnreachedBarColor ( ) ) ; bundle . putInt ( INSTANCE_MAX , getMax ( ) ) ; bundle . putInt ( INSTANCE_PROGRESS , getProgress ( ) ) ; bundle . putString ( INSTANCE_SUFFIX , getSuffix ( ) ) ; bundle . putString ( INSTANCE_PREFIX , getPrefix ( ) ) ; bundle . putBoolean ( INSTANCE_TEXT_VISIBILITY , getProgressTextVisibility ( ) ) ; return bundle ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof Bundle ) { final Bundle bundle = ( Bundle ) state ; mTextColor = bundle . getInt ( INSTANCE_TEXT_COLOR ) ; mTextSize = bundle . getFloat ( INSTANCE_TEXT_SIZE ) ; mReachedBarHeight = bundle . getFloat ( INSTANCE_REACHED_BAR_HEIGHT ) ; mUnreachedBarHeight = bundle . getFloat ( INSTANCE_UNREACHED_BAR_HEIGHT ) ; mReachedBarColor = bundle . getInt ( INSTANCE_REACHED_BAR_COLOR ) ; mUnreachedBarColor = bundle . getInt ( INSTANCE_UNREACHED_BAR_COLOR ) ; initializePainters ( ) ; setMax ( bundle . getInt ( INSTANCE_MAX ) ) ; setProgress ( bundle . getInt ( INSTANCE_PROGRESS ) ) ; setPrefix ( bundle . getString ( INSTANCE_PREFIX ) ) ; setSuffix ( bundle . getString ( INSTANCE_SUFFIX ) ) ; setProgressTextVisibility ( bundle . getBoolean ( INSTANCE_TEXT_VISIBILITY ) ? ProgressTextVisibility . VISIBLE : ProgressTextVisibility . INVISIBLE ) ; super . onRestoreInstanceState ( bundle . getParcelable ( INSTANCE_STATE ) ) ; return ; } super . onRestoreInstanceState ( state ) ; } public float dp2px ( float dp ) { final float scale = getResources ( ) . getDisplayMetrics ( ) . density ; return dp * scale + <NUM_LIT> ; } public float sp2px ( float sp ) { final float scale = getResources ( ) . getDisplayMetrics ( ) . scaledDensity ; return sp * scale ; } public boolean getProgressTextVisibility ( ) { return mIfDrawText ; } public void setProgressTextVisibility ( ProgressTextVisibility visibility ) { mIfDrawText = visibility == ProgressTextVisibility . VISIBLE ; postInvalidate ( ) ; } public void setOnProgressBarListener ( OnProgressBarListener listener ) { mListener = listener ; } public enum ProgressTextVisibility { VISIBLE , INVISIBLE } public interface OnProgressBarListener { void onProgressChange ( int current , int max ) ; } } </s>
<s> package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . utils . UpdateUtils ; import org . json . JSONException ; import org . json . JSONObject ; public class DefaultUpdateParser extends AbstractUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { if ( ! TextUtils . isEmpty ( json ) ) { JSONObject jsonObject = new JSONObject ( json ) ; if ( jsonObject . has ( APIKeyUpper . CODE ) ) { return parseDefaultUpperFormatJson ( jsonObject ) ; } else { return parseDefaultLowerFormatJson ( jsonObject ) ; } } return null ; } private UpdateEntity parseDefaultUpperFormatJson ( JSONObject jsonObject ) throws JSONException { int code = jsonObject . getInt ( APIKeyUpper . CODE ) ; if ( code == APIConstant . REQUEST_SUCCESS ) { int versionCode = jsonObject . getInt ( APIKeyUpper . VERSION_CODE ) ; String versionName = jsonObject . optString ( APIKeyUpper . VERSION_NAME ) ; int updateStatus = checkUpdateStatus ( jsonObject . getInt ( APIKeyUpper . UPDATE_STATUS ) , versionCode , versionName ) ; UpdateEntity updateEntity = new UpdateEntity ( ) ; if ( updateStatus == APIConstant . NO_NEW_VERSION ) { updateEntity . setHasUpdate ( false ) ; } else { if ( updateStatus == APIConstant . HAVE_NEW_VERSION_FORCED_UPDATE ) { updateEntity . setForce ( true ) ; } else if ( updateStatus == APIConstant . HAVE_NEW_VERSION_IGNORE_UPDATE ) { updateEntity . setIsIgnorable ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setWholeMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setSize ( jsonObject . optLong ( APIKeyUpper . APK_MD5 ) ) ; downloadEntity . setDownloadUrl ( jsonObject . optString ( APIKeyUpper . DOWNLOAD_URL ) ) ; updateEntity . setHasUpdate ( true ) . setUpdateContent ( jsonObject . getString ( APIKeyUpper . MODIFY_CONTENT ) ) . setVersionCode ( versionCode ) . setVersionName ( versionName ) . setDownLoadEntity ( downloadEntity ) ; } return updateEntity ; } return null ; } private UpdateEntity parseDefaultLowerFormatJson ( JSONObject jsonObject ) throws JSONException { int code = jsonObject . getInt ( APIKeyLower . CODE ) ; if ( code == APIConstant . REQUEST_SUCCESS ) { int versionCode = jsonObject . getInt ( APIKeyLower . VERSION_CODE ) ; String versionName = jsonObject . optString ( APIKeyLower . VERSION_NAME ) ; int updateStatus = checkUpdateStatus ( jsonObject . getInt ( APIKeyLower . UPDATE_STATUS ) , versionCode , versionName ) ; UpdateEntity updateEntity = new UpdateEntity ( ) ; if ( updateStatus == APIConstant . NO_NEW_VERSION ) { updateEntity . setHasUpdate ( false ) ; } else { if ( updateStatus == APIConstant . HAVE_NEW_VERSION_FORCED_UPDATE ) { updateEntity . setForce ( true ) ; } else if ( updateStatus == APIConstant . HAVE_NEW_VERSION_IGNORE_UPDATE ) { updateEntity . setIsIgnorable ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setWholeMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setSize ( jsonObject . optLong ( APIKeyUpper . APK_MD5 ) ) ; downloadEntity . setDownloadUrl ( jsonObject . optString ( APIKeyUpper . DOWNLOAD_URL ) ) ; updateEntity . setHasUpdate ( true ) . setUpdateContent ( jsonObject . getString ( APIKeyLower . MODIFY_CONTENT ) ) . setVersionCode ( versionCode ) . setVersionName ( versionName ) . setDownLoadEntity ( downloadEntity ) ; } return updateEntity ; } return null ; } protected int checkUpdateStatus ( int updateStatus , int cloudVersionCode , String cloudVersionName ) { if ( updateStatus == APIConstant . NO_NEW_VERSION ) { return updateStatus ; } int localVersionCode = UpdateUtils . getVersionCode ( AppSpace . getContext ( ) ) ; if ( cloudVersionCode <= localVersionCode ) { UpdateLog . i ( "<STR_LIT>" + localVersionCode + "<STR_LIT>" + cloudVersionCode ) ; updateStatus = APIConstant . NO_NEW_VERSION ; } return updateStatus ; } public interface APIKeyUpper { String CODE = "<STR_LIT>" ; String UPDATE_STATUS = "<STR_LIT>" ; String VERSION_CODE = "<STR_LIT>" ; String MODIFY_CONTENT = "<STR_LIT>" ; String VERSION_NAME = "<STR_LIT>" ; String DOWNLOAD_URL = "<STR_LIT>" ; String APK_SIZE = "<STR_LIT>" ; String APK_MD5 = "<STR_LIT>" ; } public interface APIKeyLower { String CODE = "<STR_LIT>" ; String UPDATE_STATUS = "<STR_LIT>" ; String VERSION_CODE = "<STR_LIT>" ; String MODIFY_CONTENT = "<STR_LIT>" ; String VERSION_NAME = "<STR_LIT>" ; String DOWNLOAD_URL = "<STR_LIT>" ; String APK_SIZE = "<STR_LIT>" ; String APK_MD5 = "<STR_LIT>" ; } public interface APIConstant { int REQUEST_SUCCESS = <NUM_LIT> ; int NO_NEW_VERSION = <NUM_LIT> ; int HAVE_NEW_VERSION = <NUM_LIT> ; int HAVE_NEW_VERSION_FORCED_UPDATE = <NUM_LIT> ; int HAVE_NEW_VERSION_IGNORE_UPDATE = <NUM_LIT> ; } } </s>
<s> package com . appspa . update ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . os . Handler ; import android . os . Looper ; import android . text . TextUtils ; import android . util . LruCache ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . impl . DefaultFileEncryptor ; import com . appspa . update . utils . ApkUtils ; import com . appspa . update . listener . impl . DefaultInstallListener ; import com . appspa . update . listener . impl . DefaultUpdateFailureListener ; import com . appspa . update . utils . PatchUtils ; import java . io . File ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; public final class _AppSpace { private static final Map < String , Boolean > sCheckMap = new ConcurrentHashMap < > ( ) ; private static final Map < String , Boolean > sPrompterMap = new ConcurrentHashMap < > ( ) ; private static final Map < String , Runnable > sWaitRunnableMap = new ConcurrentHashMap < > ( ) ; private static final LruCache < String , Drawable > sTopDrawableCache = new LruCache < > ( <NUM_LIT> ) ; private static final Handler sMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; private static final long CHECK_TIMEOUT = <NUM_LIT> * <NUM_LIT> ; public static void setCheckUrlStatus ( final String url , boolean isChecking ) { if ( TextUtils . isEmpty ( url ) ) { return ; } sCheckMap . put ( url , isChecking ) ; Runnable waitRunnable = sWaitRunnableMap . get ( url ) ; if ( waitRunnable != null ) { sMainHandler . removeCallbacks ( waitRunnable ) ; sWaitRunnableMap . remove ( url ) ; } if ( isChecking ) { Runnable newRunnable = new Runnable ( ) { @ Override public void run ( ) { sWaitRunnableMap . remove ( url ) ; sCheckMap . put ( url , false ) ; } } ; sMainHandler . postDelayed ( newRunnable , CHECK_TIMEOUT ) ; sWaitRunnableMap . put ( url , newRunnable ) ; } } public static boolean getCheckUrlStatus ( String url ) { Boolean checkStatus = sCheckMap . get ( url ) ; return checkStatus != null && checkStatus ; } public static void setIsPrompterShow ( String url , boolean isShow ) { if ( TextUtils . isEmpty ( url ) ) { return ; } sPrompterMap . put ( url , isShow ) ; } public static boolean isPrompterShow ( String url ) { Boolean isShow = sPrompterMap . get ( url ) ; return isShow != null && isShow ; } public static String saveTopDrawable ( Drawable drawable ) { String tag = UUID . randomUUID ( ) . toString ( ) ; sTopDrawableCache . put ( tag , drawable ) ; return tag ; } public static Drawable getTopDrawable ( String drawableTag ) { if ( TextUtils . isEmpty ( drawableTag ) ) { return null ; } return sTopDrawableCache . get ( drawableTag ) ; } public static Map < String , Object > getParams ( ) { return AppSpace . get ( ) . mParams ; } public static IUpdateHttpService getIUpdateHttpService ( ) { return AppSpace . get ( ) . mUpdateHttpService ; } public static IUpdateChecker getIUpdateChecker ( ) { return AppSpace . get ( ) . mUpdateChecker ; } public static IUpdateParser getIUpdateParser ( ) { return AppSpace . get ( ) . mUpdateParser ; } public static IUpdatePrompter getIUpdatePrompter ( ) { return AppSpace . get ( ) . mUpdatePrompter ; } public static IUpdateDownloader getIUpdateDownLoader ( ) { return AppSpace . get ( ) . mUpdateDownloader ; } public static boolean isGet ( ) { return AppSpace . get ( ) . mIsGet ; } public static boolean isWifiOnly ( ) { return AppSpace . get ( ) . mIsWifiOnly ; } public static boolean isAutoMode ( ) { return AppSpace . get ( ) . mIsAutoMode ; } public static String getApkCacheDir ( ) { return AppSpace . get ( ) . mApkCacheDir ; } public static String encryptFile ( File file ) { if ( AppSpace . get ( ) . mFileEncryptor == null ) { AppSpace . get ( ) . mFileEncryptor = new DefaultFileEncryptor ( ) ; } return AppSpace . get ( ) . mFileEncryptor . encryptFile ( file ) ; } public static boolean isFileValid ( String encrypt , File file ) { if ( AppSpace . get ( ) . mFileEncryptor == null ) { AppSpace . get ( ) . mFileEncryptor = new DefaultFileEncryptor ( ) ; } return AppSpace . get ( ) . mFileEncryptor . isFileValid ( encrypt , file ) ; } public static OnInstallListener getOnInstallListener ( ) { return AppSpace . get ( ) . mOnInstallListener ; } public static void startInstallApk ( @ NonNull Context context , @ NonNull File apkFile ) { startInstallApk ( context , apkFile , new DownloadEntity ( ) ) ; } public static void startInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) { UpdateLog . d ( "<STR_LIT>" + apkFile . getAbsolutePath ( ) + "<STR_LIT>" + downloadEntity ) ; if ( onInstallApk ( context , apkFile , downloadEntity ) ) { onApkInstallSuccess ( ) ; } else { onUpdateError ( UpdateError . ERROR . INSTALL_FAILED ) ; } } private static boolean onInstallApk ( Context context , File apkFile , DownloadEntity downloadEntity ) { if ( AppSpace . get ( ) . mOnInstallListener == null ) { AppSpace . get ( ) . mOnInstallListener = new DefaultInstallListener ( ) ; } return AppSpace . get ( ) . mOnInstallListener . onInstallApk ( context , apkFile , downloadEntity ) ; } private static void onApkInstallSuccess ( ) { if ( AppSpace . get ( ) . mOnInstallListener == null ) { AppSpace . get ( ) . mOnInstallListener = new DefaultInstallListener ( ) ; } AppSpace . get ( ) . mOnInstallListener . onInstallApkSuccess ( ) ; } public static OnUpdateFailureListener getOnUpdateFailureListener ( ) { return AppSpace . get ( ) . mOnUpdateFailureListener ; } public static void onUpdateError ( int errorCode ) { onUpdateError ( new UpdateError ( errorCode ) ) ; } public static void onUpdateError ( int errorCode , String message ) { onUpdateError ( new UpdateError ( errorCode , message ) ) ; } public static void onUpdateError ( @ NonNull UpdateError updateError ) { if ( AppSpace . get ( ) . mOnUpdateFailureListener == null ) { AppSpace . get ( ) . mOnUpdateFailureListener = new DefaultUpdateFailureListener ( ) ; } AppSpace . get ( ) . mOnUpdateFailureListener . onFailure ( updateError ) ; } } </s>
<s> package com . appspa . update . utils ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . StateListDrawable ; import android . os . Build ; import android . view . View ; import android . widget . TextView ; public final class DrawableUtils { private DrawableUtils ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static GradientDrawable getSolidRectDrawable ( int cornerRadius , int solidColor ) { GradientDrawable gradientDrawable = new GradientDrawable ( ) ; gradientDrawable . setCornerRadius ( cornerRadius ) ; gradientDrawable . setColor ( solidColor ) ; gradientDrawable . setGradientType ( GradientDrawable . RADIAL_GRADIENT ) ; return gradientDrawable ; } public static GradientDrawable getStrokeRectDrawable ( int cornerRadius , int solidColor , int strokeColor , int strokeWidth ) { GradientDrawable gradientDrawable = new GradientDrawable ( ) ; gradientDrawable . setStroke ( strokeWidth , strokeColor ) ; gradientDrawable . setColor ( solidColor ) ; gradientDrawable . setCornerRadius ( cornerRadius ) ; gradientDrawable . setGradientType ( GradientDrawable . RADIAL_GRADIENT ) ; return gradientDrawable ; } public static StateListDrawable getStateListDrawable ( Drawable pressedDrawable , Drawable normalDrawable ) { StateListDrawable stateListDrawable = new StateListDrawable ( ) ; stateListDrawable . addState ( new int [ ] { android . R . attr . state_enabled , android . R . attr . state_pressed } , pressedDrawable ) ; stateListDrawable . addState ( new int [ ] { android . R . attr . state_enabled } , normalDrawable ) ; GradientDrawable gray = getSolidRectDrawable ( <NUM_LIT> , Color . GRAY ) ; stateListDrawable . addState ( new int [ ] { } , gray ) ; return stateListDrawable ; } public static StateListDrawable getDrawable ( int cornerRadius , int pressedColor , int normalColor ) { return getStateListDrawable ( getSolidRectDrawable ( cornerRadius , pressedColor ) , getSolidRectDrawable ( cornerRadius , normalColor ) ) ; } public static StateListDrawable getStrokeSolidDrawable ( int cornerRadiusPX , int strokeWidthPX , int subColor , int mainColor ) { return getStateListDrawable ( getSolidRectDrawable ( cornerRadiusPX , subColor ) , getStrokeRectDrawable ( cornerRadiusPX , mainColor , subColor , strokeWidthPX ) ) ; } public static StateListDrawable getSolidStrokeDrawable ( int cornerRadiusPX , int strokeWidthPX , int subColor , int mainColor ) { return getStateListDrawable ( getStrokeRectDrawable ( cornerRadiusPX , subColor , mainColor , strokeWidthPX ) , getSolidRectDrawable ( cornerRadiusPX , mainColor ) ) ; } public static StateListDrawable getDrawable ( int cornerRadius , int normalColor ) { return getDrawable ( cornerRadius , ColorUtils . colorDeep ( normalColor ) , normalColor ) ; } public static StateListDrawable getDrawable ( int cornerRadius ) { return getDrawable ( cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static StateListDrawable getDrawable ( ) { return getDrawable ( <NUM_LIT> ) ; } public static StateListDrawable getRandomColorDrawable ( int cornerRadius ) { return getDrawable ( cornerRadius , ColorUtils . getRandomColor ( ) , ColorUtils . getRandomColor ( ) ) ; } public static StateListDrawable getRandomColorDrawable ( ) { return getRandomColorDrawable ( <NUM_LIT> ) ; } public static StateListDrawable getStrokeRandomColorDrawable ( ) { return getStrokeSolidDrawable ( <NUM_LIT> , <NUM_LIT> , ColorUtils . getRandomColor ( ) , Color . TRANSPARENT ) ; } public static void setTextStrokeTheme ( TextView textView , int strokeWidth , int cornerRadius , int color ) { textView . setBackgroundDrawable ( getStrokeSolidDrawable ( cornerRadius , strokeWidth , color , Color . WHITE ) ) ; textView . setTextColor ( ColorUtils . getColorStateList ( Color . WHITE , color ) ) ; textView . getPaint ( ) . setFlags ( Paint . FAKE_BOLD_TEXT_FLAG ) ; } public static void setTextStrokeTheme ( TextView textView , int strokeWidth , int cornerRadius ) { setTextStrokeTheme ( textView , strokeWidth , cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static void setTextStrokeTheme ( TextView textView ) { setTextStrokeTheme ( textView , <NUM_LIT> , <NUM_LIT> ) ; } public static void setTextStrokeTheme ( TextView textView , int color ) { setTextStrokeTheme ( textView , <NUM_LIT> , <NUM_LIT> , color ) ; } public static void setTextSolidTheme ( TextView textView , int strokeWidth , int cornerRadius , int color ) { textView . setBackgroundDrawable ( getSolidStrokeDrawable ( cornerRadius , strokeWidth , Color . WHITE , color ) ) ; textView . setTextColor ( ColorUtils . getColorStateList ( color , Color . WHITE ) ) ; textView . getPaint ( ) . setFlags ( Paint . FAKE_BOLD_TEXT_FLAG ) ; } public static void setTextSolidTheme ( TextView textView , int strokeWidth , int cornerRadius ) { setTextSolidTheme ( textView , strokeWidth , cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static void setTextSolidTheme ( TextView textView ) { setTextSolidTheme ( textView , <NUM_LIT> , <NUM_LIT> ) ; } public static void setBackgroundCompat ( View view , Drawable d ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN ) { view . setBackgroundDrawable ( d ) ; } else { view . setBackground ( d ) ; } } } </s>
<s> package com . appspa . update . utils ; import java . io . File ; import java . io . InputStream ; import java . security . MessageDigest ; public final class Md5Utils { private Md5Utils ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static String getFileMD5 ( File file ) { if ( ! FileUtils . isFileExists ( file ) ) { return "<STR_LIT>" ; } InputStream fis = null ; try { MessageDigest digest = MessageDigest . getInstance ( "<STR_LIT>" ) ; fis = FileUtils . getFileInputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len ; while ( ( len = fis . read ( buffer ) ) != - <NUM_LIT> ) { digest . update ( buffer , <NUM_LIT> , len ) ; } return bytes2Hex ( digest . digest ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtils . closeIOQuietly ( fis ) ; } return "<STR_LIT>" ; } private static String bytes2Hex ( byte [ ] src ) { char [ ] res = new char [ src . length << <NUM_LIT> ] ; final char hexDigits [ ] = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; for ( int i = <NUM_LIT> , j = <NUM_LIT> ; i < src . length ; i ++ ) { res [ j ++ ] = hexDigits [ src [ i ] > > > <NUM_LIT> & <NUM_LIT> ] ; res [ j ++ ] = hexDigits [ src [ i ] & <NUM_LIT> ] ; } return new String ( res ) ; } } </s>
<s> package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import android . text . TextUtils ; import com . appspa . update . _AppSpace ; import java . io . File ; public class DownloadEntity implements Parcelable { private String mDownloadUrl ; private String mMd5 ; private String mWholeMd5 ; private long mSize ; private boolean mIsShowNotification ; private String mTip ; private boolean isPatch ; public DownloadEntity ( ) { } protected DownloadEntity ( Parcel in ) { mDownloadUrl = in . readString ( ) ; mMd5 = in . readString ( ) ; mWholeMd5 = in . readString ( ) ; mSize = in . readLong ( ) ; mIsShowNotification = in . readByte ( ) != <NUM_LIT> ; mTip = in . readString ( ) ; isPatch = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < DownloadEntity > CREATOR = new Creator < DownloadEntity > ( ) { @ Override public DownloadEntity createFromParcel ( Parcel in ) { return new DownloadEntity ( in ) ; } @ Override public DownloadEntity [ ] newArray ( int size ) { return new DownloadEntity [ size ] ; } } ; public String getDownloadUrl ( ) { return mDownloadUrl ; } public DownloadEntity setDownloadUrl ( String downloadUrl ) { mDownloadUrl = downloadUrl ; return this ; } public String getMd5 ( ) { return mMd5 ; } public DownloadEntity setMd5 ( String md5 ) { mMd5 = md5 ; return this ; } public String getWholeMd5 ( ) { if ( mWholeMd5 == null || TextUtils . isEmpty ( mWholeMd5 ) ) { return mMd5 ; } return mWholeMd5 ; } public DownloadEntity setWholeMd5 ( String md5 ) { mWholeMd5 = md5 ; return this ; } public long getSize ( ) { return mSize ; } public DownloadEntity setSize ( long size ) { mSize = size ; return this ; } public boolean isShowNotification ( ) { return mIsShowNotification ; } public DownloadEntity setShowNotification ( boolean showNotification ) { mIsShowNotification = showNotification ; return this ; } public DownloadEntity setTip ( String mTip ) { this . mTip = mTip ; return this ; } public DownloadEntity setIsPatch ( boolean isPatch ) { this . isPatch = isPatch ; return this ; } public boolean isFileValid ( File file ) { return _AppSpace . isFileValid ( mMd5 , file ) ; } public boolean isPatch ( ) { return isPatch ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mDownloadUrl + '<STR_LIT>' + "<STR_LIT>" + mMd5 + '<STR_LIT>' + "<STR_LIT>" + mWholeMd5 + '<STR_LIT>' + "<STR_LIT>" + mSize + '<STR_LIT>' + "<STR_LIT>" + mIsShowNotification + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( mDownloadUrl ) ; dest . writeString ( mMd5 ) ; dest . writeString ( mWholeMd5 ) ; dest . writeLong ( mSize ) ; dest . writeByte ( ( byte ) ( mIsShowNotification ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeString ( mTip ) ; dest . writeByte ( ( byte ) ( isPatch ? <NUM_LIT> : <NUM_LIT> ) ) ; } } </s>
<s> package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import java . io . File ; import java . util . Map ; public interface IUpdateHttpService { void asyncGet ( @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull Callback callBack ) ; void asyncPost ( @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull Callback callBack ) ; void download ( @ NonNull String url , @ NonNull String path , @ NonNull String fileName , @ NonNull DownloadCallback callback ) ; void cancelDownload ( @ NonNull String url ) ; interface Callback { void onSuccess ( String result ) ; void onError ( Throwable throwable ) ; } interface DownloadCallback { void onStart ( ) ; void onProgress ( float progress , long total ) ; void onSuccess ( File file ) ; void onError ( Throwable throwable ) ; } } </s>
<s> package com . appspa . update . logs ; import androidx . annotation . NonNull ; import android . text . TextUtils ; import android . util . Log ; public final class UpdateLog { private UpdateLog ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public final static String DEFAULT_LOG_TAG = "<STR_LIT>" ; private final static int MAX_LOG_PRIORITY = <NUM_LIT> ; private final static int MIN_LOG_PRIORITY = <NUM_LIT> ; private static ILogger sILogger = new LogcatLogger ( ) ; private static String sTag = DEFAULT_LOG_TAG ; private static boolean sIsDebug = false ; private static int sLogPriority = MAX_LOG_PRIORITY ; public static void setLogger ( @ NonNull ILogger logger ) { sILogger = logger ; } public static void setTag ( String tag ) { sTag = tag ; } public static void setDebug ( boolean isDebug ) { sIsDebug = isDebug ; } public static void setPriority ( int priority ) { sLogPriority = priority ; } public static void debug ( boolean isDebug ) { if ( isDebug ) { debug ( DEFAULT_LOG_TAG ) ; } else { debug ( "<STR_LIT>" ) ; } } public static void debug ( String tag ) { if ( ! TextUtils . isEmpty ( tag ) ) { setDebug ( true ) ; setPriority ( MIN_LOG_PRIORITY ) ; setTag ( tag ) ; } else { setDebug ( false ) ; setPriority ( MAX_LOG_PRIORITY ) ; setTag ( "<STR_LIT>" ) ; } } public static void v ( String msg ) { if ( enableLog ( Log . VERBOSE ) ) { sILogger . log ( Log . VERBOSE , sTag , msg , null ) ; } } public static void vTag ( String tag , String msg ) { if ( enableLog ( Log . VERBOSE ) ) { sILogger . log ( Log . VERBOSE , tag , msg , null ) ; } } public static void d ( String msg ) { if ( enableLog ( Log . DEBUG ) ) { sILogger . log ( Log . DEBUG , sTag , msg , null ) ; } } public static void dTag ( String tag , String msg ) { if ( enableLog ( Log . DEBUG ) ) { sILogger . log ( Log . DEBUG , tag , msg , null ) ; } } public static void i ( String msg ) { if ( enableLog ( Log . INFO ) ) { sILogger . log ( Log . INFO , sTag , msg , null ) ; } } public static void iTag ( String tag , String msg ) { if ( enableLog ( Log . INFO ) ) { sILogger . log ( Log . INFO , tag , msg , null ) ; } } public static void w ( String msg ) { if ( enableLog ( Log . WARN ) ) { sILogger . log ( Log . WARN , sTag , msg , null ) ; } } public static void wTag ( String tag , String msg ) { if ( enableLog ( Log . WARN ) ) { sILogger . log ( Log . WARN , tag , msg , null ) ; } } public static void e ( String msg ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , msg , null ) ; } } public static void eTag ( String tag , String msg ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , msg , null ) ; } } public static void e ( Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , null , t ) ; } } public static void eTag ( String tag , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , null , t ) ; } } public static void e ( String msg , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , msg , t ) ; } } public static void eTag ( String tag , String msg , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , msg , t ) ; } } public static void wtf ( String msg ) { if ( enableLog ( Log . ASSERT ) ) { sILogger . log ( Log . ASSERT , sTag , msg , null ) ; } } public static void wtfTag ( String tag , String msg ) { if ( enableLog ( Log . ASSERT ) ) { sILogger . log ( Log . ASSERT , tag , msg , null ) ; } } private static boolean enableLog ( int logPriority ) { return sILogger != null && sIsDebug && logPriority >= sLogPriority ; } } </s>
<s> package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import android . text . TextUtils ; import com . appspa . update . proxy . IUpdateHttpService ; public class UpdateEntity implements Parcelable { private boolean mHasUpdate ; private boolean mIsForce ; private boolean mIsIgnorable ; private int mVersionCode ; private String mVersionName ; private String mUpdateContent ; private DownloadEntity mDownloadEntity ; private DownloadEntity mPatchDownloadEntity ; private boolean mIsSilent ; private boolean mIsAutoInstall ; private String mCacheDir ; public UpdateEntity ( ) { mVersionName = "<STR_LIT>" ; mDownloadEntity = new DownloadEntity ( ) ; mIsAutoInstall = true ; } protected UpdateEntity ( Parcel in ) { mHasUpdate = in . readByte ( ) != <NUM_LIT> ; mIsForce = in . readByte ( ) != <NUM_LIT> ; mIsIgnorable = in . readByte ( ) != <NUM_LIT> ; mVersionCode = in . readInt ( ) ; mVersionName = in . readString ( ) ; mUpdateContent = in . readString ( ) ; mDownloadEntity = in . readParcelable ( DownloadEntity . class . getClassLoader ( ) ) ; mPatchDownloadEntity = in . readParcelable ( DownloadEntity . class . getClassLoader ( ) ) ; mIsSilent = in . readByte ( ) != <NUM_LIT> ; mIsAutoInstall = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < UpdateEntity > CREATOR = new Creator < UpdateEntity > ( ) { @ Override public UpdateEntity createFromParcel ( Parcel in ) { return new UpdateEntity ( in ) ; } @ Override public UpdateEntity [ ] newArray ( int size ) { return new UpdateEntity [ size ] ; } } ; public boolean isHasUpdate ( ) { return mHasUpdate ; } public UpdateEntity setHasUpdate ( boolean hasUpdate ) { mHasUpdate = hasUpdate ; return this ; } public boolean isForce ( ) { return mIsForce ; } public UpdateEntity setForce ( boolean force ) { if ( force ) { mIsIgnorable = false ; } mIsForce = force ; return this ; } public boolean isIgnorable ( ) { return mIsIgnorable ; } public UpdateEntity setIsIgnorable ( boolean isIgnorable ) { if ( isIgnorable ) { mIsForce = false ; } mIsIgnorable = isIgnorable ; return this ; } public boolean isSilent ( ) { return mIsSilent ; } public UpdateEntity setIsSilent ( boolean isSilent ) { mIsSilent = isSilent ; return this ; } public boolean isAutoInstall ( ) { return mIsAutoInstall ; } public UpdateEntity setIsAutoInstall ( boolean isAutoInstall ) { mIsAutoInstall = isAutoInstall ; return this ; } public UpdateEntity setCacheDir ( String apkCacheDir ) { mCacheDir = apkCacheDir ; if ( ! TextUtils . isEmpty ( apkCacheDir ) && TextUtils . isEmpty ( mCacheDir ) ) { mCacheDir = apkCacheDir ; } return this ; } public String getCacheDir ( ) { return mCacheDir ; } public UpdateEntity setIsAutoMode ( boolean isAutoMode ) { if ( isAutoMode ) { mIsSilent = true ; mIsAutoInstall = true ; mDownloadEntity . setShowNotification ( true ) ; if ( mPatchDownloadEntity != null ) { mPatchDownloadEntity . setShowNotification ( true ) ; } } return this ; } public UpdateEntity setShowNotification ( boolean showNotification ) { mDownloadEntity . setShowNotification ( showNotification ) ; if ( mPatchDownloadEntity != null ) { mPatchDownloadEntity . setShowNotification ( true ) ; } return this ; } public int getVersionCode ( ) { return mVersionCode ; } public UpdateEntity setVersionCode ( int versionCode ) { mVersionCode = versionCode ; return this ; } public String getVersionName ( ) { return mVersionName ; } public UpdateEntity setVersionName ( String versionName ) { mVersionName = versionName ; return this ; } public String getUpdateContent ( ) { return mUpdateContent ; } public UpdateEntity setUpdateContent ( String updateContent ) { mUpdateContent = updateContent ; return this ; } public UpdateEntity setDownLoadEntity ( @ NonNull DownloadEntity downloadEntity ) { mDownloadEntity = downloadEntity ; return this ; } public UpdateEntity setPatchDownloadEntity ( DownloadEntity mPatchDownloadEntity ) { this . mPatchDownloadEntity = mPatchDownloadEntity ; return this ; } public boolean hasPatch ( ) { return mPatchDownloadEntity != null && mPatchDownloadEntity . getDownloadUrl ( ) != null ; } public DownloadEntity getPatchDownloadEntity ( ) { return mPatchDownloadEntity ; } @ NonNull public DownloadEntity getDownLoadEntity ( ) { return mDownloadEntity ; } public DownloadEntity getCurDownloadEntity ( ) { return this . hasPatch ( ) ? getPatchDownloadEntity ( ) : getDownLoadEntity ( ) ; } private IUpdateHttpService mIUpdateHttpService ; public UpdateEntity setIUpdateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { mIUpdateHttpService = updateHttpService ; return this ; } @ Nullable public IUpdateHttpService getIUpdateHttpService ( ) { return mIUpdateHttpService ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mHasUpdate + "<STR_LIT>" + mIsForce + "<STR_LIT>" + mIsIgnorable + "<STR_LIT>" + mVersionCode + "<STR_LIT>" + mVersionName + '<STR_LIT>' + "<STR_LIT>" + mUpdateContent + '<STR_LIT>' + "<STR_LIT>" + mDownloadEntity + "<STR_LIT>" + mPatchDownloadEntity + "<STR_LIT>" + mIsSilent + "<STR_LIT>" + mIsAutoInstall + "<STR_LIT>" + mIUpdateHttpService + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeByte ( ( byte ) ( mHasUpdate ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsForce ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsIgnorable ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeInt ( mVersionCode ) ; dest . writeString ( mVersionName ) ; dest . writeString ( mUpdateContent ) ; dest . writeParcelable ( mDownloadEntity , flags ) ; dest . writeParcelable ( mPatchDownloadEntity , flags ) ; dest . writeByte ( ( byte ) ( mIsSilent ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsAutoInstall ? <NUM_LIT> : <NUM_LIT> ) ) ; } } </s>
<s> package com . appspa . update . logs ; public interface ILogger { void log ( int priority , String tag , String message , Throwable t ) ; } </s>
<s> package com . appspa . demo . entity ; import java . io . Serializable ; public class CustomResult implements Serializable { public boolean success ; public VersionInfo data ; public static class VersionInfo implements Serializable { public boolean hasUpdate ; public boolean isForce ; public boolean isIgnorable ; public boolean isSilent ; public String md5 ; public int versionCode ; public String versionName ; public String changeLog ; public String downloadUrl ; public long size ; public PatchInfo patchInfo ; } public static class PatchInfo implements Serializable { public String md5 ; public String sMd5 ; public String tMd5 ; public String tip ; public String downloadUrl ; public long size ; } } </s>
<s> package com . appspa . update . widget ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . core . app . ActivityCompat ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . R ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; import static com . appspa . update . widget . UpdateDialogFragment . REQUEST_CODE_REQUEST_PERMISSIONS ; public class UpdateDialog extends BaseDialog implements View . OnClickListener , IDownloadEventHandler { private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private IPrompterProxy mPrompterProxy ; private PromptEntity mPromptEntity ; public static UpdateDialog newInstance ( @ NonNull Context context , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , PromptEntity promptEntity ) { UpdateDialog dialog = new UpdateDialog ( context ) ; dialog . setIPrompterProxy ( prompterProxy ) . setUpdateEntity ( updateEntity ) . setPromptEntity ( promptEntity ) ; dialog . initTheme ( promptEntity . getThemeColor ( ) , promptEntity . getTopResId ( ) , promptEntity . getButtonTextColor ( ) , promptEntity . getWidthRatio ( ) , promptEntity . getHeightRatio ( ) ) ; return dialog ; } private UpdateDialog ( Context context ) { super ( context , R . layout . spa_dialog_update ) ; } public UpdateDialog setPromptEntity ( PromptEntity promptEntity ) { mPromptEntity = promptEntity ; return this ; } @ Override protected void initViews ( ) { mIvTop = findViewById ( R . id . iv_top ) ; mTvTitle = findViewById ( R . id . tv_title ) ; mTvUpdateInfo = findViewById ( R . id . tv_update_info ) ; mBtnUpdate = findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = findViewById ( R . id . btn_background_update ) ; mTvIgnore = findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = findViewById ( R . id . npb_progress ) ; mLlClose = findViewById ( R . id . ll_close ) ; mIvClose = findViewById ( R . id . iv_close ) ; } @ Override protected void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; setCancelable ( false ) ; setCanceledOnTouchOutside ( false ) ; setIsSyncSystemUiVisibility ( true ) ; } private String getUrl ( ) { return mPrompterProxy != null ? mPrompterProxy . getUrl ( ) : "<STR_LIT>" ; } @ Override public void show ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; super . show ( ) ; } @ Override public void dismiss ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; super . dismiss ( ) ; } private void clearIPrompterProxy ( ) { if ( mPrompterProxy != null ) { mPrompterProxy . recycle ( ) ; mPrompterProxy = null ; } } public UpdateDialog setUpdateEntity ( UpdateEntity updateEntity ) { mUpdateEntity = updateEntity ; initUpdateInfo ( mUpdateEntity ) ; return this ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( getContext ( ) , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor , float widthRatio , float heightRatio ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( getContext ( ) , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor , widthRatio , heightRatio ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor , float widthRatio , float heightRatio ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; initWindow ( widthRatio , heightRatio ) ; } private void initWindow ( float widthRatio , float heightRatio ) { Window window = getWindow ( ) ; if ( window == null ) { return ; } WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getContext ( ) . getResources ( ) . getDisplayMetrics ( ) ; if ( widthRatio > <NUM_LIT> && widthRatio < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * widthRatio ) ; } if ( heightRatio > <NUM_LIT> && heightRatio < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * heightRatio ) ; } window . setAttributes ( lp ) ; } private UpdateDialog setIPrompterProxy ( IPrompterProxy prompterProxy ) { mPrompterProxy = prompterProxy ; return this ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( getContext ( ) , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( ( Activity ) getContext ( ) , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { mPrompterProxy . backgroundDownload ( ) ; dismiss ( ) ; } else if ( i == R . id . iv_close ) { mPrompterProxy . cancelDownload ( ) ; dismiss ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( getContext ( ) , mUpdateEntity . getVersionName ( ) ) ; dismiss ( ) ; } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismiss ( ) ; } else { showInstallButton ( ) ; } } else { if ( mPrompterProxy != null ) { mPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( isShowing ( ) ) { doStart ( ) ; } } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( isShowing ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( isShowing ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismiss ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( isShowing ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismiss ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } @ Override public void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; } @ Override public void onDetachedFromWindow ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; super . onDetachedFromWindow ( ) ; } } </s>
<s> package com . appspa . update ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . proxy . impl . DefaultUpdatePrompter ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . utils . UpdateUtils ; import java . lang . ref . WeakReference ; import java . util . Map ; import java . util . TreeMap ; public class UpdateManager implements IUpdateProxy { private IUpdateProxy mUpdateProxy ; private UpdateEntity mUpdateEntity ; private final WeakReference < Context > mContext ; private final String mUpdateUrl ; private final Map < String , Object > mParams ; private final String mCacheDir ; private final boolean mIsWifiOnly ; private final boolean mIsGet ; private final boolean mIsAutoMode ; private IUpdateHttpService mIUpdateHttpService ; private final IUpdateChecker mIUpdateChecker ; private final IUpdateParser mIUpdateParser ; private IUpdateDownloader mIUpdateDownloader ; private OnFileDownloadListener mOnFileDownloadListener ; private final IUpdatePrompter mIUpdatePrompter ; private final PromptEntity mPromptEntity ; private UpdateManager ( Builder builder ) { mContext = new WeakReference < > ( builder . context ) ; mUpdateUrl = builder . updateUrl ; mParams = builder . params ; mCacheDir = builder . apkCacheDir ; mIsWifiOnly = builder . isWifiOnly ; mIsGet = builder . isGet ; mIsAutoMode = builder . isAutoMode ; mIUpdateHttpService = builder . updateHttpService ; mIUpdateChecker = builder . updateChecker ; mIUpdateParser = builder . updateParser ; mIUpdateDownloader = builder . updateDownLoader ; mOnFileDownloadListener = builder . onFileDownloadListener ; mIUpdatePrompter = builder . updatePrompter ; mPromptEntity = builder . promptEntity ; } public UpdateManager setIUpdateProxy ( IUpdateProxy updateProxy ) { mUpdateProxy = updateProxy ; return this ; } @ Nullable @ Override public Context getContext ( ) { return mContext . get ( ) ; } @ Override public String getUrl ( ) { return mUpdateUrl ; } @ Override public IUpdateHttpService getIUpdateHttpService ( ) { return mIUpdateHttpService ; } @ Override public void update ( ) { UpdateLog . d ( "<STR_LIT>" + this ) ; if ( mUpdateProxy != null ) { mUpdateProxy . update ( ) ; } else { doUpdate ( ) ; } } private void doUpdate ( ) { onBeforeCheck ( ) ; doCheck ( ) ; } private void doCheck ( ) { if ( mIsWifiOnly ) { if ( UpdateUtils . checkWifi ( ) ) { checkVersion ( ) ; } else { onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_WIFI ) ; } } else { if ( UpdateUtils . checkNetwork ( ) ) { checkVersion ( ) ; } else { onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_NETWORK ) ; } } } @ Override public void onBeforeCheck ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . onBeforeCheck ( ) ; } else { mIUpdateChecker . onBeforeCheck ( ) ; } } @ Override public void checkVersion ( ) { UpdateLog . d ( "<STR_LIT>" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . checkVersion ( ) ; } else { if ( TextUtils . isEmpty ( mUpdateUrl ) ) { throw new NullPointerException ( "<STR_LIT>" ) ; } mIUpdateChecker . checkVersion ( mIsGet , mUpdateUrl , mParams , this ) ; } } @ Override public void onAfterCheck ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . onAfterCheck ( ) ; } else { mIUpdateChecker . onAfterCheck ( ) ; } } @ Override public boolean isAsyncParser ( ) { if ( mUpdateProxy != null ) { return mUpdateProxy . isAsyncParser ( ) ; } else { return mIUpdateParser . isAsyncParser ( ) ; } } @ Override public UpdateEntity parseJson ( @ NonNull String json ) throws Exception { UpdateLog . i ( "<STR_LIT>" + json ) ; if ( mUpdateProxy != null ) { mUpdateEntity = mUpdateProxy . parseJson ( json ) ; } else { mUpdateEntity = mIUpdateParser . parseJson ( json ) ; } mUpdateEntity = refreshParams ( mUpdateEntity ) ; return mUpdateEntity ; } @ Override public void parseJson ( @ NonNull String json , final IUpdateParseCallback callback ) throws Exception { UpdateLog . i ( "<STR_LIT>" + json ) ; if ( mUpdateProxy != null ) { mUpdateProxy . parseJson ( json , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; callback . onParseResult ( updateEntity ) ; } } ) ; } else { mIUpdateParser . parseJson ( json , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; callback . onParseResult ( updateEntity ) ; } } ) ; } } private UpdateEntity refreshParams ( UpdateEntity updateEntity ) { if ( updateEntity != null ) { updateEntity . setCacheDir ( mCacheDir ) ; updateEntity . setIsAutoMode ( mIsAutoMode ) ; updateEntity . setIUpdateHttpService ( mIUpdateHttpService ) ; } return updateEntity ; } @ Override public void findNewVersion ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy ) { UpdateLog . i ( "<STR_LIT>" + updateEntity ) ; if ( updateEntity . isSilent ( ) ) { if ( ! UpdateUtils . isApkDownloaded ( updateEntity ) ) { startDownload ( updateEntity , mOnFileDownloadListener ) ; } else { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } } else { if ( mUpdateProxy != null ) { mUpdateProxy . findNewVersion ( updateEntity , updateProxy ) ; } else { if ( mIUpdatePrompter instanceof DefaultUpdatePrompter ) { Context context = getContext ( ) ; if ( context instanceof FragmentActivity && ( ( FragmentActivity ) context ) . isFinishing ( ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . PROMPT_ACTIVITY_DESTROY ) ; } else { mIUpdatePrompter . showPrompt ( updateEntity , updateProxy , mPromptEntity ) ; } } else { mIUpdatePrompter . showPrompt ( updateEntity , updateProxy , mPromptEntity ) ; } } } } @ Override public void noNewVersion ( Throwable throwable ) { UpdateLog . i ( throwable != null ? "<STR_LIT>" + throwable . getMessage ( ) : "<STR_LIT>" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . noNewVersion ( throwable ) ; } else { mIUpdateChecker . noNewVersion ( throwable ) ; } } @ Override public void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { UpdateLog . i ( "<STR_LIT>" + updateEntity ) ; updateEntity . setIUpdateHttpService ( mIUpdateHttpService ) ; if ( mUpdateProxy != null ) { mUpdateProxy . startDownload ( updateEntity , downloadListener ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . startDownload ( updateEntity , downloadListener ) ; } } } @ Override public void backgroundDownload ( ) { UpdateLog . i ( "<STR_LIT>" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . backgroundDownload ( ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . backgroundDownload ( ) ; } } } @ Override public void cancelDownload ( ) { UpdateLog . d ( "<STR_LIT>" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . cancelDownload ( ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . cancelDownload ( ) ; } } } @ Override public void recycle ( ) { UpdateLog . d ( "<STR_LIT>" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . recycle ( ) ; mUpdateProxy = null ; } if ( mParams != null ) { mParams . clear ( ) ; } mIUpdateHttpService = null ; mIUpdateDownloader = null ; mOnFileDownloadListener = null ; } public void download ( String downloadUrl , @ Nullable OnFileDownloadListener downloadListener ) { UpdateEntity updateEntity = new UpdateEntity ( ) ; updateEntity . getCurDownloadEntity ( ) . setDownloadUrl ( downloadUrl ) ; startDownload ( refreshParams ( updateEntity ) , downloadListener ) ; } public void update ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; try { UpdateUtils . processUpdateEntity ( mUpdateEntity , "<STR_LIT>" , this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static class Builder { Context context ; String updateUrl ; Map < String , Object > params ; IUpdateHttpService updateHttpService ; IUpdateParser updateParser ; boolean isGet ; boolean isWifiOnly ; boolean isAutoMode ; IUpdateChecker updateChecker ; PromptEntity promptEntity ; IUpdatePrompter updatePrompter ; IUpdateDownloader updateDownLoader ; OnFileDownloadListener onFileDownloadListener ; String apkCacheDir ; Builder ( @ NonNull Context context ) { this . context = context ; params = new TreeMap < > ( ) ; if ( _AppSpace . getParams ( ) != null ) { params . putAll ( _AppSpace . getParams ( ) ) ; } promptEntity = new PromptEntity ( ) ; updateHttpService = _AppSpace . getIUpdateHttpService ( ) ; updateChecker = _AppSpace . getIUpdateChecker ( ) ; updateParser = _AppSpace . getIUpdateParser ( ) ; updatePrompter = _AppSpace . getIUpdatePrompter ( ) ; updateDownLoader = _AppSpace . getIUpdateDownLoader ( ) ; isGet = _AppSpace . isGet ( ) ; isWifiOnly = _AppSpace . isWifiOnly ( ) ; isAutoMode = _AppSpace . isAutoMode ( ) ; apkCacheDir = _AppSpace . getApkCacheDir ( ) ; } public Builder updateUrl ( @ NonNull String updateUrl ) { this . updateUrl = updateUrl ; return this ; } public Builder params ( @ NonNull Map < String , Object > params ) { this . params . putAll ( params ) ; return this ; } public Builder param ( @ NonNull String key , @ NonNull Object value ) { this . params . put ( key , value ) ; return this ; } public Builder updateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { this . updateHttpService = updateHttpService ; return this ; } public Builder apkCacheDir ( @ NonNull String apkCacheDir ) { this . apkCacheDir = apkCacheDir ; return this ; } public Builder isGet ( boolean isGet ) { this . isGet = isGet ; return this ; } public Builder isAutoMode ( boolean isAutoMode ) { this . isAutoMode = isAutoMode ; return this ; } public Builder isWifiOnly ( boolean isWifiOnly ) { this . isWifiOnly = isWifiOnly ; return this ; } public Builder updateChecker ( @ NonNull IUpdateChecker updateChecker ) { this . updateChecker = updateChecker ; return this ; } public Builder updateParser ( @ NonNull IUpdateParser updateParser ) { this . updateParser = updateParser ; return this ; } public Builder updatePrompter ( @ NonNull IUpdatePrompter updatePrompter ) { this . updatePrompter = updatePrompter ; return this ; } public Builder setOnFileDownloadListener ( OnFileDownloadListener onFileDownloadListener ) { this . onFileDownloadListener = onFileDownloadListener ; return this ; } @ Deprecated public Builder themeColor ( @ ColorInt int themeColor ) { promptEntity . setThemeColor ( themeColor ) ; return this ; } public Builder promptThemeColor ( @ ColorInt int themeColor ) { promptEntity . setThemeColor ( themeColor ) ; return this ; } @ Deprecated public Builder topResId ( @ DrawableRes int topResId ) { promptEntity . setTopResId ( topResId ) ; return this ; } public Builder promptTopResId ( @ DrawableRes int topResId ) { promptEntity . setTopResId ( topResId ) ; return this ; } public Builder promptTopDrawable ( Drawable topDrawable ) { if ( topDrawable != null ) { String tag = _AppSpace . saveTopDrawable ( topDrawable ) ; promptEntity . setTopDrawableTag ( tag ) ; } return this ; } public Builder promptTopBitmap ( Bitmap topBitmap ) { if ( topBitmap != null ) { String tag = _AppSpace . saveTopDrawable ( new BitmapDrawable ( context . getResources ( ) , topBitmap ) ) ; promptEntity . setTopDrawableTag ( tag ) ; } return this ; } public Builder promptButtonTextColor ( @ ColorInt int buttonTextColor ) { promptEntity . setButtonTextColor ( buttonTextColor ) ; return this ; } public Builder supportBackgroundUpdate ( boolean supportBackgroundUpdate ) { promptEntity . setSupportBackgroundUpdate ( supportBackgroundUpdate ) ; return this ; } public Builder promptWidthRatio ( float widthRatio ) { promptEntity . setWidthRatio ( widthRatio ) ; return this ; } public Builder promptHeightRatio ( float heightRatio ) { promptEntity . setHeightRatio ( heightRatio ) ; return this ; } public Builder promptIgnoreDownloadError ( boolean ignoreDownloadError ) { promptEntity . setIgnoreDownloadError ( ignoreDownloadError ) ; return this ; } public Builder promptStyle ( @ NonNull PromptEntity promptEntity ) { this . promptEntity = promptEntity ; return this ; } public Builder updateDownLoader ( @ NonNull IUpdateDownloader updateDownLoader ) { this . updateDownLoader = updateDownLoader ; return this ; } public UpdateManager build ( ) { UpdateUtils . requireNonNull ( this . context , "<STR_LIT>" ) ; UpdateUtils . requireNonNull ( this . updateHttpService , "<STR_LIT>" ) ; if ( TextUtils . isEmpty ( apkCacheDir ) ) { apkCacheDir = UpdateUtils . getDefaultDiskCacheDirPath ( ) ; } return new UpdateManager ( this ) ; } public void update ( ) { build ( ) . update ( ) ; } public void update ( IUpdateProxy updateProxy ) { build ( ) . setIUpdateProxy ( updateProxy ) . update ( ) ; } } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mUpdateUrl + '<STR_LIT>' + "<STR_LIT>" + mParams + "<STR_LIT>" + mCacheDir + '<STR_LIT>' + "<STR_LIT>" + mIsWifiOnly + "<STR_LIT>" + mIsGet + "<STR_LIT>" + mIsAutoMode + '<STR_LIT>' ; } } </s>
<s> package com . appspa . update . proxy ; import java . io . File ; public interface IFileEncryptor { String encryptFile ( File file ) ; boolean isFileValid ( String encrypt , File file ) ; } </s>
<s> package com . appspa . update . listener ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import java . io . File ; public interface OnInstallListener { boolean onInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) ; void onInstallApkSuccess ( ) ; } </s>
<s> package com . appspa . update ; import android . app . Application ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . ILogger ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IFileEncryptor ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . impl . DefaultFileEncryptor ; import com . appspa . update . proxy . impl . DefaultUpdatePrompter ; import com . appspa . update . utils . ApkUtils ; import com . appspa . update . listener . impl . DefaultInstallListener ; import com . appspa . update . listener . impl . DefaultUpdateFailureListener ; import com . appspa . update . proxy . impl . DefaultUpdateChecker ; import com . appspa . update . proxy . impl . DefaultUpdateDownloader ; import com . appspa . update . proxy . impl . DefaultUpdateParser ; import java . util . Map ; import java . util . TreeMap ; public class AppSpace { private Application mContext ; private static AppSpace sInstance ; Map < String , Object > mParams ; boolean mIsGet ; boolean mIsWifiOnly ; boolean mIsAutoMode ; boolean mIsPatchMode ; String mApkCacheDir ; IUpdateHttpService mUpdateHttpService ; IUpdateChecker mUpdateChecker ; IUpdateParser mUpdateParser ; IUpdatePrompter mUpdatePrompter ; IUpdateDownloader mUpdateDownloader ; IFileEncryptor mFileEncryptor ; OnInstallListener mOnInstallListener ; OnUpdateFailureListener mOnUpdateFailureListener ; private AppSpace ( ) { mIsGet = false ; mIsWifiOnly = true ; mIsAutoMode = false ; mUpdateChecker = new DefaultUpdateChecker ( ) ; mUpdateParser = new DefaultUpdateParser ( ) ; mUpdateDownloader = new DefaultUpdateDownloader ( ) ; mUpdatePrompter = new DefaultUpdatePrompter ( ) ; mFileEncryptor = new DefaultFileEncryptor ( ) ; mOnInstallListener = new DefaultInstallListener ( ) ; mOnUpdateFailureListener = new DefaultUpdateFailureListener ( ) ; } public static AppSpace get ( ) { if ( sInstance == null ) { synchronized ( AppSpace . class ) { if ( sInstance == null ) { sInstance = new AppSpace ( ) ; } } } return sInstance ; } public void init ( Application application ) { mContext = application ; UpdateError . init ( mContext ) ; } private Application getApplication ( ) { testInitialize ( ) ; return mContext ; } private void testInitialize ( ) { if ( mContext == null ) { throw new ExceptionInInitializerError ( "<STR_LIT>" ) ; } } public static Context getContext ( ) { return get ( ) . getApplication ( ) ; } public static UpdateManager . Builder newBuild ( @ NonNull Context context ) { return new UpdateManager . Builder ( context ) ; } public static UpdateManager . Builder newBuild ( @ NonNull Context context , String updateUrl ) { return new UpdateManager . Builder ( context ) . updateUrl ( updateUrl ) ; } public AppSpace param ( @ NonNull String key , @ NonNull Object value ) { if ( mParams == null ) { mParams = new TreeMap < > ( ) ; } UpdateLog . d ( "<STR_LIT>" + key + "<STR_LIT>" + value . toString ( ) ) ; mParams . put ( key , value ) ; return this ; } public AppSpace params ( @ NonNull Map < String , Object > params ) { logForParams ( params ) ; mParams = params ; return this ; } private void logForParams ( @ NonNull Map < String , Object > params ) { StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { sb . append ( "<STR_LIT>" ) . append ( entry . getKey ( ) ) . append ( "<STR_LIT>" ) . append ( entry . getValue ( ) . toString ( ) ) . append ( "<STR_LIT>" ) ; } sb . append ( "<STR_LIT>" ) ; UpdateLog . d ( sb . toString ( ) ) ; } public AppSpace setIUpdateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { UpdateLog . d ( "<STR_LIT>" + updateHttpService . getClass ( ) . getCanonicalName ( ) ) ; mUpdateHttpService = updateHttpService ; return this ; } public AppSpace setIUpdateChecker ( @ NonNull IUpdateChecker updateChecker ) { mUpdateChecker = updateChecker ; return this ; } public AppSpace setIUpdateParser ( @ NonNull IUpdateParser updateParser ) { mUpdateParser = updateParser ; return this ; } public AppSpace setIUpdatePrompter ( IUpdatePrompter updatePrompter ) { mUpdatePrompter = updatePrompter ; return this ; } public AppSpace setIUpdateDownLoader ( @ NonNull IUpdateDownloader updateDownLoader ) { mUpdateDownloader = updateDownLoader ; return this ; } public AppSpace isGet ( boolean isGet ) { UpdateLog . d ( "<STR_LIT>" + isGet ) ; mIsGet = isGet ; return this ; } public AppSpace isWifiOnly ( boolean isWifiOnly ) { UpdateLog . d ( "<STR_LIT>" + isWifiOnly ) ; mIsWifiOnly = isWifiOnly ; return this ; } public AppSpace isAutoMode ( boolean isAutoMode ) { UpdateLog . d ( "<STR_LIT>" + isAutoMode ) ; mIsAutoMode = isAutoMode ; return this ; } public AppSpace isPatchMode ( boolean isPatchMode ) { UpdateLog . d ( "<STR_LIT>" + isPatchMode ) ; mIsPatchMode = isPatchMode ; return this ; } public AppSpace setApkCacheDir ( String apkCacheDir ) { UpdateLog . d ( "<STR_LIT>" + apkCacheDir ) ; mApkCacheDir = apkCacheDir ; return this ; } public AppSpace supportSilentInstall ( boolean supportSilentInstall ) { ApkUtils . setSupportSilentInstall ( supportSilentInstall ) ; return this ; } public AppSpace debug ( boolean isDebug ) { UpdateLog . debug ( isDebug ) ; return this ; } public AppSpace setILogger ( @ NonNull ILogger logger ) { UpdateLog . setLogger ( logger ) ; return this ; } public AppSpace setIFileEncryptor ( IFileEncryptor fileEncryptor ) { mFileEncryptor = fileEncryptor ; return this ; } public AppSpace setOnInstallListener ( OnInstallListener onInstallListener ) { mOnInstallListener = onInstallListener ; return this ; } public AppSpace setOnUpdateFailureListener ( @ NonNull OnUpdateFailureListener onUpdateFailureListener ) { mOnUpdateFailureListener = onUpdateFailureListener ; return this ; } } </s>
<s> package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; public interface IUpdateDownloader { void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ; void cancelDownload ( ) ; void backgroundDownload ( ) ; } </s>
<s> package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; public interface IPrompterProxy { String getUrl ( ) ; void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ; void backgroundDownload ( ) ; void cancelDownload ( ) ; void recycle ( ) ; } </s>
<s> package com . appspa . update . proxy ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . service . OnFileDownloadListener ; public interface IUpdateProxy { @ Nullable Context getContext ( ) ; String getUrl ( ) ; IUpdateHttpService getIUpdateHttpService ( ) ; void update ( ) ; void onBeforeCheck ( ) ; void checkVersion ( ) ; void onAfterCheck ( ) ; void findNewVersion ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy ) ; void noNewVersion ( Throwable throwable ) ; boolean isAsyncParser ( ) ; UpdateEntity parseJson ( @ NonNull String json ) throws Exception ; void parseJson ( @ NonNull String json , final IUpdateParseCallback callback ) throws Exception ; void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ; void backgroundDownload ( ) ; void cancelDownload ( ) ; void recycle ( ) ; } </s>
<s> package com . appspa . update . proxy . impl ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . _AppSpace ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultPrompterProxyImpl implements IPrompterProxy { private IUpdateProxy mUpdateProxy ; DefaultPrompterProxyImpl ( IUpdateProxy proxy ) { mUpdateProxy = proxy ; } @ Override public String getUrl ( ) { return mUpdateProxy != null ? mUpdateProxy . getUrl ( ) : "<STR_LIT>" ; } @ Override public void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { if ( mUpdateProxy != null ) { mUpdateProxy . startDownload ( updateEntity , downloadListener ) ; } } @ Override public void backgroundDownload ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . backgroundDownload ( ) ; } } @ Override public void cancelDownload ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; if ( mUpdateProxy != null ) { mUpdateProxy . cancelDownload ( ) ; } } @ Override public void recycle ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . recycle ( ) ; mUpdateProxy = null ; } } } </s>
<s> package com . appspa . update . widget ; import androidx . annotation . NonNull ; import com . appspa . update . service . OnFileDownloadListener ; import java . io . File ; import java . lang . ref . WeakReference ; public class WeakFileDownloadListener implements OnFileDownloadListener { private WeakReference < IDownloadEventHandler > mDownloadHandlerRef ; public WeakFileDownloadListener ( @ NonNull IDownloadEventHandler handler ) { mDownloadHandlerRef = new WeakReference < > ( handler ) ; } @ Override public void onStart ( ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleStart ( ) ; } } @ Override public void onProgress ( float progress , long total ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleProgress ( progress ) ; } } @ Override public boolean onCompleted ( File file ) { if ( getEventHandler ( ) != null ) { return getEventHandler ( ) . handleCompleted ( file ) ; } else { return true ; } } @ Override public void onError ( Throwable throwable ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleError ( throwable ) ; } } private IDownloadEventHandler getEventHandler ( ) { return mDownloadHandlerRef != null ? mDownloadHandlerRef . get ( ) : null ; } } </s>
<s> package com . appspa . update . widget ; import java . io . File ; public interface IDownloadEventHandler { void handleStart ( ) ; void handleProgress ( float progress ) ; boolean handleCompleted ( File file ) ; void handleError ( Throwable throwable ) ; } </s>
<s> package com . appspa . update . proxy ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; public interface IUpdateParser { UpdateEntity parseJson ( String json ) throws Exception ; void parseJson ( String json , final IUpdateParseCallback callback ) throws Exception ; boolean isAsyncParser ( ) ; } </s>
<s> package com . appspa . demo . http ; import androidx . annotation . NonNull ; import com . appspa . update . proxy . IUpdateHttpService ; import com . zhy . http . okhttp . OkHttpUtils ; import com . zhy . http . okhttp . callback . FileCallBack ; import com . zhy . http . okhttp . callback . StringCallback ; import com . zhy . http . okhttp . request . RequestCall ; import java . io . File ; import java . util . Map ; import java . util . TreeMap ; import okhttp3 . Call ; import okhttp3 . Request ; public class OKHttpUpdateHttpService implements IUpdateHttpService { private boolean mIsPostJson ; public OKHttpUpdateHttpService ( ) { this ( false ) ; } public OKHttpUpdateHttpService ( boolean isPostJson ) { mIsPostJson = isPostJson ; } @ Override public void asyncGet ( @ NonNull String url , @ NonNull Map < String , Object > params , final @ NonNull Callback callBack ) { OkHttpUtils . get ( ) . params ( transform ( params ) ) . build ( ) . execute ( new StringCallback ( ) { @ Override public void onError ( Call call , Exception e , int id ) { callBack . onError ( e ) ; } @ Override public void onResponse ( String response , int id ) { callBack . onSuccess ( response ) ; } } ) ; } @ Override public void asyncPost ( @ NonNull String url , @ NonNull Map < String , Object > params , final @ NonNull Callback callBack ) { } @ Override public void download ( @ NonNull String url , @ NonNull String path , @ NonNull String fileName , final @ NonNull DownloadCallback callback ) { OkHttpUtils . get ( ) . url ( url ) . tag ( url ) . build ( ) . execute ( new FileCallBack ( path , fileName ) { @ Override public void inProgress ( float progress , long total , int id ) { callback . onProgress ( progress , total ) ; } @ Override public void onError ( Call call , Exception e , int id ) { callback . onError ( e ) ; } @ Override public void onResponse ( File response , int id ) { callback . onSuccess ( response ) ; } @ Override public void onBefore ( Request request , int id ) { super . onBefore ( request , id ) ; callback . onStart ( ) ; } } ) ; } @ Override public void cancelDownload ( @ NonNull String url ) { OkHttpUtils . getInstance ( ) . cancelTag ( url ) ; } private Map < String , String > transform ( Map < String , Object > params ) { Map < String , String > map = new TreeMap < > ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) . toString ( ) ) ; } return map ; } } </s>
<s> package com . appspa . update . utils ; import android . annotation . SuppressLint ; import android . app . ActivityManager ; import android . content . ActivityNotFoundException ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . graphics . Bitmap ; import android . graphics . Canvas ; import android . graphics . PixelFormat ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . net . ConnectivityManager ; import android . net . NetworkInfo ; import android . os . Environment ; import android . os . Looper ; import android . text . TextUtils ; import android . util . DisplayMetrics ; import androidx . annotation . NonNull ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . R ; import com . appspa . update . AppSpace ; import com . appspa . update . _AppSpace ; import com . appspa . update . logs . UpdateLog ; import java . io . File ; import java . util . List ; public final class UpdateUtils { private static final String IGNORE_VERSION = "<STR_LIT>" ; private static final String PREFS_FILE = "<STR_LIT>" ; private static final String KEY_SPA = "<STR_LIT>" ; private UpdateUtils ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static void processUpdateEntity ( UpdateEntity updateEntity , @ NonNull String result , @ NonNull IUpdateProxy updateProxy ) throws Exception { if ( updateEntity != null ) { if ( updateEntity . isHasUpdate ( ) ) { if ( updateEntity . isIgnorable ( ) && UpdateUtils . isIgnoreVersion ( updateProxy . getContext ( ) , updateEntity . getVersionName ( ) ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_IGNORED_VERSION ) ; } else if ( TextUtils . isEmpty ( updateEntity . getCacheDir ( ) ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_APK_CACHE_DIR_EMPTY ) ; } else { updateProxy . findNewVersion ( updateEntity , updateProxy ) ; } } else { updateProxy . noNewVersion ( null ) ; } } else { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , "<STR_LIT>" + result ) ; } } public static < T > T requireNonNull ( final T object , final String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; } public static boolean checkWifi ( ) { ConnectivityManager connectivity = ( ConnectivityManager ) AppSpace . getContext ( ) . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( connectivity == null ) { return false ; } NetworkInfo info = connectivity . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) && info . getType ( ) == ConnectivityManager . TYPE_WIFI ; } public static boolean checkNetwork ( ) { ConnectivityManager connectivity = ( ConnectivityManager ) AppSpace . getContext ( ) . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( connectivity == null ) { return false ; } NetworkInfo info = connectivity . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) ; } public static int getVersionCode ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . versionCode : - <NUM_LIT> ; } public static String getBaseApkMd5 ( Context context ) { String baseApkSource = ApkUtils . getSourceApkPath ( context , context . getPackageName ( ) ) ; return _AppSpace . encryptFile ( FileUtils . getFileByPath ( baseApkSource ) ) ; } public static String getVersionName ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . versionName : "<STR_LIT>" ; } public static int compareVersionName ( @ NonNull String versionName1 , @ NonNull String versionName2 ) { if ( versionName1 . equals ( versionName2 ) ) { return <NUM_LIT> ; } String [ ] versionArray1 = versionName1 . split ( "<STR_LIT>" ) ; String [ ] versionArray2 = versionName2 . split ( "<STR_LIT>" ) ; int idx = <NUM_LIT> ; int minLength = Math . min ( versionArray1 . length , versionArray2 . length ) ; int diff = <NUM_LIT> ; while ( idx < minLength && ( diff = versionArray1 [ idx ] . length ( ) - versionArray2 [ idx ] . length ( ) ) == <NUM_LIT> && ( diff = versionArray1 [ idx ] . compareTo ( versionArray2 [ idx ] ) ) == <NUM_LIT> ) { ++ idx ; } diff = ( diff != <NUM_LIT> ) ? diff : versionArray1 . length - versionArray2 . length ; return diff ; } public static int dip2px ( int dip , Context context ) { return ( int ) ( dip * getDensity ( context ) + <NUM_LIT> ) ; } private static float getDensity ( Context context ) { return getDisplayMetrics ( context ) . density ; } private static DisplayMetrics getDisplayMetrics ( Context context ) { return context . getResources ( ) . getDisplayMetrics ( ) ; } public static Bitmap drawable2Bitmap ( final Drawable drawable ) { if ( drawable instanceof BitmapDrawable ) { BitmapDrawable bitmapDrawable = ( BitmapDrawable ) drawable ; if ( bitmapDrawable . getBitmap ( ) != null ) { return bitmapDrawable . getBitmap ( ) ; } } Bitmap bitmap ; if ( drawable . getIntrinsicWidth ( ) <= <NUM_LIT> || drawable . getIntrinsicHeight ( ) <= <NUM_LIT> ) { bitmap = Bitmap . createBitmap ( <NUM_LIT> , <NUM_LIT> , drawable . getOpacity ( ) != PixelFormat . OPAQUE ? Bitmap . Config . ARGB_8888 : Bitmap . Config . RGB_565 ) ; } else { bitmap = Bitmap . createBitmap ( drawable . getIntrinsicWidth ( ) , drawable . getIntrinsicHeight ( ) , drawable . getOpacity ( ) != PixelFormat . OPAQUE ? Bitmap . Config . ARGB_8888 : Bitmap . Config . RGB_565 ) ; } Canvas canvas = new Canvas ( bitmap ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , canvas . getWidth ( ) , canvas . getHeight ( ) ) ; drawable . draw ( canvas ) ; return bitmap ; } private static SharedPreferences getSP ( Context context ) { return context . getSharedPreferences ( PREFS_FILE , Context . MODE_PRIVATE ) ; } public static void saveIgnoreVersion ( Context context , String newVersion ) { getSP ( context ) . edit ( ) . putString ( IGNORE_VERSION , newVersion ) . apply ( ) ; } public static boolean isIgnoreVersion ( Context context , String newVersion ) { return getSP ( context ) . getString ( IGNORE_VERSION , "<STR_LIT>" ) . equals ( newVersion ) ; } @ NonNull public static String getDisplayUpdateInfo ( Context context , @ NonNull UpdateEntity updateEntity ) { String targetSize = byte2FitMemorySize ( updateEntity . getCurDownloadEntity ( ) . getSize ( ) ) ; final String updateContent = updateEntity . getUpdateContent ( ) ; String updateInfo = "<STR_LIT>" ; if ( ! TextUtils . isEmpty ( targetSize ) ) { updateInfo = context . getString ( R . string . space_lab_new_version_size ) + targetSize + "<STR_LIT>" ; } if ( ! TextUtils . isEmpty ( updateContent ) ) { updateInfo += updateContent ; } return updateInfo ; } @ SuppressLint ( "<STR_LIT>" ) private static String byte2FitMemorySize ( final long byteNum ) { if ( byteNum <= <NUM_LIT> ) { return "<STR_LIT>" ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( "<STR_LIT>" , ( double ) byteNum ) ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( "<STR_LIT>" , ( double ) byteNum / <NUM_LIT> ) ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( "<STR_LIT>" , ( double ) byteNum / <NUM_LIT> ) ; } else { return String . format ( "<STR_LIT>" , ( double ) byteNum / <NUM_LIT> ) ; } } public static boolean isApkDownloaded ( UpdateEntity updateEntity ) { File appFile = getApkFileByUpdateEntity ( updateEntity ) ; String md5 = updateEntity . getCurDownloadEntity ( ) . getWholeMd5 ( ) ; return ! TextUtils . isEmpty ( md5 ) && FileUtils . isFileExists ( appFile ) && _AppSpace . isFileValid ( md5 , appFile ) ; } public static File getApkFileByUpdateEntity ( UpdateEntity updateEntity ) { String appName = getFileNameByDownloadUrl ( updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ) ; if ( appName != null && appName . endsWith ( "<STR_LIT>" ) ) { appName = appName . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } return new File ( updateEntity . getCacheDir ( ) . concat ( File . separator + updateEntity . getVersionName ( ) ) . concat ( File . separator + appName ) ) ; } @ NonNull public static String getFileNameByDownloadUrl ( String downloadUrl ) { if ( TextUtils . isEmpty ( downloadUrl ) ) { return "<STR_LIT>" + System . currentTimeMillis ( ) + "<STR_LIT>" ; } else { String appName = downloadUrl . substring ( downloadUrl . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; return appName ; } } public static String getDiskCacheDir ( Context context , String uniqueName ) { String cachePath ; if ( isSDCardEnable ( ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return cachePath + File . separator + uniqueName ; } public static File getDefaultDiskCacheDir ( ) { return FileUtils . getFileByPath ( getDefaultDiskCacheDirPath ( ) ) ; } public static boolean isPrivateApkCacheDir ( @ NonNull UpdateEntity updateEntity ) { return FileUtils . isPrivatePath ( AppSpace . getContext ( ) , updateEntity . getCacheDir ( ) ) ; } public static String getDefaultDiskCacheDirPath ( ) { return UpdateUtils . getDiskCacheDir ( AppSpace . getContext ( ) , KEY_SPA ) ; } private static boolean isSDCardEnable ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) || ! Environment . isExternalStorageRemovable ( ) ; } private static PackageInfo getPackageInfo ( Context context ) { try { return context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return null ; } public static String getAppName ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . applicationInfo . loadLabel ( context . getPackageManager ( ) ) . toString ( ) : "<STR_LIT>" ; } public static Drawable getAppIcon ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . applicationInfo . loadIcon ( context . getPackageManager ( ) ) : null ; } public static boolean isAppOnForeground ( Context context ) { ActivityManager activityManager = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; String packageName = context . getPackageName ( ) ; List < ActivityManager . RunningAppProcessInfo > appProcesses = activityManager . getRunningAppProcesses ( ) ; if ( appProcesses == null ) { return false ; } for ( ActivityManager . RunningAppProcessInfo appProcess : appProcesses ) { if ( appProcess . processName . equals ( packageName ) && appProcess . importance == ActivityManager . RunningAppProcessInfo . IMPORTANCE_FOREGROUND ) { return true ; } } return false ; } public static boolean isMainThread ( ) { return Looper . getMainLooper ( ) == Looper . myLooper ( ) ; } public static boolean startActivity ( final Intent intent ) { if ( intent == null ) { UpdateLog . e ( "<STR_LIT>" ) ; return false ; } if ( AppSpace . getContext ( ) . getPackageManager ( ) . resolveActivity ( intent , PackageManager . MATCH_DEFAULT_ONLY ) != null ) { try { intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; AppSpace . getContext ( ) . startActivity ( intent ) ; return true ; } catch ( ActivityNotFoundException e ) { e . printStackTrace ( ) ; UpdateLog . e ( e ) ; } } else { UpdateLog . e ( "<STR_LIT>" + ( intent . getComponent ( ) != null ? intent . getComponent ( ) . getClassName ( ) : intent . getAction ( ) ) + "<STR_LIT>" ) ; } return false ; } } </s>
<s> package com . appspa . update . logs ; import androidx . annotation . NonNull ; import android . util . Log ; import java . io . PrintWriter ; import java . io . StringWriter ; public class LogcatLogger implements ILogger { private static final int MAX_LOG_LENGTH = <NUM_LIT> ; @ Override public void log ( int priority , String tag , String message , Throwable t ) { if ( message != null && message . length ( ) == <NUM_LIT> ) { message = null ; } if ( message == null ) { if ( t == null ) { return ; } message = getStackTraceString ( t ) ; } else { if ( t != null ) { message += "<STR_LIT>" + getStackTraceString ( t ) ; } } log ( priority , tag , message ) ; } private String getStackTraceString ( Throwable t ) { StringWriter sw = new StringWriter ( <NUM_LIT> ) ; PrintWriter pw = new PrintWriter ( sw , false ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; return sw . toString ( ) ; } public void log ( int priority , String tag , String message ) { int subNum = message . length ( ) / MAX_LOG_LENGTH ; if ( subNum > <NUM_LIT> ) { int index = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < subNum ; i ++ ) { int lastIndex = index + MAX_LOG_LENGTH ; String sub = message . substring ( index , lastIndex ) ; logSub ( priority , tag , sub ) ; index = lastIndex ; } logSub ( priority , tag , message . substring ( index , message . length ( ) ) ) ; } else { logSub ( priority , tag , message ) ; } } private void logSub ( int priority , @ NonNull String tag , @ NonNull String sub ) { switch ( priority ) { case Log . VERBOSE : Log . v ( tag , sub ) ; break ; case Log . DEBUG : Log . d ( tag , sub ) ; break ; case Log . INFO : Log . i ( tag , sub ) ; break ; case Log . WARN : Log . w ( tag , sub ) ; break ; case Log . ERROR : Log . e ( tag , sub ) ; break ; case Log . ASSERT : Log . wtf ( tag , sub ) ; break ; default : Log . v ( tag , sub ) ; break ; } } } </s>
<s> package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; public class PromptEntity implements Parcelable { @ ColorInt private int mThemeColor ; @ DrawableRes private int mTopResId ; private String mTopDrawableTag ; @ ColorInt private int mButtonTextColor ; private boolean mSupportBackgroundUpdate ; private float mWidthRatio ; private float mHeightRatio ; private boolean mIgnoreDownloadError ; public PromptEntity ( ) { mThemeColor = - <NUM_LIT> ; mTopResId = - <NUM_LIT> ; mTopDrawableTag = "<STR_LIT>" ; mButtonTextColor = <NUM_LIT> ; mSupportBackgroundUpdate = false ; mWidthRatio = - <NUM_LIT> ; mHeightRatio = - <NUM_LIT> ; mIgnoreDownloadError = false ; } protected PromptEntity ( Parcel in ) { mThemeColor = in . readInt ( ) ; mTopResId = in . readInt ( ) ; mTopDrawableTag = in . readString ( ) ; mButtonTextColor = in . readInt ( ) ; mSupportBackgroundUpdate = in . readByte ( ) != <NUM_LIT> ; mWidthRatio = in . readFloat ( ) ; mHeightRatio = in . readFloat ( ) ; mIgnoreDownloadError = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < PromptEntity > CREATOR = new Creator < PromptEntity > ( ) { @ Override public PromptEntity createFromParcel ( Parcel in ) { return new PromptEntity ( in ) ; } @ Override public PromptEntity [ ] newArray ( int size ) { return new PromptEntity [ size ] ; } } ; public int getThemeColor ( ) { return mThemeColor ; } public PromptEntity setThemeColor ( int themeColor ) { mThemeColor = themeColor ; return this ; } public int getTopResId ( ) { return mTopResId ; } public PromptEntity setTopResId ( int topResId ) { mTopResId = topResId ; return this ; } public String getTopDrawableTag ( ) { return mTopDrawableTag ; } public PromptEntity setTopDrawableTag ( String topDrawableTag ) { mTopDrawableTag = topDrawableTag ; return this ; } public int getButtonTextColor ( ) { return mButtonTextColor ; } public PromptEntity setButtonTextColor ( int buttonTextColor ) { mButtonTextColor = buttonTextColor ; return this ; } public boolean isSupportBackgroundUpdate ( ) { return mSupportBackgroundUpdate ; } public PromptEntity setSupportBackgroundUpdate ( boolean supportBackgroundUpdate ) { mSupportBackgroundUpdate = supportBackgroundUpdate ; return this ; } public PromptEntity setWidthRatio ( float widthRatio ) { mWidthRatio = widthRatio ; return this ; } public float getWidthRatio ( ) { return mWidthRatio ; } public PromptEntity setHeightRatio ( float heightRatio ) { mHeightRatio = heightRatio ; return this ; } public float getHeightRatio ( ) { return mHeightRatio ; } public PromptEntity setIgnoreDownloadError ( boolean ignoreDownloadError ) { mIgnoreDownloadError = ignoreDownloadError ; return this ; } public boolean isIgnoreDownloadError ( ) { return mIgnoreDownloadError ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mThemeColor + "<STR_LIT>" + mTopResId + "<STR_LIT>" + mTopDrawableTag + "<STR_LIT>" + mButtonTextColor + "<STR_LIT>" + mSupportBackgroundUpdate + "<STR_LIT>" + mWidthRatio + "<STR_LIT>" + mHeightRatio + "<STR_LIT>" + mIgnoreDownloadError + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mThemeColor ) ; dest . writeInt ( mTopResId ) ; dest . writeString ( mTopDrawableTag ) ; dest . writeInt ( mButtonTextColor ) ; dest . writeByte ( ( byte ) ( mSupportBackgroundUpdate ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeFloat ( mWidthRatio ) ; dest . writeFloat ( mHeightRatio ) ; dest . writeByte ( ( byte ) ( mIgnoreDownloadError ? <NUM_LIT> : <NUM_LIT> ) ) ; } } </s>
<s> package com . appspa . update . utils ; public class PatchUtils { static { System . loadLibrary ( "<STR_LIT>" ) ; } public static native int patch ( String oldApkPath , String newApkPath , String patchPath ) ; } </s>
<s> package com . appspa . demo ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } } </s>
<s> package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import java . util . Map ; public interface IUpdateChecker { void onBeforeCheck ( ) ; void checkVersion ( boolean isGet , @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull IUpdateProxy updateProxy ) ; void onAfterCheck ( ) ; void processCheckResult ( @ NonNull String result , @ NonNull IUpdateProxy updateProxy ) ; void noNewVersion ( Throwable throwable ) ; } </s>
<s> package com . appspa . update . listener . impl ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . utils . ApkUtils ; import java . io . File ; import java . io . IOException ; public class DefaultInstallListener implements OnInstallListener { @ Override public boolean onInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) { if ( checkApkFile ( downloadEntity , apkFile ) ) { return installApkFile ( context , apkFile ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , "<STR_LIT>" ) ; return false ; } } protected boolean checkApkFile ( DownloadEntity downloadEntity , @ NonNull File apkFile ) { return downloadEntity != null && _AppSpace . isFileValid ( downloadEntity . getWholeMd5 ( ) , apkFile ) ; } protected boolean installApkFile ( Context context , File apkFile ) { try { return ApkUtils . install ( context , apkFile ) ; } catch ( IOException e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , "<STR_LIT>" + e . getMessage ( ) ) ; } return false ; } @ Override public void onInstallApkSuccess ( ) { } } </s>
<s> package com . appspa . update . utils ; import androidx . core . content . FileProvider ; public class UpdateFileProvider extends FileProvider { } </s>
<s> package com . appspa . demo . utils ; import android . content . Context ; import com . appspa . demo . R ; public class SettingSPUtils { private static SettingSPUtils sInstance ; private SettingSPUtils ( ) { } public static SettingSPUtils get ( ) { if ( sInstance == null ) { synchronized ( SettingSPUtils . class ) { if ( sInstance == null ) { sInstance = new SettingSPUtils ( ) ; } } } return sInstance ; } public String getServiceURL ( ) { return "<STR_LIT>" ; } public boolean setServiceURL ( String apiUrl ) { return true ; } } </s>
<s> package com . appspa . update . utils ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . res . AssetFileDescriptor ; import android . database . Cursor ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . provider . MediaStore ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RequiresApi ; import androidx . core . content . FileProvider ; import com . appspa . update . AppSpace ; import java . io . Closeable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public final class FileUtils { public static final String MODE_READ_ONLY = "<STR_LIT>" ; private static final String EXT_STORAGE_PATH = getExtStoragePath ( ) ; private static final String EXT_STORAGE_DIR = EXT_STORAGE_PATH + File . separator ; private static final String APP_EXT_STORAGE_PATH = EXT_STORAGE_DIR + "<STR_LIT>" ; private static final String EXT_DOWNLOADS_PATH = getExtDownloadsPath ( ) ; private static final String EXT_PICTURES_PATH = getExtPicturesPath ( ) ; private static final String EXT_DCIM_PATH = getExtDCIMPath ( ) ; private FileUtils ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } @ Nullable public static File getFileByPath ( final String filePath ) { return isSpace ( filePath ) ? null : new File ( filePath ) ; } public static boolean isFileExists ( final File file ) { if ( file == null ) { return false ; } if ( file . exists ( ) ) { return true ; } return isFileExists ( file . getAbsolutePath ( ) ) ; } public static boolean isFileExists ( final String filePath ) { File file = getFileByPath ( filePath ) ; if ( file == null ) { return false ; } if ( file . exists ( ) ) { return true ; } return isFileExistsApi29 ( filePath ) ; } private static boolean isFileExistsApi29 ( String filePath ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { AssetFileDescriptor afd = null ; try { Uri uri = Uri . parse ( filePath ) ; afd = openAssetFileDescriptor ( uri ) ; if ( afd == null ) { return false ; } else { closeIOQuietly ( afd ) ; } } catch ( FileNotFoundException e ) { return false ; } finally { closeIOQuietly ( afd ) ; } return true ; } return false ; } public static InputStream getFileInputStream ( File file ) throws FileNotFoundException { if ( isScopedStorageMode ( ) ) { return getContentResolver ( ) . openInputStream ( getUriByFile ( file ) ) ; } else { return new FileInputStream ( file ) ; } } public static Uri getUriByFile ( final File file ) { if ( file == null ) { return null ; } if ( isScopedStorageMode ( ) && isPublicPath ( file ) ) { String filePath = file . getAbsolutePath ( ) ; if ( filePath . startsWith ( EXT_DOWNLOADS_PATH ) ) { return getDownloadContentUri ( AppSpace . getContext ( ) , file ) ; } else if ( filePath . startsWith ( EXT_PICTURES_PATH ) || filePath . startsWith ( EXT_DCIM_PATH ) ) { return getMediaContentUri ( AppSpace . getContext ( ) , file ) ; } else { return getUriForFile ( file ) ; } } else { return getUriForFile ( file ) ; } } @ Nullable public static Uri getUriForFile ( final File file ) { if ( file == null ) { return null ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { String authority = AppSpace . getContext ( ) . getPackageName ( ) + "<STR_LIT>" ; return FileProvider . getUriForFile ( AppSpace . getContext ( ) , authority , file ) ; } else { return Uri . fromFile ( file ) ; } } public static boolean isScopedStorageMode ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q && ! Environment . isExternalStorageLegacy ( ) ; } public static Uri getMediaContentUri ( Context context , File mediaFile ) { String filePath = mediaFile . getAbsolutePath ( ) ; Uri baseUri = MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; Cursor cursor = context . getContentResolver ( ) . query ( baseUri , new String [ ] { MediaStore . Images . Media . _ID } , MediaStore . Images . Media . DATA + "<STR_LIT>" , new String [ ] { filePath } , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { int id = cursor . getInt ( cursor . getColumnIndex ( MediaStore . MediaColumns . _ID ) ) ; cursor . close ( ) ; return Uri . withAppendedPath ( baseUri , "<STR_LIT>" + id ) ; } else { if ( mediaFile . exists ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( MediaStore . Images . Media . DATA , filePath ) ; return context . getContentResolver ( ) . insert ( baseUri , values ) ; } return null ; } } @ RequiresApi ( api = Build . VERSION_CODES . Q ) public static Uri getDownloadContentUri ( Context context , File file ) { String filePath = file . getAbsolutePath ( ) ; Uri baseUri = MediaStore . Downloads . EXTERNAL_CONTENT_URI ; Cursor cursor = context . getContentResolver ( ) . query ( baseUri , new String [ ] { MediaStore . Downloads . _ID } , MediaStore . Downloads . DATA + "<STR_LIT>" , new String [ ] { filePath } , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { int id = cursor . getInt ( cursor . getColumnIndex ( MediaStore . DownloadColumns . _ID ) ) ; cursor . close ( ) ; return Uri . withAppendedPath ( baseUri , "<STR_LIT>" + id ) ; } else { if ( file . exists ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( MediaStore . Downloads . DATA , filePath ) ; return context . getContentResolver ( ) . insert ( baseUri , values ) ; } return null ; } } public static boolean isPrivatePath ( @ NonNull Context context , @ NonNull String path ) { if ( isSpace ( path ) ) { return false ; } String appIntPath = getAppIntPath ( context ) ; String appExtPath = getAppExtPath ( context ) ; return ( ! TextUtils . isEmpty ( appIntPath ) && path . startsWith ( appIntPath ) ) || ( ! TextUtils . isEmpty ( appExtPath ) && path . startsWith ( appExtPath ) ) ; } public static boolean isPublicPath ( File file ) { if ( file == null ) { return false ; } try { return isPublicPath ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } public static boolean isPublicPath ( String filePath ) { if ( isSpace ( filePath ) ) { return false ; } return filePath . startsWith ( EXT_STORAGE_PATH ) && ! filePath . startsWith ( APP_EXT_STORAGE_PATH ) ; } private static boolean isSpace ( final String s ) { if ( s == null ) { return true ; } for ( int i = <NUM_LIT> , len = s . length ( ) ; i < len ; ++ i ) { if ( ! Character . isWhitespace ( s . charAt ( i ) ) ) { return false ; } } return true ; } public static void closeIOQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return ; } for ( Closeable closeable : closeables ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException ignored ) { } } } } public static AssetFileDescriptor openAssetFileDescriptor ( Uri uri ) throws FileNotFoundException { return getContentResolver ( ) . openAssetFileDescriptor ( uri , MODE_READ_ONLY ) ; } private static ContentResolver getContentResolver ( ) { return AppSpace . getContext ( ) . getContentResolver ( ) ; } public static String getExtStoragePath ( ) { return Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) ; } public static String getExtDownloadsPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) . getAbsolutePath ( ) ; } public static String getExtPicturesPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_PICTURES ) . getAbsolutePath ( ) ; } public static String getExtDCIMPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DCIM ) . getAbsolutePath ( ) ; } public static String getAppIntPath ( @ NonNull Context context ) { File appIntCacheFile = context . getCacheDir ( ) ; if ( appIntCacheFile != null ) { String appIntCachePath = appIntCacheFile . getAbsolutePath ( ) ; return getDirName ( appIntCachePath ) ; } return null ; } public static String getAppExtPath ( @ NonNull Context context ) { File appExtCacheFile = context . getExternalCacheDir ( ) ; if ( appExtCacheFile != null ) { String appExtCachePath = appExtCacheFile . getAbsolutePath ( ) ; return getDirName ( appExtCachePath ) ; } return null ; } public static String getDirName ( final String filePath ) { if ( isSpace ( filePath ) ) { return filePath ; } int lastSep = filePath . lastIndexOf ( File . separator ) ; return lastSep == - <NUM_LIT> ? "<STR_LIT>" : filePath . substring ( <NUM_LIT> , lastSep + <NUM_LIT> ) ; } } </s>
<s> package com . appspa . update . widget ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . util . DisplayMetrics ; import android . view . Gravity ; import android . view . KeyEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import com . appspa . update . R ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; import static com . appspa . update . entity . UpdateError . ERROR . DOWNLOAD_PERMISSION_DENIED ; import static com . appspa . update . widget . UpdateDialogFragment . KEY_UPDATE_ENTITY ; import static com . appspa . update . widget . UpdateDialogFragment . KEY_UPDATE_PROMPT_ENTITY ; import static com . appspa . update . widget . UpdateDialogFragment . REQUEST_CODE_REQUEST_PERMISSIONS ; public class UpdateDialogActivity extends AppCompatActivity implements View . OnClickListener , IDownloadEventHandler { private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private static IPrompterProxy sIPrompterProxy ; private PromptEntity mPromptEntity ; public static void show ( @ NonNull Context context , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , @ NonNull PromptEntity promptEntity ) { Intent intent = new Intent ( context , UpdateDialogActivity . class ) ; intent . putExtra ( KEY_UPDATE_ENTITY , updateEntity ) ; intent . putExtra ( KEY_UPDATE_PROMPT_ENTITY , promptEntity ) ; if ( ! ( context instanceof Activity ) ) { intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; } setIPrompterProxy ( prompterProxy ) ; context . startActivity ( intent ) ; } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . spa_layout_update_prompter ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; initView ( ) ; initData ( ) ; } private void initView ( ) { mIvTop = findViewById ( R . id . iv_top ) ; mTvTitle = findViewById ( R . id . tv_title ) ; mTvUpdateInfo = findViewById ( R . id . tv_update_info ) ; mBtnUpdate = findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = findViewById ( R . id . btn_background_update ) ; mTvIgnore = findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = findViewById ( R . id . npb_progress ) ; mLlClose = findViewById ( R . id . ll_close ) ; mIvClose = findViewById ( R . id . iv_close ) ; } private void initData ( ) { Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle == null ) { return ; } mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } initTheme ( mPromptEntity . getThemeColor ( ) , mPromptEntity . getTopResId ( ) , mPromptEntity . getButtonTextColor ( ) ) ; mUpdateEntity = bundle . getParcelable ( KEY_UPDATE_ENTITY ) ; if ( mUpdateEntity != null ) { initUpdateInfo ( mUpdateEntity ) ; initListeners ( ) ; } } private PromptEntity getPromptEntity ( ) { if ( mPromptEntity == null ) { Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle != null ) { mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; } } if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } return mPromptEntity ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( this , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( this , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , this ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , this ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; } private void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; } @ Override public void onStart ( ) { super . onStart ( ) ; initWindowStyle ( ) ; } private void initWindowStyle ( ) { Window window = getWindow ( ) ; if ( window != null ) { PromptEntity promptEntity = getPromptEntity ( ) ; window . setGravity ( Gravity . CENTER ) ; WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getResources ( ) . getDisplayMetrics ( ) ; if ( promptEntity . getWidthRatio ( ) > <NUM_LIT> && promptEntity . getWidthRatio ( ) < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * promptEntity . getWidthRatio ( ) ) ; } if ( promptEntity . getHeightRatio ( ) > <NUM_LIT> && promptEntity . getHeightRatio ( ) < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * promptEntity . getHeightRatio ( ) ) ; } window . setAttributes ( lp ) ; } } @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { return keyCode == KeyEvent . KEYCODE_BACK ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( this , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . backgroundDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . iv_close ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . cancelDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( this , mUpdateEntity . getVersionName ( ) ) ; dismissDialog ( ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == REQUEST_CODE_REQUEST_PERMISSIONS ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { installApp ( ) ; } else { _AppSpace . onUpdateError ( DOWNLOAD_PERMISSION_DENIED ) ; dismissDialog ( ) ; } } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismissDialog ( ) ; } else { showInstallButton ( ) ; } } else { if ( sIPrompterProxy != null ) { sIPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( ! isFinishing ( ) ) { doStart ( ) ; } } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( ! isFinishing ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( ! isFinishing ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismissDialog ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( ! isFinishing ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismissDialog ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( this , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } private void dismissDialog ( ) { finish ( ) ; } @ Override protected void onStop ( ) { if ( isFinishing ( ) ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; } super . onStop ( ) ; } private static void setIPrompterProxy ( IPrompterProxy prompterProxy ) { UpdateDialogActivity . sIPrompterProxy = prompterProxy ; } private static void clearIPrompterProxy ( ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . recycle ( ) ; sIPrompterProxy = null ; } } private String getUrl ( ) { return sIPrompterProxy != null ? sIPrompterProxy . getUrl ( ) : "<STR_LIT>" ; } } </s>
<s> package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import com . appspa . update . utils . Md5Utils ; import com . appspa . update . proxy . IFileEncryptor ; import java . io . File ; public class DefaultFileEncryptor implements IFileEncryptor { @ Override public String encryptFile ( File file ) { return Md5Utils . getFileMD5 ( file ) ; } @ Override public boolean isFileValid ( String encrypt , File file ) { return TextUtils . isEmpty ( encrypt ) || encrypt . equalsIgnoreCase ( encryptFile ( file ) ) ; } } </s>
<s> package com . appspa . update . listener ; import com . appspa . update . entity . UpdateEntity ; public interface IUpdateParseCallback { void onParseResult ( UpdateEntity updateEntity ) ; } </s>
<s> package com . appspa . update . entity ; import android . content . Context ; import android . text . TextUtils ; import android . util . SparseArray ; import com . appspa . update . R ; public class UpdateError extends Throwable { private final int mCode ; public UpdateError ( int code ) { this ( code , null ) ; } public UpdateError ( int code , String message ) { super ( make ( code , message ) ) ; mCode = code ; } public UpdateError ( Throwable e ) { super ( e ) ; mCode = ERROR . UPDATE_UNKNOWN ; } public int getCode ( ) { return mCode ; } @ Override public String toString ( ) { return getMessage ( ) ; } private static String make ( int code , String message ) { String m = sMessages . get ( code ) ; if ( TextUtils . isEmpty ( m ) ) { return "<STR_LIT>" ; } if ( TextUtils . isEmpty ( message ) || message . equals ( "<STR_LIT>" ) ) { return m ; } return m + "<STR_LIT>" + message + "<STR_LIT>" ; } public String getDetailMsg ( ) { return "<STR_LIT>" + mCode + "<STR_LIT>" + getMessage ( ) ; } public final static class ERROR { public static final int CHECK_NET_REQUEST = <NUM_LIT> ; public static final int CHECK_NO_WIFI = CHECK_NET_REQUEST + <NUM_LIT> ; public static final int CHECK_NO_NETWORK = CHECK_NO_WIFI + <NUM_LIT> ; public static final int CHECK_UPDATING = CHECK_NO_NETWORK + <NUM_LIT> ; public static final int CHECK_NO_NEW_VERSION = CHECK_UPDATING + <NUM_LIT> ; public static final int CHECK_JSON_EMPTY = CHECK_NO_NEW_VERSION + <NUM_LIT> ; public static final int CHECK_PARSE = CHECK_JSON_EMPTY + <NUM_LIT> ; public static final int CHECK_IGNORED_VERSION = CHECK_PARSE + <NUM_LIT> ; public static final int CHECK_APK_CACHE_DIR_EMPTY = CHECK_IGNORED_VERSION + <NUM_LIT> ; public static final int PROMPT_UNKNOWN = <NUM_LIT> ; public static final int PROMPT_ACTIVITY_DESTROY = PROMPT_UNKNOWN + <NUM_LIT> ; public static final int DOWNLOAD_FAILED = <NUM_LIT> ; public static final int DOWNLOAD_PERMISSION_DENIED = DOWNLOAD_FAILED + <NUM_LIT> ; public static final int INSTALL_FAILED = <NUM_LIT> ; public static final int FAIL_OLD_MD5 = <NUM_LIT> ; public static final int FAIL_GEN_MD5 = <NUM_LIT> ; public static final int FAIL_PATCH = <NUM_LIT> ; public static final int FAIL_GET_SOURCE = <NUM_LIT> ; public static final int UPDATE_UNKNOWN = <NUM_LIT> ; } private static final SparseArray < String > sMessages = new SparseArray < > ( ) ; public static void init ( Context context ) { sMessages . append ( ERROR . CHECK_NET_REQUEST , context . getString ( R . string . space_error_check_net_request ) ) ; sMessages . append ( ERROR . CHECK_NO_WIFI , context . getString ( R . string . space_error_check_no_wifi ) ) ; sMessages . append ( ERROR . CHECK_NO_NETWORK , context . getString ( R . string . space_error_check_no_network ) ) ; sMessages . append ( ERROR . CHECK_UPDATING , context . getString ( R . string . space_error_check_updating ) ) ; sMessages . append ( ERROR . CHECK_NO_NEW_VERSION , context . getString ( R . string . space_error_check_no_new_version ) ) ; sMessages . append ( ERROR . CHECK_JSON_EMPTY , context . getString ( R . string . space_error_check_json_empty ) ) ; sMessages . append ( ERROR . CHECK_PARSE , context . getString ( R . string . space_error_check_parse ) ) ; sMessages . append ( ERROR . CHECK_IGNORED_VERSION , context . getString ( R . string . space_error_check_ignored_version ) ) ; sMessages . append ( ERROR . CHECK_APK_CACHE_DIR_EMPTY , context . getString ( R . string . space_error_check_apk_cache_dir_empty ) ) ; sMessages . append ( ERROR . PROMPT_UNKNOWN , context . getString ( R . string . space_error_prompt_unknown ) ) ; sMessages . append ( ERROR . PROMPT_ACTIVITY_DESTROY , context . getString ( R . string . space_error_prompt_activity_destroy ) ) ; sMessages . append ( ERROR . DOWNLOAD_FAILED , context . getString ( R . string . space_error_download_failed ) ) ; sMessages . append ( ERROR . DOWNLOAD_PERMISSION_DENIED , context . getString ( R . string . space_error_download_permission_denied ) ) ; sMessages . append ( ERROR . INSTALL_FAILED , context . getString ( R . string . space_error_install_failed ) ) ; } } </s>
<s> package com . appspa . demo ; import android . app . Application ; import android . widget . Toast ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . utils . UpdateUtils ; import com . appspa . demo . http . OKHttpUpdateHttpService ; import com . zhy . http . okhttp . OkHttpUtils ; import java . util . concurrent . TimeUnit ; import okhttp3 . OkHttpClient ; public class App extends Application { @ Override public void onCreate ( ) { super . onCreate ( ) ; initOKHttpUtils ( ) ; initUpdate ( ) ; } private void initUpdate ( ) { AppSpace . get ( ) . debug ( true ) . isWifiOnly ( false ) . isGet ( true ) . isAutoMode ( false ) . param ( "<STR_LIT>" , UpdateUtils . getBaseApkMd5 ( this ) ) . param ( "<STR_LIT>" , UpdateUtils . getVersionCode ( this ) ) . param ( "<STR_LIT>" , "<STR_LIT>" ) . setOnUpdateFailureListener ( new OnUpdateFailureListener ( ) { @ Override public void onFailure ( com . appspa . update . entity . UpdateError error ) { error . printStackTrace ( ) ; if ( error . getCode ( ) != UpdateError . ERROR . CHECK_NO_NEW_VERSION ) { Toast . makeText ( App . this , error . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) . supportSilentInstall ( false ) . setIUpdateHttpService ( new OKHttpUpdateHttpService ( ) ) . init ( this ) ; } private void initOKHttpUtils ( ) { OkHttpClient okHttpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , TimeUnit . MILLISECONDS ) . readTimeout ( <NUM_LIT> , TimeUnit . MILLISECONDS ) . build ( ) ; OkHttpUtils . initClient ( okHttpClient ) ; } } </s>
<s> package com . appspa . update . listener . impl ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . UpdateLog ; public class DefaultUpdateFailureListener implements OnUpdateFailureListener { @ Override public void onFailure ( UpdateError error ) { UpdateLog . e ( error ) ; } } </s>
<s> package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; public interface IUpdatePrompter { void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . bean ; public class FileTransferEvent implements DevicesInterface { public static final int STATE_DOWNLOAD = <NUM_LIT> ; public static final int STATE_UPLOAD = <NUM_LIT> ; public static final int STATE_OVER = <NUM_LIT> ; protected int state ; protected int device ; protected String desc ; public FileTransferEvent ( int state , int device , String desc ) { this . state = state ; this . device = device ; this . desc = desc ; } public FileTransferEvent ( ) { } public int getState ( ) { return state ; } public int getDevice ( ) { return device ; } public String getDesc ( ) { return desc ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferredBytesInfo ; public class ParcelableTransferredBytesInfo extends TransferredBytesInfo implements Parcelable { public ParcelableTransferredBytesInfo ( TransferredBytesInfo info ) { super ( info . getUsbReceiveBytes ( ) , info . getUsbSentBytes ( ) , info . getWifiReceiveBytes ( ) , info . getWifiSentBytes ( ) ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeLong ( this . usbReceiveBytes ) ; dest . writeLong ( this . usbSentBytes ) ; dest . writeLong ( this . wifiReceiveBytes ) ; dest . writeLong ( this . wifiSentBytes ) ; } public void readFromParcel ( Parcel source ) { this . usbReceiveBytes = source . readLong ( ) ; this . usbSentBytes = source . readLong ( ) ; this . wifiReceiveBytes = source . readLong ( ) ; this . wifiSentBytes = source . readLong ( ) ; } protected ParcelableTransferredBytesInfo ( Parcel in ) { super ( in . readLong ( ) , in . readLong ( ) , in . readLong ( ) , in . readLong ( ) ) ; } public static final Creator < ParcelableTransferredBytesInfo > CREATOR = new Creator < ParcelableTransferredBytesInfo > ( ) { @ Override public ParcelableTransferredBytesInfo createFromParcel ( Parcel source ) { return new ParcelableTransferredBytesInfo ( source ) ; } @ Override public ParcelableTransferredBytesInfo [ ] newArray ( int size ) { return new ParcelableTransferredBytesInfo [ size ] ; } } ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . core ; import java . io . IOException ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . Socket ; import java . net . UnknownHostException ; import top . weixiansen574 . hybridfilexfer . core . threads . ClientControllerThread ; import top . weixiansen574 . hybridfilexfer . core . threads . ReceiveThread ; public class FileTransferClient implements ServerInfo { ClientControllerThread controllerThread ; public void startUp ( ) { controllerThread = new ClientControllerThread ( ) ; controllerThread . start ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import android . content . DialogInterface ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public class RemoteBookmarkAdapter extends BookmarkAdapter { private final IIServiceFileSelectAdapter adapter ; private final List < BookMark > bookMarks ; private final ConfigDB db ; public RemoteBookmarkAdapter ( Context context , DialogInterface dialog , IIServiceFileSelectAdapter adapter , ConfigDB db ) { super ( context , dialog ) ; this . db = db ; this . bookMarks = db . getAllRemoteBookmark ( ) ; this . adapter = adapter ; } @ Override protected boolean onDelete ( BookMark bookMark ) { boolean success = db . removeRemoteBookmark ( bookMark . id ) > <NUM_LIT> ; if ( success ) { bookMarks . remove ( bookMark ) ; } return success ; } @ Override protected BookMark getItem ( int position ) { return bookMarks . get ( position ) ; } @ Override protected void onItemClick ( BookMark bookMark ) { adapter . cd ( bookMark . path ) ; } @ Override public int getItemCount ( ) { return bookMarks . size ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public abstract class BookmarkAdapter extends RecyclerView . Adapter < BookmarkAdapter . MyViewHolder > { public Context context ; public DialogInterface dialog ; public BookmarkAdapter ( Context context , DialogInterface dialog ) { this . context = context ; this . dialog = dialog ; } @ NonNull @ Override public MyViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new MyViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_bookmark , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull MyViewHolder holder , int position ) { BookMark item = getItem ( position ) ; holder . fileName . setText ( item . path ) ; holder . itemView . setOnClickListener ( v -> { onItemClick ( item ) ; dialog . dismiss ( ) ; } ) ; holder . itemView . setOnLongClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + item . path + "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , null ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { if ( onDelete ( item ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; notifyItemRemoved ( holder . getAdapterPosition ( ) ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return true ; } ) ; } protected abstract boolean onDelete ( BookMark bookMark ) ; protected abstract BookMark getItem ( int position ) ; protected abstract void onItemClick ( BookMark bookMark ) ; public static class MyViewHolder extends RecyclerView . ViewHolder { TextView fileName ; public MyViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; fileName = itemView . findViewById ( R . id . file_name ) ; } } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . threads ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . DevicesInterface ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public abstract class TransferThread extends Thread implements DevicesInterface { protected long transferredBytes ; protected final BlockingDeque < FileTransferEvent > events ; public final int device ; protected OnExceptionListener onExceptionListener ; public TransferThread ( BlockingDeque < FileTransferEvent > events , int device ) { this . events = events ; this . device = device ; } public long getAndResetTransferredBytes ( ) { long bytes = transferredBytes ; transferredBytes = <NUM_LIT> ; return bytes ; } protected void addEvent ( int state , String desc ) { if ( events != null ) { events . add ( new FileTransferEvent ( state , device , desc ) ) ; } } public void setOnExceptionListener ( OnExceptionListener onExceptionListener ) { this . onExceptionListener = onExceptionListener ; } public interface OnExceptionListener { void onException ( Exception e ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import java . io . File ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; public class ParcelableRemoteFile extends RemoteFile implements Parcelable { public ParcelableRemoteFile ( File file ) { super ( file ) ; } public ParcelableRemoteFile ( RemoteFile remoteFile ) { super ( remoteFile ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( this . name ) ; dest . writeString ( this . path ) ; dest . writeLong ( this . lastModified ) ; dest . writeLong ( this . size ) ; dest . writeByte ( this . isDirectory ? ( byte ) <NUM_LIT> : ( byte ) <NUM_LIT> ) ; } public void readFromParcel ( Parcel source ) { this . name = source . readString ( ) ; this . path = source . readString ( ) ; this . lastModified = source . readLong ( ) ; this . size = source . readLong ( ) ; this . isDirectory = source . readByte ( ) != <NUM_LIT> ; } protected ParcelableRemoteFile ( Parcel in ) { this . name = in . readString ( ) ; this . path = in . readString ( ) ; this . lastModified = in . readLong ( ) ; this . size = in . readLong ( ) ; this . isDirectory = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < ParcelableRemoteFile > CREATOR = new Creator < ParcelableRemoteFile > ( ) { @ Override public ParcelableRemoteFile createFromParcel ( Parcel source ) { return new ParcelableRemoteFile ( source ) ; } @ Override public ParcelableRemoteFile [ ] newArray ( int size ) { return new ParcelableRemoteFile [ size ] ; } } ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . core ; public interface ServerInfo { int PORT_CONTROLLER = <NUM_LIT> ; int PORT_USB = <NUM_LIT> ; int PORT_WIFI = <NUM_LIT> ; int 酷安飞机杯 = <NUM_LIT> ; int 晨钟酱操飞机杯 = <NUM_LIT> ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . NonNull ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ParcelableFileTransferEvent extends FileTransferEvent implements Parcelable { public ParcelableFileTransferEvent ( FileTransferEvent event ) { super ( event . getState ( ) , event . getDevice ( ) , event . getDesc ( ) ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( this . state ) ; dest . writeInt ( this . device ) ; dest . writeString ( this . desc ) ; } public void readFromParcel ( Parcel source ) { this . state = source . readInt ( ) ; this . device = source . readInt ( ) ; this . desc = source . readString ( ) ; } protected ParcelableFileTransferEvent ( Parcel in ) { super ( in . readInt ( ) , in . readInt ( ) , in . readString ( ) ) ; } public static final Creator < ParcelableFileTransferEvent > CREATOR = new Creator < ParcelableFileTransferEvent > ( ) { @ Override public ParcelableFileTransferEvent createFromParcel ( Parcel source ) { return new ParcelableFileTransferEvent ( source ) ; } @ Override public ParcelableFileTransferEvent [ ] newArray ( int size ) { return new ParcelableFileTransferEvent [ size ] ; } } ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . core ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . Closeable ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . net . BindException ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . LinkedBlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferredBytesInfo ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferJob ; import top . weixiansen574 . hybridfilexfer . core . threads . ReceiveThread ; import top . weixiansen574 . hybridfilexfer . core . threads . SendThread ; import top . weixiansen574 . hybridfilexfer . core . threads . TransferThread ; public class FileTransferServer implements ServerInfo , TransferThread . OnExceptionListener { JobPublisher jobPublisher ; Socket socket ; DataInputStream dis ; DataOutputStream dos ; SendThread usbSendThread ; ReceiveThread usbReceiveThread ; SendThread wifiSendThread ; ReceiveThread wifiReceiveThread ; public final BlockingDeque < FileTransferEvent > fileTransferEvents ; ServerSocket controllerSocket ; ServerSocket usbServerSocket ; ServerSocket wifiServerSocket ; public FileTransferServer ( ) { fileTransferEvents = new LinkedBlockingDeque < > ( ) ; } public void startServer ( ) throws IOException { this . jobPublisher = new JobPublisher ( ) ; controllerSocket = new ServerSocket ( ServerInfo . PORT_CONTROLLER ) ; socket = controllerSocket . accept ( ) ; this . dis = new DataInputStream ( socket . getInputStream ( ) ) ; this . dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; short identifier = dis . readShort ( ) ; switch ( identifier ) { case ControllerIdentifiers . GET_WLAN_ADDRESS : handleGetWifiAddress ( ) ; waitPCConnect ( ) ; break ; } } private void handleGetWifiAddress ( ) throws IOException { try { Enumeration < NetworkInterface > networkInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( networkInterfaces . hasMoreElements ( ) ) { NetworkInterface networkInterface = networkInterfaces . nextElement ( ) ; Enumeration < InetAddress > inetAddresses = networkInterface . getInetAddresses ( ) ; while ( inetAddresses . hasMoreElements ( ) ) { InetAddress inetAddress = inetAddresses . nextElement ( ) ; if ( ! inetAddress . isLoopbackAddress ( ) && inetAddress instanceof Inet4Address ) { String interfaceName = networkInterface . getName ( ) ; if ( interfaceName . contains ( "<STR_LIT>" ) ) { System . out . println ( "<STR_LIT>" + networkInterface . getName ( ) ) ; System . out . println ( "<STR_LIT>" + inetAddress . getHostAddress ( ) ) ; dos . write ( inetAddress . getAddress ( ) ) ; return ; } } } } dos . write ( new byte [ <NUM_LIT> ] ) ; } catch ( SocketException ex ) { ex . printStackTrace ( ) ; } } private void waitPCConnect ( ) throws IOException { usbServerSocket = new ServerSocket ( ServerInfo . PORT_USB ) ; wifiServerSocket = new ServerSocket ( ServerInfo . PORT_WIFI ) ; Socket usbSocket = usbServerSocket . accept ( ) ; System . out . println ( "<STR_LIT>" ) ; Socket wifiSocket = wifiServerSocket . accept ( ) ; System . out . println ( "<STR_LIT>" ) ; usbSendThread = new SendThread ( fileTransferEvents , SendThread . DEVICE_USB , jobPublisher , usbSocket . getOutputStream ( ) ) ; usbSendThread . setOnExceptionListener ( this ) ; usbSendThread . setName ( "<STR_LIT>" ) ; usbSendThread . start ( ) ; usbReceiveThread = new ReceiveThread ( fileTransferEvents , ReceiveThread . DEVICE_USB , usbSocket . getInputStream ( ) ) ; usbReceiveThread . setOnExceptionListener ( this ) ; usbReceiveThread . setName ( "<STR_LIT>" ) ; usbReceiveThread . start ( ) ; wifiSendThread = new SendThread ( fileTransferEvents , SendThread . DEVICE_WIFI , jobPublisher , wifiSocket . getOutputStream ( ) ) ; wifiSendThread . setOnExceptionListener ( this ) ; wifiSendThread . setName ( "<STR_LIT>" ) ; wifiSendThread . start ( ) ; wifiReceiveThread = new ReceiveThread ( fileTransferEvents , ReceiveThread . DEVICE_WIFI , wifiSocket . getInputStream ( ) ) ; wifiReceiveThread . setName ( "<STR_LIT>" ) ; wifiReceiveThread . setOnExceptionListener ( this ) ; wifiReceiveThread . start ( ) ; } public ArrayList < RemoteFile > listClientFiles ( String path ) throws IOException { dos . writeShort ( ControllerIdentifiers . LIST_FILES ) ; dos . writeUTF ( path ) ; int listSize = dis . readInt ( ) ; ArrayList < RemoteFile > remoteFiles = new ArrayList < > ( listSize ) ; for ( int i = <NUM_LIT> ; i < listSize ; i ++ ) { RemoteFile remoteFile = new RemoteFile ( dis . readUTF ( ) , dis . readUTF ( ) , dis . readLong ( ) , dis . readLong ( ) , dis . readBoolean ( ) ) ; remoteFiles . add ( remoteFile ) ; } return remoteFiles ; } public void transferToMe ( List < String > files , String remoteDir , String localDir ) throws IOException { dos . writeShort ( ControllerIdentifiers . TRANSPORT_FILES ) ; dos . writeUTF ( localDir ) ; dos . writeUTF ( remoteDir ) ; dos . writeInt ( files . size ( ) ) ; for ( String file : files ) { dos . writeUTF ( file ) ; } } public void transferToClient ( List < File > files , File localDir , String remoteDir ) { jobPublisher . addJob ( new TransferJob ( localDir , remoteDir , files ) ) ; } public FileTransferEvent getNextTransferEvent ( ) throws InterruptedException { return fileTransferEvents . take ( ) ; } public TransferredBytesInfo getTransferredBytesInfo ( ) { return new TransferredBytesInfo ( usbReceiveThread . getAndResetTransferredBytes ( ) , usbSendThread . getAndResetTransferredBytes ( ) , wifiReceiveThread . getAndResetTransferredBytes ( ) , wifiSendThread . getAndResetTransferredBytes ( ) ) ; } public void stopServer ( ) { if ( socket != null ) { try { sendShutdownToClientAndClose ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( usbSendThread != null ) { usbSendThread . shutdown ( ) ; } if ( wifiSendThread != null ) { wifiSendThread . shutdown ( ) ; } if ( usbSendThread != null ) { joinNoException ( usbSendThread ) ; System . out . println ( "<STR_LIT>" ) ; } if ( wifiSendThread != null ) { joinNoException ( wifiReceiveThread ) ; System . out . println ( "<STR_LIT>" ) ; } if ( usbReceiveThread != null ) { joinNoException ( usbReceiveThread ) ; System . out . println ( "<STR_LIT>" ) ; } if ( wifiReceiveThread != null ) { joinNoException ( wifiReceiveThread ) ; System . out . println ( "<STR_LIT>" ) ; } if ( controllerSocket != null ) { closeNoException ( controllerSocket ) ; } if ( usbServerSocket != null ) { closeNoException ( usbServerSocket ) ; } if ( wifiServerSocket != null ) { closeNoException ( wifiServerSocket ) ; } System . out . println ( "<STR_LIT>" ) ; } private void sendShutdownToClientAndClose ( ) throws IOException { dos . writeShort ( ControllerIdentifiers . SHUTDOWN ) ; dos . close ( ) ; } private void closeNoException ( Closeable closeable ) { try { closeable . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void joinNoException ( Thread thread ) { try { thread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } @ Override public void onException ( Exception e ) { System . exit ( - <NUM_LIT> ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . os . RemoteException ; import android . util . Log ; import java . io . File ; import java . io . IOException ; import java . net . BindException ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . core . FileTransferServer ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . droidcore . EndCommandFTEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . Error ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class TransferServiceBinder extends ITransferService . Stub { public static final String TAG = "<STR_LIT>" ; FileTransferServer fileTransferServer ; public LinkedList < ArrayList < ParcelableRemoteFile > > localFileQueue ; public LinkedList < ArrayList < ParcelableRemoteFile > > remoteFileQueue ; public static final int SLICE_SIZE = <NUM_LIT> ; @ Override public void destroy ( ) throws RemoteException { System . exit ( <NUM_LIT> ) ; } @ Override public void exit ( ) throws RemoteException { } public synchronized void stopServer ( ) { fileTransferServer . stopServer ( ) ; notifyAll ( ) ; } @ Override public synchronized void waitingForDied ( ) throws RemoteException { try { wait ( ) ; } catch ( InterruptedException ignored ) { } } @ Override public Error startServer ( ) throws RemoteException { try { fileTransferServer . startServer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; if ( e instanceof BindException ) { return new Error ( Error . CODE_PORT_IS_OCCUPIED , e . getMessage ( ) ) ; } else { return new Error ( Error . CODE_IOEXCEPTION , e . toString ( ) ) ; } } return null ; } public TransferServiceBinder ( ) { fileTransferServer = new FileTransferServer ( ) ; } @ Override public void transferToPc ( List < String > files , String localDir , String remoteDir ) throws RemoteException { List < File > fileList = new ArrayList < > ( ) ; for ( String file : files ) { fileList . add ( new File ( file ) ) ; } fileTransferServer . transferToClient ( fileList , new File ( localDir ) , remoteDir ) ; } public void transferToMe ( List < String > files , String remoteDir , String localDir ) throws RemoteException { try { fileTransferServer . transferToMe ( files , remoteDir , localDir ) ; } catch ( IOException e ) { throw new RemoteException ( e . toString ( ) ) ; } } @ Override public int listClientFiles ( String path ) throws RemoteException { try { ArrayList < RemoteFile > remoteFiles = fileTransferServer . listClientFiles ( path ) ; int count = <NUM_LIT> ; remoteFileQueue = new LinkedList < > ( ) ; ArrayList < ParcelableRemoteFile > fileArraySlice = new ArrayList < > ( ) ; for ( RemoteFile remoteFile : remoteFiles ) { count ++ ; fileArraySlice . add ( new ParcelableRemoteFile ( remoteFile ) ) ; if ( count >= SLICE_SIZE ) { remoteFileQueue . add ( fileArraySlice ) ; fileArraySlice = new ArrayList < > ( ) ; count = <NUM_LIT> ; } } remoteFileQueue . add ( fileArraySlice ) ; return remoteFileQueue . size ( ) ; } catch ( IOException e ) { throw new RemoteException ( e . toString ( ) ) ; } } @ Override public ArrayList < ParcelableRemoteFile > pollRemoteFiles ( ) throws RemoteException { if ( remoteFileQueue == null ) { return null ; } return remoteFileQueue . poll ( ) ; } @ Override public ParcelableFileTransferEvent getNextFileTransferEvent ( ) throws RemoteException { try { FileTransferEvent nextTransferEvent = fileTransferServer . getNextTransferEvent ( ) ; if ( nextTransferEvent instanceof EndCommandFTEvent ) { System . out . println ( "<STR_LIT>" ) ; return null ; } return new ParcelableFileTransferEvent ( nextTransferEvent ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; System . out . println ( "<STR_LIT>" ) ; return null ; } } @ Override public ParcelableTransferredBytesInfo getTransferredBytesInfo ( ) throws RemoteException { return new ParcelableTransferredBytesInfo ( fileTransferServer . getTransferredBytesInfo ( ) ) ; } @ Override public void stopGetNextEvent ( ) { fileTransferServer . fileTransferEvents . add ( new EndCommandFTEvent ( ) ) ; } @ Override public int listLocalFiles ( String path ) throws RemoteException { File dir = new File ( path ) ; File [ ] files = dir . listFiles ( ) ; if ( files == null ) { return - <NUM_LIT> ; } int count = <NUM_LIT> ; localFileQueue = new LinkedList < > ( ) ; ArrayList < ParcelableRemoteFile > fileArraySlice = new ArrayList < > ( ) ; for ( File file : files ) { count ++ ; ParcelableRemoteFile parcelableRemoteFile = new ParcelableRemoteFile ( file ) ; fileArraySlice . add ( parcelableRemoteFile ) ; if ( count >= SLICE_SIZE ) { localFileQueue . add ( fileArraySlice ) ; fileArraySlice = new ArrayList < > ( ) ; count = <NUM_LIT> ; } } localFileQueue . add ( fileArraySlice ) ; return localFileQueue . size ( ) ; } @ Override public List < ParcelableRemoteFile > pollLocalFiles ( ) throws RemoteException { if ( localFileQueue == null ) { return null ; } return localFileQueue . poll ( ) ; } @ Override public ParcelableRemoteFile getParentFile ( String path ) throws RemoteException { String parent = new File ( path ) . getParent ( ) ; Log . i ( TAG , parent + "<STR_LIT>" ) ; File parentFile = new File ( path ) . getParentFile ( ) ; Log . i ( TAG , parentFile + "<STR_LIT>" ) ; if ( parentFile == null ) { return null ; } return new ParcelableRemoteFile ( parentFile ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; public class Error implements Parcelable { public static final int CODE_IOEXCEPTION = <NUM_LIT> ; public static final int CODE_PORT_IS_OCCUPIED = <NUM_LIT> ; protected int errorCode ; protected String exceptionMessage ; public Error ( int errorCode , String exceptionMessage ) { this . errorCode = errorCode ; this . exceptionMessage = exceptionMessage ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( this . errorCode ) ; dest . writeString ( this . exceptionMessage ) ; } public void readFromParcel ( Parcel source ) { this . errorCode = source . readInt ( ) ; this . exceptionMessage = source . readString ( ) ; } protected Error ( Parcel in ) { this . errorCode = in . readInt ( ) ; this . exceptionMessage = in . readString ( ) ; } public static final Parcelable . Creator < Error > CREATOR = new Parcelable . Creator < Error > ( ) { @ Override public Error createFromParcel ( Parcel source ) { return new Error ( source ) ; } @ Override public Error [ ] newArray ( int size ) { return new Error [ size ] ; } } ; public int getErrorCode ( ) { return errorCode ; } public String getExceptionMessage ( ) { return exceptionMessage ; } } </s>
<s> package top . weixiansen574 . async ; import android . os . Handler ; import android . os . Looper ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; public class TaskManger { private static volatile Handler mainThreadHandler ; private static Handler getUiThreadHandler ( ) { if ( mainThreadHandler == null ) { synchronized ( TaskManger . class ) { if ( mainThreadHandler == null ) { mainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; } } } return mainThreadHandler ; } public static void postOnUiThread ( Runnable runnable ) { getUiThreadHandler ( ) . post ( runnable ) ; } private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; public static void start ( Runnable runnable ) { executorService . execute ( runnable ) ; } public static void execute ( BackstageTask < ? > backstageTask ) { start ( backstageTask ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import org . junit . Test ; import static org . junit . Assert . * ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import top . weixiansen574 . hybridfilexfer . core . FileTransferClient ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { if ( executeAdbForwardCommand ( <NUM_LIT> , args ) ) { System . out . println ( "<STR_LIT>" ) ; } else { System . out . println ( "<STR_LIT>" ) ; return ; } if ( executeAdbForwardCommand ( <NUM_LIT> , args ) ) { System . out . println ( "<STR_LIT>" ) ; } else { System . out . println ( "<STR_LIT>" ) ; } System . out . println ( "<STR_LIT>" ) ; new FileTransferClient ( ) . startUp ( ) ; } public static boolean executeAdbForwardCommand ( int port , String [ ] args ) { try { String jarDirectory = System . getProperty ( "<STR_LIT>" ) ; StringBuilder adbCommand = new StringBuilder ( ) ; adbCommand . append ( "<STR_LIT>" ) ; for ( String arg : args ) { adbCommand . append ( "<STR_LIT>" ) . append ( arg ) ; } adbCommand . append ( "<STR_LIT>" ) ; adbCommand . append ( port ) ; adbCommand . append ( "<STR_LIT>" ) ; adbCommand . append ( port ) ; String adbForwardCommand = adbCommand . toString ( ) ; Process process = Runtime . getRuntime ( ) . exec ( adbForwardCommand , null , new java . io . File ( jarDirectory ) ) ; BufferedReader errorReader = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; String l ; while ( ( l = errorReader . readLine ( ) ) != null ) { System . err . println ( l ) ; } BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { System . out . println ( "<STR_LIT>" + line ) ; } int exitCode = process . waitFor ( ) ; return exitCode == <NUM_LIT> ; } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; return false ; } } } </s>
<s> package top . weixiansen574 . hybridfilexfer . async ; import java . util . List ; import top . weixiansen574 . async . BackstageTask ; import top . weixiansen574 . hybridfilexfer . IIServiceFileSelectAdapter ; import top . weixiansen574 . hybridfilexfer . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class CDParentTask extends BackstageTask < CDParentTask . EventHandler > { IIServiceFileSelectAdapter adapter ; String path ; public CDParentTask ( EventHandler handle , IIServiceFileSelectAdapter adapter , String path ) { super ( handle ) ; this . adapter = adapter ; this . path = path ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { String parentPath = Utils . getParentByPath ( path ) ; System . out . println ( "<STR_LIT>" + parentPath ) ; if ( parentPath != null ) { List < ParcelableRemoteFile > files = null ; files = adapter . listTargetFiles ( parentPath ) ; if ( files == null ) { eventHandler . onPermissionDenied ( ) ; } else if ( files . size ( ) > <NUM_LIT> ) { Utils . sortFiles ( files ) ; eventHandler . onSuccess ( files , parentPath ) ; } else { eventHandler . onParentDirNotFiles ( ) ; } } else { eventHandler . onThisIsTheLastPage ( ) ; } } public interface EventHandler extends BaseEventHandler { void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) ; void onPermissionDenied ( ) ; void onParentDirNotFiles ( ) ; void onThisIsTheLastPage ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import androidx . test . platform . app . InstrumentationRegistry ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( "<STR_LIT>" , appContext . getPackageName ( ) ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . threads ; public interface OnErrorListener { } </s>
<s> package top . weixiansen574 . hybridfilexfer . core ; import java . io . File ; public class Utils { public static String legalizationPath ( String path ) { if ( File . separator . equals ( "<STR_LIT>" ) ) { return path . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } return path ; } public static String replaceBackslashToSlash ( String path ) { return path . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static String replaceBackslashToUnderline ( String path ) { return path . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static String replaceColon ( String path ) { return path . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . bean ; public class BookMark { public final int id ; public final String path ; public BookMark ( int id , String path ) { this . id = id ; this . path = path ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . droidcore ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class EndCommandFTEvent extends FileTransferEvent { } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . bean ; public interface DevicesInterface { int DEVICE_USB = <NUM_LIT> ; int DEVICE_WIFI = <NUM_LIT> ; } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . bean ; public class TransferredBytesInfo { protected long usbReceiveBytes ; protected long usbSentBytes ; protected long wifiReceiveBytes ; protected long wifiSentBytes ; public TransferredBytesInfo ( long usbReceiveBytes , long usbSentBytes , long wifiReceiveBytes , long wifiSentBytes ) { this . usbReceiveBytes = usbReceiveBytes ; this . usbSentBytes = usbSentBytes ; this . wifiReceiveBytes = wifiReceiveBytes ; this . wifiSentBytes = wifiSentBytes ; } public long getUsbReceiveBytes ( ) { return usbReceiveBytes ; } public long getUsbSentBytes ( ) { return usbSentBytes ; } public long getWifiReceiveBytes ( ) { return wifiReceiveBytes ; } public long getWifiSentBytes ( ) { return wifiSentBytes ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core ; public class TransferIdentifiers { public static final short END_POINT = - <NUM_LIT> ; public static final short FILE = <NUM_LIT> ; public static final short FOLDER = <NUM_LIT> ; public static final short FILE_SLICE = <NUM_LIT> ; } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import android . Manifest ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Service ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . content . pm . PackageManager ; import android . hardware . input . InputManager ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Environment ; import android . os . IBinder ; import android . os . RemoteException ; import android . provider . Settings ; import android . view . Menu ; import android . view . MenuItem ; import android . view . MotionEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Spinner ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Locale ; import java . util . Objects ; import java . util . Set ; import rikka . shizuku . Shizuku ; import rikka . sui . Sui ; import top . weixiansen574 . hybridfilexfer . droidcore . Error ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class MainActivity extends AppCompatActivity implements View . OnClickListener , ServiceConnection { private Context context ; private Button btn_start_server ; private Button btn_to_transfer ; private Spinner spinner ; private TextView usb_state , wifi_state ; private boolean isRoot ; private ConnectThread connectThread ; private ITransferService iTransferService ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; context = this ; usb_state = findViewById ( R . id . usb_state ) ; wifi_state = findViewById ( R . id . wifi_state ) ; spinner = findViewById ( R . id . spinner_mode ) ; btn_start_server = findViewById ( R . id . start_server ) ; btn_to_transfer = findViewById ( R . id . to_transfer ) ; spinner = findViewById ( R . id . spinner_mode ) ; btn_start_server . setOnClickListener ( this ) ; btn_to_transfer . setOnClickListener ( this ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public void onClick ( View v ) { int id = v . getId ( ) ; if ( id == R . id . start_server ) { System . out . println ( spinner . getSelectedItemPosition ( ) ) ; if ( ! checkPermissionOrRequest ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; return ; } if ( iTransferService == null ) { startServer ( ) ; } else { stopServerAndDisconnectService ( ) ; } } else if ( id == R . id . to_transfer ) { Intent intent = new Intent ( context , TransferActivity . class ) ; intent . putExtra ( "<STR_LIT>" , isRoot ) ; startActivity ( intent ) ; } } @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { ITransferService iTransferService = ITransferService . Stub . asInterface ( service ) ; System . out . println ( "<STR_LIT>" + service + "<STR_LIT>" + iTransferService ) ; if ( this . iTransferService == null ) { this . iTransferService = iTransferService ; onConnectedService ( iTransferService ) ; } else { System . out . println ( "<STR_LIT>" ) ; } } @ Override public void onServiceDisconnected ( ComponentName name ) { System . out . println ( name + "<STR_LIT>" ) ; } private void startServer ( ) { if ( spinner . getSelectedItemPosition ( ) == <NUM_LIT> ) { System . out . println ( "<STR_LIT>" ) ; if ( ! Sui . init ( getPackageName ( ) ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } else { if ( Shizuku . checkSelfPermission ( ) != <NUM_LIT> ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; Shizuku . requestPermission ( <NUM_LIT> ) ; return ; } } isRoot = true ; } else { System . out . println ( "<STR_LIT>" ) ; isRoot = false ; } btn_start_server . setEnabled ( false ) ; bindService ( ) ; } private void bindService ( ) { if ( isRoot ) { Shizuku . bindUserService ( Utils . getUserServiceArgs ( context ) , this ) ; } else { Intent intent = new Intent ( context , TransferServices . class ) ; bindService ( intent , this , Service . BIND_AUTO_CREATE ) ; } } private void unbindService ( ) { if ( isRoot ) { Shizuku . unbindUserService ( Utils . getUserServiceArgs ( context ) , this , true ) ; } else { unbindService ( this ) ; } } private void onConnectedService ( ITransferService service ) { btn_start_server . setEnabled ( true ) ; usb_state . setText ( "<STR_LIT>" ) ; wifi_state . setText ( "<STR_LIT>" ) ; btn_start_server . setText ( "<STR_LIT>" ) ; connectThread = new ConnectThread ( this , service ) ; connectThread . start ( ) ; } public void stopServerAndDisconnectService ( ) { btn_start_server . setEnabled ( false ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { System . out . println ( "<STR_LIT>" ) ; iTransferService . stopServer ( ) ; System . out . println ( "<STR_LIT>" ) ; if ( connectThread != null ) { connectThread . shutdown ( ) ; try { connectThread . join ( ) ; } catch ( InterruptedException ignored ) { } } runOnUiThread ( ( ) -> { unbindService ( ) ; onServerStopped ( ) ; } ) ; } catch ( RemoteException e ) { runOnUiThread ( ( ) -> { unbindService ( ) ; onServerStopped ( ) ; } ) ; } } } ) . start ( ) ; } private void onServerStopped ( ) { iTransferService = null ; usb_state . setText ( "<STR_LIT>" ) ; wifi_state . setText ( "<STR_LIT>" ) ; btn_start_server . setText ( "<STR_LIT>" ) ; btn_start_server . setEnabled ( true ) ; btn_to_transfer . setEnabled ( false ) ; } private void onServerStarted ( ) { usb_state . setText ( "<STR_LIT>" ) ; wifi_state . setText ( "<STR_LIT>" ) ; btn_to_transfer . setEnabled ( true ) ; } private boolean checkPermissionOrRequest ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { if ( Environment . isExternalStorageManager ( ) ) { return true ; } else { Intent intent = new Intent ( Settings . ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION ) ; startActivityForResult ( intent , <NUM_LIT> ) ; return false ; } } else { if ( ContextCompat . checkSelfPermission ( this , android . Manifest . permission . WRITE_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { return true ; } else { ActivityCompat . requestPermissions ( this , new String [ ] { android . Manifest . permission . WRITE_EXTERNAL_STORAGE , Manifest . permission . READ_EXTERNAL_STORAGE } , <NUM_LIT> ) ; return false ; } } } public static class ConnectThread extends Thread { private final MainActivity activity ; private boolean shutdown = false ; private final ITransferService service ; public ConnectThread ( MainActivity activity , ITransferService service ) { this . activity = activity ; this . service = service ; } @ Override public void run ( ) { try { Error error = service . startServer ( ) ; activity . runOnUiThread ( ( ) -> { if ( error != null ) { if ( ! shutdown ) { Toast . makeText ( activity , error . getErrorCode ( ) == Error . CODE_PORT_IS_OCCUPIED ? "<STR_LIT>" : "<STR_LIT>" + error . getExceptionMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; activity . stopServerAndDisconnectService ( ) ; } else { System . out . println ( "<STR_LIT>" ) ; } } else { activity . onServerStarted ( ) ; } } ) ; if ( error == null ) { service . waitingForDied ( ) ; System . out . println ( "<STR_LIT>" ) ; } } catch ( RemoteException e ) { activity . runOnUiThread ( ( ) -> { Toast . makeText ( activity , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; activity . stopServerAndDisconnectService ( ) ; } ) ; } } public void shutdown ( ) { shutdown = true ; } } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == R . id . github ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; return true ; } else if ( itemId == R . id . update ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; if ( iTransferService != null ) { System . out . println ( "<STR_LIT>" ) ; unbindService ( ) ; } } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import android . content . DialogInterface ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public class LocalBookmarkAdapter extends BookmarkAdapter { private final IIServiceFileSelectAdapter adapter ; private final List < BookMark > bookMarks ; private final ConfigDB db ; public LocalBookmarkAdapter ( Context context , DialogInterface dialog , IIServiceFileSelectAdapter adapter , ConfigDB db ) { super ( context , dialog ) ; this . db = db ; this . bookMarks = db . getAllLocalBookmark ( ) ; this . adapter = adapter ; } @ Override protected boolean onDelete ( BookMark bookMark ) { boolean success = db . removeLocalBookmark ( bookMark . id ) > <NUM_LIT> ; if ( success ) { bookMarks . remove ( bookMark ) ; } return success ; } @ Override protected BookMark getItem ( int position ) { return bookMarks . get ( position ) ; } @ Override protected void onItemClick ( BookMark bookMark ) { adapter . cd ( bookMark . path ) ; } @ Override public int getItemCount ( ) { return bookMarks . size ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; public abstract class FileSelectAdapter < T > extends RecyclerView . Adapter < FileSelectAdapter . ViewHolder > { public final Toolbar fileSelectToolbar ; private SelectModeListener selectModeListener ; private final View . OnTouchListener onTouchListener ; protected HashSet < T > selectedItems ; private OnConfirmFileSelectionListener onConfirmFileSelectionListener ; protected Activity context ; private int lastSelectedCount = <NUM_LIT> ; private final FrameLayout frameLayout ; private final View listInView ; private final View loadingView ; public FileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView ) { this . fileSelectToolbar = fileSelectToolbar ; this . context = context ; this . onTouchListener = onTouchListener ; this . frameLayout = frameLayout ; this . listInView = listInView ; selectedItems = new HashSet < > ( ) ; loadingView = View . inflate ( context , R . layout . loading_files , null ) ; fileSelectToolbar . getMenu ( ) . findItem ( R . id . select_all ) . setOnMenuItemClickListener ( item -> { selectAll ( ) ; return true ; } ) ; fileSelectToolbar . setNavigationOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { cancelSelect ( ) ; } } ) ; } public void setSelectModeListener ( SelectModeListener selectModeListener ) { this . selectModeListener = selectModeListener ; } public void setOnToTransferListener ( OnConfirmFileSelectionListener onConfirmFileSelectionListener ) { this . onConfirmFileSelectionListener = onConfirmFileSelectionListener ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_file , parent , false ) , onTouchListener ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { T item = getItem ( position ) ; View itemView = holder . itemView ; holder . fileName . setText ( getFileName ( item ) ) ; holder . dateTime . setText ( Utils . formatDateTime ( getFileDate ( item ) ) ) ; if ( isDir ( item ) ) { holder . fileSize . setText ( "<STR_LIT>" ) ; } else { holder . fileSize . setText ( Utils . formatFileSize ( getFileSize ( item ) ) ) ; } if ( selectedItems . contains ( item ) ) { itemView . setBackgroundColor ( context . getColor ( R . color . blue_background_light ) ) ; holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . baseline_check_circle_24 ) ) ; } else { itemView . setBackgroundColor ( context . getColor ( R . color . background ) ) ; if ( isDir ( item ) ) { holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . folder ) ) ; } else { holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . file ) ) ; } } itemView . setOnLongClickListener ( v -> { if ( ! isSelectMode ( ) ) { if ( ! selectedItems . contains ( item ) ) { addSelectItem ( item ) ; } else { removeSelectItem ( item ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; } else { if ( selectedItems . contains ( item ) ) { onConfirmFileSelection ( selectedItems ) ; } } return true ; } ) ; itemView . setOnClickListener ( v -> { if ( isSelectMode ( ) ) { if ( ! selectedItems . contains ( item ) ) { addSelectItem ( item ) ; } else { removeSelectItem ( item ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; } else if ( isDir ( item ) ) { cd ( getPath ( item ) ) ; } } ) ; } private void addSelectItem ( T item ) { selectedItems . add ( item ) ; updateSelectedCount ( ) ; } private void removeSelectItem ( T item ) { selectedItems . remove ( item ) ; updateSelectedCount ( ) ; } private void updateSelectedCount ( ) { int size = selectedItems . size ( ) ; fileSelectToolbar . setTitle ( "<STR_LIT>" + size + "<STR_LIT>" ) ; if ( selectModeListener != null ) { if ( selectedItems . isEmpty ( ) ) { selectModeListener . onSelectModeChanged ( false ) ; } else if ( lastSelectedCount == <NUM_LIT> ) { selectModeListener . onSelectModeChanged ( true ) ; } } lastSelectedCount = size ; } protected abstract String getFileName ( T item ) ; protected abstract String getPath ( T item ) ; protected abstract boolean isDir ( T item ) ; protected abstract T getItem ( int position ) ; protected abstract long getFileDate ( T item ) ; protected abstract long getFileSize ( T item ) ; protected abstract List < T > getAllItems ( ) ; protected abstract void cd ( String path ) ; protected void onConfirmFileSelection ( HashSet < T > selectedItems ) { List < String > files = new ArrayList < > ( ) ; for ( T item : selectedItems ) { files . add ( getPath ( item ) ) ; } onConfirmFileSelectionListener . onConfirmFileSelection ( files , getCurrentDir ( ) ) ; } ; public abstract String getCurrentDir ( ) ; public abstract void cdParent ( ) ; public boolean isSelectMode ( ) { return ! selectedItems . isEmpty ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void selectAll ( ) { selectedItems . clear ( ) ; selectedItems . addAll ( getAllItems ( ) ) ; updateSelectedCount ( ) ; notifyDataSetChanged ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void cancelSelect ( ) { selectedItems . clear ( ) ; updateSelectedCount ( ) ; notifyDataSetChanged ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { ImageView fileIcon ; TextView fileName , dateTime , fileSize ; public ViewHolder ( @ NonNull View itemView , View . OnTouchListener onTouchListener ) { super ( itemView ) ; fileIcon = itemView . findViewById ( R . id . file_icon ) ; fileName = itemView . findViewById ( R . id . file_name ) ; dateTime = itemView . findViewById ( R . id . date_time ) ; fileSize = itemView . findViewById ( R . id . file_size ) ; itemView . setOnTouchListener ( onTouchListener ) ; } } interface SelectModeListener { void onSelectModeChanged ( boolean isSelectMode ) ; } interface OnConfirmFileSelectionListener { void onConfirmFileSelection ( List < String > selectedItems , String dir ) ; } public void enterLoadingState ( ) { frameLayout . removeView ( listInView ) ; frameLayout . addView ( loadingView ) ; } public void exitLoadingState ( ) { frameLayout . removeView ( loadingView ) ; frameLayout . addView ( listInView ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Service ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . os . Bundle ; import android . os . IBinder ; import android . os . RemoteException ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuItem ; import android . view . MotionEvent ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Objects ; import rikka . shizuku . Shizuku ; import top . weixiansen574 . async . TaskManger ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class TransferActivity extends AppCompatActivity implements ServiceConnection { private boolean isRootMode ; private boolean isLeftFocus = true ; private Context context ; private RecyclerView rv_left_files , rv_right_files ; private ConstraintLayout shadowLeft , shadowRight ; private FrameLayout frameLeft , frameRight ; private IIServiceFileSelectAdapter leftRVAdapter ; private IIServiceFileSelectAdapter rightRVAdapter ; private Toolbar toolbar ; private FrameLayout frameLayout ; private View currentSelectView ; private View leftSelectView , rightSelectView ; private FileTransferEventMonitorThread fileTransferEventMonitorThread ; private TransferSpeedMeterThread transferSpeedMeterThread ; private AlertDialog errorDialog ; private ConfigDB configDB ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_transfer ) ; context = this ; toolbar = findViewById ( R . id . toolbar ) ; setSupportActionBar ( toolbar ) ; Objects . requireNonNull ( getSupportActionBar ( ) ) . setDisplayHomeAsUpEnabled ( true ) ; frameLayout = findViewById ( R . id . frame_tool ) ; leftSelectView = LayoutInflater . from ( context ) . inflate ( R . layout . toolbar_select , null ) ; rightSelectView = LayoutInflater . from ( context ) . inflate ( R . layout . toolbar_select , null ) ; frameLeft = findViewById ( R . id . frame_left ) ; frameRight = findViewById ( R . id . frame_right ) ; shadowLeft = findViewById ( R . id . inner_shadow_left ) ; shadowRight = findViewById ( R . id . inner_shadow_right ) ; rv_left_files = findViewById ( R . id . rv_left_files ) ; rv_right_files = findViewById ( R . id . rv_right_files ) ; frameLeft . removeView ( shadowLeft ) ; Intent intent = getIntent ( ) ; isRootMode = intent . getBooleanExtra ( "<STR_LIT>" , false ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; rv_left_files . setLayoutManager ( linearLayoutManager ) ; linearLayoutManager = new LinearLayoutManager ( context ) ; ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; rv_right_files . setLayoutManager ( linearLayoutManager ) ; bindService ( ) ; configDB = new ConfigDB ( context ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { ITransferService iTransferService = ITransferService . Stub . asInterface ( service ) ; System . out . println ( "<STR_LIT>" + service + "<STR_LIT>" + iTransferService ) ; OnTouchListener onTouchListenerForLeft = new OnTouchListener ( this , true ) ; Toolbar localFileSelectToolbar = leftSelectView . findViewById ( R . id . toolbar ) ; Toolbar remoteFileSelectToolbar = rightSelectView . findViewById ( R . id . toolbar ) ; OnTouchListener onTouchListenerForRight = new OnTouchListener ( this , false ) ; leftRVAdapter = new LocalFileSelectAdapter ( this , onTouchListenerForLeft , localFileSelectToolbar , findViewById ( R . id . frame_rv_left_root ) , findViewById ( R . id . frame_rv_left ) , iTransferService ) ; rightRVAdapter = new RemoteFileSelectAdapter ( this , onTouchListenerForRight , remoteFileSelectToolbar , findViewById ( R . id . frame_rv_right_root ) , findViewById ( R . id . frame_rv_right ) , iTransferService ) ; rv_left_files . setOnTouchListener ( onTouchListenerForLeft ) ; rv_right_files . setOnTouchListener ( onTouchListenerForRight ) ; leftRVAdapter . setSelectModeListener ( isSelectMode -> switchSelectView ( isSelectMode ? leftSelectView : null ) ) ; rightRVAdapter . setSelectModeListener ( isSelectMode -> switchSelectView ( isSelectMode ? rightSelectView : null ) ) ; rv_left_files . setAdapter ( leftRVAdapter ) ; rv_right_files . setAdapter ( rightRVAdapter ) ; fileTransferEventMonitorThread = new FileTransferEventMonitorThread ( this , iTransferService ) ; fileTransferEventMonitorThread . setDaemon ( true ) ; fileTransferEventMonitorThread . setName ( "<STR_LIT>" ) ; fileTransferEventMonitorThread . start ( ) ; transferSpeedMeterThread = new TransferSpeedMeterThread ( this , iTransferService ) ; transferSpeedMeterThread . setName ( "<STR_LIT>" ) ; transferSpeedMeterThread . start ( ) ; findViewById ( R . id . speed_info ) . setOnClickListener ( v -> showTransferProgressDialog ( ) ) ; TextView usb_upload_speed = findViewById ( R . id . usb_upload_speed ) ; TextView usb_download_speed = findViewById ( R . id . usb_download_speed ) ; TextView wifi_upload_speed = findViewById ( R . id . wifi_upload_speed ) ; TextView wifi_download_speed = findViewById ( R . id . wifi_download_speed ) ; transferSpeedMeterThread . addListener ( new OnInternetSpeedChangeListener ( ) { @ Override public void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) { usb_upload_speed . setText ( Utils . formatSpeed ( usbUpSpeed ) ) ; usb_download_speed . setText ( Utils . formatSpeed ( usbDownSpeed ) ) ; wifi_upload_speed . setText ( Utils . formatSpeed ( wifiUpSpeed ) ) ; wifi_download_speed . setText ( Utils . formatSpeed ( wifiDownSpeed ) ) ; } } ) ; leftRVAdapter . setOnToTransferListener ( ( selectedItems , dir ) -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + selectedItems . size ( ) + "<STR_LIT>" + rightRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { leftRVAdapter . cancelSelect ( ) ; showTransferProgressDialog ( ) ; try { iTransferService . transferToPc ( selectedItems , dir , rightRVAdapter . getCurrentDir ( ) ) ; } catch ( RemoteException e ) { onServerDied ( ) ; } } ) . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> { } ) . show ( ) ; } ) ; rightRVAdapter . setOnToTransferListener ( ( selectedItems , dir ) -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + selectedItems . size ( ) + "<STR_LIT>" + leftRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { rightRVAdapter . cancelSelect ( ) ; showTransferProgressDialog ( ) ; TaskManger . start ( ( ) -> { try { iTransferService . transferToMe ( selectedItems , dir , leftRVAdapter . getCurrentDir ( ) ) ; } catch ( RemoteException e ) { onServerDied ( ) ; } } ) ; } ) . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> { } ) . show ( ) ; } ) ; } @ Override public void onServiceDisconnected ( ComponentName name ) { } private void bindService ( ) { if ( isRootMode ) { Shizuku . bindUserService ( Utils . getUserServiceArgs ( context ) , this ) ; } else { Intent intent = new Intent ( context , TransferServices . class ) ; bindService ( intent , this , Service . BIND_AUTO_CREATE ) ; } } private void unbindService ( ) { if ( isRootMode ) { Shizuku . unbindUserService ( Utils . getUserServiceArgs ( context ) , this , false ) ; } else { unbindService ( this ) ; } } public void onServerDied ( ) { runOnUiThread ( ( ) -> { if ( errorDialog == null && ! isDestroyed ( ) ) { errorDialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setCancelable ( false ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { finish ( ) ; } ) . show ( ) ; } } ) ; } public void switchTo ( boolean isLeft ) { if ( isLeft ) { if ( ! this . isLeftFocus ) { frameLeft . removeView ( shadowLeft ) ; frameRight . addView ( shadowRight ) ; } switchSelectView ( leftRVAdapter . isSelectMode ( ) ? leftSelectView : null ) ; } else { if ( isLeftFocus ) { frameRight . removeView ( shadowRight ) ; frameLeft . addView ( shadowLeft ) ; } switchSelectView ( rightRVAdapter . isSelectMode ( ) ? rightSelectView : null ) ; } this . isLeftFocus = isLeft ; } @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { if ( isLeftFocus ) { if ( leftRVAdapter . isSelectMode ( ) ) { leftRVAdapter . cancelSelect ( ) ; } else { leftRVAdapter . cdParent ( ) ; } } else { if ( rightRVAdapter . isSelectMode ( ) ) { rightRVAdapter . cancelSelect ( ) ; } else { rightRVAdapter . cdParent ( ) ; } } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void switchSelectView ( View selectView ) { if ( currentSelectView != selectView ) { if ( currentSelectView != null ) { frameLayout . removeView ( currentSelectView ) ; } if ( selectView != null ) { frameLayout . addView ( selectView ) ; } currentSelectView = selectView ; } } private static class OnTouchListener implements View . OnTouchListener { private final TransferActivity activity ; private final boolean isLeft ; public OnTouchListener ( TransferActivity activity , boolean isLeft ) { this . activity = activity ; this . isLeft = isLeft ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouch ( View v , MotionEvent event ) { if ( event . getAction ( ) == MotionEvent . ACTION_DOWN ) { System . out . println ( "<STR_LIT>" + ( isLeft ? "<STR_LIT>" : "<STR_LIT>" ) ) ; activity . switchTo ( isLeft ) ; } return false ; } } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { int id = item . getItemId ( ) ; if ( id == android . R . id . home ) { finish ( ) ; return true ; } else if ( id == R . id . refresh ) { if ( leftRVAdapter == null || rightRVAdapter == null ) { return true ; } if ( isLeftFocus ) { leftRVAdapter . cd ( leftRVAdapter . getCurrentDir ( ) ) ; } else { rightRVAdapter . cd ( rightRVAdapter . getCurrentDir ( ) ) ; } } else if ( id == R . id . bookmark_list ) { View dialogView = View . inflate ( context , R . layout . dialog_bookmarks , null ) ; RecyclerView recyclerView = dialogView . findViewById ( R . id . bookmark_list ) ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context ) ; layoutManager . setOrientation ( RecyclerView . VERTICAL ) ; recyclerView . setLayoutManager ( layoutManager ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) . setView ( dialogView ) . setPositiveButton ( "<STR_LIT>" , null ) ; if ( isLeftFocus ) { builder . setTitle ( "<STR_LIT>" ) ; recyclerView . setAdapter ( new LocalBookmarkAdapter ( context , builder . show ( ) , leftRVAdapter , configDB ) ) ; } else { builder . setTitle ( "<STR_LIT>" ) ; recyclerView . setAdapter ( new RemoteBookmarkAdapter ( context , builder . show ( ) , rightRVAdapter , configDB ) ) ; } } else if ( id == R . id . add_bookmark ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; if ( isLeftFocus ) { builder . setTitle ( "<STR_LIT>" ) . setMessage ( leftRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { addBookmark ( false , leftRVAdapter . getCurrentDir ( ) ) ; } ) ; } else { builder . setTitle ( "<STR_LIT>" ) . setMessage ( rightRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { addBookmark ( true , rightRVAdapter . getCurrentDir ( ) ) ; } ) ; } builder . setNegativeButton ( R . string . cancel , null ) ; builder . show ( ) ; } return super . onOptionsItemSelected ( item ) ; } private void addBookmark ( boolean isRemote , String path ) { boolean exists ; if ( isRemote ) { exists = configDB . checkRemoteBookmarkExists ( path ) ; if ( ! exists ) { configDB . addRemoteBookmark ( path ) ; } } else { exists = configDB . checkLocalBookmarkExists ( path ) ; if ( ! exists ) { configDB . addLocalBookmark ( path ) ; } } if ( ! exists ) { Toast . makeText ( this , "<STR_LIT>" + ( isRemote ? "<STR_LIT>" : "<STR_LIT>" ) + "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } else { Toast . makeText ( this , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . toolbar_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; unbindService ( ) ; if ( transferSpeedMeterThread != null ) { transferSpeedMeterThread . isRun = false ; transferSpeedMeterThread . interrupt ( ) ; } if ( fileTransferEventMonitorThread != null ) { try { fileTransferEventMonitorThread . service . stopGetNextEvent ( ) ; } catch ( RemoteException ignored ) { } } } private void showTransferProgressDialog ( ) { View dialogView = View . inflate ( context , R . layout . dialog_transfer_progress_2 , null ) ; TextView txv_usb_transfer_event = dialogView . findViewById ( R . id . txv_usb_transfer_event ) ; TextView txv_wifi_transfer_event = dialogView . findViewById ( R . id . txv_wifi_transfer_event ) ; TextView txv_usb_upload_speed = dialogView . findViewById ( R . id . txv_usb_upload_speed ) ; TextView txv_usb_download_speed = dialogView . findViewById ( R . id . txv_usb_download_speed ) ; TextView txv_wifi_upload_speed = dialogView . findViewById ( R . id . txv_wifi_upload_speed ) ; TextView txv_wifi_download_speed = dialogView . findViewById ( R . id . txv_wifi_download_speed ) ; OnFileTransferEventListener listener = new OnFileTransferEventListener ( ) { @ Override public void onEvent ( ParcelableFileTransferEvent event ) { TextView setText = null ; if ( event . getDevice ( ) == ParcelableFileTransferEvent . DEVICE_USB ) { setText = txv_usb_transfer_event ; } else if ( event . getDevice ( ) == ParcelableFileTransferEvent . DEVICE_WIFI ) { setText = txv_wifi_transfer_event ; } else { throw new RuntimeException ( "<STR_LIT>" + event . getDevice ( ) ) ; } switch ( event . getState ( ) ) { case ParcelableFileTransferEvent . STATE_UPLOAD : setText . setText ( "<STR_LIT>" + event . getDesc ( ) ) ; break ; case ParcelableFileTransferEvent . STATE_DOWNLOAD : setText . setText ( "<STR_LIT>" + event . getDesc ( ) ) ; break ; case ParcelableFileTransferEvent . STATE_OVER : setText . setText ( "<STR_LIT>" + event . getDesc ( ) ) ; break ; } } } ; AlertDialog dialog = new AlertDialog . Builder ( this ) . setView ( dialogView ) . setTitle ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; OnInternetSpeedChangeListener speedChangeListener = new OnInternetSpeedChangeListener ( ) { @ Override public void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) { dialog . setTitle ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , ( ( float ) usbUpSpeed + wifiUpSpeed ) / <NUM_LIT> / <NUM_LIT> , ( ( float ) usbDownSpeed + wifiDownSpeed ) / <NUM_LIT> / <NUM_LIT> ) ) ; txv_usb_upload_speed . setText ( Utils . formatSpeed ( usbUpSpeed ) ) ; txv_usb_download_speed . setText ( Utils . formatSpeed ( usbDownSpeed ) ) ; txv_wifi_upload_speed . setText ( Utils . formatSpeed ( wifiUpSpeed ) ) ; txv_wifi_download_speed . setText ( Utils . formatSpeed ( wifiDownSpeed ) ) ; } } ; fileTransferEventMonitorThread . addListener ( listener ) ; transferSpeedMeterThread . addListener ( speedChangeListener ) ; dialog . setOnDismissListener ( dialog1 -> { fileTransferEventMonitorThread . removeListener ( listener ) ; transferSpeedMeterThread . removeListener ( speedChangeListener ) ; } ) ; } public static class FileTransferEventMonitorThread extends Thread { private boolean isRun ; private TransferActivity activity ; private ITransferService service ; List < OnFileTransferEventListener > listeners ; public FileTransferEventMonitorThread ( TransferActivity activity , ITransferService service ) { this . activity = activity ; this . service = service ; this . listeners = new ArrayList < > ( ) ; } @ Override public void run ( ) { isRun = true ; while ( isRun ) { try { ParcelableFileTransferEvent nextFileTransferEvent = service . getNextFileTransferEvent ( ) ; if ( nextFileTransferEvent != null ) { activity . runOnUiThread ( ( ) -> { for ( OnFileTransferEventListener listener : listeners ) { listener . onEvent ( nextFileTransferEvent ) ; } } ) ; } else { System . out . println ( "<STR_LIT>" ) ; break ; } } catch ( RemoteException e ) { isRun = false ; e . printStackTrace ( ) ; activity . onServerDied ( ) ; } } } public void addListener ( OnFileTransferEventListener eventListener ) { listeners . add ( eventListener ) ; } public void removeListener ( OnFileTransferEventListener eventListener ) { listeners . remove ( eventListener ) ; } } public interface OnFileTransferEventListener { void onEvent ( ParcelableFileTransferEvent event ) ; } public static class TransferSpeedMeterThread extends Thread { private boolean isRun ; private Activity activity ; private ITransferService service ; private ArrayList < OnInternetSpeedChangeListener > listeners ; public TransferSpeedMeterThread ( Activity activity , ITransferService service ) { this . activity = activity ; this . service = service ; listeners = new ArrayList < > ( ) ; } @ Override public void run ( ) { isRun = true ; while ( isRun ) { try { Thread . sleep ( <NUM_LIT> ) ; ParcelableTransferredBytesInfo info = service . getTransferredBytesInfo ( ) ; activity . runOnUiThread ( ( ) -> { for ( OnInternetSpeedChangeListener listener : listeners ) { listener . onInternetSpeedChanged ( info . getUsbSentBytes ( ) , info . getUsbReceiveBytes ( ) , info . getWifiSentBytes ( ) , info . getWifiReceiveBytes ( ) ) ; } } ) ; } catch ( InterruptedException | RemoteException ignored ) { } } } public void addListener ( OnInternetSpeedChangeListener listener ) { listeners . add ( listener ) ; } public void removeListener ( OnInternetSpeedChangeListener listener ) { listeners . remove ( listener ) ; } } public interface OnInternetSpeedChangeListener { void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . app . Activity ; import android . content . Context ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class RemoteFileSelectAdapter extends IIServiceFileSelectAdapter { public RemoteFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView , service ) ; currentDir = "<STR_LIT>" ; cd ( currentDir ) ; } @ Override public List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException { ArrayList < ParcelableRemoteFile > files = new ArrayList < > ( ) ; int size = service . listClientFiles ( path ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { files . addAll ( service . pollRemoteFiles ( ) ) ; } return files ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class LocalFileSelectAdapter extends IIServiceFileSelectAdapter { public LocalFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView , service ) ; currentDir = "<STR_LIT>" ; cd ( currentDir ) ; } @ Override public List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException { ArrayList < ParcelableRemoteFile > files = new ArrayList < > ( ) ; int size = service . listLocalFiles ( path ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { files . addAll ( service . pollLocalFiles ( ) ) ; } return files ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . async ; import static top . weixiansen574 . hybridfilexfer . Utils . sortFiles ; import java . util . List ; import top . weixiansen574 . async . BackstageTask ; import top . weixiansen574 . hybridfilexfer . IIServiceFileSelectAdapter ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class CDTask extends BackstageTask < CDTask . EventHandle > { IIServiceFileSelectAdapter adapter ; String path ; public CDTask ( EventHandle handle , IIServiceFileSelectAdapter adapter , String path ) { super ( handle ) ; this . adapter = adapter ; this . path = path ; } @ Override protected void onStart ( EventHandle eventHandler ) throws Throwable { List < ParcelableRemoteFile > files = adapter . listTargetFiles ( path ) ; if ( files == null ) { eventHandler . onPermissionDenied ( ) ; } else { sortFiles ( files ) ; eventHandler . onSuccess ( files , path ) ; } } public interface EventHandle extends BaseEventHandler { void onSuccess ( List < ParcelableRemoteFile > files , String path ) ; void onPermissionDenied ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . bean ; import java . io . File ; import top . weixiansen574 . hybridfilexfer . core . Utils ; public class FileTransferJob { public final File localDir ; public final String remoteDir ; public final File targetFile ; public final boolean isSlice ; public final long startRange ; public final long endRange ; public FileTransferJob ( File localDir , String remoteDir , File target ) { this . localDir = localDir ; this . remoteDir = remoteDir ; this . targetFile = target ; this . isSlice = false ; this . startRange = <NUM_LIT> ; this . endRange = <NUM_LIT> ; } public FileTransferJob ( File localDir , String remoteDir , File target , long startRange , long endRange ) { this . localDir = localDir ; this . remoteDir = remoteDir ; this . targetFile = target ; this . startRange = startRange ; this . endRange = endRange ; this . isSlice = true ; } public FileTransferJob ( FileTransferJob oldJob , long startRange , long endRange ) { this . localDir = oldJob . localDir ; this . remoteDir = oldJob . remoteDir ; this . targetFile = oldJob . targetFile ; this . startRange = startRange ; this . endRange = endRange ; this . isSlice = true ; } public String toRemotePath ( ) { if ( localDir == null || targetFile == null || remoteDir == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } String localDirPath = localDir . getAbsolutePath ( ) ; String targetPath = targetFile . getAbsolutePath ( ) ; String remotePath = Utils . replaceBackslashToSlash ( remoteDir ) ; if ( ! localDirPath . endsWith ( File . separator ) ) { localDirPath += File . separator ; } String relativePath = targetPath . startsWith ( localDirPath ) ? targetPath . substring ( localDirPath . length ( ) ) : targetPath ; relativePath = processFileNamesAccordingToTheSystem ( relativePath ) ; return remotePath + ( remotePath . endsWith ( "<STR_LIT>" ) ? "<STR_LIT>" : "<STR_LIT>" ) + relativePath ; } public String processFileNamesAccordingToTheSystem ( String path ) { if ( File . separator . equals ( "<STR_LIT>" ) ) { path = Utils . replaceColon ( path ) ; path = Utils . replaceBackslashToUnderline ( path ) ; } else { path = Utils . replaceBackslashToSlash ( path ) ; } return path ; } public long getTotalSize ( ) { return targetFile . length ( ) ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer ; import android . app . Service ; import android . content . Intent ; import android . os . IBinder ; import android . os . RemoteException ; import android . util . Log ; public class TransferServices extends Service { public TransferServiceBinder binder ; public TransferServices ( ) { this . binder = new TransferServiceBinder ( ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; try { binder . destroy ( ) ; } catch ( RemoteException ignored ) { } } @ Override public IBinder onBind ( Intent intent ) { return binder ; } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . Socket ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . LinkedBlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . ControllerIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . core . ServerInfo ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferJob ; public class ClientControllerThread extends Thread implements TransferThread . OnExceptionListener { Socket controllerSocket ; DataInputStream dis ; DataOutputStream dos ; ReceiveThread usbReceiveThread ; ReceiveThread wifiReceiveThread ; JobPublisher jobPublisher ; SendThread usbSendThread ; SendThread wifiSendThread ; public ClientControllerThread ( ) { jobPublisher = new JobPublisher ( ) ; } @ Override public void run ( ) { try { controllerSocket = new Socket ( InetAddress . getLoopbackAddress ( ) , ServerInfo . PORT_CONTROLLER ) ; dis = new DataInputStream ( controllerSocket . getInputStream ( ) ) ; dos = new DataOutputStream ( controllerSocket . getOutputStream ( ) ) ; InetAddress serverWifiAddress ; try { serverWifiAddress = getServerWifiAddress ( ) ; } catch ( IOException e ) { System . out . println ( "<STR_LIT>" ) ; return ; } if ( Arrays . equals ( serverWifiAddress . getAddress ( ) , new byte [ <NUM_LIT> ] ) ) { System . out . println ( "<STR_LIT>" ) ; return ; } Socket wifiSocket ; try { wifiSocket = new Socket ( serverWifiAddress , ServerInfo . PORT_WIFI ) ; } catch ( IOException e ) { System . out . println ( "<STR_LIT>" + serverWifiAddress . getHostAddress ( ) + "<STR_LIT>" ) ; return ; } Socket usbSocket = new Socket ( InetAddress . getLoopbackAddress ( ) , ServerInfo . PORT_USB ) ; usbReceiveThread = new ReceiveThread ( null , ReceiveThread . DEVICE_USB , usbSocket . getInputStream ( ) ) ; usbReceiveThread . setName ( "<STR_LIT>" ) ; usbReceiveThread . setOnExceptionListener ( this ) ; usbReceiveThread . start ( ) ; wifiReceiveThread = new ReceiveThread ( null , ReceiveThread . DEVICE_WIFI , wifiSocket . getInputStream ( ) ) ; wifiReceiveThread . setName ( "<STR_LIT>" ) ; wifiReceiveThread . setOnExceptionListener ( this ) ; wifiReceiveThread . start ( ) ; usbSendThread = new SendThread ( null , SendThread . DEVICE_USB , jobPublisher , usbSocket . getOutputStream ( ) ) ; usbSendThread . setName ( "<STR_LIT>" ) ; usbSendThread . setOnExceptionListener ( this ) ; usbSendThread . start ( ) ; wifiSendThread = new SendThread ( null , SendThread . DEVICE_WIFI , jobPublisher , wifiSocket . getOutputStream ( ) ) ; wifiSendThread . setName ( "<STR_LIT>" ) ; wifiSendThread . setOnExceptionListener ( this ) ; wifiSendThread . start ( ) ; System . out . println ( "<STR_LIT>" + serverWifiAddress . getHostAddress ( ) ) ; waitingForRequest ( ) ; } catch ( IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; onException ( e ) ; } } private InetAddress getServerWifiAddress ( ) throws IOException { dos . writeShort ( ControllerIdentifiers . GET_WLAN_ADDRESS ) ; byte [ ] wlanV4AddressBytes = new byte [ <NUM_LIT> ] ; dis . readFully ( wlanV4AddressBytes ) ; return Inet4Address . getByAddress ( wlanV4AddressBytes ) ; } private void waitingForRequest ( ) throws IOException , ClassNotFoundException { w : while ( true ) { short identifiers = dis . readShort ( ) ; switch ( identifiers ) { case ControllerIdentifiers . LIST_FILES : String path = dis . readUTF ( ) ; System . out . println ( "<STR_LIT>" + path ) ; handleListFiles ( path ) ; break ; case ControllerIdentifiers . TRANSPORT_FILES : String serverDir = dis . readUTF ( ) ; String dir = dis . readUTF ( ) ; int listSize = dis . readInt ( ) ; List < String > toTransferFilePaths = new ArrayList < > ( listSize ) ; for ( int i = <NUM_LIT> ; i < listSize ; i ++ ) { toTransferFilePaths . add ( dis . readUTF ( ) ) ; } handleTransferFileToServer ( serverDir , dir , toTransferFilePaths ) ; break ; case ControllerIdentifiers . SHUTDOWN : System . out . println ( "<STR_LIT>" ) ; usbSendThread . shutdown ( ) ; wifiSendThread . shutdown ( ) ; try { usbSendThread . join ( ) ; wifiSendThread . join ( ) ; usbReceiveThread . join ( ) ; wifiReceiveThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } controllerSocket . close ( ) ; break w ; } } } private void handleListFiles ( String path ) throws IOException { ArrayList < RemoteFile > files = new ArrayList < > ( ) ; if ( ! path . equals ( "<STR_LIT>" ) ) { File file = new File ( path ) ; File [ ] list = file . listFiles ( ) ; if ( list != null ) { for ( File file1 : list ) { files . add ( new RemoteFile ( file1 ) ) ; } } } else { File [ ] roots = File . listRoots ( ) ; if ( roots . length == <NUM_LIT> && roots [ <NUM_LIT> ] . getAbsolutePath ( ) . equals ( "<STR_LIT>" ) ) { roots = roots [ <NUM_LIT> ] . listFiles ( ) ; if ( roots == null ) { throw new RuntimeException ( "<STR_LIT>" ) ; } for ( File root : roots ) { files . add ( new RemoteFile ( root . getName ( ) , root . getPath ( ) , root . lastModified ( ) , root . length ( ) , root . isDirectory ( ) ) ) ; } } else { for ( File root : roots ) { files . add ( new RemoteFile ( root . getPath ( ) , root . getPath ( ) , root . lastModified ( ) , root . length ( ) , root . isDirectory ( ) ) ) ; } } } dos . writeInt ( files . size ( ) ) ; for ( RemoteFile file : files ) { dos . writeUTF ( file . getName ( ) ) ; dos . writeUTF ( file . getPath ( ) ) ; dos . writeLong ( file . getLastModified ( ) ) ; dos . writeLong ( file . getSize ( ) ) ; dos . writeBoolean ( file . isDirectory ( ) ) ; } } private void handleTransferFileToServer ( String serverDir , String dir , List < String > remoteFiles ) { File localDir = new File ( dir ) ; List < File > transferFiles = new ArrayList < > ( ) ; for ( String remoteFile : remoteFiles ) { transferFiles . add ( new File ( remoteFile ) ) ; } jobPublisher . addJob ( new TransferJob ( localDir , serverDir , transferFiles ) ) ; } @ Override public void onException ( Exception e ) { System . exit ( - <NUM_LIT> ) ; } } </s>
<s> package top . weixiansen574 . async ; import android . os . Handler ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class BackstageTask < T extends BackstageTask . BaseEventHandler > implements Runnable { private final T uiHandler ; public BackstageTask ( T uiHandler ) { this . uiHandler = uiHandler ; } protected abstract void onStart ( T eventHandlerProxy ) throws Throwable ; @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void run ( ) { T proxyInstance = ( T ) Proxy . newProxyInstance ( uiHandler . getClass ( ) . getClassLoader ( ) , uiHandler . getClass ( ) . getInterfaces ( ) , new SendToUiHandler ( uiHandler ) ) ; try { onStart ( proxyInstance ) ; TaskManger . postOnUiThread ( uiHandler :: onComplete ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; TaskManger . postOnUiThread ( ( ) -> uiHandler . onError ( e ) ) ; } } public void execute ( ) { TaskManger . execute ( this ) ; } public static class SendToUiHandler implements InvocationHandler { Object evHandler ; public SendToUiHandler ( Object evHandler ) { this . evHandler = evHandler ; } @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) == Object . class ) { return method . invoke ( proxy , args ) ; } TaskManger . postOnUiThread ( ( ) -> { try { method . invoke ( evHandler , args ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } ) ; return null ; } } public interface BaseEventHandler { default void onError ( Throwable th ) { throw new RuntimeException ( th ) ; } default void onComplete ( ) { } } } </s>
<s> package top . weixiansen574 . hybridfilexfer . core . bean ; import java . io . File ; import java . io . Serializable ; public class RemoteFile implements Serializable { protected String name ; protected String path ; protected long lastModified ; protected long size ; protected boolean isDirectory ; public RemoteFile ( File file ) { path = file . getPath ( ) ; isDirectory = file . isDirectory ( ) ; name = file . getName ( ) ; lastModified = file . lastModified ( ) ; size = file . length ( ) ; } public RemoteFile ( String name , String path , long lastModified , long size , boolean isDirectory ) { this . name = name ; this . path = path ; this . lastModified = lastModified ; this . size = size ; this . isDirectory = isDirectory ; } public RemoteFile ( RemoteFile file ) { this . name = file . name ; this . path = file . path ; this . lastModified = file . lastModified ; this . size = file . size ; this . isDirectory = file . isDirectory ; } protected RemoteFile ( ) { } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + path + '<STR_LIT>' + "<STR_LIT>" + isDirectory + '<STR_LIT>' ; } public String getPath ( ) { return path ; } public boolean isDirectory ( ) { return isDirectory ; } public String getName ( ) { return name ; } public long getLastModified ( ) { return lastModified ; } public long getSize ( ) { return size ; } } </s>
<s> package com . gw . swipeback ; import android . app . Activity ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Color ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . FloatRange ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . MotionEventCompat ; import androidx . core . view . ViewCompat ; import androidx . customview . widget . ViewDragHelper ; import com . gw . swipeback . tools . Util ; import com . simon . harmonichackernews . R ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; public class SwipeBackLayout extends ViewGroup { private static final String TAG = "<STR_LIT>" ; public static final int FROM_LEFT = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_RIGHT = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_TOP = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_BOTTOM = <NUM_LIT> << <NUM_LIT> ; @ IntDef ( { FROM_LEFT , FROM_TOP , FROM_RIGHT , FROM_BOTTOM } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface DirectionMode { } private int mDirectionMode = FROM_LEFT ; private final ViewDragHelper mDragHelper ; private View mDragContentView ; private View innerScrollView ; private int width , height ; private int mTouchSlop ; private float swipeBackFactor = <NUM_LIT> ; private float swipeBackFraction ; private int maskAlpha = <NUM_LIT> ; private boolean isSwipeFromEdge = false ; private float downX , downY ; private boolean active = true ; private int leftOffset = <NUM_LIT> ; private int topOffset = <NUM_LIT> ; private float autoFinishedVelocityLimit = <NUM_LIT> ; private int touchedEdge = ViewDragHelper . INVALID_POINTER ; public SwipeBackLayout ( @ NonNull Context context ) { this ( context , null ) ; } public SwipeBackLayout ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public SwipeBackLayout ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; setWillNotDraw ( false ) ; mDragHelper = ViewDragHelper . create ( this , <NUM_LIT> , new DragHelperCallback ( ) ) ; mDragHelper . setEdgeTrackingEnabled ( mDirectionMode ) ; mTouchSlop = mDragHelper . getTouchSlop ( ) ; setSwipeBackListener ( defaultSwipeBackListener ) ; init ( context , attrs ) ; } private void init ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . SwipeBackLayout ) ; setDirectionMode ( a . getInt ( R . styleable . SwipeBackLayout_directionMode , mDirectionMode ) ) ; setSwipeBackFactor ( a . getFloat ( R . styleable . SwipeBackLayout_swipeBackFactor , swipeBackFactor ) ) ; setMaskAlpha ( a . getInteger ( R . styleable . SwipeBackLayout_maskAlpha , maskAlpha ) ) ; isSwipeFromEdge = a . getBoolean ( R . styleable . SwipeBackLayout_isSwipeFromEdge , isSwipeFromEdge ) ; a . recycle ( ) ; } public void attachToActivity ( Activity activity ) { ViewGroup decorView = ( ViewGroup ) activity . getWindow ( ) . getDecorView ( ) ; ViewGroup decorChild = ( ViewGroup ) decorView . getChildAt ( <NUM_LIT> ) ; decorChild . setBackgroundColor ( Color . TRANSPARENT ) ; decorView . removeView ( decorChild ) ; addView ( decorChild ) ; decorView . addView ( this ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; int childCount = getChildCount ( ) ; if ( childCount > <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } int defaultMeasuredWidth = <NUM_LIT> ; int defaultMeasuredHeight = <NUM_LIT> ; int measuredWidth ; int measuredHeight ; if ( childCount > <NUM_LIT> ) { measureChildren ( widthMeasureSpec , heightMeasureSpec ) ; mDragContentView = getChildAt ( <NUM_LIT> ) ; defaultMeasuredWidth = mDragContentView . getMeasuredWidth ( ) ; defaultMeasuredHeight = mDragContentView . getMeasuredHeight ( ) ; } measuredWidth = View . resolveSize ( defaultMeasuredWidth , widthMeasureSpec ) + getPaddingLeft ( ) + getPaddingRight ( ) ; measuredHeight = View . resolveSize ( defaultMeasuredHeight , heightMeasureSpec ) + getPaddingTop ( ) + getPaddingBottom ( ) ; setMeasuredDimension ( measuredWidth , measuredHeight ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { if ( getChildCount ( ) == <NUM_LIT> ) return ; int left = getPaddingLeft ( ) + leftOffset ; int top = getPaddingTop ( ) + topOffset ; int right = left + mDragContentView . getMeasuredWidth ( ) ; int bottom = top + mDragContentView . getMeasuredHeight ( ) ; mDragContentView . layout ( left , top , right , bottom ) ; if ( changed ) { width = getWidth ( ) ; height = getHeight ( ) ; } innerScrollView = Util . findAllScrollViews ( this ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; canvas . drawARGB ( maskAlpha - ( int ) ( maskAlpha * swipeBackFraction ) , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( ! active ) { return super . onInterceptTouchEvent ( ev ) ; } switch ( MotionEventCompat . getActionMasked ( ev ) ) { case MotionEvent . ACTION_DOWN : downX = ev . getRawX ( ) ; downY = ev . getRawY ( ) ; break ; case MotionEvent . ACTION_MOVE : if ( innerScrollView != null && Util . contains ( innerScrollView , downX , downY ) ) { float distanceX = Math . abs ( ev . getRawX ( ) - downX ) ; float distanceY = Math . abs ( ev . getRawY ( ) - downY ) ; if ( mDirectionMode == FROM_LEFT || mDirectionMode == FROM_RIGHT ) { if ( distanceY > mTouchSlop && distanceY > distanceX ) { return super . onInterceptTouchEvent ( ev ) ; } } else if ( mDirectionMode == FROM_TOP || mDirectionMode == FROM_BOTTOM ) { if ( distanceX > mTouchSlop && distanceX > distanceY ) { return super . onInterceptTouchEvent ( ev ) ; } } } break ; } boolean handled = mDragHelper . shouldInterceptTouchEvent ( ev ) ; return handled ? handled : super . onInterceptTouchEvent ( ev ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mDragHelper . processTouchEvent ( event ) ; return true ; } @ Override public void computeScroll ( ) { if ( mDragHelper . continueSettling ( true ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } public void smoothScrollToX ( int finalLeft ) { if ( mDragHelper . settleCapturedViewAt ( finalLeft , getPaddingTop ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } public void smoothScrollToY ( int finalTop ) { if ( mDragHelper . settleCapturedViewAt ( getPaddingLeft ( ) , finalTop ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } private class DragHelperCallback extends ViewDragHelper . Callback { @ Override public boolean tryCaptureView ( View child , int pointerId ) { return child == mDragContentView ; } @ Override public int clampViewPositionHorizontal ( View child , int left , int dx ) { leftOffset = getPaddingLeft ( ) ; if ( isSwipeEnabled ( ) ) { if ( mDirectionMode == FROM_LEFT && ! Util . canViewScrollRight ( innerScrollView , downX , downY , false ) ) { leftOffset = Math . min ( Math . max ( left , getPaddingLeft ( ) ) , width ) ; } else if ( mDirectionMode == FROM_RIGHT && ! Util . canViewScrollLeft ( innerScrollView , downX , downY , false ) ) { leftOffset = Math . min ( Math . max ( left , - width ) , getPaddingRight ( ) ) ; } } return leftOffset ; } @ Override public int clampViewPositionVertical ( View child , int top , int dy ) { topOffset = getPaddingTop ( ) ; if ( isSwipeEnabled ( ) ) { if ( mDirectionMode == FROM_TOP && ! Util . canViewScrollUp ( innerScrollView , downX , downY , false ) ) { topOffset = Math . min ( Math . max ( top , getPaddingTop ( ) ) , height ) ; } else if ( mDirectionMode == FROM_BOTTOM && ! Util . canViewScrollDown ( innerScrollView , downX , downY , false ) ) { topOffset = Math . min ( Math . max ( top , - height ) , getPaddingBottom ( ) ) ; } } return topOffset ; } @ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; left = Math . abs ( left ) ; top = Math . abs ( top ) ; switch ( mDirectionMode ) { case FROM_LEFT : case FROM_RIGHT : swipeBackFraction = <NUM_LIT> * left / width ; break ; case FROM_TOP : case FROM_BOTTOM : swipeBackFraction = <NUM_LIT> * top / height ; break ; } if ( mSwipeBackListener != null ) { mSwipeBackListener . onViewPositionChanged ( mDragContentView , swipeBackFraction , swipeBackFactor ) ; } } @ Override public void onViewReleased ( View releasedChild , float xvel , float yvel ) { super . onViewReleased ( releasedChild , xvel , yvel ) ; leftOffset = topOffset = <NUM_LIT> ; if ( ! isSwipeEnabled ( ) ) { touchedEdge = ViewDragHelper . INVALID_POINTER ; return ; } touchedEdge = ViewDragHelper . INVALID_POINTER ; boolean isBackToEnd = backJudgeBySpeed ( xvel , yvel ) || swipeBackFraction >= swipeBackFactor ; if ( isBackToEnd ) { switch ( mDirectionMode ) { case FROM_LEFT : smoothScrollToX ( width ) ; break ; case FROM_TOP : smoothScrollToY ( height ) ; break ; case FROM_RIGHT : smoothScrollToX ( - width ) ; break ; case FROM_BOTTOM : smoothScrollToY ( - height ) ; break ; } } else { switch ( mDirectionMode ) { case FROM_LEFT : case FROM_RIGHT : smoothScrollToX ( getPaddingLeft ( ) ) ; break ; case FROM_BOTTOM : case FROM_TOP : smoothScrollToY ( getPaddingTop ( ) ) ; break ; } } } @ Override public void onViewDragStateChanged ( int state ) { super . onViewDragStateChanged ( state ) ; if ( state == ViewDragHelper . STATE_IDLE ) { if ( mSwipeBackListener != null ) { if ( swipeBackFraction == <NUM_LIT> ) { mSwipeBackListener . onViewSwipeFinished ( mDragContentView , false ) ; } else if ( swipeBackFraction == <NUM_LIT> ) { mSwipeBackListener . onViewSwipeFinished ( mDragContentView , true ) ; } } } } @ Override public int getViewHorizontalDragRange ( View child ) { return width ; } @ Override public int getViewVerticalDragRange ( View child ) { return height ; } @ Override public void onEdgeTouched ( int edgeFlags , int pointerId ) { super . onEdgeTouched ( edgeFlags , pointerId ) ; touchedEdge = edgeFlags ; } } public void finish ( ) { ( ( Activity ) getContext ( ) ) . finish ( ) ; } private boolean isSwipeEnabled ( ) { if ( isSwipeFromEdge ) { switch ( mDirectionMode ) { case FROM_LEFT : return touchedEdge == ViewDragHelper . EDGE_LEFT ; case FROM_TOP : return touchedEdge == ViewDragHelper . EDGE_TOP ; case FROM_RIGHT : return touchedEdge == ViewDragHelper . EDGE_RIGHT ; case FROM_BOTTOM : return touchedEdge == ViewDragHelper . EDGE_BOTTOM ; } } return true ; } private boolean backJudgeBySpeed ( float xvel , float yvel ) { switch ( mDirectionMode ) { case FROM_LEFT : return xvel > autoFinishedVelocityLimit ; case FROM_TOP : return yvel > autoFinishedVelocityLimit ; case FROM_RIGHT : return xvel < - autoFinishedVelocityLimit ; case FROM_BOTTOM : return yvel < - autoFinishedVelocityLimit ; } return false ; } public void setSwipeBackFactor ( @ FloatRange ( from = <NUM_LIT> , to = <NUM_LIT> ) float swipeBackFactor ) { if ( swipeBackFactor > <NUM_LIT> ) { swipeBackFactor = <NUM_LIT> ; } else if ( swipeBackFactor < <NUM_LIT> ) { swipeBackFactor = <NUM_LIT> ; } this . swipeBackFactor = swipeBackFactor ; } public float getSwipeBackFactor ( ) { return swipeBackFactor ; } public void setMaskAlpha ( @ IntRange ( from = <NUM_LIT> , to = <NUM_LIT> ) int maskAlpha ) { if ( maskAlpha > <NUM_LIT> ) { maskAlpha = <NUM_LIT> ; } else if ( maskAlpha < <NUM_LIT> ) { maskAlpha = <NUM_LIT> ; } this . maskAlpha = maskAlpha ; } public int getMaskAlpha ( ) { return maskAlpha ; } public void setDirectionMode ( @ DirectionMode int direction ) { mDirectionMode = direction ; mDragHelper . setEdgeTrackingEnabled ( direction ) ; } public void setActive ( boolean a ) { active = a ; } public int getDirectionMode ( ) { return mDirectionMode ; } public float getAutoFinishedVelocityLimit ( ) { return autoFinishedVelocityLimit ; } public void setAutoFinishedVelocityLimit ( float autoFinishedVelocityLimit ) { this . autoFinishedVelocityLimit = autoFinishedVelocityLimit ; } public boolean isSwipeFromEdge ( ) { return isSwipeFromEdge ; } public void setSwipeFromEdge ( boolean isSwipeFromEdge ) { this . isSwipeFromEdge = isSwipeFromEdge ; } private OnSwipeBackListener mSwipeBackListener ; private OnSwipeBackListener defaultSwipeBackListener = new OnSwipeBackListener ( ) { @ Override public void onViewPositionChanged ( View mView , float swipeBackFraction , float swipeBackFactor ) { invalidate ( ) ; } @ Override public void onViewSwipeFinished ( View mView , boolean isEnd ) { if ( isEnd ) { finish ( ) ; } } } ; public void setSwipeBackListener ( OnSwipeBackListener mSwipeBackListener ) { this . mSwipeBackListener = mSwipeBackListener ; } public interface OnSwipeBackListener { void onViewPositionChanged ( View mView , float swipeBackFraction , float swipeBackFactor ) ; void onViewSwipeFinished ( View mView , boolean isEnd ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . text . Layout ; import android . text . style . LeadingMarginSpan ; import android . text . style . LineBackgroundSpan ; import androidx . annotation . NonNull ; public class DesignQuoteSpan implements LeadingMarginSpan , LineBackgroundSpan { private int backgroundColor , stripColor ; private float stripeWidth , gap ; DesignQuoteSpan ( int backgroundColor , int stripColor , float stripWidth , float gap ) { this . backgroundColor = backgroundColor ; this . stripColor = stripColor ; this . stripeWidth = stripWidth ; this . gap = gap ; } @ Override public int getLeadingMargin ( boolean first ) { return ( int ) ( stripeWidth + gap ) ; } @ Override public void drawLeadingMargin ( Canvas c , Paint p , int x , int dir , int top , int baseline , int bottom , CharSequence text , int start , int end , boolean first , Layout layout ) { Paint . Style style = p . getStyle ( ) ; int paintColor = p . getColor ( ) ; p . setStyle ( Paint . Style . FILL ) ; p . setColor ( stripColor ) ; c . drawRect ( ( float ) x , ( float ) top , x + dir * stripeWidth , ( float ) bottom , p ) ; p . setStyle ( style ) ; p . setColor ( paintColor ) ; } @ Override public void drawBackground ( @ NonNull Canvas canvas , @ NonNull Paint paint , int left , int right , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , int lineNumber ) { int paintColor = paint . getColor ( ) ; paint . setColor ( backgroundColor ) ; canvas . drawRect ( ( float ) left , ( float ) top , ( float ) right , ( float ) bottom , paint ) ; paint . setColor ( paintColor ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . graphics . Typeface ; import android . util . TypedValue ; import android . widget . TextView ; import androidx . core . content . res . ResourcesCompat ; import com . simon . harmonichackernews . R ; public class FontUtils { public static Typeface activeRegular ; public static Typeface activeBold ; public static String font ; public static void init ( Context ctx ) { font = SettingsUtils . getPreferredFont ( ctx ) ; switch ( font ) { case "<STR_LIT>" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . product_sans ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . product_sans_bold ) ; break ; case "<STR_LIT>" : activeRegular = Typeface . create ( "<STR_LIT>" , Typeface . NORMAL ) ; activeBold = Typeface . create ( "<STR_LIT>" , Typeface . BOLD ) ; break ; case "<STR_LIT>" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . verdana ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . verdana_bold ) ; break ; case "<STR_LIT>" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . jetbrains_mono ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . jetbrains_mono_bold ) ; break ; case "<STR_LIT>" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . georgia ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . georgia_bold ) ; break ; case "<STR_LIT>" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . roboto_slab ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . roboto_slab_bold ) ; break ; } } public static void setTypeface ( TextView textView , boolean bold , float size ) { setTypeface ( textView , bold , size , size , size , size , size , size ) ; } public static void setMultipleTypefaces ( boolean bold , float prodSize , float sansSize , float verdanaSize , float jetbrainsmonoSize , float georgiaSize , float robotoSlabSize , TextView ... textViews ) { for ( TextView textView : textViews ) { FontUtils . setTypeface ( textView , bold , prodSize , sansSize , verdanaSize , jetbrainsmonoSize , georgiaSize , robotoSlabSize ) ; } } public static void setTypeface ( TextView textView , boolean bold , float prodSize , float sansSize , float verdanaSize , float jetbrainsmonoSize , float georgiaSize , float robotoSlabSize ) { if ( activeRegular == null ) { init ( textView . getContext ( ) ) ; } textView . setTypeface ( bold ? activeBold : activeRegular ) ; switch ( font ) { case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , prodSize ) ; break ; case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , sansSize ) ; break ; case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , verdanaSize ) ; break ; case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , jetbrainsmonoSize ) ; break ; case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , georgiaSize ) ; break ; case "<STR_LIT>" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , robotoSlabSize ) ; break ; } } } </s>
<s> package com . simon . harmonichackernews . adapters ; import android . graphics . drawable . RippleDrawable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Comment ; import com . simon . harmonichackernews . utils . ThemeUtils ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class CommentSearchAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { public static final int TYPE_COMMENT = <NUM_LIT> ; public static final int TYPE_COLLAPSED = <NUM_LIT> ; private final List < Comment > comments ; private String searchTerm ; public ItemClickListener itemClickListener ; private String markedColor ; public CommentSearchAdapter ( List < Comment > comments ) { this . comments = comments ; } public void setSearchTerm ( String searchTerm ) { this . searchTerm = searchTerm ; } public void setItemClickListener ( ItemClickListener clickListener ) { itemClickListener = clickListener ; } public class CommentViewHolder extends RecyclerView . ViewHolder { public HtmlTextView commentText ; public TextView commentBy ; public LinearLayout container ; public CommentViewHolder ( View view ) { super ( view ) ; commentText = view . findViewById ( R . id . comment_search_item_text ) ; commentBy = view . findViewById ( R . id . comment_search_item_by ) ; container = view . findViewById ( R . id . comment_search_item_container ) ; container . setOnClickListener ( ( v ) -> { itemClickListener . onItemClick ( comments . get ( getAbsoluteAdapterPosition ( ) ) ) ; } ) ; markedColor = ThemeUtils . isDarkMode ( view . getContext ( ) ) ? "<STR_LIT>" : "<STR_LIT>" ; final RippleDrawable rippleDrawable = ( RippleDrawable ) container . getBackground ( ) ; commentText . setOnTouchListener ( new View . OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : rippleDrawable . setHotspot ( event . getX ( ) , event . getY ( ) ) ; container . setPressed ( true ) ; return true ; case MotionEvent . ACTION_UP : container . performClick ( ) ; container . setPressed ( false ) ; return true ; case MotionEvent . ACTION_CANCEL : container . setPressed ( false ) ; return true ; } return false ; } } ) ; } } @ NonNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { if ( viewType == TYPE_COMMENT ) { View v = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . comments_search_item , parent , false ) ; return new CommentViewHolder ( v ) ; } else { return new RecyclerView . ViewHolder ( new View ( parent . getContext ( ) ) ) { } ; } } @ Override public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position ) { if ( ! ( holder instanceof CommentSearchAdapter . CommentViewHolder ) ) { return ; } final CommentViewHolder commentViewHolder = ( CommentViewHolder ) holder ; Comment comment = comments . get ( position ) ; String text = comment . text ; StringBuffer sb = new StringBuffer ( ) ; if ( ! TextUtils . isEmpty ( searchTerm ) ) { Pattern pattern = Pattern . compile ( "<STR_LIT>" + Pattern . quote ( searchTerm ) ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { String replacement = "<STR_LIT>" + markedColor + "<STR_LIT>" + matcher . group ( ) + "<STR_LIT>" ; matcher . appendReplacement ( sb , Matcher . quoteReplacement ( replacement ) ) ; } matcher . appendTail ( sb ) ; text = sb . toString ( ) ; } commentViewHolder . commentText . setHtml ( text ) ; commentViewHolder . commentBy . setText ( comment . by ) ; } @ Override public int getItemViewType ( int position ) { return TextUtils . isEmpty ( searchTerm ) || comments . get ( position ) . text . toUpperCase ( ) . contains ( searchTerm . toUpperCase ( ) ) ? TYPE_COMMENT : TYPE_COLLAPSED ; } @ Override public int getItemCount ( ) { return comments . size ( ) ; } public interface ItemClickListener { void onItemClick ( Comment comment ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . os . Environment ; import android . os . Handler ; import android . os . Looper ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . WorkerThread ; import com . simon . harmonichackernews . network . NetworkComponent ; import java . io . File ; import java . io . IOException ; import okhttp3 . Call ; import okhttp3 . Callback ; import okhttp3 . Request ; import okhttp3 . Response ; import okio . BufferedSink ; import okio . Okio ; public class FileDownloader { private String mCacheDir ; private final Handler mMainHandler ; public FileDownloader ( Context ctx ) { if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) || ! Environment . isExternalStorageRemovable ( ) ) { if ( ctx . getExternalCacheDir ( ) != null ) { mCacheDir = ctx . getExternalCacheDir ( ) . getPath ( ) ; } } else { if ( ctx . getCacheDir ( ) != null ) { mCacheDir = ctx . getCacheDir ( ) . getPath ( ) ; } } mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; } @ WorkerThread public void downloadFile ( String url , String mimeType , FileDownloaderCallback callback ) { if ( TextUtils . isEmpty ( mCacheDir ) ) { mMainHandler . post ( ( ) -> callback . onFailure ( null , null ) ) ; return ; } File outputFile = new File ( mCacheDir , new File ( url ) . getName ( ) ) ; if ( outputFile . exists ( ) ) { mMainHandler . post ( ( ) -> callback . onSuccess ( outputFile . getPath ( ) ) ) ; return ; } final Request request = new Request . Builder ( ) . url ( url ) . addHeader ( "<STR_LIT>" , mimeType ) . build ( ) ; NetworkComponent . getOkHttpClientInstance ( ) . newCall ( request ) . enqueue ( new Callback ( ) { @ Override public void onFailure ( @ NonNull Call call , @ NonNull IOException e ) { mMainHandler . post ( ( ) -> callback . onFailure ( call , e ) ) ; } @ Override public void onResponse ( @ NonNull Call call , @ NonNull Response response ) { try { BufferedSink sink = Okio . buffer ( Okio . sink ( outputFile ) ) ; sink . writeAll ( response . body ( ) . source ( ) ) ; sink . close ( ) ; mMainHandler . post ( ( ) -> callback . onSuccess ( outputFile . getPath ( ) ) ) ; } catch ( IOException e ) { this . onFailure ( call , e ) ; } } } ) ; } public interface FileDownloaderCallback { void onFailure ( Call call , IOException e ) ; void onSuccess ( String filePath ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . app . Activity ; import androidx . annotation . OptIn ; import androidx . window . embedding . SplitAttributes . SplitType ; import androidx . window . embedding . SplitController ; import androidx . window . embedding . SplitInfo ; import androidx . window . java . embedding . SplitControllerCallbackAdapter ; import com . gw . swipeback . SwipeBackLayout ; import java . util . List ; @ OptIn ( markerClass = androidx . window . core . ExperimentalWindowApi . class ) public class SplitChangeHandler { private final SplitControllerCallbackAdapter splitCallbackAdapter ; private final SwipeBackLayout layout ; private boolean isWithinSplit = false ; public SplitChangeHandler ( Activity activity , SwipeBackLayout swipeBackLayout ) { this . splitCallbackAdapter = new SplitControllerCallbackAdapter ( SplitController . getInstance ( activity ) ) ; this . layout = swipeBackLayout ; splitCallbackAdapter . addSplitListener ( activity , Runnable :: run , this :: onSplitListUpdate ) ; } private void onSplitListUpdate ( List < SplitInfo > splitInfoList ) { for ( SplitInfo split : splitInfoList ) { if ( ! split . getSplitAttributes ( ) . getSplitType ( ) . equals ( SplitType . SPLIT_TYPE_EXPAND ) ) { isWithinSplit = true ; break ; } isWithinSplit = false ; } layout . setMaskAlpha ( isWithinSplit ? <NUM_LIT> : <NUM_LIT> ) ; } public boolean isWithinSplit ( ) { return isWithinSplit ; } public void teardown ( ) { splitCallbackAdapter . removeSplitListener ( this :: onSplitListUpdate ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . text . TextUtils ; import androidx . fragment . app . FragmentManager ; import com . simon . harmonichackernews . LoginDialogFragment ; import kotlin . Triple ; public class AccountUtils { private final static String KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME = "<STR_LIT>" ; private final static String KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD = "<STR_LIT>" ; public final static int FAILURE_MODE_NONE = - <NUM_LIT> ; public final static int FAILURE_MODE_MAINKEY = <NUM_LIT> ; public final static int FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION = <NUM_LIT> ; public final static int FAILURE_MODE_NO_USERNAME = <NUM_LIT> ; public final static int FAILURE_MODE_NO_PASSWORD = <NUM_LIT> ; public static String getAccountUsername ( Context ctx ) { return SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME ) ; } public static void setAccountUsername ( Context ctx , String username ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME , username ) ; } public static boolean hasAccountDetails ( Context ctx ) { Triple < String , String , Integer > account = getAccountDetails ( ctx ) ; return ( account . getThird ( ) == FAILURE_MODE_NONE && ! TextUtils . isEmpty ( account . getFirst ( ) ) && ! TextUtils . isEmpty ( account . getSecond ( ) ) ) ; } public static Triple < String , String , Integer > getAccountDetails ( Context ctx ) { SharedPreferences sharedPreferences ; try { sharedPreferences = EncryptedSharedPreferencesHelper . getEncryptedSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return new Triple < > ( null , null , FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION ) ; } String username = getAccountUsername ( ctx ) ; String password = sharedPreferences . getString ( KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD , null ) ; if ( TextUtils . isEmpty ( username ) || TextUtils . isEmpty ( password ) ) { Utils . log ( "<STR_LIT>" + TextUtils . isEmpty ( username ) + "<STR_LIT>" + TextUtils . isEmpty ( password ) ) ; } if ( TextUtils . isEmpty ( username ) ) { return new Triple < > ( username , password , FAILURE_MODE_NO_USERNAME ) ; } if ( TextUtils . isEmpty ( password ) ) { return new Triple < > ( username , password , FAILURE_MODE_NO_PASSWORD ) ; } return new Triple < > ( username , password , FAILURE_MODE_NONE ) ; } public static void deleteAccountDetails ( Context ctx ) { setAccountDetails ( ctx , null , null ) ; boolean deleted = EncryptedSharedPreferencesHelper . deleteSharedPreferences ( ctx ) ; if ( ! deleted ) { Utils . toast ( "<STR_LIT>" , ctx ) ; } } public static void setAccountDetails ( Context ctx , String username , String password ) { SharedPreferences sharedPreferences ; try { sharedPreferences = EncryptedSharedPreferencesHelper . getEncryptedSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } SharedPreferences . Editor sharedPrefsEditor = sharedPreferences . edit ( ) ; sharedPrefsEditor . putString ( KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD , password ) ; sharedPrefsEditor . apply ( ) ; setAccountUsername ( ctx , username ) ; } public static void showLoginPrompt ( FragmentManager fm ) { new LoginDialogFragment ( ) . show ( fm , LoginDialogFragment . TAG ) ; } public static boolean handlePossibleError ( Triple < String , String , Integer > account , FragmentManager fm , Context ctx ) { if ( account . getThird ( ) == AccountUtils . FAILURE_MODE_NONE ) { return false ; } if ( fm != null ) { AccountUtils . showLoginPrompt ( fm ) ; } switch ( account . getThird ( ) ) { case AccountUtils . FAILURE_MODE_MAINKEY : Utils . toast ( "<STR_LIT>" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION : Utils . toast ( "<STR_LIT>" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_NO_USERNAME : Utils . toast ( "<STR_LIT>" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_NO_PASSWORD : Utils . toast ( "<STR_LIT>" , ctx ) ; break ; } return true ; } } </s>
<s> package com . simon . harmonichackernews ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import android . text . Html ; import android . view . View ; import android . widget . TextView ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . utils . Changelog ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; public class AboutActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_about ) ; String versionText = "<STR_LIT>" + BuildConfig . VERSION_NAME ; if ( BuildConfig . DEBUG ) { versionText += String . format ( "<STR_LIT>" , BuildConfig . BUILD_TYPE ) ; } ( ( TextView ) findViewById ( R . id . about_version ) ) . setText ( versionText ) ; } public void openGithub ( View v ) { String url = "<STR_LIT>" ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; } public void openChangelog ( View v ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( "<STR_LIT>" ) . setMessage ( Html . fromHtml ( Changelog . getHTML ( ) ) ) . setNegativeButton ( "<STR_LIT>" , null ) . create ( ) ; dialog . show ( ) ; } public void openPrivacy ( View v ) { Utils . launchCustomTab ( this , "<STR_LIT>" ) ; } } </s>
<s> package com . gw . swipeback . tools ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; import java . util . Stack ; public class WxSwipeBackActivityManager extends ActivityLifecycleCallbacksAdapter { private static final WxSwipeBackActivityManager instance = new WxSwipeBackActivityManager ( ) ; private Stack < Activity > mActivityStack = new Stack < > ( ) ; private WxSwipeBackActivityManager ( ) { } public static WxSwipeBackActivityManager getInstance ( ) { return instance ; } public void init ( Application mApplication ) { mApplication . registerActivityLifecycleCallbacks ( this ) ; } @ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) { mActivityStack . add ( activity ) ; } @ Override public void onActivityDestroyed ( Activity activity ) { mActivityStack . remove ( activity ) ; } public Activity getPenultimateActivity ( ) { return mActivityStack . size ( ) >= <NUM_LIT> ? mActivityStack . get ( mActivityStack . size ( ) - <NUM_LIT> ) : null ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . res . Resources ; import android . text . Layout ; import android . text . TextWatcher ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; public class ViewUtils { public static void setUpSwipeRefreshWithStatusBarOffset ( SwipeRefreshLayout layout ) { int start = layout . getProgressViewStartOffset ( ) ; int end = layout . getProgressViewEndOffset ( ) ; ViewCompat . setOnApplyWindowInsetsListener ( layout , ( v , insets ) -> { int top = insets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) . top ; if ( SettingsUtils . shouldUseTransparentStatusBar ( layout . getContext ( ) ) ) { layout . setProgressViewOffset ( false , start , end + top ) ; } else { layout . setProgressViewOffset ( false , start + top , end + top ) ; } return insets ; } ) ; requestApplyInsetsWhenAttached ( layout ) ; } public static void requestApplyInsetsWhenAttached ( @ NonNull View view ) { if ( ViewCompat . isAttachedToWindow ( view ) ) { ViewCompat . requestApplyInsets ( view ) ; } else { view . addOnAttachStateChangeListener ( new View . OnAttachStateChangeListener ( ) { @ Override public void onViewAttachedToWindow ( @ NonNull View v ) { v . removeOnAttachStateChangeListener ( this ) ; ViewCompat . requestApplyInsets ( v ) ; } @ Override public void onViewDetachedFromWindow ( View v ) { } } ) ; } } public static int getNavigationBarHeight ( Resources res ) { int resourceId = res . getIdentifier ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( resourceId > <NUM_LIT> ) { return res . getDimensionPixelSize ( resourceId ) ; } return <NUM_LIT> ; } public static boolean isTextTruncated ( TextView textView ) { Layout layout = textView . getLayout ( ) ; if ( layout != null ) { int maxLines = textView . getMaxLines ( ) ; if ( maxLines == - <NUM_LIT> ) { return false ; } int lineCount = layout . getLineCount ( ) ; if ( lineCount <= maxLines ) { return false ; } else { return true ; } } return false ; } public abstract static class SimpleTextWatcher implements TextWatcher { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . text . Html ; import android . util . Log ; import android . widget . TextView ; import java . io . IOException ; import java . io . InputStream ; public class HtmlAssetsImageGetter implements Html . ImageGetter { private final Context context ; public HtmlAssetsImageGetter ( Context context ) { this . context = context ; } public HtmlAssetsImageGetter ( TextView textView ) { this . context = textView . getContext ( ) ; } @ Override public Drawable getDrawable ( String source ) { try { InputStream inputStream = context . getAssets ( ) . open ( source ) ; Drawable d = Drawable . createFromStream ( inputStream , null ) ; d . setBounds ( <NUM_LIT> , <NUM_LIT> , d . getIntrinsicWidth ( ) , d . getIntrinsicHeight ( ) ) ; return d ; } catch ( IOException e ) { Log . e ( HtmlTextView . TAG , "<STR_LIT>" + source ) ; return null ; } } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . view . View ; import androidx . annotation . Nullable ; public interface OnClickATagListener { boolean onClick ( View widget , String spannedText , @ Nullable String href ) ; } </s>
<s> package com . simon . harmonichackernews . adapters ; import static android . view . View . GONE ; import static android . view . View . VISIBLE ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Context ; import android . content . SharedPreferences ; import android . text . Html ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . style . ImageSpan ; import android . util . DisplayMetrics ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageButton ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . ProgressBar ; import android . widget . RelativeLayout ; import android . widget . Space ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . TooltipCompat ; import androidx . core . view . ViewCompat ; import androidx . fragment . app . FragmentManager ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . bottomsheet . BottomSheetBehavior ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . color . MaterialColors ; import com . google . android . material . progressindicator . CircularProgressIndicator ; import com . google . android . material . snackbar . Snackbar ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Comment ; import com . simon . harmonichackernews . data . PollOption ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . FaviconLoader ; import com . simon . harmonichackernews . network . UserActions ; import com . simon . harmonichackernews . utils . FontUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import org . jetbrains . annotations . NotNull ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . List ; public class CommentsRecyclerViewAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { private final List < Comment > comments ; private HeaderClickListener headerClickListener ; private CommentClickListener commentClickListener ; private CommentClickListener commentLongClickListener ; private HeaderActionClickListener headerActionClickListener ; private RetryListener retryListener ; public LinearLayout bottomSheet ; public FragmentManager fragmentManager ; public Story story ; public boolean loadingFailed = false ; public boolean loadingFailedServerError = false ; public boolean commentsLoaded = false ; public boolean collapseParent ; public boolean showThumbnail ; public boolean monochromeCommentDepthIndicators ; public boolean showNavigationBar ; public boolean showInvert ; public String faviconProvider ; public boolean integratedWebview ; public boolean showTopLevelDepthIndicator ; public boolean swapLongPressTap ; public String username ; public int preferredTextSize ; private final boolean isTablet ; public String theme ; public String font ; public boolean showUpdate = false ; public int spacerHeight = <NUM_LIT> ; private int navbarHeight = <NUM_LIT> ; public boolean disableCommentATagClick = false ; public static final int TYPE_HEADER = <NUM_LIT> ; public static final int TYPE_COMMENT = <NUM_LIT> ; public static final int TYPE_COLLAPSED = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_USER = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_COMMENT = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_VOTE = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_SHARE = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_MORE = <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_REFRESH = - <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_EXPAND = - <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_BROWSER = - <NUM_LIT> ; public final static int FLAG_ACTION_CLICK_INVERT = - <NUM_LIT> ; private static final int [ ] commentDepthColorsDark = new int [ ] { R . color . commentIndentIndicatorColor1 , R . color . commentIndentIndicatorColor2 , R . color . commentIndentIndicatorColor3 , R . color . commentIndentIndicatorColor4 , R . color . commentIndentIndicatorColor5 , R . color . commentIndentIndicatorColor6 , R . color . commentIndentIndicatorColor7 } ; private static final int [ ] commentDepthColorsMaterial = new int [ ] { R . color . material_you_primary60 , R . color . material_you_secondary60 , R . color . material_you_tertiary50 , R . color . material_you_neutral_variant50 , R . color . commentIndentIndicatorColor5 , R . color . commentIndentIndicatorColor6 , R . color . commentIndentIndicatorColor7 } ; private static final int [ ] commentDepthColorsLight = new int [ ] { R . color . commentIndentIndicatorColor1light , R . color . commentIndentIndicatorColor2light , R . color . commentIndentIndicatorColor3light , R . color . commentIndentIndicatorColor4light , R . color . commentIndentIndicatorColor5light , R . color . commentIndentIndicatorColor6light , R . color . commentIndentIndicatorColor7light } ; public CommentsRecyclerViewAdapter ( boolean useIntegratedWebview , LinearLayout sheet , FragmentManager fm , List < Comment > items , Story masterItem , boolean shouldCollapseParent , boolean shouldShowThumbnail , String usernameParam , int prefTextSize , boolean shouldUseMonochromeCommentDepthIndicators , boolean shouldShowNavigationBar , String prefFont , boolean shouldShowInvert , boolean shouldShowTopLevelDepthIndicator , String prefTheme , boolean tablet , String favProvider , boolean shouldSwapLongPressTap ) { integratedWebview = useIntegratedWebview ; bottomSheet = sheet ; fragmentManager = fm ; comments = items ; story = masterItem ; collapseParent = shouldCollapseParent ; showThumbnail = shouldShowThumbnail ; monochromeCommentDepthIndicators = shouldUseMonochromeCommentDepthIndicators ; showNavigationBar = shouldShowNavigationBar ; username = usernameParam ; preferredTextSize = prefTextSize ; font = prefFont ; showInvert = shouldShowInvert ; showTopLevelDepthIndicator = shouldShowTopLevelDepthIndicator ; theme = prefTheme ; isTablet = tablet ; faviconProvider = favProvider ; swapLongPressTap = shouldSwapLongPressTap ; } @ NotNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { if ( viewType == TYPE_COMMENT ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . comments_item , parent , false ) ; return new ItemViewHolder ( view ) ; } else if ( viewType == TYPE_COLLAPSED ) { return new RecyclerView . ViewHolder ( new View ( parent . getContext ( ) ) ) { } ; } else { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . comments_header , parent , false ) ; return new HeaderViewHolder ( view ) ; } } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position ) { Context ctx = holder . itemView . getContext ( ) ; if ( holder instanceof HeaderViewHolder ) { final HeaderViewHolder headerViewHolder = ( HeaderViewHolder ) holder ; if ( story . isLink && story . url != null ) { try { headerViewHolder . urlView . setText ( "<STR_LIT>" + Utils . getDomainName ( story . url ) + "<STR_LIT>" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } headerViewHolder . headerView . setClickable ( story . isLink ) ; headerViewHolder . linkImage . setVisibility ( story . isLink && ! story . isComment ? View . VISIBLE : GONE ) ; headerViewHolder . textView . setVisibility ( TextUtils . isEmpty ( story . text ) ? GONE : View . VISIBLE ) ; headerViewHolder . infoContainer . setVisibility ( story . hasExtraInfo ( ) ? View . VISIBLE : GONE ) ; if ( ! TextUtils . isEmpty ( story . text ) ) { headerViewHolder . textView . setHtml ( story . text ) ; } if ( story . arxivInfo != null ) { headerViewHolder . arxivContainer . setVisibility ( View . VISIBLE ) ; headerViewHolder . infoHeader . setVisibility ( VISIBLE ) ; headerViewHolder . infoHeader . setText ( "<STR_LIT>" ) ; headerViewHolder . arxivAbstract . setHtml ( story . arxivInfo . arxivAbstract ) ; headerViewHolder . arxivBy . setText ( story . arxivInfo . concatNames ( ) ) ; headerViewHolder . arxivDate . setText ( story . arxivInfo . formatDate ( ) ) ; headerViewHolder . arxivSubjects . setText ( story . arxivInfo . formatSubjects ( ) ) ; int byIconResource = R . drawable . ic_action_group ; if ( story . arxivInfo . authors . length == <NUM_LIT> ) { byIconResource = R . drawable . ic_action_person ; } else if ( story . arxivInfo . authors . length == <NUM_LIT> ) { byIconResource = R . drawable . ic_action_pair ; } headerViewHolder . arxivByIcon . setImageResource ( byIconResource ) ; FontUtils . setTypeface ( headerViewHolder . arxivAbstract , false , <NUM_LIT> ) ; } if ( story . repoInfo != null ) { headerViewHolder . githubContainer . setVisibility ( View . VISIBLE ) ; headerViewHolder . infoHeader . setVisibility ( VISIBLE ) ; headerViewHolder . infoHeader . setText ( story . repoInfo . owner + "<STR_LIT>" + story . repoInfo . name ) ; headerViewHolder . githubAbout . setText ( story . repoInfo . about ) ; headerViewHolder . githubWebsite . setHtml ( "<STR_LIT>" + story . repoInfo . website + "<STR_LIT>" + story . repoInfo . getShortenedUrl ( ) + "<STR_LIT>" ) ; headerViewHolder . githubLicense . setText ( story . repoInfo . license ) ; headerViewHolder . githubLanguage . setText ( story . repoInfo . language ) ; headerViewHolder . githubStars . setText ( story . repoInfo . formatStars ( ) ) ; headerViewHolder . githubWatching . setText ( story . repoInfo . formatWatching ( ) ) ; headerViewHolder . githubForks . setText ( story . repoInfo . formatForks ( ) ) ; headerViewHolder . githubWebsiteContainer . setVisibility ( TextUtils . isEmpty ( story . repoInfo . website ) ? GONE : View . VISIBLE ) ; headerViewHolder . githubLicenseContainer . setVisibility ( TextUtils . isEmpty ( story . repoInfo . license ) ? GONE : View . VISIBLE ) ; headerViewHolder . githubLanguageContainer . setVisibility ( TextUtils . isEmpty ( story . repoInfo . language ) ? GONE : View . VISIBLE ) ; headerViewHolder . githubAbout . setVisibility ( TextUtils . isEmpty ( story . repoInfo . about ) ? GONE : VISIBLE ) ; } if ( story . wikiInfo != null ) { headerViewHolder . wikiContainer . setVisibility ( View . VISIBLE ) ; headerViewHolder . infoHeader . setVisibility ( VISIBLE ) ; headerViewHolder . infoHeader . setText ( "<STR_LIT>" ) ; headerViewHolder . wikiSummary . setHtml ( story . wikiInfo . summary ) ; } if ( story . pollOptionArrayList != null ) { headerViewHolder . pollLayout . setVisibility ( View . VISIBLE ) ; headerViewHolder . pollLayout . removeAllViews ( ) ; for ( int i = <NUM_LIT> ; i < story . pollOptionArrayList . size ( ) ; i ++ ) { PollOption pollOption = story . pollOptionArrayList . get ( i ) ; if ( pollOption . loaded ) { MaterialButton materialButton = new MaterialButton ( ctx , null , com . google . android . material . R . attr . materialButtonOutlinedStyle ) ; materialButton . setText ( pollOption . text + "<STR_LIT>" + pollOption . points + ( pollOption . points == <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" ) + "<STR_LIT>" ) ; materialButton . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorNormal ) ) ; materialButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { UserActions . upvote ( ctx , pollOption . id , fragmentManager ) ; } } ) ; headerViewHolder . pollLayout . addView ( materialButton ) ; } else { ProgressBar progressBar = new ProgressBar ( ctx ) ; headerViewHolder . pollLayout . addView ( progressBar ) ; } } } else { headerViewHolder . pollLayout . setVisibility ( GONE ) ; } if ( ! TextUtils . isEmpty ( story . pdfTitle ) ) { SpannableStringBuilder sb = new SpannableStringBuilder ( story . pdfTitle + "<STR_LIT>" ) ; ImageSpan imageSpan = new ImageSpan ( ctx , R . drawable . ic_action_pdf_large ) ; sb . setSpan ( imageSpan , story . pdfTitle . length ( ) , story . pdfTitle . length ( ) + <NUM_LIT> , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; headerViewHolder . titleView . setText ( sb ) ; } else { headerViewHolder . titleView . setText ( story . title ) ; } if ( story . loaded ) { headerViewHolder . metaVotes . setText ( String . valueOf ( story . score ) ) ; headerViewHolder . metaComments . setText ( String . valueOf ( story . descendants ) ) ; headerViewHolder . metaTime . setText ( story . getTimeFormatted ( ) ) ; headerViewHolder . metaBy . setText ( story . by ) ; } headerViewHolder . metaContainer . setVisibility ( story . loaded ? View . VISIBLE : GONE ) ; headerViewHolder . urlView . setVisibility ( story . isLink ? View . VISIBLE : GONE ) ; headerViewHolder . metaVotes . setVisibility ( story . isComment ? GONE : View . VISIBLE ) ; headerViewHolder . metaVotesIcon . setVisibility ( story . isComment ? GONE : View . VISIBLE ) ; FontUtils . setMultipleTypefaces ( false , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , headerViewHolder . urlView , headerViewHolder . metaVotes , headerViewHolder . metaComments , headerViewHolder . metaTime , headerViewHolder . metaBy ) ; FontUtils . setTypeface ( headerViewHolder . titleView , true , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; FontUtils . setTypeface ( headerViewHolder . textView , false , preferredTextSize ) ; if ( loadingFailed ) { headerViewHolder . loadingIndicator . setVisibility ( GONE ) ; headerViewHolder . emptyView . setVisibility ( GONE ) ; } else { if ( commentsLoaded ) { headerViewHolder . loadingIndicator . setVisibility ( GONE ) ; headerViewHolder . emptyView . setVisibility ( story . descendants > <NUM_LIT> ? GONE : View . VISIBLE ) ; } else { headerViewHolder . loadingIndicator . setVisibility ( View . VISIBLE ) ; headerViewHolder . emptyView . setVisibility ( GONE ) ; } } headerViewHolder . spacer . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , spacerHeight ) ) ; headerViewHolder . refreshButton . setVisibility ( showUpdate ? View . VISIBLE : GONE ) ; int actionContainerPadding = Math . round ( headerViewHolder . actionsContainer . getResources ( ) . getDimension ( R . dimen . comments_header_action_padding ) ) ; headerViewHolder . actionsContainer . setPadding ( actionContainerPadding , <NUM_LIT> , actionContainerPadding , <NUM_LIT> ) ; headerViewHolder . favicon . setVisibility ( showThumbnail ? View . VISIBLE : GONE ) ; headerViewHolder . linkInfoContainer . setVisibility ( ! story . isComment && story . isLink ? View . VISIBLE : GONE ) ; if ( showThumbnail && ! TextUtils . isEmpty ( story . url ) ) { FaviconLoader . loadFavicon ( story . url , headerViewHolder . favicon , ctx , faviconProvider ) ; } headerViewHolder . bookmarkButton . setImageResource ( Utils . isBookmarked ( ctx , story . id ) ? R . drawable . ic_action_bookmark_filled : R . drawable . ic_action_bookmark_border ) ; headerViewHolder . bookmarkButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { boolean wasBookmarked = Utils . isBookmarked ( view . getContext ( ) , story . id ) ; if ( wasBookmarked ) { Utils . removeBookmark ( view . getContext ( ) , story . id ) ; } else { Utils . addBookmark ( view . getContext ( ) , story . id ) ; } notifyItemChanged ( <NUM_LIT> ) ; Snackbar snackbar = Snackbar . make ( view , wasBookmarked ? "<STR_LIT>" : "<STR_LIT>" , Snackbar . LENGTH_SHORT ) ; ViewCompat . setElevation ( snackbar . getView ( ) , Utils . pxFromDp ( view . getResources ( ) , <NUM_LIT> ) ) ; if ( showNavigationBar ) { snackbar . getView ( ) . setTranslationY ( - ctx . getResources ( ) . getDimensionPixelSize ( R . dimen . comments_bottom_navigation ) ) ; } snackbar . show ( ) ; } } ) ; headerViewHolder . emptyViewText . setText ( story . isComment ? "<STR_LIT>" : "<STR_LIT>" ) ; headerViewHolder . bookmarkButtonParent . setVisibility ( story . isComment ? GONE : View . VISIBLE ) ; headerViewHolder . commentButtonParent . setVisibility ( Utils . timeInSecondsMoreThanTwoWeeksAgo ( story . time ) ? GONE : View . VISIBLE ) ; headerViewHolder . loadingFailed . setVisibility ( loadingFailed ? View . VISIBLE : GONE ) ; headerViewHolder . serverErrorLayout . setVisibility ( loadingFailedServerError ? View . VISIBLE : GONE ) ; } else if ( holder instanceof ItemViewHolder ) { final ItemViewHolder itemViewHolder = ( ItemViewHolder ) holder ; Comment comment = comments . get ( position ) ; itemViewHolder . comment = comments . get ( position ) ; LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; DisplayMetrics displayMetrics = new DisplayMetrics ( ) ; ( ( Activity ) ctx ) . getWindowManager ( ) . getDefaultDisplay ( ) . getMetrics ( displayMetrics ) ; int width = displayMetrics . widthPixels ; if ( isTablet ) { width /= <NUM_LIT> ; } params . setMargins ( Math . min ( Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> + <NUM_LIT> * comment . depth ) , Math . round ( ( ( float ) width ) * <NUM_LIT> ) ) , Utils . pxFromDpInt ( ctx . getResources ( ) , comment . depth > <NUM_LIT> && ! collapseParent ? <NUM_LIT> : <NUM_LIT> ) , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ) ; itemViewHolder . itemView . setLayoutParams ( params ) ; if ( comment . depth == <NUM_LIT> && ! showTopLevelDepthIndicator ) { itemViewHolder . commentIndentIndicator . setVisibility ( GONE ) ; } else { itemViewHolder . commentIndentIndicator . setVisibility ( View . VISIBLE ) ; int index = ( comment . depth + ( showTopLevelDepthIndicator ? <NUM_LIT> : - <NUM_LIT> ) ) % <NUM_LIT> ; if ( monochromeCommentDepthIndicators ) { itemViewHolder . commentIndentIndicator . setBackgroundResource ( R . color . commentIndentIndicatorColorMonochrome ) ; } else { if ( theme . startsWith ( "<STR_LIT>" ) ) { itemViewHolder . commentIndentIndicator . setBackgroundResource ( commentDepthColorsMaterial [ index ] ) ; } else { itemViewHolder . commentIndentIndicator . setBackgroundResource ( ThemeUtils . isDarkMode ( ctx , theme ) ? commentDepthColorsDark [ index ] : commentDepthColorsLight [ index ] ) ; } } } if ( ! comment . text . isEmpty ( ) ) { itemViewHolder . commentBody . setHtml ( comment . text ) ; if ( collapseParent ) { itemViewHolder . commentHiddenText . setText ( "<STR_LIT>" + Html . fromHtml ( comment . text . substring ( <NUM_LIT> , Math . min ( <NUM_LIT> , comment . text . length ( ) ) ) ) ) ; } FontUtils . setTypeface ( itemViewHolder . commentBody , false , preferredTextSize ) ; } itemViewHolder . commentByTime . setText ( comment . getTimeFormatted ( ) ) ; boolean byOp = story . by . equals ( comment . by ) ; boolean byUser = false ; if ( ! TextUtils . isEmpty ( username ) ) { byUser = comment . by . equals ( username ) ; } itemViewHolder . commentBy . setText ( byOp ? comment . by + "<STR_LIT>" : comment . by ) ; if ( byUser ) { itemViewHolder . commentBy . setTextColor ( MaterialColors . getColor ( itemViewHolder . commentBy , R . attr . selfCommentColor ) ) ; } else if ( byOp ) { itemViewHolder . commentBy . setTextColor ( MaterialColors . getColor ( itemViewHolder . commentBy , R . attr . opCommentColor ) ) ; } else { itemViewHolder . commentBy . setTextColor ( MaterialColors . getColor ( itemViewHolder . commentBy , R . attr . storyColorDisabled ) ) ; } itemViewHolder . commentBy . setTypeface ( FontUtils . activeBold ) ; itemViewHolder . commentByTime . setTypeface ( FontUtils . activeRegular ) ; if ( collapseParent ) { itemViewHolder . commentHiddenText . setTypeface ( FontUtils . activeRegular ) ; } itemViewHolder . commentBody . setVisibility ( ( ! comment . expanded && collapseParent ) ? GONE : View . VISIBLE ) ; itemViewHolder . commentHiddenText . setVisibility ( ( ! comment . expanded && collapseParent ) ? View . VISIBLE : GONE ) ; if ( comment . expanded ) { itemViewHolder . commentHiddenCount . setVisibility ( GONE ) ; } else { int subCommentCount = getIndexOfLastChild ( comment . depth , position ) - position ; if ( subCommentCount > <NUM_LIT> ) { itemViewHolder . commentHiddenCount . setVisibility ( View . VISIBLE ) ; itemViewHolder . commentHiddenCount . setText ( "<STR_LIT>" + subCommentCount ) ; } else { itemViewHolder . commentHiddenCount . setVisibility ( GONE ) ; } } } } @ Override public int getItemCount ( ) { return comments . size ( ) ; } @ Override public int getItemViewType ( int position ) { if ( position == <NUM_LIT> ) { return TYPE_HEADER ; } else { return shouldShow ( comments . get ( position ) ) ? TYPE_COMMENT : TYPE_COLLAPSED ; } } public class ItemViewHolder extends RecyclerView . ViewHolder { public final HtmlTextView commentBody ; public final TextView commentBy ; public final TextView commentByTime ; public final TextView commentHiddenCount ; public final TextView commentHiddenText ; public final View commentIndentIndicator ; public Comment comment ; public ItemViewHolder ( View view ) { super ( view ) ; commentBody = view . findViewById ( R . id . comment_body ) ; commentBy = view . findViewById ( R . id . comment_by ) ; commentByTime = view . findViewById ( R . id . comment_by_time ) ; commentHiddenCount = view . findViewById ( R . id . comment_hidden_count ) ; commentHiddenText = view . findViewById ( R . id . comment_hidden_short ) ; commentIndentIndicator = view . findViewById ( R . id . comment_indent_indicator ) ; itemView . setOnLongClickListener ( v -> { longPressed ( comment , getAbsoluteAdapterPosition ( ) , v ) ; return true ; } ) ; commentBody . setOnLongClickListener ( v -> { longPressed ( comment , getAbsoluteAdapterPosition ( ) , v ) ; return true ; } ) ; itemView . setOnClickListener ( v -> tapped ( comment , getAbsoluteAdapterPosition ( ) , v ) ) ; commentBody . setOnClickListener ( v -> tapped ( comment , getAbsoluteAdapterPosition ( ) , v ) ) ; commentBody . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { if ( disableCommentATagClick ) return true ; Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; } private void tapped ( Comment comment , int pos , View v ) { if ( swapLongPressTap ) { commentLongClickListener . onItemClick ( comment , pos , v ) ; } else { commentClickListener . onItemClick ( comment , pos , v ) ; } } private void longPressed ( Comment comment , int pos , View v ) { if ( swapLongPressTap ) { commentClickListener . onItemClick ( comment , pos , v ) ; } else { commentLongClickListener . onItemClick ( comment , pos , v ) ; } } } public class HeaderViewHolder extends RecyclerView . ViewHolder { public final View mView ; public final TextView titleView ; public final ImageView linkImage ; public final LinearLayout metaContainer ; public final TextView metaVotes ; public final TextView metaComments ; public final TextView metaTime ; public final TextView metaBy ; public final ImageView metaVotesIcon ; public final TextView urlView ; public final HtmlTextView textView ; public final LinearLayout infoContainer ; public final HtmlTextView arxivAbstract ; public final LinearLayout githubContainer ; public final LinearLayout arxivContainer ; public final LinearLayout wikiContainer ; public final TextView infoHeader ; public final LinearLayout emptyView ; public final TextView emptyViewText ; public final CircularProgressIndicator loadingIndicator ; public final LinearLayout loadingFailed ; public final LinearLayout serverErrorLayout ; public final Button serverErrorSwitchApiButton ; public final Button refreshButton ; public final ImageButton userButton ; public final ImageButton commentButton ; public final ImageButton voteButton ; public final ImageButton bookmarkButton ; public final ImageButton shareButton ; public final ImageButton moreButton ; public final RelativeLayout userButtonParent ; public final RelativeLayout moreButtonParent ; public final RelativeLayout commentButtonParent ; public final RelativeLayout bookmarkButtonParent ; public final Space spacer ; public final TextView githubAbout ; public final HtmlTextView githubWebsite ; public final TextView githubLicense ; public final TextView githubLanguage ; public final TextView githubStars ; public final TextView githubWatching ; public final TextView githubForks ; public final LinearLayout githubWebsiteContainer ; public final LinearLayout githubLicenseContainer ; public final LinearLayout githubLanguageContainer ; public final TextView arxivBy ; public final TextView arxivDate ; public final TextView arxivSubjects ; public final ImageView arxivByIcon ; public final Button arxivDownloadButton ; public final HtmlTextView wikiSummary ; public final ImageView favicon ; public final RelativeLayout sheetRefreshButton ; public final RelativeLayout sheetExpandButton ; public final RelativeLayout sheetBrowserButton ; public final RelativeLayout sheetInvertButton ; public final LinearLayout actionsContainer ; public final LinearLayout linkInfoContainer ; public final Button retryButton ; public final LinearLayout pollLayout ; public final LinearLayout headerView ; public HeaderViewHolder ( View view ) { super ( view ) ; mView = view ; titleView = view . findViewById ( R . id . comments_header_title ) ; linkImage = view . findViewById ( R . id . comments_header_link_image ) ; metaContainer = view . findViewById ( R . id . comments_header_meta_container ) ; metaVotes = view . findViewById ( R . id . comments_header_meta_votes ) ; metaComments = view . findViewById ( R . id . comments_header_meta_comments ) ; metaTime = view . findViewById ( R . id . comments_header_meta_time ) ; metaBy = view . findViewById ( R . id . comments_header_meta_by ) ; metaVotesIcon = view . findViewById ( R . id . comments_header_meta_votes_icon ) ; urlView = view . findViewById ( R . id . comments_header_url ) ; textView = view . findViewById ( R . id . comments_header_text ) ; arxivAbstract = view . findViewById ( R . id . comments_header_arxiv_abstract ) ; infoContainer = view . findViewById ( R . id . comments_header_info_container ) ; infoHeader = view . findViewById ( R . id . comments_header_info_header ) ; emptyView = view . findViewById ( R . id . comments_header_empty ) ; emptyViewText = view . findViewById ( R . id . comments_header_empty_text ) ; headerView = view . findViewById ( R . id . comments_header ) ; loadingIndicator = view . findViewById ( R . id . comments_header_loading ) ; loadingFailed = view . findViewById ( R . id . comments_header_loading_failed ) ; serverErrorLayout = view . findViewById ( R . id . comments_header_server_error ) ; serverErrorSwitchApiButton = view . findViewById ( R . id . comments_header_server_error_switch_api ) ; refreshButton = view . findViewById ( R . id . comments_header_refresh ) ; favicon = view . findViewById ( R . id . comments_header_favicon ) ; linkInfoContainer = view . findViewById ( R . id . comments_header_link_info_container ) ; userButton = view . findViewById ( R . id . comments_header_button_user ) ; commentButton = view . findViewById ( R . id . comments_header_button_comment ) ; voteButton = view . findViewById ( R . id . comments_header_button_vote ) ; bookmarkButton = view . findViewById ( R . id . comments_header_button_bookmark ) ; shareButton = view . findViewById ( R . id . comments_header_button_share ) ; moreButton = view . findViewById ( R . id . comments_header_button_more ) ; userButtonParent = view . findViewById ( R . id . comments_header_button_user_parent ) ; moreButtonParent = view . findViewById ( R . id . comments_header_button_more_parent ) ; commentButtonParent = view . findViewById ( R . id . comments_header_button_comment_parent ) ; bookmarkButtonParent = view . findViewById ( R . id . comments_header_button_bookmark_parent ) ; retryButton = view . findViewById ( R . id . comments_header_retry ) ; pollLayout = view . findViewById ( R . id . comments_header_poll_layout ) ; sheetRefreshButton = view . findViewById ( R . id . comments_sheet_layout_refresh ) ; sheetExpandButton = view . findViewById ( R . id . comments_sheet_layout_expand ) ; sheetBrowserButton = view . findViewById ( R . id . comments_sheet_layout_browser ) ; sheetInvertButton = view . findViewById ( R . id . comments_sheet_layout_invert ) ; actionsContainer = view . findViewById ( R . id . comments_header_actions_container ) ; spacer = view . findViewById ( R . id . comments_header_spacer ) ; githubContainer = view . findViewById ( R . id . comments_header_github_container ) ; arxivContainer = view . findViewById ( R . id . comments_header_arxiv_container ) ; wikiContainer = view . findViewById ( R . id . comments_header_wikipedia_container ) ; wikiSummary = view . findViewById ( R . id . comments_header_wikipedia_summary ) ; githubAbout = view . findViewById ( R . id . comments_header_github_about ) ; githubWebsite = view . findViewById ( R . id . comments_header_github_website ) ; githubLicense = view . findViewById ( R . id . comments_header_github_license ) ; githubLanguage = view . findViewById ( R . id . comments_header_github_language ) ; githubStars = view . findViewById ( R . id . comments_header_github_stars ) ; githubWatching = view . findViewById ( R . id . comments_header_github_watching ) ; githubForks = view . findViewById ( R . id . comments_header_github_forks ) ; githubWebsiteContainer = view . findViewById ( R . id . comments_header_github_website_container ) ; githubLicenseContainer = view . findViewById ( R . id . comments_header_github_license_container ) ; githubLanguageContainer = view . findViewById ( R . id . comments_header_github_language_container ) ; arxivBy = view . findViewById ( R . id . comments_header_arxiv_by ) ; arxivDate = view . findViewById ( R . id . comments_header_arxiv_date ) ; arxivSubjects = view . findViewById ( R . id . comments_header_arxiv_subjects ) ; arxivByIcon = view . findViewById ( R . id . comments_header_arxiv_by_icon ) ; arxivDownloadButton = view . findViewById ( R . id . comments_header_arxiv_download ) ; final int SHEET_ITEM_HEIGHT = Utils . pxFromDpInt ( view . getResources ( ) , <NUM_LIT> ) ; retryButton . setOnClickListener ( ( v ) -> retryListener . onRetry ( ) ) ; refreshButton . setOnClickListener ( ( v ) -> { showUpdate = false ; retryListener . onRetry ( ) ; } ) ; serverErrorSwitchApiButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( view . getContext ( ) ) ; prefs . edit ( ) . putBoolean ( "<STR_LIT>" , false ) . apply ( ) ; Toast . makeText ( view . getContext ( ) , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; arxivDownloadButton . setOnClickListener ( ( v ) -> { Utils . downloadPDF ( v . getContext ( ) , story . arxivInfo . getPDFURL ( ) ) ; } ) ; userButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_USER , null ) ) ; commentButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_COMMENT , null ) ) ; voteButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_VOTE , view ) ) ; shareButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_SHARE , v ) ) ; moreButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_MORE , v ) ) ; sheetRefreshButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_REFRESH , view ) ) ; sheetExpandButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_EXPAND , view ) ) ; sheetBrowserButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_BROWSER , view ) ) ; sheetInvertButton . setOnClickListener ( ( v ) -> headerActionClickListener . onActionClicked ( FLAG_ACTION_CLICK_INVERT , view ) ) ; TooltipCompat . setTooltipText ( sheetRefreshButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( sheetExpandButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( sheetBrowserButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( sheetInvertButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( userButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( commentButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( voteButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( bookmarkButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( shareButton , "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( moreButton , "<STR_LIT>" ) ; if ( ! showInvert ) { view . findViewById ( R . id . comments_sheet_container_invert ) . setVisibility ( GONE ) ; } headerView . setOnClickListener ( view1 -> headerClickListener . onItemClick ( story ) ) ; textView . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . launchCustomTab ( mView . getContext ( ) , href ) ; return true ; } } ) ; githubWebsite . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . launchCustomTab ( view . getContext ( ) , story . repoInfo . website ) ; return false ; } } ) ; LinearLayout sheetButtonsContainer = view . findViewById ( R . id . comment_sheet_buttons_container ) ; BottomSheetBehavior . from ( bottomSheet ) . addBottomSheetCallback ( new BottomSheetBehavior . BottomSheetCallback ( ) { @ Override public void onStateChanged ( @ NonNull View bottomSheet , int newState ) { } @ Override public void onSlide ( @ NonNull View bottomSheet , float slideOffset ) { sheetButtonsContainer . setAlpha ( ( <NUM_LIT> - slideOffset ) * ( <NUM_LIT> - slideOffset ) * ( <NUM_LIT> - slideOffset ) ) ; sheetButtonsContainer . getLayoutParams ( ) . height = Math . round ( ( <NUM_LIT> - slideOffset ) * ( SHEET_ITEM_HEIGHT + navbarHeight ) ) ; sheetButtonsContainer . requestLayout ( ) ; float headerAlpha = Math . min ( <NUM_LIT> , slideOffset * slideOffset * <NUM_LIT> ) ; actionsContainer . setAlpha ( headerAlpha ) ; headerView . setAlpha ( headerAlpha ) ; } } ) ; if ( integratedWebview ) { if ( BottomSheetBehavior . from ( bottomSheet ) . getState ( ) == BottomSheetBehavior . STATE_EXPANDED ) { sheetButtonsContainer . setAlpha ( <NUM_LIT> ) ; sheetButtonsContainer . getLayoutParams ( ) . height = <NUM_LIT> ; sheetButtonsContainer . requestLayout ( ) ; } else { sheetButtonsContainer . getLayoutParams ( ) . height = SHEET_ITEM_HEIGHT + navbarHeight ; sheetButtonsContainer . requestLayout ( ) ; } } else { sheetButtonsContainer . setVisibility ( GONE ) ; view . findViewById ( R . id . comments_sheet_handle ) . setVisibility ( GONE ) ; } } } public void setOnHeaderClickListener ( CommentsRecyclerViewAdapter . HeaderClickListener clickListener ) { headerClickListener = clickListener ; } public void setOnCommentClickListener ( CommentClickListener clickListener ) { commentClickListener = clickListener ; } public void setOnCommentLongClickListener ( CommentClickListener clickListener ) { commentLongClickListener = clickListener ; } public void setOnHeaderActionClickListener ( HeaderActionClickListener clickListener ) { headerActionClickListener = clickListener ; } public void setRetryListener ( RetryListener listener ) { retryListener = listener ; } public void setNavbarHeight ( int navbarHeight ) { if ( this . navbarHeight != navbarHeight ) { this . navbarHeight = navbarHeight ; notifyItemChanged ( <NUM_LIT> ) ; } } public interface RetryListener { void onRetry ( ) ; } public interface HeaderActionClickListener { void onActionClicked ( int flag , View view ) ; } public interface HeaderClickListener { void onItemClick ( Story story ) ; } public interface CommentClickListener { void onItemClick ( Comment comment , int pos , View view ) ; } public int getIndexOfLastChild ( int commentDepth , int pos ) { int lastChildIndex = pos ; for ( int i = pos + <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { if ( comments . get ( i ) . depth > commentDepth ) { lastChildIndex = i ; } else { return lastChildIndex ; } } return lastChildIndex ; } private boolean shouldShow ( Comment comment ) { if ( comment . parent == - <NUM_LIT> ) { return true ; } for ( Comment c : comments ) { if ( c . id == comment . parent ) { if ( c . expanded ) { return shouldShow ( c ) ; } else { return false ; } } } return true ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . Layout ; import android . text . Selection ; import android . text . Spannable ; import android . text . method . LinkMovementMethod ; import android . text . method . Touch ; import android . text . style . ClickableSpan ; import android . view . MotionEvent ; import android . widget . TextView ; public class LocalLinkMovementMethod extends LinkMovementMethod { static LocalLinkMovementMethod sInstance ; public static LocalLinkMovementMethod getInstance ( ) { if ( sInstance == null ) sInstance = new LocalLinkMovementMethod ( ) ; return sInstance ; } @ Override public boolean onTouchEvent ( TextView widget , Spannable buffer , MotionEvent event ) { int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_UP || action == MotionEvent . ACTION_DOWN ) { int x = ( int ) event . getX ( ) ; int y = ( int ) event . getY ( ) ; x -= widget . getTotalPaddingLeft ( ) ; y -= widget . getTotalPaddingTop ( ) ; x += widget . getScrollX ( ) ; y += widget . getScrollY ( ) ; Layout layout = widget . getLayout ( ) ; int line = layout . getLineForVertical ( y ) ; int off = layout . getOffsetForHorizontal ( line , x ) ; ClickableSpan [ ] link = buffer . getSpans ( off , off , ClickableSpan . class ) ; if ( link . length != <NUM_LIT> ) { if ( action == MotionEvent . ACTION_UP ) { link [ <NUM_LIT> ] . onClick ( widget ) ; } else if ( action == MotionEvent . ACTION_DOWN ) { Selection . setSelection ( buffer , buffer . getSpanStart ( link [ <NUM_LIT> ] ) , buffer . getSpanEnd ( link [ <NUM_LIT> ] ) ) ; } return true ; } else { Selection . removeSelection ( buffer ) ; Touch . onTouchEvent ( widget , buffer , event ) ; return false ; } } return Touch . onTouchEvent ( widget , buffer , event ) ; } } </s>
<s> package com . simon . harmonichackernews . data ; import android . os . Bundle ; import android . text . TextUtils ; import com . simon . harmonichackernews . CommentsFragment ; import com . simon . harmonichackernews . utils . Utils ; import java . util . ArrayList ; public class Story { public String by ; public int descendants ; public int id ; public int score ; public int time ; public String title ; public String pdfTitle ; public String url ; public int [ ] kids ; public int [ ] pollOptions ; public ArrayList < PollOption > pollOptionArrayList ; public boolean loaded ; public boolean clicked ; public String text ; public RepoInfo repoInfo ; public ArxivInfo arxivInfo ; public WikipediaInfo wikiInfo ; public boolean isLink ; public boolean isJob = false ; public boolean loadingFailed = false ; public boolean isComment = false ; public String commentMasterTitle ; public int commentMasterId ; public String commentMasterUrl ; public Story ( ) { } public Story ( String title , int id , boolean loaded , boolean clicked ) { this . title = title ; this . id = id ; this . loaded = loaded ; this . clicked = clicked ; } public void update ( String by , int id , int score , int time , String title ) { this . by = by ; this . id = id ; this . score = score ; this . time = time ; this . title = title ; } public String getTimeFormatted ( ) { return Utils . getTimeAgo ( this . time ) ; } @ Override public String toString ( ) { return title ; } public Bundle toBundle ( ) { Bundle bundle = new Bundle ( ) ; bundle . putString ( CommentsFragment . EXTRA_TITLE , title ) ; bundle . putString ( CommentsFragment . EXTRA_PDF_TITLE , pdfTitle ) ; bundle . putString ( CommentsFragment . EXTRA_BY , by ) ; bundle . putString ( CommentsFragment . EXTRA_URL , url ) ; bundle . putInt ( CommentsFragment . EXTRA_TIME , time ) ; bundle . putIntArray ( CommentsFragment . EXTRA_KIDS , kids ) ; bundle . putIntArray ( CommentsFragment . EXTRA_POLL_OPTIONS , pollOptions ) ; bundle . putInt ( CommentsFragment . EXTRA_DESCENDANTS , descendants ) ; bundle . putInt ( CommentsFragment . EXTRA_ID , id ) ; bundle . putInt ( CommentsFragment . EXTRA_SCORE , score ) ; bundle . putString ( CommentsFragment . EXTRA_TEXT , text ) ; bundle . putBoolean ( CommentsFragment . EXTRA_IS_LINK , isLink ) ; bundle . putBoolean ( CommentsFragment . EXTRA_IS_COMMENT , isComment ) ; return bundle ; } public boolean hasExtraInfo ( ) { return arxivInfo != null || repoInfo != null || wikiInfo != null ; } } </s>
<s> package com . simon . harmonichackernews . linkpreview ; import android . content . Context ; import android . text . TextUtils ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . data . WikipediaInfo ; import com . simon . harmonichackernews . network . NetworkComponent ; import org . json . JSONObject ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class WikipediaGetter { public static boolean isValidWikipediaUrl ( String url ) { String regex = "<STR_LIT>" ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( url ) ; return matcher . matches ( ) ; } public static void getInfo ( String wikipediaUrl , Context ctx , WikipediaGetter . GetterCallback callback ) { try { String title = wikipediaUrl . split ( "<STR_LIT>" ) [ <NUM_LIT> ] ; String apiUrl = "<STR_LIT>" + title ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , apiUrl , response -> { try { JSONObject jsonResponse = new JSONObject ( response ) ; JSONObject pages = jsonResponse . getJSONObject ( "<STR_LIT>" ) . getJSONObject ( "<STR_LIT>" ) ; String pageId = pages . keys ( ) . next ( ) ; String summary = pages . getJSONObject ( pageId ) . optString ( "<STR_LIT>" ) ; if ( ! TextUtils . isEmpty ( summary ) ) { Document doc = Jsoup . parse ( summary ) ; for ( Element ul : doc . select ( "<STR_LIT>" ) ) { if ( ! ul . hasText ( ) ) { ul . remove ( ) ; } } String cleanedHtml = doc . html ( ) ; WikipediaInfo wikiInfo = new WikipediaInfo ( ) ; wikiInfo . summary = cleanedHtml ; callback . onSuccess ( wikiInfo ) ; } else { callback . onFailure ( "<STR_LIT>" ) ; } } catch ( Exception e ) { callback . onFailure ( "<STR_LIT>" ) ; e . printStackTrace ( ) ; } } , error -> { error . printStackTrace ( ) ; callback . onFailure ( "<STR_LIT>" ) ; } ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( ctx ) ; queue . add ( stringRequest ) ; } catch ( Exception e ) { callback . onFailure ( "<STR_LIT>" ) ; } } public interface GetterCallback { void onSuccess ( WikipediaInfo wikiInfo ) ; void onFailure ( String reason ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . Html . ImageGetter ; import androidx . annotation . Nullable ; public class HtmlFormatterBuilder { private String html ; private ImageGetter imageGetter ; private ClickableTableSpan clickableTableSpan ; private DrawTableLinkSpan drawTableLinkSpan ; private OnClickATagListener onClickATagListener ; private float indent = <NUM_LIT> ; private boolean removeTrailingWhiteSpace = true ; public String getHtml ( ) { return html ; } public ImageGetter getImageGetter ( ) { return imageGetter ; } public ClickableTableSpan getClickableTableSpan ( ) { return clickableTableSpan ; } public DrawTableLinkSpan getDrawTableLinkSpan ( ) { return drawTableLinkSpan ; } public OnClickATagListener getOnClickATagListener ( ) { return onClickATagListener ; } public float getIndent ( ) { return indent ; } public boolean isRemoveTrailingWhiteSpace ( ) { return removeTrailingWhiteSpace ; } public HtmlFormatterBuilder setHtml ( @ Nullable final String html ) { this . html = html ; return this ; } public HtmlFormatterBuilder setImageGetter ( @ Nullable final ImageGetter imageGetter ) { this . imageGetter = imageGetter ; return this ; } public HtmlFormatterBuilder setClickableTableSpan ( @ Nullable final ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; return this ; } public HtmlFormatterBuilder setDrawTableLinkSpan ( @ Nullable final DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; return this ; } public void setOnClickATagListener ( OnClickATagListener onClickATagListener ) { this . onClickATagListener = onClickATagListener ; } public HtmlFormatterBuilder setIndent ( final float indent ) { this . indent = indent ; return this ; } public HtmlFormatterBuilder setRemoveTrailingWhiteSpace ( final boolean removeTrailingWhiteSpace ) { this . removeTrailingWhiteSpace = removeTrailingWhiteSpace ; return this ; } } </s>
<s> package com . simon . harmonichackernews . network ; import android . content . Context ; import android . widget . ImageView ; import androidx . core . content . ContextCompat ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . utils . Utils ; import com . squareup . picasso . Picasso ; import java . util . Objects ; public class FaviconLoader { public static void loadFavicon ( String url , ImageView into , Context ctx , String faviconProvider ) { try { String host = Utils . getDomainName ( url ) ; int faviconSize = Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ; Picasso . get ( ) . load ( getFaviconUrl ( host , faviconProvider ) ) . resize ( faviconSize , faviconSize ) . onlyScaleDown ( ) . placeholder ( Objects . requireNonNull ( ContextCompat . getDrawable ( ctx , R . drawable . ic_action_web ) ) ) . into ( into ) ; } catch ( Exception ignored ) { } ; } private static String getFaviconUrl ( String host , String faviconProvider ) { switch ( faviconProvider ) { case "<STR_LIT>" : return "<STR_LIT>" + host ; case "<STR_LIT>" : return "<STR_LIT>" + host + "<STR_LIT>" ; case "<STR_LIT>" : return "<STR_LIT>" + host + "<STR_LIT>" ; default : return "<STR_LIT>" + host + "<STR_LIT>" ; } } } </s>
<s> package com . simon . harmonichackernews . linkpreview ; import android . content . Context ; import android . util . Xml ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . data . ArxivInfo ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . ArxivResolver ; import org . xmlpull . v1 . XmlPullParser ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . IOException ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ArxivAbstractGetter { public static boolean isValidArxivUrl ( String url ) { String arxivUrlPattern = "<STR_LIT>" ; Pattern pattern = Pattern . compile ( arxivUrlPattern ) ; Matcher matcher = pattern . matcher ( url ) ; return matcher . matches ( ) ; } public static void getAbstract ( String url , Context ctx , GetterCallback callback ) { String arxivID = url . substring ( url . lastIndexOf ( '<STR_LIT>' ) + <NUM_LIT> ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , "<STR_LIT>" + arxivID , response -> { try { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( new StringReader ( response ) ) ; int eventType = parser . getEventType ( ) ; String abstractText = "<STR_LIT>" ; List < String > authorList = new ArrayList < > ( ) ; String primaryCategoryText = "<STR_LIT>" ; List < String > secondaryCategoryList = new ArrayList < > ( ) ; String publishedDateText = "<STR_LIT>" ; while ( eventType != XmlPullParser . END_DOCUMENT ) { String tagName = parser . getName ( ) ; if ( eventType == XmlPullParser . START_TAG && "<STR_LIT>" . equals ( tagName ) ) { parser . next ( ) ; abstractText = parser . getText ( ) ; } if ( eventType == XmlPullParser . START_TAG && "<STR_LIT>" . equals ( tagName ) ) { parser . next ( ) ; authorList . add ( parser . getText ( ) ) ; } if ( eventType == XmlPullParser . START_TAG && "<STR_LIT>" . equals ( tagName ) ) { primaryCategoryText = parser . getAttributeValue ( null , "<STR_LIT>" ) ; } if ( eventType == XmlPullParser . START_TAG && "<STR_LIT>" . equals ( tagName ) ) { String category = parser . getAttributeValue ( null , "<STR_LIT>" ) ; if ( ! category . equals ( primaryCategoryText ) ) { secondaryCategoryList . add ( category ) ; } } if ( eventType == XmlPullParser . START_TAG && "<STR_LIT>" . equals ( tagName ) ) { parser . next ( ) ; publishedDateText = parser . getText ( ) ; } eventType = parser . next ( ) ; } String [ ] authorsArray = authorList . toArray ( new String [ <NUM_LIT> ] ) ; List < String > secondaryCategoriesFiltered = new ArrayList < > ( ) ; for ( String category : secondaryCategoryList ) { if ( ArxivResolver . isArxivSubjet ( category ) ) { secondaryCategoriesFiltered . add ( category ) ; } } String [ ] secondaryCategoriesFilteredArray = secondaryCategoriesFiltered . toArray ( new String [ <NUM_LIT> ] ) ; ArxivInfo info = new ArxivInfo ( ) ; info . arxivAbstract = abstractText ; info . authors = authorsArray ; info . primaryCategory = primaryCategoryText ; info . secondaryCategories = secondaryCategoriesFilteredArray ; info . publishedDate = publishedDateText ; info . arxivID = arxivID ; if ( ! abstractText . isEmpty ( ) && authorsArray . length > <NUM_LIT> && ! primaryCategoryText . isEmpty ( ) && ! publishedDateText . isEmpty ( ) ) { callback . onSuccess ( info ) ; } else { callback . onFailure ( "<STR_LIT>" ) ; } } catch ( XmlPullParserException | IOException e ) { callback . onFailure ( "<STR_LIT>" ) ; e . printStackTrace ( ) ; } } , error -> { error . printStackTrace ( ) ; callback . onFailure ( "<STR_LIT>" ) ; } ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( ctx ) ; queue . add ( stringRequest ) ; } public interface GetterCallback { void onSuccess ( ArxivInfo arxivInfo ) ; void onFailure ( String reason ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . startup . Initializer ; import androidx . window . embedding . RuleController ; import androidx . window . embedding . SplitController ; import androidx . window . embedding . SplitController . SplitSupportStatus ; import com . simon . harmonichackernews . R ; import java . util . Collections ; import java . util . List ; public class FoldableSplitInitializer implements Initializer < RuleController > { private static RuleController ruleController ; @ NonNull @ Override public RuleController create ( @ NonNull Context context ) { ruleController = RuleController . getInstance ( context ) ; if ( ! isSplitSupported ( context ) ) { return ruleController ; } setFoldableSupport ( context , SettingsUtils . shouldEnableFoldableSupport ( context ) ) ; return ruleController ; } @ NonNull @ Override public List < Class < ? extends Initializer < ? > > > dependencies ( ) { return Collections . emptyList ( ) ; } private void setFoldableSupport ( Context context , boolean enabled ) { if ( enabled ) { ruleController . setRules ( RuleController . parseRules ( context , R . xml . main_split_config ) ) ; } else { ruleController . clearRules ( ) ; } } public static boolean isSplitSupported ( Context context ) { return SplitController . getInstance ( context ) . getSplitSupportStatus ( ) . equals ( SplitSupportStatus . SPLIT_AVAILABLE ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . text . Html ; import android . util . Log ; import androidx . annotation . NonNull ; public class HtmlResImageGetter implements Html . ImageGetter { private Context context ; public HtmlResImageGetter ( @ NonNull Context context ) { this . context = context ; } public Drawable getDrawable ( String source ) { int id = context . getResources ( ) . getIdentifier ( source , "<STR_LIT>" , context . getPackageName ( ) ) ; if ( id == <NUM_LIT> ) { id = context . getResources ( ) . getIdentifier ( source , "<STR_LIT>" , "<STR_LIT>" ) ; } if ( id == <NUM_LIT> ) { Log . e ( HtmlTextView . TAG , "<STR_LIT>" + source ) ; return null ; } else { Drawable d = context . getResources ( ) . getDrawable ( id ) ; d . setBounds ( <NUM_LIT> , <NUM_LIT> , d . getIntrinsicWidth ( ) , d . getIntrinsicHeight ( ) ) ; return d ; } } } </s>
<s> package com . simon . harmonichackernews ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . view . View ; import android . widget . Button ; import android . widget . CompoundButton ; import android . widget . ImageView ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import com . google . android . material . materialswitch . MaterialSwitch ; import com . simon . harmonichackernews . utils . ThemeUtils ; public class WelcomeActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_welcome ) ; ImageView favicon = findViewById ( R . id . story_meta_favicon ) ; TextView index = findViewById ( R . id . story_index ) ; TextView meta = findViewById ( R . id . story_meta ) ; Button materialDaynightButton = findViewById ( R . id . welcome_button_material_daynight ) ; Button materialDarkButton = findViewById ( R . id . welcome_button_material_dark ) ; Button materialLightButton = findViewById ( R . id . welcome_button_material_light ) ; Button darkButton = findViewById ( R . id . welcome_button_dark ) ; Button grayButton = findViewById ( R . id . welcome_button_gray ) ; Button blackButton = findViewById ( R . id . welcome_button_black ) ; Button lightButton = findViewById ( R . id . welcome_button_light ) ; Button whiteButton = findViewById ( R . id . welcome_button_white ) ; favicon . setImageResource ( R . drawable . quanta ) ; MaterialSwitch thumbnailSwitch = findViewById ( R . id . welcome_switch_thumbnails ) ; MaterialSwitch pointsSwitch = findViewById ( R . id . welcome_switch_points ) ; MaterialSwitch indexSwitch = findViewById ( R . id . welcome_switch_index ) ; thumbnailSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { favicon . setVisibility ( b ? View . VISIBLE : View . GONE ) ; setBooleanSetting ( compoundButton . getContext ( ) , "<STR_LIT>" , b ) ; } } ) ; indexSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { index . setVisibility ( b ? View . VISIBLE : View . GONE ) ; setBooleanSetting ( compoundButton . getContext ( ) , "<STR_LIT>" , b ) ; } } ) ; pointsSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { meta . setText ( ( b ? "<STR_LIT>" : "<STR_LIT>" ) + "<STR_LIT>" ) ; setBooleanSetting ( compoundButton . getContext ( ) , "<STR_LIT>" , b ) ; } } ) ; View . OnClickListener buttonClickListener = new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { setSetting ( view . getContext ( ) , "<STR_LIT>" , ( String ) view . getTag ( ) ) ; restartActivity ( ) ; } } ; materialDaynightButton . setOnClickListener ( buttonClickListener ) ; materialDarkButton . setOnClickListener ( buttonClickListener ) ; materialLightButton . setOnClickListener ( buttonClickListener ) ; darkButton . setOnClickListener ( buttonClickListener ) ; grayButton . setOnClickListener ( buttonClickListener ) ; blackButton . setOnClickListener ( buttonClickListener ) ; lightButton . setOnClickListener ( buttonClickListener ) ; whiteButton . setOnClickListener ( buttonClickListener ) ; } @ SuppressLint ( "<STR_LIT>" ) private void setSetting ( Context ctx , String key , String newTheme ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; prefs . edit ( ) . putString ( key , newTheme ) . commit ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void setBooleanSetting ( Context ctx , String key , boolean newVal ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; prefs . edit ( ) . putBoolean ( key , newVal ) . commit ( ) ; } private void restartActivity ( ) { Intent intent = new Intent ( this , WelcomeActivity . class ) ; startActivity ( intent ) ; finish ( ) ; } public void done ( View view ) { startActivity ( new Intent ( this , MainActivity . class ) ) ; finish ( ) ; } } </s>
<s> package com . simon . harmonichackernews . data ; public class RepoInfo { public String name ; public String owner ; public String about ; public String website ; public String license ; public String language ; public int stars ; public int watching ; public int forks ; public String formatStars ( ) { if ( stars == <NUM_LIT> ) { return "<STR_LIT>" ; } return kFormat ( stars ) + "<STR_LIT>" ; } public String formatWatching ( ) { return kFormat ( watching ) + "<STR_LIT>" ; } public String formatForks ( ) { if ( forks == <NUM_LIT> ) { return "<STR_LIT>" ; } return kFormat ( forks ) + "<STR_LIT>" ; } public String getShortenedUrl ( ) { if ( website == null ) { return null ; } if ( website . startsWith ( "<STR_LIT>" ) ) { website = website . substring ( <NUM_LIT> ) ; } else if ( website . startsWith ( "<STR_LIT>" ) ) { website = website . substring ( <NUM_LIT> ) ; } if ( website . startsWith ( "<STR_LIT>" ) ) { website = website . substring ( <NUM_LIT> ) ; } return website ; } public String kFormat ( int number ) { if ( number < <NUM_LIT> ) { return String . valueOf ( number ) ; } else { double rounded = Math . round ( ( double ) number / <NUM_LIT> ) * <NUM_LIT> ; String result = String . format ( "<STR_LIT>" , rounded / <NUM_LIT> ) ; if ( result . endsWith ( "<STR_LIT>" ) ) { return result . substring ( <NUM_LIT> , result . length ( ) - <NUM_LIT> ) + "<STR_LIT>" ; } return result ; } } } </s>
<s> package com . simon . harmonichackernews . data ; import android . text . TextUtils ; import com . simon . harmonichackernews . utils . ArxivResolver ; public class ArxivInfo { public String arxivAbstract ; public String [ ] authors ; public String primaryCategory ; public String arxivID ; public String [ ] secondaryCategories ; public String publishedDate ; public String concatNames ( ) { return TextUtils . join ( "<STR_LIT>" , authors ) ; } public String formatDate ( ) { return publishedDate . substring ( <NUM_LIT> , <NUM_LIT> ) ; } public String formatSubjects ( ) { StringBuilder allSubjects = new StringBuilder ( ArxivResolver . resolveFull ( primaryCategory ) ) ; for ( String secondaryCategory : secondaryCategories ) { allSubjects . append ( "<STR_LIT>" ) . append ( ArxivResolver . resolveFull ( secondaryCategory ) ) ; } return allSubjects . toString ( ) ; } public String getPDFURL ( ) { return "<STR_LIT>" + arxivID + "<STR_LIT>" ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . graphics . Color ; import android . os . Build ; import android . view . Window ; import androidx . activity . ComponentActivity ; import androidx . activity . EdgeToEdge ; import androidx . core . view . WindowCompat ; import androidx . core . view . WindowInsetsControllerCompat ; import androidx . preference . PreferenceManager ; import com . simon . harmonichackernews . R ; import java . util . Calendar ; import java . util . concurrent . TimeUnit ; public class ThemeUtils { private static final int defaultLightScrim = Color . argb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private static final int defaultDarkScrim = Color . argb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; public static void setupTheme ( ComponentActivity activity ) { setupTheme ( activity , false , true ) ; } public static void setupTheme ( ComponentActivity activity , boolean swipeBack ) { setupTheme ( activity , swipeBack , true ) ; } public static void setupTheme ( ComponentActivity activity , boolean swipeBack , boolean specialFlags ) { String theme = getPreferredTheme ( activity ) ; switch ( theme ) { case "<STR_LIT>" : if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { if ( ! swipeBack ) { activity . setTheme ( R . style . AppThemeMaterialDayNight ) ; } } else { if ( swipeBack ) { activity . setTheme ( R . style . ThemeSwipeBackNoActionBarMaterialDayNight ) ; } } break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarMaterialDark : R . style . AppThemeMaterialDark ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarAmoledDark : R . style . AppThemeAmoledDark ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarGray : R . style . AppThemeGray ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarLight : R . style . AppThemeLight ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarMaterialLight : R . style . AppThemeMaterialLight ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarWhite : R . style . AppThemeWhite ) ; break ; case "<STR_LIT>" : activity . setTheme ( swipeBack ? R . style . Theme_Swipe_Back_NoActionBar : R . style . AppTheme ) ; break ; } Window window = activity . getWindow ( ) ; WindowInsetsControllerCompat insetsController = WindowCompat . getInsetsController ( window , window . getDecorView ( ) ) ; insetsController . setAppearanceLightStatusBars ( ! isDarkMode ( activity ) ) ; insetsController . setAppearanceLightNavigationBars ( ! isDarkMode ( activity ) ) ; if ( specialFlags ) { WindowCompat . setDecorFitsSystemWindows ( window , false ) ; } if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q ) { int navBarColor ; if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { navBarColor = defaultDarkScrim ; } else { navBarColor = isDarkMode ( activity ) ? defaultDarkScrim : defaultLightScrim ; } window . setNavigationBarColor ( navBarColor ) ; } if ( SettingsUtils . shouldUseTransparentStatusBar ( activity ) ) { window . setStatusBarColor ( Color . TRANSPARENT ) ; } } public static boolean isDarkMode ( Context ctx , String theme ) { if ( theme . equals ( "<STR_LIT>" ) ) { return uiModeNight ( ctx ) ; } return theme . equals ( "<STR_LIT>" ) || theme . equals ( "<STR_LIT>" ) || theme . equals ( "<STR_LIT>" ) || theme . equals ( "<STR_LIT>" ) ; } public static boolean isDarkMode ( Context ctx ) { String theme = getPreferredTheme ( ctx ) ; return isDarkMode ( ctx , theme ) ; } public static boolean uiModeNight ( Context ctx ) { int currentNightMode = ctx . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; return currentNightMode == Configuration . UI_MODE_NIGHT_YES ; } public static int getBackgroundColorResource ( Context ctx ) { String theme = getPreferredTheme ( ctx ) ; switch ( theme ) { case "<STR_LIT>" : return android . R . color . black ; case "<STR_LIT>" : return R . color . grayBackground ; case "<STR_LIT>" : return R . color . lightBackground ; case "<STR_LIT>" : return R . color . whiteBackground ; case "<STR_LIT>" : return R . color . material_you_neutral_900 ; case "<STR_LIT>" : return R . color . material_you_neutral_50 ; case "<STR_LIT>" : return uiModeNight ( ctx ) ? R . color . material_you_neutral_900 : R . color . material_you_neutral_50 ; case "<STR_LIT>" : return R . color . background ; default : return R . color . background ; } } public static String getPreferredTheme ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; if ( SettingsUtils . shouldUseSpecialNighttimeTheme ( ctx ) ) { Calendar currentCalendar = Calendar . getInstance ( ) ; int [ ] nighttimeHours = Utils . getNighttimeHours ( ctx ) ; long startTime = TimeUnit . HOURS . toMinutes ( nighttimeHours [ <NUM_LIT> ] ) + nighttimeHours [ <NUM_LIT> ] ; long endTime = TimeUnit . HOURS . toMinutes ( nighttimeHours [ <NUM_LIT> ] ) + nighttimeHours [ <NUM_LIT> ] ; long currentTime = TimeUnit . HOURS . toMinutes ( currentCalendar . get ( Calendar . HOUR_OF_DAY ) ) + currentCalendar . get ( Calendar . MINUTE ) ; if ( Utils . isTimeBetweenTwoTimes ( startTime , endTime , currentTime ) ) { return prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } } return prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } } </s>
<s> package com . simon . harmonichackernews . network ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import android . widget . Toast ; import androidx . appcompat . app . AlertDialog ; import androidx . core . util . Pair ; import androidx . fragment . app . FragmentManager ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . utils . AccountUtils ; import com . simon . harmonichackernews . utils . EncryptedSharedPreferencesHelper ; import com . simon . harmonichackernews . utils . Utils ; import org . jetbrains . annotations . NotNull ; import java . io . IOException ; import java . util . Objects ; import kotlin . Triple ; import okhttp3 . Call ; import okhttp3 . Callback ; import okhttp3 . FormBody ; import okhttp3 . HttpUrl ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class UserActions { private static final String BASE_WEB_URL = "<STR_LIT>" ; private static final String LOGIN_PATH = "<STR_LIT>" ; private static final String VOTE_PATH = "<STR_LIT>" ; private static final String COMMENT_PATH = "<STR_LIT>" ; private static final String SUBMIT_PATH = "<STR_LIT>" ; private static final String ITEM_PATH = "<STR_LIT>" ; private static final String SUBMIT_POST_PATH = "<STR_LIT>" ; private static final String LOGIN_PARAM_ACCT = "<STR_LIT>" ; private static final String LOGIN_PARAM_PW = "<STR_LIT>" ; private static final String LOGIN_PARAM_CREATING = "<STR_LIT>" ; private static final String LOGIN_PARAM_GOTO = "<STR_LIT>" ; private static final String ITEM_PARAM_ID = "<STR_LIT>" ; private static final String VOTE_PARAM_ID = "<STR_LIT>" ; private static final String VOTE_PARAM_HOW = "<STR_LIT>" ; private static final String COMMENT_PARAM_PARENT = "<STR_LIT>" ; private static final String COMMENT_PARAM_TEXT = "<STR_LIT>" ; private static final String SUBMIT_PARAM_TITLE = "<STR_LIT>" ; private static final String SUBMIT_PARAM_URL = "<STR_LIT>" ; private static final String SUBMIT_PARAM_TEXT = "<STR_LIT>" ; private static final String SUBMIT_PARAM_FNID = "<STR_LIT>" ; private static final String SUBMIT_PARAM_FNOP = "<STR_LIT>" ; private static final String VOTE_DIR_UP = "<STR_LIT>" ; private static final String VOTE_DIR_DOWN = "<STR_LIT>" ; private static final String VOTE_DIR_UN = "<STR_LIT>" ; private static final String DEFAULT_REDIRECT = "<STR_LIT>" ; private static final String CREATING_TRUE = "<STR_LIT>" ; private static final String DEFAULT_FNOP = "<STR_LIT>" ; private static final String DEFAULT_SUBMIT_REDIRECT = "<STR_LIT>" ; private static final String REGEX_INPUT = "<STR_LIT>" ; private static final String REGEX_VALUE = "<STR_LIT>" ; private static final String REGEX_CREATE_ERROR_BODY = "<STR_LIT>" ; private static final String HEADER_LOCATION = "<STR_LIT>" ; private static final String HEADER_COOKIE = "<STR_LIT>" ; private static final String HEADER_SET_COOKIE = "<STR_LIT>" ; public static void voteWithDir ( Context ctx , int id , FragmentManager fm , String dir ) { UserActions . vote ( String . valueOf ( id ) , dir , ctx , fm , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { String message = "<STR_LIT>" ; switch ( dir ) { case VOTE_DIR_UP : message = "<STR_LIT>" ; break ; case VOTE_DIR_DOWN : message = "<STR_LIT>" ; break ; case VOTE_DIR_UN : message = "<STR_LIT>" ; break ; } Toast . makeText ( ctx , message , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onFailure ( String summary , String response ) { UserActions . showFailureDetailDialog ( ctx , summary , response ) ; Toast . makeText ( ctx , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } public static void upvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_UP ) ; } public static void downvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_DOWN ) ; } public static void unvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_UN ) ; } public static void vote ( String itemId , String direction , Context ctx , FragmentManager fm , ActionCallback cb ) { Utils . log ( "<STR_LIT>" ) ; Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , fm , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( VOTE_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( VOTE_PARAM_ID , itemId ) . add ( VOTE_PARAM_HOW , direction ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void comment ( String itemId , String text , Context ctx , ActionCallback cb ) { Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , null , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( COMMENT_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( COMMENT_PARAM_PARENT , itemId ) . add ( COMMENT_PARAM_TEXT , text ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void submit ( String title , String text , String url , Context ctx , ActionCallback cb ) { Utils . log ( "<STR_LIT>" ) ; Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , null , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( SUBMIT_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( SUBMIT_PARAM_TITLE , title ) . add ( SUBMIT_PARAM_TEXT , text ) . add ( SUBMIT_PARAM_URL , url ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void executeRequest ( Context ctx , Request request , ActionCallback cb ) { OkHttpClient client = NetworkComponent . getOkHttpClientInstance ( ) ; client . newCall ( request ) . enqueue ( new Callback ( ) { final Handler mainHandler = new Handler ( ctx . getMainLooper ( ) ) ; @ Override public void onResponse ( @ NotNull Call call , @ NotNull Response response ) { mainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( ! response . isSuccessful ( ) ) { cb . onFailure ( "<STR_LIT>" , response . toString ( ) ) ; return ; } try { String responseBody = response . body ( ) . string ( ) ; if ( responseBody . contains ( "<STR_LIT>" ) ) { cb . onFailure ( "<STR_LIT>" , responseBody ) ; return ; } if ( responseBody . contains ( "<STR_LIT>" ) ) { AccountUtils . deleteAccountDetails ( ctx ) ; cb . onFailure ( "<STR_LIT>" , "<STR_LIT>" ) ; return ; } if ( responseBody . contains ( "<STR_LIT>" ) ) { cb . onFailure ( "<STR_LIT>" , responseBody ) ; return ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } cb . onSuccess ( response ) ; } } ) ; } @ Override public void onFailure ( @ NotNull Call call , @ NotNull IOException e ) { mainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { cb . onFailure ( "<STR_LIT>" , null ) ; } } ) ; } } ) ; } public static void showFailureDetailDialog ( Context ctx , String summary , String response ) { try { AlertDialog dialog = new MaterialAlertDialogBuilder ( ctx ) . setTitle ( summary ) . setMessage ( response ) . setNegativeButton ( "<STR_LIT>" , null ) . create ( ) ; dialog . show ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public interface ActionCallback { void onSuccess ( Response response ) ; void onFailure ( String summary , String response ) ; } } </s>
<s> package com . simon . harmonichackernews ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import com . simon . harmonichackernews . utils . ViewUtils ; public class BaseActivity extends AppCompatActivity { private int navBarHeight = <NUM_LIT> ; @ Override protected void onStart ( ) { super . onStart ( ) ; ViewCompat . setOnApplyWindowInsetsListener ( findViewById ( android . R . id . content ) , new OnApplyWindowInsetsListener ( ) { @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat windowInsets ) { Insets insets = windowInsets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) ; navBarHeight = insets . bottom ; return windowInsets ; } } ) ; ViewUtils . requestApplyInsetsWhenAttached ( findViewById ( android . R . id . content ) ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { int screenHeight = getWindow ( ) . getDecorView ( ) . getHeight ( ) ; int actionType = ev . getAction ( ) ; if ( ev . getY ( ) >= ( screenHeight - navBarHeight ) ) { if ( actionType == MotionEvent . ACTION_UP ) { return super . dispatchTouchEvent ( ev ) ; } return true ; } try { return super . dispatchTouchEvent ( ev ) ; } catch ( Exception e ) { return false ; } } } </s>
<s> package com . simon . harmonichackernews . data ; public class Bookmark { public int id ; public long created ; } </s>
<s> package com . gw . swipeback . tools ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; public class ActivityLifecycleCallbacksAdapter implements Application . ActivityLifecycleCallbacks { @ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) { } @ Override public void onActivityStarted ( Activity activity ) { } @ Override public void onActivityResumed ( Activity activity ) { } @ Override public void onActivityPaused ( Activity activity ) { } @ Override public void onActivityStopped ( Activity activity ) { } @ Override public void onActivitySaveInstanceState ( Activity activity , Bundle outState ) { } @ Override public void onActivityDestroyed ( Activity activity ) { } } </s>
<s> package com . simon . harmonichackernews ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . text . Html ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedCallback ; import androidx . activity . SystemBarStyle ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import androidx . coordinatorlayout . widget . CoordinatorLayout ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fragment . app . FragmentTransaction ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . data . CommentsScrollProgress ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . utils . Changelog ; import com . simon . harmonichackernews . utils . FoldableSplitInitializer ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import java . util . ArrayList ; public class MainActivity extends BaseActivity implements StoriesFragment . StoryClickListener { public static ArrayList < CommentsScrollProgress > commentsScrollProgresses = new ArrayList < > ( ) ; int lastPosition = <NUM_LIT> ; public OnBackPressedCallback backPressedCallback ; public int bottom = <NUM_LIT> ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( Utils . isFirstAppStart ( this ) ) { startActivity ( new Intent ( this , WelcomeActivity . class ) ) ; finish ( ) ; } ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_main ) ; updateFragmentLayout ( ) ; if ( Utils . justUpdated ( this ) && SettingsUtils . shouldShowChangelog ( this ) ) { showUpdateDialog ( ) ; } backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { final StoriesFragment fragment = ( StoriesFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . main_fragment_stories_container ) ; if ( fragment != null ) { fragment . exitSearch ( ) ; } } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; updateFragmentLayout ( ) ; } @ Override public void openStory ( Story story , int pos , boolean showWebsite ) { Bundle bundle = story . toBundle ( ) ; bundle . putInt ( CommentsFragment . EXTRA_FORWARD , pos - lastPosition ) ; bundle . putBoolean ( CommentsFragment . EXTRA_SHOW_WEBSITE , showWebsite ) ; if ( FoldableSplitInitializer . isSplitSupported ( this ) ) { bundle . putBoolean ( CommentsActivity . PREVENT_BACK , true ) ; } lastPosition = pos ; if ( Utils . isTablet ( getResources ( ) ) ) { CommentsFragment fragment = new CommentsFragment ( ) ; fragment . setArguments ( bundle ) ; FragmentTransaction transaction = getSupportFragmentManager ( ) . beginTransaction ( ) ; transaction . replace ( R . id . main_fragment_comments_container , fragment ) ; transaction . commit ( ) ; } else { Intent intent = new Intent ( getApplicationContext ( ) , CommentsActivity . class ) ; intent . putExtras ( bundle ) ; startActivity ( intent ) ; if ( ! SettingsUtils . shouldDisableCommentsSwipeBack ( getApplicationContext ( ) ) ) { overridePendingTransition ( R . anim . activity_in_animation , R . anim . hold ) ; } } } private void updateFragmentLayout ( ) { if ( Utils . isTablet ( getResources ( ) ) && findViewById ( R . id . main_fragments_container ) != null ) { LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , getResources ( ) . getInteger ( R . integer . stories_pane_weight ) ) ; findViewById ( R . id . main_fragment_stories_container ) . setLayoutParams ( params ) ; int extraPadding = getResources ( ) . getDimensionPixelSize ( R . dimen . extra_pane_padding ) ; findViewById ( R . id . main_fragments_container ) . setPadding ( extraPadding , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } } private void showUpdateDialog ( ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( "<STR_LIT>" ) . setMessage ( Html . fromHtml ( Changelog . getHTML ( ) ) ) . setNeutralButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { String url = "<STR_LIT>" ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; } } ) . setNegativeButton ( "<STR_LIT>" , null ) . create ( ) ; dialog . show ( ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . style . ClickableSpan ; public abstract class ClickableTableSpan extends ClickableSpan { protected String tableHtml ; public abstract ClickableTableSpan newInstance ( ) ; public void setTableHtml ( String tableHtml ) { this . tableHtml = tableHtml ; } public String getTableHtml ( ) { return tableHtml ; } } </s>
<s> package com . simon . harmonichackernews ; import android . os . Bundle ; import androidx . appcompat . app . AppCompatActivity ; import com . simon . harmonichackernews . utils . ThemeUtils ; public class SplitPlaceholderActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_split_placeholder ) ; } } </s>
<s> package com . simon . harmonichackernews . data ; import java . util . HashSet ; public class CommentsScrollProgress { public CommentsScrollProgress ( ) { collapsedIDs = new HashSet < > ( ) ; } public int storyId ; public int topCommentId ; public int topCommentOffset ; public HashSet < Integer > collapsedIDs ; } </s>
<s> package com . simon . harmonichackernews . utils ; import static androidx . browser . customtabs . CustomTabsService . ACTION_CUSTOM_TABS_CONNECTION ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . content . pm . ResolveInfo ; import android . content . res . Resources ; import android . net . ConnectivityManager ; import android . net . Network ; import android . net . NetworkCapabilities ; import android . net . Uri ; import android . os . AsyncTask ; import android . text . TextUtils ; import android . util . Log ; import android . util . TypedValue ; import android . webkit . URLUtil ; import android . widget . Toast ; import androidx . browser . customtabs . CustomTabColorSchemeParams ; import androidx . browser . customtabs . CustomTabsIntent ; import androidx . core . content . ContextCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . preference . PreferenceManager ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; import com . simon . harmonichackernews . BuildConfig ; import com . simon . harmonichackernews . CommentsActivity ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Bookmark ; import org . json . JSONArray ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . math . BigDecimal ; import java . net . URI ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . text . NumberFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . concurrent . TimeUnit ; public class Utils { private static final long SECOND_MILLIS = <NUM_LIT> ; private static final long MINUTE_MILLIS = <NUM_LIT> * SECOND_MILLIS ; private static final long HOUR_MILLIS = <NUM_LIT> * MINUTE_MILLIS ; private static final long DAY_MILLIS = <NUM_LIT> * HOUR_MILLIS ; private static final long YEAR_MILLIS = <NUM_LIT> * DAY_MILLIS ; public final static String KEY_SHARED_PREFERENCES_CLICKED_IDS = "<STR_LIT>" ; public final static String KEY_SHARED_PREFERENCES_CACHED_STORY = "<STR_LIT>" ; public final static String KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS = "<STR_LIT>" ; public final static String GLOBAL_SHARED_PREFERENCES_KEY = "<STR_LIT>" ; public final static String KEY_SHARED_PREFERENCES_BOOKMARKS = "<STR_LIT>" ; public final static String KEY_SHARED_PREFERENCES_FIRST_TIME = "<STR_LIT>" ; public final static String KEY_SHARED_PREFERENCES_LAST_VERSION = "<STR_LIT>" ; public final static String KEY_NIGHTTIME_FROM_HOUR = "<STR_LIT>" ; public final static String KEY_NIGHTTIME_FROM_MINUTE = "<STR_LIT>" ; public final static String KEY_NIGHTTIME_TO_HOUR = "<STR_LIT>" ; public final static String KEY_NIGHTTIME_TO_MINUTE = "<STR_LIT>" ; public final static String URL_TOP = "<STR_LIT>" ; public final static String URL_NEW = "<STR_LIT>" ; public final static String URL_BEST = "<STR_LIT>" ; public final static String URL_ASK = "<STR_LIT>" ; public final static String URL_SHOW = "<STR_LIT>" ; public final static String URL_JOBS = "<STR_LIT>" ; public static String adservers ; public static void log ( String s ) { Log . d ( "<STR_LIT>" , s ) ; } public static void log ( long i ) { Log . d ( "<STR_LIT>" , String . valueOf ( i ) ) ; } public static void log ( int i ) { Log . d ( "<STR_LIT>" , String . valueOf ( i ) ) ; } public static void log ( float i ) { Log . d ( "<STR_LIT>" , String . valueOf ( i ) ) ; } public static void log ( boolean b ) { Log . d ( "<STR_LIT>" , String . valueOf ( b ) ) ; } public static void toast ( String s , Context ctx ) { Toast . makeText ( ctx , s , Toast . LENGTH_SHORT ) . show ( ) ; } public static String getDomainName ( String url ) throws Exception { if ( url . endsWith ( "<STR_LIT>" ) ) { url = url . substring ( <NUM_LIT> , url . length ( ) - <NUM_LIT> ) ; } URI uri = new URI ( url ) ; String domain = uri . getHost ( ) ; return domain . startsWith ( "<STR_LIT>" ) ? domain . substring ( <NUM_LIT> ) : domain ; } public static void loadAdservers ( Resources resources ) { Runnable r = new Runnable ( ) { @ Override public void run ( ) { String strLine2 ; StringBuilder adserversBuilder = new StringBuilder ( ) ; InputStream fis2 = resources . openRawResource ( R . raw . adblockserverlist ) ; BufferedReader br2 = new BufferedReader ( new InputStreamReader ( fis2 ) ) ; if ( fis2 != null ) { try { while ( ( strLine2 = br2 . readLine ( ) ) != null ) { adserversBuilder . append ( strLine2 ) ; adserversBuilder . append ( "<STR_LIT>" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } Utils . adservers = String . valueOf ( adserversBuilder ) ; } } ; AsyncTask . execute ( r ) ; } public static void cacheStory ( Context ctx , int id , String data ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORY + id , data ) ; Set < String > cachedStories = SettingsUtils . readStringSetFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS ) ; if ( cachedStories == null ) { cachedStories = new HashSet < > ( ) ; } if ( ! cachedStories . isEmpty ( ) ) { for ( Iterator < String > iterator = cachedStories . iterator ( ) ; iterator . hasNext ( ) ; ) { String cached = iterator . next ( ) ; String [ ] idAndDate = cached . split ( "<STR_LIT>" ) ; if ( Integer . parseInt ( idAndDate [ <NUM_LIT> ] ) == id ) { iterator . remove ( ) ; } } } cachedStories . add ( id + "<STR_LIT>" + System . currentTimeMillis ( ) ) ; if ( cachedStories . size ( ) > <NUM_LIT> ) { long oldestTime = - <NUM_LIT> ; int oldestId = - <NUM_LIT> ; for ( String cachedStory : cachedStories ) { String [ ] idAndDate = cachedStory . split ( "<STR_LIT>" ) ; if ( oldestTime == - <NUM_LIT> || Long . parseLong ( idAndDate [ <NUM_LIT> ] ) < oldestTime ) { oldestTime = Long . parseLong ( idAndDate [ <NUM_LIT> ] ) ; oldestId = Integer . parseInt ( idAndDate [ <NUM_LIT> ] ) ; } } cachedStories . remove ( oldestId + "<STR_LIT>" + oldestTime ) ; ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) . edit ( ) . remove ( KEY_SHARED_PREFERENCES_CACHED_STORY + oldestId ) . apply ( ) ; } SettingsUtils . saveStringSetToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS , cachedStories ) ; } public static String loadCachedStory ( Context ctx , int id ) { return SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORY + id ) ; } public static ArrayList < Bookmark > loadBookmarks ( Context ctx , boolean sorted ) { return loadBookmarks ( sorted , SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } public static ArrayList < Bookmark > loadBookmarks ( boolean sorted , String bookmarksString ) { ArrayList < Bookmark > bookmarks = new ArrayList < > ( ) ; if ( bookmarksString == null || bookmarksString . isEmpty ( ) ) { return bookmarks ; } String [ ] pairs = bookmarksString . split ( "<STR_LIT>" ) ; for ( String pair : pairs ) { Bookmark b = new Bookmark ( ) ; String [ ] info = pair . split ( "<STR_LIT>" ) ; if ( info . length == <NUM_LIT> ) { b . id = Integer . parseInt ( info [ <NUM_LIT> ] ) ; b . created = Long . parseLong ( info [ <NUM_LIT> ] ) ; bookmarks . add ( b ) ; } } if ( sorted ) { Collections . sort ( bookmarks , ( b1 , b2 ) -> Long . compare ( b2 . created , b1 . created ) ) ; } return bookmarks ; } public static boolean isBookmarked ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; for ( Bookmark b : bookmarks ) { if ( b . id == id ) { return true ; } } return false ; } public static void saveBookmarks ( Context ctx , ArrayList < Bookmark > bookmarks ) { StringBuilder sb = new StringBuilder ( ) ; int size = bookmarks . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Bookmark b = bookmarks . get ( i ) ; sb . append ( b . id ) ; sb . append ( "<STR_LIT>" ) ; sb . append ( b . created ) ; if ( i != size - <NUM_LIT> ) { sb . append ( "<STR_LIT>" ) ; } } SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_BOOKMARKS , sb . toString ( ) ) ; } public static void addBookmark ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; Bookmark b = new Bookmark ( ) ; b . id = id ; b . created = System . currentTimeMillis ( ) ; bookmarks . add ( b ) ; saveBookmarks ( ctx , bookmarks ) ; } public static void removeBookmark ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; for ( Bookmark bookmark : bookmarks ) { if ( bookmark . id == id ) { bookmarks . remove ( bookmark ) ; break ; } } saveBookmarks ( ctx , bookmarks ) ; } public static String getThousandSeparatedString ( int n ) { BigDecimal bd = new BigDecimal ( n ) ; NumberFormat formatter = NumberFormat . getInstance ( new Locale ( "<STR_LIT>" ) ) ; return formatter . format ( bd . longValue ( ) ) ; } public static ArrayList < String > getFilterWords ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String prefText = prefs . getString ( "<STR_LIT>" , null ) ; ArrayList < String > phrases = new ArrayList < > ( ) ; if ( ! TextUtils . isEmpty ( prefText ) ) { for ( String phrase : prefText . split ( "<STR_LIT>" ) ) { phrases . add ( phrase . trim ( ) ) ; } } return phrases ; } public static ArrayList < String > getFilterDomains ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String prefText = prefs . getString ( "<STR_LIT>" , null ) ; ArrayList < String > phrases = new ArrayList < > ( ) ; if ( ! TextUtils . isEmpty ( prefText ) ) { for ( String phrase : prefText . split ( "<STR_LIT>" ) ) { phrases . add ( phrase . trim ( ) ) ; } } return phrases ; } public static boolean isFirstAppStart ( Context ctx ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; if ( sharedPref . getBoolean ( KEY_SHARED_PREFERENCES_FIRST_TIME , true ) && SettingsUtils . readIntSetFromSharedPreferences ( ctx , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) . isEmpty ( ) ) { sharedPref . edit ( ) . putBoolean ( KEY_SHARED_PREFERENCES_FIRST_TIME , false ) . apply ( ) ; return true ; } return false ; } public static boolean justUpdated ( Context ctx ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; if ( BuildConfig . VERSION_CODE > sharedPref . getInt ( KEY_SHARED_PREFERENCES_LAST_VERSION , - <NUM_LIT> ) ) { sharedPref . edit ( ) . putInt ( KEY_SHARED_PREFERENCES_LAST_VERSION , BuildConfig . VERSION_CODE ) . apply ( ) ; return true ; } return false ; } public static String getTimeAgo ( long time ) { if ( time < <NUM_LIT> ) { time *= <NUM_LIT> ; } long now = System . currentTimeMillis ( ) ; if ( time > now || time <= <NUM_LIT> ) { return "<STR_LIT>" ; } final long diff = now - time ; if ( diff < MINUTE_MILLIS ) { return "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return diff / MINUTE_MILLIS + "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * HOUR_MILLIS ) { return diff / HOUR_MILLIS + "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * HOUR_MILLIS ) { return "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * DAY_MILLIS ) { return diff / DAY_MILLIS + "<STR_LIT>" ; } else if ( diff < <NUM_LIT> * YEAR_MILLIS ) { return "<STR_LIT>" ; } else { return diff / YEAR_MILLIS + "<STR_LIT>" ; } } public static boolean isOnWiFi ( Context ctx ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) ctx . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; Network network = connectivityManager . getActiveNetwork ( ) ; if ( network == null ) { return false ; } NetworkCapabilities networkCapabilities = connectivityManager . getNetworkCapabilities ( network ) ; return networkCapabilities != null && networkCapabilities . hasTransport ( NetworkCapabilities . TRANSPORT_WIFI ) ; } public static void launchCustomTab ( Context ctx , String url ) { launchCustomTab ( ctx , url , true ) ; } public static void launchCustomTab ( Context ctx , String url , boolean shareable ) { if ( url != null ) { if ( SettingsUtils . shouldUseExternalBrowser ( ctx ) || ! isCustomTabSupported ( ctx ) ) { launchInExternalBrowser ( ctx , url ) ; } else { try { CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( url ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( URLUtil . guessUrl ( url ) ) ) ; } catch ( Exception e1 ) { try { if ( ! url . startsWith ( "<STR_LIT>" ) && ! url . startsWith ( "<STR_LIT>" ) ) url = "<STR_LIT>" + url ; CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( url ) ) ; } catch ( Exception e2 ) { launchInExternalBrowser ( ctx , url ) ; } } } } } } public static void launchInExternalBrowser ( Context ctx , String url ) { try { Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e ) { try { Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( URLUtil . guessUrl ( url ) ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e1 ) { try { if ( ! url . startsWith ( "<STR_LIT>" ) && ! url . startsWith ( "<STR_LIT>" ) ) url = "<STR_LIT>" + url ; Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e2 ) { Toast . makeText ( ctx , "<STR_LIT>" + url , Toast . LENGTH_SHORT ) . show ( ) ; } } } } public static boolean downloadPDF ( Context context , String pdfUrl ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( pdfUrl ) ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( intent . resolveActivity ( context . getPackageManager ( ) ) != null ) { context . startActivity ( intent ) ; return true ; } return false ; } public static boolean isCustomTabSupported ( Context context ) { return ! getCustomTabsPackages ( context ) . isEmpty ( ) ; } public static ArrayList < ResolveInfo > getCustomTabsPackages ( Context context ) { PackageManager pm = context . getPackageManager ( ) ; Intent activityIntent = new Intent ( ) . setAction ( Intent . ACTION_VIEW ) . addCategory ( Intent . CATEGORY_BROWSABLE ) . setData ( Uri . fromParts ( "<STR_LIT>" , "<STR_LIT>" , null ) ) ; List < ResolveInfo > resolvedActivityList = pm . queryIntentActivities ( activityIntent , <NUM_LIT> ) ; ArrayList < ResolveInfo > packagesSupportingCustomTabs = new ArrayList < > ( ) ; for ( ResolveInfo info : resolvedActivityList ) { Intent serviceIntent = new Intent ( ) ; serviceIntent . setAction ( ACTION_CUSTOM_TABS_CONNECTION ) ; serviceIntent . setPackage ( info . activityInfo . packageName ) ; if ( pm . resolveService ( serviceIntent , <NUM_LIT> ) != null ) { packagesSupportingCustomTabs . add ( info ) ; } } return packagesSupportingCustomTabs ; } public static int [ ] JSONArrayToIntArray ( JSONArray jsonArray ) { int [ ] intArray = new int [ jsonArray . length ( ) ] ; for ( int i = <NUM_LIT> ; i < intArray . length ; ++ i ) { intArray [ i ] = jsonArray . optInt ( i ) ; } return intArray ; } public static int getColorViaAttr ( Context ctx , int attr ) { TypedValue typedValue = new TypedValue ( ) ; Resources . Theme theme = ctx . getTheme ( ) ; theme . resolveAttribute ( attr , typedValue , true ) ; return typedValue . data ; } public static String thousandSeparated ( int n ) { DecimalFormatSymbols symbols = DecimalFormatSymbols . getInstance ( ) ; symbols . setGroupingSeparator ( '<STR_LIT>' ) ; DecimalFormat formatter = new DecimalFormat ( "<STR_LIT>" , symbols ) ; return formatter . format ( new BigDecimal ( n ) . longValue ( ) ) ; } public static void writeInFile ( Context ctx , Uri uri , String text ) throws IOException { OutputStream outputStream ; outputStream = ctx . getContentResolver ( ) . openOutputStream ( uri ) ; BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( outputStream ) ) ; bw . write ( text ) ; bw . flush ( ) ; bw . close ( ) ; } public static String readFileContent ( Context ctx , Uri uri ) throws IOException { InputStream inputStream = ctx . getContentResolver ( ) . openInputStream ( uri ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; String currentline ; while ( ( currentline = reader . readLine ( ) ) != null ) { stringBuilder . append ( currentline ) ; } inputStream . close ( ) ; return stringBuilder . toString ( ) ; } public static boolean isTimeBetweenTwoTimes ( long initialTime , long finalTime , long currentTime ) { if ( finalTime < initialTime ) { finalTime += TimeUnit . DAYS . toMinutes ( <NUM_LIT> ) ; } if ( currentTime < initialTime ) { currentTime += TimeUnit . DAYS . toMinutes ( <NUM_LIT> ) ; } return initialTime <= currentTime && currentTime < finalTime ; } public static void setNighttimeHours ( int fromHour , int fromMinute , int toHour , int toMinute , Context ctx ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_HOUR , fromHour + "<STR_LIT>" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_MINUTE , fromMinute + "<STR_LIT>" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_TO_HOUR , toHour + "<STR_LIT>" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_TO_MINUTE , toMinute + "<STR_LIT>" ) ; } public static int [ ] getNighttimeHours ( Context ctx ) { return new int [ ] { Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_HOUR , "<STR_LIT>" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_MINUTE , "<STR_LIT>" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_TO_HOUR , "<STR_LIT>" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_TO_MINUTE , "<STR_LIT>" ) ) } ; } public static boolean timeInSecondsMoreThanTwoWeeksAgo ( int time ) { return ( System . currentTimeMillis ( ) - ( ( long ) time ) * <NUM_LIT> ) / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> > <NUM_LIT> ; } public static boolean timeInSecondsMoreThanTwoHoursAgo ( int time ) { return ( System . currentTimeMillis ( ) - ( ( long ) time ) * <NUM_LIT> ) / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> > <NUM_LIT> ; } public static float pxFromDp ( final Resources resources , final float dp ) { return dp * resources . getDisplayMetrics ( ) . density ; } public static int pxFromDpInt ( final Resources resources , final float dp ) { return Math . round ( pxFromDp ( resources , dp ) ) ; } public static boolean isTablet ( Resources res ) { return res . getBoolean ( R . bool . is_tablet ) ; } public static void openLinkMaybeHN ( Context context , String href ) { Uri uri = Uri . parse ( href ) ; String scheme = uri . getScheme ( ) ; if ( "<STR_LIT>" . equalsIgnoreCase ( scheme ) || "<STR_LIT>" . equalsIgnoreCase ( scheme ) ) { if ( "<STR_LIT>" . equalsIgnoreCase ( uri . getHost ( ) ) && "<STR_LIT>" . equals ( uri . getPath ( ) ) ) { String sId = uri . getQueryParameter ( "<STR_LIT>" ) ; if ( sId != null && ! sId . isEmpty ( ) && TextUtils . isDigitsOnly ( sId ) ) { int id = Integer . parseInt ( sId ) ; openCommentsActivity ( id , context ) ; return ; } } } Utils . launchCustomTab ( context , href ) ; } public static void openCommentsActivity ( int id , Context context ) { Uri uri = Uri . parse ( "<STR_LIT>" ) . buildUpon ( ) . appendQueryParameter ( "<STR_LIT>" , String . valueOf ( id ) ) . build ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; intent . setClass ( context , CommentsActivity . class ) ; context . startActivity ( intent ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import android . text . Html ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class WrapperContentHandler implements ContentHandler , Html . TagHandler { private ContentHandler mContentHandler ; private WrapperTagHandler mTagHandler ; private Editable mSpannableStringBuilder ; public WrapperContentHandler ( WrapperTagHandler tagHandler ) { this . mTagHandler = tagHandler ; } @ Override public void handleTag ( boolean opening , String tag , Editable output , XMLReader xmlReader ) { if ( mContentHandler == null ) { mSpannableStringBuilder = output ; mContentHandler = xmlReader . getContentHandler ( ) ; xmlReader . setContentHandler ( this ) ; } } @ Override public void setDocumentLocator ( Locator locator ) { mContentHandler . setDocumentLocator ( locator ) ; } @ Override public void startDocument ( ) throws SAXException { mContentHandler . startDocument ( ) ; } @ Override public void endDocument ( ) throws SAXException { mContentHandler . endDocument ( ) ; } @ Override public void startPrefixMapping ( String prefix , String uri ) throws SAXException { mContentHandler . startPrefixMapping ( prefix , uri ) ; } @ Override public void endPrefixMapping ( String prefix ) throws SAXException { mContentHandler . endPrefixMapping ( prefix ) ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! mTagHandler . handleTag ( true , localName , mSpannableStringBuilder , attributes ) ) { mContentHandler . startElement ( uri , localName , qName , attributes ) ; } } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! mTagHandler . handleTag ( false , localName , mSpannableStringBuilder , null ) ) { mContentHandler . endElement ( uri , localName , qName ) ; } } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { mContentHandler . characters ( ch , start , length ) ; } @ Override public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { mContentHandler . ignorableWhitespace ( ch , start , length ) ; } @ Override public void processingInstruction ( String target , String data ) throws SAXException { mContentHandler . processingInstruction ( target , data ) ; } @ Override public void skippedEntity ( String name ) throws SAXException { mContentHandler . skippedEntity ( name ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import com . simon . harmonichackernews . data . Comment ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class CommentSorter { public static void sort ( Context ctx , List < Comment > comments ) { String sortType = SettingsUtils . getPreferredCommentSorting ( ctx ) ; switch ( sortType ) { case "<STR_LIT>" : for ( int i = <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { comments . get ( i ) . totalReplies = numChildren ( comments , i ) ; } sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( - c1 . totalReplies , - c2 . totalReplies ) ; } } ) ; break ; case "<STR_LIT>" : sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( - c1 . time , - c2 . time ) ; } } ) ; break ; case "<STR_LIT>" : sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( c1 . time , c2 . time ) ; } } ) ; break ; } } private static void sortComments ( List < Comment > comments , Comparator < Comment > comparator ) { List < Comment > commentsWithChildren = populateChildComments ( comments ) ; sortCommentsRecursive ( commentsWithChildren , comparator ) ; setSortOrder ( commentsWithChildren ) ; comments . get ( <NUM_LIT> ) . sortOrder = - <NUM_LIT> ; Collections . sort ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment e1 , Comment e2 ) { return Integer . compare ( e1 . sortOrder , e2 . sortOrder ) ; } } ) ; } private static void sortCommentsRecursive ( List < Comment > commentsWithChildren , Comparator < Comment > comparator ) { Collections . sort ( commentsWithChildren , comparator ) ; for ( Comment c : commentsWithChildren ) { sortCommentsRecursive ( c . childComments , comparator ) ; } } private static List < Comment > populateChildComments ( List < Comment > comments ) { List < Comment > commentsWithChildren = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { Comment comment = comments . get ( i ) ; if ( comment . depth == <NUM_LIT> ) { commentsWithChildren . add ( comment ) ; populateChildComments ( comments , comment , i ) ; } } return commentsWithChildren ; } private static void populateChildComments ( List < Comment > comments , Comment comment , int startIndex ) { int targetDepth = comment . depth + <NUM_LIT> ; comment . childComments = new ArrayList < > ( ) ; for ( int i = startIndex + <NUM_LIT> ; i < comments . size ( ) && comments . get ( i ) . depth >= targetDepth ; i ++ ) { if ( comments . get ( i ) . depth == targetDepth ) { comment . childComments . add ( comments . get ( i ) ) ; populateChildComments ( comments , comments . get ( i ) , i ) ; } } } private static void setSortOrder ( List < Comment > commentsWithChildren ) { List < Comment > flatComments = new ArrayList < > ( ) ; flattenComments ( commentsWithChildren , flatComments ) ; for ( int i = <NUM_LIT> ; i < flatComments . size ( ) ; i ++ ) { flatComments . get ( i ) . sortOrder = i ; } } private static void flattenComments ( List < Comment > comments , List < Comment > flatComments ) { for ( Comment comment : comments ) { flatComments . add ( comment ) ; if ( comment . childComments != null ) { flattenComments ( comment . childComments , flatComments ) ; } } } private static int numChildren ( List < Comment > comments , int startIndex ) { int count = <NUM_LIT> ; int targetDepth = comments . get ( startIndex ) . depth ; for ( int i = startIndex + <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { if ( comments . get ( i ) . depth == targetDepth ) { break ; } else { count ++ ; } } return count ; } } </s>
<s> package com . simon . harmonichackernews ; import android . app . Dialog ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . simon . harmonichackernews . utils . AccountUtils ; import com . simon . harmonichackernews . utils . ViewUtils ; public class LoginDialogFragment extends AppCompatDialogFragment { public static String TAG = "<STR_LIT>" ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireActivity ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . login_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; TextInputEditText usernameInput = rootView . findViewById ( R . id . login_dialog_username ) ; TextInputEditText passwordInput = rootView . findViewById ( R . id . login_dialog_password ) ; MaterialButton cancelButton = rootView . findViewById ( R . id . login_dialog_cancel ) ; MaterialButton saveButton = rootView . findViewById ( R . id . login_dialog_save ) ; Button infoButton = rootView . findViewById ( R . id . login_dialog_more_info ) ; LinearLayout infoContainer = rootView . findViewById ( R . id . login_dialog_info_container ) ; usernameInput . addTextChangedListener ( new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; } } ) ; passwordInput . addTextChangedListener ( new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; } } ) ; boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; cancelButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { dismiss ( ) ; } } ) ; saveButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { AccountUtils . setAccountDetails ( getContext ( ) , usernameInput . getText ( ) . toString ( ) , passwordInput . getText ( ) . toString ( ) ) ; dismiss ( ) ; } } ) ; infoButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { infoButton . setVisibility ( View . GONE ) ; infoContainer . setVisibility ( View . VISIBLE ) ; } } ) ; return dialog ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . text . Html ; import android . text . Spannable ; import android . text . Spanned ; import android . text . style . QuoteSpan ; import android . util . AttributeSet ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RawRes ; import java . io . InputStream ; import java . util . Scanner ; public class HtmlTextView extends JellyBeanSpanFixTextView { public static final String TAG = "<STR_LIT>" ; public static final boolean DEBUG = false ; public int blockQuoteBackgroundColor = getResources ( ) . getColor ( android . R . color . white ) ; public int blockQuoteStripColor = getResources ( ) . getColor ( android . R . color . black ) ; public float blockQuoteStripWidth = <NUM_LIT> ; public float blockQuoteGap = <NUM_LIT> ; @ Nullable private ClickableTableSpan clickableTableSpan ; @ Nullable private DrawTableLinkSpan drawTableLinkSpan ; @ Nullable private OnClickATagListener onClickATagListener ; private float indent = <NUM_LIT> ; private boolean removeTrailingWhiteSpace = true ; public HtmlTextView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } public HtmlTextView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public HtmlTextView ( Context context ) { super ( context ) ; } public void setHtml ( @ RawRes int resId ) { setHtml ( resId , null ) ; } public void setHtml ( @ NonNull String html ) { setHtml ( html , null ) ; } public void setHtml ( @ RawRes int resId , @ Nullable Html . ImageGetter imageGetter ) { InputStream inputStreamText = getContext ( ) . getResources ( ) . openRawResource ( resId ) ; setHtml ( convertStreamToString ( inputStreamText ) , imageGetter ) ; } public void setHtml ( @ NonNull String html , @ Nullable Html . ImageGetter imageGetter ) { Spanned styledText = HtmlFormatter . formatHtml ( html , imageGetter , clickableTableSpan , drawTableLinkSpan , new HtmlFormatter . TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return onClickATagListener ; } } , indent , removeTrailingWhiteSpace ) ; replaceQuoteSpans ( styledText ) ; setText ( styledText ) ; setMovementMethod ( LocalLinkMovementMethod . getInstance ( ) ) ; } public void setRemoveTrailingWhiteSpace ( boolean removeTrailingWhiteSpace ) { this . removeTrailingWhiteSpace = removeTrailingWhiteSpace ; } public void setClickableTableSpan ( @ Nullable ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; } public void setDrawTableLinkSpan ( @ Nullable DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; } public void setOnClickATagListener ( @ Nullable OnClickATagListener onClickATagListener ) { this . onClickATagListener = onClickATagListener ; } public void setListIndentPx ( float px ) { this . indent = px ; } @ NonNull private static String convertStreamToString ( @ NonNull InputStream is ) { Scanner s = new Scanner ( is ) . useDelimiter ( "<STR_LIT>" ) ; return s . hasNext ( ) ? s . next ( ) : "<STR_LIT>" ; } private void replaceQuoteSpans ( Spanned spanned ) { Spannable spannable = ( Spannable ) spanned ; QuoteSpan [ ] quoteSpans = spannable . getSpans ( <NUM_LIT> , spannable . length ( ) - <NUM_LIT> , QuoteSpan . class ) ; for ( QuoteSpan quoteSpan : quoteSpans ) { int start = spannable . getSpanStart ( quoteSpan ) ; int end = spannable . getSpanEnd ( quoteSpan ) ; int flags = spannable . getSpanFlags ( quoteSpan ) ; spannable . removeSpan ( quoteSpan ) ; spannable . setSpan ( new DesignQuoteSpan ( blockQuoteBackgroundColor , blockQuoteStripColor , blockQuoteStripWidth , blockQuoteGap ) , start , end , flags ) ; } } } </s>
<s> package com . simon . harmonichackernews . utils ; import java . util . HashMap ; import java . util . Map ; public class ArxivResolver { private static final Map < String , String > ARXIV_SUBJECTS = new HashMap < > ( ) ; static { ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; ARXIV_SUBJECTS . put ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static String resolveSubject ( String abbreviation ) { return ARXIV_SUBJECTS . get ( abbreviation ) ; } public static boolean isArxivSubjet ( String abbr ) { return ARXIV_SUBJECTS . containsKey ( abbr ) ; } public static String resolveFull ( String category ) { return ArxivResolver . resolveSubject ( category ) + "<STR_LIT>" + category + "<STR_LIT>" ; } } </s>
<s> package com . simon . harmonichackernews . data ; public class PollOption { public boolean loaded ; public String text ; public int points ; public int id ; } </s>
<s> package com . simon . harmonichackernews . utils ; public class Changelog { static public String getHTML ( ) { return "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . content . res . Resources ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Canvas ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . text . Html . ImageGetter ; import android . util . Log ; import android . view . View ; import android . widget . TextView ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . ref . WeakReference ; import java . net . URI ; import java . net . URL ; public class HtmlHttpImageGetter implements ImageGetter { private TextView container ; private URI baseUri ; private boolean matchParentWidth ; private int placeHolder ; private boolean compressImage = false ; private int qualityImage = <NUM_LIT> ; public HtmlHttpImageGetter ( TextView textView ) { this . container = textView ; this . matchParentWidth = false ; } public HtmlHttpImageGetter ( TextView textView , String baseUrl ) { this . container = textView ; if ( baseUrl != null ) { this . baseUri = URI . create ( baseUrl ) ; } } public HtmlHttpImageGetter ( TextView textView , String baseUrl , boolean matchParentWidth ) { this ( textView , baseUrl , <NUM_LIT> , matchParentWidth ) ; } public HtmlHttpImageGetter ( TextView textView , String baseUrl , int placeHolder , boolean matchParentWidth ) { this . container = textView ; this . placeHolder = placeHolder ; this . matchParentWidth = matchParentWidth ; if ( baseUrl != null ) { this . baseUri = URI . create ( baseUrl ) ; } } public void enableCompressImage ( boolean enable ) { enableCompressImage ( enable , <NUM_LIT> ) ; } public void enableCompressImage ( boolean enable , int quality ) { compressImage = enable ; qualityImage = quality ; } public Drawable getDrawable ( String source ) { UrlDrawable urlDrawable = new UrlDrawable ( ) ; if ( placeHolder != <NUM_LIT> ) { Drawable placeDrawable = container . getContext ( ) . getResources ( ) . getDrawable ( placeHolder ) ; placeDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , placeDrawable . getIntrinsicWidth ( ) , placeDrawable . getIntrinsicHeight ( ) ) ; urlDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , placeDrawable . getIntrinsicWidth ( ) , placeDrawable . getIntrinsicHeight ( ) ) ; urlDrawable . drawable = placeDrawable ; } ImageGetterAsyncTask asyncTask = new ImageGetterAsyncTask ( urlDrawable , this , container , matchParentWidth , compressImage , qualityImage ) ; asyncTask . execute ( source ) ; return urlDrawable ; } private static class ImageGetterAsyncTask extends AsyncTask < String , Void , Drawable > { private final WeakReference < UrlDrawable > drawableReference ; private final WeakReference < HtmlHttpImageGetter > imageGetterReference ; private final WeakReference < View > containerReference ; private final WeakReference < Resources > resources ; private String source ; private boolean matchParentWidth ; private float scale ; private boolean compressImage = false ; private int qualityImage = <NUM_LIT> ; public ImageGetterAsyncTask ( UrlDrawable d , HtmlHttpImageGetter imageGetter , View container , boolean matchParentWidth , boolean compressImage , int qualityImage ) { this . drawableReference = new WeakReference < > ( d ) ; this . imageGetterReference = new WeakReference < > ( imageGetter ) ; this . containerReference = new WeakReference < > ( container ) ; this . resources = new WeakReference < > ( container . getResources ( ) ) ; this . matchParentWidth = matchParentWidth ; this . compressImage = compressImage ; this . qualityImage = qualityImage ; } @ Override protected Drawable doInBackground ( String ... params ) { source = params [ <NUM_LIT> ] ; if ( resources . get ( ) != null ) { if ( compressImage ) { return fetchCompressedDrawable ( resources . get ( ) , source ) ; } else { return fetchDrawable ( resources . get ( ) , source ) ; } } return null ; } @ Override protected void onPostExecute ( Drawable result ) { if ( result == null ) { Log . w ( HtmlTextView . TAG , "<STR_LIT>" + source + "<STR_LIT>" ) ; return ; } final UrlDrawable urlDrawable = drawableReference . get ( ) ; if ( urlDrawable == null ) { return ; } urlDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( result . getIntrinsicWidth ( ) * scale ) , ( int ) ( result . getIntrinsicHeight ( ) * scale ) ) ; urlDrawable . drawable = result ; final HtmlHttpImageGetter imageGetter = imageGetterReference . get ( ) ; if ( imageGetter == null ) { return ; } imageGetter . container . invalidate ( ) ; imageGetter . container . setText ( imageGetter . container . getText ( ) ) ; } public Drawable fetchDrawable ( Resources res , String urlString ) { try { InputStream is = fetch ( urlString ) ; Drawable drawable = new BitmapDrawable ( res , is ) ; scale = getScale ( drawable ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( drawable . getIntrinsicWidth ( ) * scale ) , ( int ) ( drawable . getIntrinsicHeight ( ) * scale ) ) ; return drawable ; } catch ( Exception e ) { return null ; } } public Drawable fetchCompressedDrawable ( Resources res , String urlString ) { try { InputStream is = fetch ( urlString ) ; Bitmap original = new BitmapDrawable ( res , is ) . getBitmap ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; original . compress ( Bitmap . CompressFormat . JPEG , qualityImage , out ) ; original . recycle ( ) ; is . close ( ) ; Bitmap decoded = BitmapFactory . decodeStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; out . close ( ) ; scale = getScale ( decoded ) ; BitmapDrawable b = new BitmapDrawable ( res , decoded ) ; b . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( b . getIntrinsicWidth ( ) * scale ) , ( int ) ( b . getIntrinsicHeight ( ) * scale ) ) ; return b ; } catch ( Exception e ) { return null ; } } private float getScale ( Bitmap bitmap ) { View container = containerReference . get ( ) ; if ( container == null ) { return <NUM_LIT> ; } float maxWidth = container . getWidth ( ) ; float originalDrawableWidth = bitmap . getWidth ( ) ; return maxWidth / originalDrawableWidth ; } private float getScale ( Drawable drawable ) { View container = containerReference . get ( ) ; if ( ! matchParentWidth || container == null ) { return <NUM_LIT> ; } float maxWidth = container . getWidth ( ) ; float originalDrawableWidth = drawable . getIntrinsicWidth ( ) ; return maxWidth / originalDrawableWidth ; } private InputStream fetch ( String urlString ) throws IOException { URL url ; final HtmlHttpImageGetter imageGetter = imageGetterReference . get ( ) ; if ( imageGetter == null ) { return null ; } if ( imageGetter . baseUri != null ) { url = imageGetter . baseUri . resolve ( urlString ) . toURL ( ) ; } else { url = URI . create ( urlString ) . toURL ( ) ; } return ( InputStream ) url . getContent ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public class UrlDrawable extends BitmapDrawable { protected Drawable drawable ; @ Override public void draw ( Canvas canvas ) { if ( drawable != null ) { drawable . draw ( canvas ) ; } } } } </s>
<s> package com . simon . harmonichackernews ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . content . res . Resources ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . ScrollView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowCompat ; import androidx . core . view . WindowInsetsAnimationCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . swiperefreshlayout . widget . CircularProgressDrawable ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . google . android . material . textfield . TextInputLayout ; import com . simon . harmonichackernews . network . UserActions ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . List ; import okhttp3 . Response ; public class ComposeActivity extends AppCompatActivity { public final static String EXTRA_ID = "<STR_LIT>" ; public final static String EXTRA_PARENT_TEXT = "<STR_LIT>" ; public final static String EXTRA_USER = "<STR_LIT>" ; public final static String EXTRA_TYPE = "<STR_LIT>" ; public final static int TYPE_TOP_COMMENT = <NUM_LIT> ; public final static int TYPE_COMMENT_REPLY = <NUM_LIT> ; public final static int TYPE_POST = <NUM_LIT> ; private EditText editText ; private TextInputEditText editTextTitle ; private TextInputEditText editTextUrl ; private TextInputEditText editTextText ; private TextInputLayout titleContainer ; private TextInputLayout urlContainer ; private TextInputLayout textContainer ; private Button submitButton ; private HtmlTextView replyingTextView ; private ScrollView replyingScrollView ; private TextView topCommentTextView ; private int id ; private String parentText ; private String user ; private int type ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false , false ) ; setContentView ( R . layout . activity_compose ) ; editText = findViewById ( R . id . compose_edittext ) ; editTextTitle = findViewById ( R . id . compose_edittext_title ) ; editTextUrl = findViewById ( R . id . compose_edittext_url ) ; editTextText = findViewById ( R . id . compose_edittext_text ) ; titleContainer = findViewById ( R . id . compose_title_container ) ; urlContainer = findViewById ( R . id . compose_url_container ) ; textContainer = findViewById ( R . id . compose_text_container ) ; submitButton = findViewById ( R . id . compose_submit ) ; replyingTextView = findViewById ( R . id . compose_replying_text ) ; replyingScrollView = findViewById ( R . id . compose_replying_scrollview ) ; topCommentTextView = findViewById ( R . id . compose_top_comment ) ; TextView postInfo = findViewById ( R . id . compose_submit_info ) ; LinearLayout bottomContainer = findViewById ( R . id . compose_bottom_container ) ; LinearLayout container = findViewById ( R . id . compose_container ) ; Intent intent = getIntent ( ) ; id = intent . getIntExtra ( EXTRA_ID , - <NUM_LIT> ) ; parentText = intent . getStringExtra ( EXTRA_PARENT_TEXT ) ; user = intent . getStringExtra ( EXTRA_USER ) ; type = intent . getIntExtra ( EXTRA_TYPE , TYPE_POST ) ; if ( type != TYPE_POST && id == - <NUM_LIT> ) { Toast . makeText ( this , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } switch ( type ) { case TYPE_TOP_COMMENT : replyingScrollView . setVisibility ( View . GONE ) ; topCommentTextView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setText ( "<STR_LIT>" + parentText ) ; break ; case TYPE_COMMENT_REPLY : replyingScrollView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setVisibility ( View . GONE ) ; replyingTextView . setHtml ( "<STR_LIT>" + user + "<STR_LIT>" + parentText ) ; replyingTextView . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; break ; case TYPE_POST : replyingScrollView . setVisibility ( View . GONE ) ; topCommentTextView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setText ( "<STR_LIT>" ) ; titleContainer . setVisibility ( View . VISIBLE ) ; urlContainer . setVisibility ( View . VISIBLE ) ; textContainer . setVisibility ( View . VISIBLE ) ; postInfo . setVisibility ( View . VISIBLE ) ; editText . setVisibility ( View . GONE ) ; break ; } ViewUtils . SimpleTextWatcher updateStatusTextWatcher = new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { updateEnabledStatuses ( ) ; } } ; editText . addTextChangedListener ( updateStatusTextWatcher ) ; editTextTitle . addTextChangedListener ( updateStatusTextWatcher ) ; editTextUrl . addTextChangedListener ( updateStatusTextWatcher ) ; editTextText . addTextChangedListener ( updateStatusTextWatcher ) ; WindowCompat . setDecorFitsSystemWindows ( getWindow ( ) , false ) ; ViewCompat . setOnApplyWindowInsetsListener ( container , new OnApplyWindowInsetsListener ( ) { @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat windowInsets ) { Insets insets = windowInsets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) | WindowInsetsCompat . Type . ime ( ) ) ; int sideMargin = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ; bottomContainer . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , insets . bottom ) ; container . setPadding ( insets . left + sideMargin , insets . top , insets . right + sideMargin , <NUM_LIT> ) ; return windowInsets ; } } ) ; ViewUtils . requestApplyInsetsWhenAttached ( container ) ; ViewCompat . setWindowInsetsAnimationCallback ( bottomContainer , new WindowInsetsAnimationCompat . Callback ( WindowInsetsAnimationCompat . Callback . DISPATCH_MODE_STOP ) { @ NonNull @ Override public WindowInsetsCompat onProgress ( @ NonNull WindowInsetsCompat insets , @ NonNull List < WindowInsetsAnimationCompat > runningAnimations ) { WindowInsetsAnimationCompat imeAnimation = null ; for ( WindowInsetsAnimationCompat animation : runningAnimations ) { if ( ( animation . getTypeMask ( ) & WindowInsetsCompat . Type . ime ( ) ) != <NUM_LIT> ) { imeAnimation = animation ; break ; } } if ( imeAnimation != null ) { bottomContainer . setTranslationY ( - ( startBottom - endBottom ) * ( <NUM_LIT> - imeAnimation . getInterpolatedFraction ( ) ) ) ; } return insets ; } float startBottom ; @ Override public void onPrepare ( @ NonNull WindowInsetsAnimationCompat animation ) { startBottom = bottomContainer . getPaddingBottom ( ) ; } float endBottom ; @ NonNull @ Override public WindowInsetsAnimationCompat . BoundsCompat onStart ( @ NonNull WindowInsetsAnimationCompat animation , @ NonNull WindowInsetsAnimationCompat . BoundsCompat bounds ) { endBottom = bottomContainer . getPaddingBottom ( ) ; return bounds ; } } ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( editText . getContext ( ) ) . setMessage ( type == TYPE_POST ? "<STR_LIT>" : "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { dialog . cancel ( ) ; finish ( ) ; } } ) . setNegativeButton ( "<STR_LIT>" , null ) . create ( ) ; dialog . show ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; updateEnabledStatuses ( ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; ViewGroup . LayoutParams layout = replyingScrollView . getLayoutParams ( ) ; int dp160 = Utils . pxFromDpInt ( getResources ( ) , <NUM_LIT> ) ; int screenHeightThird = Resources . getSystem ( ) . getDisplayMetrics ( ) . heightPixels / <NUM_LIT> ; layout . height = Math . min ( dp160 , screenHeightThird ) ; replyingScrollView . setLayoutParams ( layout ) ; } public void infoClick ( View view ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , null ) . create ( ) ; dialog . show ( ) ; } private void updateEnabledStatuses ( ) { boolean enable ; if ( type == TYPE_POST ) { boolean hasTitle = ! TextUtils . isEmpty ( editTextTitle . getText ( ) . toString ( ) ) ; boolean hasUrl = ! TextUtils . isEmpty ( editTextUrl . getText ( ) . toString ( ) ) ; boolean hasText = ! TextUtils . isEmpty ( editTextText . getText ( ) . toString ( ) ) ; enable = hasTitle && ( hasText || hasUrl ) ; } else { enable = ! TextUtils . isEmpty ( editText . getText ( ) . toString ( ) ) ; } backPressedCallback . setEnabled ( enable ) ; submitButton . setEnabled ( enable ) ; } public void submit ( View view ) { MaterialButton submitButton = ( MaterialButton ) view ; CircularProgressDrawable c = new CircularProgressDrawable ( this ) ; submitButton . setIcon ( c ) ; c . start ( ) ; if ( type == TYPE_POST ) { UserActions . submit ( editTextTitle . getText ( ) . toString ( ) , editText . getText ( ) . toString ( ) , editTextUrl . getText ( ) . toString ( ) , view . getContext ( ) , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; Toast . makeText ( view . getContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } @ Override public void onFailure ( String summary , String response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; UserActions . showFailureDetailDialog ( view . getContext ( ) , summary , response ) ; Toast . makeText ( view . getContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } else { UserActions . comment ( String . valueOf ( id ) , editText . getText ( ) . toString ( ) , getApplicationContext ( ) , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; Toast . makeText ( view . getContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } @ Override public void onFailure ( String summary , String response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; UserActions . showFailureDetailDialog ( view . getContext ( ) , summary , response ) ; Toast . makeText ( view . getContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } } } </s>
<s> package com . simon . harmonichackernews . network ; import com . android . volley . AuthFailureError ; import com . android . volley . Header ; import com . android . volley . Request ; import com . android . volley . toolbox . BaseHttpStack ; import com . android . volley . toolbox . HttpResponse ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import okhttp3 . Call ; import okhttp3 . Headers ; import okhttp3 . MediaType ; import okhttp3 . OkHttpClient ; import okhttp3 . RequestBody ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class VolleyOkHttp3StackInterceptors extends BaseHttpStack { private static final RequestBody EMPTY_REQUEST = RequestBody . create ( new byte [ <NUM_LIT> ] ) ; public VolleyOkHttp3StackInterceptors ( ) { } private static void setConnectionParametersForRequest ( okhttp3 . Request . Builder builder , Request < ? > request ) throws AuthFailureError { switch ( request . getMethod ( ) ) { case Request . Method . DEPRECATED_GET_OR_POST : byte [ ] postBody = request . getBody ( ) ; if ( postBody != null ) { builder . post ( RequestBody . create ( postBody , MediaType . parse ( request . getBodyContentType ( ) ) ) ) ; } break ; case Request . Method . GET : builder . get ( ) ; break ; case Request . Method . DELETE : builder . delete ( createRequestBody ( request ) ) ; break ; case Request . Method . POST : builder . post ( createRequestBody ( request ) ) ; break ; case Request . Method . PUT : builder . put ( createRequestBody ( request ) ) ; break ; case Request . Method . HEAD : builder . head ( ) ; break ; case Request . Method . OPTIONS : builder . method ( "<STR_LIT>" , null ) ; break ; case Request . Method . TRACE : builder . method ( "<STR_LIT>" , null ) ; break ; case Request . Method . PATCH : builder . patch ( createRequestBody ( request ) ) ; break ; default : throw new IllegalStateException ( "<STR_LIT>" ) ; } } private static RequestBody createRequestBody ( Request < ? > r ) throws AuthFailureError { final byte [ ] body = r . getBody ( ) ; if ( body == null ) { return EMPTY_REQUEST ; } return RequestBody . create ( body , MediaType . parse ( r . getBodyContentType ( ) ) ) ; } @ Override public HttpResponse executeRequest ( Request < ? > request , Map < String , String > additionalHeaders ) throws IOException , AuthFailureError { OkHttpClient . Builder clientBuilder = NetworkComponent . getOkHttpClientInstance ( ) . newBuilder ( ) ; int timeoutMs = request . getTimeoutMs ( ) ; clientBuilder . connectTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; clientBuilder . readTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; clientBuilder . writeTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; okhttp3 . Request . Builder okHttpRequestBuilder = new okhttp3 . Request . Builder ( ) ; okHttpRequestBuilder . url ( request . getUrl ( ) ) ; Map < String , String > headers = request . getHeaders ( ) ; for ( Map . Entry < String , String > header : headers . entrySet ( ) ) { okHttpRequestBuilder . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } for ( Map . Entry < String , String > header : additionalHeaders . entrySet ( ) ) { okHttpRequestBuilder . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } setConnectionParametersForRequest ( okHttpRequestBuilder , request ) ; OkHttpClient client = clientBuilder . build ( ) ; okhttp3 . Request okHttpRequest = okHttpRequestBuilder . build ( ) ; Call okHttpCall = client . newCall ( okHttpRequest ) ; Response okHttpResponse = okHttpCall . execute ( ) ; int code = okHttpResponse . code ( ) ; ResponseBody body = okHttpResponse . body ( ) ; InputStream content = body == null ? null : body . byteStream ( ) ; int contentLength = body == null ? <NUM_LIT> : ( int ) body . contentLength ( ) ; List < Header > responseHeaders = mapHeaders ( okHttpResponse . headers ( ) ) ; return new HttpResponse ( code , responseHeaders , contentLength , content ) ; } private List < Header > mapHeaders ( Headers responseHeaders ) { List < Header > headers = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> , len = responseHeaders . size ( ) ; i < len ; i ++ ) { final String name = responseHeaders . name ( i ) , value = responseHeaders . value ( i ) ; headers . add ( new Header ( name , value ) ) ; } return headers ; } } </s>
<s> package com . simon . harmonichackernews ; import android . app . Dialog ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . simon . harmonichackernews . adapters . CommentSearchAdapter ; import com . simon . harmonichackernews . data . Comment ; import java . io . Serializable ; import java . util . List ; public class CommentsSearchDialogFragment extends AppCompatDialogFragment { public static String TAG = "<STR_LIT>" ; public final static String EXTRA_SEARCHABLE_COMMENTS = "<STR_LIT>" ; private TextInputEditText searchBar ; private RecyclerView recyclerView ; private TextView matchesText ; private CommentSearchAdapter adapter ; private List < Comment > comments ; private final CommentSelectedListener listener ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( getArguments ( ) != null ) { comments = ( List < Comment > ) getArguments ( ) . getSerializable ( EXTRA_SEARCHABLE_COMMENTS ) ; } } public CommentsSearchDialogFragment ( CommentSelectedListener commentSelectedListener ) { this . listener = commentSelectedListener ; } @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . comments_search_dialog , null ) ; searchBar = rootView . findViewById ( R . id . comments_search_edittext ) ; recyclerView = rootView . findViewById ( R . id . comments_search_recyclerview ) ; matchesText = rootView . findViewById ( R . id . comments_search_matches ) ; if ( getArguments ( ) != null ) { comments = ( List < Comment > ) getArguments ( ) . getSerializable ( EXTRA_SEARCHABLE_COMMENTS ) ; comments = comments . subList ( <NUM_LIT> , comments . size ( ) ) ; } updateMatches ( null ) ; adapter = new CommentSearchAdapter ( comments ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( getContext ( ) ) ) ; searchBar . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void afterTextChanged ( Editable editable ) { String searchTerm = editable . toString ( ) ; adapter . setSearchTerm ( searchTerm ) ; adapter . notifyDataSetChanged ( ) ; updateMatches ( searchTerm ) ; } } ) ; builder . setView ( rootView ) ; final AlertDialog dialog = builder . create ( ) ; adapter . setItemClickListener ( new CommentSearchAdapter . ItemClickListener ( ) { @ Override public void onItemClick ( Comment comment ) { if ( listener != null ) { listener . onCommentSelected ( comment ) ; } dialog . cancel ( ) ; } } ) ; return dialog ; } private void updateMatches ( String searchTerm ) { int matchingComments = <NUM_LIT> ; if ( TextUtils . isEmpty ( searchTerm ) ) { matchingComments = comments . size ( ) ; } else { for ( Comment c : comments ) { if ( c . text . toUpperCase ( ) . contains ( searchTerm . toUpperCase ( ) ) ) { matchingComments ++ ; } } } matchesText . setText ( "<STR_LIT>" + matchingComments + ( matchingComments == <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" ) + "<STR_LIT>" ) ; } public static void showCommentSearchDialog ( FragmentManager fm , List < Comment > comments , CommentSelectedListener listener ) { CommentsSearchDialogFragment dialogFragment = new CommentsSearchDialogFragment ( listener ) ; Bundle bundle = new Bundle ( ) ; bundle . putSerializable ( EXTRA_SEARCHABLE_COMMENTS , ( Serializable ) comments ) ; dialogFragment . setArguments ( bundle ) ; dialogFragment . show ( fm , CommentsSearchDialogFragment . TAG ) ; } public interface CommentSelectedListener { void onCommentSelected ( Comment comment ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import android . text . Html ; import android . text . Layout ; import android . text . Spannable ; import android . text . Spanned ; import android . text . style . AlignmentSpan ; import android . text . style . BulletSpan ; import android . text . style . LeadingMarginSpan ; import android . text . style . StrikethroughSpan ; import android . text . style . TypefaceSpan ; import android . text . style . URLSpan ; import android . util . Log ; import android . view . View ; import androidx . annotation . Nullable ; import java . util . Stack ; import org . xml . sax . Attributes ; public class HtmlTagHandler implements WrapperTagHandler { public static final String UNORDERED_LIST = "<STR_LIT>" ; public static final String ORDERED_LIST = "<STR_LIT>" ; public static final String LIST_ITEM = "<STR_LIT>" ; public static final String A_ITEM = "<STR_LIT>" ; public static final String PLACEHOLDER_ITEM = "<STR_LIT>" ; public HtmlTagHandler ( ) { } String overrideTags ( @ Nullable String html ) { if ( html == null ) return null ; html = "<STR_LIT>" + PLACEHOLDER_ITEM + "<STR_LIT>" + PLACEHOLDER_ITEM + "<STR_LIT>" + html ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + UNORDERED_LIST ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + UNORDERED_LIST + "<STR_LIT>" ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + ORDERED_LIST ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + ORDERED_LIST + "<STR_LIT>" ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + LIST_ITEM ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + LIST_ITEM + "<STR_LIT>" ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + A_ITEM ) ; html = html . replace ( "<STR_LIT>" , "<STR_LIT>" + A_ITEM + "<STR_LIT>" ) ; return html ; } Stack < String > lists = new Stack < > ( ) ; Stack < Integer > olNextIndex = new Stack < > ( ) ; StringBuilder tableHtmlBuilder = new StringBuilder ( ) ; int tableTagLevel = <NUM_LIT> ; private static int userGivenIndent = - <NUM_LIT> ; private static final int defaultIndent = <NUM_LIT> ; private static final int defaultListItemIndent = defaultIndent * <NUM_LIT> ; private static final BulletSpan defaultBullet = new BulletSpan ( defaultIndent ) ; private ClickableTableSpan clickableTableSpan ; private DrawTableLinkSpan drawTableLinkSpan ; private HtmlFormatter . TagClickListenerProvider onClickATagListenerProvider ; private static class Ul { } private static class Ol { } private static class A { private String text ; private String href ; private A ( String text , String href ) { this . text = text ; this . href = href ; } } private static class Code { } private static class Center { } private static class Strike { } private static class Table { } private static class Tr { } private static class Th { } private static class Td { } @ Override public boolean handleTag ( boolean opening , String tag , Editable output , Attributes attributes ) { if ( opening ) { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , "<STR_LIT>" + output . toString ( ) ) ; } if ( tag . equalsIgnoreCase ( UNORDERED_LIST ) ) { lists . push ( tag ) ; } else if ( tag . equalsIgnoreCase ( ORDERED_LIST ) ) { lists . push ( tag ) ; olNextIndex . push ( <NUM_LIT> ) ; } else if ( tag . equalsIgnoreCase ( LIST_ITEM ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( "<STR_LIT>" ) ; } if ( ! lists . isEmpty ( ) ) { String parentList = lists . peek ( ) ; if ( parentList . equalsIgnoreCase ( ORDERED_LIST ) ) { start ( output , new Ol ( ) ) ; olNextIndex . push ( olNextIndex . pop ( ) + <NUM_LIT> ) ; } else if ( parentList . equalsIgnoreCase ( UNORDERED_LIST ) ) { start ( output , new Ul ( ) ) ; } } } else if ( tag . equalsIgnoreCase ( A_ITEM ) ) { final String href = attributes != null ? attributes . getValue ( "<STR_LIT>" ) : null ; start ( output , new A ( output . toString ( ) , href ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Code ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Center ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) || tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Strike ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Table ( ) ) ; if ( tableTagLevel == <NUM_LIT> ) { tableHtmlBuilder = new StringBuilder ( ) ; output . append ( "<STR_LIT>" ) ; } tableTagLevel ++ ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Tr ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Th ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { start ( output , new Td ( ) ) ; } else { return false ; } } else { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , "<STR_LIT>" + output . toString ( ) ) ; } if ( tag . equalsIgnoreCase ( UNORDERED_LIST ) ) { lists . pop ( ) ; } else if ( tag . equalsIgnoreCase ( ORDERED_LIST ) ) { lists . pop ( ) ; olNextIndex . pop ( ) ; } else if ( tag . equalsIgnoreCase ( LIST_ITEM ) ) { if ( ! lists . isEmpty ( ) ) { int listItemIndent = ( userGivenIndent > - <NUM_LIT> ) ? ( userGivenIndent * <NUM_LIT> ) : defaultListItemIndent ; if ( lists . peek ( ) . equalsIgnoreCase ( UNORDERED_LIST ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( "<STR_LIT>" ) ; } int indent = ( userGivenIndent > - <NUM_LIT> ) ? userGivenIndent : defaultIndent ; BulletSpan bullet = ( userGivenIndent > - <NUM_LIT> ) ? new BulletSpan ( userGivenIndent ) : defaultBullet ; if ( lists . size ( ) > <NUM_LIT> ) { indent = indent - bullet . getLeadingMargin ( true ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent -= ( lists . size ( ) - <NUM_LIT> ) * listItemIndent ; } } BulletSpan newBullet = new BulletSpan ( indent ) ; end ( output , Ul . class , false , new LeadingMarginSpan . Standard ( listItemIndent * ( lists . size ( ) - <NUM_LIT> ) ) , newBullet ) ; } else if ( lists . peek ( ) . equalsIgnoreCase ( ORDERED_LIST ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( "<STR_LIT>" ) ; } int indent = ( userGivenIndent > - <NUM_LIT> ) ? userGivenIndent : defaultIndent ; NumberSpan span = new NumberSpan ( indent , olNextIndex . lastElement ( ) - <NUM_LIT> ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent = indent - span . getLeadingMargin ( true ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent -= ( lists . size ( ) - <NUM_LIT> ) * listItemIndent ; } } NumberSpan numberSpan = new NumberSpan ( indent , olNextIndex . lastElement ( ) - <NUM_LIT> ) ; end ( output , Ol . class , false , new LeadingMarginSpan . Standard ( listItemIndent * ( lists . size ( ) - <NUM_LIT> ) ) , numberSpan ) ; } } } else if ( tag . equalsIgnoreCase ( A_ITEM ) ) { final Object a = getLast ( output , A . class ) ; final int spanStart = output . getSpanStart ( a ) ; final int spanEnd = output . length ( ) ; final String href = a instanceof A ? ( ( A ) a ) . href : null ; final String spannedText = output . subSequence ( spanStart , spanEnd ) . toString ( ) ; end ( output , A . class , false , new URLSpan ( href ) { @ Override public void onClick ( View widget ) { if ( onClickATagListenerProvider != null && widget != null ) { OnClickATagListener tagClickListener = onClickATagListenerProvider . provideTagClickListener ( ) ; if ( tagClickListener != null ) { boolean clickConsumed = tagClickListener . onClick ( widget , spannedText , getURL ( ) ) ; if ( ! clickConsumed ) { super . onClick ( widget ) ; } } } } } ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Code . class , false , new TypefaceSpan ( "<STR_LIT>" ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Center . class , true , new AlignmentSpan . Standard ( Layout . Alignment . ALIGN_CENTER ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) || tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Strike . class , false , new StrikethroughSpan ( ) ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { tableTagLevel -- ; if ( tableTagLevel == <NUM_LIT> ) { final String tableHtml = tableHtmlBuilder . toString ( ) ; ClickableTableSpan myClickableTableSpan = null ; if ( clickableTableSpan != null ) { myClickableTableSpan = clickableTableSpan . newInstance ( ) ; myClickableTableSpan . setTableHtml ( tableHtml ) ; } DrawTableLinkSpan myDrawTableLinkSpan = null ; if ( drawTableLinkSpan != null ) { myDrawTableLinkSpan = drawTableLinkSpan . newInstance ( ) ; } end ( output , Table . class , false , myDrawTableLinkSpan , myClickableTableSpan ) ; } else { end ( output , Table . class , false ) ; } } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Tr . class , false ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Th . class , false ) ; } else if ( tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { end ( output , Td . class , false ) ; } else { return false ; } } storeTableTags ( opening , tag ) ; return true ; } private void storeTableTags ( boolean opening , String tag ) { if ( tableTagLevel > <NUM_LIT> || tag . equalsIgnoreCase ( "<STR_LIT>" ) ) { tableHtmlBuilder . append ( "<STR_LIT>" ) ; if ( ! opening ) { tableHtmlBuilder . append ( "<STR_LIT>" ) ; } tableHtmlBuilder . append ( tag . toLowerCase ( ) ) . append ( "<STR_LIT>" ) ; } } private void start ( Editable output , Object mark ) { int len = output . length ( ) ; output . setSpan ( mark , len , len , Spannable . SPAN_MARK_MARK ) ; if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , "<STR_LIT>" + len ) ; } } private void end ( Editable output , Class kind , boolean paragraphStyle , Object ... replaces ) { Object obj = getLast ( output , kind ) ; int where = output . getSpanStart ( obj ) ; int len = output . length ( ) ; if ( tableTagLevel > <NUM_LIT> ) { final CharSequence extractedSpanText = extractSpanText ( output , kind ) ; tableHtmlBuilder . append ( extractedSpanText ) ; } output . removeSpan ( obj ) ; if ( where != len ) { int thisLen = len ; if ( paragraphStyle ) { output . append ( "<STR_LIT>" ) ; thisLen ++ ; } for ( Object replace : replaces ) { output . setSpan ( replace , where , thisLen , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , "<STR_LIT>" + where ) ; Log . d ( HtmlTextView . TAG , "<STR_LIT>" + thisLen ) ; } } } private CharSequence extractSpanText ( Editable output , Class kind ) { final Object obj = getLast ( output , kind ) ; final int where = output . getSpanStart ( obj ) ; final int len = output . length ( ) ; final CharSequence extractedSpanText = output . subSequence ( where , len ) ; output . delete ( where , len ) ; return extractedSpanText ; } private static Object getLast ( Editable text , Class kind ) { Object [ ] objs = text . getSpans ( <NUM_LIT> , text . length ( ) , kind ) ; if ( objs . length == <NUM_LIT> ) { return null ; } else { for ( int i = objs . length ; i > <NUM_LIT> ; i -- ) { if ( text . getSpanFlags ( objs [ i - <NUM_LIT> ] ) == Spannable . SPAN_MARK_MARK ) { return objs [ i - <NUM_LIT> ] ; } } return null ; } } public void setListIndentPx ( float px ) { userGivenIndent = Math . round ( px ) ; } public void setClickableTableSpan ( ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; } public void setDrawTableLinkSpan ( DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; } public void setOnClickATagListenerProvider ( HtmlFormatter . TagClickListenerProvider onClickATagListenerProvider ) { this . onClickATagListenerProvider = onClickATagListenerProvider ; } } </s>
<s> package com . simon . harmonichackernews . adapters ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . GradientDrawable ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . style . ImageSpan ; import android . util . TypedValue ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . inputmethod . EditorInfo ; import android . view . inputmethod . InputMethodManager ; import android . widget . AdapterView ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . Spinner ; import android . widget . TextView ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . TooltipCompat ; import androidx . core . content . ContextCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . FaviconLoader ; import com . simon . harmonichackernews . utils . FontUtils ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . jetbrains . annotations . NotNull ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class StoryRecyclerViewAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { private final List < Story > stories ; private ClickListener typeClickListener ; private ClickListener linkClickListener ; private ClickListener commentClickListener ; private ClickListener commentRepliesClickListener ; private ClickListener commentStoryClickListener ; private SearchListener storiesSearchListener ; private RefreshListener refreshListener ; private View . OnClickListener moreClickListener ; private LongClickCoordinateListener longClickListener ; private final boolean atSubmissions ; private final String submitter ; private static final int TYPE_HEADER_MAIN = <NUM_LIT> ; private static final int TYPE_HEADER_SUBMISSIONS = <NUM_LIT> ; private static final int TYPE_STORY = <NUM_LIT> ; private static final int TYPE_COMMENT = <NUM_LIT> ; public boolean loadingFailed = false ; public boolean loadingFailedServerError = false ; public boolean showPoints ; public boolean showCommentsCount ; public boolean compactView ; public boolean thumbnails ; public boolean showIndex ; public boolean compactHeader ; public boolean leftAlign ; public String faviconProvider ; public int hotness ; public int type ; public boolean searching = false ; public String lastSearch = "<STR_LIT>" ; public StoryRecyclerViewAdapter ( List < Story > items , boolean shouldShowPoints , boolean shouldShowCommentsCount , boolean shouldUseCompactView , boolean shouldShowThumbnails , boolean shouldShowIndex , boolean shouldUseCompactHeader , boolean shouldLeftAlign , int preferredHotness , String faviconProv , String submissionsUserName , int wantedType ) { stories = items ; showPoints = shouldShowPoints ; showCommentsCount = shouldShowCommentsCount ; compactView = shouldUseCompactView ; thumbnails = shouldShowThumbnails ; showIndex = shouldShowIndex ; compactHeader = shouldUseCompactHeader ; leftAlign = shouldLeftAlign ; hotness = preferredHotness ; faviconProvider = faviconProv ; type = wantedType ; atSubmissions = ! TextUtils . isEmpty ( submissionsUserName ) ; submitter = submissionsUserName ; } @ NotNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NotNull ViewGroup parent , int viewType ) { if ( viewType == TYPE_STORY ) { return new StoryViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( leftAlign ? R . layout . story_list_item_left : R . layout . story_list_item , parent , false ) ) ; } else if ( viewType == TYPE_HEADER_MAIN ) { return new MainHeaderViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . stories_header , parent , false ) ) ; } else if ( viewType == TYPE_HEADER_SUBMISSIONS ) { return new SubmissionsHeaderViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . submissions_header , parent , false ) ) ; } else { return new CommentViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . submissions_comment , parent , false ) ) ; } } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onBindViewHolder ( @ NotNull final RecyclerView . ViewHolder holder , int position ) { if ( holder instanceof StoryViewHolder ) { final StoryViewHolder storyViewHolder = ( StoryViewHolder ) holder ; final Context ctx = storyViewHolder . itemView . getContext ( ) ; storyViewHolder . story = stories . get ( position ) ; if ( showIndex ) { storyViewHolder . indexTextView . setText ( position + "<STR_LIT>" ) ; if ( storyViewHolder . story . clicked ) { storyViewHolder . indexTextView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorDisabled ) ) ; } else { storyViewHolder . indexTextView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorNormal ) ) ; } if ( position < <NUM_LIT> ) { storyViewHolder . indexTextView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; storyViewHolder . indexTextView . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; } else { storyViewHolder . indexTextView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; storyViewHolder . indexTextView . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; } } storyViewHolder . indexTextView . setVisibility ( showIndex ? View . VISIBLE : View . GONE ) ; if ( storyViewHolder . story . loaded || storyViewHolder . story . loadingFailed ) { if ( ! TextUtils . isEmpty ( storyViewHolder . story . pdfTitle ) ) { SpannableStringBuilder sb = new SpannableStringBuilder ( storyViewHolder . story . pdfTitle + "<STR_LIT>" ) ; ImageSpan imageSpan = new ImageSpan ( ctx , storyViewHolder . story . clicked ? R . drawable . ic_action_pdf_clicked : R . drawable . ic_action_pdf ) ; sb . setSpan ( imageSpan , sb . length ( ) - <NUM_LIT> , sb . length ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; storyViewHolder . titleView . setText ( sb ) ; } else { storyViewHolder . titleView . setText ( storyViewHolder . story . title ) ; } final String commentCountText ; if ( showCommentsCount ) { commentCountText = Integer . toString ( storyViewHolder . story . descendants ) ; } else if ( storyViewHolder . story . descendants > <NUM_LIT> ) { commentCountText = "<STR_LIT>" ; } else { commentCountText = "<STR_LIT>" ; } storyViewHolder . commentsView . setText ( commentCountText ) ; String host = "<STR_LIT>" ; try { if ( storyViewHolder . story . url != null ) { host = Utils . getDomainName ( storyViewHolder . story . url ) ; } } catch ( Exception e ) { host = "<STR_LIT>" ; } if ( showPoints && ! storyViewHolder . story . isComment ) { String ptsString = storyViewHolder . story . score == <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" ; storyViewHolder . metaView . setText ( storyViewHolder . story . score + ptsString + "<STR_LIT>" + host + "<STR_LIT>" + storyViewHolder . story . getTimeFormatted ( ) ) ; } else { storyViewHolder . metaView . setText ( host + "<STR_LIT>" + storyViewHolder . story . getTimeFormatted ( ) ) ; } if ( thumbnails ) { FaviconLoader . loadFavicon ( storyViewHolder . story . url , storyViewHolder . metaFavicon , ctx , faviconProvider ) ; } storyViewHolder . commentsIcon . setImageResource ( hotness > <NUM_LIT> && storyViewHolder . story . score + storyViewHolder . story . descendants > hotness ? R . drawable . ic_action_whatshot : R . drawable . ic_action_comment ) ; FontUtils . setTypeface ( storyViewHolder . titleView , true , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; FontUtils . setTypeface ( storyViewHolder . metaView , false , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; FontUtils . setTypeface ( storyViewHolder . commentsView , true , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; if ( storyViewHolder . story . clicked && type != SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) { storyViewHolder . titleView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorDisabled ) ) ; storyViewHolder . commentsIcon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . metaFavicon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . commentsView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDisabled ) ) ; storyViewHolder . metaView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDisabled ) ) ; } else { storyViewHolder . titleView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorNormal ) ) ; storyViewHolder . commentsIcon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . metaFavicon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . commentsView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDefault ) ) ; storyViewHolder . metaView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDefault ) ) ; } storyViewHolder . titleShimmer . setVisibility ( View . GONE ) ; storyViewHolder . metaShimmer . setVisibility ( View . GONE ) ; storyViewHolder . titleView . setVisibility ( View . VISIBLE ) ; storyViewHolder . metaContainer . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . commentsView . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . metaFavicon . setVisibility ( thumbnails ? View . VISIBLE : View . GONE ) ; if ( storyViewHolder . story . loadingFailed ) { storyViewHolder . titleView . setText ( "<STR_LIT>" ) ; storyViewHolder . metaContainer . setVisibility ( View . GONE ) ; storyViewHolder . commentsView . setVisibility ( View . GONE ) ; } storyViewHolder . linkLayoutView . setClickable ( true ) ; storyViewHolder . commentLayoutView . setClickable ( ! storyViewHolder . story . loadingFailed ) ; } else { storyViewHolder . commentsIcon . setImageResource ( R . drawable . ic_action_comment ) ; storyViewHolder . titleShimmer . setVisibility ( View . VISIBLE ) ; storyViewHolder . metaShimmer . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . titleView . setVisibility ( View . GONE ) ; storyViewHolder . metaContainer . setVisibility ( View . GONE ) ; storyViewHolder . commentsView . setText ( null ) ; storyViewHolder . linkLayoutView . setClickable ( false ) ; storyViewHolder . commentLayoutView . setClickable ( false ) ; storyViewHolder . commentsIcon . setAlpha ( storyViewHolder . story . clicked ? <NUM_LIT> : <NUM_LIT> ) ; } } else if ( holder instanceof MainHeaderViewHolder ) { final MainHeaderViewHolder headerViewHolder = ( MainHeaderViewHolder ) holder ; final Context ctx = headerViewHolder . itemView . getContext ( ) ; if ( compactHeader ) { headerViewHolder . container . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ) ; } else { headerViewHolder . container . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ) ; } headerViewHolder . moreButton . setVisibility ( searching ? View . GONE : View . VISIBLE ) ; headerViewHolder . spinnerContainer . setVisibility ( searching ? View . GONE : View . VISIBLE ) ; headerViewHolder . searchButton . setImageResource ( searching ? R . drawable . ic_action_cancel : R . drawable . ic_action_search ) ; headerViewHolder . searchEditText . setVisibility ( searching ? View . VISIBLE : View . GONE ) ; headerViewHolder . searchEditText . setText ( stories . get ( <NUM_LIT> ) . title ) ; if ( searching ) { headerViewHolder . loadingIndicator . setVisibility ( View . GONE ) ; headerViewHolder . searchEditText . requestFocus ( ) ; headerViewHolder . searchEditText . setText ( lastSearch ) ; headerViewHolder . searchEditText . setSelection ( lastSearch . length ( ) ) ; headerViewHolder . searchEmptyContainer . setVisibility ( stories . size ( ) == <NUM_LIT> ? View . VISIBLE : View . GONE ) ; headerViewHolder . noBookmarksLayout . setVisibility ( View . GONE ) ; } else { headerViewHolder . noBookmarksLayout . setVisibility ( ( stories . size ( ) == <NUM_LIT> && type == SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) ? View . VISIBLE : View . GONE ) ; headerViewHolder . searchEmptyContainer . setVisibility ( View . GONE ) ; headerViewHolder . loadingIndicator . setVisibility ( stories . size ( ) == <NUM_LIT> && ! loadingFailed && ! loadingFailedServerError && ( type != SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) ? View . VISIBLE : View . GONE ) ; } headerViewHolder . typeSpinner . setSelection ( type ) ; TooltipCompat . setTooltipText ( headerViewHolder . searchButton , searching ? "<STR_LIT>" : "<STR_LIT>" ) ; TooltipCompat . setTooltipText ( headerViewHolder . moreButton , "<STR_LIT>" ) ; headerViewHolder . loadingFailedLayout . setVisibility ( loadingFailed ? View . VISIBLE : View . GONE ) ; headerViewHolder . loadingFailedAlgoliaLayout . setVisibility ( loadingFailedServerError ? View . VISIBLE : View . GONE ) ; } else if ( holder instanceof SubmissionsHeaderViewHolder ) { final SubmissionsHeaderViewHolder submissionsHeaderViewHolder = ( SubmissionsHeaderViewHolder ) holder ; submissionsHeaderViewHolder . headerText . setText ( submitter + "<STR_LIT>" ) ; } else if ( holder instanceof CommentViewHolder ) { final CommentViewHolder commentViewHolder = ( CommentViewHolder ) holder ; Story story = stories . get ( position ) ; commentViewHolder . headerText . setText ( "<STR_LIT>" + story . commentMasterTitle + "<STR_LIT>" + Utils . getTimeAgo ( story . time ) ) ; commentViewHolder . bodyText . setHtml ( story . text ) ; commentViewHolder . bodyText . post ( new Runnable ( ) { @ Override public void run ( ) { commentViewHolder . scrim . setVisibility ( ViewUtils . isTextTruncated ( commentViewHolder . bodyText ) ? View . VISIBLE : View . GONE ) ; } } ) ; } } @ Override public int getItemViewType ( int position ) { if ( position == <NUM_LIT> ) { return atSubmissions ? TYPE_HEADER_SUBMISSIONS : TYPE_HEADER_MAIN ; } else { if ( atSubmissions ) { return stories . get ( position ) . isComment ? TYPE_COMMENT : TYPE_STORY ; } else { return TYPE_STORY ; } } } @ Override public int getItemCount ( ) { return stories . size ( ) ; } public class StoryViewHolder extends RecyclerView . ViewHolder { public final View mView ; public final TextView titleView ; public final TextView metaView ; public final TextView commentsView ; public final LinearLayout linkLayoutView ; public final LinearLayout commentLayoutView ; public final ImageView commentsIcon ; public final LinearLayout titleShimmer ; public final View metaShimmer ; public final LinearLayout metaContainer ; public final ImageView metaFavicon ; public final TextView indexTextView ; private int touchX , touchY ; public Story story ; @ SuppressLint ( "<STR_LIT>" ) public StoryViewHolder ( View view ) { super ( view ) ; mView = view ; titleView = view . findViewById ( R . id . story_title ) ; metaView = view . findViewById ( R . id . story_meta ) ; metaContainer = view . findViewById ( R . id . story_meta_container ) ; commentsView = view . findViewById ( R . id . story_comments ) ; linkLayoutView = view . findViewById ( R . id . story_link_layout ) ; commentLayoutView = view . findViewById ( R . id . story_comment_layout ) ; commentsIcon = view . findViewById ( R . id . story_comments_icon ) ; titleShimmer = view . findViewById ( R . id . story_title_shimmer ) ; metaShimmer = view . findViewById ( R . id . story_title_shimmer_meta ) ; metaFavicon = view . findViewById ( R . id . story_meta_favicon ) ; indexTextView = view . findViewById ( R . id . story_index ) ; linkLayoutView . setOnClickListener ( v -> linkClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ) ; commentLayoutView . setOnClickListener ( v -> commentClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ) ; if ( longClickListener != null ) { linkLayoutView . setOnTouchListener ( new View . OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { touchX = ( int ) event . getX ( ) ; touchY = ( int ) event . getY ( ) ; return false ; } } ) ; linkLayoutView . setOnLongClickListener ( v -> longClickListener . onLongClick ( v , getAbsoluteAdapterPosition ( ) , touchX , touchY ) ) ; } } } public class MainHeaderViewHolder extends RecyclerView . ViewHolder { public final Spinner typeSpinner ; public final LinearLayout container ; public final LinearLayout loadingFailedLayout ; public final TextView loadingFailedAlgoliaLayout ; public final LinearLayout noBookmarksLayout ; public final LinearLayout spinnerContainer ; public final LinearLayout searchEmptyContainer ; public final RelativeLayout loadingIndicator ; public final EditText searchEditText ; public final ImageButton moreButton ; public final ImageButton searchButton ; public final Button retryButton ; public ArrayAdapter < CharSequence > typeAdapter ; public MainHeaderViewHolder ( View view ) { super ( view ) ; final Context ctx = view . getContext ( ) ; loadingFailedLayout = view . findViewById ( R . id . stories_header_loading_failed ) ; loadingFailedAlgoliaLayout = view . findViewById ( R . id . stories_header_loading_failed_algolia ) ; container = view . findViewById ( R . id . stories_header_container ) ; typeSpinner = view . findViewById ( R . id . stories_header_spinner ) ; noBookmarksLayout = view . findViewById ( R . id . stories_header_no_bookmarks ) ; searchEditText = view . findViewById ( R . id . stories_header_search_edittext ) ; moreButton = view . findViewById ( R . id . stories_header_more ) ; spinnerContainer = view . findViewById ( R . id . stories_header_spinner_container ) ; searchButton = view . findViewById ( R . id . stories_header_search_button ) ; searchEmptyContainer = view . findViewById ( R . id . stories_header_search_empty_container ) ; retryButton = view . findViewById ( R . id . stories_header_retry_button ) ; loadingIndicator = view . findViewById ( R . id . stories_header_loading_indicator ) ; retryButton . setOnClickListener ( ( v ) -> refreshListener . onRefresh ( ) ) ; moreButton . setOnClickListener ( moreClickListener ) ; searchEditText . setOnEditorActionListener ( new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView textView , int actionId , KeyEvent keyEvent ) { if ( actionId != EditorInfo . IME_ACTION_SEARCH ) { return false ; } doSearch ( ) ; if ( textView != null ) { InputMethodManager imm = ( InputMethodManager ) ctx . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; } return true ; } } ) ; searchButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { searching = ! searching ; storiesSearchListener . onSearchStatusChanged ( ) ; InputMethodManager imm = ( InputMethodManager ) ctx . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; if ( searching ) { imm . toggleSoftInput ( InputMethodManager . SHOW_IMPLICIT , <NUM_LIT> ) ; } else { imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; lastSearch = "<STR_LIT>" ; } } } ) ; String [ ] sortingOptions = ctx . getResources ( ) . getStringArray ( R . array . sorting_options ) ; ArrayList < CharSequence > typeAdapterList = new ArrayList < > ( Arrays . asList ( sortingOptions ) ) ; typeAdapter = new ArrayAdapter < > ( ctx , R . layout . spinner_top_layout , R . id . selection_dropdown_item_textview , typeAdapterList ) ; typeAdapter . setDropDownViewResource ( R . layout . spinner_item_layout ) ; typeSpinner . setAdapter ( typeAdapter ) ; typeSpinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { if ( i != type ) { typeClickListener . onItemClick ( i ) ; } } @ Override public void onNothingSelected ( AdapterView < ? > adapterView ) { } } ) ; } private void doSearch ( ) { storiesSearchListener . onQueryTextSubmit ( searchEditText . getText ( ) . toString ( ) ) ; } } public static class SubmissionsHeaderViewHolder extends RecyclerView . ViewHolder { public final TextView headerText ; public SubmissionsHeaderViewHolder ( View view ) { super ( view ) ; headerText = view . findViewById ( R . id . submissions_header_text ) ; } } public class CommentViewHolder extends RecyclerView . ViewHolder { public final TextView headerText ; public final HtmlTextView bodyText ; public final Button storyButton ; public final Button repliesButton ; public final View scrim ; public CommentViewHolder ( View view ) { super ( view ) ; headerText = view . findViewById ( R . id . submissions_comment_header ) ; bodyText = view . findViewById ( R . id . submissions_comment_body ) ; storyButton = view . findViewById ( R . id . submissions_comment_button_story ) ; repliesButton = view . findViewById ( R . id . submissions_comment_button_replies ) ; scrim = view . findViewById ( R . id . submissions_comment_scrim ) ; Context ctx = view . getContext ( ) ; GradientDrawable gradientDrawable = new GradientDrawable ( GradientDrawable . Orientation . TOP_BOTTOM , new int [ ] { Color . TRANSPARENT , ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) } ) ; scrim . setBackground ( gradientDrawable ) ; bodyText . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . launchCustomTab ( widget . getContext ( ) , href ) ; return true ; } } ) ; storyButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { int pos = getAbsoluteAdapterPosition ( ) ; if ( pos != RecyclerView . NO_POSITION ) { commentStoryClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ; } } } ) ; repliesButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { int pos = getAbsoluteAdapterPosition ( ) ; if ( pos != RecyclerView . NO_POSITION ) { commentRepliesClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ; } } } ) ; } } public void setOnTypeClickListener ( ClickListener clickListener ) { typeClickListener = clickListener ; } public void setOnLinkClickListener ( ClickListener clickListener ) { linkClickListener = clickListener ; } public void setOnCommentClickListener ( ClickListener clickListener ) { commentClickListener = clickListener ; } public void setOnCommentStoryClickListener ( ClickListener clickListener ) { commentStoryClickListener = clickListener ; } public void setOnCommentRepliesClickListener ( ClickListener clickListener ) { commentRepliesClickListener = clickListener ; } public void setOnLongClickListener ( LongClickCoordinateListener clickListener ) { longClickListener = clickListener ; } public void setOnRefreshListener ( RefreshListener listener ) { refreshListener = listener ; } public void setOnMoreClickListener ( View . OnClickListener listener ) { moreClickListener = listener ; } public interface ClickListener { void onItemClick ( int position ) ; } public void setSearchListener ( SearchListener searchListener ) { storiesSearchListener = searchListener ; } public interface SearchListener { void onQueryTextSubmit ( String query ) ; void onSearchStatusChanged ( ) ; } public interface RefreshListener { void onRefresh ( ) ; } public interface LongClickCoordinateListener { boolean onLongClick ( View v , int position , int x , int y ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . R ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; public class DialogUtils { public static void showTextSelectionDialog ( Context ctx , String text ) { MaterialAlertDialogBuilder selectTextDialogBuilder = new MaterialAlertDialogBuilder ( ctx ) ; View rootView = LayoutInflater . from ( ctx ) . inflate ( R . layout . select_text_dialog , null ) ; selectTextDialogBuilder . setView ( rootView ) ; HtmlTextView htmlTextView = rootView . findViewById ( R . id . select_text_htmltextview ) ; htmlTextView . setHtml ( text ) ; htmlTextView . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( ctx , href ) ; return true ; } } ) ; final AlertDialog selectTextDialog = selectTextDialogBuilder . create ( ) ; selectTextDialog . show ( ) ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . os . Parcel ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import android . text . Layout ; import android . text . Spanned ; import android . text . style . BulletSpan ; public class NumberSpan extends BulletSpan { private final int mNumberGapWidth ; private final String mNumber ; public static final int STANDARD_GAP_WIDTH = <NUM_LIT> ; public NumberSpan ( int gapWidth , int number ) { super ( ) ; mNumberGapWidth = gapWidth ; mNumber = Integer . toString ( number ) . concat ( "<STR_LIT>" ) ; } public NumberSpan ( int number ) { this ( STANDARD_GAP_WIDTH , number ) ; } public NumberSpan ( Parcel src ) { super ( src ) ; mNumberGapWidth = src . readInt ( ) ; mNumber = src . readString ( ) ; } public void writeToParcel ( @ NonNull Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeInt ( mNumberGapWidth ) ; dest . writeString ( mNumber ) ; } public int getLeadingMargin ( boolean first ) { return <NUM_LIT> * STANDARD_GAP_WIDTH + mNumberGapWidth ; } @ Override public void drawLeadingMargin ( @ NonNull Canvas c , @ NonNull Paint p , int x , int dir , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , boolean first , @ Nullable Layout l ) { if ( ( ( Spanned ) text ) . getSpanStart ( this ) == start ) { Paint . Style style = p . getStyle ( ) ; p . setStyle ( Paint . Style . FILL ) ; if ( c . isHardwareAccelerated ( ) ) { c . save ( ) ; c . drawText ( mNumber , x + dir , baseline , p ) ; c . restore ( ) ; } else { c . drawText ( mNumber , x + dir , ( top + bottom ) / <NUM_LIT> , p ) ; } p . setStyle ( style ) ; } } } </s>
<s> package com . simon . harmonichackernews . data ; public class WikipediaInfo { public String summary ; } </s>
<s> package com . simon . harmonichackernews ; import android . animation . AnimatorListenerAdapter ; import android . animation . AnimatorSet ; import android . animation . ObjectAnimator ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . PathInterpolator ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . PopupMenu ; import androidx . coordinatorlayout . widget . CoordinatorLayout ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . adapters . StoryRecyclerViewAdapter ; import com . simon . harmonichackernews . data . Bookmark ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . JSONParser ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . AccountUtils ; import com . simon . harmonichackernews . utils . FontUtils ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . StoryUpdate ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . jetbrains . annotations . NotNull ; import org . json . JSONArray ; import org . json . JSONException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; public class StoriesFragment extends Fragment { private StoryClickListener storyClickListener ; private SwipeRefreshLayout swipeRefreshLayout ; private LinearLayout updateContainer ; private RecyclerView recyclerView ; private StoryRecyclerViewAdapter adapter ; private List < Story > stories ; private RequestQueue queue ; private final Object requestTag = new Object ( ) ; private LinearLayoutManager linearLayoutManager ; private Set < Integer > clickedIds ; private ArrayList < String > filterWords ; private ArrayList < String > filterDomains ; private boolean hideJobs , alwaysOpenComments , hideClicked ; private String lastSearch ; private int loadedTo = <NUM_LIT> ; public final static String [ ] hnUrls = new String [ ] { Utils . URL_TOP , Utils . URL_NEW , Utils . URL_BEST , Utils . URL_ASK , Utils . URL_SHOW , Utils . URL_JOBS } ; long lastLoaded = <NUM_LIT> ; long lastClick = <NUM_LIT> ; private final static long CLICK_INTERVAL = <NUM_LIT> ; private int topInset = <NUM_LIT> ; public StoriesFragment ( ) { super ( R . layout . fragment_stories ) ; } @ Nullable @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { clickedIds = SettingsUtils . readIntSetFromSharedPreferences ( requireContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; recyclerView = view . findViewById ( R . id . stories_recyclerview ) ; swipeRefreshLayout = view . findViewById ( R . id . stories_swipe_refresh ) ; updateContainer = view . findViewById ( R . id . stories_update_container ) ; Button updateButton = view . findViewById ( R . id . stories_update_button ) ; swipeRefreshLayout . setOnRefreshListener ( this :: attemptRefresh ) ; ViewUtils . setUpSwipeRefreshWithStatusBarOffset ( swipeRefreshLayout ) ; linearLayoutManager = new LinearLayoutManager ( getContext ( ) ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; stories = new ArrayList < > ( ) ; setupAdapter ( ) ; recyclerView . setAdapter ( adapter ) ; ViewCompat . setOnApplyWindowInsetsListener ( view , new OnApplyWindowInsetsListener ( ) { @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat windowInsets ) { Insets insets = windowInsets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) ; CoordinatorLayout . LayoutParams params = ( CoordinatorLayout . LayoutParams ) updateContainer . getLayoutParams ( ) ; params . bottomMargin = insets . bottom + Utils . pxFromDpInt ( getResources ( ) , <NUM_LIT> ) ; updateContainer . setLayoutParams ( params ) ; topInset = insets . top ; return windowInsets ; } } ) ; ViewUtils . requestApplyInsetsWhenAttached ( view ) ; updateButton . setOnClickListener ( ( v ) -> { attemptRefresh ( ) ; recyclerView . smoothScrollToPosition ( <NUM_LIT> ) ; } ) ; recyclerView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { int lastVisibleItem ; @ Override public void onScrolled ( @ NotNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( ! adapter . searching ) { lastVisibleItem = linearLayoutManager . findLastVisibleItemPosition ( ) ; int visibleThreshold = <NUM_LIT> ; for ( int i = loadedTo + <NUM_LIT> ; i < Math . min ( lastVisibleItem + visibleThreshold , stories . size ( ) ) ; i ++ ) { loadedTo = i ; loadStory ( stories . get ( i ) , <NUM_LIT> ) ; } } } } ) ; queue = NetworkComponent . getRequestQueueInstance ( requireContext ( ) ) ; stories . add ( new Story ( ) ) ; attemptRefresh ( ) ; StoryUpdate . setStoryUpdatedListener ( new StoryUpdate . StoryUpdateListener ( ) { @ Override public void callback ( Story story ) { for ( int i = <NUM_LIT> ; i < stories . size ( ) ; i ++ ) { if ( story . id == stories . get ( i ) . id ) { Story oldStory = stories . get ( i ) ; if ( ! oldStory . title . equals ( story . title ) || oldStory . descendants != story . descendants || oldStory . score != story . score || oldStory . time != story . time || ! oldStory . url . equals ( story . url ) ) { oldStory . title = story . title ; oldStory . descendants = story . descendants ; oldStory . score = story . score ; oldStory . time = story . time ; oldStory . url = story . url ; adapter . notifyItemChanged ( i ) ; } break ; } } } } ) ; } private int getPreferredTypeIndex ( ) { String [ ] sortingOptions = getResources ( ) . getStringArray ( R . array . sorting_options ) ; ArrayList < CharSequence > typeAdapterList = new ArrayList < > ( Arrays . asList ( sortingOptions ) ) ; return typeAdapterList . indexOf ( SettingsUtils . getPreferredStoryType ( getContext ( ) ) ) ; } private void setupAdapter ( ) { adapter = new StoryRecyclerViewAdapter ( stories , SettingsUtils . shouldShowPoints ( getContext ( ) ) , SettingsUtils . shouldShowCommentsCount ( getContext ( ) ) , SettingsUtils . shouldUseCompactView ( getContext ( ) ) , SettingsUtils . shouldShowThumbnails ( getContext ( ) ) , SettingsUtils . shouldShowIndex ( getContext ( ) ) , SettingsUtils . shouldUseCompactHeader ( getContext ( ) ) , SettingsUtils . shouldUseLeftAlign ( getContext ( ) ) , SettingsUtils . getPreferredHotness ( getContext ( ) ) , SettingsUtils . getPreferredFaviconProvider ( getContext ( ) ) , null , getPreferredTypeIndex ( ) ) ; adapter . setOnLinkClickListener ( position -> { if ( position == RecyclerView . NO_POSITION ) { return ; } if ( alwaysOpenComments ) { clickedComments ( position ) ; return ; } long now = System . currentTimeMillis ( ) ; if ( now - lastClick > CLICK_INTERVAL ) { lastClick = now ; } else { return ; } Story story = stories . get ( position ) ; if ( story . loaded ) { story . clicked = true ; clickedIds . add ( story . id ) ; if ( story . isLink ) { if ( SettingsUtils . shouldUseIntegratedWebView ( getContext ( ) ) ) { openComments ( story , position , true ) ; } else { Utils . launchCustomTab ( getContext ( ) , story . url ) ; } } else { openComments ( story , position , false ) ; } adapter . notifyItemChanged ( position ) ; } else if ( story . loadingFailed ) { story . loadingFailed = false ; loadStory ( story , <NUM_LIT> ) ; adapter . notifyItemChanged ( position ) ; } } ) ; adapter . setOnCommentClickListener ( this :: clickedComments ) ; adapter . setOnRefreshListener ( this :: attemptRefresh ) ; adapter . setOnMoreClickListener ( this :: moreClick ) ; adapter . setOnTypeClickListener ( index -> { if ( index != adapter . type ) { adapter . type = index ; attemptRefresh ( ) ; } } ) ; adapter . setSearchListener ( new StoryRecyclerViewAdapter . SearchListener ( ) { @ Override public void onQueryTextSubmit ( String query ) { search ( query ) ; } @ Override public void onSearchStatusChanged ( ) { updateSearchStatus ( ) ; } } ) ; adapter . setOnLongClickListener ( new StoryRecyclerViewAdapter . LongClickCoordinateListener ( ) { @ Override public boolean onLongClick ( View v , int position , int x , int y ) { if ( position == RecyclerView . NO_POSITION ) { return false ; } Context ctx = v . getContext ( ) ; PopupMenu popupMenu = new PopupMenu ( ctx , v ) ; Story story = stories . get ( position ) ; boolean oldClicked = story . clicked ; boolean oldBookmarked = Utils . isBookmarked ( ctx , story . id ) ; popupMenu . getMenu ( ) . add ( oldClicked ? "<STR_LIT>" : "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { story . clicked = ! oldClicked ; if ( oldClicked ) { clickedIds . remove ( story . id ) ; } else { clickedIds . add ( story . id ) ; } adapter . notifyItemChanged ( position ) ; return true ; } } ) ; popupMenu . getMenu ( ) . add ( oldBookmarked ? "<STR_LIT>" : "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { if ( oldBookmarked ) { Utils . removeBookmark ( ctx , story . id ) ; if ( adapter . type == SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) { stories . remove ( story ) ; adapter . notifyItemRemoved ( position ) ; return true ; } } else { Utils . addBookmark ( ctx , story . id ) ; } adapter . notifyItemChanged ( position ) ; return true ; } } ) ; try { java . lang . reflect . Field fieldPopup = popupMenu . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; fieldPopup . setAccessible ( true ) ; Object menuPopupHelper = fieldPopup . get ( popupMenu ) ; int targetX = x - Utils . pxFromDpInt ( getResources ( ) , <NUM_LIT> ) ; int targetY = y - topInset - Utils . pxFromDpInt ( getResources ( ) , <NUM_LIT> ) - v . getHeight ( ) / <NUM_LIT> ; menuPopupHelper . getClass ( ) . getDeclaredMethod ( "<STR_LIT>" , int . class , int . class ) . invoke ( menuPopupHelper , targetX , targetY ) ; } catch ( Exception e ) { popupMenu . show ( ) ; } return false ; } } ) ; } @ Override public void onActivityCreated ( @ Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; if ( getActivity ( ) instanceof MainActivity ) { storyClickListener = ( MainActivity ) getActivity ( ) ; } } @ Override public void onResume ( ) { super . onResume ( ) ; filterWords = Utils . getFilterWords ( getContext ( ) ) ; filterDomains = Utils . getFilterDomains ( getContext ( ) ) ; hideJobs = SettingsUtils . shouldHideJobs ( getContext ( ) ) ; hideClicked = SettingsUtils . shouldHideClicked ( getContext ( ) ) ; alwaysOpenComments = SettingsUtils . shouldAlwaysOpenComments ( getContext ( ) ) ; long timeDiff = System . currentTimeMillis ( ) - lastLoaded ; if ( timeDiff > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> && ! adapter . searching && adapter . type != SettingsUtils . getBookmarksIndex ( getResources ( ) ) && ! currentTypeIsAlgolia ( ) ) { showUpdateButton ( ) ; } if ( adapter . showPoints != SettingsUtils . shouldShowPoints ( getContext ( ) ) ) { adapter . showPoints = ! adapter . showPoints ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . showCommentsCount != SettingsUtils . shouldShowCommentsCount ( getContext ( ) ) ) { adapter . showCommentsCount = ! adapter . showCommentsCount ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . compactView != SettingsUtils . shouldUseCompactView ( getContext ( ) ) ) { adapter . compactView = ! adapter . compactView ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . thumbnails != SettingsUtils . shouldShowThumbnails ( getContext ( ) ) ) { adapter . thumbnails = ! adapter . thumbnails ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . showIndex != SettingsUtils . shouldShowIndex ( getContext ( ) ) ) { adapter . showIndex = ! adapter . showIndex ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . leftAlign != SettingsUtils . shouldUseLeftAlign ( getContext ( ) ) ) { adapter . leftAlign = ! adapter . leftAlign ; setupAdapter ( ) ; recyclerView . setAdapter ( adapter ) ; } if ( TextUtils . isEmpty ( FontUtils . font ) || ! FontUtils . font . equals ( SettingsUtils . getPreferredFont ( getContext ( ) ) ) ) { FontUtils . init ( getContext ( ) ) ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( adapter . compactHeader != SettingsUtils . shouldUseCompactHeader ( getContext ( ) ) ) { adapter . compactHeader = SettingsUtils . shouldUseCompactHeader ( getContext ( ) ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } if ( adapter . hotness != SettingsUtils . getPreferredHotness ( getContext ( ) ) ) { adapter . hotness = SettingsUtils . getPreferredHotness ( getContext ( ) ) ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } if ( hideJobs != SettingsUtils . shouldHideJobs ( getContext ( ) ) ) { hideJobs = ! hideJobs ; attemptRefresh ( ) ; } if ( adapter . faviconProvider != SettingsUtils . getPreferredFaviconProvider ( getContext ( ) ) ) { adapter . faviconProvider = SettingsUtils . getPreferredFaviconProvider ( getContext ( ) ) ; adapter . notifyItemRangeChanged ( <NUM_LIT> , stories . size ( ) ) ; } } @ Override public void onPause ( ) { super . onPause ( ) ; SettingsUtils . saveIntSetToSharedPreferences ( getContext ( ) , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS , clickedIds ) ; } @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; if ( queue != null ) { queue . cancelAll ( requestTag ) ; } } private void clickedComments ( int position ) { long now = System . currentTimeMillis ( ) ; if ( now - lastClick > CLICK_INTERVAL ) { lastClick = now ; } else { return ; } if ( position == RecyclerView . NO_POSITION ) { return ; } Story story = stories . get ( position ) ; if ( story . loaded ) { story . clicked = true ; clickedIds . add ( story . id ) ; openComments ( story , position , false ) ; adapter . notifyItemChanged ( position ) ; } } private void loadStory ( Story story , final int attempt ) { if ( story . loaded || attempt >= <NUM_LIT> ) { return ; } String url = "<STR_LIT>" + story . id + "<STR_LIT>" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { try { int index = stories . indexOf ( story ) ; if ( ! JSONParser . updateStoryWithHNJson ( response , story ) ) { stories . remove ( story ) ; adapter . notifyItemRemoved ( index ) ; loadedTo = Math . max ( <NUM_LIT> , loadedTo - <NUM_LIT> ) ; return ; } for ( String phrase : filterWords ) { if ( story . title . toLowerCase ( ) . contains ( phrase . toLowerCase ( ) ) ) { stories . remove ( story ) ; adapter . notifyItemRemoved ( index ) ; loadedTo = Math . max ( <NUM_LIT> , loadedTo - <NUM_LIT> ) ; return ; } } for ( String phrase : filterDomains ) { if ( story . url . toLowerCase ( ) . contains ( phrase . toLowerCase ( ) ) ) { stories . remove ( story ) ; adapter . notifyItemRemoved ( index ) ; loadedTo = Math . max ( <NUM_LIT> , loadedTo - <NUM_LIT> ) ; return ; } } if ( hideJobs && adapter . type != SettingsUtils . getJobsIndex ( getResources ( ) ) && ( story . isJob || story . by . equals ( "<STR_LIT>" ) ) ) { stories . remove ( story ) ; adapter . notifyItemRemoved ( index ) ; loadedTo = Math . max ( <NUM_LIT> , loadedTo - <NUM_LIT> ) ; return ; } adapter . notifyItemChanged ( index ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; Utils . log ( "<STR_LIT>" + story . id ) ; adapter . notifyDataSetChanged ( ) ; } } , error -> { error . printStackTrace ( ) ; story . loadingFailed = true ; adapter . notifyItemChanged ( stories . indexOf ( story ) ) ; loadStory ( story , attempt + <NUM_LIT> ) ; } ) ; stringRequest . setTag ( requestTag ) ; queue . add ( stringRequest ) ; } public void moreClick ( View view ) { PopupMenu popup = new PopupMenu ( requireActivity ( ) , view ) ; popup . setOnMenuItemClickListener ( new PopupMenu . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( MenuItem item ) { if ( item . getItemId ( ) == R . id . menu_settings ) { requireActivity ( ) . startActivity ( new Intent ( requireActivity ( ) , SettingsActivity . class ) ) ; } else if ( item . getItemId ( ) == R . id . menu_log ) { if ( TextUtils . isEmpty ( AccountUtils . getAccountUsername ( requireActivity ( ) ) ) ) { AccountUtils . showLoginPrompt ( requireActivity ( ) . getSupportFragmentManager ( ) ) ; } else { AccountUtils . deleteAccountDetails ( requireActivity ( ) ) ; Toast . makeText ( getContext ( ) , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } else if ( item . getItemId ( ) == R . id . menu_profile ) { UserDialogFragment . showUserDialog ( requireActivity ( ) . getSupportFragmentManager ( ) , AccountUtils . getAccountUsername ( requireActivity ( ) ) ) ; } else if ( item . getItemId ( ) == R . id . menu_submit ) { Intent submitIntent = new Intent ( getContext ( ) , ComposeActivity . class ) ; submitIntent . putExtra ( ComposeActivity . EXTRA_TYPE , ComposeActivity . TYPE_POST ) ; startActivity ( submitIntent ) ; } return true ; } } ) ; popup . getMenuInflater ( ) . inflate ( R . menu . main_menu , popup . getMenu ( ) ) ; Menu menu = popup . getMenu ( ) ; boolean loggedIn = ! TextUtils . isEmpty ( AccountUtils . getAccountUsername ( requireActivity ( ) ) ) ; menu . findItem ( R . id . menu_log ) . setTitle ( loggedIn ? "<STR_LIT>" : "<STR_LIT>" ) ; menu . findItem ( R . id . menu_profile ) . setVisible ( loggedIn ) ; menu . findItem ( R . id . menu_submit ) . setVisible ( loggedIn ) ; popup . show ( ) ; } public void attemptRefresh ( ) { hideUpdateButton ( ) ; if ( adapter . searching ) { search ( lastSearch ) ; return ; } swipeRefreshLayout . setRefreshing ( true ) ; queue . cancelAll ( requestTag ) ; if ( currentTypeIsAlgolia ( ) ) { int currentTime = ( int ) ( System . currentTimeMillis ( ) / <NUM_LIT> ) ; int startTime = currentTime ; if ( adapter . type == <NUM_LIT> ) { startTime = currentTime - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } else if ( adapter . type == <NUM_LIT> ) { startTime = currentTime - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } else if ( adapter . type == <NUM_LIT> ) { startTime = currentTime - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } loadTopStoriesSince ( startTime ) ; return ; } lastLoaded = System . currentTimeMillis ( ) ; if ( adapter . type == SettingsUtils . getBookmarksIndex ( getResources ( ) ) ) { adapter . notifyItemRangeRemoved ( <NUM_LIT> , stories . size ( ) + <NUM_LIT> ) ; loadedTo = <NUM_LIT> ; stories . clear ( ) ; stories . add ( new Story ( ) ) ; ArrayList < Bookmark > bookmarks = Utils . loadBookmarks ( getContext ( ) , true ) ; for ( int i = <NUM_LIT> ; i < bookmarks . size ( ) ; i ++ ) { Story s = new Story ( "<STR_LIT>" , bookmarks . get ( i ) . id , false , false ) ; stories . add ( s ) ; adapter . notifyItemInserted ( i + <NUM_LIT> ) ; if ( i < <NUM_LIT> ) { loadStory ( stories . get ( i + <NUM_LIT> ) , <NUM_LIT> ) ; } } adapter . notifyItemChanged ( <NUM_LIT> ) ; swipeRefreshLayout . setRefreshing ( false ) ; return ; } StringRequest stringRequest = new StringRequest ( Request . Method . GET , hnUrls [ adapter . type == <NUM_LIT> ? <NUM_LIT> : adapter . type - <NUM_LIT> ] , response -> { swipeRefreshLayout . setRefreshing ( false ) ; try { JSONArray jsonArray = new JSONArray ( response ) ; loadedTo = <NUM_LIT> ; adapter . notifyItemRangeRemoved ( <NUM_LIT> , stories . size ( ) ) ; stories . clear ( ) ; stories . add ( new Story ( ) ) ; for ( int i = <NUM_LIT> ; i < jsonArray . length ( ) ; i ++ ) { int id = Integer . parseInt ( jsonArray . get ( i ) . toString ( ) ) ; if ( hideClicked && clickedIds . contains ( id ) ) { continue ; } Story s = new Story ( "<STR_LIT>" , id , false , clickedIds . contains ( id ) ) ; String cachedResponse = Utils . loadCachedStory ( getContext ( ) , id ) ; if ( cachedResponse != null && ! cachedResponse . equals ( JSONParser . ALGOLIA_ERROR_STRING ) ) { JSONParser . updateStoryWithAlgoliaResponse ( s , cachedResponse ) ; } stories . add ( s ) ; adapter . notifyItemInserted ( <NUM_LIT> + i ) ; } if ( adapter . loadingFailed ) { adapter . loadingFailed = false ; adapter . loadingFailedServerError = false ; } adapter . notifyItemChanged ( <NUM_LIT> ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } , error -> { swipeRefreshLayout . setRefreshing ( false ) ; adapter . loadingFailed = true ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; stringRequest . setTag ( requestTag ) ; queue . add ( stringRequest ) ; } private void updateSearchStatus ( ) { hideUpdateButton ( ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; if ( getActivity ( ) != null && getActivity ( ) instanceof MainActivity ) { ( ( MainActivity ) getActivity ( ) ) . backPressedCallback . setEnabled ( adapter . searching ) ; } swipeRefreshLayout . setEnabled ( ! adapter . searching ) ; if ( adapter . searching ) { queue . cancelAll ( requestTag ) ; swipeRefreshLayout . setRefreshing ( false ) ; adapter . notifyItemRangeRemoved ( <NUM_LIT> , stories . size ( ) + <NUM_LIT> ) ; stories . clear ( ) ; stories . add ( new Story ( ) ) ; } else { int size = stories . size ( ) ; if ( size > <NUM_LIT> ) { stories . subList ( <NUM_LIT> , size ) . clear ( ) ; } adapter . notifyItemRangeRemoved ( <NUM_LIT> , size + <NUM_LIT> ) ; attemptRefresh ( ) ; } } private void loadTopStoriesSince ( int start_i ) { loadAlgolia ( "<STR_LIT>" + start_i + "<STR_LIT>" , true ) ; } private void search ( String query ) { lastSearch = query ; adapter . lastSearch = query ; loadAlgolia ( "<STR_LIT>" + query + "<STR_LIT>" , false ) ; } private void loadAlgolia ( String url , boolean markClicked ) { swipeRefreshLayout . setEnabled ( true ) ; swipeRefreshLayout . setRefreshing ( true ) ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { swipeRefreshLayout . setRefreshing ( false ) ; try { int oldSize = stories . size ( ) ; stories . clear ( ) ; stories . add ( new Story ( ) ) ; adapter . notifyItemRangeRemoved ( <NUM_LIT> , oldSize + <NUM_LIT> ) ; stories . addAll ( JSONParser . algoliaJsonToStories ( response ) ) ; Iterator < Story > iterator = stories . iterator ( ) ; while ( iterator . hasNext ( ) ) { Story story = iterator . next ( ) ; story . clicked = clickedIds . contains ( story . id ) ; if ( hideClicked && story . clicked ) { iterator . remove ( ) ; } } adapter . loadingFailed = false ; adapter . loadingFailedServerError = false ; adapter . notifyItemRangeInserted ( <NUM_LIT> , stories . size ( ) ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } , error -> { if ( error . networkResponse != null && error . networkResponse . statusCode == <NUM_LIT> ) { adapter . loadingFailedServerError = true ; } error . printStackTrace ( ) ; swipeRefreshLayout . setRefreshing ( false ) ; adapter . loadingFailed = true ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; stringRequest . setTag ( requestTag ) ; queue . add ( stringRequest ) ; } public boolean currentTypeIsAlgolia ( ) { return <NUM_LIT> < adapter . type && <NUM_LIT> > adapter . type ; } public boolean exitSearch ( ) { if ( adapter . searching ) { adapter . searching = false ; adapter . lastSearch = "<STR_LIT>" ; updateSearchStatus ( ) ; return true ; } return false ; } private void hideUpdateButton ( ) { if ( updateContainer . getVisibility ( ) == View . VISIBLE ) { float endYPosition = getResources ( ) . getDisplayMetrics ( ) . heightPixels - updateContainer . getY ( ) + updateContainer . getHeight ( ) + ViewUtils . getNavigationBarHeight ( getResources ( ) ) ; PathInterpolator pathInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; ObjectAnimator yAnimator = ObjectAnimator . ofFloat ( updateContainer , "<STR_LIT>" , endYPosition ) ; yAnimator . setDuration ( <NUM_LIT> ) ; yAnimator . setInterpolator ( pathInterpolator ) ; ObjectAnimator alphaAnimator = ObjectAnimator . ofFloat ( updateContainer , "<STR_LIT>" , <NUM_LIT> , <NUM_LIT> ) ; alphaAnimator . setDuration ( <NUM_LIT> ) ; alphaAnimator . setInterpolator ( pathInterpolator ) ; AnimatorSet animatorSet = new AnimatorSet ( ) ; animatorSet . playTogether ( yAnimator , alphaAnimator ) ; animatorSet . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( android . animation . Animator animation ) { updateContainer . setVisibility ( View . GONE ) ; updateContainer . setTranslationY ( <NUM_LIT> ) ; updateContainer . setAlpha ( <NUM_LIT> ) ; } } ) ; animatorSet . start ( ) ; } } private void showUpdateButton ( ) { if ( updateContainer . getVisibility ( ) != View . VISIBLE ) { updateContainer . setVisibility ( View . VISIBLE ) ; AlphaAnimation anim = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; anim . setDuration ( <NUM_LIT> ) ; anim . setRepeatMode ( Animation . REVERSE ) ; updateContainer . startAnimation ( anim ) ; } } private void openComments ( Story story , int pos , boolean showWebsite ) { storyClickListener . openStory ( story , pos , showWebsite ) ; } public interface StoryClickListener { void openStory ( Story story , int pos , boolean showWebsite ) ; } } </s>
<s> package com . simon . harmonichackernews . data ; import com . simon . harmonichackernews . utils . Utils ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; public class Comment implements Serializable { public String by ; public int id ; public int parent ; public String text ; public int time ; public boolean expanded ; public int depth ; public int children ; public int totalReplies ; public boolean matchesSearch = true ; public List < Comment > childComments = new ArrayList < > ( ) ; public int sortOrder ; public Comment ( ) { } public String getTimeFormatted ( ) { return Utils . getTimeAgo ( this . time ) ; } public int getTime ( ) { return this . time ; } } </s>
<s> package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import androidx . annotation . Nullable ; import org . xml . sax . Attributes ; public interface WrapperTagHandler { boolean handleTag ( boolean opening , String tag , Editable output , @ Nullable Attributes attributes ) ; } </s>
<s> package com . simon . harmonichackernews ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . adapters . StoryRecyclerViewAdapter ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . JSONParser ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . json . JSONException ; import java . util . ArrayList ; public class SubmissionsActivity extends AppCompatActivity { public final static String KEY_USER = "<STR_LIT>" ; private StoryRecyclerViewAdapter adapter ; private ArrayList < Story > submissions ; private LinearLayoutManager linearLayoutManager ; private RequestQueue queue ; private SwipeRefreshLayout swipeRefreshLayout ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_submissions ) ; swipeRefreshLayout = findViewById ( R . id . submissions_swiperefreshlayout ) ; swipeRefreshLayout . setOnRefreshListener ( this :: loadSubmissions ) ; ViewUtils . setUpSwipeRefreshWithStatusBarOffset ( swipeRefreshLayout ) ; RecyclerView recyclerView = findViewById ( R . id . submissions_recyclerview ) ; submissions = new ArrayList < > ( ) ; submissions . add ( new Story ( ) ) ; queue = NetworkComponent . getRequestQueueInstance ( this ) ; linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; adapter = new StoryRecyclerViewAdapter ( submissions , SettingsUtils . shouldShowPoints ( this ) , SettingsUtils . shouldShowCommentsCount ( this ) , SettingsUtils . shouldUseCompactView ( this ) , SettingsUtils . shouldShowThumbnails ( this ) , false , SettingsUtils . shouldUseCompactHeader ( this ) , SettingsUtils . shouldUseLeftAlign ( this ) , SettingsUtils . getPreferredHotness ( this ) , SettingsUtils . getPreferredFaviconProvider ( this ) , getIntent ( ) . getStringExtra ( KEY_USER ) , - <NUM_LIT> ) ; adapter . setOnRefreshListener ( this :: loadSubmissions ) ; adapter . setOnCommentClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { openComments ( submissions . get ( position ) , false ) ; } } ) ; adapter . setOnLinkClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { Story story = submissions . get ( position ) ; if ( story . isLink ) { if ( SettingsUtils . shouldUseIntegratedWebView ( getApplicationContext ( ) ) ) { openComments ( story , true ) ; } else { Utils . launchCustomTab ( SubmissionsActivity . this , story . url ) ; } } else { openComments ( story , false ) ; } } } ) ; adapter . setOnCommentStoryClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { Story story = submissions . get ( position ) ; Intent intent = new Intent ( getApplicationContext ( ) , CommentsActivity . class ) ; intent . putExtra ( CommentsFragment . EXTRA_ID , story . commentMasterId ) ; intent . putExtra ( CommentsFragment . EXTRA_TITLE , story . commentMasterTitle ) ; intent . putExtra ( CommentsFragment . EXTRA_URL , story . commentMasterUrl ) ; startActivity ( intent ) ; overridePendingTransition ( R . anim . activity_in_animation , <NUM_LIT> ) ; } } ) ; adapter . setOnCommentRepliesClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { openComments ( submissions . get ( position ) , false ) ; } } ) ; recyclerView . setAdapter ( adapter ) ; loadSubmissions ( ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; if ( Utils . isTablet ( getResources ( ) ) ) { int sideMargin = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ; swipeRefreshLayout . setPadding ( sideMargin , <NUM_LIT> , sideMargin , <NUM_LIT> ) ; } } private void openComments ( Story story , boolean showWebsite ) { Bundle bundle = story . toBundle ( ) ; bundle . putBoolean ( CommentsFragment . EXTRA_SHOW_WEBSITE , showWebsite ) ; Intent intent = new Intent ( SubmissionsActivity . this , CommentsActivity . class ) ; intent . putExtras ( bundle ) ; startActivity ( intent ) ; overridePendingTransition ( R . anim . activity_in_animation , <NUM_LIT> ) ; } private void loadSubmissions ( ) { swipeRefreshLayout . setRefreshing ( true ) ; String url = "<STR_LIT>" + getIntent ( ) . getStringExtra ( KEY_USER ) + "<STR_LIT>" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { swipeRefreshLayout . setRefreshing ( false ) ; try { int oldSize = submissions . size ( ) ; submissions . clear ( ) ; submissions . add ( new Story ( ) ) ; adapter . notifyItemRangeRemoved ( <NUM_LIT> , oldSize + <NUM_LIT> ) ; submissions . addAll ( JSONParser . algoliaJsonToStories ( response ) ) ; adapter . loadingFailed = false ; adapter . loadingFailedServerError = false ; adapter . notifyItemRangeInserted ( <NUM_LIT> , submissions . size ( ) ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } , error -> { if ( error . networkResponse != null && error . networkResponse . statusCode == <NUM_LIT> ) { adapter . loadingFailedServerError = true ; } error . printStackTrace ( ) ; swipeRefreshLayout . setRefreshing ( false ) ; adapter . loadingFailed = true ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) ; queue . add ( stringRequest ) ; } } </s>
<s> package com . simon . harmonichackernews . utils ; import com . simon . harmonichackernews . data . Story ; public class StoryUpdate { public static StoryUpdateListener storyUpdateListener ; public static void updateStory ( Story story ) { if ( storyUpdateListener != null ) { storyUpdateListener . callback ( story ) ; } } public static void setStoryUpdatedListener ( StoryUpdateListener storyUpdateListener ) { StoryUpdate . storyUpdateListener = storyUpdateListener ; } public interface StoryUpdateListener { void callback ( Story story ) ; } } </s>
<s> package com . gw . swipeback . tools ; import android . app . Activity ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . AbsListView ; import android . widget . HorizontalScrollView ; import android . widget . ScrollView ; import androidx . core . view . ViewCompat ; import androidx . core . widget . NestedScrollView ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; public class Util { public static boolean canViewScrollUp ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollVertically ( mView , - <NUM_LIT> ) ; } public static boolean canViewScrollDown ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollVertically ( mView , <NUM_LIT> ) ; } public static boolean canViewScrollRight ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollHorizontally ( mView , - <NUM_LIT> ) ; } public static boolean canViewScrollLeft ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollHorizontally ( mView , <NUM_LIT> ) ; } public static View findAllScrollViews ( ViewGroup mViewGroup ) { for ( int i = <NUM_LIT> ; i < mViewGroup . getChildCount ( ) ; i ++ ) { View mView = mViewGroup . getChildAt ( i ) ; if ( mView . getVisibility ( ) != View . VISIBLE ) { continue ; } if ( isScrollableView ( mView ) ) { return mView ; } if ( mView instanceof ViewGroup ) { mView = findAllScrollViews ( ( ViewGroup ) mView ) ; if ( mView != null ) { return mView ; } } } return null ; } public static boolean isScrollableView ( View mView ) { return mView instanceof ScrollView || mView instanceof HorizontalScrollView || mView instanceof NestedScrollView || mView instanceof AbsListView || mView instanceof RecyclerView || mView instanceof ViewPager || mView instanceof WebView ; } public static boolean contains ( View mView , float x , float y ) { Rect localRect = new Rect ( ) ; mView . getGlobalVisibleRect ( localRect ) ; return localRect . contains ( ( int ) x , ( int ) y ) ; } public static void onPanelSlide ( float fraction ) { Activity activity = WxSwipeBackActivityManager . getInstance ( ) . getPenultimateActivity ( ) ; if ( activity != null && ! activity . isFinishing ( ) ) { View decorView = activity . getWindow ( ) . getDecorView ( ) ; ViewCompat . setTranslationX ( decorView , - ( decorView . getMeasuredWidth ( ) / <NUM_LIT> ) * ( <NUM_LIT> - fraction ) ) ; } } public static void onPanelReset ( ) { Activity activity = WxSwipeBackActivityManager . getInstance ( ) . getPenultimateActivity ( ) ; if ( activity != null ) { View decorView = activity . getWindow ( ) . getDecorView ( ) ; ViewCompat . setTranslationX ( decorView , <NUM_LIT> ) ; } } } </s>
<s> package com . reactnative . pulltorefresh ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . NativeViewHierarchyOptimizer ; import com . facebook . yoga . YogaEdge ; import com . facebook . yoga . YogaPositionType ; public class PullToRefreshFooterShadowNode extends LayoutShadowNode { @ Override public void setLocalData ( Object data ) { super . setLocalData ( data ) ; if ( data instanceof PullToRefreshFooterLocalData ) { PullToRefreshFooterLocalData footerLocalData = ( PullToRefreshFooterLocalData ) data ; setStyleHeight ( footerLocalData . viewRect . bottom - footerLocalData . viewRect . top ) ; } } @ Override public void onBeforeLayout ( NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer ) { setPositionType ( YogaPositionType . ABSOLUTE ) ; setPosition ( YogaEdge . LEFT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . RIGHT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . BOTTOM . intValue ( ) , - getLayoutHeight ( ) ) ; } } </s>
<s> package com . reactnative . pulltorefresh . event ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . Event ; public class RefreshEvent extends Event < RefreshEvent > { public static final String Name = "<STR_LIT>" ; public static final String JSEventName = "<STR_LIT>" ; public RefreshEvent ( int surfaceId , int viewTag ) { super ( surfaceId , viewTag ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { return Arguments . createMap ( ) ; } } </s>
<s> package com . reactnative . wheelpicker . wheel ; public interface IPickerViewData { String getPickerViewText ( ) ; } </s>
<s> package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class ImageCropPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new RNImageCropViewManager ( ) ) ; } } </s>
<s> package com . reactnative . keyboardinsets ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . WindowInsetsAnimationCompat ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . common . logging . FLog ; import com . facebook . react . uimanager . ThemedReactContext ; import java . util . List ; public class KeyboardInsetsCallback extends WindowInsetsAnimationCompat . Callback implements OnApplyWindowInsetsListener { private final KeyboardInsetsView view ; private final KeyboardAutoHandler autoHandler ; private final KeyboardManualHandler manualHandler ; public KeyboardInsetsCallback ( KeyboardInsetsView view , ThemedReactContext reactContext ) { super ( WindowInsetsAnimationCompat . Callback . DISPATCH_MODE_CONTINUE_ON_SUBTREE ) ; this . view = view ; this . autoHandler = new KeyboardAutoHandler ( view , reactContext ) ; this . manualHandler = new KeyboardManualHandler ( view , reactContext ) ; } public View focusView ; private boolean transitioning ; private int keyboardHeight ; @ Override public void onPrepare ( @ NonNull WindowInsetsAnimationCompat animation ) { transitioning = true ; } @ NonNull @ Override public WindowInsetsAnimationCompat . BoundsCompat onStart ( @ NonNull WindowInsetsAnimationCompat animation , @ NonNull WindowInsetsAnimationCompat . BoundsCompat bounds ) { if ( SystemUI . isImeVisible ( view ) ) { focusView = view . findFocus ( ) ; } if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return super . onStart ( animation , bounds ) ; } if ( SystemUI . isImeVisible ( view ) ) { keyboardHeight = SystemUI . imeHeight ( view ) ; } FLog . i ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( view . isAutoMode ( ) ) { autoHandler . onStart ( focusView , keyboardHeight ) ; } else { manualHandler . onStart ( focusView , keyboardHeight ) ; } return super . onStart ( animation , bounds ) ; } @ Override public void onEnd ( @ NonNull WindowInsetsAnimationCompat animation ) { super . onEnd ( animation ) ; transitioning = false ; if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return ; } if ( ! SystemUI . isImeVisible ( view ) ) { focusView = null ; } FLog . i ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( view . isAutoMode ( ) ) { autoHandler . onEnd ( focusView , keyboardHeight ) ; } else { manualHandler . onEnd ( focusView , keyboardHeight ) ; } } @ NonNull @ Override public WindowInsetsCompat onProgress ( @ NonNull WindowInsetsCompat insets , @ NonNull List < WindowInsetsAnimationCompat > runningAnimations ) { if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return insets ; } handleKeyboardTransition ( insets ) ; return WindowInsetsCompat . CONSUMED ; } @ Override public WindowInsetsCompat onApplyWindowInsets ( View v , WindowInsetsCompat insets ) { if ( transitioning ) { return insets ; } if ( focusView == null ) { focusView = view . findFocus ( ) ; } if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return insets ; } Insets imeInsets = insets . getInsets ( WindowInsetsCompat . Type . ime ( ) ) ; FLog . i ( "<STR_LIT>" , "<STR_LIT>" + imeInsets ) ; if ( SystemUI . isImeVisible ( view ) ) { keyboardHeight = SystemUI . imeHeight ( view ) ; } if ( view . isAutoMode ( ) ) { View focusView = view . findFocus ( ) ; if ( focusView != null && focusView != this . focusView ) { KeyboardInsetsView insetsView = findClosestKeyboardInsetsView ( focusView ) ; if ( insetsView != view ) { focusView = null ; } } this . focusView = focusView ; autoHandler . onApplyWindowInsets ( insets , focusView , keyboardHeight ) ; } else { manualHandler . onApplyWindowInsets ( insets , focusView , keyboardHeight ) ; } return insets ; } private void handleKeyboardTransition ( WindowInsetsCompat insets ) { if ( view . isAutoMode ( ) ) { autoHandler . handleKeyboardTransition ( insets , focusView ) ; } else { manualHandler . handleKeyboardTransition ( insets , focusView ) ; } } private boolean shouldHandleKeyboardTransition ( View focus ) { if ( focus != null ) { KeyboardInsetsView insetsView = findClosestKeyboardInsetsView ( focus ) ; return insetsView == view ; } return false ; } private static KeyboardInsetsView findClosestKeyboardInsetsView ( View focus ) { ViewParent viewParent = focus . getParent ( ) ; if ( viewParent instanceof KeyboardInsetsView ) { return ( KeyboardInsetsView ) viewParent ; } if ( viewParent instanceof View ) { return findClosestKeyboardInsetsView ( ( View ) viewParent ) ; } return null ; } } </s>
<s> package com . reactnative . pulltorefresh ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . NativeViewHierarchyOptimizer ; import com . facebook . yoga . YogaEdge ; import com . facebook . yoga . YogaPositionType ; public class PullToRefreshHeaderShadowNode extends LayoutShadowNode { @ Override public void setLocalData ( Object data ) { super . setLocalData ( data ) ; if ( data instanceof PullToRefreshHeaderLocalData ) { PullToRefreshHeaderLocalData headerLocalData = ( PullToRefreshHeaderLocalData ) data ; setStyleHeight ( headerLocalData . viewRect . bottom - headerLocalData . viewRect . top ) ; } } @ Override public void onBeforeLayout ( NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer ) { setPositionType ( YogaPositionType . ABSOLUTE ) ; setPosition ( YogaEdge . LEFT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . RIGHT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . TOP . intValue ( ) , - getLayoutHeight ( ) ) ; } } </s>
<s> package com . reactnativecommunity . webview ; import android . util . Log ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import android . view . ViewParent ; import android . widget . OverScroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . NestedScrollingChild3 ; import androidx . core . view . NestedScrollingChildHelper ; import androidx . core . view . ViewCompat ; import com . facebook . react . uimanager . ThemedReactContext ; public class RNCNestedScrollWebView extends RNCWebViewManager . RNCWebView implements NestedScrollingChild3 { public RNCNestedScrollWebView ( ThemedReactContext reactContext ) { super ( reactContext ) ; mChildHelper = new NestedScrollingChildHelper ( this ) ; setNestedScrollingEnabled ( true ) ; initScrollView ( ) ; } private static final String TAG = "<STR_LIT>" ; private static final int INVALID_POINTER = - <NUM_LIT> ; private final int [ ] mScrollOffset = new int [ <NUM_LIT> ] ; private final int [ ] mScrollConsumed = new int [ <NUM_LIT> ] ; private int mLastMotionY ; private final NestedScrollingChildHelper mChildHelper ; private boolean mIsBeingDragged = false ; private VelocityTracker mVelocityTracker ; private int mTouchSlop ; private int mActivePointerId = INVALID_POINTER ; private int mNestedYOffset ; private OverScroller mScroller ; private int mMinimumVelocity ; private int mMaximumVelocity ; int mLastScrollerY = <NUM_LIT> ; private void initScrollView ( ) { mScroller = new OverScroller ( getContext ( ) , null ) ; final ViewConfiguration configuration = ViewConfiguration . get ( getContext ( ) ) ; mTouchSlop = configuration . getScaledTouchSlop ( ) ; mMinimumVelocity = configuration . getScaledMinimumFlingVelocity ( ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { initVelocityTrackerIfNotExists ( ) ; boolean consumedScrollEvent = false ; final int actionMasked = ev . getAction ( ) ; if ( actionMasked == MotionEvent . ACTION_DOWN ) { mNestedYOffset = <NUM_LIT> ; } MotionEvent vtev = MotionEvent . obtain ( ev ) ; vtev . offsetLocation ( <NUM_LIT> , mNestedYOffset ) ; switch ( actionMasked ) { case MotionEvent . ACTION_DOWN : { initOrResetVelocityTracker ( ) ; mIsBeingDragged = ! mScroller . isFinished ( ) ; if ( mIsBeingDragged ) { mScroller . abortAnimation ( ) ; final ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } } mLastMotionY = ( int ) ev . getY ( ) ; mActivePointerId = ev . getPointerId ( <NUM_LIT> ) ; if ( hasNestedScrollingParent ( ViewCompat . TYPE_NON_TOUCH ) ) { stopNestedScroll ( ViewCompat . TYPE_NON_TOUCH ) ; } startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL , ViewCompat . TYPE_TOUCH ) ; break ; } case MotionEvent . ACTION_MOVE : final int activePointerIndex = ev . findPointerIndex ( mActivePointerId ) ; if ( activePointerIndex == - <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + mActivePointerId + "<STR_LIT>" ) ; break ; } final int y = ( int ) ev . getY ( activePointerIndex ) ; int deltaY = mLastMotionY - y ; if ( ! mIsBeingDragged && Math . abs ( deltaY ) > mTouchSlop ) { final ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } mIsBeingDragged = true ; deltaY = deltaY > <NUM_LIT> ? deltaY - mTouchSlop : deltaY + mTouchSlop ; } if ( mIsBeingDragged ) { mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; if ( dispatchNestedPreScroll ( <NUM_LIT> , deltaY , mScrollConsumed , mScrollOffset ) ) { deltaY -= mScrollConsumed [ <NUM_LIT> ] ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; } mLastMotionY = y - mScrollOffset [ <NUM_LIT> ] ; final int oldScrollY = getScrollY ( ) ; final int range = getScrollRange ( ) ; if ( overScrollByCompat ( deltaY , oldScrollY , range ) && ! hasNestedScrollingParent ( ViewCompat . TYPE_TOUCH ) ) { mVelocityTracker . clear ( ) ; } final int scrolledDeltaY = getScrollY ( ) - oldScrollY ; final int unconsumedY = deltaY - scrolledDeltaY ; mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( <NUM_LIT> , scrolledDeltaY , <NUM_LIT> , unconsumedY , mScrollOffset , ViewCompat . TYPE_TOUCH , mScrollConsumed ) ; mLastMotionY -= mScrollOffset [ <NUM_LIT> ] ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; consumedScrollEvent = true ; } break ; case MotionEvent . ACTION_UP : final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( <NUM_LIT> , mMaximumVelocity ) ; int initialVelocity = ( int ) velocityTracker . getYVelocity ( mActivePointerId ) ; if ( Math . abs ( initialVelocity ) > mMinimumVelocity ) { flingWithNestedDispatch ( - initialVelocity ) ; } else if ( springBack ( getScrollY ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } mActivePointerId = INVALID_POINTER ; endDrag ( ) ; break ; case MotionEvent . ACTION_CANCEL : if ( mIsBeingDragged && springBack ( getScrollY ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } mActivePointerId = INVALID_POINTER ; endDrag ( ) ; break ; case MotionEvent . ACTION_POINTER_DOWN : { final int index = ev . getActionIndex ( ) ; mLastMotionY = ( int ) ev . getY ( index ) ; mActivePointerId = ev . getPointerId ( index ) ; break ; } case MotionEvent . ACTION_POINTER_UP : onSecondaryPointerUp ( ev ) ; mLastMotionY = ( int ) ev . getY ( ev . findPointerIndex ( mActivePointerId ) ) ; break ; } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( vtev ) ; } vtev . recycle ( ) ; if ( consumedScrollEvent ) { ev . setAction ( MotionEvent . ACTION_CANCEL ) ; } return super . onTouchEvent ( ev ) ; } boolean overScrollByCompat ( int deltaY , int scrollY , int scrollRangeY ) { final int top = <NUM_LIT> ; int newScrollY = scrollY + deltaY ; boolean clampedY = false ; if ( newScrollY > scrollRangeY ) { newScrollY = scrollRangeY ; clampedY = true ; } else if ( newScrollY < top ) { newScrollY = top ; clampedY = true ; } if ( clampedY && ! hasNestedScrollingParent ( ViewCompat . TYPE_NON_TOUCH ) ) { springBack ( newScrollY ) ; } onOverScrolled ( <NUM_LIT> , newScrollY , false , clampedY ) ; return clampedY ; } boolean springBack ( int startY ) { return mScroller . springBack ( <NUM_LIT> , startY , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , getScrollRange ( ) ) ; } int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } private void endDrag ( ) { mIsBeingDragged = false ; recycleVelocityTracker ( ) ; stopNestedScroll ( ViewCompat . TYPE_TOUCH ) ; } private void onSecondaryPointerUp ( MotionEvent ev ) { final int pointerIndex = ( ev . getAction ( ) & MotionEvent . ACTION_POINTER_INDEX_MASK ) > > MotionEvent . ACTION_POINTER_INDEX_SHIFT ; final int pointerId = ev . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mLastMotionY = ( int ) ev . getY ( newPointerIndex ) ; mActivePointerId = ev . getPointerId ( newPointerIndex ) ; if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } } } private void initOrResetVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void initVelocityTrackerIfNotExists ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } } private void recycleVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } } private void flingWithNestedDispatch ( int velocityY ) { final int scrollY = getScrollY ( ) ; final boolean canFling = ( scrollY > <NUM_LIT> || velocityY > <NUM_LIT> ) && ( scrollY < getScrollRange ( ) || velocityY < <NUM_LIT> ) ; if ( ! dispatchNestedPreFling ( <NUM_LIT> , velocityY ) ) { dispatchNestedFling ( <NUM_LIT> , velocityY , canFling ) ; fling ( velocityY ) ; } } public void fling ( int velocityY ) { startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL , ViewCompat . TYPE_NON_TOUCH ) ; mScroller . fling ( getScrollX ( ) , getScrollY ( ) , <NUM_LIT> , velocityY , <NUM_LIT> , <NUM_LIT> , Integer . MIN_VALUE , Integer . MAX_VALUE , <NUM_LIT> , <NUM_LIT> ) ; mLastScrollerY = getScrollY ( ) ; ViewCompat . postInvalidateOnAnimation ( this ) ; } @ Override public void computeScroll ( ) { if ( nestedScrollEnabled ) { super . computeScroll ( ) ; return ; } if ( mScroller . isFinished ( ) ) { return ; } if ( mScroller . computeScrollOffset ( ) ) { final int y = mScroller . getCurrY ( ) ; int unconsumed = y - mLastScrollerY ; mLastScrollerY = y ; if ( unconsumed != <NUM_LIT> ) { mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedPreScroll ( <NUM_LIT> , unconsumed , mScrollConsumed , mScrollOffset , ViewCompat . TYPE_NON_TOUCH ) ; unconsumed -= mScrollConsumed [ <NUM_LIT> ] ; final int oldScrollY = getScrollY ( ) ; final int range = getScrollRange ( ) ; overScrollByCompat ( unconsumed , oldScrollY , range ) ; final int consumedByScroll = getScrollY ( ) - oldScrollY ; unconsumed -= consumedByScroll ; mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , unconsumed , mScrollOffset , ViewCompat . TYPE_NON_TOUCH , mScrollConsumed ) ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; unconsumed -= mScrollConsumed [ <NUM_LIT> ] ; } boolean isScrollFinish = mScroller . isFinished ( ) || unconsumed != <NUM_LIT> ; if ( ! isScrollFinish ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } else { mScroller . forceFinished ( true ) ; stopNestedScroll ( ViewCompat . TYPE_NON_TOUCH ) ; } } } @ Override public boolean isNestedScrollingEnabled ( ) { return mChildHelper . isNestedScrollingEnabled ( ) ; } @ Override public int getNestedScrollAxes ( ) { return ViewCompat . SCROLL_AXIS_NONE ; } @ Override public void setNestedScrollingEnabled ( boolean enabled ) { mChildHelper . setNestedScrollingEnabled ( enabled ) ; } @ Override public boolean startNestedScroll ( int axes ) { return mChildHelper . startNestedScroll ( axes ) ; } @ Override public boolean startNestedScroll ( int axes , int type ) { return mChildHelper . startNestedScroll ( axes , type ) ; } @ Override public void stopNestedScroll ( ) { mChildHelper . stopNestedScroll ( ) ; } @ Override public void stopNestedScroll ( int type ) { mChildHelper . stopNestedScroll ( type ) ; } @ Override public boolean hasNestedScrollingParent ( ) { return mChildHelper . hasNestedScrollingParent ( ) ; } @ Override public boolean hasNestedScrollingParent ( int type ) { return mChildHelper . hasNestedScrollingParent ( type ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow ) { return mChildHelper . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , @ Nullable int [ ] consumed , @ Nullable int [ ] offsetInWindow , int type ) { return mChildHelper . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow , type ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow ) { return mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , @ Nullable int [ ] offsetInWindow , int type ) { return mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type ) ; } @ Override public void dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , @ Nullable int [ ] offsetInWindow , int type , @ NonNull int [ ] consumed ) { mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type , consumed ) ; } @ Override public boolean dispatchNestedPreFling ( float velocityX , float velocityY ) { return mChildHelper . dispatchNestedPreFling ( velocityX , velocityY ) ; } @ Override public boolean dispatchNestedFling ( float velocityX , float velocityY , boolean consumed ) { return mChildHelper . dispatchNestedFling ( velocityX , velocityY , consumed ) ; } } </s>
<s> package com . reactnative . nestedscroll ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ReactShadowNode ; public class NestedScrollViewShadowNode extends LayoutShadowNode { private final static String TAG = "<STR_LIT>" ; @ Override public void setLocalData ( Object data ) { if ( data instanceof NestedScrollViewLocalData ) { NestedScrollViewLocalData nestedScrollViewLocalData = ( ( NestedScrollViewLocalData ) data ) ; ReactShadowNode < ? > parent = getChildAt ( <NUM_LIT> ) ; float parentNodeH = nestedScrollViewLocalData . headerNodeH + nestedScrollViewLocalData . contentNodeH ; setNodeHeight ( parent , parentNodeH ) ; for ( int i = <NUM_LIT> , count = parent . getChildCount ( ) ; i < count ; i ++ ) { ReactShadowNode < ? > shadowNode = parent . getChildAt ( i ) ; if ( NestedScrollViewHeaderManager . REACT_CLASS . equals ( ( shadowNode . getViewClass ( ) ) ) ) { continue ; } float childNodeH = nestedScrollViewLocalData . contentNodeH ; setNodeHeight ( shadowNode , childNodeH ) ; } } } void setNodeHeight ( ReactShadowNode < ? > shadowNode , float h ) { shadowNode . setStyleMinHeight ( h ) ; shadowNode . setStyleMaxHeight ( h ) ; } } </s>
<s> package com . reactnative . activityindicator ; import android . content . Context ; import android . graphics . Color ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . SimpleViewManager ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . yoga . YogaMeasureFunction ; import com . facebook . yoga . YogaMeasureMode ; import com . facebook . yoga . YogaMeasureOutput ; import com . facebook . yoga . YogaNode ; public class ActivityIndicatorManager extends SimpleViewManager < ActivityIndicator > { public static final String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected ActivityIndicator createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new ActivityIndicator ( reactContext ) ; } @ Override public Class getShadowNodeClass ( ) { return ActivityIndicatorShadowNode . class ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new ActivityIndicatorShadowNode ( ) ; } @ ReactProp ( name = "<STR_LIT>" , defaultBoolean = true ) public void setAnimating ( ActivityIndicator view , boolean animating ) { view . setAnimating ( animating ) ; } @ ReactProp ( name = "<STR_LIT>" , customType = "<STR_LIT>" ) public void setColor ( ActivityIndicator view , @ Nullable Integer color ) { if ( color != null ) { view . setColor ( color ) ; } else { view . setColor ( Color . parseColor ( "<STR_LIT>" ) ) ; } } @ ReactProp ( name = "<STR_LIT>" ) public void setSize ( ActivityIndicator view , @ Nullable String size ) { if ( size != null && size . equals ( "<STR_LIT>" ) ) { view . setSize ( ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ) ; } else { view . setSize ( ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ) ; } } @ Override public long measure ( Context context , ReadableMap localData , ReadableMap props , ReadableMap state , float width , YogaMeasureMode widthMode , float height , YogaMeasureMode heightMode , @ Nullable float [ ] attachmentsPositions ) { String sizeStr = props . getString ( "<STR_LIT>" ) ; if ( sizeStr == null ) { sizeStr = "<STR_LIT>" ; } int size = sizeStr . equals ( "<STR_LIT>" ) ? <NUM_LIT> : <NUM_LIT> ; return YogaMeasureOutput . make ( size , size ) ; } static class ActivityIndicatorShadowNode extends LayoutShadowNode implements YogaMeasureFunction { private String mSize ; private ActivityIndicatorShadowNode ( ) { initMeasureFunction ( ) ; } private void initMeasureFunction ( ) { setMeasureFunction ( this ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setSize ( @ Nullable String size ) { if ( mSize == null || ! mSize . equals ( size ) ) { mSize = size ; dirty ( ) ; } } @ Override public long measure ( YogaNode node , float width , YogaMeasureMode widthMode , float height , YogaMeasureMode heightMode ) { if ( mSize == null ) { mSize = "<STR_LIT>" ; } int size = ( int ) ( PixelUtil . toPixelFromDIP ( mSize . equals ( "<STR_LIT>" ) ? <NUM_LIT> : <NUM_LIT> ) + <NUM_LIT> ) ; return YogaMeasureOutput . make ( size , size ) ; } } } </s>
<s> package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableType ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import com . reactnative . pulltorefresh . event . OffsetChangedEvent ; import com . reactnative . pulltorefresh . event . RefreshEvent ; import com . reactnative . pulltorefresh . event . StateChangedEvent ; import java . util . Map ; public class PullToRefreshFooterManager extends ReactViewManager { public final static String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new PullToRefreshFooter ( context ) ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new PullToRefreshFooterShadowNode ( ) ; } @ Override public Class < ? extends LayoutShadowNode > getShadowNodeClass ( ) { return PullToRefreshFooterShadowNode . class ; } @ ReactProp ( name = "<STR_LIT>" ) public void setRefreshing ( PullToRefreshFooter footer , boolean refreshing ) { footer . setLoadingMore ( refreshing ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setNoMoreData ( PullToRefreshFooter footer , boolean noMoreData ) { footer . setNoMoreData ( noMoreData ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setManual ( PullToRefreshFooter footer , boolean manual ) { footer . setAutoLoadMore ( ! manual ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( RefreshEvent . Name , MapBuilder . of ( "<STR_LIT>" , RefreshEvent . JSEventName ) ) . put ( StateChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ Override public void receiveCommand ( ReactViewGroup root , String commandId , @ Nullable ReadableArray args ) { if ( root instanceof PullToRefreshFooter ) { PullToRefreshFooter footer = ( PullToRefreshFooter ) root ; if ( "<STR_LIT>" . equals ( commandId ) ) { if ( args != null && args . getType ( <NUM_LIT> ) == ReadableType . Boolean ) { footer . setLoadingMore ( args . getBoolean ( <NUM_LIT> ) ) ; } } } } @ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof PullToRefreshFooter ) { PullToRefreshFooter pullToRefreshFooter = ( ( PullToRefreshFooter ) view ) ; int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; pullToRefreshFooter . setOnRefreshHeaderChangeListener ( new OnRefreshChangeListener ( ) { @ Override public void onRefresh ( ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new RefreshEvent ( surfaceId , viewId ) ) ; } } } @ Override public void onOffsetChange ( int offset ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new OffsetChangedEvent ( surfaceId , viewId , offset ) ) ; } } } @ Override public void onStateChanged ( PullToRefreshState state ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new StateChangedEvent ( surfaceId , viewId , state ) ) ; } } } } ) ; } } } </s>
<s> package com . reactnative . keyboardinsets ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . RCTEventEmitter ; public class KeyboardPositionChangedEvent extends Event < KeyboardPositionChangedEvent > { private final int position ; public KeyboardPositionChangedEvent ( int viewId , int position ) { super ( viewId ) ; this . position = position ; } @ Override public String getEventName ( ) { return "<STR_LIT>" ; } @ Override public void dispatch ( RCTEventEmitter rctEventEmitter ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( position ) ) ; rctEventEmitter . receiveEvent ( getViewTag ( ) , getEventName ( ) , map ) ; } } </s>
<s> package com . reactnative . bottomsheet ; public enum BottomSheetState { COLLAPSED , EXPANDED , HIDDEN , DRAGGING , SETTLING } </s>
<s> package com . reactnative . keyboardinsets ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class KeyboardInsetsPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new KeyboardInsetsModule ( reactContext ) ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new KeyboardInsetsViewManager ( ) ) ; } } </s>
<s> package com . reactnative . overlay ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import android . app . Activity ; import android . os . Bundle ; import android . view . Gravity ; import android . view . ViewGroup ; import android . view . Window ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . annotation . UiThread ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . bridge . ReadableMap ; @ UiThread public class Overlay { final Activity activity ; final String moduleName ; final ReactInstanceManager reactInstanceManager ; OverlayRootView rootView ; ViewGroup decorView ; public Overlay ( @ NonNull Activity activity , String moduleName , ReactInstanceManager reactInstanceManager ) { this . activity = activity ; this . moduleName = moduleName ; this . reactInstanceManager = reactInstanceManager ; } public void show ( ReadableMap props , ReadableMap options ) { OverlayRootView reactRootView = createReactRootView ( ) ; if ( options . hasKey ( "<STR_LIT>" ) ) { reactRootView . setShouldConsumeTouchEvent ( ! options . getBoolean ( "<STR_LIT>" ) ) ; } this . rootView = reactRootView ; startReactApplication ( reactRootView , Arguments . toBundle ( props ) ) ; decorView = getDecorView ( ) ; if ( decorView != null ) { decorView . addView ( reactRootView ) ; } } public void hide ( ) { if ( decorView != null ) { decorView . removeView ( rootView ) ; decorView = null ; } unmountReactView ( ) ; } public void update ( ) { ViewGroup decorView = getDecorView ( ) ; if ( decorView != null && decorView != this . decorView ) { this . decorView . removeView ( rootView ) ; this . decorView = decorView ; decorView . addView ( rootView ) ; } } private void unmountReactView ( ) { ReactContext reactContext = reactInstanceManager . getCurrentReactContext ( ) ; if ( reactContext == null || ! reactContext . hasActiveCatalystInstance ( ) ) { return ; } if ( rootView != null ) { rootView . unmountReactApplication ( ) ; rootView = null ; } } private void startReactApplication ( OverlayRootView reactRootView , Bundle props ) { reactRootView . startReactApplication ( reactInstanceManager , moduleName , props ) ; } private OverlayRootView createReactRootView ( ) { OverlayRootView reactRootView = new OverlayRootView ( activity ) ; reactRootView . setLayoutParams ( new FrameLayout . LayoutParams ( MATCH_PARENT , MATCH_PARENT , Gravity . CENTER ) ) ; return reactRootView ; } private ViewGroup getDecorView ( ) { Window window = activity . getWindow ( ) ; if ( window == null ) { return null ; } return ( ViewGroup ) window . getDecorView ( ) ; } } </s>
<s> package com . reactnative . wheelpicker . wheel ; import java . util . TimerTask ; public final class SmoothScrollTimerTask extends TimerTask { private int realTotalOffset ; private int realOffset ; private int offset ; private final WheelView wheelView ; public SmoothScrollTimerTask ( WheelView wheelView , int offset ) { this . wheelView = wheelView ; this . offset = offset ; realTotalOffset = Integer . MAX_VALUE ; realOffset = <NUM_LIT> ; } @ Override public final void run ( ) { if ( realTotalOffset == Integer . MAX_VALUE ) { realTotalOffset = offset ; } realOffset = ( int ) ( ( float ) realTotalOffset * <NUM_LIT> ) ; if ( realOffset == <NUM_LIT> ) { if ( realTotalOffset < <NUM_LIT> ) { realOffset = - <NUM_LIT> ; } else { realOffset = <NUM_LIT> ; } } if ( Math . abs ( realTotalOffset ) <= <NUM_LIT> ) { wheelView . cancelFuture ( ) ; wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_ITEM_SELECTED ) ; } else { wheelView . setTotalScrollY ( wheelView . getTotalScrollY ( ) + realOffset ) ; if ( ! wheelView . isLoop ( ) ) { float itemHeight = wheelView . getItemHeight ( ) ; float top = ( float ) ( - wheelView . getInitPosition ( ) ) * itemHeight ; float bottom = ( float ) ( wheelView . getItemsCount ( ) - <NUM_LIT> - wheelView . getInitPosition ( ) ) * itemHeight ; if ( wheelView . getTotalScrollY ( ) <= top || wheelView . getTotalScrollY ( ) >= bottom ) { wheelView . setTotalScrollY ( wheelView . getTotalScrollY ( ) - realOffset ) ; wheelView . cancelFuture ( ) ; wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_ITEM_SELECTED ) ; return ; } } wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_INVALIDATE_LOOP_VIEW ) ; realTotalOffset = realTotalOffset - realOffset ; } } } </s>
<s> package com . reactnative . wheelpicker . wheel ; import android . view . MotionEvent ; public final class LoopViewGestureListener extends android . view . GestureDetector . SimpleOnGestureListener { private final WheelView wheelView ; public LoopViewGestureListener ( WheelView wheelView ) { this . wheelView = wheelView ; } @ Override public final boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) { wheelView . scrollBy ( velocityY ) ; return true ; } } </s>
<s> package com . reactnative . pulltorefresh ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . View ; import android . widget . ScrollView ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . views . view . ReactViewGroup ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; import com . scwang . smart . refresh . layout . api . RefreshLayout ; import com . scwang . smart . refresh . layout . constant . RefreshState ; import com . scwang . smart . refresh . layout . constant . SpinnerStyle ; @ SuppressLint ( "<STR_LIT>" ) public class PullToRefreshHeader extends ReactViewGroup implements RefreshHeader { private RefreshKernel mRefreshKernel ; private OnRefreshChangeListener onRefreshChangeListener ; private boolean mIsRefreshing = false ; public void setOnRefreshHeaderChangeListener ( OnRefreshChangeListener onRefreshChangeListener ) { this . onRefreshChangeListener = onRefreshChangeListener ; } public PullToRefreshHeader ( Context context ) { super ( context ) ; } @ NonNull @ Override public View getView ( ) { return this ; } public void setRefreshing ( boolean refreshing ) { mIsRefreshing = refreshing ; if ( refreshing ) { beginRefresh ( ) ; } else { finishRefresh ( ) ; } } public void beginRefresh ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isFooter && ! refreshState . isOpening ) { View scrollable = mRefreshKernel . getRefreshContent ( ) . getScrollableView ( ) ; if ( scrollable instanceof ScrollView ) { ScrollView scrollView = ( ScrollView ) scrollable ; scrollView . smoothScrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } else { scrollable . scrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } mRefreshKernel . getRefreshLayout ( ) . autoRefresh ( ) ; } } } public void finishRefresh ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isFooter && ! refreshState . isFinishing ) { mRefreshKernel . getRefreshLayout ( ) . finishRefresh ( ) ; } } } @ NonNull @ Override public SpinnerStyle getSpinnerStyle ( ) { return SpinnerStyle . Translate ; } @ Override public void setPrimaryColors ( int ... colors ) { } @ Override public void onInitialized ( @ NonNull RefreshKernel kernel , int height , int maxDragHeight ) { mRefreshKernel = kernel ; mRefreshKernel . getRefreshLayout ( ) . setOnRefreshListener ( refreshLayout -> { if ( onRefreshChangeListener != null && refreshLayout . getState ( ) == RefreshState . Refreshing ) { onRefreshChangeListener . onRefresh ( ) ; } } ) ; setRefreshing ( mIsRefreshing ) ; } @ Override public void onMoving ( boolean isDragging , float percent , int offset , int height , int maxDragHeight ) { if ( isDragging && onRefreshChangeListener != null ) { onRefreshChangeListener . onOffsetChange ( offset ) ; } } @ Override public void onReleased ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int measureMode = MeasureSpec . getMode ( heightMeasureSpec ) ; if ( measureMode == MeasureSpec . AT_MOST ) { heightMeasureSpec = MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ; } super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( getParent ( ) instanceof PullToRefresh && mRefreshKernel == null ) { PullToRefresh refreshLayout = ( PullToRefresh ) getParent ( ) ; int h = MeasureSpec . getSize ( heightMeasureSpec ) ; refreshLayout . setHeaderHeightPx ( h ) ; } } PullToRefreshHeaderLocalData headerLocalData = new PullToRefreshHeaderLocalData ( ) ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( headerLocalData . viewRect . top == top && headerLocalData . viewRect . bottom == bottom && headerLocalData . viewRect . left == left && headerLocalData . viewRect . right == right ) { return ; } headerLocalData . viewRect . top = top ; headerLocalData . viewRect . bottom = bottom ; headerLocalData . viewRect . left = left ; headerLocalData . viewRect . right = right ; Context context = getContext ( ) ; if ( context instanceof ReactContext ) { ReactContext reactContext = ( ReactContext ) context ; UIManagerModule uiManagerModule = reactContext . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule != null ) { uiManagerModule . setViewLocalData ( getId ( ) , headerLocalData ) ; } } } @ Override public void onStartAnimator ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public int onFinish ( @ NonNull RefreshLayout refreshLayout , boolean success ) { return <NUM_LIT> ; } @ Override public void onHorizontalDrag ( float percentX , int offsetX , int offsetMax ) { } @ Override public boolean isSupportHorizontalDrag ( ) { return false ; } @ Override public boolean autoOpen ( int duration , float dragRate , boolean animationOnly ) { return false ; } @ Override public void onStateChanged ( @ NonNull RefreshLayout refreshLayout , @ NonNull RefreshState oldState , @ NonNull RefreshState newState ) { if ( onRefreshChangeListener != null ) { PullToRefreshState oldPullToRefreshState = convertRefreshStateToPullToRefreshState ( oldState ) ; PullToRefreshState newPullToRefreshState = convertRefreshStateToPullToRefreshState ( newState ) ; if ( newPullToRefreshState != oldPullToRefreshState ) { onRefreshChangeListener . onStateChanged ( newPullToRefreshState ) ; } } } @ Override public PointerEvents getPointerEvents ( ) { RefreshState refreshState = mRefreshKernel != null ? mRefreshKernel . getRefreshLayout ( ) . getState ( ) : RefreshState . None ; if ( refreshState . isHeader && refreshState . isOpening ) { return super . getPointerEvents ( ) ; } return PointerEvents . NONE ; } private PullToRefreshState convertRefreshStateToPullToRefreshState ( RefreshState state ) { if ( state == RefreshState . ReleaseToRefresh ) { return PullToRefreshState . Coming ; } if ( state == RefreshState . Refreshing || state == RefreshState . RefreshReleased ) { return PullToRefreshState . Refreshing ; } return PullToRefreshState . Idle ; } } </s>
<s> package com . reactnative . wheelpicker . wheel ; public interface WheelAdapter < T > { int getItemsCount ( ) ; T getItem ( int index ) ; int indexOf ( T o ) ; } </s>
<s> package com . reactnative . nestedscrollwebview ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import com . reactnativecommunity . webview . RNCNestedScrollWebViewManager ; public class NestedScrollWebViewPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } } </s>
<s> package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableType ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import com . reactnative . pulltorefresh . event . OffsetChangedEvent ; import com . reactnative . pulltorefresh . event . RefreshEvent ; import com . reactnative . pulltorefresh . event . StateChangedEvent ; import java . util . Map ; public class PullToRefreshHeaderManager extends ReactViewManager { public final static String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new PullToRefreshHeader ( context ) ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new PullToRefreshHeaderShadowNode ( ) ; } @ Override public Class < ? extends LayoutShadowNode > getShadowNodeClass ( ) { return PullToRefreshHeaderShadowNode . class ; } @ ReactProp ( name = "<STR_LIT>" ) public void setRefreshing ( PullToRefreshHeader pullToRefreshHeader , boolean refreshing ) { pullToRefreshHeader . setRefreshing ( refreshing ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( RefreshEvent . Name , MapBuilder . of ( "<STR_LIT>" , RefreshEvent . JSEventName ) ) . put ( StateChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ Override public void receiveCommand ( ReactViewGroup root , String commandId , @ Nullable ReadableArray args ) { if ( root instanceof PullToRefreshHeader ) { PullToRefreshHeader header = ( PullToRefreshHeader ) root ; if ( "<STR_LIT>" . equals ( commandId ) ) { if ( args != null && args . getType ( <NUM_LIT> ) == ReadableType . Boolean ) { header . setRefreshing ( args . getBoolean ( <NUM_LIT> ) ) ; } } } } @ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof PullToRefreshHeader ) { PullToRefreshHeader pullToRefreshHeader = ( ( PullToRefreshHeader ) view ) ; int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; pullToRefreshHeader . setOnRefreshHeaderChangeListener ( new OnRefreshChangeListener ( ) { @ Override public void onRefresh ( ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new RefreshEvent ( surfaceId , viewId ) ) ; } } } @ Override public void onOffsetChange ( int offset ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new OffsetChangedEvent ( surfaceId , viewId , offset ) ) ; } } } @ Override public void onStateChanged ( PullToRefreshState state ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new StateChangedEvent ( surfaceId , viewId , state ) ) ; } } } } ) ; } } } </s>
<s> package com . reactnative . wheelpicker . wheel ; import java . util . TimerTask ; public final class InertiaTimerTask extends TimerTask { private float mCurrentVelocityY ; private final float mFirstVelocityY ; private final WheelView mWheelView ; public InertiaTimerTask ( WheelView wheelView , float velocityY ) { super ( ) ; this . mWheelView = wheelView ; this . mFirstVelocityY = velocityY ; mCurrentVelocityY = Integer . MAX_VALUE ; } @ Override public final void run ( ) { if ( mCurrentVelocityY == Integer . MAX_VALUE ) { if ( Math . abs ( mFirstVelocityY ) > <NUM_LIT> ) { mCurrentVelocityY = mFirstVelocityY > <NUM_LIT> ? <NUM_LIT> : - <NUM_LIT> ; } else { mCurrentVelocityY = mFirstVelocityY ; } } if ( Math . abs ( mCurrentVelocityY ) >= <NUM_LIT> && Math . abs ( mCurrentVelocityY ) <= <NUM_LIT> ) { mWheelView . cancelFuture ( ) ; mWheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_SMOOTH_SCROLL ) ; return ; } int dy = ( int ) ( mCurrentVelocityY / <NUM_LIT> ) ; mWheelView . setTotalScrollY ( mWheelView . getTotalScrollY ( ) - dy ) ; if ( ! mWheelView . isLoop ( ) ) { float itemHeight = mWheelView . getItemHeight ( ) ; float top = ( - mWheelView . getInitPosition ( ) ) * itemHeight ; float bottom = ( mWheelView . getItemsCount ( ) - <NUM_LIT> - mWheelView . getInitPosition ( ) ) * itemHeight ; if ( mWheelView . getTotalScrollY ( ) - itemHeight * <NUM_LIT> < top ) { top = mWheelView . getTotalScrollY ( ) + dy ; } else if ( mWheelView . getTotalScrollY ( ) + itemHeight * <NUM_LIT> > bottom ) { bottom = mWheelView . getTotalScrollY ( ) + dy ; } if ( mWheelView . getTotalScrollY ( ) <= top ) { mCurrentVelocityY = <NUM_LIT> ; mWheelView . setTotalScrollY ( ( int ) top ) ; } else if ( mWheelView . getTotalScrollY ( ) >= bottom ) { mWheelView . setTotalScrollY ( ( int ) bottom ) ; mCurrentVelocityY = - <NUM_LIT> ; } } if ( mCurrentVelocityY < <NUM_LIT> ) { mCurrentVelocityY = mCurrentVelocityY + <NUM_LIT> ; } else { mCurrentVelocityY = mCurrentVelocityY - <NUM_LIT> ; } mWheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_INVALIDATE_LOOP_VIEW ) ; } } </s>
<s> package com . reactnative . wheelpicker ; import androidx . annotation . NonNull ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class WheelPickerPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new PickerViewManager ( ) ) ; } } </s>
<s> package com . reactnative . overlay ; import android . app . Activity ; import androidx . annotation . NonNull ; import androidx . core . graphics . Insets ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . common . logging . FLog ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . bridge . JavaOnlyMap ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import java . util . HashMap ; public class OverlayModule extends ReactContextBaseJavaModule implements LifecycleEventListener { private final HashMap < String , Overlay > overlays = new HashMap < > ( ) ; private final ReactApplicationContext reactContext ; private final ReactNativeHost reactNativeHost ; public OverlayModule ( ReactApplicationContext reactContext , ReactNativeHost reactNativeHost ) { super ( reactContext ) ; this . reactContext = reactContext ; this . reactNativeHost = reactNativeHost ; reactContext . addLifecycleEventListener ( this ) ; } @ Override public void invalidate ( ) { reactContext . removeLifecycleEventListener ( this ) ; final Activity activity = getCurrentActivity ( ) ; if ( activity == null || activity . isFinishing ( ) ) { return ; } UiThreadUtil . runOnUiThread ( this :: handleDestroy ) ; } private void handleDestroy ( ) { for ( String key : overlays . keySet ( ) ) { Overlay overlay = overlays . get ( key ) ; overlay . hide ( ) ; } overlays . clear ( ) ; } @ NonNull @ Override public String getName ( ) { return "<STR_LIT>" ; } @ ReactMethod public void show ( final String moduleName , final ReadableMap options ) { UiThreadUtil . runOnUiThread ( ( ) -> { final Activity activity = getCurrentActivity ( ) ; if ( activity == null || activity . isFinishing ( ) ) { return ; } Overlay overlay = overlays . get ( moduleName ) ; if ( overlay != null ) { overlay . update ( ) ; return ; } int id = options . getInt ( "<STR_LIT>" ) ; WritableMap props = JavaOnlyMap . deepClone ( options ) ; props . putMap ( "<STR_LIT>" , getInsets ( activity ) ) ; overlay = new Overlay ( activity , moduleName , reactNativeHost . getReactInstanceManager ( ) ) ; overlay . show ( props , options ) ; overlays . put ( genOverlayKey ( moduleName , id ) , overlay ) ; } ) ; } @ ReactMethod public void hide ( String moduleName , int id ) { UiThreadUtil . runOnUiThread ( ( ) -> { Overlay overlay = overlays . get ( genOverlayKey ( moduleName , id ) ) ; if ( overlay == null ) { return ; } overlays . remove ( genOverlayKey ( moduleName , id ) ) ; overlay . hide ( ) ; } ) ; } @ Override public void onHostResume ( ) { } @ Override public void onHostPause ( ) { } @ Override public void onHostDestroy ( ) { FLog . i ( "<STR_LIT>" , "<STR_LIT>" ) ; handleDestroy ( ) ; } private String genOverlayKey ( String moduleName , int id ) { return moduleName + "<STR_LIT>" + id ; } private ReadableMap getInsets ( Activity activity ) { WindowInsetsCompat windowInsets = ViewCompat . getRootWindowInsets ( activity . getWindow ( ) . getDecorView ( ) ) ; assert windowInsets != null ; Insets navigationBarInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . navigationBars ( ) ) ; Insets statusBarInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . statusBars ( ) ) ; Insets displayCutoutInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . displayCutout ( ) ) ; WritableMap insets = new JavaOnlyMap ( ) ; insets . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( Math . max ( navigationBarInsets . left , displayCutoutInsets . left ) ) ) ; insets . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( statusBarInsets . top ) ) ; insets . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( Math . max ( navigationBarInsets . right , displayCutoutInsets . right ) ) ) ; insets . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( navigationBarInsets . bottom ) ) ; return insets ; } } </s>
<s> package com . reactnative . nestedscroll ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class NestedViewHeaderScrollEvent extends Event < NestedViewHeaderScrollEvent > { public static final String Name = "<STR_LIT>" ; public static final String JSEventName = "<STR_LIT>" ; private final float y ; public NestedViewHeaderScrollEvent ( int surfaceId , int viewTag , int offset ) { super ( surfaceId , viewTag ) ; this . y = PixelUtil . toDIPFromPixel ( offset ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap event = Arguments . createMap ( ) ; WritableMap offset = Arguments . createMap ( ) ; offset . putDouble ( "<STR_LIT>" , y ) ; offset . putDouble ( "<STR_LIT>" , <NUM_LIT> ) ; event . putMap ( "<STR_LIT>" , offset ) ; return event ; } } </s>
<s> package com . reactnative . nestedscroll ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class NestedScrollViewPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new NestedScrollViewHeaderManager ( ) , new NestedScrollViewManager ( ) ) ; } } </s>
<s> package com . reactnative . wheelpicker . wheel ; import android . os . Handler ; import android . os . Message ; public final class MessageHandler extends Handler { public static final int WHAT_INVALIDATE_LOOP_VIEW = <NUM_LIT> ; public static final int WHAT_SMOOTH_SCROLL = <NUM_LIT> ; public static final int WHAT_ITEM_SELECTED = <NUM_LIT> ; private final WheelView wheelView ; public MessageHandler ( WheelView wheelView ) { this . wheelView = wheelView ; } @ Override public final void handleMessage ( Message msg ) { switch ( msg . what ) { case WHAT_INVALIDATE_LOOP_VIEW : wheelView . invalidate ( ) ; break ; case WHAT_SMOOTH_SCROLL : wheelView . smoothScroll ( WheelView . ACTION . FLING ) ; break ; case WHAT_ITEM_SELECTED : wheelView . onItemSelected ( ) ; break ; } } } </s>
<s> package com . example . myuidemo ; import android . app . Application ; import com . facebook . common . logging . FLog ; import com . facebook . react . PackageList ; import com . facebook . react . ReactApplication ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . ReactPackage ; import com . facebook . soloader . SoLoader ; import com . reactnative . hybridnavigation . ReactBridgeManager ; import java . util . List ; public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost ( this ) { @ Override public boolean getUseDeveloperSupport ( ) { return BuildConfig . DEBUG ; } @ Override protected List < ReactPackage > getPackages ( ) { @ SuppressWarnings ( "<STR_LIT>" ) List < ReactPackage > packages = new PackageList ( this ) . getPackages ( ) ; packages . add ( new MyUiPackage ( ) ) ; return packages ; } @ Override protected String getJSMainModuleName ( ) { return "<STR_LIT>" ; } } ; @ Override public ReactNativeHost getReactNativeHost ( ) { return mReactNativeHost ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; SoLoader . init ( this , false ) ; ReactBridgeManager bridgeManager = ReactBridgeManager . get ( ) ; bridgeManager . install ( getReactNativeHost ( ) ) ; FLog . setMinimumLoggingLevel ( FLog . INFO ) ; } } </s>
<s> package com . example . myuidemo ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import com . reactnativecommunity . webview . RNCNestedScrollWebViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class MyUiPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new RNCNestedScrollWebViewManager ( ) ) ; } } </s>
<s> package com . reactnative . wheelpicker ; import android . content . Context ; import android . view . Gravity ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . RCTEventEmitter ; import com . reactnative . wheelpicker . wheel . OnItemSelectedListener ; import com . reactnative . wheelpicker . wheel . WheelAdapter ; import com . reactnative . wheelpicker . wheel . WheelView ; import java . util . Collections ; import java . util . List ; public class PickerView extends FrameLayout implements WheelAdapter , OnItemSelectedListener { final WheelView wheelView ; public PickerView ( @ NonNull Context context ) { super ( context ) ; wheelView = new WheelView ( context ) ; LayoutParams layoutParams = new LayoutParams ( - <NUM_LIT> , - <NUM_LIT> ) ; layoutParams . gravity = Gravity . CENTER ; addView ( wheelView , layoutParams ) ; wheelView . setTextXOffset ( <NUM_LIT> ) ; wheelView . setAdapter ( this ) ; wheelView . setOnItemSelectedListener ( this ) ; wheelView . setCyclic ( false ) ; setClipChildren ( true ) ; } List < String > items = Collections . emptyList ( ) ; public void setItems ( List < String > items ) { this . items = items ; wheelView . setAdapter ( this ) ; if ( items . size ( ) > selectedIndex ) { wheelView . setCurrentItem ( selectedIndex ) ; } } int selectedIndex = <NUM_LIT> ; public void setSelectedItem ( int index ) { selectedIndex = index ; if ( items . size ( ) > index ) { wheelView . setCurrentItem ( index ) ; } } public void setCyclic ( boolean cyclic ) { wheelView . setCyclic ( cyclic ) ; } public void setTextSize ( int size ) { wheelView . setTextSize ( size ) ; } public void setItemHeight ( float height ) { wheelView . setItemHeight ( height ) ; } public void setTextColorOut ( int textColorOut ) { wheelView . setTextColorOut ( textColorOut ) ; } public void setTextColorCenter ( int textColorCenter ) { wheelView . setTextColorCenter ( textColorCenter ) ; } @ Override public int getItemsCount ( ) { return items . size ( ) ; } @ Override public Object getItem ( int index ) { return items . get ( index ) ; } @ Override public int indexOf ( Object o ) { return items . indexOf ( o ) ; } @ Override public void onItemSelected ( int index ) { if ( getItemsCount ( ) > index ) { WritableMap event = Arguments . createMap ( ) ; event . putInt ( "<STR_LIT>" , index ) ; ReactContext reactContext = ( ReactContext ) getContext ( ) ; reactContext . getJSModule ( RCTEventEmitter . class ) . receiveEvent ( getId ( ) , "<STR_LIT>" , event ) ; } } } </s>
<s> package com . reactnative . overlay ; import androidx . annotation . NonNull ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Collections ; import java . util . List ; public class OverlayPackage implements ReactPackage { private final ReactNativeHost reactNativeHost ; public OverlayPackage ( ReactNativeHost reactNativeHost ) { this . reactNativeHost = reactNativeHost ; } @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new OverlayModule ( reactContext , reactNativeHost ) ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } } </s>
<s> package com . reactnative . wheelpicker . wheel ; public interface OnItemSelectedListener { void onItemSelected ( int index ) ; } </s>
<s> package com . reactnative . imagecrop ; import com . facebook . react . bridge . ReadableMap ; public class ObjectRect { private int top ; private int left ; private int width ; private int height ; public ObjectRect ( int top , int left , int width , int height ) { this . top = top ; this . left = left ; this . width = width ; this . height = height ; } public static ObjectRect fromReadableMap ( ReadableMap map ) { int top = - <NUM_LIT> , left = - <NUM_LIT> , width = - <NUM_LIT> , height = - <NUM_LIT> ; if ( map . hasKey ( "<STR_LIT>" ) ) { top = map . getInt ( "<STR_LIT>" ) ; } if ( map . hasKey ( "<STR_LIT>" ) ) { left = map . getInt ( "<STR_LIT>" ) ; } if ( map . hasKey ( "<STR_LIT>" ) ) { width = map . getInt ( "<STR_LIT>" ) ; } if ( map . hasKey ( "<STR_LIT>" ) ) { height = map . getInt ( "<STR_LIT>" ) ; } if ( top != - <NUM_LIT> && left != - <NUM_LIT> && width != - <NUM_LIT> && height != - <NUM_LIT> ) { return new ObjectRect ( top , left , width , height ) ; } return null ; } public int getTop ( ) { return top ; } public void setTop ( int top ) { this . top = top ; } public int getLeft ( ) { return left ; } public void setLeft ( int left ) { this . left = left ; } public int getWidth ( ) { return width ; } public void setWidth ( int width ) { this . width = width ; } public int getHeight ( ) { return height ; } public void setHeight ( int height ) { this . height = height ; } } </s>
<s> package com . reactnative . keyboardinsets ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . ViewCompat ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class KeyboardInsetsViewManager extends ViewGroupManager < KeyboardInsetsView > { public static final String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected KeyboardInsetsView createViewInstance ( @ NonNull ThemedReactContext themedReactContext ) { KeyboardInsetsView view = new KeyboardInsetsView ( themedReactContext ) ; KeyboardInsetsCallback callback = new KeyboardInsetsCallback ( view , themedReactContext ) ; ViewCompat . setWindowInsetsAnimationCallback ( view , callback ) ; ViewCompat . setOnApplyWindowInsetsListener ( view , callback ) ; return view ; } @ ReactProp ( name = "<STR_LIT>" ) public void setMode ( KeyboardInsetsView view , String mode ) { view . setMode ( mode ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setExtraHeight ( KeyboardInsetsView view , float extraHeight ) { view . setExtraHeight ( extraHeight ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . of ( "<STR_LIT>" , MapBuilder . of ( "<STR_LIT>" , "<STR_LIT>" ) , "<STR_LIT>" , MapBuilder . of ( "<STR_LIT>" , "<STR_LIT>" ) ) ; } } </s>
<s> package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class PullToRefreshPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new PullToRefreshManager ( ) , new PullToRefreshHeaderManager ( ) , new PullToRefreshFooterManager ( ) ) ; } } </s>
<s> package com . reactnative . pulltorefresh ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import java . util . HashMap ; public class PullToRefreshManager extends ViewGroupManager < PullToRefresh > { public final static String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected PullToRefresh createViewInstance ( @ NonNull ThemedReactContext reactContext ) { PullToRefresh pullToRefresh = new PullToRefresh ( reactContext ) ; pullToRefresh . setEnableOverScrollBounce ( false ) ; pullToRefresh . setEnableOverScrollDrag ( true ) ; pullToRefresh . setEnableRefresh ( false ) ; pullToRefresh . setEnableLoadMore ( false ) ; return pullToRefresh ; } HashMap < Integer , View > reactChildMap = new HashMap < > ( ) ; @ Override public void addView ( PullToRefresh parent , View child , int index ) { if ( child instanceof PullToRefreshHeader ) { parent . setEnableRefresh ( true ) ; parent . setRefreshHeader ( ( RefreshHeader ) child ) ; if ( parent . isLaidOut ( ) ) { ( ( PullToRefreshHeader ) child ) . onInitialized ( parent . getRefreshKernel ( ) , <NUM_LIT> , <NUM_LIT> ) ; } } else if ( child instanceof PullToRefreshFooter ) { parent . setEnableLoadMore ( true ) ; parent . setRefreshFooter ( ( RefreshFooter ) child ) ; if ( parent . isLaidOut ( ) ) { ( ( PullToRefreshFooter ) child ) . onInitialized ( parent . getRefreshKernel ( ) , <NUM_LIT> , <NUM_LIT> ) ; } } else { parent . setRefreshContent ( child ) ; } reactChildMap . put ( index , child ) ; } @ Override public void removeViewAt ( PullToRefresh parent , int index ) { View child = reactChildMap . get ( index ) ; for ( int i = <NUM_LIT> ; i < parent . getChildCount ( ) ; i ++ ) { if ( child == parent . getChildAt ( i ) ) { if ( child instanceof PullToRefreshHeader ) { parent . setEnableRefresh ( false ) ; parent . setOnRefreshListener ( null ) ; } else if ( child instanceof PullToRefreshFooter ) { parent . setEnableLoadMore ( false ) ; parent . setOnLoadMoreListener ( null ) ; } super . removeViewAt ( parent , i ) ; break ; } } reactChildMap . remove ( index ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setOverflow ( PullToRefresh view , @ Nullable String overflow ) { view . setOverflow ( overflow ) ; } @ Override public boolean needsCustomLayoutForChildren ( ) { return true ; } } </s>
<s> package com . reactnative . overlay ; import android . content . Context ; import android . os . Bundle ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . view . ViewTreeObserver ; import androidx . annotation . Nullable ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . ReactRootView ; import java . lang . reflect . Method ; public class OverlayRootView extends ReactRootView { public OverlayRootView ( Context context ) { super ( context ) ; } public OverlayRootView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public OverlayRootView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } private boolean shouldConsumeTouchEvent = true ; public void setShouldConsumeTouchEvent ( boolean consume ) { this . shouldConsumeTouchEvent = consume ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { int action = ev . getAction ( ) & MotionEvent . ACTION_MASK ; if ( action == MotionEvent . ACTION_DOWN ) { onChildStartedNativeGesture ( ev ) ; } return shouldConsumeTouchEvent ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; removeOnGlobalLayoutListener ( ) ; } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; removeOnGlobalLayoutListener ( ) ; } @ Override public void startReactApplication ( ReactInstanceManager reactInstanceManager , String moduleName , @ Nullable Bundle initialProperties ) { super . startReactApplication ( reactInstanceManager , moduleName , initialProperties ) ; removeOnGlobalLayoutListener ( ) ; } private boolean shouldRunApplication = true ; @ Override public void runApplication ( ) { if ( shouldRunApplication ) { shouldRunApplication = false ; super . runApplication ( ) ; } } private boolean hbd_isAttachedToReactInstance ; @ Override public void onAttachedToReactInstance ( ) { super . onAttachedToReactInstance ( ) ; hbd_isAttachedToReactInstance = true ; } @ Override public void setAppProperties ( @ Nullable Bundle appProperties ) { if ( hbd_isAttachedToReactInstance ) { shouldRunApplication = true ; super . setAppProperties ( appProperties ) ; } } @ Override public void unmountReactApplication ( ) { super . unmountReactApplication ( ) ; removeOnGlobalLayoutListener ( ) ; } private ViewTreeObserver . OnGlobalLayoutListener mGlobalLayoutListener ; private ViewTreeObserver . OnGlobalLayoutListener getGlobalLayoutListener ( ) { if ( mGlobalLayoutListener == null ) { try { Method method = ReactRootView . class . getDeclaredMethod ( "<STR_LIT>" ) ; method . setAccessible ( true ) ; mGlobalLayoutListener = ( ViewTreeObserver . OnGlobalLayoutListener ) method . invoke ( this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return mGlobalLayoutListener ; } void addOnGlobalLayoutListener ( ) { removeOnGlobalLayoutListener ( ) ; getViewTreeObserver ( ) . addOnGlobalLayoutListener ( getGlobalLayoutListener ( ) ) ; } void removeOnGlobalLayoutListener ( ) { getViewTreeObserver ( ) . removeOnGlobalLayoutListener ( getGlobalLayoutListener ( ) ) ; } } </s>
<s> package com . reactnative . bottomsheet ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class OffsetChangedEvent extends Event < OffsetChangedEvent > { public static final String Name = "<STR_LIT>" ; public static final String JSEventName = "<STR_LIT>" ; private final int offset ; private final int minOffset ; private final int maxOffset ; public OffsetChangedEvent ( int surfaceId , int viewTag , int offset , int minOffset , int maxOffset ) { super ( surfaceId , viewTag ) ; this . offset = offset ; this . maxOffset = maxOffset ; this . minOffset = minOffset ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { double progress = Math . min ( ( offset - minOffset ) * <NUM_LIT> / ( maxOffset - minOffset ) , <NUM_LIT> ) ; WritableMap data = Arguments . createMap ( ) ; data . putDouble ( "<STR_LIT>" , progress ) ; data . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( offset ) ) ; data . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( minOffset ) ) ; data . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( maxOffset ) ) ; return data ; } } </s>
<s> package com . reactnative . bottomsheet ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . Event ; public class StateChangedEvent extends Event < StateChangedEvent > { public static final String Name = "<STR_LIT>" ; public static final String JSEventName = "<STR_LIT>" ; private final String state ; public StateChangedEvent ( int surfaceId , int viewTag , String state ) { super ( surfaceId , viewTag ) ; this . state = state ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap data = Arguments . createMap ( ) ; data . putString ( "<STR_LIT>" , state ) ; return data ; } } </s>
<s> package com . reactnative . bottomsheet ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class BottomSheetPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new BottomSheetManager ( ) ) ; } } </s>
<s> package com . reactnative . keyboardinsets ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . RCTEventEmitter ; public class KeyboardStatusChangedEvent extends Event < KeyboardStatusChangedEvent > { private final int height ; private final boolean shown ; private final boolean transitioning ; public KeyboardStatusChangedEvent ( int viewTag , int height , boolean shown , boolean transitioning ) { super ( viewTag ) ; this . height = height ; this . shown = shown ; this . transitioning = transitioning ; } @ Override public String getEventName ( ) { return "<STR_LIT>" ; } @ Override public void dispatch ( RCTEventEmitter rctEventEmitter ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( "<STR_LIT>" , PixelUtil . toDIPFromPixel ( height ) ) ; map . putBoolean ( "<STR_LIT>" , transitioning ) ; map . putBoolean ( "<STR_LIT>" , shown ) ; rctEventEmitter . receiveEvent ( getViewTag ( ) , getEventName ( ) , map ) ; } } </s>
<s> package com . reactnative . bottomsheet ; import androidx . annotation . NonNull ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class BottomSheetManager extends ViewGroupManager < BottomSheet > { @ NonNull @ Override public String getName ( ) { return "<STR_LIT>" ; } @ NonNull @ Override protected BottomSheet createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new BottomSheet ( reactContext ) ; } @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( StateChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( "<STR_LIT>" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ ReactProp ( name = "<STR_LIT>" , defaultInt = <NUM_LIT> ) public void setPeekHeight ( BottomSheet view , int dp ) { view . setPeekHeight ( ( int ) ( PixelUtil . toPixelFromDIP ( dp ) + <NUM_LIT> ) ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setState ( BottomSheet view , String state ) { view . setState ( BottomSheetState . valueOf ( state . toUpperCase ( ) ) ) ; } @ ReactProp ( name = "<STR_LIT>" ) public void setDraggable ( BottomSheet view , boolean draggable ) { view . setDraggable ( draggable ) ; } } </s>
<s> package com . reactnative . pulltorefresh ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import androidx . annotation . Nullable ; import androidx . core . view . ViewCompat ; import com . facebook . react . uimanager . ReactOverflowView ; import com . facebook . react . uimanager . events . NativeGestureUtil ; import com . scwang . smart . refresh . layout . SmartRefreshLayout ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; public class PullToRefresh extends SmartRefreshLayout implements ReactOverflowView { private final static String TAG = "<STR_LIT>" ; private final Rect mRect ; private String mOverflow = "<STR_LIT>" ; public PullToRefresh ( Context context ) { super ( context ) ; mRect = new Rect ( ) ; } public void setOverflow ( String overflow ) { mOverflow = overflow ; invalidate ( ) ; } @ Nullable @ Override public String getOverflow ( ) { return mOverflow ; } private final Runnable measureAndLayout = ( ) -> { measure ( View . MeasureSpec . makeMeasureSpec ( getWidth ( ) , View . MeasureSpec . EXACTLY ) , View . MeasureSpec . makeMeasureSpec ( getHeight ( ) , View . MeasureSpec . EXACTLY ) ) ; layout ( getLeft ( ) , getTop ( ) , getRight ( ) , getBottom ( ) ) ; } ; @ Override public void requestLayout ( ) { super . requestLayout ( ) ; post ( measureAndLayout ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { ViewGroup view = ( ViewGroup ) mRefreshContent . getScrollableView ( ) ; String viewName = view . getClass ( ) . getCanonicalName ( ) ; if ( viewName != null && viewName . contains ( "<STR_LIT>" ) ) { if ( mIsBeingDragged ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; } return super . dispatchTouchEvent ( ev ) ; } if ( view . canScrollHorizontally ( - <NUM_LIT> ) || view . canScrollHorizontally ( <NUM_LIT> ) ) { if ( mIsBeingDragged ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; } return super . dispatchTouchEvent ( ev ) ; } if ( ! view . canScrollVertically ( - <NUM_LIT> ) && ! view . canScrollVertically ( <NUM_LIT> ) ) { view . onInterceptTouchEvent ( ev ) ; view . onTouchEvent ( ev ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) { view . startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL ) ; } if ( ev . getAction ( ) == MotionEvent . ACTION_UP || ev . getAction ( ) == MotionEvent . ACTION_CANCEL ) { view . stopNestedScroll ( ) ; } if ( shouldInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } return true ; } } return super . dispatchTouchEvent ( ev ) ; } private int mLastMotionY ; private boolean shouldInterceptTouchEvent ( MotionEvent ev ) { final int action = ev . getAction ( ) ; if ( ( action == MotionEvent . ACTION_MOVE ) && ( mIsBeingDragged ) ) { return true ; } switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_MOVE : { final int y = ( int ) ev . getRawY ( ) ; final int yDiff = Math . abs ( y - mLastMotionY ) ; if ( yDiff >= mTouchSlop ) { mIsBeingDragged = true ; } break ; } case MotionEvent . ACTION_DOWN : { mLastMotionY = ( int ) ev . getRawY ( ) ; break ; } case MotionEvent . ACTION_CANCEL : case MotionEvent . ACTION_UP : mIsBeingDragged = false ; } return mIsBeingDragged ; } public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( super . onInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; return true ; } return false ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; float height = ( float ) ( getMeasuredHeight ( ) * <NUM_LIT> ) ; RefreshHeader header = getRefreshHeader ( ) ; if ( header != null ) { int headerHeight = header . getView ( ) . getMeasuredHeight ( ) ; setHeaderMaxDragRate ( height / headerHeight ) ; } RefreshFooter footer = getRefreshFooter ( ) ; if ( footer != null ) { int footerHeight = footer . getView ( ) . getMeasuredHeight ( ) ; setFooterMaxDragRate ( height / footerHeight ) ; } } @ Override protected void dispatchDraw ( Canvas canvas ) { getDrawingRect ( mRect ) ; if ( ! "<STR_LIT>" . equals ( mOverflow ) ) { canvas . clipRect ( mRect ) ; } super . dispatchDraw ( canvas ) ; } public RefreshKernel getRefreshKernel ( ) { return mKernel ; } } </s>
<s> package com . reactnativecommunity . webview ; import static com . reactnativecommunity . webview . RNCWebViewManager . REACT_CLASS ; import com . facebook . react . module . annotations . ReactModule ; import com . facebook . react . uimanager . ThemedReactContext ; @ ReactModule ( name = REACT_CLASS ) public class RNCNestedScrollWebViewManager extends RNCWebViewManager { @ Override protected RNCWebView createRNCWebViewInstance ( ThemedReactContext reactContext ) { return new RNCNestedScrollWebView ( reactContext ) ; } @ Override public boolean canOverrideExistingModule ( ) { return true ; } } </s>
<s> package com . reactnative . pulltorefresh ; public interface OnRefreshChangeListener { void onRefresh ( ) ; void onOffsetChange ( int offset ) ; void onStateChanged ( PullToRefreshState state ) ; } </s>
<s> package com . reactnative . pulltorefresh . event ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class OffsetChangedEvent extends Event < OffsetChangedEvent > { public static final String Name = "<STR_LIT>" ; public static final String JSEventName = "<STR_LIT>" ; private final float offset ; public OffsetChangedEvent ( int surfaceId , int viewTag , float offset ) { super ( surfaceId , viewTag ) ; this . offset = PixelUtil . toDIPFromPixel ( offset ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( "<STR_LIT>" , offset ) ; return map ; } } </s>
<s> package com . reactnative . nestedscroll ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import java . util . Map ; public class NestedScrollViewHeaderManager extends ReactViewManager { public final static String REACT_CLASS = "<STR_LIT>" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new NestedScrollViewHeader ( context ) ; } @ ReactProp ( name = "<STR_LIT>" , defaultInt = NestedScrollViewHeader . INVALID_STICKY_HEIGHT ) public void setFixedHeight ( NestedScrollViewHeader view , int stickyHeight ) { view . setStickyHeight ( ( int ) PixelUtil . toPixelFromDIP ( stickyHeight ) ) ; } @ ReactProp ( name = "<STR_LIT>" , defaultInt = NestedScrollViewHeader . INVALID_STICKY_BEGIN_INDEX ) public void setStickyHeaderBeginIndex ( NestedScrollViewHeader view , int stickyHeaderBeginIndex ) { view . setStickyHeaderBeginIndex ( stickyHeaderBeginIndex ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( NestedViewHeaderScrollEvent . Name , MapBuilder . of ( "<STR_LIT>" , NestedViewHeaderScrollEvent . JSEventName ) ) . build ( ) ; } @ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof NestedScrollViewHeader ) { ( ( NestedScrollViewHeader ) view ) . setOnScrollChangeListener ( ( NestedScrollView . OnScrollChangeListener ) ( v , scrollX , scrollY , oldScrollX , oldScrollY ) -> { int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { NestedViewHeaderScrollEvent nestedViewHeaderScrollEvent = new NestedViewHeaderScrollEvent ( surfaceId , viewId , scrollY ) ; eventDispatcher . dispatchEvent ( nestedViewHeaderScrollEvent ) ; } } ) ; } } } </s>
<s> package com . reactnative . pulltorefresh ; import android . graphics . Rect ; public class PullToRefreshHeaderLocalData { Rect viewRect = new Rect ( ) ; } </s>
<s> package com . reactnative . nestedscroll ; import android . content . Context ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import com . facebook . react . views . view . ReactViewGroup ; public class NestedScrollViewHeader extends ReactViewGroup { public final static int INVALID_STICKY_HEIGHT = - <NUM_LIT> ; public final static int INVALID_STICKY_BEGIN_INDEX = Integer . MAX_VALUE ; private int mStickyHeight = INVALID_STICKY_HEIGHT ; private int mStickyHeaderBeginIndex = INVALID_STICKY_BEGIN_INDEX ; private androidx . core . widget . NestedScrollView . OnScrollChangeListener mOnScrollChangeListener ; public NestedScrollViewHeader ( @ NonNull Context context ) { super ( context ) ; } public void setOnScrollChangeListener ( androidx . core . widget . NestedScrollView . OnScrollChangeListener onScrollChangeListener ) { this . mOnScrollChangeListener = onScrollChangeListener ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; NestedScrollView nestedScrollView = getParentNestedScrollView ( ) ; if ( nestedScrollView != null && mOnScrollChangeListener != null ) { nestedScrollView . setOnScrollChangeListener ( mOnScrollChangeListener ) ; } } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; notifyStickyHeightChanged ( ) ; } public void setStickyHeight ( int stickyHeight ) { mStickyHeight = stickyHeight ; notifyStickyHeightChanged ( ) ; } public void setStickyHeaderBeginIndex ( int index ) { mStickyHeaderBeginIndex = index ; notifyStickyHeightChanged ( ) ; } public int getStickyHeight ( ) { if ( mStickyHeight >= <NUM_LIT> ) { return Math . min ( mStickyHeight , getHeight ( ) ) ; } if ( mStickyHeaderBeginIndex != INVALID_STICKY_BEGIN_INDEX ) { int stickyHeaderHeight = <NUM_LIT> ; for ( int i = <NUM_LIT> , count = getChildCount ( ) ; i < count ; i ++ ) { View child = getChildAt ( i ) ; int childHeight = i >= mStickyHeaderBeginIndex ? child . getHeight ( ) : <NUM_LIT> ; stickyHeaderHeight += childHeight ; } return stickyHeaderHeight ; } return <NUM_LIT> ; } private void notifyStickyHeightChanged ( ) { NestedScrollView nestedScrollView = getParentNestedScrollView ( ) ; if ( nestedScrollView != null ) { nestedScrollView . notifyStickyHeightChanged ( ) ; } } private NestedScrollView getParentNestedScrollView ( ) { ViewParent parent = getParent ( ) ; if ( parent != null ) { parent = parent . getParent ( ) ; if ( parent instanceof NestedScrollView ) { return ( NestedScrollView ) parent ; } } return null ; } } </s>
<s> package com . example . myuidemo ; import com . reactnative . hybridnavigation . ReactAppCompatActivity ; public class MainActivity extends ReactAppCompatActivity { } </s>
<s> package com . reactnative . nestedscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . MeasureSpecAssertions ; import com . facebook . react . uimanager . ReactOverflowView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . NativeGestureUtil ; public class NestedScrollView extends androidx . core . widget . NestedScrollView implements ReactOverflowView { private final NestedScrollViewLocalData mNestedScrollViewLocalData = new NestedScrollViewLocalData ( ) ; private String mOverflow = "<STR_LIT>" ; private final Rect mRect ; private final NestedScrollFlingHelper mFlingHelper ; public NestedScrollView ( @ NonNull Context context ) { super ( context ) ; mRect = new Rect ( ) ; mFlingHelper = new NestedScrollFlingHelper ( this ) ; } public void setOverflow ( String overflow ) { mOverflow = overflow ; invalidate ( ) ; } @ Nullable @ Override public String getOverflow ( ) { return mOverflow ; } @ Override public void onNestedPreScroll ( @ NonNull View target , int dx , int dy , @ NonNull int [ ] consumed , int type ) { super . onNestedPreScroll ( target , dx , dy , consumed , type ) ; int dyUnconsumed = dy - consumed [ <NUM_LIT> ] ; if ( dyUnconsumed > <NUM_LIT> ) { final int oldScrollY = getScrollY ( ) ; scrollBy ( <NUM_LIT> , dyUnconsumed ) ; final int myConsumed = getScrollY ( ) - oldScrollY ; consumed [ <NUM_LIT> ] += myConsumed ; } } @ Override public boolean onNestedPreFling ( View target , float velocityX , float velocityY ) { boolean consumed = super . onNestedPreFling ( target , velocityX , velocityY ) ; if ( ! consumed ) { consumed = mFlingHelper . onNestedPreFling ( target , velocityY ) ; } return consumed ; } @ Override public void computeScroll ( ) { super . computeScroll ( ) ; mFlingHelper . computeScroll ( ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { mFlingHelper . dispatchTouchEvent ( ev ) ; return super . dispatchTouchEvent ( ev ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( super . onInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; return true ; } return false ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { MeasureSpecAssertions . assertExplicitMeasureSpec ( widthMeasureSpec , heightMeasureSpec ) ; this . setMeasuredDimension ( MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . getSize ( heightMeasureSpec ) ) ; } void notifyStickyHeightChanged ( ) { if ( isLaidOut ( ) && ! isInLayout ( ) ) { fitStickyHeightIfNeeded ( ) ; } } private void fitStickyHeightIfNeeded ( ) { Context context = getContext ( ) ; if ( context instanceof ReactContext ) { UIManagerModule uiManagerModule = ( ( ReactContext ) context ) . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule == null ) { return ; } ViewGroup content = ( ViewGroup ) getChildAt ( <NUM_LIT> ) ; if ( content == null ) { return ; } int headerFixedHeight = <NUM_LIT> ; float headerHeight = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < content . getChildCount ( ) ; i ++ ) { View child = content . getChildAt ( i ) ; if ( child instanceof NestedScrollViewHeader ) { headerFixedHeight = ( ( NestedScrollViewHeader ) child ) . getStickyHeight ( ) ; headerHeight = child . getHeight ( ) ; } } int nestedScrollViewH = getHeight ( ) ; float contentHeight = nestedScrollViewH - headerFixedHeight ; if ( contentHeight != mNestedScrollViewLocalData . contentNodeH || headerHeight != mNestedScrollViewLocalData . headerNodeH ) { mNestedScrollViewLocalData . contentNodeH = contentHeight ; mNestedScrollViewLocalData . headerNodeH = headerHeight ; uiManagerModule . setViewLocalData ( getId ( ) , mNestedScrollViewLocalData ) ; } int maxScrollRange = ( int ) ( headerHeight - headerFixedHeight ) ; if ( getScrollY ( ) > maxScrollRange ) { scrollTo ( <NUM_LIT> , maxScrollRange ) ; } } } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { super . onLayout ( changed , l , t , r , b ) ; fitStickyHeightIfNeeded ( ) ; } @ Override public void draw ( Canvas canvas ) { getDrawingRect ( mRect ) ; if ( ! "<STR_LIT>" . equals ( mOverflow ) ) { canvas . clipRect ( mRect ) ; } super . draw ( canvas ) ; } } </s>
<s> package com . reactnative . pulltorefresh ; import android . graphics . Rect ; public class PullToRefreshFooterLocalData { Rect viewRect = new Rect ( ) ; } </s>
<s> package com . reactnative . nestedscroll ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ScrollView ; import android . widget . Scroller ; import androidx . core . view . ViewCompat ; public class NestedScrollFlingHelper { private final NestedScrollView mNestedScrollView ; private final Scroller mScroller ; private ViewGroup mTarget ; private int mLastScrollerY = <NUM_LIT> ; public NestedScrollFlingHelper ( NestedScrollView nestedScrollView ) { mNestedScrollView = nestedScrollView ; mScroller = new Scroller ( nestedScrollView . getContext ( ) ) ; } public boolean onNestedPreFling ( View target , float velocityY ) { mTarget = findScrollableView ( target ) ; if ( mTarget != null && mTarget . getChildCount ( ) > <NUM_LIT> ) { mScroller . fling ( mTarget . getScrollX ( ) , mTarget . getScrollY ( ) , <NUM_LIT> , ( int ) velocityY , <NUM_LIT> , <NUM_LIT> , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; runAnimatedScroll ( ) ; return true ; } return false ; } private ViewGroup findScrollableView ( View target ) { if ( ! ( target instanceof ViewGroup ) ) { return null ; } ViewGroup viewGroup = ( ViewGroup ) target ; if ( viewGroup instanceof ScrollView ) { return viewGroup ; } ViewGroup scrollableView ; if ( viewGroup . getChildCount ( ) > <NUM_LIT> ) { int size = viewGroup . getChildCount ( ) ; for ( int i = size - <NUM_LIT> ; i > - <NUM_LIT> ; i -- ) { View child = viewGroup . getChildAt ( i ) ; scrollableView = findScrollableView ( child ) ; if ( scrollableView != null ) { return scrollableView ; } } } return null ; } private void runAnimatedScroll ( ) { mLastScrollerY = mTarget . getScrollY ( ) ; ViewCompat . postInvalidateOnAnimation ( mNestedScrollView ) ; } public void computeScroll ( ) { if ( mScroller . isFinished ( ) ) { return ; } mScroller . computeScrollOffset ( ) ; final int y = mScroller . getCurrY ( ) ; int unconsumed = y - mLastScrollerY ; mLastScrollerY = y ; if ( unconsumed > <NUM_LIT> ) { unconsumed = scrollBy ( unconsumed , mNestedScrollView ) ; } unconsumed = scrollBy ( unconsumed , mTarget ) ; if ( unconsumed < <NUM_LIT> ) { unconsumed = scrollBy ( unconsumed , mNestedScrollView ) ; } if ( unconsumed != <NUM_LIT> ) { abortAnimatedScroll ( ) ; } if ( ! mScroller . isFinished ( ) ) { ViewCompat . postInvalidateOnAnimation ( mNestedScrollView ) ; } } private int scrollBy ( int unconsumed , View view ) { final int oldScrollY = view . getScrollY ( ) ; view . scrollBy ( <NUM_LIT> , unconsumed ) ; final int myConsumed = view . getScrollY ( ) - oldScrollY ; unconsumed -= myConsumed ; return unconsumed ; } private void abortAnimatedScroll ( ) { mScroller . abortAnimation ( ) ; } public void dispatchTouchEvent ( MotionEvent ev ) { final int actionMasked = ev . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_DOWN ) { abortAnimatedScroll ( ) ; mTarget = null ; } } } </s>
<s> package com . reactnative . pulltorefresh ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . views . view . ReactViewGroup ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; import com . scwang . smart . refresh . layout . api . RefreshLayout ; import com . scwang . smart . refresh . layout . constant . RefreshState ; import com . scwang . smart . refresh . layout . constant . SpinnerStyle ; @ SuppressLint ( "<STR_LIT>" ) public class PullToRefreshFooter extends ReactViewGroup implements RefreshFooter { private RefreshKernel mRefreshKernel ; private OnRefreshChangeListener onRefreshChangeListener ; private boolean mIsLoadingMore = false ; private boolean mEnableAutoloadMore = true ; private boolean mNoMoreData = false ; public void setOnRefreshHeaderChangeListener ( OnRefreshChangeListener onRefreshChangeListener ) { this . onRefreshChangeListener = onRefreshChangeListener ; } public PullToRefreshFooter ( Context context ) { super ( context ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int measureMode = MeasureSpec . getMode ( heightMeasureSpec ) ; if ( measureMode == MeasureSpec . AT_MOST ) { heightMeasureSpec = MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ; } super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( getParent ( ) instanceof PullToRefresh && mRefreshKernel == null ) { PullToRefresh refreshLayout = ( PullToRefresh ) getParent ( ) ; int h = MeasureSpec . getSize ( heightMeasureSpec ) ; refreshLayout . setFooterHeightPx ( h ) ; } } PullToRefreshFooterLocalData footerLocalData = new PullToRefreshFooterLocalData ( ) ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( footerLocalData . viewRect . top == top && footerLocalData . viewRect . bottom == bottom && footerLocalData . viewRect . left == left && footerLocalData . viewRect . right == right ) { return ; } footerLocalData . viewRect . top = top ; footerLocalData . viewRect . bottom = bottom ; footerLocalData . viewRect . left = left ; footerLocalData . viewRect . right = right ; Context context = getContext ( ) ; if ( context instanceof ReactContext ) { ReactContext reactContext = ( ReactContext ) context ; UIManagerModule uiManagerModule = reactContext . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule != null ) { uiManagerModule . setViewLocalData ( getId ( ) , footerLocalData ) ; } } } public void setLoadingMore ( boolean loadingMore ) { mIsLoadingMore = loadingMore ; if ( loadingMore ) { beginLoadMore ( ) ; } else { finishLoadMore ( ) ; } } @ Override public boolean setNoMoreData ( boolean noMoreData ) { mNoMoreData = noMoreData ; if ( mRefreshKernel != null ) { mRefreshKernel . getRefreshLayout ( ) . setNoMoreData ( noMoreData ) ; return noMoreData ; } return false ; } public void setAutoLoadMore ( boolean enable ) { mEnableAutoloadMore = enable ; if ( mRefreshKernel != null ) { mRefreshKernel . getRefreshLayout ( ) . setEnableAutoLoadMore ( enable ) ; } } @ NonNull @ Override public View getView ( ) { return this ; } public void beginLoadMore ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isHeader && ! refreshState . isOpening ) { mRefreshKernel . getRefreshLayout ( ) . autoLoadMore ( ) ; } } } public void finishLoadMore ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isHeader && ! refreshState . isFinishing ) { mRefreshKernel . getRefreshLayout ( ) . finishLoadMore ( ) ; } } } @ NonNull @ Override public SpinnerStyle getSpinnerStyle ( ) { return SpinnerStyle . Translate ; } @ Override public void setPrimaryColors ( int ... colors ) { } @ Override public void onInitialized ( @ NonNull RefreshKernel kernel , int height , int maxDragHeight ) { mRefreshKernel = kernel ; mRefreshKernel . getRefreshLayout ( ) . setOnLoadMoreListener ( refreshLayout -> { if ( onRefreshChangeListener != null ) { onRefreshChangeListener . onRefresh ( ) ; } } ) ; setLoadingMore ( mIsLoadingMore ) ; setAutoLoadMore ( mEnableAutoloadMore ) ; setNoMoreData ( mNoMoreData ) ; } @ Override public void onMoving ( boolean isDragging , float percent , int offset , int height , int maxDragHeight ) { if ( isDragging && onRefreshChangeListener != null ) { onRefreshChangeListener . onOffsetChange ( offset ) ; } } @ Override public void onReleased ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public void onStartAnimator ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public int onFinish ( @ NonNull RefreshLayout refreshLayout , boolean success ) { return <NUM_LIT> ; } @ Override public void onHorizontalDrag ( float percentX , int offsetX , int offsetMax ) { } @ Override public boolean isSupportHorizontalDrag ( ) { return false ; } @ Override public boolean autoOpen ( int duration , float dragRate , boolean animationOnly ) { return false ; } @ Override public void onStateChanged ( @ NonNull RefreshLayout refreshLayout , @ NonNull RefreshState oldState , @ NonNull RefreshState newState ) { if ( onRefreshChangeListener != null ) { PullToRefreshState oldPullToRefreshState = convertRefreshStateToPullToRefreshState ( oldState ) ; PullToRefreshState newPullToRefreshState = convertRefreshStateToPullToRefreshState ( newState ) ; if ( newPullToRefreshState != oldPullToRefreshState ) { onRefreshChangeListener . onStateChanged ( newPullToRefreshState ) ; } } } @ Override public PointerEvents getPointerEvents ( ) { RefreshState refreshState = mRefreshKernel != null ? mRefreshKernel . getRefreshLayout ( ) . getState ( ) : RefreshState . None ; if ( refreshState . isHeader && refreshState . isOpening ) { return super . getPointerEvents ( ) ; } return PointerEvents . NONE ; } private PullToRefreshState convertRefreshStateToPullToRefreshState ( RefreshState state ) { if ( state == RefreshState . ReleaseToLoad ) { return PullToRefreshState . Coming ; } if ( state == RefreshState . Loading || state == RefreshState . LoadReleased ) { return PullToRefreshState . Refreshing ; } return PullToRefreshState . Idle ; } } </s>
<s> package com . reactnative . keyboardinsets ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; public class SystemUI { public static boolean isImeVisible ( @ NonNull View view ) { WindowInsetsCompat insetsCompat = ViewCompat . getRootWindowInsets ( view ) ; assert insetsCompat != null ; return insetsCompat . isVisible ( WindowInsetsCompat . Type . ime ( ) ) ; } public static int imeHeight ( @ NonNull View view ) { WindowInsetsCompat insetsCompat = ViewCompat . getRootWindowInsets ( view ) ; assert insetsCompat != null ; return insetsCompat . getInsets ( WindowInsetsCompat . Type . ime ( ) ) . bottom ; } public static EdgeInsets getEdgeInsetsForView ( @ NonNull View view ) { ViewGroup root = ( ViewGroup ) view . getRootView ( ) ; int windowHeight = root . getHeight ( ) ; int windowWidth = root . getWidth ( ) ; Rect offset = new Rect ( ) ; view . getDrawingRect ( offset ) ; root . offsetDescendantRectToMyCoords ( view , offset ) ; int leftMargin = <NUM_LIT> ; int topMargin = <NUM_LIT> ; int rightMargin = <NUM_LIT> ; int bottomMargin = <NUM_LIT> ; if ( view . getLayoutParams ( ) instanceof ViewGroup . MarginLayoutParams ) { ViewGroup . MarginLayoutParams lp = ( ViewGroup . MarginLayoutParams ) view . getLayoutParams ( ) ; leftMargin = lp . leftMargin ; topMargin = lp . topMargin ; rightMargin = lp . rightMargin ; bottomMargin = lp . bottomMargin ; } EdgeInsets insets = new EdgeInsets ( ) ; insets . left = Math . max ( offset . left - leftMargin , <NUM_LIT> ) ; insets . top = Math . max ( offset . top - topMargin , <NUM_LIT> ) ; insets . right = Math . max ( windowWidth - offset . right - rightMargin , <NUM_LIT> ) ; insets . bottom = Math . max ( windowHeight - offset . bottom - bottomMargin , <NUM_LIT> ) ; return insets ; } } </s>
<s> package com . reactnative . keyboardinsets ; public class EdgeInsets { public int left ; public int top ; public int right ; public int bottom ; public EdgeInsets ( ) { } public EdgeInsets ( int left , int top , int right , int bottom ) { this . left = left ; this . top = top ; this . right = right ; this . bottom = bottom ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + left + "<STR_LIT>" + top + "<STR_LIT>" + right + "<STR_LIT>" + bottom + '<STR_LIT>' ; } } </s>
<s> package com . reactnative . bottomsheet ; import static com . reactnative . bottomsheet . BottomSheetState . COLLAPSED ; import static com . reactnative . bottomsheet . BottomSheetState . DRAGGING ; import static com . reactnative . bottomsheet . BottomSheetState . EXPANDED ; import static com . reactnative . bottomsheet . BottomSheetState . HIDDEN ; import static com . reactnative . bottomsheet . BottomSheetState . SETTLING ; import static java . lang . Math . max ; import android . annotation . SuppressLint ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewTreeObserver ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . math . MathUtils ; import androidx . core . util . Pools ; import androidx . core . view . NestedScrollingParent ; import androidx . core . view . NestedScrollingParentHelper ; import androidx . core . view . ViewCompat ; import androidx . customview . widget . ViewDragHelper ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . ReactPointerEventsView ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . uimanager . events . NativeGestureUtil ; import com . facebook . react . views . view . ReactViewGroup ; import java . lang . ref . WeakReference ; @ SuppressLint ( "<STR_LIT>" ) public class BottomSheet extends ReactViewGroup implements NestedScrollingParent , ReactPointerEventsView { private static final String TAG = "<STR_LIT>" ; private final ReactContext reactContext ; public BottomSheet ( ThemedReactContext reactContext ) { super ( reactContext ) ; this . reactContext = reactContext ; this . nestedScrollingParentHelper = new NestedScrollingParentHelper ( this ) ; } private BottomSheetState state = COLLAPSED ; private SettleRunnable settleRunnable = null ; private boolean draggable ; private int peekHeight ; private int expandedOffset ; private int collapsedOffset ; private View contentView ; @ Nullable private WeakReference < View > nestedScrollingChildRef ; private boolean touchingScrollingChild ; @ Nullable private ViewDragHelper viewDragHelper ; private final NestedScrollingParentHelper nestedScrollingParentHelper ; private boolean ignoreEvents ; private int lastNestedScrollDy ; private VelocityTracker velocityTracker ; private int activePointerId ; private int initialY ; private int contentHeight = - <NUM_LIT> ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { if ( viewDragHelper == null ) { viewDragHelper = ViewDragHelper . create ( this , dragCallback ) ; } viewDragHelper . abort ( ) ; if ( settleRunnable != null && settleRunnable . isPosted ) { settleRunnable . run ( ) ; } layoutChild ( ) ; } private void layoutChild ( ) { int count = getChildCount ( ) ; if ( count == <NUM_LIT> ) { View child = getChildAt ( <NUM_LIT> ) ; if ( contentView == null ) { contentView = child ; } contentHeight = contentView . getHeight ( ) ; calculateOffset ( ) ; getViewTreeObserver ( ) . removeOnPreDrawListener ( preDrawListener ) ; int top = contentView . getTop ( ) ; if ( state == COLLAPSED ) { child . offsetTopAndBottom ( collapsedOffset - top ) ; } else if ( state == EXPANDED ) { child . offsetTopAndBottom ( expandedOffset - top ) ; } else if ( state == HIDDEN ) { child . offsetTopAndBottom ( getHeight ( ) - top ) ; } getViewTreeObserver ( ) . addOnPreDrawListener ( preDrawListener ) ; dispatchOnSlide ( child . getTop ( ) ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; getViewTreeObserver ( ) . removeOnPreDrawListener ( preDrawListener ) ; } ViewTreeObserver . OnPreDrawListener preDrawListener = new ViewTreeObserver . OnPreDrawListener ( ) { @ Override public boolean onPreDraw ( ) { if ( contentHeight != - <NUM_LIT> && contentHeight != contentView . getHeight ( ) ) { layoutChild ( ) ; } return true ; } } ; private void calculateOffset ( ) { expandedOffset = Math . max ( <NUM_LIT> , getHeight ( ) - contentView . getHeight ( ) ) ; collapsedOffset = Math . max ( getHeight ( ) - peekHeight , expandedOffset ) ; } public void setPeekHeight ( int peekHeight ) { this . peekHeight = max ( peekHeight , <NUM_LIT> ) ; if ( contentView != null ) { calculateOffset ( ) ; if ( state == COLLAPSED ) { settleToState ( contentView , state ) ; } } } public void setDraggable ( boolean draggable ) { this . draggable = draggable ; } public void setState ( BottomSheetState state ) { if ( state == this . state ) { return ; } if ( contentView == null ) { if ( state == COLLAPSED || state == EXPANDED || state == HIDDEN ) { this . state = state ; } return ; } settleToState ( contentView , state ) ; } @ Nullable @ VisibleForTesting View findScrollingChild ( View view ) { if ( ViewCompat . isNestedScrollingEnabled ( view ) ) { if ( ! view . canScrollHorizontally ( <NUM_LIT> ) && ! view . canScrollHorizontally ( - <NUM_LIT> ) && ( view . canScrollVertically ( - <NUM_LIT> ) || view . canScrollVertically ( <NUM_LIT> ) ) ) { return view ; } } if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = <NUM_LIT> , count = group . getChildCount ( ) ; i < count ; i ++ ) { View child = group . getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { View scrollingChild = findScrollingChild ( child ) ; if ( scrollingChild != null ) { return scrollingChild ; } } } } return null ; } public PointerEvents getPointerEvents ( ) { return PointerEvents . BOX_NONE ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { if ( shouldInterceptTouchEvent ( event ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , event ) ; return true ; } return false ; } private boolean shouldInterceptTouchEvent ( MotionEvent event ) { if ( ! draggable ) { return false ; } int action = event . getActionMasked ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { reset ( ) ; } if ( velocityTracker == null ) { velocityTracker = VelocityTracker . obtain ( ) ; } velocityTracker . addMovement ( event ) ; switch ( action ) { case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : touchingScrollingChild = false ; activePointerId = MotionEvent . INVALID_POINTER_ID ; if ( ignoreEvents ) { ignoreEvents = false ; return false ; } break ; case MotionEvent . ACTION_DOWN : nestedScrollingChildRef = new WeakReference < > ( findScrollingChild ( contentView ) ) ; int initialX = ( int ) event . getX ( ) ; initialY = ( int ) event . getY ( ) ; if ( state != SETTLING ) { View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; if ( scroll != null && isPointInChildBounds ( scroll , initialX , initialY ) ) { activePointerId = event . getPointerId ( event . getActionIndex ( ) ) ; touchingScrollingChild = true ; } } ignoreEvents = activePointerId == MotionEvent . INVALID_POINTER_ID && ! isPointInChildBounds ( contentView , initialX , initialY ) ; break ; default : } if ( ! ignoreEvents && viewDragHelper != null && viewDragHelper . shouldInterceptTouchEvent ( event ) ) { return true ; } View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; return action == MotionEvent . ACTION_MOVE && scroll != null && ! ignoreEvents && state != DRAGGING && ! isPointInChildBounds ( scroll , ( int ) event . getX ( ) , ( int ) event . getY ( ) ) && viewDragHelper != null && Math . abs ( initialY - event . getY ( ) ) > viewDragHelper . getTouchSlop ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { if ( ! draggable ) { return false ; } int action = event . getActionMasked ( ) ; if ( state == DRAGGING && action == MotionEvent . ACTION_DOWN ) { return true ; } if ( viewDragHelper != null ) { viewDragHelper . processTouchEvent ( event ) ; } if ( action == MotionEvent . ACTION_DOWN ) { reset ( ) ; } if ( velocityTracker == null ) { velocityTracker = VelocityTracker . obtain ( ) ; } velocityTracker . addMovement ( event ) ; if ( viewDragHelper != null && action == MotionEvent . ACTION_MOVE && ! ignoreEvents ) { if ( Math . abs ( initialY - event . getY ( ) ) > viewDragHelper . getTouchSlop ( ) ) { viewDragHelper . captureChildView ( contentView , event . getPointerId ( event . getActionIndex ( ) ) ) ; } } return ! ignoreEvents ; } @ Override public boolean onStartNestedScroll ( @ NonNull View child , @ NonNull View target , int nestedScrollAxes ) { return ( nestedScrollAxes & ViewCompat . SCROLL_AXIS_VERTICAL ) != <NUM_LIT> ; } @ Override public void onNestedScrollAccepted ( @ NonNull View child , @ NonNull View target , int axes ) { lastNestedScrollDy = <NUM_LIT> ; nestedScrollingParentHelper . onNestedScrollAccepted ( child , target , axes ) ; } @ Override public void onNestedPreScroll ( @ NonNull View target , int dx , int dy , @ NonNull int [ ] consumed ) { View scrollingChild = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; if ( target != scrollingChild ) { return ; } View child = contentView ; int currentTop = child . getTop ( ) ; int newTop = currentTop - dy ; if ( dy > <NUM_LIT> ) { if ( newTop < expandedOffset ) { consumed [ <NUM_LIT> ] = currentTop - expandedOffset ; ViewCompat . offsetTopAndBottom ( child , - consumed [ <NUM_LIT> ] ) ; setStateInternal ( EXPANDED ) ; } else { consumed [ <NUM_LIT> ] = dy ; ViewCompat . offsetTopAndBottom ( child , - dy ) ; setStateInternal ( DRAGGING ) ; } } else if ( dy < <NUM_LIT> ) { if ( ! target . canScrollVertically ( - <NUM_LIT> ) ) { if ( newTop <= collapsedOffset ) { consumed [ <NUM_LIT> ] = dy ; ViewCompat . offsetTopAndBottom ( child , - dy ) ; setStateInternal ( DRAGGING ) ; } else { consumed [ <NUM_LIT> ] = currentTop - collapsedOffset ; ViewCompat . offsetTopAndBottom ( child , - consumed [ <NUM_LIT> ] ) ; setStateInternal ( COLLAPSED ) ; } } } if ( currentTop != child . getTop ( ) ) { dispatchOnSlide ( child . getTop ( ) ) ; } lastNestedScrollDy = dy ; } @ Override public int getNestedScrollAxes ( ) { return nestedScrollingParentHelper . getNestedScrollAxes ( ) ; } @ Override public void onStopNestedScroll ( @ NonNull View target ) { nestedScrollingParentHelper . onStopNestedScroll ( target ) ; View child = contentView ; if ( child . getTop ( ) == expandedOffset ) { setStateInternal ( EXPANDED ) ; return ; } if ( nestedScrollingChildRef == null || target != nestedScrollingChildRef . get ( ) ) { return ; } int top ; BottomSheetState targetState ; if ( lastNestedScrollDy > <NUM_LIT> ) { top = expandedOffset ; targetState = EXPANDED ; } else if ( lastNestedScrollDy == <NUM_LIT> ) { int currentTop = child . getTop ( ) ; if ( Math . abs ( currentTop - collapsedOffset ) < Math . abs ( currentTop - expandedOffset ) ) { top = collapsedOffset ; targetState = COLLAPSED ; } else { top = expandedOffset ; targetState = EXPANDED ; } } else { top = collapsedOffset ; targetState = COLLAPSED ; } startSettlingAnimation ( child , targetState , top , false ) ; } @ Override public void onNestedScroll ( @ NonNull View target , int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed ) { } @ Override public boolean onNestedPreFling ( @ NonNull View target , float velocityX , float velocityY ) { if ( nestedScrollingChildRef != null ) { return target == nestedScrollingChildRef . get ( ) && ( state != EXPANDED ) ; } else { return false ; } } @ Override public boolean onNestedFling ( @ NonNull View target , float velocityX , float velocityY , boolean consumed ) { return false ; } private void reset ( ) { activePointerId = ViewDragHelper . INVALID_POINTER ; if ( velocityTracker != null ) { velocityTracker . recycle ( ) ; velocityTracker = null ; } } private static final Pools . Pool < Rect > sRectPool = new Pools . SynchronizedPool < > ( <NUM_LIT> ) ; private static Rect acquireTempRect ( ) { Rect rect = sRectPool . acquire ( ) ; if ( rect == null ) { rect = new Rect ( ) ; } return rect ; } private static void releaseTempRect ( @ NonNull Rect rect ) { rect . setEmpty ( ) ; sRectPool . release ( rect ) ; } public boolean isPointInChildBounds ( @ NonNull View child , int x , int y ) { final Rect r = acquireTempRect ( ) ; child . getDrawingRect ( r ) ; offsetDescendantRectToMyCoords ( child , r ) ; try { return r . contains ( x , y ) ; } finally { releaseTempRect ( r ) ; } } private final ViewDragHelper . Callback dragCallback = new ViewDragHelper . Callback ( ) { @ Override public boolean tryCaptureView ( @ NonNull View child , int pointerId ) { if ( state == DRAGGING ) { return false ; } if ( touchingScrollingChild ) { return false ; } if ( state == EXPANDED && activePointerId == pointerId ) { View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; if ( scroll != null && scroll . canScrollVertically ( - <NUM_LIT> ) ) { return false ; } } return contentView == child ; } @ Override public void onViewPositionChanged ( @ NonNull View changedView , int left , int top , int dx , int dy ) { dispatchOnSlide ( top ) ; } @ Override public void onViewDragStateChanged ( int state ) { if ( state == ViewDragHelper . STATE_DRAGGING ) { setStateInternal ( DRAGGING ) ; } } @ Override public void onViewReleased ( @ NonNull View releasedChild , float xvel , float yvel ) { int top ; BottomSheetState targetState ; if ( yvel < <NUM_LIT> ) { top = expandedOffset ; targetState = EXPANDED ; } else if ( yvel == <NUM_LIT> || Math . abs ( xvel ) > Math . abs ( yvel ) ) { int currentTop = releasedChild . getTop ( ) ; if ( Math . abs ( currentTop - collapsedOffset ) < Math . abs ( currentTop - expandedOffset ) ) { top = collapsedOffset ; targetState = COLLAPSED ; } else { top = expandedOffset ; targetState = EXPANDED ; } } else { top = collapsedOffset ; targetState = COLLAPSED ; } startSettlingAnimation ( releasedChild , targetState , top , true ) ; } @ Override public int clampViewPositionVertical ( @ NonNull View child , int top , int dy ) { return MathUtils . clamp ( top , expandedOffset , collapsedOffset ) ; } @ Override public int clampViewPositionHorizontal ( @ NonNull View child , int left , int dx ) { return child . getLeft ( ) ; } @ Override public int getViewVerticalDragRange ( @ NonNull View child ) { return collapsedOffset ; } } ; void dispatchOnSlide ( int top ) { if ( contentView != null ) { sentEvent ( new OffsetChangedEvent ( UIManagerHelper . getSurfaceId ( reactContext ) , getId ( ) , top , expandedOffset , collapsedOffset ) ) ; } } void settleToState ( @ NonNull View child , BottomSheetState state ) { int top ; if ( state == COLLAPSED ) { top = collapsedOffset ; } else if ( state == EXPANDED ) { top = expandedOffset ; } else if ( state == HIDDEN ) { top = getHeight ( ) ; } else { throw new IllegalArgumentException ( "<STR_LIT>" + state ) ; } startSettlingAnimation ( child , state , top , false ) ; } void startSettlingAnimation ( View child , BottomSheetState state , int top , boolean settleFromViewDragHelper ) { boolean startedSettling = viewDragHelper != null && ( settleFromViewDragHelper ? viewDragHelper . settleCapturedViewAt ( child . getLeft ( ) , top ) : viewDragHelper . smoothSlideViewTo ( child , child . getLeft ( ) , top ) ) ; if ( startedSettling ) { setStateInternal ( SETTLING ) ; if ( settleRunnable == null ) { settleRunnable = new SettleRunnable ( child , state ) ; } if ( ! settleRunnable . isPosted ) { settleRunnable . targetState = state ; ViewCompat . postOnAnimation ( child , settleRunnable ) ; settleRunnable . isPosted = true ; } else { settleRunnable . targetState = state ; } } else { setStateInternal ( state ) ; } } void setStateInternal ( BottomSheetState state ) { if ( this . state == state ) { return ; } this . state = state ; if ( state == COLLAPSED || state == EXPANDED || state == HIDDEN ) { sentEvent ( new StateChangedEvent ( UIManagerHelper . getSurfaceId ( reactContext ) , getId ( ) , state . name ( ) . toLowerCase ( ) ) ) ; } } private class SettleRunnable implements Runnable { private final View view ; private boolean isPosted ; BottomSheetState targetState ; SettleRunnable ( View view , BottomSheetState targetState ) { this . view = view ; this . targetState = targetState ; } @ Override public void run ( ) { if ( viewDragHelper != null && viewDragHelper . continueSettling ( true ) ) { ViewCompat . postOnAnimation ( view , this ) ; } else { setStateInternal ( targetState ) ; } this . isPosted = false ; } } void sentEvent ( Event < ? > event ) { int viewId = getId ( ) ; EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( event ) ; } } } </s>
<s> package de . robv . android . xposed ; </s>
<s> package com . android . internal . os ; public class RuntimeInit { public static final void main ( String [ ] argv ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package de . robv . android . xposed ; import android . os . Environment ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . security . DigestException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . zip . Adler32 ; import static de . robv . android . xposed . XposedHelpers . inputStreamToByteArray ; class DexCreator { public static File DALVIK_CACHE = new File ( Environment . getDataDirectory ( ) , "<STR_LIT>" ) ; public static File getDefaultFile ( String childClz ) { return new File ( DALVIK_CACHE , "<STR_LIT>" + childClz . substring ( childClz . lastIndexOf ( '<STR_LIT>' ) + <NUM_LIT> ) + "<STR_LIT>" ) ; } public static File ensure ( String clz , Class < ? > realSuperClz , Class < ? > topClz ) throws IOException { if ( ! topClz . isAssignableFrom ( realSuperClz ) ) { throw new ClassCastException ( "<STR_LIT>" + clz + "<STR_LIT>" + realSuperClz + "<STR_LIT>" + topClz ) ; } try { return ensure ( "<STR_LIT>" + clz + "<STR_LIT>" , realSuperClz ) ; } catch ( IOException e ) { throw new IOException ( "<STR_LIT>" + clz , e ) ; } } public static File ensure ( String childClz , Class < ? > superClz ) throws IOException { return ensure ( getDefaultFile ( childClz ) , childClz , superClz . getName ( ) ) ; } public static File ensure ( File file , String childClz , String superClz ) throws IOException { try { byte [ ] dex = inputStreamToByteArray ( new FileInputStream ( file ) ) ; if ( matches ( dex , childClz , superClz ) ) { return file ; } else { file . delete ( ) ; } } catch ( IOException e ) { file . delete ( ) ; } byte [ ] dex = create ( childClz , superClz ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( dex ) ; fos . close ( ) ; return file ; } public static boolean matches ( byte [ ] dex , String childClz , String superClz ) throws IOException { boolean childFirst = childClz . compareTo ( superClz ) < <NUM_LIT> ; byte [ ] childBytes = stringToBytes ( "<STR_LIT>" + childClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + "<STR_LIT>" ) ; byte [ ] superBytes = stringToBytes ( "<STR_LIT>" + superClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + "<STR_LIT>" ) ; int pos = <NUM_LIT> ; if ( pos + childBytes . length + superBytes . length >= dex . length ) { return false ; } for ( byte b : childFirst ? childBytes : superBytes ) { if ( dex [ pos ++ ] != b ) { return false ; } } for ( byte b : childFirst ? superBytes : childBytes ) { if ( dex [ pos ++ ] != b ) { return false ; } } return true ; } public static byte [ ] create ( String childClz , String superClz ) throws IOException { boolean childFirst = childClz . compareTo ( superClz ) < <NUM_LIT> ; byte [ ] childBytes = stringToBytes ( "<STR_LIT>" + childClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + "<STR_LIT>" ) ; byte [ ] superBytes = stringToBytes ( "<STR_LIT>" + superClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + "<STR_LIT>" ) ; int stringsSize = childBytes . length + superBytes . length ; int padding = - stringsSize & <NUM_LIT> ; stringsSize += padding ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; out . write ( "<STR_LIT>" . getBytes ( ) ) ; out . write ( new byte [ <NUM_LIT> ] ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + ( childFirst ? childBytes . length : superBytes . length ) ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , childFirst ? <NUM_LIT> : <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , childFirst ? <NUM_LIT> : <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , - <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; out . write ( childFirst ? childBytes : superBytes ) ; out . write ( childFirst ? superBytes : childBytes ) ; out . write ( new byte [ padding ] ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> + stringsSize ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> + stringsSize ) ; byte [ ] buf = out . toByteArray ( ) ; updateSignature ( buf ) ; updateChecksum ( buf ) ; return buf ; } private static void updateSignature ( byte [ ] dex ) { try { MessageDigest md = MessageDigest . getInstance ( "<STR_LIT>" ) ; md . update ( dex , <NUM_LIT> , dex . length - <NUM_LIT> ) ; md . digest ( dex , <NUM_LIT> , <NUM_LIT> ) ; } catch ( NoSuchAlgorithmException | DigestException e ) { throw new RuntimeException ( e ) ; } } private static void updateChecksum ( byte [ ] dex ) { Adler32 a32 = new Adler32 ( ) ; a32 . update ( dex , <NUM_LIT> , dex . length - <NUM_LIT> ) ; int chksum = ( int ) a32 . getValue ( ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; } private static void writeUleb128 ( OutputStream out , int value ) throws IOException { while ( value > <NUM_LIT> ) { out . write ( ( value & <NUM_LIT> ) | <NUM_LIT> ) ; value >>>= <NUM_LIT> ; } out . write ( value ) ; } private static void writeInt ( OutputStream out , int value ) throws IOException { out . write ( value ) ; out . write ( value > > <NUM_LIT> ) ; out . write ( value > > <NUM_LIT> ) ; out . write ( value > > <NUM_LIT> ) ; } private static void writeMapItem ( OutputStream out , int type , int count , int offset ) throws IOException { writeInt ( out , type ) ; writeInt ( out , count ) ; writeInt ( out , offset ) ; } private static byte [ ] stringToBytes ( String s ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; writeUleb128 ( bytes , s . length ( ) ) ; bytes . write ( s . getBytes ( "<STR_LIT>" ) ) ; bytes . write ( <NUM_LIT> ) ; return bytes . toByteArray ( ) ; } private DexCreator ( ) { } } </s>
<s> package external . org . apache . commons . lang3 . reflect ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Member ; import java . lang . reflect . Modifier ; import external . org . apache . commons . lang3 . ClassUtils ; public abstract class MemberUtils { private static final int ACCESS_TEST = Modifier . PUBLIC | Modifier . PROTECTED | Modifier . PRIVATE ; private static final Class < ? > [ ] ORDERED_PRIMITIVE_TYPES = { Byte . TYPE , Short . TYPE , Character . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; static void setAccessibleWorkaround ( AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return ; } Member m = ( Member ) o ; if ( Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true ) ; } catch ( SecurityException e ) { } } } static boolean isPackageAccess ( int modifiers ) { return ( modifiers & ACCESS_TEST ) == <NUM_LIT> ; } static boolean isAccessible ( Member m ) { return m != null && Modifier . isPublic ( m . getModifiers ( ) ) && ! m . isSynthetic ( ) ; } public static int compareParameterTypes ( Class < ? > [ ] left , Class < ? > [ ] right , Class < ? > [ ] actual ) { float leftCost = getTotalTransformationCost ( actual , left ) ; float rightCost = getTotalTransformationCost ( actual , right ) ; return leftCost < rightCost ? - <NUM_LIT> : rightCost < leftCost ? <NUM_LIT> : <NUM_LIT> ; } private static float getTotalTransformationCost ( Class < ? > [ ] srcArgs , Class < ? > [ ] destArgs ) { float totalCost = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < srcArgs . length ; i ++ ) { Class < ? > srcClass , destClass ; srcClass = srcArgs [ i ] ; destClass = destArgs [ i ] ; totalCost += getObjectTransformationCost ( srcClass , destClass ) ; } return totalCost ; } private static float getObjectTransformationCost ( Class < ? > srcClass , Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = <NUM_LIT> ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { cost += <NUM_LIT> ; break ; } cost ++ ; srcClass = srcClass . getSuperclass ( ) ; } if ( srcClass == null ) { cost += <NUM_LIT> ; } return cost ; } private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = <NUM_LIT> ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) { cost += <NUM_LIT> ; cls = ClassUtils . wrapperToPrimitive ( cls ) ; } for ( int i = <NUM_LIT> ; cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; i ++ ) { if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { cost += <NUM_LIT> ; if ( i < ORDERED_PRIMITIVE_TYPES . length - <NUM_LIT> ) { cls = ORDERED_PRIMITIVE_TYPES [ i + <NUM_LIT> ] ; } } } return cost ; } } </s>
<s> package de . robv . android . xposed . callbacks ; import android . content . pm . ApplicationInfo ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_LoadPackage extends XCallback implements IXposedHookLoadPackage { @ SuppressWarnings ( "<STR_LIT>" ) public XC_LoadPackage ( ) { super ( ) ; } public XC_LoadPackage ( int priority ) { super ( priority ) ; } public static final class LoadPackageParam extends XCallback . Param { public LoadPackageParam ( CopyOnWriteSortedSet < XC_LoadPackage > callbacks ) { super ( callbacks ) ; } public String packageName ; public String processName ; public ClassLoader classLoader ; public ApplicationInfo appInfo ; public boolean isFirstApplication ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof LoadPackageParam ) handleLoadPackage ( ( LoadPackageParam ) param ) ; } } </s>
<s> package external . org . apache . commons . lang3 . tuple ; public final class ImmutablePair < L , R > extends Pair < L , R > { private static final long serialVersionUID = <NUM_LIT> ; public final L left ; public final R right ; public static < L , R > ImmutablePair < L , R > of ( L left , R right ) { return new ImmutablePair < L , R > ( left , right ) ; } public ImmutablePair ( L left , R right ) { super ( ) ; this . left = left ; this . right = right ; } @ Override public L getLeft ( ) { return left ; } @ Override public R getRight ( ) { return right ; } public R setValue ( R value ) { throw new UnsupportedOperationException ( ) ; } } </s>
<s> package external . org . apache . commons . lang3 ; public class CharUtils { private static final String [ ] CHAR_STRING_ARRAY = new String [ <NUM_LIT> ] ; public static final char LF = '<STR_LIT>' ; public static final char CR = '<STR_LIT>' ; static { for ( char c = <NUM_LIT> ; c < CHAR_STRING_ARRAY . length ; c ++ ) { CHAR_STRING_ARRAY [ c ] = String . valueOf ( c ) ; } } public CharUtils ( ) { super ( ) ; } @ Deprecated public static Character toCharacterObject ( char ch ) { return Character . valueOf ( ch ) ; } public static Character toCharacterObject ( String str ) { if ( StringUtils . isEmpty ( str ) ) { return null ; } return Character . valueOf ( str . charAt ( <NUM_LIT> ) ) ; } public static char toChar ( Character ch ) { if ( ch == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } return ch . charValue ( ) ; } public static char toChar ( Character ch , char defaultValue ) { if ( ch == null ) { return defaultValue ; } return ch . charValue ( ) ; } public static char toChar ( String str ) { if ( StringUtils . isEmpty ( str ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } return str . charAt ( <NUM_LIT> ) ; } public static char toChar ( String str , char defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } return str . charAt ( <NUM_LIT> ) ; } public static int toIntValue ( char ch ) { if ( isAsciiNumeric ( ch ) == false ) { throw new IllegalArgumentException ( "<STR_LIT>" + ch + "<STR_LIT>" ) ; } return ch - <NUM_LIT> ; } public static int toIntValue ( char ch , int defaultValue ) { if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - <NUM_LIT> ; } public static int toIntValue ( Character ch ) { if ( ch == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } return toIntValue ( ch . charValue ( ) ) ; } public static int toIntValue ( Character ch , int defaultValue ) { if ( ch == null ) { return defaultValue ; } return toIntValue ( ch . charValue ( ) , defaultValue ) ; } public static String toString ( char ch ) { if ( ch < <NUM_LIT> ) { return CHAR_STRING_ARRAY [ ch ] ; } return new String ( new char [ ] { ch } ) ; } public static String toString ( Character ch ) { if ( ch == null ) { return null ; } return toString ( ch . charValue ( ) ) ; } public static String unicodeEscaped ( char ch ) { if ( ch < <NUM_LIT> ) { return "<STR_LIT>" + Integer . toHexString ( ch ) ; } else if ( ch < <NUM_LIT> ) { return "<STR_LIT>" + Integer . toHexString ( ch ) ; } else if ( ch < <NUM_LIT> ) { return "<STR_LIT>" + Integer . toHexString ( ch ) ; } return "<STR_LIT>" + Integer . toHexString ( ch ) ; } public static String unicodeEscaped ( Character ch ) { if ( ch == null ) { return null ; } return unicodeEscaped ( ch . charValue ( ) ) ; } public static boolean isAscii ( char ch ) { return ch < <NUM_LIT> ; } public static boolean isAsciiPrintable ( char ch ) { return ch >= <NUM_LIT> && ch < <NUM_LIT> ; } public static boolean isAsciiControl ( char ch ) { return ch < <NUM_LIT> || ch == <NUM_LIT> ; } public static boolean isAsciiAlpha ( char ch ) { return ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) ; } public static boolean isAsciiAlphaUpper ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiAlphaLower ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiNumeric ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiAlphanumeric ( char ch ) { return ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) ; } } </s>
<s> package de . robv . android . xposed . services ; </s>
<s> package de . robv . android . xposed . callbacks ; import de . robv . android . xposed . IXposedHookZygoteInit ; public interface IXUnhook < T > { T getCallback ( ) ; void unhook ( ) ; } </s>
<s> package external . org . apache . commons . lang3 . mutable ; public interface Mutable < T > { T getValue ( ) ; void setValue ( T value ) ; } </s>
<s> package de . robv . android . xposed . services ; import android . os . IBinder ; import android . os . Parcel ; import android . os . RemoteException ; import android . os . ServiceManager ; import java . io . IOException ; public final class BinderService extends BaseService { public static final int TARGET_APP = <NUM_LIT> ; public static final int TARGET_SYSTEM = <NUM_LIT> ; public static BinderService getService ( int target ) { if ( target < <NUM_LIT> || target > sServices . length ) { throw new IllegalArgumentException ( "<STR_LIT>" + target ) ; } synchronized ( sServices ) { if ( sServices [ target ] == null ) { sServices [ target ] = new BinderService ( target ) ; } return sServices [ target ] ; } } @ Override public boolean checkFileAccess ( String filename , int mode ) { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; data . writeInt ( mode ) ; try { mRemote . transact ( ACCESS_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; return false ; } reply . readException ( ) ; int result = reply . readInt ( ) ; reply . recycle ( ) ; data . recycle ( ) ; return result == <NUM_LIT> ; } @ Override public FileResult statFile ( String filename ) throws IOException { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; try { mRemote . transact ( STAT_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; throw new IOException ( e ) ; } reply . readException ( ) ; int errno = reply . readInt ( ) ; if ( errno != <NUM_LIT> ) throwCommonIOException ( errno , null , filename , "<STR_LIT>" ) ; long size = reply . readLong ( ) ; long time = reply . readLong ( ) ; reply . recycle ( ) ; data . recycle ( ) ; return new FileResult ( size , time ) ; } @ Override public byte [ ] readFile ( String filename ) throws IOException { return readFile ( filename , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) . content ; } @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { return readFile ( filename , <NUM_LIT> , <NUM_LIT> , previousSize , previousTime ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; data . writeInt ( offset ) ; data . writeInt ( length ) ; data . writeLong ( previousSize ) ; data . writeLong ( previousTime ) ; try { mRemote . transact ( READ_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; throw new IOException ( e ) ; } reply . readException ( ) ; int errno = reply . readInt ( ) ; String errorMsg = reply . readString ( ) ; long size = reply . readLong ( ) ; long time = reply . readLong ( ) ; byte [ ] content = reply . createByteArray ( ) ; reply . recycle ( ) ; data . recycle ( ) ; switch ( errno ) { case <NUM_LIT> : return new FileResult ( content , size , time ) ; case <NUM_LIT> : if ( errorMsg != null ) { IllegalArgumentException iae = new IllegalArgumentException ( errorMsg ) ; if ( offset == <NUM_LIT> && length == <NUM_LIT> ) throw new IOException ( iae ) ; else throw iae ; } else { throw new IllegalArgumentException ( "<STR_LIT>" + offset + "<STR_LIT>" + length + "<STR_LIT>" + filename + "<STR_LIT>" + size ) ; } default : throwCommonIOException ( errno , errorMsg , filename , "<STR_LIT>" ) ; throw new IllegalStateException ( ) ; } } private static final String INTERFACE_TOKEN = "<STR_LIT>" ; private static final int ACCESS_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final int STAT_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final int READ_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final String [ ] SERVICE_NAMES = { "<STR_LIT>" , "<STR_LIT>" } ; private static final BinderService [ ] sServices = new BinderService [ <NUM_LIT> ] ; private final IBinder mRemote ; private BinderService ( int target ) { IBinder binder = ServiceManager . getService ( SERVICE_NAMES [ target ] ) ; if ( binder == null ) throw new IllegalStateException ( "<STR_LIT>" + SERVICE_NAMES [ target ] + "<STR_LIT>" ) ; this . mRemote = binder ; } } </s>
<s> package de . robv . android . xposed ; import android . content . res . AssetManager ; import android . content . res . Resources ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . Closeable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . math . BigInteger ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . WeakHashMap ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . zip . ZipFile ; import dalvik . system . DexFile ; import external . org . apache . commons . lang3 . ClassUtils ; import external . org . apache . commons . lang3 . reflect . MemberUtils ; public final class XposedHelpers { private XposedHelpers ( ) { } private static final HashMap < String , Field > fieldCache = new HashMap < > ( ) ; private static final HashMap < String , Method > methodCache = new HashMap < > ( ) ; private static final HashMap < String , Constructor < ? > > constructorCache = new HashMap < > ( ) ; private static final WeakHashMap < Object , HashMap < String , Object > > additionalFields = new WeakHashMap < > ( ) ; private static final HashMap < String , ThreadLocal < AtomicInteger > > sMethodDepth = new HashMap < > ( ) ; public static Class < ? > findClass ( String className , ClassLoader classLoader ) { if ( classLoader == null ) classLoader = XposedBridge . BOOTCLASSLOADER ; try { return ClassUtils . getClass ( classLoader , className , false ) ; } catch ( ClassNotFoundException e ) { throw new ClassNotFoundError ( e ) ; } } public static Class < ? > findClassIfExists ( String className , ClassLoader classLoader ) { try { return findClass ( className , classLoader ) ; } catch ( ClassNotFoundError e ) { return null ; } } public static Field findField ( Class < ? > clazz , String fieldName ) { String fullFieldName = clazz . getName ( ) + '<STR_LIT>' + fieldName ; if ( fieldCache . containsKey ( fullFieldName ) ) { Field field = fieldCache . get ( fullFieldName ) ; if ( field == null ) throw new NoSuchFieldError ( fullFieldName ) ; return field ; } try { Field field = findFieldRecursiveImpl ( clazz , fieldName ) ; field . setAccessible ( true ) ; fieldCache . put ( fullFieldName , field ) ; return field ; } catch ( NoSuchFieldException e ) { fieldCache . put ( fullFieldName , null ) ; throw new NoSuchFieldError ( fullFieldName ) ; } } public static Field findFieldIfExists ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) ; } catch ( NoSuchFieldError e ) { return null ; } } private static Field findFieldRecursiveImpl ( Class < ? > clazz , String fieldName ) throws NoSuchFieldException { try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException e ) { while ( true ) { clazz = clazz . getSuperclass ( ) ; if ( clazz == null || clazz . equals ( Object . class ) ) break ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException ignored ) { } } throw e ; } } public static Field findFirstFieldByExactType ( Class < ? > clazz , Class < ? > type ) { Class < ? > clz = clazz ; do { for ( Field field : clz . getDeclaredFields ( ) ) { if ( field . getType ( ) == type ) { field . setAccessible ( true ) ; return field ; } } } while ( ( clz = clz . getSuperclass ( ) ) != null ) ; throw new NoSuchFieldError ( "<STR_LIT>" + type . getName ( ) + "<STR_LIT>" + clazz . getName ( ) ) ; } public static XC_MethodHook . Unhook findAndHookMethod ( Class < ? > clazz , String methodName , Object ... parameterTypesAndCallback ) { if ( parameterTypesAndCallback . length == <NUM_LIT> || ! ( parameterTypesAndCallback [ parameterTypesAndCallback . length - <NUM_LIT> ] instanceof XC_MethodHook ) ) throw new IllegalArgumentException ( "<STR_LIT>" ) ; XC_MethodHook callback = ( XC_MethodHook ) parameterTypesAndCallback [ parameterTypesAndCallback . length - <NUM_LIT> ] ; Method m = findMethodExact ( clazz , methodName , getParameterClasses ( clazz . getClassLoader ( ) , parameterTypesAndCallback ) ) ; return XposedBridge . hookMethod ( m , callback ) ; } public static XC_MethodHook . Unhook findAndHookMethod ( String className , ClassLoader classLoader , String methodName , Object ... parameterTypesAndCallback ) { return findAndHookMethod ( findClass ( className , classLoader ) , methodName , parameterTypesAndCallback ) ; } public static Method findMethodExact ( Class < ? > clazz , String methodName , Object ... parameterTypes ) { return findMethodExact ( clazz , methodName , getParameterClasses ( clazz . getClassLoader ( ) , parameterTypes ) ) ; } public static Method findMethodExactIfExists ( Class < ? > clazz , String methodName , Object ... parameterTypes ) { try { return findMethodExact ( clazz , methodName , parameterTypes ) ; } catch ( ClassNotFoundError | NoSuchMethodError e ) { return null ; } } public static Method findMethodExact ( String className , ClassLoader classLoader , String methodName , Object ... parameterTypes ) { return findMethodExact ( findClass ( className , classLoader ) , methodName , getParameterClasses ( classLoader , parameterTypes ) ) ; } public static Method findMethodExactIfExists ( String className , ClassLoader classLoader , String methodName , Object ... parameterTypes ) { try { return findMethodExact ( className , classLoader , methodName , parameterTypes ) ; } catch ( ClassNotFoundError | NoSuchMethodError e ) { return null ; } } public static Method findMethodExact ( Class < ? > clazz , String methodName , Class < ? > ... parameterTypes ) { String fullMethodName = clazz . getName ( ) + '<STR_LIT>' + methodName + getParametersString ( parameterTypes ) + "<STR_LIT>" ; if ( methodCache . containsKey ( fullMethodName ) ) { Method method = methodCache . get ( fullMethodName ) ; if ( method == null ) throw new NoSuchMethodError ( fullMethodName ) ; return method ; } try { Method method = clazz . getDeclaredMethod ( methodName , parameterTypes ) ; method . setAccessible ( true ) ; methodCache . put ( fullMethodName , method ) ; return method ; } catch ( NoSuchMethodException e ) { methodCache . put ( fullMethodName , null ) ; throw new NoSuchMethodError ( fullMethodName ) ; } } public static Method [ ] findMethodsByExactParameters ( Class < ? > clazz , Class < ? > returnType , Class < ? > ... parameterTypes ) { List < Method > result = new LinkedList < > ( ) ; for ( Method method : clazz . getDeclaredMethods ( ) ) { if ( returnType != null && returnType != method . getReturnType ( ) ) continue ; Class < ? > [ ] methodParameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != methodParameterTypes . length ) continue ; boolean match = true ; for ( int i = <NUM_LIT> ; i < parameterTypes . length ; i ++ ) { if ( parameterTypes [ i ] != methodParameterTypes [ i ] ) { match = false ; break ; } } if ( ! match ) continue ; method . setAccessible ( true ) ; result . add ( method ) ; } return result . toArray ( new Method [ result . size ( ) ] ) ; } public static Method findMethodBestMatch ( Class < ? > clazz , String methodName , Class < ? > ... parameterTypes ) { String fullMethodName = clazz . getName ( ) + '<STR_LIT>' + methodName + getParametersString ( parameterTypes ) + "<STR_LIT>" ; if ( methodCache . containsKey ( fullMethodName ) ) { Method method = methodCache . get ( fullMethodName ) ; if ( method == null ) throw new NoSuchMethodError ( fullMethodName ) ; return method ; } try { Method method = findMethodExact ( clazz , methodName , parameterTypes ) ; methodCache . put ( fullMethodName , method ) ; return method ; } catch ( NoSuchMethodError ignored ) { } Method bestMatch = null ; Class < ? > clz = clazz ; boolean considerPrivateMethods = true ; do { for ( Method method : clz . getDeclaredMethods ( ) ) { if ( ! considerPrivateMethods && Modifier . isPrivate ( method . getModifiers ( ) ) ) continue ; if ( method . getName ( ) . equals ( methodName ) && ClassUtils . isAssignable ( parameterTypes , method . getParameterTypes ( ) , true ) ) { if ( bestMatch == null || MemberUtils . compareParameterTypes ( method . getParameterTypes ( ) , bestMatch . getParameterTypes ( ) , parameterTypes ) < <NUM_LIT> ) { bestMatch = method ; } } } considerPrivateMethods = false ; } while ( ( clz = clz . getSuperclass ( ) ) != null ) ; if ( bestMatch != null ) { bestMatch . setAccessible ( true ) ; methodCache . put ( fullMethodName , bestMatch ) ; return bestMatch ; } else { NoSuchMethodError e = new NoSuchMethodError ( fullMethodName ) ; methodCache . put ( fullMethodName , null ) ; throw e ; } } public static Method findMethodBestMatch ( Class < ? > clazz , String methodName , Object ... args ) { return findMethodBestMatch ( clazz , methodName , getParameterTypes ( args ) ) ; } public static Method findMethodBestMatch ( Class < ? > clazz , String methodName , Class < ? > [ ] parameterTypes , Object [ ] args ) { Class < ? > [ ] argsClasses = null ; for ( int i = <NUM_LIT> ; i < parameterTypes . length ; i ++ ) { if ( parameterTypes [ i ] != null ) continue ; if ( argsClasses == null ) argsClasses = getParameterTypes ( args ) ; parameterTypes [ i ] = argsClasses [ i ] ; } return findMethodBestMatch ( clazz , methodName , parameterTypes ) ; } public static Class < ? > [ ] getParameterTypes ( Object ... args ) { Class < ? > [ ] clazzes = new Class < ? > [ args . length ] ; for ( int i = <NUM_LIT> ; i < args . length ; i ++ ) { clazzes [ i ] = ( args [ i ] != null ) ? args [ i ] . getClass ( ) : null ; } return clazzes ; } private static Class < ? > [ ] getParameterClasses ( ClassLoader classLoader , Object [ ] parameterTypesAndCallback ) { Class < ? > [ ] parameterClasses = null ; for ( int i = parameterTypesAndCallback . length - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { Object type = parameterTypesAndCallback [ i ] ; if ( type == null ) throw new ClassNotFoundError ( "<STR_LIT>" , null ) ; if ( type instanceof XC_MethodHook ) continue ; if ( parameterClasses == null ) parameterClasses = new Class < ? > [ i + <NUM_LIT> ] ; if ( type instanceof Class ) parameterClasses [ i ] = ( Class < ? > ) type ; else if ( type instanceof String ) parameterClasses [ i ] = findClass ( ( String ) type , classLoader ) ; else throw new ClassNotFoundError ( "<STR_LIT>" , null ) ; } if ( parameterClasses == null ) parameterClasses = new Class < ? > [ <NUM_LIT> ] ; return parameterClasses ; } public static Class < ? > [ ] getClassesAsArray ( Class < ? > ... clazzes ) { return clazzes ; } private static String getParametersString ( Class < ? > ... clazzes ) { StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; boolean first = true ; for ( Class < ? > clazz : clazzes ) { if ( first ) first = false ; else sb . append ( "<STR_LIT>" ) ; if ( clazz != null ) sb . append ( clazz . getCanonicalName ( ) ) ; else sb . append ( "<STR_LIT>" ) ; } sb . append ( "<STR_LIT>" ) ; return sb . toString ( ) ; } public static Constructor < ? > findConstructorExact ( Class < ? > clazz , Object ... parameterTypes ) { return findConstructorExact ( clazz , getParameterClasses ( clazz . getClassLoader ( ) , parameterTypes ) ) ; } public static Constructor < ? > findConstructorExactIfExists ( Class < ? > clazz , Object ... parameterTypes ) { try { return findConstructorExact ( clazz , parameterTypes ) ; } catch ( ClassNotFoundError | NoSuchMethodError e ) { return null ; } } public static Constructor < ? > findConstructorExact ( String className , ClassLoader classLoader , Object ... parameterTypes ) { return findConstructorExact ( findClass ( className , classLoader ) , getParameterClasses ( classLoader , parameterTypes ) ) ; } public static Constructor < ? > findConstructorExactIfExists ( String className , ClassLoader classLoader , Object ... parameterTypes ) { try { return findConstructorExact ( className , classLoader , parameterTypes ) ; } catch ( ClassNotFoundError | NoSuchMethodError e ) { return null ; } } public static Constructor < ? > findConstructorExact ( Class < ? > clazz , Class < ? > ... parameterTypes ) { String fullConstructorName = clazz . getName ( ) + getParametersString ( parameterTypes ) + "<STR_LIT>" ; if ( constructorCache . containsKey ( fullConstructorName ) ) { Constructor < ? > constructor = constructorCache . get ( fullConstructorName ) ; if ( constructor == null ) throw new NoSuchMethodError ( fullConstructorName ) ; return constructor ; } try { Constructor < ? > constructor = clazz . getDeclaredConstructor ( parameterTypes ) ; constructor . setAccessible ( true ) ; constructorCache . put ( fullConstructorName , constructor ) ; return constructor ; } catch ( NoSuchMethodException e ) { constructorCache . put ( fullConstructorName , null ) ; throw new NoSuchMethodError ( fullConstructorName ) ; } } public static XC_MethodHook . Unhook findAndHookConstructor ( Class < ? > clazz , Object ... parameterTypesAndCallback ) { if ( parameterTypesAndCallback . length == <NUM_LIT> || ! ( parameterTypesAndCallback [ parameterTypesAndCallback . length - <NUM_LIT> ] instanceof XC_MethodHook ) ) throw new IllegalArgumentException ( "<STR_LIT>" ) ; XC_MethodHook callback = ( XC_MethodHook ) parameterTypesAndCallback [ parameterTypesAndCallback . length - <NUM_LIT> ] ; Constructor < ? > m = findConstructorExact ( clazz , getParameterClasses ( clazz . getClassLoader ( ) , parameterTypesAndCallback ) ) ; return XposedBridge . hookMethod ( m , callback ) ; } public static XC_MethodHook . Unhook findAndHookConstructor ( String className , ClassLoader classLoader , Object ... parameterTypesAndCallback ) { return findAndHookConstructor ( findClass ( className , classLoader ) , parameterTypesAndCallback ) ; } public static Constructor < ? > findConstructorBestMatch ( Class < ? > clazz , Class < ? > ... parameterTypes ) { String fullConstructorName = clazz . getName ( ) + getParametersString ( parameterTypes ) + "<STR_LIT>" ; if ( constructorCache . containsKey ( fullConstructorName ) ) { Constructor < ? > constructor = constructorCache . get ( fullConstructorName ) ; if ( constructor == null ) throw new NoSuchMethodError ( fullConstructorName ) ; return constructor ; } try { Constructor < ? > constructor = findConstructorExact ( clazz , parameterTypes ) ; constructorCache . put ( fullConstructorName , constructor ) ; return constructor ; } catch ( NoSuchMethodError ignored ) { } Constructor < ? > bestMatch = null ; Constructor < ? > [ ] constructors = clazz . getDeclaredConstructors ( ) ; for ( Constructor < ? > constructor : constructors ) { if ( ClassUtils . isAssignable ( parameterTypes , constructor . getParameterTypes ( ) , true ) ) { if ( bestMatch == null || MemberUtils . compareParameterTypes ( constructor . getParameterTypes ( ) , bestMatch . getParameterTypes ( ) , parameterTypes ) < <NUM_LIT> ) { bestMatch = constructor ; } } } if ( bestMatch != null ) { bestMatch . setAccessible ( true ) ; constructorCache . put ( fullConstructorName , bestMatch ) ; return bestMatch ; } else { NoSuchMethodError e = new NoSuchMethodError ( fullConstructorName ) ; constructorCache . put ( fullConstructorName , null ) ; throw e ; } } public static Constructor < ? > findConstructorBestMatch ( Class < ? > clazz , Object ... args ) { return findConstructorBestMatch ( clazz , getParameterTypes ( args ) ) ; } public static Constructor < ? > findConstructorBestMatch ( Class < ? > clazz , Class < ? > [ ] parameterTypes , Object [ ] args ) { Class < ? > [ ] argsClasses = null ; for ( int i = <NUM_LIT> ; i < parameterTypes . length ; i ++ ) { if ( parameterTypes [ i ] != null ) continue ; if ( argsClasses == null ) argsClasses = getParameterTypes ( args ) ; parameterTypes [ i ] = argsClasses [ i ] ; } return findConstructorBestMatch ( clazz , parameterTypes ) ; } public static final class ClassNotFoundError extends Error { private static final long serialVersionUID = - <NUM_LIT> ; public ClassNotFoundError ( Throwable cause ) { super ( cause ) ; } public ClassNotFoundError ( String detailMessage , Throwable cause ) { super ( detailMessage , cause ) ; } } public static int getFirstParameterIndexByType ( Member method , Class < ? > type ) { Class < ? > [ ] classes = ( method instanceof Method ) ? ( ( Method ) method ) . getParameterTypes ( ) : ( ( Constructor ) method ) . getParameterTypes ( ) ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { if ( classes [ i ] == type ) { return i ; } } throw new NoSuchFieldError ( "<STR_LIT>" + type + "<STR_LIT>" + method ) ; } public static int getParameterIndexByType ( Member method , Class < ? > type ) { Class < ? > [ ] classes = ( method instanceof Method ) ? ( ( Method ) method ) . getParameterTypes ( ) : ( ( Constructor ) method ) . getParameterTypes ( ) ; int idx = - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { if ( classes [ i ] == type ) { if ( idx == - <NUM_LIT> ) { idx = i ; } else { throw new NoSuchFieldError ( "<STR_LIT>" + type + "<STR_LIT>" + method ) ; } } } if ( idx != - <NUM_LIT> ) { return idx ; } else { throw new NoSuchFieldError ( "<STR_LIT>" + type + "<STR_LIT>" + method ) ; } } public static void setObjectField ( Object obj , String fieldName , Object value ) { try { findField ( obj . getClass ( ) , fieldName ) . set ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setBooleanField ( Object obj , String fieldName , boolean value ) { try { findField ( obj . getClass ( ) , fieldName ) . setBoolean ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setByteField ( Object obj , String fieldName , byte value ) { try { findField ( obj . getClass ( ) , fieldName ) . setByte ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setCharField ( Object obj , String fieldName , char value ) { try { findField ( obj . getClass ( ) , fieldName ) . setChar ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setDoubleField ( Object obj , String fieldName , double value ) { try { findField ( obj . getClass ( ) , fieldName ) . setDouble ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setFloatField ( Object obj , String fieldName , float value ) { try { findField ( obj . getClass ( ) , fieldName ) . setFloat ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setIntField ( Object obj , String fieldName , int value ) { try { findField ( obj . getClass ( ) , fieldName ) . setInt ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setLongField ( Object obj , String fieldName , long value ) { try { findField ( obj . getClass ( ) , fieldName ) . setLong ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setShortField ( Object obj , String fieldName , short value ) { try { findField ( obj . getClass ( ) , fieldName ) . setShort ( obj , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static Object getObjectField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . get ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static Object getSurroundingThis ( Object obj ) { return getObjectField ( obj , "<STR_LIT>" ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public static boolean getBooleanField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getBoolean ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static byte getByteField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getByte ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static char getCharField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getChar ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static double getDoubleField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getDouble ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static float getFloatField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getFloat ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static int getIntField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getInt ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static long getLongField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getLong ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static short getShortField ( Object obj , String fieldName ) { try { return findField ( obj . getClass ( ) , fieldName ) . getShort ( obj ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticObjectField ( Class < ? > clazz , String fieldName , Object value ) { try { findField ( clazz , fieldName ) . set ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticBooleanField ( Class < ? > clazz , String fieldName , boolean value ) { try { findField ( clazz , fieldName ) . setBoolean ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticByteField ( Class < ? > clazz , String fieldName , byte value ) { try { findField ( clazz , fieldName ) . setByte ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticCharField ( Class < ? > clazz , String fieldName , char value ) { try { findField ( clazz , fieldName ) . setChar ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticDoubleField ( Class < ? > clazz , String fieldName , double value ) { try { findField ( clazz , fieldName ) . setDouble ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticFloatField ( Class < ? > clazz , String fieldName , float value ) { try { findField ( clazz , fieldName ) . setFloat ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticIntField ( Class < ? > clazz , String fieldName , int value ) { try { findField ( clazz , fieldName ) . setInt ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticLongField ( Class < ? > clazz , String fieldName , long value ) { try { findField ( clazz , fieldName ) . setLong ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static void setStaticShortField ( Class < ? > clazz , String fieldName , short value ) { try { findField ( clazz , fieldName ) . setShort ( null , value ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static Object getStaticObjectField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . get ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static boolean getStaticBooleanField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getBoolean ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static byte getStaticByteField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getByte ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static char getStaticCharField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getChar ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static double getStaticDoubleField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getDouble ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static float getStaticFloatField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getFloat ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static int getStaticIntField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getInt ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static long getStaticLongField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getLong ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static short getStaticShortField ( Class < ? > clazz , String fieldName ) { try { return findField ( clazz , fieldName ) . getShort ( null ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } } public static Object callMethod ( Object obj , String methodName , Object ... args ) { try { return findMethodBestMatch ( obj . getClass ( ) , methodName , args ) . invoke ( obj , args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } } public static Object callMethod ( Object obj , String methodName , Class < ? > [ ] parameterTypes , Object ... args ) { try { return findMethodBestMatch ( obj . getClass ( ) , methodName , parameterTypes , args ) . invoke ( obj , args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } } public static Object callStaticMethod ( Class < ? > clazz , String methodName , Object ... args ) { try { return findMethodBestMatch ( clazz , methodName , args ) . invoke ( null , args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } } public static Object callStaticMethod ( Class < ? > clazz , String methodName , Class < ? > [ ] parameterTypes , Object ... args ) { try { return findMethodBestMatch ( clazz , methodName , parameterTypes , args ) . invoke ( null , args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } } public static final class InvocationTargetError extends Error { private static final long serialVersionUID = - <NUM_LIT> ; public InvocationTargetError ( Throwable cause ) { super ( cause ) ; } } public static Object newInstance ( Class < ? > clazz , Object ... args ) { try { return findConstructorBestMatch ( clazz , args ) . newInstance ( args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } catch ( InstantiationException e ) { throw new InstantiationError ( e . getMessage ( ) ) ; } } public static Object newInstance ( Class < ? > clazz , Class < ? > [ ] parameterTypes , Object ... args ) { try { return findConstructorBestMatch ( clazz , parameterTypes , args ) . newInstance ( args ) ; } catch ( IllegalAccessException e ) { XposedBridge . log ( e ) ; throw new IllegalAccessError ( e . getMessage ( ) ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( InvocationTargetException e ) { throw new InvocationTargetError ( e . getCause ( ) ) ; } catch ( InstantiationException e ) { throw new InstantiationError ( e . getMessage ( ) ) ; } } public static Object setAdditionalInstanceField ( Object obj , String key , Object value ) { if ( obj == null ) throw new NullPointerException ( "<STR_LIT>" ) ; if ( key == null ) throw new NullPointerException ( "<STR_LIT>" ) ; HashMap < String , Object > objectFields ; synchronized ( additionalFields ) { objectFields = additionalFields . get ( obj ) ; if ( objectFields == null ) { objectFields = new HashMap < > ( ) ; additionalFields . put ( obj , objectFields ) ; } } synchronized ( objectFields ) { return objectFields . put ( key , value ) ; } } public static Object getAdditionalInstanceField ( Object obj , String key ) { if ( obj == null ) throw new NullPointerException ( "<STR_LIT>" ) ; if ( key == null ) throw new NullPointerException ( "<STR_LIT>" ) ; HashMap < String , Object > objectFields ; synchronized ( additionalFields ) { objectFields = additionalFields . get ( obj ) ; if ( objectFields == null ) return null ; } synchronized ( objectFields ) { return objectFields . get ( key ) ; } } public static Object removeAdditionalInstanceField ( Object obj , String key ) { if ( obj == null ) throw new NullPointerException ( "<STR_LIT>" ) ; if ( key == null ) throw new NullPointerException ( "<STR_LIT>" ) ; HashMap < String , Object > objectFields ; synchronized ( additionalFields ) { objectFields = additionalFields . get ( obj ) ; if ( objectFields == null ) return null ; } synchronized ( objectFields ) { return objectFields . remove ( key ) ; } } public static Object setAdditionalStaticField ( Object obj , String key , Object value ) { return setAdditionalInstanceField ( obj . getClass ( ) , key , value ) ; } public static Object getAdditionalStaticField ( Object obj , String key ) { return getAdditionalInstanceField ( obj . getClass ( ) , key ) ; } public static Object removeAdditionalStaticField ( Object obj , String key ) { return removeAdditionalInstanceField ( obj . getClass ( ) , key ) ; } public static Object setAdditionalStaticField ( Class < ? > clazz , String key , Object value ) { return setAdditionalInstanceField ( clazz , key , value ) ; } public static Object getAdditionalStaticField ( Class < ? > clazz , String key ) { return getAdditionalInstanceField ( clazz , key ) ; } public static Object removeAdditionalStaticField ( Class < ? > clazz , String key ) { return removeAdditionalInstanceField ( clazz , key ) ; } public static byte [ ] assetAsByteArray ( Resources res , String path ) throws IOException { return inputStreamToByteArray ( res . getAssets ( ) . open ( path ) ) ; } static byte [ ] inputStreamToByteArray ( InputStream is ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; byte [ ] temp = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = is . read ( temp ) ) > <NUM_LIT> ) { buf . write ( temp , <NUM_LIT> , read ) ; } is . close ( ) ; return buf . toByteArray ( ) ; } static void closeSilently ( Closeable c ) { if ( c != null ) { try { c . close ( ) ; } catch ( IOException ignored ) { } } } static void closeSilently ( DexFile dexFile ) { if ( dexFile != null ) { try { dexFile . close ( ) ; } catch ( IOException ignored ) { } } } static void closeSilently ( ZipFile zipFile ) { if ( zipFile != null ) { try { zipFile . close ( ) ; } catch ( IOException ignored ) { } } } public static String getMD5Sum ( String file ) throws IOException { try { MessageDigest digest = MessageDigest . getInstance ( "<STR_LIT>" ) ; InputStream is = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = is . read ( buffer ) ) > <NUM_LIT> ) { digest . update ( buffer , <NUM_LIT> , read ) ; } is . close ( ) ; byte [ ] md5sum = digest . digest ( ) ; BigInteger bigInt = new BigInteger ( <NUM_LIT> , md5sum ) ; return bigInt . toString ( <NUM_LIT> ) ; } catch ( NoSuchAlgorithmException e ) { return "<STR_LIT>" ; } } public static int incrementMethodDepth ( String method ) { return getMethodDepthCounter ( method ) . get ( ) . incrementAndGet ( ) ; } public static int decrementMethodDepth ( String method ) { return getMethodDepthCounter ( method ) . get ( ) . decrementAndGet ( ) ; } public static int getMethodDepth ( String method ) { return getMethodDepthCounter ( method ) . get ( ) . get ( ) ; } private static ThreadLocal < AtomicInteger > getMethodDepthCounter ( String method ) { synchronized ( sMethodDepth ) { ThreadLocal < AtomicInteger > counter = sMethodDepth . get ( method ) ; if ( counter == null ) { counter = new ThreadLocal < AtomicInteger > ( ) { @ Override protected AtomicInteger initialValue ( ) { return new AtomicInteger ( ) ; } } ; sMethodDepth . put ( method , counter ) ; } return counter ; } } static boolean fileContains ( File file , String str ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . contains ( str ) ) { return true ; } } return false ; } finally { closeSilently ( in ) ; } } static Method getOverriddenMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; if ( Modifier . isStatic ( modifiers ) || Modifier . isPrivate ( modifiers ) ) { return null ; } String name = method . getName ( ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; Class < ? > clazz = method . getDeclaringClass ( ) . getSuperclass ( ) ; while ( clazz != null ) { try { Method superMethod = clazz . getDeclaredMethod ( name , parameters ) ; modifiers = superMethod . getModifiers ( ) ; if ( ! Modifier . isPrivate ( modifiers ) && ! Modifier . isAbstract ( modifiers ) ) { return superMethod ; } else { return null ; } } catch ( NoSuchMethodException ignored ) { clazz = clazz . getSuperclass ( ) ; } } return null ; } static Set < Method > getOverriddenMethods ( Class < ? > clazz ) { Set < Method > methods = new HashSet < > ( ) ; for ( Method method : clazz . getDeclaredMethods ( ) ) { Method overridden = getOverriddenMethod ( method ) ; if ( overridden != null ) { methods . add ( overridden ) ; } } return methods ; } } </s>
<s> package android . os ; public class SELinux { public static final String getContext ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static final boolean isSELinuxEnabled ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static final boolean isSELinuxEnforced ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package de . robv . android . xposed ; public interface IXposedHookZygoteInit extends IXposedMod { void initZygote ( StartupParam startupParam ) throws Throwable ; final class StartupParam { StartupParam ( ) { } public String modulePath ; public boolean startsSystemServer ; } } </s>
<s> package de . robv . android . xposed . services ; import java . io . IOException ; import java . util . Arrays ; @ SuppressWarnings ( "<STR_LIT>" ) public final class ZygoteService extends BaseService { @ Override public native boolean checkFileAccess ( String filename , int mode ) ; @ Override public native FileResult statFile ( String filename ) throws IOException ; @ Override public native byte [ ] readFile ( String filename ) throws IOException ; @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { FileResult stat = statFile ( filename ) ; if ( previousSize == stat . size && previousTime == stat . mtime ) return stat ; return new FileResult ( readFile ( filename ) , stat . size , stat . mtime ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { FileResult stat = statFile ( filename ) ; if ( previousSize == stat . size && previousTime == stat . mtime ) return stat ; if ( offset <= <NUM_LIT> && length <= <NUM_LIT> ) return new FileResult ( readFile ( filename ) , stat . size , stat . mtime ) ; if ( offset > <NUM_LIT> && offset >= stat . size ) { throw new IllegalArgumentException ( "<STR_LIT>" + offset + "<STR_LIT>" + stat . size + "<STR_LIT>" + filename ) ; } else if ( offset < <NUM_LIT> ) { offset = <NUM_LIT> ; } if ( length > <NUM_LIT> && ( offset + length ) > stat . size ) { throw new IllegalArgumentException ( "<STR_LIT>" + offset + "<STR_LIT>" + length + "<STR_LIT>" + stat . size + "<STR_LIT>" + filename ) ; } else if ( length <= <NUM_LIT> ) { length = ( int ) ( stat . size - offset ) ; } byte [ ] content = readFile ( filename ) ; return new FileResult ( Arrays . copyOfRange ( content , offset , offset + length ) , stat . size , stat . mtime ) ; } } </s>
<s> package de . robv . android . xposed ; public interface IXposedHookCmdInit extends IXposedMod { void initCmdApp ( StartupParam startupParam ) throws Throwable ; final class StartupParam { StartupParam ( ) { } public String modulePath ; public String startClassName ; } } </s>
<s> package external . org . apache . commons . lang3 . builder ; import external . org . apache . commons . lang3 . ObjectUtils ; public class ToStringBuilder implements Builder < String > { private static volatile ToStringStyle defaultStyle = ToStringStyle . DEFAULT_STYLE ; public static ToStringStyle getDefaultStyle ( ) { return defaultStyle ; } public static void setDefaultStyle ( ToStringStyle style ) { if ( style == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } defaultStyle = style ; } public static String reflectionToString ( Object object ) { return ReflectionToStringBuilder . toString ( object ) ; } public static String reflectionToString ( Object object , ToStringStyle style ) { return ReflectionToStringBuilder . toString ( object , style ) ; } public static String reflectionToString ( Object object , ToStringStyle style , boolean outputTransients ) { return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , null ) ; } public static < T > String reflectionToString ( T object , ToStringStyle style , boolean outputTransients , Class < ? super T > reflectUpToClass ) { return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , reflectUpToClass ) ; } private final StringBuffer buffer ; private final Object object ; private final ToStringStyle style ; public ToStringBuilder ( Object object ) { this ( object , null , null ) ; } public ToStringBuilder ( Object object , ToStringStyle style ) { this ( object , style , null ) ; } public ToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { if ( style == null ) { style = getDefaultStyle ( ) ; } if ( buffer == null ) { buffer = new StringBuffer ( <NUM_LIT> ) ; } this . buffer = buffer ; this . style = style ; this . object = object ; style . appendStart ( buffer , object ) ; } public ToStringBuilder append ( boolean value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( boolean [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( byte value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( byte [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( char value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( char [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( double value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( double [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( float value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( float [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( int value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( int [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( long value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( long [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( Object obj ) { style . append ( buffer , null , obj , null ) ; return this ; } public ToStringBuilder append ( Object [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( short value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( short [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , byte value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , byte [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , byte [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , char value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , char [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , char [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , double value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , double [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , double [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , float value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , float [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , float [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , int value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , int [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , int [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , long value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , long [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , long [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , Object obj ) { style . append ( buffer , fieldName , obj , null ) ; return this ; } public ToStringBuilder append ( String fieldName , Object obj , boolean fullDetail ) { style . append ( buffer , fieldName , obj , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , Object [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , Object [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , short value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , short [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , short [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder appendAsObjectToString ( Object object ) { ObjectUtils . identityToString ( this . getStringBuffer ( ) , object ) ; return this ; } public ToStringBuilder appendSuper ( String superToString ) { if ( superToString != null ) { style . appendSuper ( buffer , superToString ) ; } return this ; } public ToStringBuilder appendToString ( String toString ) { if ( toString != null ) { style . appendToString ( buffer , toString ) ; } return this ; } public Object getObject ( ) { return object ; } public StringBuffer getStringBuffer ( ) { return buffer ; } public ToStringStyle getStyle ( ) { return style ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { this . getStringBuffer ( ) . append ( this . getStyle ( ) . getNullText ( ) ) ; } else { style . appendEnd ( this . getStringBuffer ( ) , this . getObject ( ) ) ; } return this . getStringBuffer ( ) . toString ( ) ; } public String build ( ) { return toString ( ) ; } } </s>
<s> package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . util . Log ; import com . android . internal . os . RuntimeInit ; import com . android . internal . os . ZygoteInit ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Constructor ; import java . lang . reflect . Executable ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import dalvik . system . PathClassLoader ; import de . robv . android . xposed . XC_MethodHook . MethodHookParam ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import top . bienvenido . xposedcompat . JKLog ; import top . bienvenido . xposedcompat . MundoXposedBridge ; import static de . robv . android . xposed . XposedHelpers . getIntField ; import static de . robv . android . xposed . XposedHelpers . setObjectField ; @ SuppressWarnings ( "<STR_LIT>" ) public final class XposedBridge { public static final ClassLoader BOOTCLASSLOADER = ClassLoader . getSystemClassLoader ( ) ; public static final String TAG = "<STR_LIT>" ; @ Deprecated public static int XPOSED_BRIDGE_VERSION = <NUM_LIT> ; static boolean isZygote = true ; private static final int RUNTIME_DALVIK = <NUM_LIT> ; private static final int RUNTIME_ART = <NUM_LIT> ; static boolean disableHooks = false ; static long BOOT_START_TIME ; private static final Object [ ] EMPTY_ARRAY = new Object [ <NUM_LIT> ] ; private static final Map < Member , CopyOnWriteSortedSet < XC_MethodHook > > sHookedMethodCallbacks = new HashMap < > ( ) ; static final CopyOnWriteSortedSet < XC_LoadPackage > sLoadedPackageCallbacks = new CopyOnWriteSortedSet < > ( ) ; static final CopyOnWriteSortedSet < XC_InitPackageResources > sInitPackageResourcesCallbacks = new CopyOnWriteSortedSet < > ( ) ; private XposedBridge ( ) { } @ SuppressWarnings ( "<STR_LIT>" ) protected static void main ( String [ ] args ) { try { initXResources ( ) ; SELinuxHelper . initOnce ( ) ; SELinuxHelper . initForProcess ( null ) ; XPOSED_BRIDGE_VERSION = getXposedVersion ( ) ; if ( isZygote ) { XposedInit . hookResources ( ) ; XposedInit . initForZygote ( ) ; } XposedInit . loadModules ( ) ; } catch ( Throwable t ) { Log . e ( TAG , "<STR_LIT>" , t ) ; disableHooks = true ; } if ( isZygote ) { ZygoteInit . main ( args ) ; } else { RuntimeInit . main ( args ) ; } } protected static final class ToolEntryPoint { protected static void main ( String [ ] args ) { isZygote = false ; XposedBridge . main ( args ) ; } } private static void initXResources ( ) throws IOException { Resources res = Resources . getSystem ( ) ; File resDexFile = ensureSuperDexFile ( "<STR_LIT>" , res . getClass ( ) , Resources . class ) ; Class < ? > taClass = TypedArray . class ; try { TypedArray ta = res . obtainTypedArray ( res . getIdentifier ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ; taClass = ta . getClass ( ) ; ta . recycle ( ) ; } catch ( Resources . NotFoundException nfe ) { XposedBridge . log ( nfe ) ; } Runtime . getRuntime ( ) . gc ( ) ; File taDexFile = ensureSuperDexFile ( "<STR_LIT>" , taClass , TypedArray . class ) ; ClassLoader myCL = XposedBridge . class . getClassLoader ( ) ; String paths = resDexFile . getAbsolutePath ( ) + File . pathSeparator + taDexFile . getAbsolutePath ( ) ; PathClassLoader dummyCL = new PathClassLoader ( paths , myCL . getParent ( ) ) ; setObjectField ( myCL , "<STR_LIT>" , dummyCL ) ; } @ SuppressLint ( "<STR_LIT>" ) private static File ensureSuperDexFile ( String clz , Class < ? > realSuperClz , Class < ? > topClz ) throws IOException { File dexFile = DexCreator . ensure ( clz , realSuperClz , topClz ) ; dexFile . setReadable ( true , false ) ; return dexFile ; } public static int getXposedVersion ( ) { return <NUM_LIT> ; } public synchronized static void log ( String text ) { Log . i ( TAG , text ) ; } public synchronized static void log ( Throwable t ) { Log . e ( TAG , Log . getStackTraceString ( t ) ) ; } public static XC_MethodHook . Unhook hookMethod ( Member hookMethod , XC_MethodHook callback ) { if ( ! ( hookMethod instanceof Executable ) ) throw new IllegalArgumentException ( "<STR_LIT>" + hookMethod . toString ( ) ) ; boolean newMethod = false ; CopyOnWriteSortedSet < XC_MethodHook > callbacks ; synchronized ( sHookedMethodCallbacks ) { callbacks = sHookedMethodCallbacks . get ( hookMethod ) ; if ( callbacks == null ) { callbacks = new CopyOnWriteSortedSet < > ( ) ; sHookedMethodCallbacks . put ( hookMethod , callbacks ) ; newMethod = true ; } } callbacks . add ( callback ) ; if ( newMethod ) { AdditionalHookInfo additionalInfo = new AdditionalHookInfo ( callbacks ) ; hookMethodNative ( hookMethod , additionalInfo ) ; } return callback . new Unhook ( hookMethod ) ; } @ Deprecated public static void unhookMethod ( Member hookMethod , XC_MethodHook callback ) { CopyOnWriteSortedSet < XC_MethodHook > callbacks ; synchronized ( sHookedMethodCallbacks ) { callbacks = sHookedMethodCallbacks . get ( hookMethod ) ; if ( callbacks == null ) return ; } callbacks . remove ( callback ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public static Set < XC_MethodHook . Unhook > hookAllMethods ( Class < ? > hookClass , String methodName , XC_MethodHook callback ) { Set < XC_MethodHook . Unhook > unhooks = new HashSet < > ( ) ; for ( Member method : hookClass . getDeclaredMethods ( ) ) if ( method . getName ( ) . equals ( methodName ) ) unhooks . add ( hookMethod ( method , callback ) ) ; return unhooks ; } @ SuppressWarnings ( "<STR_LIT>" ) public static Set < XC_MethodHook . Unhook > hookAllConstructors ( Class < ? > hookClass , XC_MethodHook callback ) { Set < XC_MethodHook . Unhook > unhooks = new HashSet < > ( ) ; for ( Member constructor : hookClass . getDeclaredConstructors ( ) ) unhooks . add ( hookMethod ( constructor , callback ) ) ; return unhooks ; } private static Object handleHookedMethod ( Member method , int originalMethodId , Object additionalInfoObj , Object thisObject , Object [ ] args ) throws Throwable { AdditionalHookInfo additionalInfo = ( AdditionalHookInfo ) additionalInfoObj ; if ( disableHooks ) { return invokeOriginalMethodNative ( method , originalMethodId , thisObject , args ) ; } Object [ ] callbacksSnapshot = additionalInfo . callbacks . getSnapshot ( ) ; final int callbacksLength = callbacksSnapshot . length ; if ( callbacksLength == <NUM_LIT> ) { return invokeOriginalMethodNative ( method , originalMethodId , thisObject , args ) ; } MethodHookParam param = new MethodHookParam ( ) ; param . method = method ; param . thisObject = thisObject ; param . args = args ; int beforeIdx = <NUM_LIT> ; do { try { ( ( XC_MethodHook ) callbacksSnapshot [ beforeIdx ] ) . beforeHookedMethod ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; param . setResult ( null ) ; param . returnEarly = false ; continue ; } if ( param . returnEarly ) { beforeIdx ++ ; break ; } } while ( ++ beforeIdx < callbacksLength ) ; if ( ! param . returnEarly ) { param . setResult ( invokeOriginalMethodNative ( method , originalMethodId , param . thisObject , param . args ) ) ; } int afterIdx = beforeIdx - <NUM_LIT> ; do { Object lastResult = param . getResult ( ) ; Throwable lastThrowable = param . getThrowable ( ) ; try { ( ( XC_MethodHook ) callbacksSnapshot [ afterIdx ] ) . afterHookedMethod ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; if ( lastThrowable == null ) param . setResult ( lastResult ) ; else param . setThrowable ( lastThrowable ) ; } } while ( -- afterIdx >= <NUM_LIT> ) ; if ( param . hasThrowable ( ) ) throw param . getThrowable ( ) ; else return param . getResult ( ) ; } public static void hookLoadPackage ( XC_LoadPackage callback ) { synchronized ( sLoadedPackageCallbacks ) { sLoadedPackageCallbacks . add ( callback ) ; } } public static void hookInitPackageResources ( XC_InitPackageResources callback ) { synchronized ( sInitPackageResourcesCallbacks ) { sInitPackageResourcesCallbacks . add ( callback ) ; } } private static void hookMethodNative ( Member method , AdditionalHookInfo additionalInfo ) { MundoXposedBridge . hookMethod ( method , additionalInfo ) ; } private synchronized static Object invokeOriginalMethodNative ( Member method , int methodId , Object thisObject , Object [ ] args ) { CopyOnWriteSortedSet < XC_MethodHook > callbacks = sHookedMethodCallbacks . get ( method ) ; Object res = null ; if ( callbacks != null ) { Object [ ] e = callbacks . elements ; callbacks . elements = new XC_MethodHook [ ] { } ; try { if ( method instanceof Constructor ) { res = ( ( Constructor < ? > ) method ) . newInstance ( args ) ; } else if ( method instanceof Method ) { res = ( ( Method ) method ) . invoke ( thisObject , args ) ; } } catch ( Throwable t ) { JKLog . INSTANCE . e ( t ) ; } callbacks . elements = e ; } return res ; } public static Object invokeOriginalMethod ( Member method , Object thisObject , Object [ ] args ) throws NullPointerException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { if ( args == null ) { args = EMPTY_ARRAY ; } return invokeOriginalMethodNative ( method , <NUM_LIT> , thisObject , args ) ; } public static final class CopyOnWriteSortedSet < E > { public transient volatile Object [ ] elements = EMPTY_ARRAY ; @ SuppressWarnings ( "<STR_LIT>" ) public synchronized boolean add ( E e ) { int index = indexOf ( e ) ; if ( index >= <NUM_LIT> ) return false ; Object [ ] newElements = new Object [ elements . length + <NUM_LIT> ] ; System . arraycopy ( elements , <NUM_LIT> , newElements , <NUM_LIT> , elements . length ) ; newElements [ elements . length ] = e ; Arrays . sort ( newElements ) ; elements = newElements ; return true ; } @ SuppressWarnings ( "<STR_LIT>" ) public synchronized boolean remove ( E e ) { int index = indexOf ( e ) ; if ( index == - <NUM_LIT> ) return false ; Object [ ] newElements = new Object [ elements . length - <NUM_LIT> ] ; System . arraycopy ( elements , <NUM_LIT> , newElements , <NUM_LIT> , index ) ; System . arraycopy ( elements , index + <NUM_LIT> , newElements , index , elements . length - index - <NUM_LIT> ) ; elements = newElements ; return true ; } private int indexOf ( Object o ) { for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( o . equals ( elements [ i ] ) ) return i ; } return - <NUM_LIT> ; } public Object [ ] getSnapshot ( ) { return elements ; } } public static class AdditionalHookInfo { public final CopyOnWriteSortedSet < XC_MethodHook > callbacks ; private AdditionalHookInfo ( CopyOnWriteSortedSet < XC_MethodHook > callbacks ) { this . callbacks = callbacks ; } } } </s>
<s> package android . content . res ; import android . os . Parcel ; import android . os . Parcelable ; public class CompatibilityInfo implements Parcelable { @ Override public int describeContents ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static final Parcelable . Creator < CompatibilityInfo > CREATOR = null ; } </s>
<s> package external . org . apache . commons . lang3 ; public enum JavaVersion { JAVA_0_9 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_1 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_2 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_3 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_4 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_5 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_6 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_7 ( <NUM_LIT> , "<STR_LIT>" ) , JAVA_1_8 ( <NUM_LIT> , "<STR_LIT>" ) ; private float value ; private String name ; JavaVersion ( final float value , final String name ) { this . value = value ; this . name = name ; } public boolean atLeast ( JavaVersion requiredVersion ) { return this . value >= requiredVersion . value ; } static JavaVersion getJavaVersion ( final String nom ) { return get ( nom ) ; } static JavaVersion get ( final String nom ) { if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_0_9 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_1 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_2 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_3 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_4 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_5 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_6 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_7 ; } else if ( "<STR_LIT>" . equals ( nom ) ) { return JAVA_1_8 ; } else { return null ; } } @ Override public String toString ( ) { return name ; } } </s>
<s> package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . app . ActivityThread ; import android . app . AndroidAppHelper ; import android . app . Application ; import android . app . LoadedApk ; import android . content . ComponentName ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . content . res . XResources ; import android . os . Build ; import android . os . Environment ; import android . os . IBinder ; import android . os . Process ; import android . util . Log ; import android . widget . Toast ; import com . android . internal . os . ZygoteInit ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . lang . ref . WeakReference ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import dalvik . system . DexFile ; import dalvik . system . PathClassLoader ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import de . robv . android . xposed . callbacks . XCallback ; import de . robv . android . xposed . services . BaseService ; import static de . robv . android . xposed . XposedBridge . hookAllConstructors ; import static de . robv . android . xposed . XposedBridge . hookAllMethods ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . closeSilently ; import static de . robv . android . xposed . XposedHelpers . fileContains ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import static de . robv . android . xposed . XposedHelpers . findClass ; import static de . robv . android . xposed . XposedHelpers . findFieldIfExists ; import static de . robv . android . xposed . XposedHelpers . getBooleanField ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import static de . robv . android . xposed . XposedHelpers . getOverriddenMethods ; import static de . robv . android . xposed . XposedHelpers . getParameterIndexByType ; import static de . robv . android . xposed . XposedHelpers . setObjectField ; import static de . robv . android . xposed . XposedHelpers . setStaticBooleanField ; import static de . robv . android . xposed . XposedHelpers . setStaticLongField ; import static de . robv . android . xposed . XposedHelpers . setStaticObjectField ; final class XposedInit { private static final String TAG = XposedBridge . TAG ; private static final boolean startsSystemServer = true ; private static final String INSTALLER_PACKAGE_NAME = "<STR_LIT>" ; @ SuppressLint ( "<STR_LIT>" ) private static final String BASE_DIR = Build . VERSION . SDK_INT >= <NUM_LIT> ? "<STR_LIT>" + INSTALLER_PACKAGE_NAME + "<STR_LIT>" : "<STR_LIT>" + INSTALLER_PACKAGE_NAME + "<STR_LIT>" ; private static final String INSTANT_RUN_CLASS = "<STR_LIT>" ; private static boolean disableResources = false ; private static final String [ ] XRESOURCES_CONFLICTING_PACKAGES = { "<STR_LIT>" } ; private XposedInit ( ) { } static void initForZygote ( ) throws Throwable { if ( needsToCloseFilesForFork ( ) ) { XC_MethodHook callback = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { } } ; Class < ? > zygote = findClass ( "<STR_LIT>" , null ) ; hookAllMethods ( zygote , "<STR_LIT>" , callback ) ; hookAllMethods ( zygote , "<STR_LIT>" , callback ) ; } final HashSet < String > loadedPackagesInProcess = new HashSet < > ( <NUM_LIT> ) ; findAndHookMethod ( ActivityThread . class , "<STR_LIT>" , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { ActivityThread activityThread = ( ActivityThread ) param . thisObject ; ApplicationInfo appInfo = ( ApplicationInfo ) getObjectField ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; String reportedPackageName = appInfo . packageName . equals ( "<STR_LIT>" ) ? "<STR_LIT>" : appInfo . packageName ; SELinuxHelper . initForProcess ( reportedPackageName ) ; ComponentName instrumentationName = ( ComponentName ) getObjectField ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( instrumentationName != null ) { Log . w ( TAG , "<STR_LIT>" + reportedPackageName ) ; XposedBridge . disableHooks = true ; return ; } CompatibilityInfo compatInfo = ( CompatibilityInfo ) getObjectField ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( appInfo . sourceDir == null ) return ; setObjectField ( activityThread , "<STR_LIT>" , param . args [ <NUM_LIT> ] ) ; loadedPackagesInProcess . add ( reportedPackageName ) ; LoadedApk loadedApk = activityThread . getPackageInfoNoCheck ( appInfo , compatInfo ) ; XResources . setPackageNameForResDir ( appInfo . packageName , loadedApk . getResDir ( ) ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = reportedPackageName ; lpparam . processName = ( String ) getObjectField ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; lpparam . classLoader = loadedApk . getClassLoader ( ) ; lpparam . appInfo = appInfo ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; if ( reportedPackageName . equals ( INSTALLER_PACKAGE_NAME ) ) hookXposedInstaller ( lpparam . classLoader ) ; } } ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { findAndHookMethod ( "<STR_LIT>" , null , Build . VERSION . SDK_INT < <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { SELinuxHelper . initForProcess ( "<STR_LIT>" ) ; loadedPackagesInProcess . add ( "<STR_LIT>" ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = "<STR_LIT>" ; lpparam . processName = "<STR_LIT>" ; lpparam . classLoader = XposedBridge . BOOTCLASSLOADER ; lpparam . appInfo = null ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; } } ) ; } else if ( startsSystemServer ) { findAndHookMethod ( ActivityThread . class , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { final ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; findAndHookMethod ( "<STR_LIT>" , cl , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { SELinuxHelper . initForProcess ( "<STR_LIT>" ) ; loadedPackagesInProcess . add ( "<STR_LIT>" ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = "<STR_LIT>" ; lpparam . processName = "<STR_LIT>" ; lpparam . classLoader = cl ; lpparam . appInfo = null ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; try { findAndHookMethod ( "<STR_LIT>" , cl , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( false ) ) ; } catch ( XposedHelpers . ClassNotFoundError | NoSuchMethodError ignored ) { } try { String className = "<STR_LIT>" + ( Build . VERSION . SDK_INT >= <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" ) ; findAndHookMethod ( className , cl , "<STR_LIT>" , String . class , XC_MethodReplacement . returnConstant ( true ) ) ; } catch ( XposedHelpers . ClassNotFoundError | NoSuchMethodError ignored ) { } } } ) ; } } ) ; } hookAllConstructors ( LoadedApk . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { LoadedApk loadedApk = ( LoadedApk ) param . thisObject ; String packageName = loadedApk . getPackageName ( ) ; XResources . setPackageNameForResDir ( packageName , loadedApk . getResDir ( ) ) ; if ( packageName . equals ( "<STR_LIT>" ) || ! loadedPackagesInProcess . add ( packageName ) ) return ; if ( ! getBooleanField ( loadedApk , "<STR_LIT>" ) ) return ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = packageName ; lpparam . processName = AndroidAppHelper . currentProcessName ( ) ; lpparam . classLoader = loadedApk . getClassLoader ( ) ; lpparam . appInfo = loadedApk . getApplicationInfo ( ) ; lpparam . isFirstApplication = false ; XC_LoadPackage . callAll ( lpparam ) ; } } ) ; findAndHookMethod ( "<STR_LIT>" , null , "<STR_LIT>" , ApplicationInfo . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { ApplicationInfo app = ( ApplicationInfo ) param . args [ <NUM_LIT> ] ; XResources . setPackageNameForResDir ( app . packageName , app . uid == Process . myUid ( ) ? app . sourceDir : app . publicSourceDir ) ; } } ) ; if ( findFieldIfExists ( ZygoteInit . class , "<STR_LIT>" ) != null ) { setStaticLongField ( ZygoteInit . class , "<STR_LIT>" , XposedBridge . BOOT_START_TIME ) ; } if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Class < ? > zygote = findClass ( "<STR_LIT>" , null ) ; try { setStaticBooleanField ( zygote , "<STR_LIT>" , false ) ; } catch ( NoSuchFieldError ignored ) { } } } static void hookResources ( ) throws Throwable { if ( SELinuxHelper . getAppDataFileService ( ) . checkFileExists ( BASE_DIR + "<STR_LIT>" ) ) { Log . w ( TAG , "<STR_LIT>" + BASE_DIR + "<STR_LIT>" ) ; disableResources = true ; return ; } final Class < ? > classGTLR ; final Class < ? > classResKey ; final ThreadLocal < Object > latestResKey = new ThreadLocal < > ( ) ; if ( Build . VERSION . SDK_INT <= <NUM_LIT> ) { classGTLR = ActivityThread . class ; classResKey = Class . forName ( "<STR_LIT>" ) ; } else { classGTLR = Class . forName ( "<STR_LIT>" ) ; classResKey = Class . forName ( "<STR_LIT>" ) ; } XResources . init ( latestResKey ) ; } private static boolean needsToCloseFilesForFork ( ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { return true ; } else if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { return false ; } File lib = new File ( Environment . getRootDirectory ( ) , "<STR_LIT>" ) ; try { return fileContains ( lib , "<STR_LIT>" ) ; } catch ( IOException e ) { Log . e ( TAG , "<STR_LIT>" + lib + "<STR_LIT>" ) ; return true ; } } private static void hookXposedInstaller ( ClassLoader classLoader ) { try { findAndHookMethod ( INSTALLER_PACKAGE_NAME + "<STR_LIT>" , classLoader , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( XposedBridge . getXposedVersion ( ) ) ) ; findAndHookMethod ( INSTALLER_PACKAGE_NAME + "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Application application = ( Application ) param . thisObject ; Resources res = application . getResources ( ) ; if ( res . getIdentifier ( "<STR_LIT>" , "<STR_LIT>" , INSTALLER_PACKAGE_NAME ) == <NUM_LIT> ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" ) ; Toast . makeText ( application , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } } } ) ; } catch ( Throwable t ) { Log . e ( TAG , "<STR_LIT>" , t ) ; } } static void loadModules ( ) throws IOException { final String filename = BASE_DIR + "<STR_LIT>" ; BaseService service = SELinuxHelper . getAppDataFileService ( ) ; if ( ! service . checkFileExists ( filename ) ) { Log . e ( TAG , "<STR_LIT>" + filename + "<STR_LIT>" ) ; return ; } ClassLoader topClassLoader = XposedBridge . BOOTCLASSLOADER ; ClassLoader parent ; while ( ( parent = topClassLoader . getParent ( ) ) != null ) { topClassLoader = parent ; } InputStream stream = service . getFileInputStream ( filename ) ; BufferedReader apks = new BufferedReader ( new InputStreamReader ( stream ) ) ; String apk ; while ( ( apk = apks . readLine ( ) ) != null ) { loadModule ( apk , topClassLoader ) ; } apks . close ( ) ; } private static void loadModule ( String apk , ClassLoader topClassLoader ) { Log . i ( TAG , "<STR_LIT>" + apk ) ; if ( ! new File ( apk ) . exists ( ) ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } DexFile dexFile ; try { dexFile = new DexFile ( apk ) ; } catch ( IOException e ) { Log . e ( TAG , "<STR_LIT>" , e ) ; return ; } if ( dexFile . loadClass ( INSTANT_RUN_CLASS , topClassLoader ) != null ) { Log . e ( TAG , "<STR_LIT>" ) ; closeSilently ( dexFile ) ; return ; } if ( dexFile . loadClass ( XposedBridge . class . getName ( ) , topClassLoader ) != null ) { Log . e ( TAG , "<STR_LIT>" ) ; Log . e ( TAG , "<STR_LIT>" ) ; Log . e ( TAG , "<STR_LIT>" ) ; Log . e ( TAG , "<STR_LIT>" ) ; closeSilently ( dexFile ) ; return ; } closeSilently ( dexFile ) ; ZipFile zipFile = null ; InputStream is ; try { zipFile = new ZipFile ( apk ) ; ZipEntry zipEntry = zipFile . getEntry ( "<STR_LIT>" ) ; if ( zipEntry == null ) { Log . e ( TAG , "<STR_LIT>" ) ; closeSilently ( zipFile ) ; return ; } is = zipFile . getInputStream ( zipEntry ) ; } catch ( IOException e ) { Log . e ( TAG , "<STR_LIT>" , e ) ; closeSilently ( zipFile ) ; return ; } ClassLoader mcl = new PathClassLoader ( apk , XposedBridge . BOOTCLASSLOADER ) ; BufferedReader moduleClassesReader = new BufferedReader ( new InputStreamReader ( is ) ) ; try { String moduleClassName ; while ( ( moduleClassName = moduleClassesReader . readLine ( ) ) != null ) { moduleClassName = moduleClassName . trim ( ) ; if ( moduleClassName . isEmpty ( ) || moduleClassName . startsWith ( "<STR_LIT>" ) ) continue ; try { Log . i ( TAG , "<STR_LIT>" + moduleClassName ) ; Class < ? > moduleClass = mcl . loadClass ( moduleClassName ) ; if ( ! IXposedMod . class . isAssignableFrom ( moduleClass ) ) { Log . e ( TAG , "<STR_LIT>" ) ; continue ; } else if ( disableResources && IXposedHookInitPackageResources . class . isAssignableFrom ( moduleClass ) ) { Log . e ( TAG , "<STR_LIT>" ) ; continue ; } final Object moduleInstance = moduleClass . newInstance ( ) ; if ( XposedBridge . isZygote ) { if ( moduleInstance instanceof IXposedHookZygoteInit ) { IXposedHookZygoteInit . StartupParam param = new IXposedHookZygoteInit . StartupParam ( ) ; param . modulePath = apk ; param . startsSystemServer = startsSystemServer ; ( ( IXposedHookZygoteInit ) moduleInstance ) . initZygote ( param ) ; } if ( moduleInstance instanceof IXposedHookLoadPackage ) XposedBridge . hookLoadPackage ( new IXposedHookLoadPackage . Wrapper ( ( IXposedHookLoadPackage ) moduleInstance ) ) ; if ( moduleInstance instanceof IXposedHookInitPackageResources ) XposedBridge . hookInitPackageResources ( new IXposedHookInitPackageResources . Wrapper ( ( IXposedHookInitPackageResources ) moduleInstance ) ) ; } else { if ( moduleInstance instanceof IXposedHookCmdInit ) { IXposedHookCmdInit . StartupParam param = new IXposedHookCmdInit . StartupParam ( ) ; param . modulePath = apk ; param . startClassName = "<STR_LIT>" ; ( ( IXposedHookCmdInit ) moduleInstance ) . initCmdApp ( param ) ; } } } catch ( Throwable t ) { Log . e ( TAG , "<STR_LIT>" + moduleClassName , t ) ; } } } catch ( IOException e ) { Log . e ( TAG , "<STR_LIT>" + apk , e ) ; } finally { closeSilently ( is ) ; closeSilently ( zipFile ) ; } } } </s>
<s> package de . robv . android . xposed ; import android . content . res . XResources ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_InitPackageResources . InitPackageResourcesParam ; public interface IXposedHookInitPackageResources extends IXposedMod { void handleInitPackageResources ( InitPackageResourcesParam resparam ) throws Throwable ; final class Wrapper extends XC_InitPackageResources { private final IXposedHookInitPackageResources instance ; public Wrapper ( IXposedHookInitPackageResources instance ) { this . instance = instance ; } @ Override public void handleInitPackageResources ( InitPackageResourcesParam resparam ) throws Throwable { instance . handleInitPackageResources ( resparam ) ; } } } </s>
<s> package xposed . dummy ; import android . content . res . Resources ; public class XResourcesSuperClass extends Resources { protected XResourcesSuperClass ( ) { super ( null , null , null ) ; throw new UnsupportedOperationException ( ) ; } } </s>
<s> package de . robv . android . xposed . services ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; public final class DirectAccessService extends BaseService { @ Override public boolean hasDirectFileAccess ( ) { return true ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public boolean checkFileAccess ( String filename , int mode ) { File file = new File ( filename ) ; if ( mode == F_OK && ! file . exists ( ) ) return false ; if ( ( mode & R_OK ) != <NUM_LIT> && ! file . canRead ( ) ) return false ; if ( ( mode & W_OK ) != <NUM_LIT> && ! file . canWrite ( ) ) return false ; if ( ( mode & X_OK ) != <NUM_LIT> && ! file . canExecute ( ) ) return false ; return true ; } @ Override public boolean checkFileExists ( String filename ) { return new File ( filename ) . exists ( ) ; } @ Override public FileResult statFile ( String filename ) throws IOException { File file = new File ( filename ) ; return new FileResult ( file . length ( ) , file . lastModified ( ) ) ; } @ Override public byte [ ] readFile ( String filename ) throws IOException { File file = new File ( filename ) ; byte content [ ] = new byte [ ( int ) file . length ( ) ] ; FileInputStream fis = new FileInputStream ( file ) ; fis . read ( content ) ; fis . close ( ) ; return content ; } @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; return new FileResult ( readFile ( filename ) , size , time ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; if ( offset <= <NUM_LIT> && length <= <NUM_LIT> ) return new FileResult ( readFile ( filename ) , size , time ) ; if ( offset > <NUM_LIT> && offset >= size ) { throw new IllegalArgumentException ( "<STR_LIT>" + offset + "<STR_LIT>" + filename ) ; } else if ( offset < <NUM_LIT> ) { offset = <NUM_LIT> ; } if ( length > <NUM_LIT> && ( offset + length ) > size ) { throw new IllegalArgumentException ( "<STR_LIT>" + length + "<STR_LIT>" + filename ) ; } else if ( length <= <NUM_LIT> ) { length = ( int ) ( size - offset ) ; } byte content [ ] = new byte [ length ] ; FileInputStream fis = new FileInputStream ( file ) ; fis . skip ( offset ) ; fis . read ( content ) ; fis . close ( ) ; return new FileResult ( content , size , time ) ; } @ Override public InputStream getFileInputStream ( String filename ) throws IOException { return new BufferedInputStream ( new FileInputStream ( filename ) , <NUM_LIT> * <NUM_LIT> ) ; } @ Override public FileResult getFileInputStream ( String filename , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; return new FileResult ( new BufferedInputStream ( new FileInputStream ( filename ) , <NUM_LIT> * <NUM_LIT> ) , size , time ) ; } } </s>
<s> package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import external . org . apache . commons . lang3 . ArrayUtils ; public class HashCodeBuilder implements Builder < Integer > { private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static Set < IDKey > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry != null && registry . contains ( new IDKey ( value ) ) ; } private static void reflectionAppend ( Object object , Class < ? > clazz , HashCodeBuilder builder , boolean useTransients , String [ ] excludeFields ) { if ( isRegistered ( object ) ) { return ; } try { register ( object ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { if ( ! ArrayUtils . contains ( excludeFields , field . getName ( ) ) && ( field . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( field . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) ) { try { Object fieldValue = field . get ( object ) ; builder . append ( fieldValue ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( "<STR_LIT>" ) ; } } } } finally { unregister ( object ) ; } } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object ) { return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object , boolean testTransients ) { return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass , String ... excludeFields ) { if ( object == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } HashCodeBuilder builder = new HashCodeBuilder ( initialNonZeroOddNumber , multiplierNonZeroOddNumber ) ; Class < ? > clazz = object . getClass ( ) ; reflectionAppend ( object , clazz , builder , testTransients , excludeFields ) ; while ( clazz . getSuperclass ( ) != null && clazz != reflectUpToClass ) { clazz = clazz . getSuperclass ( ) ; reflectionAppend ( object , clazz , builder , testTransients , excludeFields ) ; } return builder . toHashCode ( ) ; } public static int reflectionHashCode ( Object object , boolean testTransients ) { return reflectionHashCode ( <NUM_LIT> , <NUM_LIT> , object , testTransients , null ) ; } public static int reflectionHashCode ( Object object , Collection < String > excludeFields ) { return reflectionHashCode ( object , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static int reflectionHashCode ( Object object , String ... excludeFields ) { return reflectionHashCode ( <NUM_LIT> , <NUM_LIT> , object , false , null , excludeFields ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) == null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; if ( registry != null ) { registry . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { registry = getRegistry ( ) ; if ( registry != null && registry . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } private final int iConstant ; private int iTotal = <NUM_LIT> ; public HashCodeBuilder ( ) { iConstant = <NUM_LIT> ; iTotal = <NUM_LIT> ; } public HashCodeBuilder ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber ) { if ( initialNonZeroOddNumber == <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( initialNonZeroOddNumber % <NUM_LIT> == <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( multiplierNonZeroOddNumber == <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( multiplierNonZeroOddNumber % <NUM_LIT> == <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } iConstant = multiplierNonZeroOddNumber ; iTotal = initialNonZeroOddNumber ; } public HashCodeBuilder append ( boolean value ) { iTotal = iTotal * iConstant + ( value ? <NUM_LIT> : <NUM_LIT> ) ; return this ; } public HashCodeBuilder append ( boolean [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( boolean element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( byte value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( byte [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( byte element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( char value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( char [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( char element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( double value ) { return append ( Double . doubleToLongBits ( value ) ) ; } public HashCodeBuilder append ( double [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( double element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( float value ) { iTotal = iTotal * iConstant + Float . floatToIntBits ( value ) ; return this ; } public HashCodeBuilder append ( float [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( float element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( int value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( int [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( int element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( long value ) { iTotal = iTotal * iConstant + ( ( int ) ( value ^ ( value > > <NUM_LIT> ) ) ) ; return this ; } public HashCodeBuilder append ( long [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( long element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( Object object ) { if ( object == null ) { iTotal = iTotal * iConstant ; } else { if ( object . getClass ( ) . isArray ( ) ) { if ( object instanceof long [ ] ) { append ( ( long [ ] ) object ) ; } else if ( object instanceof int [ ] ) { append ( ( int [ ] ) object ) ; } else if ( object instanceof short [ ] ) { append ( ( short [ ] ) object ) ; } else if ( object instanceof char [ ] ) { append ( ( char [ ] ) object ) ; } else if ( object instanceof byte [ ] ) { append ( ( byte [ ] ) object ) ; } else if ( object instanceof double [ ] ) { append ( ( double [ ] ) object ) ; } else if ( object instanceof float [ ] ) { append ( ( float [ ] ) object ) ; } else if ( object instanceof boolean [ ] ) { append ( ( boolean [ ] ) object ) ; } else { append ( ( Object [ ] ) object ) ; } } else { iTotal = iTotal * iConstant + object . hashCode ( ) ; } } return this ; } public HashCodeBuilder append ( Object [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( Object element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( short value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( short [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( short element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder appendSuper ( int superHashCode ) { iTotal = iTotal * iConstant + superHashCode ; return this ; } public int toHashCode ( ) { return iTotal ; } public Integer build ( ) { return Integer . valueOf ( toHashCode ( ) ) ; } @ Override public int hashCode ( ) { return toHashCode ( ) ; } } </s>
<s> package android . content . res ; import android . graphics . drawable . Drawable ; public class TypedArray { TypedArray ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } protected TypedArray ( Resources resources , int [ ] data , int [ ] indices , int len ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public boolean getBoolean ( int index , boolean defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getColor ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public ColorStateList getColorStateList ( int index ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getDimension ( int index , float defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getDimensionPixelOffset ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getDimensionPixelSize ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawable ( int index ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getFloat ( int index , float defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getFraction ( int index , int base , int pbase , float defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getInt ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getInteger ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getLayoutDimension ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getLayoutDimension ( int index , String name ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getResourceId ( int index , int defValue ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Resources getResources ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getString ( int index ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence getText ( int index ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence [ ] getTextArray ( int index ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public void recycle ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package de . robv . android . xposed ; interface IXposedMod { } </s>
<s> package xposed . dummy ; import android . content . res . Resources ; import android . content . res . TypedArray ; public class XTypedArraySuperClass extends TypedArray { protected XTypedArraySuperClass ( Resources resources , int [ ] data , int [ ] indices , int len ) { super ( null , null , null , <NUM_LIT> ) ; throw new UnsupportedOperationException ( ) ; } } </s>
<s> package de . robv . android . xposed ; import android . app . Application ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import de . robv . android . xposed . callbacks . XC_LoadPackage . LoadPackageParam ; public interface IXposedHookLoadPackage extends IXposedMod { void handleLoadPackage ( LoadPackageParam lpparam ) throws Throwable ; final class Wrapper extends XC_LoadPackage { private final IXposedHookLoadPackage instance ; public Wrapper ( IXposedHookLoadPackage instance ) { this . instance = instance ; } @ Override public void handleLoadPackage ( LoadPackageParam lpparam ) throws Throwable { instance . handleLoadPackage ( lpparam ) ; } } } </s>
<s> package external . org . apache . commons . lang3 ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . regex . Pattern ; public class StringUtils { public static final String EMPTY = "<STR_LIT>" ; public static final int INDEX_NOT_FOUND = - <NUM_LIT> ; private static final int PAD_LIMIT = <NUM_LIT> ; private static final Pattern WHITESPACE_BLOCK = Pattern . compile ( "<STR_LIT>" ) ; public StringUtils ( ) { super ( ) ; } public static boolean isEmpty ( CharSequence cs ) { return cs == null || cs . length ( ) == <NUM_LIT> ; } public static boolean isNotEmpty ( CharSequence cs ) { return ! StringUtils . isEmpty ( cs ) ; } public static boolean isBlank ( CharSequence cs ) { int strLen ; if ( cs == null || ( strLen = cs . length ( ) ) == <NUM_LIT> ) { return true ; } for ( int i = <NUM_LIT> ; i < strLen ; i ++ ) { if ( Character . isWhitespace ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isNotBlank ( CharSequence cs ) { return ! StringUtils . isBlank ( cs ) ; } public static String trim ( String str ) { return str == null ? null : str . trim ( ) ; } public static String trimToNull ( String str ) { String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; } public static String trimToEmpty ( String str ) { return str == null ? EMPTY : str . trim ( ) ; } public static String strip ( String str ) { return strip ( str , null ) ; } public static String stripToNull ( String str ) { if ( str == null ) { return null ; } str = strip ( str , null ) ; return str . length ( ) == <NUM_LIT> ? null : str ; } public static String stripToEmpty ( String str ) { return str == null ? EMPTY : strip ( str , null ) ; } public static String strip ( String str , String stripChars ) { if ( isEmpty ( str ) ) { return str ; } str = stripStart ( str , stripChars ) ; return stripEnd ( str , stripChars ) ; } public static String stripStart ( String str , String stripChars ) { int strLen ; if ( str == null || ( strLen = str . length ( ) ) == <NUM_LIT> ) { return str ; } int start = <NUM_LIT> ; if ( stripChars == null ) { while ( start != strLen && Character . isWhitespace ( str . charAt ( start ) ) ) { start ++ ; } } else if ( stripChars . length ( ) == <NUM_LIT> ) { return str ; } else { while ( start != strLen && stripChars . indexOf ( str . charAt ( start ) ) != INDEX_NOT_FOUND ) { start ++ ; } } return str . substring ( start ) ; } public static String stripEnd ( String str , String stripChars ) { int end ; if ( str == null || ( end = str . length ( ) ) == <NUM_LIT> ) { return str ; } if ( stripChars == null ) { while ( end != <NUM_LIT> && Character . isWhitespace ( str . charAt ( end - <NUM_LIT> ) ) ) { end -- ; } } else if ( stripChars . length ( ) == <NUM_LIT> ) { return str ; } else { while ( end != <NUM_LIT> && stripChars . indexOf ( str . charAt ( end - <NUM_LIT> ) ) != INDEX_NOT_FOUND ) { end -- ; } } return str . substring ( <NUM_LIT> , end ) ; } public static String [ ] stripAll ( String ... strs ) { return stripAll ( strs , null ) ; } public static String [ ] stripAll ( String [ ] strs , String stripChars ) { int strsLen ; if ( strs == null || ( strsLen = strs . length ) == <NUM_LIT> ) { return strs ; } String [ ] newArr = new String [ strsLen ] ; for ( int i = <NUM_LIT> ; i < strsLen ; i ++ ) { newArr [ i ] = strip ( strs [ i ] , stripChars ) ; } return newArr ; } public static String stripAccents ( String input ) { if ( input == null ) { return null ; } try { String result = null ; if ( InitStripAccents . java6NormalizeMethod != null ) { result = removeAccentsJava6 ( input ) ; } else if ( InitStripAccents . sunDecomposeMethod != null ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" + InitStripAccents . java6Exception + "<STR_LIT>" + InitStripAccents . sunException ) ; } return result ; } catch ( IllegalArgumentException iae ) { throw new RuntimeException ( "<STR_LIT>" , iae ) ; } catch ( IllegalAccessException iae ) { throw new RuntimeException ( "<STR_LIT>" , iae ) ; } catch ( InvocationTargetException ite ) { throw new RuntimeException ( "<STR_LIT>" , ite ) ; } catch ( SecurityException se ) { throw new RuntimeException ( "<STR_LIT>" , se ) ; } } private static String removeAccentsJava6 ( CharSequence text ) throws IllegalAccessException , InvocationTargetException { if ( InitStripAccents . java6NormalizeMethod == null || InitStripAccents . java6NormalizerFormNFD == null ) { throw new IllegalStateException ( "<STR_LIT>" , InitStripAccents . java6Exception ) ; } String result ; result = ( String ) InitStripAccents . java6NormalizeMethod . invoke ( null , new Object [ ] { text , InitStripAccents . java6NormalizerFormNFD } ) ; result = InitStripAccents . java6Pattern . matcher ( result ) . replaceAll ( "<STR_LIT>" ) ; return result ; } private static String removeAccentsSUN ( CharSequence text ) throws IllegalAccessException , InvocationTargetException { if ( InitStripAccents . sunDecomposeMethod == null ) { throw new IllegalStateException ( "<STR_LIT>" , InitStripAccents . sunException ) ; } String result ; result = ( String ) InitStripAccents . sunDecomposeMethod . invoke ( null , new Object [ ] { text , Boolean . FALSE , Integer . valueOf ( <NUM_LIT> ) } ) ; result = InitStripAccents . sunPattern . matcher ( result ) . replaceAll ( "<STR_LIT>" ) ; return result ; } private static class InitStripAccents { private static final Throwable sunException ; private static final Method sunDecomposeMethod ; private static final Pattern sunPattern = Pattern . compile ( "<STR_LIT>" ) ; private static final Throwable java6Exception ; private static final Method java6NormalizeMethod ; private static final Object java6NormalizerFormNFD ; private static final Pattern java6Pattern = sunPattern ; static { Object _java6NormalizerFormNFD = null ; Method _java6NormalizeMethod = null ; Method _sunDecomposeMethod = null ; Throwable _java6Exception = null ; Throwable _sunException = null ; try { Class < ? > normalizerFormClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( "<STR_LIT>" ) ; _java6NormalizerFormNFD = normalizerFormClass . getField ( "<STR_LIT>" ) . get ( null ) ; Class < ? > normalizerClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( "<STR_LIT>" ) ; _java6NormalizeMethod = normalizerClass . getMethod ( "<STR_LIT>" , new Class [ ] { CharSequence . class , normalizerFormClass } ) ; } catch ( Exception e1 ) { _java6Exception = e1 ; try { Class < ? > normalizerClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( "<STR_LIT>" ) ; _sunDecomposeMethod = normalizerClass . getMethod ( "<STR_LIT>" , new Class [ ] { String . class , Boolean . TYPE , Integer . TYPE } ) ; } catch ( Exception e2 ) { _sunException = e2 ; } } java6Exception = _java6Exception ; java6NormalizerFormNFD = _java6NormalizerFormNFD ; java6NormalizeMethod = _java6NormalizeMethod ; sunException = _sunException ; sunDecomposeMethod = _sunDecomposeMethod ; } } public static boolean equals ( CharSequence cs1 , CharSequence cs2 ) { return cs1 == null ? cs2 == null : cs1 . equals ( cs2 ) ; } public static boolean equalsIgnoreCase ( CharSequence str1 , CharSequence str2 ) { if ( str1 == null || str2 == null ) { return str1 == str2 ; } else { return CharSequenceUtils . regionMatches ( str1 , true , <NUM_LIT> , str2 , <NUM_LIT> , Math . max ( str1 . length ( ) , str2 . length ( ) ) ) ; } } public static int indexOf ( CharSequence seq , int searchChar ) { if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , <NUM_LIT> ) ; } public static int indexOf ( CharSequence seq , int searchChar , int startPos ) { if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , startPos ) ; } public static int indexOf ( CharSequence seq , CharSequence searchSeq ) { if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , <NUM_LIT> ) ; } public static int indexOf ( CharSequence seq , CharSequence searchSeq , int startPos ) { if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , startPos ) ; } public static int ordinalIndexOf ( CharSequence str , CharSequence searchStr , int ordinal ) { return ordinalIndexOf ( str , searchStr , ordinal , false ) ; } private static int ordinalIndexOf ( CharSequence str , CharSequence searchStr , int ordinal , boolean lastIndex ) { if ( str == null || searchStr == null || ordinal <= <NUM_LIT> ) { return INDEX_NOT_FOUND ; } if ( searchStr . length ( ) == <NUM_LIT> ) { return lastIndex ? str . length ( ) : <NUM_LIT> ; } int found = <NUM_LIT> ; int index = lastIndex ? str . length ( ) : INDEX_NOT_FOUND ; do { if ( lastIndex ) { index = CharSequenceUtils . lastIndexOf ( str , searchStr , index - <NUM_LIT> ) ; } else { index = CharSequenceUtils . indexOf ( str , searchStr , index + <NUM_LIT> ) ; } if ( index < <NUM_LIT> ) { return index ; } found ++ ; } while ( found < ordinal ) ; return index ; } public static int indexOfIgnoreCase ( CharSequence str , CharSequence searchStr ) { return indexOfIgnoreCase ( str , searchStr , <NUM_LIT> ) ; } public static int indexOfIgnoreCase ( CharSequence str , CharSequence searchStr , int startPos ) { if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } if ( startPos < <NUM_LIT> ) { startPos = <NUM_LIT> ; } int endLimit = str . length ( ) - searchStr . length ( ) + <NUM_LIT> ; if ( startPos > endLimit ) { return INDEX_NOT_FOUND ; } if ( searchStr . length ( ) == <NUM_LIT> ) { return startPos ; } for ( int i = startPos ; i < endLimit ; i ++ ) { if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , <NUM_LIT> , searchStr . length ( ) ) ) { return i ; } } return INDEX_NOT_FOUND ; } public static int lastIndexOf ( CharSequence seq , int searchChar ) { if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , seq . length ( ) ) ; } public static int lastIndexOf ( CharSequence seq , int searchChar , int startPos ) { if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , startPos ) ; } public static int lastIndexOf ( CharSequence seq , CharSequence searchSeq ) { if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchSeq , seq . length ( ) ) ; } public static int lastOrdinalIndexOf ( CharSequence str , CharSequence searchStr , int ordinal ) { return ordinalIndexOf ( str , searchStr , ordinal , true ) ; } public static int lastIndexOf ( CharSequence seq , CharSequence searchSeq , int startPos ) { if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchSeq , startPos ) ; } public static int lastIndexOfIgnoreCase ( CharSequence str , CharSequence searchStr ) { if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return lastIndexOfIgnoreCase ( str , searchStr , str . length ( ) ) ; } public static int lastIndexOfIgnoreCase ( CharSequence str , CharSequence searchStr , int startPos ) { if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } if ( startPos > str . length ( ) - searchStr . length ( ) ) { startPos = str . length ( ) - searchStr . length ( ) ; } if ( startPos < <NUM_LIT> ) { return INDEX_NOT_FOUND ; } if ( searchStr . length ( ) == <NUM_LIT> ) { return startPos ; } for ( int i = startPos ; i >= <NUM_LIT> ; i -- ) { if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , <NUM_LIT> , searchStr . length ( ) ) ) { return i ; } } return INDEX_NOT_FOUND ; } public static boolean contains ( CharSequence seq , int searchChar ) { if ( isEmpty ( seq ) ) { return false ; } return CharSequenceUtils . indexOf ( seq , searchChar , <NUM_LIT> ) >= <NUM_LIT> ; } public static boolean contains ( CharSequence seq , CharSequence searchSeq ) { if ( seq == null || searchSeq == null ) { return false ; } return CharSequenceUtils . indexOf ( seq , searchSeq , <NUM_LIT> ) >= <NUM_LIT> ; } public static boolean containsIgnoreCase ( CharSequence str , CharSequence searchStr ) { if ( str == null || searchStr == null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = <NUM_LIT> ; i <= max ; i ++ ) { if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , <NUM_LIT> , len ) ) { return true ; } } return false ; } public static boolean containsWhitespace ( CharSequence seq ) { if ( isEmpty ( seq ) ) { return false ; } int strLen = seq . length ( ) ; for ( int i = <NUM_LIT> ; i < strLen ; i ++ ) { if ( Character . isWhitespace ( seq . charAt ( i ) ) ) { return true ; } } return false ; } public static int indexOfAny ( CharSequence cs , char ... searchChars ) { if ( isEmpty ( cs ) || ArrayUtils . isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - <NUM_LIT> ; int searchLen = searchChars . length ; int searchLast = searchLen - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < csLen ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = <NUM_LIT> ; j < searchLen ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( i < csLast && j < searchLast && Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + <NUM_LIT> ] == cs . charAt ( i + <NUM_LIT> ) ) { return i ; } } else { return i ; } } } } return INDEX_NOT_FOUND ; } public static int indexOfAny ( CharSequence cs , String searchChars ) { if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } return indexOfAny ( cs , searchChars . toCharArray ( ) ) ; } public static boolean containsAny ( CharSequence cs , char ... searchChars ) { if ( isEmpty ( cs ) || ArrayUtils . isEmpty ( searchChars ) ) { return false ; } int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLast = csLength - <NUM_LIT> ; int searchLast = searchLength - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < csLength ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = <NUM_LIT> ; j < searchLength ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j == searchLast ) { return true ; } if ( i < csLast && searchChars [ j + <NUM_LIT> ] == cs . charAt ( i + <NUM_LIT> ) ) { return true ; } } else { return true ; } } } } return false ; } public static boolean containsAny ( CharSequence cs , CharSequence searchChars ) { if ( searchChars == null ) { return false ; } return containsAny ( cs , CharSequenceUtils . toCharArray ( searchChars ) ) ; } public static int indexOfAnyBut ( CharSequence cs , char ... searchChars ) { if ( isEmpty ( cs ) || ArrayUtils . isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - <NUM_LIT> ; int searchLen = searchChars . length ; int searchLast = searchLen - <NUM_LIT> ; outer : for ( int i = <NUM_LIT> ; i < csLen ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = <NUM_LIT> ; j < searchLen ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( i < csLast && j < searchLast && Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + <NUM_LIT> ] == cs . charAt ( i + <NUM_LIT> ) ) { continue outer ; } } else { continue outer ; } } } return i ; } return INDEX_NOT_FOUND ; } public static int indexOfAnyBut ( CharSequence seq , CharSequence searchChars ) { if ( isEmpty ( seq ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } int strLen = seq . length ( ) ; for ( int i = <NUM_LIT> ; i < strLen ; i ++ ) { char ch = seq . charAt ( i ) ; boolean chFound = CharSequenceUtils . indexOf ( searchChars , ch , <NUM_LIT> ) >= <NUM_LIT> ; if ( i + <NUM_LIT> < strLen && Character . isHighSurrogate ( ch ) ) { char ch2 = seq . charAt ( i + <NUM_LIT> ) ; if ( chFound && CharSequenceUtils . indexOf ( searchChars , ch2 , <NUM_LIT> ) < <NUM_LIT> ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; } public static boolean containsOnly ( CharSequence cs , char ... valid ) { if ( valid == null || cs == null ) { return false ; } if ( cs . length ( ) == <NUM_LIT> ) { return true ; } if ( valid . length == <NUM_LIT> ) { return false ; } return indexOfAnyBut ( cs , valid ) == INDEX_NOT_FOUND ; } public static boolean containsOnly ( CharSequence cs , String validChars ) { if ( cs == null || validChars == null ) { return false ; } return containsOnly ( cs , validChars . toCharArray ( ) ) ; } public static boolean containsNone ( CharSequence cs , char ... searchChars ) { if ( cs == null || searchChars == null ) { return true ; } int csLen = cs . length ( ) ; int csLast = csLen - <NUM_LIT> ; int searchLen = searchChars . length ; int searchLast = searchLen - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < csLen ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = <NUM_LIT> ; j < searchLen ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j == searchLast ) { return false ; } if ( i < csLast && searchChars [ j + <NUM_LIT> ] == cs . charAt ( i + <NUM_LIT> ) ) { return false ; } } else { return false ; } } } } return true ; } public static boolean containsNone ( CharSequence cs , String invalidChars ) { if ( cs == null || invalidChars == null ) { return true ; } return containsNone ( cs , invalidChars . toCharArray ( ) ) ; } public static int indexOfAny ( CharSequence str , CharSequence ... searchStrs ) { if ( str == null || searchStrs == null ) { return INDEX_NOT_FOUND ; } int sz = searchStrs . length ; int ret = Integer . MAX_VALUE ; int tmp = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { CharSequence search = searchStrs [ i ] ; if ( search == null ) { continue ; } tmp = CharSequenceUtils . indexOf ( str , search , <NUM_LIT> ) ; if ( tmp == INDEX_NOT_FOUND ) { continue ; } if ( tmp < ret ) { ret = tmp ; } } return ret == Integer . MAX_VALUE ? INDEX_NOT_FOUND : ret ; } public static int lastIndexOfAny ( CharSequence str , CharSequence ... searchStrs ) { if ( str == null || searchStrs == null ) { return INDEX_NOT_FOUND ; } int sz = searchStrs . length ; int ret = INDEX_NOT_FOUND ; int tmp = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { CharSequence search = searchStrs [ i ] ; if ( search == null ) { continue ; } tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length ( ) ) ; if ( tmp > ret ) { ret = tmp ; } } return ret ; } public static String substring ( String str , int start ) { if ( str == null ) { return null ; } if ( start < <NUM_LIT> ) { start = str . length ( ) + start ; } if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } if ( start > str . length ( ) ) { return EMPTY ; } return str . substring ( start ) ; } public static String substring ( String str , int start , int end ) { if ( str == null ) { return null ; } if ( end < <NUM_LIT> ) { end = str . length ( ) + end ; } if ( start < <NUM_LIT> ) { start = str . length ( ) + start ; } if ( end > str . length ( ) ) { end = str . length ( ) ; } if ( start > end ) { return EMPTY ; } if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } if ( end < <NUM_LIT> ) { end = <NUM_LIT> ; } return str . substring ( start , end ) ; } public static String left ( String str , int len ) { if ( str == null ) { return null ; } if ( len < <NUM_LIT> ) { return EMPTY ; } if ( str . length ( ) <= len ) { return str ; } return str . substring ( <NUM_LIT> , len ) ; } public static String right ( String str , int len ) { if ( str == null ) { return null ; } if ( len < <NUM_LIT> ) { return EMPTY ; } if ( str . length ( ) <= len ) { return str ; } return str . substring ( str . length ( ) - len ) ; } public static String mid ( String str , int pos , int len ) { if ( str == null ) { return null ; } if ( len < <NUM_LIT> || pos > str . length ( ) ) { return EMPTY ; } if ( pos < <NUM_LIT> ) { pos = <NUM_LIT> ; } if ( str . length ( ) <= pos + len ) { return str . substring ( pos ) ; } return str . substring ( pos , pos + len ) ; } public static String substringBefore ( String str , String separator ) { if ( isEmpty ( str ) || separator == null ) { return str ; } if ( separator . length ( ) == <NUM_LIT> ) { return EMPTY ; } int pos = str . indexOf ( separator ) ; if ( pos == INDEX_NOT_FOUND ) { return str ; } return str . substring ( <NUM_LIT> , pos ) ; } public static String substringAfter ( String str , String separator ) { if ( isEmpty ( str ) ) { return str ; } if ( separator == null ) { return EMPTY ; } int pos = str . indexOf ( separator ) ; if ( pos == INDEX_NOT_FOUND ) { return EMPTY ; } return str . substring ( pos + separator . length ( ) ) ; } public static String substringBeforeLast ( String str , String separator ) { if ( isEmpty ( str ) || isEmpty ( separator ) ) { return str ; } int pos = str . lastIndexOf ( separator ) ; if ( pos == INDEX_NOT_FOUND ) { return str ; } return str . substring ( <NUM_LIT> , pos ) ; } public static String substringAfterLast ( String str , String separator ) { if ( isEmpty ( str ) ) { return str ; } if ( isEmpty ( separator ) ) { return EMPTY ; } int pos = str . lastIndexOf ( separator ) ; if ( pos == INDEX_NOT_FOUND || pos == str . length ( ) - separator . length ( ) ) { return EMPTY ; } return str . substring ( pos + separator . length ( ) ) ; } public static String substringBetween ( String str , String tag ) { return substringBetween ( str , tag , tag ) ; } public static String substringBetween ( String str , String open , String close ) { if ( str == null || open == null || close == null ) { return null ; } int start = str . indexOf ( open ) ; if ( start != INDEX_NOT_FOUND ) { int end = str . indexOf ( close , start + open . length ( ) ) ; if ( end != INDEX_NOT_FOUND ) { return str . substring ( start + open . length ( ) , end ) ; } } return null ; } public static String [ ] substringsBetween ( String str , String open , String close ) { if ( str == null || isEmpty ( open ) || isEmpty ( close ) ) { return null ; } int strLen = str . length ( ) ; if ( strLen == <NUM_LIT> ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } int closeLen = close . length ( ) ; int openLen = open . length ( ) ; List < String > list = new ArrayList < String > ( ) ; int pos = <NUM_LIT> ; while ( pos < strLen - closeLen ) { int start = str . indexOf ( open , pos ) ; if ( start < <NUM_LIT> ) { break ; } start += openLen ; int end = str . indexOf ( close , start ) ; if ( end < <NUM_LIT> ) { break ; } list . add ( str . substring ( start , end ) ) ; pos = end + closeLen ; } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String [ ] split ( String str ) { return split ( str , null , - <NUM_LIT> ) ; } public static String [ ] split ( String str , char separatorChar ) { return splitWorker ( str , separatorChar , false ) ; } public static String [ ] split ( String str , String separatorChars ) { return splitWorker ( str , separatorChars , - <NUM_LIT> , false ) ; } public static String [ ] split ( String str , String separatorChars , int max ) { return splitWorker ( str , separatorChars , max , false ) ; } public static String [ ] splitByWholeSeparator ( String str , String separator ) { return splitByWholeSeparatorWorker ( str , separator , - <NUM_LIT> , false ) ; } public static String [ ] splitByWholeSeparator ( String str , String separator , int max ) { return splitByWholeSeparatorWorker ( str , separator , max , false ) ; } public static String [ ] splitByWholeSeparatorPreserveAllTokens ( String str , String separator ) { return splitByWholeSeparatorWorker ( str , separator , - <NUM_LIT> , true ) ; } public static String [ ] splitByWholeSeparatorPreserveAllTokens ( String str , String separator , int max ) { return splitByWholeSeparatorWorker ( str , separator , max , true ) ; } private static String [ ] splitByWholeSeparatorWorker ( String str , String separator , int max , boolean preserveAllTokens ) { if ( str == null ) { return null ; } int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } if ( separator == null || EMPTY . equals ( separator ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; } int separatorLength = separator . length ( ) ; ArrayList < String > substrings = new ArrayList < String > ( ) ; int numberOfSubstrings = <NUM_LIT> ; int beg = <NUM_LIT> ; int end = <NUM_LIT> ; while ( end < len ) { end = str . indexOf ( separator , beg ) ; if ( end > - <NUM_LIT> ) { if ( end > beg ) { numberOfSubstrings += <NUM_LIT> ; if ( numberOfSubstrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { substrings . add ( str . substring ( beg , end ) ) ; beg = end + separatorLength ; } } else { if ( preserveAllTokens ) { numberOfSubstrings += <NUM_LIT> ; if ( numberOfSubstrings == max ) { end = len ; substrings . add ( str . substring ( beg ) ) ; } else { substrings . add ( EMPTY ) ; } } beg = end + separatorLength ; } } else { substrings . add ( str . substring ( beg ) ) ; end = len ; } } return substrings . toArray ( new String [ substrings . size ( ) ] ) ; } public static String [ ] splitPreserveAllTokens ( String str ) { return splitWorker ( str , null , - <NUM_LIT> , true ) ; } public static String [ ] splitPreserveAllTokens ( String str , char separatorChar ) { return splitWorker ( str , separatorChar , true ) ; } private static String [ ] splitWorker ( String str , char separatorChar , boolean preserveAllTokens ) { if ( str == null ) { return null ; } int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } List < String > list = new ArrayList < String > ( ) ; int i = <NUM_LIT> , start = <NUM_LIT> ; boolean match = false ; boolean lastMatch = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match || preserveAllTokens ) { list . add ( str . substring ( start , i ) ) ; match = false ; lastMatch = true ; } start = ++ i ; continue ; } lastMatch = false ; match = true ; i ++ ; } if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String [ ] splitPreserveAllTokens ( String str , String separatorChars ) { return splitWorker ( str , separatorChars , - <NUM_LIT> , true ) ; } public static String [ ] splitPreserveAllTokens ( String str , String separatorChars , int max ) { return splitWorker ( str , separatorChars , max , true ) ; } private static String [ ] splitWorker ( String str , String separatorChars , int max , boolean preserveAllTokens ) { if ( str == null ) { return null ; } int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } List < String > list = new ArrayList < String > ( ) ; int sizePlus1 = <NUM_LIT> ; int i = <NUM_LIT> , start = <NUM_LIT> ; boolean match = false ; boolean lastMatch = false ; if ( separatorChars == null ) { while ( i < len ) { if ( Character . isWhitespace ( str . charAt ( i ) ) ) { if ( match || preserveAllTokens ) { lastMatch = true ; if ( sizePlus1 ++ == max ) { i = len ; lastMatch = false ; } list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } lastMatch = false ; match = true ; i ++ ; } } else if ( separatorChars . length ( ) == <NUM_LIT> ) { char sep = separatorChars . charAt ( <NUM_LIT> ) ; while ( i < len ) { if ( str . charAt ( i ) == sep ) { if ( match || preserveAllTokens ) { lastMatch = true ; if ( sizePlus1 ++ == max ) { i = len ; lastMatch = false ; } list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } lastMatch = false ; match = true ; i ++ ; } } else { while ( i < len ) { if ( separatorChars . indexOf ( str . charAt ( i ) ) >= <NUM_LIT> ) { if ( match || preserveAllTokens ) { lastMatch = true ; if ( sizePlus1 ++ == max ) { i = len ; lastMatch = false ; } list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } lastMatch = false ; match = true ; i ++ ; } } if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String [ ] splitByCharacterType ( String str ) { return splitByCharacterType ( str , false ) ; } public static String [ ] splitByCharacterTypeCamelCase ( String str ) { return splitByCharacterType ( str , true ) ; } private static String [ ] splitByCharacterType ( String str , boolean camelCase ) { if ( str == null ) { return null ; } if ( str . length ( ) == <NUM_LIT> ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } char [ ] c = str . toCharArray ( ) ; List < String > list = new ArrayList < String > ( ) ; int tokenStart = <NUM_LIT> ; int currentType = Character . getType ( c [ tokenStart ] ) ; for ( int pos = tokenStart + <NUM_LIT> ; pos < c . length ; pos ++ ) { int type = Character . getType ( c [ pos ] ) ; if ( type == currentType ) { continue ; } if ( camelCase && type == Character . LOWERCASE_LETTER && currentType == Character . UPPERCASE_LETTER ) { int newTokenStart = pos - <NUM_LIT> ; if ( newTokenStart != tokenStart ) { list . add ( new String ( c , tokenStart , newTokenStart - tokenStart ) ) ; tokenStart = newTokenStart ; } } else { list . add ( new String ( c , tokenStart , pos - tokenStart ) ) ; tokenStart = pos ; } currentType = type ; } list . add ( new String ( c , tokenStart , c . length - tokenStart ) ) ; return list . toArray ( new String [ list . size ( ) ] ) ; } public static < T > String join ( T ... elements ) { return join ( elements , null ) ; } public static String join ( Object [ ] array , char separator ) { if ( array == null ) { return null ; } return join ( array , separator , <NUM_LIT> , array . length ) ; } public static String join ( Object [ ] array , char separator , int startIndex , int endIndex ) { if ( array == null ) { return null ; } int noOfItems = endIndex - startIndex ; if ( noOfItems <= <NUM_LIT> ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * <NUM_LIT> ) ; for ( int i = startIndex ; i < endIndex ; i ++ ) { if ( i > startIndex ) { buf . append ( separator ) ; } if ( array [ i ] != null ) { buf . append ( array [ i ] ) ; } } return buf . toString ( ) ; } public static String join ( Object [ ] array , String separator ) { if ( array == null ) { return null ; } return join ( array , separator , <NUM_LIT> , array . length ) ; } public static String join ( Object [ ] array , String separator , int startIndex , int endIndex ) { if ( array == null ) { return null ; } if ( separator == null ) { separator = EMPTY ; } int noOfItems = endIndex - startIndex ; if ( noOfItems <= <NUM_LIT> ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * <NUM_LIT> ) ; for ( int i = startIndex ; i < endIndex ; i ++ ) { if ( i > startIndex ) { buf . append ( separator ) ; } if ( array [ i ] != null ) { buf . append ( array [ i ] ) ; } } return buf . toString ( ) ; } public static String join ( Iterator < ? > iterator , char separator ) { if ( iterator == null ) { return null ; } if ( ! iterator . hasNext ( ) ) { return EMPTY ; } Object first = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return ObjectUtils . toString ( first ) ; } StringBuilder buf = new StringBuilder ( <NUM_LIT> ) ; if ( first != null ) { buf . append ( first ) ; } while ( iterator . hasNext ( ) ) { buf . append ( separator ) ; Object obj = iterator . next ( ) ; if ( obj != null ) { buf . append ( obj ) ; } } return buf . toString ( ) ; } public static String join ( Iterator < ? > iterator , String separator ) { if ( iterator == null ) { return null ; } if ( ! iterator . hasNext ( ) ) { return EMPTY ; } Object first = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return ObjectUtils . toString ( first ) ; } StringBuilder buf = new StringBuilder ( <NUM_LIT> ) ; if ( first != null ) { buf . append ( first ) ; } while ( iterator . hasNext ( ) ) { if ( separator != null ) { buf . append ( separator ) ; } Object obj = iterator . next ( ) ; if ( obj != null ) { buf . append ( obj ) ; } } return buf . toString ( ) ; } public static String join ( Iterable < ? > iterable , char separator ) { if ( iterable == null ) { return null ; } return join ( iterable . iterator ( ) , separator ) ; } public static String join ( Iterable < ? > iterable , String separator ) { if ( iterable == null ) { return null ; } return join ( iterable . iterator ( ) , separator ) ; } public static String deleteWhitespace ( String str ) { if ( isEmpty ( str ) ) { return str ; } int sz = str . length ( ) ; char [ ] chs = new char [ sz ] ; int count = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( ! Character . isWhitespace ( str . charAt ( i ) ) ) { chs [ count ++ ] = str . charAt ( i ) ; } } if ( count == sz ) { return str ; } return new String ( chs , <NUM_LIT> , count ) ; } public static String removeStart ( String str , String remove ) { if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } if ( str . startsWith ( remove ) ) { return str . substring ( remove . length ( ) ) ; } return str ; } public static String removeStartIgnoreCase ( String str , String remove ) { if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } if ( startsWithIgnoreCase ( str , remove ) ) { return str . substring ( remove . length ( ) ) ; } return str ; } public static String removeEnd ( String str , String remove ) { if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } if ( str . endsWith ( remove ) ) { return str . substring ( <NUM_LIT> , str . length ( ) - remove . length ( ) ) ; } return str ; } public static String removeEndIgnoreCase ( String str , String remove ) { if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } if ( endsWithIgnoreCase ( str , remove ) ) { return str . substring ( <NUM_LIT> , str . length ( ) - remove . length ( ) ) ; } return str ; } public static String remove ( String str , String remove ) { if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , EMPTY , - <NUM_LIT> ) ; } public static String remove ( String str , char remove ) { if ( isEmpty ( str ) || str . indexOf ( remove ) == INDEX_NOT_FOUND ) { return str ; } char [ ] chars = str . toCharArray ( ) ; int pos = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < chars . length ; i ++ ) { if ( chars [ i ] != remove ) { chars [ pos ++ ] = chars [ i ] ; } } return new String ( chars , <NUM_LIT> , pos ) ; } public static String replaceOnce ( String text , String searchString , String replacement ) { return replace ( text , searchString , replacement , <NUM_LIT> ) ; } public static String replace ( String text , String searchString , String replacement ) { return replace ( text , searchString , replacement , - <NUM_LIT> ) ; } public static String replace ( String text , String searchString , String replacement , int max ) { if ( isEmpty ( text ) || isEmpty ( searchString ) || replacement == null || max == <NUM_LIT> ) { return text ; } int start = <NUM_LIT> ; int end = text . indexOf ( searchString , start ) ; if ( end == INDEX_NOT_FOUND ) { return text ; } int replLength = searchString . length ( ) ; int increase = replacement . length ( ) - replLength ; increase = increase < <NUM_LIT> ? <NUM_LIT> : increase ; increase *= max < <NUM_LIT> ? <NUM_LIT> : max > <NUM_LIT> ? <NUM_LIT> : max ; StringBuilder buf = new StringBuilder ( text . length ( ) + increase ) ; while ( end != INDEX_NOT_FOUND ) { buf . append ( text . substring ( start , end ) ) . append ( replacement ) ; start = end + replLength ; if ( -- max == <NUM_LIT> ) { break ; } end = text . indexOf ( searchString , start ) ; } buf . append ( text . substring ( start ) ) ; return buf . toString ( ) ; } public static String replaceEach ( String text , String [ ] searchList , String [ ] replacementList ) { return replaceEach ( text , searchList , replacementList , false , <NUM_LIT> ) ; } public static String replaceEachRepeatedly ( String text , String [ ] searchList , String [ ] replacementList ) { int timeToLive = searchList == null ? <NUM_LIT> : searchList . length ; return replaceEach ( text , searchList , replacementList , true , timeToLive ) ; } private static String replaceEach ( String text , String [ ] searchList , String [ ] replacementList , boolean repeat , int timeToLive ) { if ( text == null || text . length ( ) == <NUM_LIT> || searchList == null || searchList . length == <NUM_LIT> || replacementList == null || replacementList . length == <NUM_LIT> ) { return text ; } if ( timeToLive < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } int searchLength = searchList . length ; int replacementLength = replacementList . length ; if ( searchLength != replacementLength ) { throw new IllegalArgumentException ( "<STR_LIT>" + searchLength + "<STR_LIT>" + replacementLength ) ; } boolean [ ] noMoreMatchesForReplIndex = new boolean [ searchLength ] ; int textIndex = - <NUM_LIT> ; int replaceIndex = - <NUM_LIT> ; int tempIndex = - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < searchLength ; i ++ ) { if ( noMoreMatchesForReplIndex [ i ] || searchList [ i ] == null || searchList [ i ] . length ( ) == <NUM_LIT> || replacementList [ i ] == null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ; if ( tempIndex == - <NUM_LIT> ) { noMoreMatchesForReplIndex [ i ] = true ; } else { if ( textIndex == - <NUM_LIT> || tempIndex < textIndex ) { textIndex = tempIndex ; replaceIndex = i ; } } } if ( textIndex == - <NUM_LIT> ) { return text ; } int start = <NUM_LIT> ; int increase = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < searchList . length ; i ++ ) { if ( searchList [ i ] == null || replacementList [ i ] == null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > <NUM_LIT> ) { increase += <NUM_LIT> * greater ; } } increase = Math . min ( increase , text . length ( ) / <NUM_LIT> ) ; StringBuilder buf = new StringBuilder ( text . length ( ) + increase ) ; while ( textIndex != - <NUM_LIT> ) { for ( int i = start ; i < textIndex ; i ++ ) { buf . append ( text . charAt ( i ) ) ; } buf . append ( replacementList [ replaceIndex ] ) ; start = textIndex + searchList [ replaceIndex ] . length ( ) ; textIndex = - <NUM_LIT> ; replaceIndex = - <NUM_LIT> ; tempIndex = - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < searchLength ; i ++ ) { if ( noMoreMatchesForReplIndex [ i ] || searchList [ i ] == null || searchList [ i ] . length ( ) == <NUM_LIT> || replacementList [ i ] == null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] , start ) ; if ( tempIndex == - <NUM_LIT> ) { noMoreMatchesForReplIndex [ i ] = true ; } else { if ( textIndex == - <NUM_LIT> || tempIndex < textIndex ) { textIndex = tempIndex ; replaceIndex = i ; } } } } int textLength = text . length ( ) ; for ( int i = start ; i < textLength ; i ++ ) { buf . append ( text . charAt ( i ) ) ; } String result = buf . toString ( ) ; if ( ! repeat ) { return result ; } return replaceEach ( result , searchList , replacementList , repeat , timeToLive - <NUM_LIT> ) ; } public static String replaceChars ( String str , char searchChar , char replaceChar ) { if ( str == null ) { return null ; } return str . replace ( searchChar , replaceChar ) ; } public static String replaceChars ( String str , String searchChars , String replaceChars ) { if ( isEmpty ( str ) || isEmpty ( searchChars ) ) { return str ; } if ( replaceChars == null ) { replaceChars = EMPTY ; } boolean modified = false ; int replaceCharsLength = replaceChars . length ( ) ; int strLength = str . length ( ) ; StringBuilder buf = new StringBuilder ( strLength ) ; for ( int i = <NUM_LIT> ; i < strLength ; i ++ ) { char ch = str . charAt ( i ) ; int index = searchChars . indexOf ( ch ) ; if ( index >= <NUM_LIT> ) { modified = true ; if ( index < replaceCharsLength ) { buf . append ( replaceChars . charAt ( index ) ) ; } } else { buf . append ( ch ) ; } } if ( modified ) { return buf . toString ( ) ; } return str ; } public static String overlay ( String str , String overlay , int start , int end ) { if ( str == null ) { return null ; } if ( overlay == null ) { overlay = EMPTY ; } int len = str . length ( ) ; if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } if ( start > len ) { start = len ; } if ( end < <NUM_LIT> ) { end = <NUM_LIT> ; } if ( end > len ) { end = len ; } if ( start > end ) { int temp = start ; start = end ; end = temp ; } return new StringBuilder ( len + start - end + overlay . length ( ) + <NUM_LIT> ) . append ( str . substring ( <NUM_LIT> , start ) ) . append ( overlay ) . append ( str . substring ( end ) ) . toString ( ) ; } public static String chomp ( String str ) { if ( isEmpty ( str ) ) { return str ; } if ( str . length ( ) == <NUM_LIT> ) { char ch = str . charAt ( <NUM_LIT> ) ; if ( ch == CharUtils . CR || ch == CharUtils . LF ) { return EMPTY ; } return str ; } int lastIdx = str . length ( ) - <NUM_LIT> ; char last = str . charAt ( lastIdx ) ; if ( last == CharUtils . LF ) { if ( str . charAt ( lastIdx - <NUM_LIT> ) == CharUtils . CR ) { lastIdx -- ; } } else if ( last != CharUtils . CR ) { lastIdx ++ ; } return str . substring ( <NUM_LIT> , lastIdx ) ; } @ Deprecated public static String chomp ( String str , String separator ) { return removeEnd ( str , separator ) ; } public static String chop ( String str ) { if ( str == null ) { return null ; } int strLen = str . length ( ) ; if ( strLen < <NUM_LIT> ) { return EMPTY ; } int lastIdx = strLen - <NUM_LIT> ; String ret = str . substring ( <NUM_LIT> , lastIdx ) ; char last = str . charAt ( lastIdx ) ; if ( last == CharUtils . LF && ret . charAt ( lastIdx - <NUM_LIT> ) == CharUtils . CR ) { return ret . substring ( <NUM_LIT> , lastIdx - <NUM_LIT> ) ; } return ret ; } public static String repeat ( String str , int repeat ) { if ( str == null ) { return null ; } if ( repeat <= <NUM_LIT> ) { return EMPTY ; } int inputLength = str . length ( ) ; if ( repeat == <NUM_LIT> || inputLength == <NUM_LIT> ) { return str ; } if ( inputLength == <NUM_LIT> && repeat <= PAD_LIMIT ) { return repeat ( str . charAt ( <NUM_LIT> ) , repeat ) ; } int outputLength = inputLength * repeat ; switch ( inputLength ) { case <NUM_LIT> : return repeat ( str . charAt ( <NUM_LIT> ) , repeat ) ; case <NUM_LIT> : char ch0 = str . charAt ( <NUM_LIT> ) ; char ch1 = str . charAt ( <NUM_LIT> ) ; char [ ] output2 = new char [ outputLength ] ; for ( int i = repeat * <NUM_LIT> - <NUM_LIT> ; i >= <NUM_LIT> ; i -- , i -- ) { output2 [ i ] = ch0 ; output2 [ i + <NUM_LIT> ] = ch1 ; } return new String ( output2 ) ; default : StringBuilder buf = new StringBuilder ( outputLength ) ; for ( int i = <NUM_LIT> ; i < repeat ; i ++ ) { buf . append ( str ) ; } return buf . toString ( ) ; } } public static String repeat ( String str , String separator , int repeat ) { if ( str == null || separator == null ) { return repeat ( str , repeat ) ; } else { String result = repeat ( str + separator , repeat ) ; return removeEnd ( result , separator ) ; } } public static String repeat ( char ch , int repeat ) { char [ ] buf = new char [ repeat ] ; for ( int i = repeat - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { buf [ i ] = ch ; } return new String ( buf ) ; } public static String rightPad ( String str , int size ) { return rightPad ( str , size , '<STR_LIT>' ) ; } public static String rightPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= <NUM_LIT> ) { return str ; } if ( pads > PAD_LIMIT ) { return rightPad ( str , size , String . valueOf ( padChar ) ) ; } return str . concat ( repeat ( padChar , pads ) ) ; } public static String rightPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = "<STR_LIT>" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= <NUM_LIT> ) { return str ; } if ( padLen == <NUM_LIT> && pads <= PAD_LIMIT ) { return rightPad ( str , size , padStr . charAt ( <NUM_LIT> ) ) ; } if ( pads == padLen ) { return str . concat ( padStr ) ; } else if ( pads < padLen ) { return str . concat ( padStr . substring ( <NUM_LIT> , pads ) ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = <NUM_LIT> ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return str . concat ( new String ( padding ) ) ; } } public static String leftPad ( String str , int size ) { return leftPad ( str , size , '<STR_LIT>' ) ; } public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= <NUM_LIT> ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return repeat ( padChar , pads ) . concat ( str ) ; } public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = "<STR_LIT>" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= <NUM_LIT> ) { return str ; } if ( padLen == <NUM_LIT> && pads <= PAD_LIMIT ) { return leftPad ( str , size , padStr . charAt ( <NUM_LIT> ) ) ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( <NUM_LIT> , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = <NUM_LIT> ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } public static int length ( CharSequence cs ) { return cs == null ? <NUM_LIT> : cs . length ( ) ; } public static String center ( String str , int size ) { return center ( str , size , '<STR_LIT>' ) ; } public static String center ( String str , int size , char padChar ) { if ( str == null || size <= <NUM_LIT> ) { return str ; } int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= <NUM_LIT> ) { return str ; } str = leftPad ( str , strLen + pads / <NUM_LIT> , padChar ) ; str = rightPad ( str , size , padChar ) ; return str ; } public static String center ( String str , int size , String padStr ) { if ( str == null || size <= <NUM_LIT> ) { return str ; } if ( isEmpty ( padStr ) ) { padStr = "<STR_LIT>" ; } int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= <NUM_LIT> ) { return str ; } str = leftPad ( str , strLen + pads / <NUM_LIT> , padStr ) ; str = rightPad ( str , size , padStr ) ; return str ; } public static String upperCase ( String str ) { if ( str == null ) { return null ; } return str . toUpperCase ( ) ; } public static String upperCase ( String str , Locale locale ) { if ( str == null ) { return null ; } return str . toUpperCase ( locale ) ; } public static String lowerCase ( String str ) { if ( str == null ) { return null ; } return str . toLowerCase ( ) ; } public static String lowerCase ( String str , Locale locale ) { if ( str == null ) { return null ; } return str . toLowerCase ( locale ) ; } public static String capitalize ( String str ) { int strLen ; if ( str == null || ( strLen = str . length ( ) ) == <NUM_LIT> ) { return str ; } return new StringBuilder ( strLen ) . append ( Character . toTitleCase ( str . charAt ( <NUM_LIT> ) ) ) . append ( str . substring ( <NUM_LIT> ) ) . toString ( ) ; } public static String uncapitalize ( String str ) { int strLen ; if ( str == null || ( strLen = str . length ( ) ) == <NUM_LIT> ) { return str ; } return new StringBuilder ( strLen ) . append ( Character . toLowerCase ( str . charAt ( <NUM_LIT> ) ) ) . append ( str . substring ( <NUM_LIT> ) ) . toString ( ) ; } public static String swapCase ( String str ) { if ( StringUtils . isEmpty ( str ) ) { return str ; } char [ ] buffer = str . toCharArray ( ) ; for ( int i = <NUM_LIT> ; i < buffer . length ; i ++ ) { char ch = buffer [ i ] ; if ( Character . isUpperCase ( ch ) ) { buffer [ i ] = Character . toLowerCase ( ch ) ; } else if ( Character . isTitleCase ( ch ) ) { buffer [ i ] = Character . toLowerCase ( ch ) ; } else if ( Character . isLowerCase ( ch ) ) { buffer [ i ] = Character . toUpperCase ( ch ) ; } } return new String ( buffer ) ; } public static int countMatches ( CharSequence str , CharSequence sub ) { if ( isEmpty ( str ) || isEmpty ( sub ) ) { return <NUM_LIT> ; } int count = <NUM_LIT> ; int idx = <NUM_LIT> ; while ( ( idx = CharSequenceUtils . indexOf ( str , sub , idx ) ) != INDEX_NOT_FOUND ) { count ++ ; idx += sub . length ( ) ; } return count ; } public static boolean isAlpha ( CharSequence cs ) { if ( cs == null || cs . length ( ) == <NUM_LIT> ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isLetter ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isAlphaSpace ( CharSequence cs ) { if ( cs == null ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isLetter ( cs . charAt ( i ) ) == false && cs . charAt ( i ) != '<STR_LIT>' ) { return false ; } } return true ; } public static boolean isAlphanumeric ( CharSequence cs ) { if ( cs == null || cs . length ( ) == <NUM_LIT> ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isLetterOrDigit ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isAlphanumericSpace ( CharSequence cs ) { if ( cs == null ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isLetterOrDigit ( cs . charAt ( i ) ) == false && cs . charAt ( i ) != '<STR_LIT>' ) { return false ; } } return true ; } public static boolean isAsciiPrintable ( CharSequence cs ) { if ( cs == null ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( CharUtils . isAsciiPrintable ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isNumeric ( CharSequence cs ) { if ( cs == null || cs . length ( ) == <NUM_LIT> ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isDigit ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isNumericSpace ( CharSequence cs ) { if ( cs == null ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isDigit ( cs . charAt ( i ) ) == false && cs . charAt ( i ) != '<STR_LIT>' ) { return false ; } } return true ; } public static boolean isWhitespace ( CharSequence cs ) { if ( cs == null ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isWhitespace ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isAllLowerCase ( CharSequence cs ) { if ( cs == null || isEmpty ( cs ) ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isLowerCase ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static boolean isAllUpperCase ( CharSequence cs ) { if ( cs == null || isEmpty ( cs ) ) { return false ; } int sz = cs . length ( ) ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { if ( Character . isUpperCase ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } public static String defaultString ( String str ) { return str == null ? EMPTY : str ; } public static String defaultString ( String str , String defaultStr ) { return str == null ? defaultStr : str ; } public static < T extends CharSequence > T defaultIfBlank ( T str , T defaultStr ) { return StringUtils . isBlank ( str ) ? defaultStr : str ; } public static < T extends CharSequence > T defaultIfEmpty ( T str , T defaultStr ) { return StringUtils . isEmpty ( str ) ? defaultStr : str ; } public static String reverse ( String str ) { if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; } public static String reverseDelimited ( String str , char separatorChar ) { if ( str == null ) { return null ; } String [ ] strs = split ( str , separatorChar ) ; ArrayUtils . reverse ( strs ) ; return join ( strs , separatorChar ) ; } public static String abbreviate ( String str , int maxWidth ) { return abbreviate ( str , <NUM_LIT> , maxWidth ) ; } public static String abbreviate ( String str , int offset , int maxWidth ) { if ( str == null ) { return null ; } if ( maxWidth < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( str . length ( ) <= maxWidth ) { return str ; } if ( offset > str . length ( ) ) { offset = str . length ( ) ; } if ( str . length ( ) - offset < maxWidth - <NUM_LIT> ) { offset = str . length ( ) - ( maxWidth - <NUM_LIT> ) ; } final String abrevMarker = "<STR_LIT>" ; if ( offset <= <NUM_LIT> ) { return str . substring ( <NUM_LIT> , maxWidth - <NUM_LIT> ) + abrevMarker ; } if ( maxWidth < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( offset + maxWidth - <NUM_LIT> < str . length ( ) ) { return abrevMarker + abbreviate ( str . substring ( offset ) , maxWidth - <NUM_LIT> ) ; } return abrevMarker + str . substring ( str . length ( ) - ( maxWidth - <NUM_LIT> ) ) ; } public static String abbreviateMiddle ( String str , String middle , int length ) { if ( isEmpty ( str ) || isEmpty ( middle ) ) { return str ; } if ( length >= str . length ( ) || length < middle . length ( ) + <NUM_LIT> ) { return str ; } int targetSting = length - middle . length ( ) ; int startOffset = targetSting / <NUM_LIT> + targetSting % <NUM_LIT> ; int endOffset = str . length ( ) - targetSting / <NUM_LIT> ; StringBuilder builder = new StringBuilder ( length ) ; builder . append ( str . substring ( <NUM_LIT> , startOffset ) ) ; builder . append ( middle ) ; builder . append ( str . substring ( endOffset ) ) ; return builder . toString ( ) ; } public static String difference ( String str1 , String str2 ) { if ( str1 == null ) { return str2 ; } if ( str2 == null ) { return str1 ; } int at = indexOfDifference ( str1 , str2 ) ; if ( at == INDEX_NOT_FOUND ) { return EMPTY ; } return str2 . substring ( at ) ; } public static int indexOfDifference ( CharSequence cs1 , CharSequence cs2 ) { if ( cs1 == cs2 ) { return INDEX_NOT_FOUND ; } if ( cs1 == null || cs2 == null ) { return <NUM_LIT> ; } int i ; for ( i = <NUM_LIT> ; i < cs1 . length ( ) && i < cs2 . length ( ) ; ++ i ) { if ( cs1 . charAt ( i ) != cs2 . charAt ( i ) ) { break ; } } if ( i < cs2 . length ( ) || i < cs1 . length ( ) ) { return i ; } return INDEX_NOT_FOUND ; } public static int indexOfDifference ( CharSequence ... css ) { if ( css == null || css . length <= <NUM_LIT> ) { return INDEX_NOT_FOUND ; } boolean anyStringNull = false ; boolean allStringsNull = true ; int arrayLen = css . length ; int shortestStrLen = Integer . MAX_VALUE ; int longestStrLen = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < arrayLen ; i ++ ) { if ( css [ i ] == null ) { anyStringNull = true ; shortestStrLen = <NUM_LIT> ; } else { allStringsNull = false ; shortestStrLen = Math . min ( css [ i ] . length ( ) , shortestStrLen ) ; longestStrLen = Math . max ( css [ i ] . length ( ) , longestStrLen ) ; } } if ( allStringsNull || longestStrLen == <NUM_LIT> && ! anyStringNull ) { return INDEX_NOT_FOUND ; } if ( shortestStrLen == <NUM_LIT> ) { return <NUM_LIT> ; } int firstDiff = - <NUM_LIT> ; for ( int stringPos = <NUM_LIT> ; stringPos < shortestStrLen ; stringPos ++ ) { char comparisonChar = css [ <NUM_LIT> ] . charAt ( stringPos ) ; for ( int arrayPos = <NUM_LIT> ; arrayPos < arrayLen ; arrayPos ++ ) { if ( css [ arrayPos ] . charAt ( stringPos ) != comparisonChar ) { firstDiff = stringPos ; break ; } } if ( firstDiff != - <NUM_LIT> ) { break ; } } if ( firstDiff == - <NUM_LIT> && shortestStrLen != longestStrLen ) { return shortestStrLen ; } return firstDiff ; } public static String getCommonPrefix ( String ... strs ) { if ( strs == null || strs . length == <NUM_LIT> ) { return EMPTY ; } int smallestIndexOfDiff = indexOfDifference ( strs ) ; if ( smallestIndexOfDiff == INDEX_NOT_FOUND ) { if ( strs [ <NUM_LIT> ] == null ) { return EMPTY ; } return strs [ <NUM_LIT> ] ; } else if ( smallestIndexOfDiff == <NUM_LIT> ) { return EMPTY ; } else { return strs [ <NUM_LIT> ] . substring ( <NUM_LIT> , smallestIndexOfDiff ) ; } } public static int getLevenshteinDistance ( CharSequence s , CharSequence t ) { if ( s == null || t == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } int n = s . length ( ) ; int m = t . length ( ) ; if ( n == <NUM_LIT> ) { return m ; } else if ( m == <NUM_LIT> ) { return n ; } if ( n > m ) { CharSequence tmp = s ; s = t ; t = tmp ; n = m ; m = t . length ( ) ; } int p [ ] = new int [ n + <NUM_LIT> ] ; int d [ ] = new int [ n + <NUM_LIT> ] ; int _d [ ] ; int i ; int j ; char t_j ; int cost ; for ( i = <NUM_LIT> ; i <= n ; i ++ ) { p [ i ] = i ; } for ( j = <NUM_LIT> ; j <= m ; j ++ ) { t_j = t . charAt ( j - <NUM_LIT> ) ; d [ <NUM_LIT> ] = j ; for ( i = <NUM_LIT> ; i <= n ; i ++ ) { cost = s . charAt ( i - <NUM_LIT> ) == t_j ? <NUM_LIT> : <NUM_LIT> ; d [ i ] = Math . min ( Math . min ( d [ i - <NUM_LIT> ] + <NUM_LIT> , p [ i ] + <NUM_LIT> ) , p [ i - <NUM_LIT> ] + cost ) ; } _d = p ; p = d ; d = _d ; } return p [ n ] ; } public static int getLevenshteinDistance ( CharSequence s , CharSequence t , int threshold ) { if ( s == null || t == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( threshold < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } int n = s . length ( ) ; int m = t . length ( ) ; if ( n == <NUM_LIT> ) { return m <= threshold ? m : - <NUM_LIT> ; } else if ( m == <NUM_LIT> ) { return n <= threshold ? n : - <NUM_LIT> ; } if ( n > m ) { CharSequence tmp = s ; s = t ; t = tmp ; n = m ; m = t . length ( ) ; } int p [ ] = new int [ n + <NUM_LIT> ] ; int d [ ] = new int [ n + <NUM_LIT> ] ; int _d [ ] ; int boundary = Math . min ( n , threshold ) + <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < boundary ; i ++ ) { p [ i ] = i ; } Arrays . fill ( p , boundary , p . length , Integer . MAX_VALUE ) ; Arrays . fill ( d , Integer . MAX_VALUE ) ; for ( int j = <NUM_LIT> ; j <= m ; j ++ ) { char t_j = t . charAt ( j - <NUM_LIT> ) ; d [ <NUM_LIT> ] = j ; int min = Math . max ( <NUM_LIT> , j - threshold ) ; int max = Math . min ( n , j + threshold ) ; if ( min > max ) { return - <NUM_LIT> ; } if ( min > <NUM_LIT> ) { d [ min - <NUM_LIT> ] = Integer . MAX_VALUE ; } for ( int i = min ; i <= max ; i ++ ) { if ( s . charAt ( i - <NUM_LIT> ) == t_j ) { d [ i ] = p [ i - <NUM_LIT> ] ; } else { d [ i ] = <NUM_LIT> + Math . min ( Math . min ( d [ i - <NUM_LIT> ] , p [ i ] ) , p [ i - <NUM_LIT> ] ) ; } } _d = p ; p = d ; d = _d ; } if ( p [ n ] <= threshold ) { return p [ n ] ; } else { return - <NUM_LIT> ; } } public static boolean startsWith ( CharSequence str , CharSequence prefix ) { return startsWith ( str , prefix , false ) ; } public static boolean startsWithIgnoreCase ( CharSequence str , CharSequence prefix ) { return startsWith ( str , prefix , true ) ; } private static boolean startsWith ( CharSequence str , CharSequence prefix , boolean ignoreCase ) { if ( str == null || prefix == null ) { return str == null && prefix == null ; } if ( prefix . length ( ) > str . length ( ) ) { return false ; } return CharSequenceUtils . regionMatches ( str , ignoreCase , <NUM_LIT> , prefix , <NUM_LIT> , prefix . length ( ) ) ; } public static boolean startsWithAny ( CharSequence string , CharSequence ... searchStrings ) { if ( isEmpty ( string ) || ArrayUtils . isEmpty ( searchStrings ) ) { return false ; } for ( CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } } return false ; } public static boolean endsWith ( CharSequence str , CharSequence suffix ) { return endsWith ( str , suffix , false ) ; } public static boolean endsWithIgnoreCase ( CharSequence str , CharSequence suffix ) { return endsWith ( str , suffix , true ) ; } private static boolean endsWith ( CharSequence str , CharSequence suffix , boolean ignoreCase ) { if ( str == null || suffix == null ) { return str == null && suffix == null ; } if ( suffix . length ( ) > str . length ( ) ) { return false ; } int strOffset = str . length ( ) - suffix . length ( ) ; return CharSequenceUtils . regionMatches ( str , ignoreCase , strOffset , suffix , <NUM_LIT> , suffix . length ( ) ) ; } public static String normalizeSpace ( String str ) { if ( str == null ) { return null ; } return WHITESPACE_BLOCK . matcher ( trim ( str ) ) . replaceAll ( "<STR_LIT>" ) ; } public static boolean endsWithAny ( CharSequence string , CharSequence ... searchStrings ) { if ( isEmpty ( string ) || ArrayUtils . isEmpty ( searchStrings ) ) { return false ; } for ( CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } } return false ; } public static String toString ( byte [ ] bytes , String charsetName ) throws UnsupportedEncodingException { return charsetName == null ? new String ( bytes ) : new String ( bytes , charsetName ) ; } } </s>
<s> package de . robv . android . xposed . services ; import java . io . InputStream ; public final class FileResult { public final byte [ ] content ; public final InputStream stream ; public final long size ; public final long mtime ; FileResult ( long size , long mtime ) { this . content = null ; this . stream = null ; this . size = size ; this . mtime = mtime ; } FileResult ( byte [ ] content , long size , long mtime ) { this . content = content ; this . stream = null ; this . size = size ; this . mtime = mtime ; } FileResult ( InputStream stream , long size , long mtime ) { this . content = null ; this . stream = stream ; this . size = size ; this . mtime = mtime ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; if ( content != null ) { sb . append ( "<STR_LIT>" ) ; sb . append ( content . length ) ; sb . append ( "<STR_LIT>" ) ; } if ( stream != null ) { sb . append ( "<STR_LIT>" ) ; sb . append ( stream . toString ( ) ) ; sb . append ( "<STR_LIT>" ) ; } sb . append ( "<STR_LIT>" ) ; sb . append ( size ) ; sb . append ( "<STR_LIT>" ) ; sb . append ( mtime ) ; sb . append ( "<STR_LIT>" ) ; return sb . toString ( ) ; } } </s>
<s> package external . org . apache . commons . lang3 ; public class CharSequenceUtils { public CharSequenceUtils ( ) { super ( ) ; } public static CharSequence subSequence ( CharSequence cs , int start ) { return cs == null ? null : cs . subSequence ( start , cs . length ( ) ) ; } static int indexOf ( CharSequence cs , int searchChar , int start ) { if ( cs instanceof String ) { return ( ( String ) cs ) . indexOf ( searchChar , start ) ; } else { int sz = cs . length ( ) ; if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } for ( int i = start ; i < sz ; i ++ ) { if ( cs . charAt ( i ) == searchChar ) { return i ; } } return - <NUM_LIT> ; } } static int indexOf ( CharSequence cs , CharSequence searchChar , int start ) { return cs . toString ( ) . indexOf ( searchChar . toString ( ) , start ) ; } static int lastIndexOf ( CharSequence cs , int searchChar , int start ) { if ( cs instanceof String ) { return ( ( String ) cs ) . lastIndexOf ( searchChar , start ) ; } else { int sz = cs . length ( ) ; if ( start < <NUM_LIT> ) { return - <NUM_LIT> ; } if ( start >= sz ) { start = sz - <NUM_LIT> ; } for ( int i = start ; i >= <NUM_LIT> ; -- i ) { if ( cs . charAt ( i ) == searchChar ) { return i ; } } return - <NUM_LIT> ; } } static int lastIndexOf ( CharSequence cs , CharSequence searchChar , int start ) { return cs . toString ( ) . lastIndexOf ( searchChar . toString ( ) , start ) ; } static char [ ] toCharArray ( CharSequence cs ) { if ( cs instanceof String ) { return ( ( String ) cs ) . toCharArray ( ) ; } else { int sz = cs . length ( ) ; char [ ] array = new char [ cs . length ( ) ] ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { array [ i ] = cs . charAt ( i ) ; } return array ; } } static boolean regionMatches ( CharSequence cs , boolean ignoreCase , int thisStart , CharSequence substring , int start , int length ) { if ( cs instanceof String && substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , thisStart , ( String ) substring , start , length ) ; } else { return cs . toString ( ) . regionMatches ( ignoreCase , thisStart , substring . toString ( ) , start , length ) ; } } } </s>
<s> package de . robv . android . xposed ; import de . robv . android . xposed . callbacks . XCallback ; public abstract class XC_MethodReplacement extends XC_MethodHook { public XC_MethodReplacement ( ) { super ( ) ; } public XC_MethodReplacement ( int priority ) { super ( priority ) ; } @ Override protected final void beforeHookedMethod ( MethodHookParam param ) throws Throwable { try { Object result = replaceHookedMethod ( param ) ; param . setResult ( result ) ; } catch ( Throwable t ) { param . setThrowable ( t ) ; } } @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected final void afterHookedMethod ( MethodHookParam param ) throws Throwable { } @ SuppressWarnings ( "<STR_LIT>" ) protected abstract Object replaceHookedMethod ( MethodHookParam param ) throws Throwable ; public static final XC_MethodReplacement DO_NOTHING = new XC_MethodReplacement ( PRIORITY_HIGHEST * <NUM_LIT> ) { @ Override protected Object replaceHookedMethod ( MethodHookParam param ) throws Throwable { return null ; } } ; public static XC_MethodReplacement returnConstant ( final Object result ) { return returnConstant ( PRIORITY_DEFAULT , result ) ; } public static XC_MethodReplacement returnConstant ( int priority , final Object result ) { return new XC_MethodReplacement ( priority ) { @ Override protected Object replaceHookedMethod ( MethodHookParam param ) throws Throwable { return result ; } } ; } } </s>
<s> package android . content . res ; </s>
<s> package de . robv . android . xposed . callbacks ; import android . os . Bundle ; import java . io . Serializable ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XCallback implements Comparable < XCallback > { public final int priority ; @ Deprecated public XCallback ( ) { this . priority = PRIORITY_DEFAULT ; } public XCallback ( int priority ) { this . priority = priority ; } public static abstract class Param { public final Object [ ] callbacks ; private Bundle extra ; @ Deprecated protected Param ( ) { callbacks = null ; } protected Param ( CopyOnWriteSortedSet < ? extends XCallback > callbacks ) { this . callbacks = callbacks . getSnapshot ( ) ; } public synchronized Bundle getExtra ( ) { if ( extra == null ) extra = new Bundle ( ) ; return extra ; } public Object getObjectExtra ( String key ) { Serializable o = getExtra ( ) . getSerializable ( key ) ; if ( o instanceof SerializeWrapper ) return ( ( SerializeWrapper ) o ) . object ; return null ; } public void setObjectExtra ( String key , Object o ) { getExtra ( ) . putSerializable ( key , new SerializeWrapper ( o ) ) ; } private static class SerializeWrapper implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private final Object object ; public SerializeWrapper ( Object o ) { object = o ; } } } public static void callAll ( Param param ) { if ( param . callbacks == null ) throw new IllegalStateException ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < param . callbacks . length ; i ++ ) { try { ( ( XCallback ) param . callbacks [ i ] ) . call ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; } } } protected void call ( Param param ) throws Throwable { } @ Override public int compareTo ( XCallback other ) { if ( this == other ) return <NUM_LIT> ; if ( other . priority != this . priority ) return other . priority - this . priority ; else if ( System . identityHashCode ( this ) < System . identityHashCode ( other ) ) return - <NUM_LIT> ; else return <NUM_LIT> ; } public static final int PRIORITY_DEFAULT = <NUM_LIT> ; public static final int PRIORITY_LOWEST = - <NUM_LIT> ; public static final int PRIORITY_HIGHEST = <NUM_LIT> ; } </s>
<s> package external . org . apache . commons . lang3 . tuple ; import java . io . Serializable ; import java . util . Map ; import external . org . apache . commons . lang3 . ObjectUtils ; import external . org . apache . commons . lang3 . builder . CompareToBuilder ; public abstract class Pair < L , R > implements Map . Entry < L , R > , Comparable < Pair < L , R > > , Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static < L , R > Pair < L , R > of ( L left , R right ) { return new ImmutablePair < L , R > ( left , right ) ; } public abstract L getLeft ( ) ; public abstract R getRight ( ) ; public final L getKey ( ) { return getLeft ( ) ; } public R getValue ( ) { return getRight ( ) ; } public int compareTo ( Pair < L , R > other ) { return new CompareToBuilder ( ) . append ( getLeft ( ) , other . getLeft ( ) ) . append ( getRight ( ) , other . getRight ( ) ) . toComparison ( ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Map . Entry < ? , ? > ) { Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; return ObjectUtils . equals ( getKey ( ) , other . getKey ( ) ) && ObjectUtils . equals ( getValue ( ) , other . getValue ( ) ) ; } return false ; } @ Override public int hashCode ( ) { return ( getKey ( ) == null ? <NUM_LIT> : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) == null ? <NUM_LIT> : getValue ( ) . hashCode ( ) ) ; } @ Override public String toString ( ) { return new StringBuilder ( ) . append ( '<STR_LIT>' ) . append ( getLeft ( ) ) . append ( '<STR_LIT>' ) . append ( getRight ( ) ) . append ( '<STR_LIT>' ) . toString ( ) ; } public String toString ( String format ) { return String . format ( format , getLeft ( ) , getRight ( ) ) ; } } </s>
<s> package android . content . res ; import android . graphics . Movie ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import java . io . InputStream ; public class Resources { @ SuppressWarnings ( "<STR_LIT>" ) public static class NotFoundException extends RuntimeException { public NotFoundException ( ) { } public NotFoundException ( String name ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } public final class Theme { } public Resources ( AssetManager assets , DisplayMetrics metrics , Configuration config ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static Resources getSystem ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public XmlResourceParser getAnimation ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public final AssetManager getAssets ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public boolean getBoolean ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getColor ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public ColorStateList getColorStateList ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Configuration getConfiguration ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getDimension ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getDimensionPixelOffset ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getDimensionPixelSize ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public DisplayMetrics getDisplayMetrics ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawable ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawable ( int id , Theme theme ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawable ( int id , Theme theme , boolean supportComposedIcons ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawableForDensity ( int id , int density ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawableForDensity ( int id , int density , Theme theme ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Drawable getDrawableForDensity ( int id , int density , Theme theme , boolean supportComposedIcons ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getFloat ( int id ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public float getFraction ( int id , int base , int pbase ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getIdentifier ( String name , String defType , String defPackage ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int [ ] getIntArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public int getInteger ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public XmlResourceParser getLayout ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public Movie getMovie ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getQuantityString ( int id , int quantity ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getQuantityString ( int id , int quantity , Object ... formatArgs ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence getQuantityText ( int id , int quantity ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getResourceEntryName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getResourceName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getResourcePackageName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getResourceTypeName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getString ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getString ( int id , Object ... formatArgs ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String [ ] getStringArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence getText ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence getText ( int id , CharSequence def ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public CharSequence [ ] getTextArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public void getValue ( int id , TypedValue outValue , boolean resolveRefs ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public XmlResourceParser getXml ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public InputStream openRawResource ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public TypedArray obtainTypedArray ( int id ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . Comparator ; import external . org . apache . commons . lang3 . ArrayUtils ; public class CompareToBuilder implements Builder < Integer > { private int comparison ; public CompareToBuilder ( ) { super ( ) ; comparison = <NUM_LIT> ; } public static int reflectionCompare ( Object lhs , Object rhs ) { return reflectionCompare ( lhs , rhs , false , null ) ; } public static int reflectionCompare ( Object lhs , Object rhs , boolean compareTransients ) { return reflectionCompare ( lhs , rhs , compareTransients , null ) ; } public static int reflectionCompare ( Object lhs , Object rhs , Collection < String > excludeFields ) { return reflectionCompare ( lhs , rhs , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static int reflectionCompare ( Object lhs , Object rhs , String ... excludeFields ) { return reflectionCompare ( lhs , rhs , false , null , excludeFields ) ; } public static int reflectionCompare ( Object lhs , Object rhs , boolean compareTransients , Class < ? > reflectUpToClass , String ... excludeFields ) { if ( lhs == rhs ) { return <NUM_LIT> ; } if ( lhs == null || rhs == null ) { throw new NullPointerException ( ) ; } Class < ? > lhsClazz = lhs . getClass ( ) ; if ( ! lhsClazz . isInstance ( rhs ) ) { throw new ClassCastException ( ) ; } CompareToBuilder compareToBuilder = new CompareToBuilder ( ) ; reflectionAppend ( lhs , rhs , lhsClazz , compareToBuilder , compareTransients , excludeFields ) ; while ( lhsClazz . getSuperclass ( ) != null && lhsClazz != reflectUpToClass ) { lhsClazz = lhsClazz . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , lhsClazz , compareToBuilder , compareTransients , excludeFields ) ; } return compareToBuilder . toComparison ( ) ; } private static void reflectionAppend ( Object lhs , Object rhs , Class < ? > clazz , CompareToBuilder builder , boolean useTransients , String [ ] excludeFields ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = <NUM_LIT> ; i < fields . length && builder . comparison == <NUM_LIT> ; i ++ ) { Field f = fields [ i ] ; if ( ! ArrayUtils . contains ( excludeFields , f . getName ( ) ) && ( f . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( f . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( "<STR_LIT>" ) ; } } } } public CompareToBuilder appendSuper ( int superCompareTo ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = superCompareTo ; return this ; } public CompareToBuilder append ( Object lhs , Object rhs ) { return append ( lhs , rhs , null ) ; } public CompareToBuilder append ( Object lhs , Object rhs , Comparator < ? > comparator ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . getClass ( ) . isArray ( ) ) { if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs , comparator ) ; } } else { if ( comparator == null ) { @ SuppressWarnings ( "<STR_LIT>" ) final Comparable < Object > comparable = ( Comparable < Object > ) lhs ; comparison = comparable . compareTo ( rhs ) ; } else { @ SuppressWarnings ( "<STR_LIT>" ) final Comparator < Object > comparator2 = ( Comparator < Object > ) comparator ; comparison = comparator2 . compare ( lhs , rhs ) ; } } return this ; } public CompareToBuilder append ( long lhs , long rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( int lhs , int rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( short lhs , short rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( char lhs , char rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( byte lhs , byte rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( double lhs , double rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = Double . compare ( lhs , rhs ) ; return this ; } public CompareToBuilder append ( float lhs , float rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = Float . compare ( lhs , rhs ) ; return this ; } public CompareToBuilder append ( boolean lhs , boolean rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == false ) { comparison = - <NUM_LIT> ; } else { comparison = + <NUM_LIT> ; } return this ; } public CompareToBuilder append ( Object [ ] lhs , Object [ ] rhs ) { return append ( lhs , rhs , null ) ; } public CompareToBuilder append ( Object [ ] lhs , Object [ ] rhs , Comparator < ? > comparator ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] , comparator ) ; } return this ; } public CompareToBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( char [ ] lhs , char [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( byte [ ] lhs , byte [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( double [ ] lhs , double [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( float [ ] lhs , float [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public int toComparison ( ) { return comparison ; } public Integer build ( ) { return Integer . valueOf ( toComparison ( ) ) ; } } </s>
<s> package de . robv . android . xposed . callbacks ; import android . content . res . XResources ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_InitPackageResources extends XCallback implements IXposedHookInitPackageResources { @ SuppressWarnings ( "<STR_LIT>" ) public XC_InitPackageResources ( ) { super ( ) ; } public XC_InitPackageResources ( int priority ) { super ( priority ) ; } public static final class InitPackageResourcesParam extends XCallback . Param { public InitPackageResourcesParam ( CopyOnWriteSortedSet < XC_InitPackageResources > callbacks ) { super ( callbacks ) ; } public String packageName ; public XResources res ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof InitPackageResourcesParam ) handleInitPackageResources ( ( InitPackageResourcesParam ) param ) ; } } </s>
<s> package android . content . res ; public class XResForwarder { private final Resources res ; private final int id ; public XResForwarder ( Resources res , int id ) { this . res = res ; this . id = id ; } public Resources getResources ( ) { return res ; } public int getId ( ) { return id ; } } </s>
<s> package de . robv . android . xposed ; import java . lang . reflect . Member ; import de . robv . android . xposed . callbacks . IXUnhook ; import de . robv . android . xposed . callbacks . XCallback ; public abstract class XC_MethodHook extends XCallback { @ SuppressWarnings ( "<STR_LIT>" ) public XC_MethodHook ( ) { super ( ) ; } public XC_MethodHook ( int priority ) { super ( priority ) ; } protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { } public void callBeforeHookedMethod ( MethodHookParam param ) throws Throwable { beforeHookedMethod ( param ) ; } protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { } public void callAfterHookedMethod ( MethodHookParam param ) throws Throwable { afterHookedMethod ( param ) ; } public static final class MethodHookParam extends XCallback . Param { @ SuppressWarnings ( "<STR_LIT>" ) public MethodHookParam ( ) { super ( ) ; } public Member method ; public Object thisObject ; public Object [ ] args ; public Object result = null ; public Throwable throwable = null ; public boolean returnEarly = false ; public Object getResult ( ) { return result ; } public void setResult ( Object result ) { this . result = result ; this . throwable = null ; this . returnEarly = true ; } public Throwable getThrowable ( ) { return throwable ; } public boolean hasThrowable ( ) { return throwable != null ; } public void setThrowable ( Throwable throwable ) { this . throwable = throwable ; this . result = null ; this . returnEarly = true ; } public Object getResultOrThrowable ( ) throws Throwable { if ( throwable != null ) throw throwable ; return result ; } } public class Unhook implements IXUnhook < XC_MethodHook > { private final Member hookMethod ; Unhook ( Member hookMethod ) { this . hookMethod = hookMethod ; } public Member getHookedMethod ( ) { return hookMethod ; } @ Override public XC_MethodHook getCallback ( ) { return XC_MethodHook . this ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void unhook ( ) { XposedBridge . unhookMethod ( hookMethod , XC_MethodHook . this ) ; } } } </s>
<s> package de . robv . android . xposed . callbacks ; import android . content . res . XResources ; import android . content . res . XResources . ResourceNames ; import android . view . View ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_LayoutInflated extends XCallback { @ SuppressWarnings ( "<STR_LIT>" ) public XC_LayoutInflated ( ) { super ( ) ; } public XC_LayoutInflated ( int priority ) { super ( priority ) ; } public static final class LayoutInflatedParam extends XCallback . Param { public LayoutInflatedParam ( CopyOnWriteSortedSet < XC_LayoutInflated > callbacks ) { super ( callbacks ) ; } public View view ; public ResourceNames resNames ; public String variant ; public XResources res ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof LayoutInflatedParam ) handleLayoutInflated ( ( LayoutInflatedParam ) param ) ; } public abstract void handleLayoutInflated ( LayoutInflatedParam liparam ) throws Throwable ; public class Unhook implements IXUnhook < XC_LayoutInflated > { private final String resDir ; private final int id ; public Unhook ( String resDir , int id ) { this . resDir = resDir ; this . id = id ; } public int getId ( ) { return id ; } @ Override public XC_LayoutInflated getCallback ( ) { return XC_LayoutInflated . this ; } @ Override public void unhook ( ) { XResources . unhookLayout ( resDir , id , XC_LayoutInflated . this ) ; } } } </s>
<s> package android . app ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; public final class ActivityThread { public static ActivityThread currentActivityThread ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static Application currentApplication ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public static String currentPackageName ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public final LoadedApk getPackageInfoNoCheck ( ApplicationInfo ai , CompatibilityInfo compatInfo ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package external . org . apache . commons . lang3 ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String PACKAGE_SEPARATOR = String . valueOf ( PACKAGE_SEPARATOR_CHAR ) ; public static final char INNER_CLASS_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String INNER_CLASS_SEPARATOR = String . valueOf ( INNER_CLASS_SEPARATOR_CHAR ) ; private static final Map < Class < ? > , Class < ? > > primitiveWrapperMap = new HashMap < Class < ? > , Class < ? > > ( ) ; static { primitiveWrapperMap . put ( Boolean . TYPE , Boolean . class ) ; primitiveWrapperMap . put ( Byte . TYPE , Byte . class ) ; primitiveWrapperMap . put ( Character . TYPE , Character . class ) ; primitiveWrapperMap . put ( Short . TYPE , Short . class ) ; primitiveWrapperMap . put ( Integer . TYPE , Integer . class ) ; primitiveWrapperMap . put ( Long . TYPE , Long . class ) ; primitiveWrapperMap . put ( Double . TYPE , Double . class ) ; primitiveWrapperMap . put ( Float . TYPE , Float . class ) ; primitiveWrapperMap . put ( Void . TYPE , Void . TYPE ) ; } private static final Map < Class < ? > , Class < ? > > wrapperPrimitiveMap = new HashMap < Class < ? > , Class < ? > > ( ) ; static { for ( Class < ? > primitiveClass : primitiveWrapperMap . keySet ( ) ) { Class < ? > wrapperClass = primitiveWrapperMap . get ( primitiveClass ) ; if ( ! primitiveClass . equals ( wrapperClass ) ) { wrapperPrimitiveMap . put ( wrapperClass , primitiveClass ) ; } } } private static final Map < String , String > abbreviationMap = new HashMap < String , String > ( ) ; private static final Map < String , String > reverseAbbreviationMap = new HashMap < String , String > ( ) ; private static void addAbbreviation ( String primitive , String abbreviation ) { abbreviationMap . put ( primitive , abbreviation ) ; reverseAbbreviationMap . put ( abbreviation , primitive ) ; } static { addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; addAbbreviation ( "<STR_LIT>" , "<STR_LIT>" ) ; } public ClassUtils ( ) { super ( ) ; } public static String getShortClassName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } public static String getShortClassName ( String className ) { if ( className == null ) { return StringUtils . EMPTY ; } if ( className . length ( ) == <NUM_LIT> ) { return StringUtils . EMPTY ; } StringBuilder arrayPrefix = new StringBuilder ( ) ; if ( className . startsWith ( "<STR_LIT>" ) ) { while ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; arrayPrefix . append ( "<STR_LIT>" ) ; } if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' && className . charAt ( className . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> , className . length ( ) - <NUM_LIT> ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( INNER_CLASS_SEPARATOR_CHAR , lastDotIdx == - <NUM_LIT> ? <NUM_LIT> : lastDotIdx + <NUM_LIT> ) ; String out = className . substring ( lastDotIdx + <NUM_LIT> ) ; if ( innerIdx != - <NUM_LIT> ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } public static String getSimpleName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return cls . getSimpleName ( ) ; } public static String getSimpleName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getSimpleName ( object . getClass ( ) ) ; } public static String getPackageName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } public static String getPackageName ( String className ) { if ( className == null || className . length ( ) == <NUM_LIT> ) { return StringUtils . EMPTY ; } while ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; } if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' && className . charAt ( className . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i == - <NUM_LIT> ) { return StringUtils . EMPTY ; } return className . substring ( <NUM_LIT> , i ) ; } public static List < Class < ? > > getAllSuperclasses ( Class < ? > cls ) { if ( cls == null ) { return null ; } List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; Class < ? > superclass = cls . getSuperclass ( ) ; while ( superclass != null ) { classes . add ( superclass ) ; superclass = superclass . getSuperclass ( ) ; } return classes ; } public static List < Class < ? > > getAllInterfaces ( Class < ? > cls ) { if ( cls == null ) { return null ; } LinkedHashSet < Class < ? > > interfacesFound = new LinkedHashSet < Class < ? > > ( ) ; getAllInterfaces ( cls , interfacesFound ) ; return new ArrayList < Class < ? > > ( interfacesFound ) ; } private static void getAllInterfaces ( Class < ? > cls , HashSet < Class < ? > > interfacesFound ) { while ( cls != null ) { Class < ? > [ ] interfaces = cls . getInterfaces ( ) ; for ( Class < ? > i : interfaces ) { if ( interfacesFound . add ( i ) ) { getAllInterfaces ( i , interfacesFound ) ; } } cls = cls . getSuperclass ( ) ; } } public static List < Class < ? > > convertClassNamesToClasses ( List < String > classNames ) { if ( classNames == null ) { return null ; } List < Class < ? > > classes = new ArrayList < Class < ? > > ( classNames . size ( ) ) ; for ( String className : classNames ) { try { classes . add ( Class . forName ( className ) ) ; } catch ( Exception ex ) { classes . add ( null ) ; } } return classes ; } public static List < String > convertClassesToClassNames ( List < Class < ? > > classes ) { if ( classes == null ) { return null ; } List < String > classNames = new ArrayList < String > ( classes . size ( ) ) ; for ( Class < ? > cls : classes ) { if ( cls == null ) { classNames . add ( null ) ; } else { classNames . add ( cls . getName ( ) ) ; } } return classNames ; } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > ... toClassArray ) { return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_5 ) ) ; } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( ArrayUtils . isSameLength ( classArray , toClassArray ) == false ) { return false ; } if ( classArray == null ) { classArray = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = ArrayUtils . EMPTY_CLASS_ARRAY ; } for ( int i = <NUM_LIT> ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { return false ; } } return true ; } public static boolean isPrimitiveOrWrapper ( Class < ? > type ) { if ( type == null ) { return false ; } return type . isPrimitive ( ) || isPrimitiveWrapper ( type ) ; } public static boolean isPrimitiveWrapper ( Class < ? > type ) { return wrapperPrimitiveMap . containsKey ( type ) ; } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass ) { return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_5 ) ) ; } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass , boolean autoboxing ) { if ( toClass == null ) { return false ; } if ( cls == null ) { return ! toClass . isPrimitive ( ) ; } if ( autoboxing ) { if ( cls . isPrimitive ( ) && ! toClass . isPrimitive ( ) ) { cls = primitiveToWrapper ( cls ) ; if ( cls == null ) { return false ; } } if ( toClass . isPrimitive ( ) && ! cls . isPrimitive ( ) ) { cls = wrapperToPrimitive ( cls ) ; if ( cls == null ) { return false ; } } } if ( cls . equals ( toClass ) ) { return true ; } if ( cls . isPrimitive ( ) ) { if ( toClass . isPrimitive ( ) == false ) { return false ; } if ( Integer . TYPE . equals ( cls ) ) { return Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Long . TYPE . equals ( cls ) ) { return Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Boolean . TYPE . equals ( cls ) ) { return false ; } if ( Double . TYPE . equals ( cls ) ) { return false ; } if ( Float . TYPE . equals ( cls ) ) { return Double . TYPE . equals ( toClass ) ; } if ( Character . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Short . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Byte . TYPE . equals ( cls ) ) { return Short . TYPE . equals ( toClass ) || Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } return false ; } return toClass . isAssignableFrom ( cls ) ; } public static Class < ? > primitiveToWrapper ( Class < ? > cls ) { Class < ? > convertedClass = cls ; if ( cls != null && cls . isPrimitive ( ) ) { convertedClass = primitiveWrapperMap . get ( cls ) ; } return convertedClass ; } public static Class < ? > [ ] primitivesToWrappers ( Class < ? > ... classes ) { if ( classes == null ) { return null ; } if ( classes . length == <NUM_LIT> ) { return classes ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { convertedClasses [ i ] = primitiveToWrapper ( classes [ i ] ) ; } return convertedClasses ; } public static Class < ? > wrapperToPrimitive ( Class < ? > cls ) { return wrapperPrimitiveMap . get ( cls ) ; } public static Class < ? > [ ] wrappersToPrimitives ( Class < ? > ... classes ) { if ( classes == null ) { return null ; } if ( classes . length == <NUM_LIT> ) { return classes ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { convertedClasses [ i ] = wrapperToPrimitive ( classes [ i ] ) ; } return convertedClasses ; } public static boolean isInnerClass ( Class < ? > cls ) { return cls != null && cls . getEnclosingClass ( ) != null ; } public static Class < ? > getClass ( ClassLoader classLoader , String className , boolean initialize ) throws ClassNotFoundException { try { Class < ? > clazz ; if ( abbreviationMap . containsKey ( className ) ) { String clsName = "<STR_LIT>" + abbreviationMap . get ( className ) ; clazz = Class . forName ( clsName , initialize , classLoader ) . getComponentType ( ) ; } else { clazz = Class . forName ( toCanonicalName ( className ) , initialize , classLoader ) ; } return clazz ; } catch ( ClassNotFoundException ex ) { int lastDotIndex = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( lastDotIndex != - <NUM_LIT> ) { try { return getClass ( classLoader , className . substring ( <NUM_LIT> , lastDotIndex ) + INNER_CLASS_SEPARATOR_CHAR + className . substring ( lastDotIndex + <NUM_LIT> ) , initialize ) ; } catch ( ClassNotFoundException ex2 ) { } } throw ex ; } } public static Class < ? > getClass ( ClassLoader classLoader , String className ) throws ClassNotFoundException { return getClass ( classLoader , className , true ) ; } public static Class < ? > getClass ( String className ) throws ClassNotFoundException { return getClass ( className , true ) ; } public static Class < ? > getClass ( String className , boolean initialize ) throws ClassNotFoundException { ClassLoader contextCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader loader = contextCL == null ? ClassUtils . class . getClassLoader ( ) : contextCL ; return getClass ( loader , className , initialize ) ; } public static Method getPublicMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) throws SecurityException , NoSuchMethodException { Method declaredMethod = cls . getMethod ( methodName , parameterTypes ) ; if ( Modifier . isPublic ( declaredMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { return declaredMethod ; } List < Class < ? > > candidateClasses = new ArrayList < Class < ? > > ( ) ; candidateClasses . addAll ( getAllInterfaces ( cls ) ) ; candidateClasses . addAll ( getAllSuperclasses ( cls ) ) ; for ( Class < ? > candidateClass : candidateClasses ) { if ( ! Modifier . isPublic ( candidateClass . getModifiers ( ) ) ) { continue ; } Method candidateMethod ; try { candidateMethod = candidateClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException ex ) { continue ; } if ( Modifier . isPublic ( candidateMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { return candidateMethod ; } } throw new NoSuchMethodException ( "<STR_LIT>" + methodName + "<STR_LIT>" + ArrayUtils . toString ( parameterTypes ) ) ; } private static String toCanonicalName ( String className ) { className = StringUtils . deleteWhitespace ( className ) ; if ( className == null ) { throw new NullPointerException ( "<STR_LIT>" ) ; } else if ( className . endsWith ( "<STR_LIT>" ) ) { StringBuilder classNameBuffer = new StringBuilder ( ) ; while ( className . endsWith ( "<STR_LIT>" ) ) { className = className . substring ( <NUM_LIT> , className . length ( ) - <NUM_LIT> ) ; classNameBuffer . append ( "<STR_LIT>" ) ; } String abbreviation = abbreviationMap . get ( className ) ; if ( abbreviation != null ) { classNameBuffer . append ( abbreviation ) ; } else { classNameBuffer . append ( "<STR_LIT>" ) . append ( className ) . append ( "<STR_LIT>" ) ; } className = classNameBuffer . toString ( ) ; } return className ; } public static Class < ? > [ ] toClass ( Object ... array ) { if ( array == null ) { return null ; } else if ( array . length == <NUM_LIT> ) { return ArrayUtils . EMPTY_CLASS_ARRAY ; } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = <NUM_LIT> ; i < array . length ; i ++ ) { classes [ i ] = array [ i ] == null ? null : array [ i ] . getClass ( ) ; } return classes ; } public static String getShortCanonicalName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getShortCanonicalName ( object . getClass ( ) . getName ( ) ) ; } public static String getShortCanonicalName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } public static String getShortCanonicalName ( String canonicalName ) { return ClassUtils . getShortClassName ( getCanonicalName ( canonicalName ) ) ; } public static String getPackageCanonicalName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getPackageCanonicalName ( object . getClass ( ) . getName ( ) ) ; } public static String getPackageCanonicalName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } public static String getPackageCanonicalName ( String canonicalName ) { return ClassUtils . getPackageName ( getCanonicalName ( canonicalName ) ) ; } private static String getCanonicalName ( String className ) { className = StringUtils . deleteWhitespace ( className ) ; if ( className == null ) { return null ; } else { int dim = <NUM_LIT> ; while ( className . startsWith ( "<STR_LIT>" ) ) { dim ++ ; className = className . substring ( <NUM_LIT> ) ; } if ( dim < <NUM_LIT> ) { return className ; } else { if ( className . startsWith ( "<STR_LIT>" ) ) { className = className . substring ( <NUM_LIT> , className . endsWith ( "<STR_LIT>" ) ? className . length ( ) - <NUM_LIT> : className . length ( ) ) ; } else { if ( className . length ( ) > <NUM_LIT> ) { className = reverseAbbreviationMap . get ( className . substring ( <NUM_LIT> , <NUM_LIT> ) ) ; } } StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ; for ( int i = <NUM_LIT> ; i < dim ; i ++ ) { canonicalClassNameBuffer . append ( "<STR_LIT>" ) ; } return canonicalClassNameBuffer . toString ( ) ; } } } } </s>
<s> package de . robv . android . xposed ; import android . os . SELinux ; import de . robv . android . xposed . services . BaseService ; import de . robv . android . xposed . services . BinderService ; import de . robv . android . xposed . services . DirectAccessService ; import de . robv . android . xposed . services . ZygoteService ; public final class SELinuxHelper { private SELinuxHelper ( ) { } public static boolean isSELinuxEnabled ( ) { return sIsSELinuxEnabled ; } public static boolean isSELinuxEnforced ( ) { return sIsSELinuxEnabled && SELinux . isSELinuxEnforced ( ) ; } public static String getContext ( ) { return sIsSELinuxEnabled ? SELinux . getContext ( ) : null ; } public static BaseService getAppDataFileService ( ) { if ( sServiceAppDataFile != null ) return sServiceAppDataFile ; throw new UnsupportedOperationException ( ) ; } private static boolean sIsSELinuxEnabled = false ; private static BaseService sServiceAppDataFile = null ; static void initOnce ( ) { try { sIsSELinuxEnabled = SELinux . isSELinuxEnabled ( ) ; } catch ( NoClassDefFoundError ignored ) { } } static void initForProcess ( String packageName ) { if ( sIsSELinuxEnabled ) { if ( packageName == null ) { sServiceAppDataFile = new ZygoteService ( ) ; } else if ( packageName . equals ( "<STR_LIT>" ) ) { sServiceAppDataFile = BinderService . getService ( BinderService . TARGET_APP ) ; } else { sServiceAppDataFile = new DirectAccessService ( ) ; } } else { sServiceAppDataFile = new DirectAccessService ( ) ; } } } </s>
<s> package external . org . apache . commons . lang3 . reflect ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class MethodUtils { public MethodUtils ( ) { super ( ) ; } public static Object invokeMethod ( Object object , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeMethod ( object , methodName , args , parameterTypes ) ; } public static Object invokeMethod ( Object object , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } Method method = getMatchingAccessibleMethod ( object . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( "<STR_LIT>" + methodName + "<STR_LIT>" + object . getClass ( ) . getName ( ) ) ; } return method . invoke ( object , args ) ; } public static Object invokeExactMethod ( Object object , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeExactMethod ( object , methodName , args , parameterTypes ) ; } public static Object invokeExactMethod ( Object object , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } Method method = getAccessibleMethod ( object . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( "<STR_LIT>" + methodName + "<STR_LIT>" + object . getClass ( ) . getName ( ) ) ; } return method . invoke ( object , args ) ; } public static Object invokeExactStaticMethod ( Class < ? > cls , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } Method method = getAccessibleMethod ( cls , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( "<STR_LIT>" + methodName + "<STR_LIT>" + cls . getName ( ) ) ; } return method . invoke ( null , args ) ; } public static Object invokeStaticMethod ( Class < ? > cls , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeStaticMethod ( cls , methodName , args , parameterTypes ) ; } public static Object invokeStaticMethod ( Class < ? > cls , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } Method method = getMatchingAccessibleMethod ( cls , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( "<STR_LIT>" + methodName + "<STR_LIT>" + cls . getName ( ) ) ; } return method . invoke ( null , args ) ; } public static Object invokeExactStaticMethod ( Class < ? > cls , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeExactStaticMethod ( cls , methodName , args , parameterTypes ) ; } public static Method getAccessibleMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } } public static Method getAccessibleMethod ( Method method ) { if ( ! MemberUtils . isAccessible ( method ) ) { return null ; } Class < ? > cls = method . getDeclaringClass ( ) ; if ( Modifier . isPublic ( cls . getModifiers ( ) ) ) { return method ; } String methodName = method . getName ( ) ; Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; method = getAccessibleMethodFromInterfaceNest ( cls , methodName , parameterTypes ) ; if ( method == null ) { method = getAccessibleMethodFromSuperclass ( cls , methodName , parameterTypes ) ; } return method ; } private static Method getAccessibleMethodFromSuperclass ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { Class < ? > parentClass = cls . getSuperclass ( ) ; while ( parentClass != null ) { if ( Modifier . isPublic ( parentClass . getModifiers ( ) ) ) { try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } } parentClass = parentClass . getSuperclass ( ) ; } return null ; } private static Method getAccessibleMethodFromInterfaceNest ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { Method method = null ; for ( ; cls != null ; cls = cls . getSuperclass ( ) ) { Class < ? > [ ] interfaces = cls . getInterfaces ( ) ; for ( int i = <NUM_LIT> ; i < interfaces . length ; i ++ ) { if ( ! Modifier . isPublic ( interfaces [ i ] . getModifiers ( ) ) ) { continue ; } try { method = interfaces [ i ] . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { } if ( method != null ) { break ; } method = getAccessibleMethodFromInterfaceNest ( interfaces [ i ] , methodName , parameterTypes ) ; if ( method != null ) { break ; } } } return method ; } public static Method getMatchingAccessibleMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { try { Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( NoSuchMethodException e ) { } Method bestMatch = null ; Method [ ] methods = cls . getMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && ClassUtils . isAssignable ( parameterTypes , method . getParameterTypes ( ) , true ) ) { Method accessibleMethod = getAccessibleMethod ( method ) ; if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareParameterTypes ( accessibleMethod . getParameterTypes ( ) , bestMatch . getParameterTypes ( ) , parameterTypes ) < <NUM_LIT> ) ) { bestMatch = accessibleMethod ; } } } if ( bestMatch != null ) { MemberUtils . setAccessibleWorkaround ( bestMatch ) ; } return bestMatch ; } } </s>
<s> package external . org . apache . commons . lang3 ; import java . io . Serializable ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Map ; import java . util . TreeSet ; import external . org . apache . commons . lang3 . exception . CloneFailedException ; import external . org . apache . commons . lang3 . mutable . MutableInt ; public class ObjectUtils { public static final Null NULL = new Null ( ) ; public ObjectUtils ( ) { super ( ) ; } public static < T > T defaultIfNull ( T object , T defaultValue ) { return object != null ? object : defaultValue ; } public static < T > T firstNonNull ( T ... values ) { if ( values != null ) { for ( T val : values ) { if ( val != null ) { return val ; } } } return null ; } public static boolean equals ( Object object1 , Object object2 ) { if ( object1 == object2 ) { return true ; } if ( object1 == null || object2 == null ) { return false ; } return object1 . equals ( object2 ) ; } public static boolean notEqual ( Object object1 , Object object2 ) { return ObjectUtils . equals ( object1 , object2 ) == false ; } public static int hashCode ( Object obj ) { return obj == null ? <NUM_LIT> : obj . hashCode ( ) ; } public static int hashCodeMulti ( Object ... objects ) { int hash = <NUM_LIT> ; if ( objects != null ) { for ( Object object : objects ) { hash = hash * <NUM_LIT> + ObjectUtils . hashCode ( object ) ; } } return hash ; } public static String identityToString ( Object object ) { if ( object == null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; identityToString ( buffer , object ) ; return buffer . toString ( ) ; } public static void identityToString ( StringBuffer buffer , Object object ) { if ( object == null ) { throw new NullPointerException ( "<STR_LIT>" ) ; } buffer . append ( object . getClass ( ) . getName ( ) ) . append ( '<STR_LIT>' ) . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; } public static String toString ( Object obj ) { return obj == null ? "<STR_LIT>" : obj . toString ( ) ; } public static String toString ( Object obj , String nullStr ) { return obj == null ? nullStr : obj . toString ( ) ; } public static < T extends Comparable < ? super T > > T min ( T ... values ) { T result = null ; if ( values != null ) { for ( T value : values ) { if ( compare ( value , result , true ) < <NUM_LIT> ) { result = value ; } } } return result ; } public static < T extends Comparable < ? super T > > T max ( T ... values ) { T result = null ; if ( values != null ) { for ( T value : values ) { if ( compare ( value , result , false ) > <NUM_LIT> ) { result = value ; } } } return result ; } public static < T extends Comparable < ? super T > > int compare ( T c1 , T c2 ) { return compare ( c1 , c2 , false ) ; } public static < T extends Comparable < ? super T > > int compare ( T c1 , T c2 , boolean nullGreater ) { if ( c1 == c2 ) { return <NUM_LIT> ; } else if ( c1 == null ) { return nullGreater ? <NUM_LIT> : - <NUM_LIT> ; } else if ( c2 == null ) { return nullGreater ? - <NUM_LIT> : <NUM_LIT> ; } return c1 . compareTo ( c2 ) ; } public static < T extends Comparable < ? super T > > T median ( T ... items ) { Validate . notEmpty ( items ) ; Validate . noNullElements ( items ) ; TreeSet < T > sort = new TreeSet < T > ( ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( "<STR_LIT>" ) T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - <NUM_LIT> ) / <NUM_LIT> ] ; return result ; } public static < T > T median ( Comparator < T > comparator , T ... items ) { Validate . notEmpty ( items , "<STR_LIT>" ) ; Validate . noNullElements ( items ) ; Validate . notNull ( comparator , "<STR_LIT>" ) ; TreeSet < T > sort = new TreeSet < T > ( comparator ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( "<STR_LIT>" ) T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - <NUM_LIT> ) / <NUM_LIT> ] ; return result ; } public static < T > T mode ( T ... items ) { if ( ArrayUtils . isNotEmpty ( items ) ) { HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( items . length ) ; for ( T t : items ) { MutableInt count = occurrences . get ( t ) ; if ( count == null ) { occurrences . put ( t , new MutableInt ( <NUM_LIT> ) ) ; } else { count . increment ( ) ; } } T result = null ; int max = <NUM_LIT> ; for ( Map . Entry < T , MutableInt > e : occurrences . entrySet ( ) ) { int cmp = e . getValue ( ) . intValue ( ) ; if ( cmp == max ) { result = null ; } else if ( cmp > max ) { max = cmp ; result = e . getKey ( ) ; } } return result ; } return null ; } public static < T > T clone ( final T obj ) { if ( obj instanceof Cloneable ) { final Object result ; if ( obj . getClass ( ) . isArray ( ) ) { final Class < ? > componentType = obj . getClass ( ) . getComponentType ( ) ; if ( ! componentType . isPrimitive ( ) ) { result = ( ( Object [ ] ) obj ) . clone ( ) ; } else { int length = Array . getLength ( obj ) ; result = Array . newInstance ( componentType , length ) ; while ( length -- > <NUM_LIT> ) { Array . set ( result , length , Array . get ( obj , length ) ) ; } } } else { try { final Method clone = obj . getClass ( ) . getMethod ( "<STR_LIT>" ) ; result = clone . invoke ( obj ) ; } catch ( final NoSuchMethodException e ) { throw new CloneFailedException ( "<STR_LIT>" + obj . getClass ( ) . getName ( ) + "<STR_LIT>" , e ) ; } catch ( final IllegalAccessException e ) { throw new CloneFailedException ( "<STR_LIT>" + obj . getClass ( ) . getName ( ) , e ) ; } catch ( final InvocationTargetException e ) { throw new CloneFailedException ( "<STR_LIT>" + obj . getClass ( ) . getName ( ) , e . getCause ( ) ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) final T checked = ( T ) result ; return checked ; } return null ; } public static < T > T cloneIfPossible ( final T obj ) { final T clone = clone ( obj ) ; return clone == null ? obj : clone ; } public static class Null implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; Null ( ) { super ( ) ; } private Object readResolve ( ) { return ObjectUtils . NULL ; } } } </s>
<s> package external . org . apache . commons . lang3 ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . regex . Pattern ; public class Validate { private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_MATCHES_PATTERN_EX = "<STR_LIT>" ; private static final String DEFAULT_IS_NULL_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_IS_TRUE_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_VALID_STATE_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = "<STR_LIT>" ; private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = "<STR_LIT>" ; public Validate ( ) { super ( ) ; } public static void isTrue ( boolean expression , String message , long value ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Long . valueOf ( value ) ) ) ; } } public static void isTrue ( boolean expression , String message , double value ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Double . valueOf ( value ) ) ) ; } } public static void isTrue ( boolean expression , String message , Object ... values ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isTrue ( boolean expression ) { if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } } public static < T > T notNull ( T object ) { return notNull ( object , DEFAULT_IS_NULL_EX_MESSAGE ) ; } public static < T > T notNull ( T object , String message , Object ... values ) { if ( object == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } return object ; } public static < T > T [ ] notEmpty ( T [ ] array , String message , Object ... values ) { if ( array == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( array . length == <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return array ; } public static < T > T [ ] notEmpty ( T [ ] array ) { return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE ) ; } public static < T extends Collection < ? > > T notEmpty ( T collection , String message , Object ... values ) { if ( collection == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( collection . isEmpty ( ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return collection ; } public static < T extends Collection < ? > > T notEmpty ( T collection ) { return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE ) ; } public static < T extends Map < ? , ? > > T notEmpty ( T map , String message , Object ... values ) { if ( map == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( map . isEmpty ( ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return map ; } public static < T extends Map < ? , ? > > T notEmpty ( T map ) { return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE ) ; } public static < T extends CharSequence > T notEmpty ( T chars , String message , Object ... values ) { if ( chars == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( chars . length ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T notEmpty ( T chars ) { return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE ) ; } public static < T extends CharSequence > T notBlank ( T chars , String message , Object ... values ) { if ( chars == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( StringUtils . isBlank ( chars ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T notBlank ( T chars ) { return notBlank ( chars , DEFAULT_NOT_BLANK_EX_MESSAGE ) ; } public static < T > T [ ] noNullElements ( T [ ] array , String message , Object ... values ) { Validate . notNull ( array ) ; for ( int i = <NUM_LIT> ; i < array . length ; i ++ ) { if ( array [ i ] == null ) { Object [ ] values2 = ArrayUtils . add ( values , Integer . valueOf ( i ) ) ; throw new IllegalArgumentException ( String . format ( message , values2 ) ) ; } } return array ; } public static < T > T [ ] noNullElements ( T [ ] array ) { return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE ) ; } public static < T extends Iterable < ? > > T noNullElements ( T iterable , String message , Object ... values ) { Validate . notNull ( iterable ) ; int i = <NUM_LIT> ; for ( Iterator < ? > it = iterable . iterator ( ) ; it . hasNext ( ) ; i ++ ) { if ( it . next ( ) == null ) { Object [ ] values2 = ArrayUtils . addAll ( values , Integer . valueOf ( i ) ) ; throw new IllegalArgumentException ( String . format ( message , values2 ) ) ; } } return iterable ; } public static < T extends Iterable < ? > > T noNullElements ( T iterable ) { return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE ) ; } public static < T > T [ ] validIndex ( T [ ] array , int index , String message , Object ... values ) { Validate . notNull ( array ) ; if ( index < <NUM_LIT> || index >= array . length ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return array ; } public static < T > T [ ] validIndex ( T [ ] array , int index ) { return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static < T extends Collection < ? > > T validIndex ( T collection , int index , String message , Object ... values ) { Validate . notNull ( collection ) ; if ( index < <NUM_LIT> || index >= collection . size ( ) ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return collection ; } public static < T extends Collection < ? > > T validIndex ( T collection , int index ) { return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static < T extends CharSequence > T validIndex ( T chars , int index , String message , Object ... values ) { Validate . notNull ( chars ) ; if ( index < <NUM_LIT> || index >= chars . length ( ) ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T validIndex ( T chars , int index ) { return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static void validState ( boolean expression ) { if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } } public static void validState ( boolean expression , String message , Object ... values ) { if ( expression == false ) { throw new IllegalStateException ( String . format ( message , values ) ) ; } } public static void matchesPattern ( CharSequence input , String pattern ) { if ( Pattern . matches ( pattern , input ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_MATCHES_PATTERN_EX , input , pattern ) ) ; } } public static void matchesPattern ( CharSequence input , String pattern , String message , Object ... values ) { if ( Pattern . matches ( pattern , input ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static < T > void inclusiveBetween ( T start , T end , Comparable < T > value ) { if ( value . compareTo ( start ) < <NUM_LIT> || value . compareTo ( end ) > <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE , value , start , end ) ) ; } } public static < T > void inclusiveBetween ( T start , T end , Comparable < T > value , String message , Object ... values ) { if ( value . compareTo ( start ) < <NUM_LIT> || value . compareTo ( end ) > <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static < T > void exclusiveBetween ( T start , T end , Comparable < T > value ) { if ( value . compareTo ( start ) <= <NUM_LIT> || value . compareTo ( end ) >= <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE , value , start , end ) ) ; } } public static < T > void exclusiveBetween ( T start , T end , Comparable < T > value , String message , Object ... values ) { if ( value . compareTo ( start ) <= <NUM_LIT> || value . compareTo ( end ) >= <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isInstanceOf ( Class < ? > type , Object obj ) { if ( type . isInstance ( obj ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_IS_INSTANCE_OF_EX_MESSAGE , type . getName ( ) , obj == null ? "<STR_LIT>" : obj . getClass ( ) . getName ( ) ) ) ; } } public static void isInstanceOf ( Class < ? > type , Object obj , String message , Object ... values ) { if ( type . isInstance ( obj ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isAssignableFrom ( Class < ? > superType , Class < ? > type ) { if ( superType . isAssignableFrom ( type ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_IS_ASSIGNABLE_EX_MESSAGE , type == null ? "<STR_LIT>" : type . getName ( ) , superType . getName ( ) ) ) ; } } public static void isAssignableFrom ( Class < ? > superType , Class < ? > type , String message , Object ... values ) { if ( superType . isAssignableFrom ( type ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } } </s>
<s> package de . robv . android . xposed . callbacks ; </s>
<s> package android . content . res ; import android . app . AndroidAppHelper ; import android . util . DisplayMetrics ; import java . lang . reflect . InvocationTargetException ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . IXposedHookZygoteInit ; import de . robv . android . xposed . IXposedHookZygoteInit . StartupParam ; import de . robv . android . xposed . callbacks . XC_InitPackageResources . InitPackageResourcesParam ; public class XModuleResources extends Resources { private XModuleResources ( AssetManager assets , DisplayMetrics metrics , Configuration config ) { super ( assets , metrics , config ) ; } public static XModuleResources createInstance ( String path , XResources origRes ) { if ( path == null ) throw new IllegalArgumentException ( "<STR_LIT>" ) ; AssetManager assets = new AssetManager ( ) ; try { AssetManager . class . getMethod ( "<STR_LIT>" , String . class ) . invoke ( assets , path ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } XModuleResources res ; if ( origRes != null ) res = new XModuleResources ( assets , origRes . getDisplayMetrics ( ) , origRes . getConfiguration ( ) ) ; else res = new XModuleResources ( assets , null , null ) ; AndroidAppHelper . addActiveResource ( path , res ) ; return res ; } public XResForwarder fwd ( int id ) { return new XResForwarder ( this , id ) ; } } </s>
<s> package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . tuple . Pair ; public class EqualsBuilder implements Builder < Boolean > { private static final ThreadLocal < Set < Pair < IDKey , IDKey > > > REGISTRY = new ThreadLocal < Set < Pair < IDKey , IDKey > > > ( ) ; static Set < Pair < IDKey , IDKey > > getRegistry ( ) { return REGISTRY . get ( ) ; } static Pair < IDKey , IDKey > getRegisterPair ( Object lhs , Object rhs ) { IDKey left = new IDKey ( lhs ) ; IDKey right = new IDKey ( rhs ) ; return Pair . of ( left , right ) ; } static boolean isRegistered ( Object lhs , Object rhs ) { Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft ( ) , pair . getRight ( ) ) ; return registry != null && ( registry . contains ( pair ) || registry . contains ( swappedPair ) ) ; } static void register ( Object lhs , Object rhs ) { synchronized ( EqualsBuilder . class ) { if ( getRegistry ( ) == null ) { REGISTRY . set ( new HashSet < Pair < IDKey , IDKey > > ( ) ) ; } } Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; registry . add ( pair ) ; } static void unregister ( Object lhs , Object rhs ) { Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; if ( registry != null ) { Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; registry . remove ( pair ) ; synchronized ( EqualsBuilder . class ) { registry = getRegistry ( ) ; if ( registry != null && registry . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } private boolean isEquals = true ; public EqualsBuilder ( ) { } public static boolean reflectionEquals ( Object lhs , Object rhs , Collection < String > excludeFields ) { return reflectionEquals ( lhs , rhs , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , String ... excludeFields ) { return reflectionEquals ( lhs , rhs , false , null , excludeFields ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients ) { return reflectionEquals ( lhs , rhs , testTransients , null ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients , Class < ? > reflectUpToClass , String ... excludeFields ) { if ( lhs == rhs ) { return true ; } if ( lhs == null || rhs == null ) { return false ; } Class < ? > lhsClass = lhs . getClass ( ) ; Class < ? > rhsClass = rhs . getClass ( ) ; Class < ? > testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( ! rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( ! lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; } } else { return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) != null && testClass != reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) { return false ; } return equalsBuilder . isEquals ( ) ; } private static void reflectionAppend ( Object lhs , Object rhs , Class < ? > clazz , EqualsBuilder builder , boolean useTransients , String [ ] excludeFields ) { if ( isRegistered ( lhs , rhs ) ) { return ; } try { register ( lhs , rhs ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = <NUM_LIT> ; i < fields . length && builder . isEquals ; i ++ ) { Field f = fields [ i ] ; if ( ! ArrayUtils . contains ( excludeFields , f . getName ( ) ) && ( f . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( f . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( "<STR_LIT>" ) ; } } } } finally { unregister ( lhs , rhs ) ; } } public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals == false ) { return this ; } isEquals = superEquals ; return this ; } public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } Class < ? > lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) != rhs . getClass ( ) ) { this . setEquals ( false ) ; } else if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs ) ; } return this ; } public EqualsBuilder append ( long lhs , long rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( int lhs , int rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( short lhs , short rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( byte lhs , byte rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( double lhs , double rhs ) { if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; } public EqualsBuilder append ( float lhs , float rhs ) { if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; } public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( Object [ ] lhs , Object [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( char [ ] lhs , char [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( byte [ ] lhs , byte [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( double [ ] lhs , double [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( float [ ] lhs , float [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public boolean isEquals ( ) { return this . isEquals ; } public Boolean build ( ) { return Boolean . valueOf ( isEquals ( ) ) ; } protected void setEquals ( boolean isEquals ) { this . isEquals = isEquals ; } public void reset ( ) { this . isEquals = true ; } } </s>
<s> package android . app ; import android . content . SharedPreferences ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; import android . content . res . Configuration ; import android . content . res . Resources ; import android . os . Build ; import android . os . IBinder ; import android . view . Display ; import java . lang . ref . WeakReference ; import java . util . Map ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import static de . robv . android . xposed . XposedHelpers . findClass ; import static de . robv . android . xposed . XposedHelpers . findFieldIfExists ; import static de . robv . android . xposed . XposedHelpers . findMethodExactIfExists ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import static de . robv . android . xposed . XposedHelpers . newInstance ; import static de . robv . android . xposed . XposedHelpers . setFloatField ; public final class AndroidAppHelper { private AndroidAppHelper ( ) { } private static final Class < ? > CLASS_RESOURCES_KEY ; private static final boolean HAS_IS_THEMEABLE ; private static final boolean HAS_THEME_CONFIG_PARAMETER ; static { CLASS_RESOURCES_KEY = ( Build . VERSION . SDK_INT < <NUM_LIT> ) ? findClass ( "<STR_LIT>" , null ) : findClass ( "<STR_LIT>" , null ) ; HAS_IS_THEMEABLE = findFieldIfExists ( CLASS_RESOURCES_KEY , "<STR_LIT>" ) != null ; HAS_THEME_CONFIG_PARAMETER = HAS_IS_THEMEABLE && Build . VERSION . SDK_INT >= <NUM_LIT> && findMethodExactIfExists ( "<STR_LIT>" , null , "<STR_LIT>" ) != null ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) private static Map < Object , WeakReference > getResourcesMap ( ActivityThread activityThread ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resourcesManager = getObjectField ( activityThread , "<STR_LIT>" ) ; return ( Map ) getObjectField ( resourcesManager , "<STR_LIT>" ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resourcesManager = getObjectField ( activityThread , "<STR_LIT>" ) ; return ( Map ) getObjectField ( resourcesManager , "<STR_LIT>" ) ; } else { return ( Map ) getObjectField ( activityThread , "<STR_LIT>" ) ; } } private static Object createResourcesKey ( String resDir , float scale ) { try { if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , scale , false ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , scale ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , int displayId , Configuration overrideConfiguration , float scale ) { try { if ( HAS_THEME_CONFIG_PARAMETER ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , null ) ; else if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , int displayId , Configuration overrideConfiguration , float scale , IBinder token ) { try { if ( HAS_THEME_CONFIG_PARAMETER ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , null , token ) ; else if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , token ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , token ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , String [ ] splitResDirs , String [ ] overlayDirs , String [ ] libDirs , int displayId , Configuration overrideConfiguration , CompatibilityInfo compatInfo ) { try { return newInstance ( CLASS_RESOURCES_KEY , resDir , splitResDirs , overlayDirs , libDirs , displayId , overrideConfiguration , compatInfo ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } public static void addActiveResource ( String resDir , float scale , boolean isThemeable , Resources resources ) { addActiveResource ( resDir , resources ) ; } public static void addActiveResource ( String resDir , Resources resources ) { ActivityThread thread = ActivityThread . currentActivityThread ( ) ; if ( thread == null ) { return ; } Object resourcesKey ; if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { CompatibilityInfo compatInfo = ( CompatibilityInfo ) newInstance ( CompatibilityInfo . class ) ; setFloatField ( compatInfo , "<STR_LIT>" , resources . hashCode ( ) ) ; resourcesKey = createResourcesKey ( resDir , null , null , null , Display . DEFAULT_DISPLAY , null , compatInfo ) ; } else if ( Build . VERSION . SDK_INT == <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) , null ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) ) ; } else { resourcesKey = createResourcesKey ( resDir , resources . hashCode ( ) ) ; } if ( resourcesKey != null ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resImpl = getObjectField ( resources , "<STR_LIT>" ) ; getResourcesMap ( thread ) . put ( resourcesKey , new WeakReference < > ( resImpl ) ) ; } else { getResourcesMap ( thread ) . put ( resourcesKey , new WeakReference < > ( resources ) ) ; } } } public static String currentProcessName ( ) { String processName = ActivityThread . currentPackageName ( ) ; if ( processName == null ) return "<STR_LIT>" ; return processName ; } public static ApplicationInfo currentApplicationInfo ( ) { ActivityThread am = ActivityThread . currentActivityThread ( ) ; if ( am == null ) return null ; Object boundApplication = getObjectField ( am , "<STR_LIT>" ) ; if ( boundApplication == null ) return null ; return ( ApplicationInfo ) getObjectField ( boundApplication , "<STR_LIT>" ) ; } public static String currentPackageName ( ) { ApplicationInfo ai = currentApplicationInfo ( ) ; return ( ai != null ) ? ai . packageName : "<STR_LIT>" ; } public static Application currentApplication ( ) { return ActivityThread . currentApplication ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Deprecated public static SharedPreferences getSharedPreferencesForPackage ( String packageName , String prefFileName , int mode ) { return new XSharedPreferences ( packageName , prefFileName ) ; } @ Deprecated public static SharedPreferences getDefaultSharedPreferencesForPackage ( String packageName ) { return new XSharedPreferences ( packageName ) ; } @ Deprecated public static void reloadSharedPreferencesIfNeeded ( SharedPreferences pref ) { if ( pref instanceof XSharedPreferences ) { ( ( XSharedPreferences ) pref ) . reload ( ) ; } } } </s>
<s> package com . android . internal . util ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; public class XmlUtils { @ SuppressWarnings ( "<STR_LIT>" ) public static final HashMap readMapXml ( InputStream in ) throws XmlPullParserException , IOException { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package external . org . apache . commons . lang3 . builder ; final class IDKey { private final Object value ; private final int id ; public IDKey ( Object _value ) { id = System . identityHashCode ( _value ) ; value = _value ; } @ Override public int hashCode ( ) { return id ; } @ Override public boolean equals ( Object other ) { if ( ! ( other instanceof IDKey ) ) { return false ; } IDKey idKey = ( IDKey ) other ; if ( id != idKey . id ) { return false ; } return value == idKey . value ; } } </s>
<s> package android . os ; public class ServiceManager { public static IBinder getService ( String name ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package android . app ; import android . content . pm . ApplicationInfo ; public final class LoadedApk { public ApplicationInfo getApplicationInfo ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public ClassLoader getClassLoader ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getPackageName ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } public String getResDir ( ) { throw new UnsupportedOperationException ( "<STR_LIT>" ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( "<STR_LIT>" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return getHorizontalHelper ( layoutManager ) ; } else { return null ; } } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) { mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ; } return mHorizontalHelper ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mAdapter . notifyItemRangeChanged ( position , count ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollWebView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollWebView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollWebView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollWebView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , "<STR_LIT>" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , "<STR_LIT>" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , "<STR_LIT>" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) { mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ; } } private void autoHideScrollbar ( ) { if ( mDragging ) { return ; } mAnimationHelper . hideScrollbar ( mTrackView , mThumbView ) ; } private void cancelAutoHideScrollbar ( ) { mView . removeCallbacks ( mAutoHideScrollbarRunnable ) ; } public interface ViewHelper { void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) ; void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) ; void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) ; int getScrollRange ( ) ; int getScrollOffset ( ) ; void scrollTo ( int offset ) ; @ Nullable default CharSequence getPopupText ( ) { return null ; } } public interface AnimationHelper { void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; boolean isScrollbarAutoHideEnabled ( ) ; int getScrollbarAutoHideDelayMillis ( ) ; void showPopup ( @ NonNull View popupView ) ; void hidePopup ( @ NonNull View popupView ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ; @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { } @ Override public void clearView ( @ NonNull View view ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { final Object tag = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( tag instanceof Float ) { ViewCompat . setElevation ( view , ( Float ) tag ) ; } view . setTag ( R . id . item_touch_helper_previous_elevation , null ) ; } view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; } @ Override public void onSelected ( @ NonNull View view ) { } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; } @ Override public void showPopup ( @ NonNull View popupView ) { if ( mShowingPopup ) { return ; } mShowingPopup = true ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . start ( ) ; } @ Override public void hidePopup ( @ NonNull View popupView ) { if ( ! mShowingPopup ) { return ; } mShowingPopup = false ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( HIDE_DURATION_MILLIS ) . start ( ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY_GROUP_PREFIX ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Rect ; import android . os . Build ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . SparseArray ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityNodeInfo ; import android . view . animation . Interpolator ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . Px ; import androidx . annotation . RequiresApi ; import androidx . annotation . RestrictTo ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat . AccessibilityActionCompat ; import androidx . core . view . accessibility . AccessibilityViewCommand ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . PagerSnapHelper ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ItemDecoration ; import androidx . fluidviewpager2 . adapter . FragmentStateAdapter ; import androidx . fluidviewpager2 . adapter . StatefulAdapter ; import androidx . interpolator . view . animation . FastOutSlowInInterpolator ; import androidx . viewpager2 . R ; import com . google . android . material . motion . MotionUtils ; import java . lang . annotation . Retention ; public final class ViewPager2 extends ViewGroup { public static final int ORIENTATION_HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int ORIENTATION_VERTICAL = RecyclerView . VERTICAL ; public static final int SCROLL_STATE_IDLE = <NUM_LIT> ; public static final int SCROLL_STATE_DRAGGING = <NUM_LIT> ; public static final int SCROLL_STATE_SETTLING = <NUM_LIT> ; public static final int OFFSCREEN_PAGE_LIMIT_DEFAULT = - <NUM_LIT> ; static boolean sFeatureEnhancedA11yEnabled = true ; private final Rect mTmpContainerRect = new Rect ( ) ; private final Rect mTmpChildRect = new Rect ( ) ; int mCurrentItem ; boolean mCurrentItemDirty = false ; LinearLayoutManager mLayoutManager ; RecyclerView mRecyclerView ; ScrollEventAdapter mScrollEventAdapter ; AccessibilityProvider mAccessibilityProvider ; private CompositeOnPageChangeCallback mExternalPageChangeCallbacks = new CompositeOnPageChangeCallback ( <NUM_LIT> ) ; private RecyclerView . AdapterDataObserver mCurrentItemDataSetChangeObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { mCurrentItemDirty = true ; mScrollEventAdapter . notifyDataSetChangeHappened ( ) ; } } ; private int mPendingCurrentItem = NO_POSITION ; private Parcelable mPendingAdapterState ; private PagerSnapHelper mPagerSnapHelper ; private CompositeOnPageChangeCallback mPageChangeEventDispatcher ; private FakeDrag mFakeDragger ; private androidx . fluidviewpager2 . widget . PageTransformerAdapter mPageTransformerAdapter ; private RecyclerView . ItemAnimator mSavedItemAnimator = null ; private boolean mSavedItemAnimatorPresent = false ; private boolean mUserInputEnabled = true ; private @ OffscreenPageLimit int mOffscreenPageLimit = OFFSCREEN_PAGE_LIMIT_DEFAULT ; public ViewPager2 ( @ NonNull Context context ) { super ( context ) ; initialize ( context , null ) ; } public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; initialize ( context , attrs ) ; } public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; initialize ( context , attrs ) ; } @ RequiresApi ( <NUM_LIT> ) @ SuppressLint ( "<STR_LIT>" ) public ViewPager2 ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; initialize ( context , attrs ) ; } private void initialize ( Context context , AttributeSet attrs ) { mAccessibilityProvider = sFeatureEnhancedA11yEnabled ? new PageAwareAccessibilityProvider ( ) : new BasicAccessibilityProvider ( ) ; mRecyclerView = new RecyclerViewImpl ( context ) ; mRecyclerView . setId ( View . generateViewId ( ) ) ; mRecyclerView . setDescendantFocusability ( FOCUS_BEFORE_DESCENDANTS ) ; mLayoutManager = new LinearLayoutManagerImpl ( context ) ; mRecyclerView . setLayoutManager ( mLayoutManager ) ; mRecyclerView . setScrollingTouchSlop ( RecyclerView . TOUCH_SLOP_PAGING ) ; setOrientation ( context , attrs ) ; mRecyclerView . setLayoutParams ( new ViewGroup . LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ) ; mRecyclerView . addOnChildAttachStateChangeListener ( enforceChildFillListener ( ) ) ; mScrollEventAdapter = new ScrollEventAdapter ( this ) ; mFakeDragger = new FakeDrag ( this , mScrollEventAdapter , mRecyclerView ) ; mPagerSnapHelper = new PagerSnapHelperImpl ( ) ; mPagerSnapHelper . attachToRecyclerView ( mRecyclerView ) ; mRecyclerView . addOnScrollListener ( mScrollEventAdapter ) ; mPageChangeEventDispatcher = new CompositeOnPageChangeCallback ( <NUM_LIT> ) ; mScrollEventAdapter . setOnPageChangeCallback ( mPageChangeEventDispatcher ) ; final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { if ( mCurrentItem != position ) { mCurrentItem = position ; mAccessibilityProvider . onSetNewCurrentItem ( ) ; } } @ Override public void onPageScrollStateChanged ( int newState ) { if ( newState == SCROLL_STATE_IDLE ) { updateCurrentItem ( ) ; } } } ; final OnPageChangeCallback focusClearer = new OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { clearFocus ( ) ; if ( hasFocus ( ) ) { mRecyclerView . requestFocus ( View . FOCUS_FORWARD ) ; } } } ; mPageChangeEventDispatcher . addOnPageChangeCallback ( currentItemUpdater ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( focusClearer ) ; mAccessibilityProvider . onInitialize ( mPageChangeEventDispatcher , mRecyclerView ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( mExternalPageChangeCallbacks ) ; mPageTransformerAdapter = new androidx . fluidviewpager2 . widget . PageTransformerAdapter ( mLayoutManager ) ; mPageChangeEventDispatcher . addOnPageChangeCallback ( mPageTransformerAdapter ) ; attachViewToParent ( mRecyclerView , <NUM_LIT> , mRecyclerView . getLayoutParams ( ) ) ; } private RecyclerView . OnChildAttachStateChangeListener enforceChildFillListener ( ) { return new RecyclerView . OnChildAttachStateChangeListener ( ) { @ Override public void onChildViewAttachedToWindow ( @ NonNull View view ) { RecyclerView . LayoutParams layoutParams = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( layoutParams . width != LayoutParams . MATCH_PARENT || layoutParams . height != LayoutParams . MATCH_PARENT ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } @ Override public void onChildViewDetachedFromWindow ( @ NonNull View view ) { } } ; } @ RequiresApi ( <NUM_LIT> ) @ Override public CharSequence getAccessibilityClassName ( ) { if ( mAccessibilityProvider . handlesGetAccessibilityClassName ( ) ) { return mAccessibilityProvider . onGetAccessibilityClassName ( ) ; } return super . getAccessibilityClassName ( ) ; } private void setOrientation ( Context context , AttributeSet attrs ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . ViewPager2 ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , R . styleable . ViewPager2 , attrs , a , <NUM_LIT> , <NUM_LIT> ) ; try { setOrientation ( a . getInt ( R . styleable . ViewPager2_android_orientation , ORIENTATION_HORIZONTAL ) ) ; } finally { a . recycle ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable @ Override protected Parcelable onSaveInstanceState ( ) { Parcelable superState = super . onSaveInstanceState ( ) ; SavedState ss = new SavedState ( superState ) ; ss . mRecyclerViewId = mRecyclerView . getId ( ) ; ss . mCurrentItem = mPendingCurrentItem == NO_POSITION ? mCurrentItem : mPendingCurrentItem ; if ( mPendingAdapterState != null ) { ss . mAdapterState = mPendingAdapterState ; } else { Adapter < ? > adapter = mRecyclerView . getAdapter ( ) ; if ( adapter instanceof StatefulAdapter ) { ss . mAdapterState = ( ( StatefulAdapter ) adapter ) . saveState ( ) ; } } return ss ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( ! ( state instanceof SavedState ) ) { super . onRestoreInstanceState ( state ) ; return ; } SavedState ss = ( SavedState ) state ; super . onRestoreInstanceState ( ss . getSuperState ( ) ) ; mPendingCurrentItem = ss . mCurrentItem ; mPendingAdapterState = ss . mAdapterState ; } private void restorePendingState ( ) { if ( mPendingCurrentItem == NO_POSITION ) { return ; } Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { return ; } if ( mPendingAdapterState != null ) { if ( adapter instanceof StatefulAdapter ) { ( ( StatefulAdapter ) adapter ) . restoreState ( mPendingAdapterState ) ; } mPendingAdapterState = null ; } mCurrentItem = Math . max ( <NUM_LIT> , Math . min ( mPendingCurrentItem , adapter . getItemCount ( ) - <NUM_LIT> ) ) ; mPendingCurrentItem = NO_POSITION ; mRecyclerView . scrollToPosition ( mCurrentItem ) ; mAccessibilityProvider . onRestorePendingState ( ) ; } @ Override protected void dispatchRestoreInstanceState ( SparseArray < Parcelable > container ) { Parcelable state = container . get ( getId ( ) ) ; if ( state instanceof SavedState ) { final int previousRvId = ( ( SavedState ) state ) . mRecyclerViewId ; final int currentRvId = mRecyclerView . getId ( ) ; container . put ( currentRvId , container . get ( previousRvId ) ) ; container . remove ( previousRvId ) ; } super . dispatchRestoreInstanceState ( container ) ; restorePendingState ( ) ; } private void registerCurrentItemDataSetTracker ( @ Nullable Adapter < ? > adapter ) { if ( adapter != null ) { adapter . registerAdapterDataObserver ( mCurrentItemDataSetChangeObserver ) ; } } private void unregisterCurrentItemDataSetTracker ( @ Nullable Adapter < ? > adapter ) { if ( adapter != null ) { adapter . unregisterAdapterDataObserver ( mCurrentItemDataSetChangeObserver ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public @ Nullable Adapter getAdapter ( ) { return mRecyclerView . getAdapter ( ) ; } public void setAdapter ( @ Nullable @ SuppressWarnings ( "<STR_LIT>" ) Adapter adapter ) { final Adapter < ? > currentAdapter = mRecyclerView . getAdapter ( ) ; mAccessibilityProvider . onDetachAdapter ( currentAdapter ) ; unregisterCurrentItemDataSetTracker ( currentAdapter ) ; mRecyclerView . setAdapter ( adapter ) ; mCurrentItem = <NUM_LIT> ; restorePendingState ( ) ; mAccessibilityProvider . onAttachAdapter ( adapter ) ; registerCurrentItemDataSetTracker ( adapter ) ; } @ Override public void onViewAdded ( View child ) { throw new IllegalStateException ( getClass ( ) . getSimpleName ( ) + "<STR_LIT>" ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { measureChild ( mRecyclerView , widthMeasureSpec , heightMeasureSpec ) ; int width = mRecyclerView . getMeasuredWidth ( ) ; int height = mRecyclerView . getMeasuredHeight ( ) ; int childState = mRecyclerView . getMeasuredState ( ) ; width += getPaddingLeft ( ) + getPaddingRight ( ) ; height += getPaddingTop ( ) + getPaddingBottom ( ) ; width = Math . max ( width , getSuggestedMinimumWidth ( ) ) ; height = Math . max ( height , getSuggestedMinimumHeight ( ) ) ; setMeasuredDimension ( resolveSizeAndState ( width , widthMeasureSpec , childState ) , resolveSizeAndState ( height , heightMeasureSpec , childState << MEASURED_HEIGHT_STATE_SHIFT ) ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { int width = mRecyclerView . getMeasuredWidth ( ) ; int height = mRecyclerView . getMeasuredHeight ( ) ; mTmpContainerRect . left = getPaddingLeft ( ) ; mTmpContainerRect . right = r - l - getPaddingRight ( ) ; mTmpContainerRect . top = getPaddingTop ( ) ; mTmpContainerRect . bottom = b - t - getPaddingBottom ( ) ; Gravity . apply ( Gravity . TOP | Gravity . START , width , height , mTmpContainerRect , mTmpChildRect ) ; mRecyclerView . layout ( mTmpChildRect . left , mTmpChildRect . top , mTmpChildRect . right , mTmpChildRect . bottom ) ; if ( mCurrentItemDirty ) { updateCurrentItem ( ) ; } } void updateCurrentItem ( ) { if ( mPagerSnapHelper == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } View snapView = mPagerSnapHelper . findSnapView ( mLayoutManager ) ; if ( snapView == null ) { return ; } int snapPosition = mLayoutManager . getPosition ( snapView ) ; if ( snapPosition != mCurrentItem && getScrollState ( ) == SCROLL_STATE_IDLE ) { mPageChangeEventDispatcher . onPageSelected ( snapPosition ) ; } mCurrentItemDirty = false ; } int getPageSize ( ) { final RecyclerView rv = mRecyclerView ; return getOrientation ( ) == ORIENTATION_HORIZONTAL ? rv . getWidth ( ) - rv . getPaddingLeft ( ) - rv . getPaddingRight ( ) : rv . getHeight ( ) - rv . getPaddingTop ( ) - rv . getPaddingBottom ( ) ; } public @ Orientation int getOrientation ( ) { return mLayoutManager . getOrientation ( ) == LinearLayoutManager . VERTICAL ? ViewPager2 . ORIENTATION_VERTICAL : ViewPager2 . ORIENTATION_HORIZONTAL ; } public void setOrientation ( @ Orientation int orientation ) { mLayoutManager . setOrientation ( orientation ) ; mAccessibilityProvider . onSetOrientation ( ) ; } boolean isRtl ( ) { return mLayoutManager . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; } public void setCurrentItem ( int item , boolean smoothScroll ) { if ( isFakeDragging ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } setCurrentItemInternal ( item , smoothScroll ) ; } void setCurrentItemInternal ( int item , boolean smoothScroll ) { Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { if ( mPendingCurrentItem != NO_POSITION ) { mPendingCurrentItem = Math . max ( item , <NUM_LIT> ) ; } return ; } if ( adapter . getItemCount ( ) <= <NUM_LIT> ) { return ; } item = Math . max ( item , <NUM_LIT> ) ; item = Math . min ( item , adapter . getItemCount ( ) - <NUM_LIT> ) ; if ( item == mCurrentItem && mScrollEventAdapter . isIdle ( ) ) { return ; } if ( item == mCurrentItem && smoothScroll ) { return ; } double previousItem = mCurrentItem ; mCurrentItem = item ; mAccessibilityProvider . onSetNewCurrentItem ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { previousItem = mScrollEventAdapter . getRelativeScrollPosition ( ) ; } mScrollEventAdapter . notifyProgrammaticScroll ( item , smoothScroll ) ; if ( ! smoothScroll ) { mRecyclerView . scrollToPosition ( item ) ; return ; } if ( Math . abs ( item - previousItem ) > <NUM_LIT> ) { mRecyclerView . scrollToPosition ( item > previousItem ? item - <NUM_LIT> : item + <NUM_LIT> ) ; mRecyclerView . post ( new SmoothScrollToPosition ( item , mRecyclerView ) ) ; } else { mRecyclerView . smoothScrollToPosition ( item ) ; } } public int getCurrentItem ( ) { return mCurrentItem ; } public void setCurrentItem ( int item ) { setCurrentItem ( item , true ) ; } @ ScrollState public int getScrollState ( ) { return mScrollEventAdapter . getScrollState ( ) ; } public boolean beginFakeDrag ( ) { return mFakeDragger . beginFakeDrag ( ) ; } public boolean fakeDragBy ( @ SuppressLint ( "<STR_LIT>" ) @ Px float offsetPxFloat ) { return mFakeDragger . fakeDragBy ( offsetPxFloat ) ; } public boolean endFakeDrag ( ) { return mFakeDragger . endFakeDrag ( ) ; } public boolean isFakeDragging ( ) { return mFakeDragger . isFakeDragging ( ) ; } void snapToPage ( ) { View view = mPagerSnapHelper . findSnapView ( mLayoutManager ) ; if ( view == null ) { return ; } int [ ] snapDistance = mPagerSnapHelper . calculateDistanceToFinalSnap ( mLayoutManager , view ) ; TimeInterpolator interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , com . google . android . material . R . attr . motionEasingStandardInterpolator , new FastOutSlowInInterpolator ( ) ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] , ( Interpolator ) interpolator ) ; } } public boolean isUserInputEnabled ( ) { return mUserInputEnabled ; } public void setUserInputEnabled ( boolean enabled ) { mUserInputEnabled = enabled ; mAccessibilityProvider . onSetUserInputEnabled ( ) ; } @ OffscreenPageLimit public int getOffscreenPageLimit ( ) { return mOffscreenPageLimit ; } public void setOffscreenPageLimit ( @ OffscreenPageLimit int limit ) { if ( limit < <NUM_LIT> && limit != OFFSCREEN_PAGE_LIMIT_DEFAULT ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOffscreenPageLimit = limit ; mRecyclerView . requestLayout ( ) ; } @ Override public boolean canScrollHorizontally ( int direction ) { return mRecyclerView . canScrollHorizontally ( direction ) ; } @ Override public boolean canScrollVertically ( int direction ) { return mRecyclerView . canScrollVertically ( direction ) ; } public void registerOnPageChangeCallback ( @ NonNull OnPageChangeCallback callback ) { mExternalPageChangeCallbacks . addOnPageChangeCallback ( callback ) ; } public void unregisterOnPageChangeCallback ( @ NonNull OnPageChangeCallback callback ) { mExternalPageChangeCallbacks . removeOnPageChangeCallback ( callback ) ; } public void setPageTransformer ( @ Nullable PageTransformer transformer ) { if ( transformer != null ) { if ( ! mSavedItemAnimatorPresent ) { mSavedItemAnimator = mRecyclerView . getItemAnimator ( ) ; mSavedItemAnimatorPresent = true ; } mRecyclerView . setItemAnimator ( null ) ; } else { if ( mSavedItemAnimatorPresent ) { mRecyclerView . setItemAnimator ( mSavedItemAnimator ) ; mSavedItemAnimator = null ; mSavedItemAnimatorPresent = false ; } } if ( transformer == mPageTransformerAdapter . getPageTransformer ( ) ) { return ; } mPageTransformerAdapter . setPageTransformer ( transformer ) ; requestTransform ( ) ; } public void requestTransform ( ) { if ( mPageTransformerAdapter . getPageTransformer ( ) == null ) { return ; } double relativePosition = mScrollEventAdapter . getRelativeScrollPosition ( ) ; int position = ( int ) relativePosition ; float positionOffset = ( float ) ( relativePosition - position ) ; int positionOffsetPx = Math . round ( getPageSize ( ) * positionOffset ) ; mPageTransformerAdapter . onPageScrolled ( position , positionOffset , positionOffsetPx ) ; } @ Override public void setLayoutDirection ( int layoutDirection ) { super . setLayoutDirection ( layoutDirection ) ; mAccessibilityProvider . onSetLayoutDirection ( ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { super . onInitializeAccessibilityNodeInfo ( info ) ; mAccessibilityProvider . onInitializeAccessibilityNodeInfo ( info ) ; } @ Override public boolean performAccessibilityAction ( int action , @ Nullable Bundle arguments ) { if ( mAccessibilityProvider . handlesPerformAccessibilityAction ( action , arguments ) ) { return mAccessibilityProvider . onPerformAccessibilityAction ( action , arguments ) ; } return super . performAccessibilityAction ( action , arguments ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor ) { mRecyclerView . addItemDecoration ( decor ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { mRecyclerView . addItemDecoration ( decor , index ) ; } @ NonNull public ItemDecoration getItemDecorationAt ( int index ) { return mRecyclerView . getItemDecorationAt ( index ) ; } public int getItemDecorationCount ( ) { return mRecyclerView . getItemDecorationCount ( ) ; } public void invalidateItemDecorations ( ) { mRecyclerView . invalidateItemDecorations ( ) ; } public void removeItemDecorationAt ( int index ) { mRecyclerView . removeItemDecorationAt ( index ) ; } public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { mRecyclerView . removeItemDecoration ( decor ) ; } @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { ORIENTATION_HORIZONTAL , ORIENTATION_VERTICAL } ) public @ interface Orientation { } @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { SCROLL_STATE_IDLE , SCROLL_STATE_DRAGGING , SCROLL_STATE_SETTLING } ) public @ interface ScrollState { } @ SuppressWarnings ( "<STR_LIT>" ) @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ Retention ( SOURCE ) @ IntDef ( { OFFSCREEN_PAGE_LIMIT_DEFAULT } ) @ IntRange ( from = <NUM_LIT> ) public @ interface OffscreenPageLimit { } public interface PageTransformer { void transformPage ( @ NonNull View page , float position ) ; } static class SavedState extends BaseSavedState { public static final Creator < SavedState > CREATOR = new ClassLoaderCreator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel source , ClassLoader loader ) { return Build . VERSION . SDK_INT >= <NUM_LIT> ? new SavedState ( source , loader ) : new SavedState ( source ) ; } @ Override public SavedState createFromParcel ( Parcel source ) { return createFromParcel ( source , null ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; int mRecyclerViewId ; int mCurrentItem ; Parcelable mAdapterState ; @ RequiresApi ( <NUM_LIT> ) @ SuppressLint ( "<STR_LIT>" ) SavedState ( Parcel source , ClassLoader loader ) { super ( source , loader ) ; readValues ( source , loader ) ; } SavedState ( Parcel source ) { super ( source ) ; readValues ( source , null ) ; } SavedState ( Parcelable superState ) { super ( superState ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void readValues ( Parcel source , ClassLoader loader ) { mRecyclerViewId = source . readInt ( ) ; mCurrentItem = source . readInt ( ) ; mAdapterState = source . readParcelable ( loader ) ; } @ Override public void writeToParcel ( Parcel out , int flags ) { super . writeToParcel ( out , flags ) ; out . writeInt ( mRecyclerViewId ) ; out . writeInt ( mCurrentItem ) ; out . writeParcelable ( mAdapterState , flags ) ; } } private static class SmoothScrollToPosition implements Runnable { private final int mPosition ; private final RecyclerView mRecyclerView ; SmoothScrollToPosition ( int position , RecyclerView recyclerView ) { mPosition = position ; mRecyclerView = recyclerView ; } @ Override public void run ( ) { mRecyclerView . smoothScrollToPosition ( mPosition ) ; } } public abstract static class OnPageChangeCallback { public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { } public void onPageSelected ( int position ) { } public void onPageScrollStateChanged ( @ ScrollState int state ) { } } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } private class RecyclerViewImpl extends RecyclerView { RecyclerViewImpl ( @ NonNull Context context ) { super ( context ) ; } @ RequiresApi ( <NUM_LIT> ) @ Override public CharSequence getAccessibilityClassName ( ) { if ( mAccessibilityProvider . handlesRvGetAccessibilityClassName ( ) ) { return mAccessibilityProvider . onRvGetAccessibilityClassName ( ) ; } return super . getAccessibilityClassName ( ) ; } @ Override public void onInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; event . setFromIndex ( mCurrentItem ) ; event . setToIndex ( mCurrentItem ) ; mAccessibilityProvider . onRvInitializeAccessibilityEvent ( event ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onTouchEvent ( MotionEvent event ) { return isUserInputEnabled ( ) && super . onTouchEvent ( event ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { return isUserInputEnabled ( ) && super . onInterceptTouchEvent ( ev ) ; } } private class LinearLayoutManagerImpl extends LinearLayoutManager { LinearLayoutManagerImpl ( Context context ) { super ( context ) ; } @ Override public boolean performAccessibilityAction ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , int action , @ Nullable Bundle args ) { if ( mAccessibilityProvider . handlesLmPerformAccessibilityAction ( action ) ) { return mAccessibilityProvider . onLmPerformAccessibilityAction ( action ) ; } return super . performAccessibilityAction ( recycler , state , action , args ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( recycler , state , info ) ; mAccessibilityProvider . onLmInitializeAccessibilityNodeInfo ( info ) ; } @ Override public void onInitializeAccessibilityNodeInfoForItem ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { mAccessibilityProvider . onLmInitializeAccessibilityNodeInfoForItem ( host , info ) ; } @ Override protected void calculateExtraLayoutSpace ( @ NonNull RecyclerView . State state , @ NonNull int [ ] extraLayoutSpace ) { int pageLimit = getOffscreenPageLimit ( ) ; if ( pageLimit == OFFSCREEN_PAGE_LIMIT_DEFAULT ) { super . calculateExtraLayoutSpace ( state , extraLayoutSpace ) ; return ; } final int offscreenSpace = getPageSize ( ) * pageLimit ; extraLayoutSpace [ <NUM_LIT> ] = offscreenSpace ; extraLayoutSpace [ <NUM_LIT> ] = offscreenSpace ; } @ Override public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate , boolean focusedChildVisible ) { return false ; } } private class PagerSnapHelperImpl extends PagerSnapHelper { PagerSnapHelperImpl ( ) { } @ Nullable @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { return isFakeDragging ( ) ? null : super . findSnapView ( layoutManager ) ; } } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) private abstract class AccessibilityProvider { void onInitialize ( @ NonNull CompositeOnPageChangeCallback pageChangeEventDispatcher , @ NonNull RecyclerView recyclerView ) { } boolean handlesGetAccessibilityClassName ( ) { return false ; } String onGetAccessibilityClassName ( ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onRestorePendingState ( ) { } void onAttachAdapter ( @ Nullable Adapter < ? > newAdapter ) { } void onDetachAdapter ( @ Nullable Adapter < ? > oldAdapter ) { } void onSetOrientation ( ) { } void onSetNewCurrentItem ( ) { } void onSetUserInputEnabled ( ) { } void onSetLayoutDirection ( ) { } void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { } boolean handlesPerformAccessibilityAction ( int action , Bundle arguments ) { return false ; } boolean onPerformAccessibilityAction ( int action , Bundle arguments ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onRvInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { } boolean handlesLmPerformAccessibilityAction ( int action ) { return false ; } boolean onLmPerformAccessibilityAction ( int action ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } void onLmInitializeAccessibilityNodeInfo ( @ NonNull AccessibilityNodeInfoCompat info ) { } void onLmInitializeAccessibilityNodeInfoForItem ( @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { } boolean handlesRvGetAccessibilityClassName ( ) { return false ; } CharSequence onRvGetAccessibilityClassName ( ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } class BasicAccessibilityProvider extends AccessibilityProvider { @ Override public boolean handlesLmPerformAccessibilityAction ( int action ) { return ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD || action == AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) && ! isUserInputEnabled ( ) ; } @ Override public boolean onLmPerformAccessibilityAction ( int action ) { if ( ! handlesLmPerformAccessibilityAction ( action ) ) { throw new IllegalStateException ( ) ; } return false ; } @ Override public void onLmInitializeAccessibilityNodeInfo ( @ NonNull AccessibilityNodeInfoCompat info ) { if ( ! isUserInputEnabled ( ) ) { info . removeAction ( AccessibilityActionCompat . ACTION_SCROLL_BACKWARD ) ; info . removeAction ( AccessibilityActionCompat . ACTION_SCROLL_FORWARD ) ; info . setScrollable ( false ) ; } } @ Override public boolean handlesRvGetAccessibilityClassName ( ) { return true ; } @ Override public CharSequence onRvGetAccessibilityClassName ( ) { if ( ! handlesRvGetAccessibilityClassName ( ) ) { throw new IllegalStateException ( ) ; } return "<STR_LIT>" ; } } class PageAwareAccessibilityProvider extends AccessibilityProvider { private final AccessibilityViewCommand mActionPageForward = new AccessibilityViewCommand ( ) { @ Override public boolean perform ( @ NonNull View view , @ Nullable CommandArguments arguments ) { ViewPager2 viewPager = ( ViewPager2 ) view ; setCurrentItemFromAccessibilityCommand ( viewPager . getCurrentItem ( ) + <NUM_LIT> ) ; return true ; } } ; private final AccessibilityViewCommand mActionPageBackward = new AccessibilityViewCommand ( ) { @ Override public boolean perform ( @ NonNull View view , @ Nullable CommandArguments arguments ) { ViewPager2 viewPager = ( ViewPager2 ) view ; setCurrentItemFromAccessibilityCommand ( viewPager . getCurrentItem ( ) - <NUM_LIT> ) ; return true ; } } ; private RecyclerView . AdapterDataObserver mAdapterDataObserver ; @ Override public void onInitialize ( @ NonNull CompositeOnPageChangeCallback pageChangeEventDispatcher , @ NonNull RecyclerView recyclerView ) { recyclerView . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_NO ) ; mAdapterDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updatePageAccessibilityActions ( ) ; } } ; if ( ViewPager2 . this . getImportantForAccessibility ( ) == View . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewPager2 . this . setImportantForAccessibility ( View . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } } @ Override public boolean handlesGetAccessibilityClassName ( ) { return true ; } @ Override public String onGetAccessibilityClassName ( ) { if ( ! handlesGetAccessibilityClassName ( ) ) { throw new IllegalStateException ( ) ; } return "<STR_LIT>" ; } @ Override public void onRestorePendingState ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onAttachAdapter ( @ Nullable Adapter < ? > newAdapter ) { updatePageAccessibilityActions ( ) ; if ( newAdapter != null ) { newAdapter . registerAdapterDataObserver ( mAdapterDataObserver ) ; } } @ Override public void onDetachAdapter ( @ Nullable Adapter < ? > oldAdapter ) { if ( oldAdapter != null ) { oldAdapter . unregisterAdapterDataObserver ( mAdapterDataObserver ) ; } } @ Override public void onSetOrientation ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onSetNewCurrentItem ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onSetUserInputEnabled ( ) { updatePageAccessibilityActions ( ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { sendAccessibilityEvent ( AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED ) ; } } @ Override public void onSetLayoutDirection ( ) { updatePageAccessibilityActions ( ) ; } @ Override public void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfo info ) { AccessibilityNodeInfoCompat infoCompat = AccessibilityNodeInfoCompat . wrap ( info ) ; addCollectionInfo ( infoCompat ) ; addScrollActions ( infoCompat ) ; } @ Override void onLmInitializeAccessibilityNodeInfoForItem ( @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { addCollectionItemInfo ( host , info ) ; } @ Override public boolean handlesPerformAccessibilityAction ( int action , Bundle arguments ) { return action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD || action == AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ; } @ Override public boolean onPerformAccessibilityAction ( int action , Bundle arguments ) { if ( ! handlesPerformAccessibilityAction ( action , arguments ) ) { throw new IllegalStateException ( ) ; } int nextItem = ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ? getCurrentItem ( ) - <NUM_LIT> : getCurrentItem ( ) + <NUM_LIT> ; setCurrentItemFromAccessibilityCommand ( nextItem ) ; return true ; } @ Override public void onRvInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { event . setSource ( ViewPager2 . this ) ; event . setClassName ( onGetAccessibilityClassName ( ) ) ; } void setCurrentItemFromAccessibilityCommand ( int item ) { if ( isUserInputEnabled ( ) ) { setCurrentItemInternal ( item , true ) ; } } void updatePageAccessibilityActions ( ) { ViewPager2 viewPager = ViewPager2 . this ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageLeft = android . R . id . accessibilityActionPageLeft ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageRight = android . R . id . accessibilityActionPageRight ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageUp = android . R . id . accessibilityActionPageUp ; @ SuppressLint ( "<STR_LIT>" ) final int actionIdPageDown = android . R . id . accessibilityActionPageDown ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageLeft ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageRight ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageUp ) ; ViewCompat . removeAccessibilityAction ( viewPager , actionIdPageDown ) ; if ( getAdapter ( ) == null ) { return ; } int itemCount = getAdapter ( ) . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return ; } if ( ! isUserInputEnabled ( ) ) { return ; } if ( getOrientation ( ) == ORIENTATION_HORIZONTAL ) { boolean isLayoutRtl = isRtl ( ) ; int actionIdPageForward = isLayoutRtl ? actionIdPageLeft : actionIdPageRight ; int actionIdPageBackward = isLayoutRtl ? actionIdPageRight : actionIdPageLeft ; if ( mCurrentItem < itemCount - <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageForward , null ) , null , mActionPageForward ) ; } if ( mCurrentItem > <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageBackward , null ) , null , mActionPageBackward ) ; } } else { if ( mCurrentItem < itemCount - <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageDown , null ) , null , mActionPageForward ) ; } if ( mCurrentItem > <NUM_LIT> ) { ViewCompat . replaceAccessibilityAction ( viewPager , new AccessibilityActionCompat ( actionIdPageUp , null ) , null , mActionPageBackward ) ; } } } private void addCollectionInfo ( AccessibilityNodeInfoCompat infoCompat ) { int rowCount = <NUM_LIT> ; int colCount = <NUM_LIT> ; if ( getAdapter ( ) != null ) { if ( getOrientation ( ) == ORIENTATION_VERTICAL ) { rowCount = getAdapter ( ) . getItemCount ( ) ; colCount = <NUM_LIT> ; } else { colCount = getAdapter ( ) . getItemCount ( ) ; rowCount = <NUM_LIT> ; } } AccessibilityNodeInfoCompat . CollectionInfoCompat collectionInfo = AccessibilityNodeInfoCompat . CollectionInfoCompat . obtain ( rowCount , colCount , false , AccessibilityNodeInfoCompat . CollectionInfoCompat . SELECTION_MODE_NONE ) ; infoCompat . setCollectionInfo ( collectionInfo ) ; } private void addCollectionItemInfo ( View host , AccessibilityNodeInfoCompat infoCompat ) { int rowIndex = ( getOrientation ( ) == ORIENTATION_VERTICAL ) ? mLayoutManager . getPosition ( host ) : <NUM_LIT> ; int colIndex = ( getOrientation ( ) == ORIENTATION_HORIZONTAL ) ? mLayoutManager . getPosition ( host ) : <NUM_LIT> ; AccessibilityNodeInfoCompat . CollectionItemInfoCompat collectionItemInfoCompat = AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( rowIndex , <NUM_LIT> , colIndex , <NUM_LIT> , false , false ) ; infoCompat . setCollectionItemInfo ( collectionItemInfoCompat ) ; } private void addScrollActions ( AccessibilityNodeInfoCompat infoCompat ) { final Adapter < ? > adapter = getAdapter ( ) ; if ( adapter == null ) { return ; } int itemCount = adapter . getItemCount ( ) ; if ( itemCount == <NUM_LIT> || ! isUserInputEnabled ( ) ) { return ; } if ( mCurrentItem > <NUM_LIT> ) { infoCompat . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; } if ( mCurrentItem < itemCount - <NUM_LIT> ) { infoCompat . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; } infoCompat . setScrollable ( true ) ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ; } mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) { mViewPager . snapToPage ( ) ; } return true ; } private void beginFakeVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; final ViewConfiguration configuration = ViewConfiguration . get ( mViewPager . getContext ( ) ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void addFakeMotionEvent ( long time , int action , float x , float y ) { final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , action , x , y , <NUM_LIT> ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( String . format ( Locale . US , "<STR_LIT>" , i , mLayoutManager . getChildCount ( ) ) ) ; } int currPos = mLayoutManager . getPosition ( view ) ; float viewOffset = transformOffset + ( currPos - position ) ; mPageTransformer . transformPage ( view , viewOffset ) ; } } @ Override public void onPageSelected ( int position ) { } @ Override public void onPageScrollStateChanged ( int state ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup { private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ; @ Override public long localToGlobal ( long localId ) { Long globalId = mLocalToGlobalLookup . get ( localId ) ; if ( globalId == null ) { globalId = obtainId ( ) ; mLocalToGlobalLookup . put ( localId , globalId ) ; } return globalId ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollNestedScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollNestedScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) protected int computeVerticalScrollRange ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollRange ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) protected int computeVerticalScrollOffset ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollNestedScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollNestedScrollView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_text_size ) ) ; } ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( "<STR_LIT>" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( "<STR_LIT>" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } } mBackgroundThreadExecutor = sDiffExecutor ; } return new AsyncDifferConfig < > ( mMainThreadExecutor , mBackgroundThreadExecutor , mDiffCallback ) ; } private static final Object sExecutorLock = new Object ( ) ; private static Executor sDiffExecutor = null ; } } </s>
<s> package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( "<STR_LIT>" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( "<STR_LIT>" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( "<STR_LIT>" + mArtists + "<STR_LIT>" + mAlbums + "<STR_LIT>" + mSongs + "<STR_LIT>" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( "<STR_LIT>" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else { registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void addAlbum ( ) { try { new File ( "<STR_LIT>" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( "<STR_LIT>" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = "<STR_LIT>" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , "<STR_LIT>" + albumName + "<STR_LIT>" + artist + "<STR_LIT>" + i + "<STR_LIT>" ) ; File file = new File ( "<STR_LIT>" + albumName + "<STR_LIT>" + artist + "<STR_LIT>" + i + "<STR_LIT>" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + "<STR_LIT>" + getRandomWord ( <NUM_LIT> ) + "<STR_LIT>" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( "<STR_LIT>" , "<STR_LIT>" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ; mBuilder . setLength ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { mBuilder . append ( elements [ mRandom . nextInt ( max ) ] ) ; } char c = mBuilder . charAt ( <NUM_LIT> ) ; c = Character . toUpperCase ( c ) ; mBuilder . setCharAt ( <NUM_LIT> , c ) ; return mBuilder . toString ( ) ; } private String getRandomName ( ) { boolean longfirst = mRandom . nextInt ( <NUM_LIT> ) < <NUM_LIT> ; String first = getRandomWord ( longfirst ? <NUM_LIT> : <NUM_LIT> ) ; String last = getRandomWord ( <NUM_LIT> ) ; switch ( mRandom . nextInt ( <NUM_LIT> ) ) { case <NUM_LIT> : if ( ! last . startsWith ( "<STR_LIT>" ) ) { last = "<STR_LIT>" + last ; } break ; case <NUM_LIT> : last = "<STR_LIT>" + last ; break ; case <NUM_LIT> : last = "<STR_LIT>" + last ; break ; } return first + "<STR_LIT>" + last ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import static androidx . annotation . RestrictTo . Scope . LIBRARY_GROUP_PREFIX ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . core . view . ViewCompat . TYPE_NON_TOUCH ; import static androidx . core . view . ViewCompat . TYPE_TOUCH ; import android . animation . LayoutTransition ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . database . Observable ; import android . graphics . Canvas ; import android . graphics . Matrix ; import android . graphics . PointF ; import android . graphics . Rect ; import android . graphics . RectF ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . hardware . SensorManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . os . SystemClock ; import android . util . AttributeSet ; import android . util . Log ; import android . util . SparseArray ; import android . view . Display ; import android . view . FocusFinder ; import android . view . InputDevice ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityManager ; import android . view . animation . Interpolator ; import android . widget . EdgeEffect ; import android . widget . LinearLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . Px ; import androidx . annotation . RestrictTo ; import androidx . annotation . VisibleForTesting ; import androidx . core . os . TraceCompat ; import androidx . core . view . AccessibilityDelegateCompat ; import androidx . core . view . InputDeviceCompat ; import androidx . core . view . MotionEventCompat ; import androidx . core . view . NestedScrollingChild2 ; import androidx . core . view . NestedScrollingChild3 ; import androidx . core . view . NestedScrollingChildHelper ; import androidx . core . view . ScrollingView ; import androidx . core . view . ViewCompat ; import androidx . core . view . ViewConfigurationCompat ; import androidx . core . view . accessibility . AccessibilityEventCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . customview . poolingcontainer . PoolingContainer ; import androidx . customview . poolingcontainer . PoolingContainerListener ; import androidx . customview . view . AbsSavedState ; import androidx . fluidrecyclerview . R ; import androidx . fluidrecyclerview . widget . RecyclerView . ItemAnimator . ItemHolderInfo ; import org . helixform . fluidrecyclerview . EdgeEffectAdapter ; import org . helixform . fluidrecyclerview . OverScrollerAdapter ; import org . helixform . fluidrecyclerview . VelocityTracker ; import org . helixform . fluidrecyclerview . VelocityTrackerFactory ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . ref . WeakReference ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Set ; public class RecyclerView extends ViewGroup implements ScrollingView , NestedScrollingChild2 , NestedScrollingChild3 { static final String TAG = "<STR_LIT>" ; static boolean sDebugAssertionsEnabled = false ; static boolean sVerboseLoggingEnabled = false ; static final boolean VERBOSE_TRACING = false ; private static final int [ ] NESTED_SCROLLING_ATTRS = { <NUM_LIT> } ; private static final float SCROLL_FRICTION = <NUM_LIT> ; private static final float INFLEXION = <NUM_LIT> ; private static final float DECELERATION_RATE = ( float ) ( Math . log ( <NUM_LIT> ) / Math . log ( <NUM_LIT> ) ) ; private final float mPhysicalCoef ; static final boolean FORCE_INVALIDATE_DISPLAY_LIST = Build . VERSION . SDK_INT == <NUM_LIT> || Build . VERSION . SDK_INT == <NUM_LIT> || Build . VERSION . SDK_INT == <NUM_LIT> ; static final boolean ALLOW_SIZE_IN_UNSPECIFIED_SPEC = Build . VERSION . SDK_INT >= <NUM_LIT> ; static final boolean POST_UPDATES_ON_ANIMATION = Build . VERSION . SDK_INT >= <NUM_LIT> ; static final boolean ALLOW_THREAD_GAP_WORK = Build . VERSION . SDK_INT >= <NUM_LIT> ; private static final boolean FORCE_ABS_FOCUS_SEARCH_DIRECTION = Build . VERSION . SDK_INT <= <NUM_LIT> ; private static final boolean IGNORE_DETACHED_FOCUSED_CHILD = Build . VERSION . SDK_INT <= <NUM_LIT> ; private static final float FLING_DESTRETCH_FACTOR = <NUM_LIT> ; static final boolean DISPATCH_TEMP_DETACH = false ; @ RestrictTo ( LIBRARY_GROUP_PREFIX ) @ IntDef ( { HORIZONTAL , VERTICAL } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface Orientation { } public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; static final int DEFAULT_ORIENTATION = VERTICAL ; public static final int NO_POSITION = - <NUM_LIT> ; public static final long NO_ID = - <NUM_LIT> ; public static final int INVALID_TYPE = - <NUM_LIT> ; public static final int TOUCH_SLOP_DEFAULT = <NUM_LIT> ; public static final int TOUCH_SLOP_PAGING = <NUM_LIT> ; public static final int UNDEFINED_DURATION = Integer . MIN_VALUE ; static final int MAX_SCROLL_DURATION = <NUM_LIT> ; static final String TRACE_SCROLL_TAG = "<STR_LIT>" ; private static final String TRACE_ON_LAYOUT_TAG = "<STR_LIT>" ; private static final String TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG = "<STR_LIT>" ; private static final String TRACE_HANDLE_ADAPTER_UPDATES_TAG = "<STR_LIT>" ; static final String TRACE_BIND_VIEW_TAG = "<STR_LIT>" ; static final String TRACE_PREFETCH_TAG = "<STR_LIT>" ; static final String TRACE_NESTED_PREFETCH_TAG = "<STR_LIT>" ; static final String TRACE_CREATE_VIEW_TAG = "<STR_LIT>" ; private static final Class < ? > [ ] LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE = new Class < ? > [ ] { Context . class , AttributeSet . class , int . class , int . class } ; public static void setDebugAssertionsEnabled ( boolean debugAssertionsEnabled ) { RecyclerView . sDebugAssertionsEnabled = debugAssertionsEnabled ; } public static void setVerboseLoggingEnabled ( boolean verboseLoggingEnabled ) { RecyclerView . sVerboseLoggingEnabled = verboseLoggingEnabled ; } private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver ( ) ; final Recycler mRecycler = new Recycler ( ) ; SavedState mPendingSavedState ; AdapterHelper mAdapterHelper ; ChildHelper mChildHelper ; final ViewInfoStore mViewInfoStore = new ViewInfoStore ( ) ; boolean mClipToPadding ; final Runnable mUpdateChildViewsRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( ! mFirstLayoutComplete || isLayoutRequested ( ) ) { return ; } if ( ! mIsAttached ) { requestLayout ( ) ; return ; } if ( mLayoutSuppressed ) { mLayoutWasDefered = true ; return ; } consumePendingUpdateOperations ( ) ; } } ; final Rect mTempRect = new Rect ( ) ; private final Rect mTempRect2 = new Rect ( ) ; final RectF mTempRectF = new RectF ( ) ; Adapter mAdapter ; @ VisibleForTesting LayoutManager mLayout ; RecyclerListener mRecyclerListener ; final List < RecyclerListener > mRecyclerListeners = new ArrayList < > ( ) ; final ArrayList < ItemDecoration > mItemDecorations = new ArrayList < > ( ) ; private final ArrayList < OnItemTouchListener > mOnItemTouchListeners = new ArrayList < > ( ) ; private OnItemTouchListener mInterceptingOnItemTouchListener ; boolean mIsAttached ; boolean mHasFixedSize ; boolean mEnableFastScroller ; @ VisibleForTesting boolean mFirstLayoutComplete ; private int mInterceptRequestLayoutDepth = <NUM_LIT> ; boolean mLayoutWasDefered ; boolean mLayoutSuppressed ; private boolean mIgnoreMotionEventTillDown ; private int mEatenAccessibilityChangeFlags ; boolean mAdapterUpdateDuringMeasure ; private final AccessibilityManager mAccessibilityManager ; private List < OnChildAttachStateChangeListener > mOnChildAttachStateListeners ; boolean mDataSetHasChangedAfterLayout = false ; boolean mDispatchItemsChangedEvent = false ; private int mLayoutOrScrollCounter = <NUM_LIT> ; private int mDispatchScrollCounter = <NUM_LIT> ; private EdgeEffectAdapter mHorizontalEdgeEffect , mVerticalEdgeEffect ; ItemAnimator mItemAnimator = new DefaultItemAnimator ( ) ; private static final int INVALID_POINTER = - <NUM_LIT> ; public static final int SCROLL_STATE_IDLE = <NUM_LIT> ; public static final int SCROLL_STATE_DRAGGING = <NUM_LIT> ; public static final int SCROLL_STATE_SETTLING = <NUM_LIT> ; static final long FOREVER_NS = Long . MAX_VALUE ; private int mScrollState = SCROLL_STATE_IDLE ; private int mScrollPointerId = INVALID_POINTER ; private VelocityTracker mVelocityTracker ; private int mInitialTouchX ; private int mInitialTouchY ; private int mLastTouchX ; private int mLastTouchY ; private int mTouchSlop ; private OnFlingListener mOnFlingListener ; private final int mMinFlingVelocity ; private final int mMaxFlingVelocity ; private float mScaledHorizontalScrollFactor = Float . MIN_VALUE ; private float mScaledVerticalScrollFactor = Float . MIN_VALUE ; private boolean mPreserveFocusAfterLayout = true ; final ViewFlinger mViewFlinger = new ViewFlinger ( ) ; GapWorker mGapWorker ; GapWorker . LayoutPrefetchRegistryImpl mPrefetchRegistry = ALLOW_THREAD_GAP_WORK ? new GapWorker . LayoutPrefetchRegistryImpl ( ) : null ; final State mState = new State ( ) ; private OnScrollListener mScrollListener ; private List < OnScrollListener > mScrollListeners ; boolean mItemsAddedOrRemoved = false ; boolean mItemsChanged = false ; private ItemAnimator . ItemAnimatorListener mItemAnimatorListener = new ItemAnimatorRestoreListener ( ) ; boolean mPostedAnimatorRunner = false ; RecyclerViewAccessibilityDelegate mAccessibilityDelegate ; private ChildDrawingOrderCallback mChildDrawingOrderCallback ; private final int [ ] mMinMaxLayoutPositions = new int [ <NUM_LIT> ] ; private NestedScrollingChildHelper mScrollingChildHelper ; private final int [ ] mScrollOffset = new int [ <NUM_LIT> ] ; private final int [ ] mNestedOffsets = new int [ <NUM_LIT> ] ; final int [ ] mReusableIntPair = new int [ <NUM_LIT> ] ; @ VisibleForTesting final List < ViewHolder > mPendingAccessibilityImportanceChange = new ArrayList < > ( ) ; private Runnable mItemAnimatorRunner = new Runnable ( ) { @ Override public void run ( ) { if ( mItemAnimator != null ) { mItemAnimator . runPendingAnimations ( ) ; } mPostedAnimatorRunner = false ; } } ; static final Interpolator sQuinticInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { t -= <NUM_LIT> ; return t * t * t * t * t + <NUM_LIT> ; } } ; private boolean mLastAutoMeasureSkippedDueToExact ; private int mLastAutoMeasureNonExactMeasuredWidth = <NUM_LIT> ; private int mLastAutoMeasureNonExactMeasuredHeight = <NUM_LIT> ; private final ViewInfoStore . ProcessCallback mViewInfoProcessCallback = new ViewInfoStore . ProcessCallback ( ) { @ Override public void processDisappeared ( ViewHolder viewHolder , @ NonNull ItemHolderInfo info , @ Nullable ItemHolderInfo postInfo ) { mRecycler . unscrapView ( viewHolder ) ; animateDisappearance ( viewHolder , info , postInfo ) ; } @ Override public void processAppeared ( ViewHolder viewHolder , ItemHolderInfo preInfo , ItemHolderInfo info ) { animateAppearance ( viewHolder , preInfo , info ) ; } @ Override public void processPersistent ( ViewHolder viewHolder , @ NonNull ItemHolderInfo preInfo , @ NonNull ItemHolderInfo postInfo ) { viewHolder . setIsRecyclable ( false ) ; if ( mDataSetHasChangedAfterLayout ) { if ( mItemAnimator . animateChange ( viewHolder , viewHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } else if ( mItemAnimator . animatePersistence ( viewHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } @ Override public void unused ( ViewHolder viewHolder ) { mLayout . removeAndRecycleView ( viewHolder . itemView , mRecycler ) ; } } ; public RecyclerView ( @ NonNull Context context ) { this ( context , null ) ; } public RecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . recyclerViewStyle ) ; } public RecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; setScrollContainer ( true ) ; setFocusableInTouchMode ( true ) ; final ViewConfiguration vc = ViewConfiguration . get ( context ) ; mTouchSlop = vc . getScaledTouchSlop ( ) ; mScaledHorizontalScrollFactor = ViewConfigurationCompat . getScaledHorizontalScrollFactor ( vc , context ) ; mScaledVerticalScrollFactor = ViewConfigurationCompat . getScaledVerticalScrollFactor ( vc , context ) ; mMinFlingVelocity = vc . getScaledMinimumFlingVelocity ( ) ; mMaxFlingVelocity = vc . getScaledMaximumFlingVelocity ( ) ; final float ppi = context . getResources ( ) . getDisplayMetrics ( ) . density * <NUM_LIT> ; mPhysicalCoef = SensorManager . GRAVITY_EARTH * <NUM_LIT> * ppi * <NUM_LIT> ; setWillNotDraw ( getOverScrollMode ( ) == View . OVER_SCROLL_NEVER ) ; mItemAnimator . setListener ( mItemAnimatorListener ) ; initAdapterManager ( ) ; initChildrenHelper ( ) ; initAutofill ( ) ; if ( ViewCompat . getImportantForAccessibility ( this ) == ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewCompat . setImportantForAccessibility ( this , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } mAccessibilityManager = ( AccessibilityManager ) getContext ( ) . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; setAccessibilityDelegateCompat ( new RecyclerViewAccessibilityDelegate ( this ) ) ; TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . RecyclerView , defStyleAttr , <NUM_LIT> ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , R . styleable . RecyclerView , attrs , a , defStyleAttr , <NUM_LIT> ) ; String layoutManagerName = a . getString ( R . styleable . RecyclerView_layoutManager ) ; int descendantFocusability = a . getInt ( R . styleable . RecyclerView_android_descendantFocusability , - <NUM_LIT> ) ; if ( descendantFocusability == - <NUM_LIT> ) { setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; } mClipToPadding = a . getBoolean ( R . styleable . RecyclerView_android_clipToPadding , true ) ; mEnableFastScroller = a . getBoolean ( R . styleable . RecyclerView_fastScrollEnabled , false ) ; if ( mEnableFastScroller ) { StateListDrawable verticalThumbDrawable = ( StateListDrawable ) a . getDrawable ( R . styleable . RecyclerView_fastScrollVerticalThumbDrawable ) ; Drawable verticalTrackDrawable = a . getDrawable ( R . styleable . RecyclerView_fastScrollVerticalTrackDrawable ) ; StateListDrawable horizontalThumbDrawable = ( StateListDrawable ) a . getDrawable ( R . styleable . RecyclerView_fastScrollHorizontalThumbDrawable ) ; Drawable horizontalTrackDrawable = a . getDrawable ( R . styleable . RecyclerView_fastScrollHorizontalTrackDrawable ) ; initFastScroller ( verticalThumbDrawable , verticalTrackDrawable , horizontalThumbDrawable , horizontalTrackDrawable ) ; } a . recycle ( ) ; createLayoutManager ( context , layoutManagerName , attrs , defStyleAttr , <NUM_LIT> ) ; boolean nestedScrollingEnabled = true ; if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { a = context . obtainStyledAttributes ( attrs , NESTED_SCROLLING_ATTRS , defStyleAttr , <NUM_LIT> ) ; ViewCompat . saveAttributeDataForStyleable ( this , context , NESTED_SCROLLING_ATTRS , attrs , a , defStyleAttr , <NUM_LIT> ) ; nestedScrollingEnabled = a . getBoolean ( <NUM_LIT> , true ) ; a . recycle ( ) ; } setNestedScrollingEnabled ( nestedScrollingEnabled ) ; PoolingContainer . setPoolingContainer ( this , true ) ; } String exceptionLabel ( ) { return "<STR_LIT>" + super . toString ( ) + "<STR_LIT>" + mAdapter + "<STR_LIT>" + mLayout + "<STR_LIT>" + getContext ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void initAutofill ( ) { if ( ViewCompat . getImportantForAutofill ( this ) == View . IMPORTANT_FOR_AUTOFILL_AUTO ) { ViewCompat . setImportantForAutofill ( this , View . IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS ) ; } } @ Nullable public RecyclerViewAccessibilityDelegate getCompatAccessibilityDelegate ( ) { return mAccessibilityDelegate ; } public void setAccessibilityDelegateCompat ( @ Nullable RecyclerViewAccessibilityDelegate accessibilityDelegate ) { mAccessibilityDelegate = accessibilityDelegate ; ViewCompat . setAccessibilityDelegate ( this , mAccessibilityDelegate ) ; } @ Override public CharSequence getAccessibilityClassName ( ) { return "<STR_LIT>" ; } private void createLayoutManager ( Context context , String className , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { if ( className != null ) { className = className . trim ( ) ; if ( ! className . isEmpty ( ) ) { className = getFullClassName ( context , className ) ; try { ClassLoader classLoader ; if ( isInEditMode ( ) ) { classLoader = this . getClass ( ) . getClassLoader ( ) ; } else { classLoader = context . getClassLoader ( ) ; } Class < ? extends LayoutManager > layoutManagerClass = Class . forName ( className , false , classLoader ) . asSubclass ( LayoutManager . class ) ; Constructor < ? extends LayoutManager > constructor ; Object [ ] constructorArgs = null ; try { constructor = layoutManagerClass . getConstructor ( LAYOUT_MANAGER_CONSTRUCTOR_SIGNATURE ) ; constructorArgs = new Object [ ] { context , attrs , defStyleAttr , defStyleRes } ; } catch ( NoSuchMethodException e ) { try { constructor = layoutManagerClass . getConstructor ( ) ; } catch ( NoSuchMethodException e1 ) { e1 . initCause ( e ) ; throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e1 ) ; } } constructor . setAccessible ( true ) ; setLayoutManager ( constructor . newInstance ( constructorArgs ) ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( InstantiationException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } catch ( ClassCastException e ) { throw new IllegalStateException ( attrs . getPositionDescription ( ) + "<STR_LIT>" + className , e ) ; } } } } private String getFullClassName ( Context context , String className ) { if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return context . getPackageName ( ) + className ; } if ( className . contains ( "<STR_LIT>" ) ) { return className ; } return RecyclerView . class . getPackage ( ) . getName ( ) + '<STR_LIT>' + className ; } private void initChildrenHelper ( ) { mChildHelper = new ChildHelper ( new ChildHelper . Callback ( ) { @ Override public int getChildCount ( ) { return RecyclerView . this . getChildCount ( ) ; } @ Override public void addView ( View child , int index ) { if ( VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } RecyclerView . this . addView ( child , index ) ; if ( VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } dispatchChildAttached ( child ) ; } @ Override public int indexOfChild ( View view ) { return RecyclerView . this . indexOfChild ( view ) ; } @ Override public void removeViewAt ( int index ) { final View child = RecyclerView . this . getChildAt ( index ) ; if ( child != null ) { dispatchChildDetached ( child ) ; child . clearAnimation ( ) ; } if ( VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } RecyclerView . this . removeViewAt ( index ) ; if ( VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } } @ Override public View getChildAt ( int offset ) { return RecyclerView . this . getChildAt ( offset ) ; } @ Override public void removeAllViews ( ) { final int count = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View child = getChildAt ( i ) ; dispatchChildDetached ( child ) ; child . clearAnimation ( ) ; } RecyclerView . this . removeAllViews ( ) ; } @ Override public ViewHolder getChildViewHolder ( View view ) { return getChildViewHolderInt ( view ) ; } @ Override public void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { if ( ! vh . isTmpDetached ( ) && ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + vh ) ; } vh . clearTmpDetachFlag ( ) ; } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + "<STR_LIT>" + index + exceptionLabel ( ) ) ; } } RecyclerView . this . attachViewToParent ( child , index , layoutParams ) ; } @ Override public void detachViewFromParent ( int offset ) { final View view = getChildAt ( offset ) ; if ( view != null ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; if ( vh != null ) { if ( vh . isTmpDetached ( ) && ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + vh ) ; } vh . addFlags ( ViewHolder . FLAG_TMP_DETACHED ) ; } } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + offset + exceptionLabel ( ) ) ; } } RecyclerView . this . detachViewFromParent ( offset ) ; } @ Override public void onEnteredHiddenState ( View child ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { vh . onEnteredHiddenState ( RecyclerView . this ) ; } } @ Override public void onLeftHiddenState ( View child ) { final ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { vh . onLeftHiddenState ( RecyclerView . this ) ; } } } ) ; } void initAdapterManager ( ) { mAdapterHelper = new AdapterHelper ( new AdapterHelper . Callback ( ) { @ Override public ViewHolder findViewHolder ( int position ) { final ViewHolder vh = findViewHolderForPosition ( position , true ) ; if ( vh == null ) { return null ; } if ( mChildHelper . isHidden ( vh . itemView ) ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } return null ; } return vh ; } @ Override public void offsetPositionsForRemovingInvisible ( int start , int count ) { offsetPositionRecordsForRemove ( start , count , true ) ; mItemsAddedOrRemoved = true ; mState . mDeletedInvisibleItemCountSincePreviousLayout += count ; } @ Override public void offsetPositionsForRemovingLaidOutOrNewView ( int positionStart , int itemCount ) { offsetPositionRecordsForRemove ( positionStart , itemCount , false ) ; mItemsAddedOrRemoved = true ; } @ Override public void markViewHoldersUpdated ( int positionStart , int itemCount , Object payload ) { viewRangeUpdate ( positionStart , itemCount , payload ) ; mItemsChanged = true ; } @ Override public void onDispatchFirstPass ( AdapterHelper . UpdateOp op ) { dispatchUpdate ( op ) ; } void dispatchUpdate ( AdapterHelper . UpdateOp op ) { switch ( op . cmd ) { case AdapterHelper . UpdateOp . ADD : mLayout . onItemsAdded ( RecyclerView . this , op . positionStart , op . itemCount ) ; break ; case AdapterHelper . UpdateOp . REMOVE : mLayout . onItemsRemoved ( RecyclerView . this , op . positionStart , op . itemCount ) ; break ; case AdapterHelper . UpdateOp . UPDATE : mLayout . onItemsUpdated ( RecyclerView . this , op . positionStart , op . itemCount , op . payload ) ; break ; case AdapterHelper . UpdateOp . MOVE : mLayout . onItemsMoved ( RecyclerView . this , op . positionStart , op . itemCount , <NUM_LIT> ) ; break ; } } @ Override public void onDispatchSecondPass ( AdapterHelper . UpdateOp op ) { dispatchUpdate ( op ) ; } @ Override public void offsetPositionsForAdd ( int positionStart , int itemCount ) { offsetPositionRecordsForInsert ( positionStart , itemCount ) ; mItemsAddedOrRemoved = true ; } @ Override public void offsetPositionsForMove ( int from , int to ) { offsetPositionRecordsForMove ( from , to ) ; mItemsAddedOrRemoved = true ; } } ) ; } public void setHasFixedSize ( boolean hasFixedSize ) { mHasFixedSize = hasFixedSize ; } public boolean hasFixedSize ( ) { return mHasFixedSize ; } @ Override public void setClipToPadding ( boolean clipToPadding ) { if ( clipToPadding != mClipToPadding ) { invalidateGlows ( ) ; } mClipToPadding = clipToPadding ; super . setClipToPadding ( clipToPadding ) ; if ( mFirstLayoutComplete ) { requestLayout ( ) ; } } @ Override public boolean getClipToPadding ( ) { return mClipToPadding ; } public void setScrollingTouchSlop ( int slopConstant ) { final ViewConfiguration vc = ViewConfiguration . get ( getContext ( ) ) ; switch ( slopConstant ) { default : Log . w ( TAG , "<STR_LIT>" + slopConstant + "<STR_LIT>" ) ; case TOUCH_SLOP_DEFAULT : mTouchSlop = vc . getScaledTouchSlop ( ) ; break ; case TOUCH_SLOP_PAGING : mTouchSlop = vc . getScaledPagingTouchSlop ( ) ; break ; } } public void swapAdapter ( @ Nullable Adapter adapter , boolean removeAndRecycleExistingViews ) { setLayoutFrozen ( false ) ; setAdapterInternal ( adapter , true , removeAndRecycleExistingViews ) ; processDataSetCompletelyChanged ( true ) ; requestLayout ( ) ; } public void setAdapter ( @ Nullable Adapter adapter ) { setLayoutFrozen ( false ) ; setAdapterInternal ( adapter , false , true ) ; processDataSetCompletelyChanged ( false ) ; requestLayout ( ) ; } void removeAndRecycleViews ( ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } if ( mLayout != null ) { mLayout . removeAndRecycleAllViews ( mRecycler ) ; mLayout . removeAndRecycleScrapInt ( mRecycler ) ; } mRecycler . clear ( ) ; } private void setAdapterInternal ( @ Nullable Adapter < ? > adapter , boolean compatibleWithPrevious , boolean removeAndRecycleViews ) { if ( mAdapter != null ) { mAdapter . unregisterAdapterDataObserver ( mObserver ) ; mAdapter . onDetachedFromRecyclerView ( this ) ; } if ( ! compatibleWithPrevious || removeAndRecycleViews ) { removeAndRecycleViews ( ) ; } mAdapterHelper . reset ( ) ; final Adapter < ? > oldAdapter = mAdapter ; mAdapter = adapter ; if ( adapter != null ) { adapter . registerAdapterDataObserver ( mObserver ) ; adapter . onAttachedToRecyclerView ( this ) ; } if ( mLayout != null ) { mLayout . onAdapterChanged ( oldAdapter , mAdapter ) ; } mRecycler . onAdapterChanged ( oldAdapter , mAdapter , compatibleWithPrevious ) ; mState . mStructureChanged = true ; } @ Nullable public Adapter getAdapter ( ) { return mAdapter ; } @ Deprecated public void setRecyclerListener ( @ Nullable RecyclerListener listener ) { mRecyclerListener = listener ; } public void addRecyclerListener ( @ NonNull RecyclerListener listener ) { checkArgument ( listener != null , "<STR_LIT>" + "<STR_LIT>" ) ; mRecyclerListeners . add ( listener ) ; } public void removeRecyclerListener ( @ NonNull RecyclerListener listener ) { mRecyclerListeners . remove ( listener ) ; } @ Override public int getBaseline ( ) { if ( mLayout != null ) { return mLayout . getBaseline ( ) ; } else { return super . getBaseline ( ) ; } } public void addOnChildAttachStateChangeListener ( @ NonNull OnChildAttachStateChangeListener listener ) { if ( mOnChildAttachStateListeners == null ) { mOnChildAttachStateListeners = new ArrayList < > ( ) ; } mOnChildAttachStateListeners . add ( listener ) ; } public void removeOnChildAttachStateChangeListener ( @ NonNull OnChildAttachStateChangeListener listener ) { if ( mOnChildAttachStateListeners == null ) { return ; } mOnChildAttachStateListeners . remove ( listener ) ; } public void clearOnChildAttachStateChangeListeners ( ) { if ( mOnChildAttachStateListeners != null ) { mOnChildAttachStateListeners . clear ( ) ; } } public void setLayoutManager ( @ Nullable LayoutManager layout ) { if ( layout == mLayout ) { return ; } stopScroll ( ) ; if ( mLayout != null ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } mLayout . removeAndRecycleAllViews ( mRecycler ) ; mLayout . removeAndRecycleScrapInt ( mRecycler ) ; mRecycler . clear ( ) ; if ( mIsAttached ) { mLayout . dispatchDetachedFromWindow ( this , mRecycler ) ; } mLayout . setRecyclerView ( null ) ; mLayout = null ; } else { mRecycler . clear ( ) ; } mChildHelper . removeAllViewsUnfiltered ( ) ; mLayout = layout ; if ( layout != null ) { if ( layout . mRecyclerView != null ) { throw new IllegalArgumentException ( "<STR_LIT>" + layout + "<STR_LIT>" + layout . mRecyclerView . exceptionLabel ( ) ) ; } mLayout . setRecyclerView ( this ) ; if ( mIsAttached ) { mLayout . dispatchAttachedToWindow ( this ) ; } } mRecycler . updateViewCacheSize ( ) ; requestLayout ( ) ; } public void setOnFlingListener ( @ Nullable OnFlingListener onFlingListener ) { mOnFlingListener = onFlingListener ; } @ Nullable public OnFlingListener getOnFlingListener ( ) { return mOnFlingListener ; } @ Override protected Parcelable onSaveInstanceState ( ) { SavedState state = new SavedState ( super . onSaveInstanceState ( ) ) ; if ( mPendingSavedState != null ) { state . copyFrom ( mPendingSavedState ) ; } else if ( mLayout != null ) { state . mLayoutState = mLayout . onSaveInstanceState ( ) ; } else { state . mLayoutState = null ; } return state ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( ! ( state instanceof SavedState ) ) { super . onRestoreInstanceState ( state ) ; return ; } mPendingSavedState = ( SavedState ) state ; super . onRestoreInstanceState ( mPendingSavedState . getSuperState ( ) ) ; requestLayout ( ) ; } @ Override protected void dispatchSaveInstanceState ( SparseArray < Parcelable > container ) { dispatchFreezeSelfOnly ( container ) ; } @ Override protected void dispatchRestoreInstanceState ( SparseArray < Parcelable > container ) { dispatchThawSelfOnly ( container ) ; } private void addAnimatingView ( ViewHolder viewHolder ) { final View view = viewHolder . itemView ; final boolean alreadyParented = view . getParent ( ) == this ; mRecycler . unscrapView ( getChildViewHolder ( view ) ) ; if ( viewHolder . isTmpDetached ( ) ) { mChildHelper . attachViewToParent ( view , - <NUM_LIT> , view . getLayoutParams ( ) , true ) ; } else if ( ! alreadyParented ) { mChildHelper . addView ( view , true ) ; } else { mChildHelper . hide ( view ) ; } } boolean removeAnimatingView ( View view ) { startInterceptRequestLayout ( ) ; final boolean removed = mChildHelper . removeViewIfHidden ( view ) ; if ( removed ) { final ViewHolder viewHolder = getChildViewHolderInt ( view ) ; mRecycler . unscrapView ( viewHolder ) ; mRecycler . recycleViewHolderInternal ( viewHolder ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + view + "<STR_LIT>" + this ) ; } } stopInterceptRequestLayout ( ! removed ) ; return removed ; } @ Nullable public LayoutManager getLayoutManager ( ) { return mLayout ; } @ NonNull public RecycledViewPool getRecycledViewPool ( ) { return mRecycler . getRecycledViewPool ( ) ; } public void setRecycledViewPool ( @ Nullable RecycledViewPool pool ) { mRecycler . setRecycledViewPool ( pool ) ; } public void setViewCacheExtension ( @ Nullable ViewCacheExtension extension ) { mRecycler . setViewCacheExtension ( extension ) ; } public void setItemViewCacheSize ( int size ) { mRecycler . setViewCacheSize ( size ) ; } public int getScrollState ( ) { return mScrollState ; } void setScrollState ( int state ) { if ( state == mScrollState ) { return ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + state + "<STR_LIT>" + mScrollState , new Exception ( ) ) ; } mScrollState = state ; if ( state != SCROLL_STATE_SETTLING ) { stopScrollersInternal ( ) ; } dispatchOnScrollStateChanged ( state ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mItemDecorations . isEmpty ( ) ) { setWillNotDraw ( false ) ; } if ( index < <NUM_LIT> ) { mItemDecorations . add ( decor ) ; } else { mItemDecorations . add ( index , decor ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public void addItemDecoration ( @ NonNull ItemDecoration decor ) { addItemDecoration ( decor , - <NUM_LIT> ) ; } @ NonNull public ItemDecoration getItemDecorationAt ( int index ) { final int size = getItemDecorationCount ( ) ; if ( index < <NUM_LIT> || index >= size ) { throw new IndexOutOfBoundsException ( index + "<STR_LIT>" + size ) ; } return mItemDecorations . get ( index ) ; } public int getItemDecorationCount ( ) { return mItemDecorations . size ( ) ; } public void removeItemDecorationAt ( int index ) { final int size = getItemDecorationCount ( ) ; if ( index < <NUM_LIT> || index >= size ) { throw new IndexOutOfBoundsException ( index + "<STR_LIT>" + size ) ; } removeItemDecoration ( getItemDecorationAt ( index ) ) ; } public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } mItemDecorations . remove ( decor ) ; if ( mItemDecorations . isEmpty ( ) ) { setWillNotDraw ( getOverScrollMode ( ) == View . OVER_SCROLL_NEVER ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public void setChildDrawingOrderCallback ( @ Nullable ChildDrawingOrderCallback childDrawingOrderCallback ) { if ( childDrawingOrderCallback == mChildDrawingOrderCallback ) { return ; } mChildDrawingOrderCallback = childDrawingOrderCallback ; setChildrenDrawingOrderEnabled ( mChildDrawingOrderCallback != null ) ; } @ Deprecated public void setOnScrollListener ( @ Nullable OnScrollListener listener ) { mScrollListener = listener ; } public void addOnScrollListener ( @ NonNull OnScrollListener listener ) { if ( mScrollListeners == null ) { mScrollListeners = new ArrayList < > ( ) ; } mScrollListeners . add ( listener ) ; } public void removeOnScrollListener ( @ NonNull OnScrollListener listener ) { if ( mScrollListeners != null ) { mScrollListeners . remove ( listener ) ; } } public void clearOnScrollListeners ( ) { if ( mScrollListeners != null ) { mScrollListeners . clear ( ) ; } } public void scrollToPosition ( int position ) { if ( mLayoutSuppressed ) { return ; } stopScroll ( ) ; if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } mLayout . scrollToPosition ( position ) ; awakenScrollBars ( ) ; } void jumpToPositionForSmoothScroller ( int position ) { if ( mLayout == null ) { return ; } setScrollState ( SCROLL_STATE_SETTLING ) ; mLayout . scrollToPosition ( position ) ; awakenScrollBars ( ) ; } public void smoothScrollToPosition ( int position ) { if ( mLayoutSuppressed ) { return ; } if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } mLayout . smoothScrollToPosition ( this , mState , position ) ; } @ Override public void scrollTo ( int x , int y ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void scrollBy ( int x , int y ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; if ( canScrollHorizontal || canScrollVertical ) { scrollByInternal ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , null , TYPE_TOUCH ) ; } } public void nestedScrollBy ( int x , int y ) { nestedScrollByInternal ( x , y , null , TYPE_NON_TOUCH ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void nestedScrollByInternal ( int x , int y , @ Nullable MotionEvent motionEvent , int type ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontal ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertical ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } float verticalDisplacement = motionEvent == null ? getHeight ( ) / <NUM_LIT> : motionEvent . getY ( ) ; float horizontalDisplacement = motionEvent == null ? getWidth ( ) / <NUM_LIT> : motionEvent . getX ( ) ; x -= releaseHorizontalGlow ( x , verticalDisplacement ) ; y -= releaseVerticalGlow ( y , horizontalDisplacement ) ; startNestedScroll ( nestedScrollAxis , type ) ; if ( dispatchNestedPreScroll ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , mReusableIntPair , mScrollOffset , type ) ) { x -= mReusableIntPair [ <NUM_LIT> ] ; y -= mReusableIntPair [ <NUM_LIT> ] ; } scrollByInternal ( canScrollHorizontal ? x : <NUM_LIT> , canScrollVertical ? y : <NUM_LIT> , motionEvent , type ) ; if ( mGapWorker != null && ( x != <NUM_LIT> || y != <NUM_LIT> ) ) { mGapWorker . postFromTraversal ( this , x , y ) ; } stopNestedScroll ( type ) ; } void scrollStep ( int dx , int dy , @ Nullable int [ ] consumed ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; TraceCompat . beginSection ( TRACE_SCROLL_TAG ) ; fillRemainingScrollValues ( mState ) ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; if ( dx != <NUM_LIT> ) { consumedX = mLayout . scrollHorizontallyBy ( dx , mRecycler , mState ) ; } if ( dy != <NUM_LIT> ) { consumedY = mLayout . scrollVerticallyBy ( dy , mRecycler , mState ) ; } TraceCompat . endSection ( ) ; repositionShadowingViews ( ) ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; if ( consumed != null ) { consumed [ <NUM_LIT> ] = consumedX ; consumed [ <NUM_LIT> ] = consumedY ; } } void consumePendingUpdateOperations ( ) { if ( ! mFirstLayoutComplete || mDataSetHasChangedAfterLayout ) { TraceCompat . beginSection ( TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; return ; } if ( ! mAdapterHelper . hasPendingUpdates ( ) ) { return ; } if ( mAdapterHelper . hasAnyUpdateTypes ( AdapterHelper . UpdateOp . UPDATE ) && ! mAdapterHelper . hasAnyUpdateTypes ( AdapterHelper . UpdateOp . ADD | AdapterHelper . UpdateOp . REMOVE | AdapterHelper . UpdateOp . MOVE ) ) { TraceCompat . beginSection ( TRACE_HANDLE_ADAPTER_UPDATES_TAG ) ; startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mAdapterHelper . preProcess ( ) ; if ( ! mLayoutWasDefered ) { if ( hasUpdatedView ( ) ) { dispatchLayout ( ) ; } else { mAdapterHelper . consumePostponedUpdates ( ) ; } } stopInterceptRequestLayout ( true ) ; onExitLayoutOrScroll ( ) ; TraceCompat . endSection ( ) ; } else if ( mAdapterHelper . hasPendingUpdates ( ) ) { TraceCompat . beginSection ( TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; } } private boolean hasUpdatedView ( ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder == null || holder . shouldIgnore ( ) ) { continue ; } if ( holder . isUpdated ( ) ) { return true ; } } return false ; } boolean scrollByInternal ( int x , int y , MotionEvent ev , int type ) { int unconsumedX = <NUM_LIT> ; int unconsumedY = <NUM_LIT> ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; consumePendingUpdateOperations ( ) ; if ( mAdapter != null ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; scrollStep ( x , y , mReusableIntPair ) ; consumedX = mReusableIntPair [ <NUM_LIT> ] ; consumedY = mReusableIntPair [ <NUM_LIT> ] ; unconsumedX = x - consumedX ; unconsumedY = y - consumedY ; } if ( ! mItemDecorations . isEmpty ( ) ) { invalidate ( ) ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( consumedX , consumedY , unconsumedX , unconsumedY , mScrollOffset , type , mReusableIntPair ) ; unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; boolean consumedNestedScroll = mReusableIntPair [ <NUM_LIT> ] != <NUM_LIT> || mReusableIntPair [ <NUM_LIT> ] != <NUM_LIT> ; mLastTouchX -= mScrollOffset [ <NUM_LIT> ] ; mLastTouchY -= mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; if ( getOverScrollMode ( ) != View . OVER_SCROLL_NEVER ) { if ( ev != null && ! MotionEventCompat . isFromSource ( ev , InputDevice . SOURCE_MOUSE ) ) { pullGlows ( ev . getX ( ) , unconsumedX , ev . getY ( ) , unconsumedY ) ; } } if ( consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ) { dispatchOnScrolled ( consumedX , consumedY ) ; } if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } return consumedNestedScroll || consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ; } private int releaseHorizontalGlow ( int deltaX , float y ) { if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) mHorizontalEdgeEffect . onPullDistance ( deltaX , true ) ; invalidate ( ) ; return consumed ; } return <NUM_LIT> ; } private int releaseVerticalGlow ( int deltaY , float x ) { if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) mVerticalEdgeEffect . onPullDistance ( deltaY , true ) ; invalidate ( ) ; return consumed ; } return <NUM_LIT> ; } @ Override public int computeHorizontalScrollOffset ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollOffset ( mState ) : <NUM_LIT> ; } @ Override public int computeHorizontalScrollExtent ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollExtent ( mState ) : <NUM_LIT> ; } @ Override public int computeHorizontalScrollRange ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollHorizontally ( ) ? mLayout . computeHorizontalScrollRange ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollOffset ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollOffset ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollExtent ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollExtent ( mState ) : <NUM_LIT> ; } @ Override public int computeVerticalScrollRange ( ) { if ( mLayout == null ) { return <NUM_LIT> ; } return mLayout . canScrollVertically ( ) ? mLayout . computeVerticalScrollRange ( mState ) : <NUM_LIT> ; } void startInterceptRequestLayout ( ) { mInterceptRequestLayoutDepth ++ ; if ( mInterceptRequestLayoutDepth == <NUM_LIT> && ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } } void stopInterceptRequestLayout ( boolean performLayoutChildren ) { if ( mInterceptRequestLayoutDepth < <NUM_LIT> ) { if ( sDebugAssertionsEnabled ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } mInterceptRequestLayoutDepth = <NUM_LIT> ; } if ( ! performLayoutChildren && ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } if ( mInterceptRequestLayoutDepth == <NUM_LIT> ) { if ( performLayoutChildren && mLayoutWasDefered && ! mLayoutSuppressed && mLayout != null && mAdapter != null ) { dispatchLayout ( ) ; } if ( ! mLayoutSuppressed ) { mLayoutWasDefered = false ; } } mInterceptRequestLayoutDepth -- ; } @ Override public final void suppressLayout ( boolean suppress ) { if ( suppress != mLayoutSuppressed ) { assertNotInLayoutOrScroll ( "<STR_LIT>" ) ; if ( ! suppress ) { mLayoutSuppressed = false ; if ( mLayoutWasDefered && mLayout != null && mAdapter != null ) { requestLayout ( ) ; } mLayoutWasDefered = false ; } else { final long now = SystemClock . uptimeMillis ( ) ; MotionEvent cancelEvent = MotionEvent . obtain ( now , now , MotionEvent . ACTION_CANCEL , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; onTouchEvent ( cancelEvent ) ; mLayoutSuppressed = true ; mIgnoreMotionEventTillDown = true ; stopScroll ( ) ; } } } @ Override public final boolean isLayoutSuppressed ( ) { return mLayoutSuppressed ; } @ Deprecated public void setLayoutFrozen ( boolean frozen ) { suppressLayout ( frozen ) ; } @ Deprecated public boolean isLayoutFrozen ( ) { return isLayoutSuppressed ( ) ; } @ Deprecated @ Override public void setLayoutTransition ( LayoutTransition transition ) { if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { if ( transition == null ) { suppressLayout ( false ) ; return ; } else { int layoutTransitionChanging = <NUM_LIT> ; if ( transition . getAnimator ( LayoutTransition . CHANGE_APPEARING ) == null && transition . getAnimator ( LayoutTransition . CHANGE_DISAPPEARING ) == null && transition . getAnimator ( LayoutTransition . APPEARING ) == null && transition . getAnimator ( LayoutTransition . DISAPPEARING ) == null && transition . getAnimator ( layoutTransitionChanging ) == null ) { suppressLayout ( true ) ; return ; } } } if ( transition == null ) { super . setLayoutTransition ( null ) ; } else { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } } public void smoothScrollBy ( @ Px int dx , @ Px int dy ) { smoothScrollBy ( dx , dy , null ) ; } public void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator ) { smoothScrollBy ( dx , dy , interpolator , UNDEFINED_DURATION ) ; } public void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator , int duration ) { smoothScrollBy ( dx , dy , interpolator , duration , false ) ; } void smoothScrollBy ( @ Px int dx , @ Px int dy , @ Nullable Interpolator interpolator , int duration , boolean withNestedScrolling ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } if ( mLayoutSuppressed ) { return ; } if ( ! mLayout . canScrollHorizontally ( ) ) { dx = <NUM_LIT> ; } if ( ! mLayout . canScrollVertically ( ) ) { dy = <NUM_LIT> ; } if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { boolean durationSuggestsAnimation = duration == UNDEFINED_DURATION || duration > <NUM_LIT> ; if ( durationSuggestsAnimation ) { if ( withNestedScrolling ) { int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( dx != <NUM_LIT> ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( dy != <NUM_LIT> ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_NON_TOUCH ) ; } mViewFlinger . smoothScrollBy ( dx , dy , duration , interpolator ) ; } else { scrollBy ( dx , dy ) ; } } } public boolean fling ( int velocityX , int velocityY ) { if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return false ; } if ( mLayoutSuppressed ) { return false ; } final boolean canScrollHorizontal = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertical = mLayout . canScrollVertically ( ) ; if ( ! canScrollHorizontal || Math . abs ( velocityX ) < mMinFlingVelocity ) { velocityX = <NUM_LIT> ; } if ( ! canScrollVertical || Math . abs ( velocityY ) < mMinFlingVelocity ) { velocityY = <NUM_LIT> ; } if ( velocityX == <NUM_LIT> && velocityY == <NUM_LIT> ) { return false ; } int flingX = <NUM_LIT> ; int flingY = <NUM_LIT> ; if ( velocityX != <NUM_LIT> ) { if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { if ( shouldAbsorb ( mHorizontalEdgeEffect , velocityX ) ) { mHorizontalEdgeEffect . onAbsorb ( velocityX ) ; } else { flingX = velocityX ; } velocityX = <NUM_LIT> ; } } if ( velocityY != <NUM_LIT> ) { if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { if ( shouldAbsorb ( mVerticalEdgeEffect , velocityY ) ) { mVerticalEdgeEffect . onAbsorb ( - velocityY ) ; } else { flingY = velocityY ; } velocityY = <NUM_LIT> ; } } if ( flingX != <NUM_LIT> || flingY != <NUM_LIT> ) { flingX = Math . max ( - mMaxFlingVelocity , Math . min ( flingX , mMaxFlingVelocity ) ) ; flingY = Math . max ( - mMaxFlingVelocity , Math . min ( flingY , mMaxFlingVelocity ) ) ; mViewFlinger . fling ( flingX , flingY ) ; } if ( velocityX == <NUM_LIT> && velocityY == <NUM_LIT> ) { return flingX != <NUM_LIT> || flingY != <NUM_LIT> ; } if ( ! dispatchNestedPreFling ( velocityX , velocityY ) ) { final boolean canScroll = canScrollHorizontal || canScrollVertical ; dispatchNestedFling ( velocityX , velocityY , canScroll ) ; if ( mOnFlingListener != null && mOnFlingListener . onFling ( velocityX , velocityY ) ) { return true ; } if ( canScroll ) { int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontal ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertical ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_NON_TOUCH ) ; velocityX = Math . max ( - mMaxFlingVelocity , Math . min ( velocityX , mMaxFlingVelocity ) ) ; velocityY = Math . max ( - mMaxFlingVelocity , Math . min ( velocityY , mMaxFlingVelocity ) ) ; mViewFlinger . fling ( velocityX , velocityY ) ; return true ; } } return false ; } private boolean shouldAbsorb ( @ NonNull EdgeEffectAdapter edgeEffect , int velocity ) { return true ; } int consumeFlingInHorizontalStretch ( int unconsumedX ) { return consumeFlingInStretch ( unconsumedX , mHorizontalEdgeEffect ) ; } int consumeFlingInVerticalStretch ( int unconsumedY ) { return consumeFlingInStretch ( unconsumedY , mVerticalEdgeEffect ) ; } private int consumeFlingInStretch ( int unconsumed , EdgeEffectAdapter edgeEffect ) { if ( unconsumed != <NUM_LIT> && edgeEffect != null && edgeEffect . getDistance ( ) != <NUM_LIT> ) { int consumed = ( int ) edgeEffect . onPullDistance ( unconsumed , true ) ; return unconsumed > <NUM_LIT> ? ( unconsumed - consumed ) : ( unconsumed + consumed ) ; } return unconsumed ; } public void stopScroll ( ) { setScrollState ( SCROLL_STATE_IDLE ) ; stopScrollersInternal ( ) ; } private void stopScrollersInternal ( ) { mViewFlinger . stop ( ) ; if ( mLayout != null ) { mLayout . stopSmoothScroller ( ) ; } } public int getMinFlingVelocity ( ) { return mMinFlingVelocity ; } public int getMaxFlingVelocity ( ) { return mMaxFlingVelocity ; } private void pullGlows ( float x , float overscrollX , float y , float overscrollY ) { boolean invalidate = false ; if ( overscrollX != <NUM_LIT> ) { ensureHorizontalGlow ( ) ; mHorizontalEdgeEffect . onPullDistance ( overscrollX , false ) ; invalidate = true ; } if ( overscrollY != <NUM_LIT> ) { ensureVerticalGlow ( ) ; mVerticalEdgeEffect . onPullDistance ( overscrollY , false ) ; invalidate = true ; } if ( invalidate || overscrollX != <NUM_LIT> || overscrollY != <NUM_LIT> ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } private void releaseGlows ( ) { boolean needsInvalidate = false ; if ( mHorizontalEdgeEffect != null ) { mHorizontalEdgeEffect . onRelease ( ) ; needsInvalidate = mHorizontalEdgeEffect . isFinished ( ) ; } if ( mVerticalEdgeEffect != null ) { mVerticalEdgeEffect . onRelease ( ) ; needsInvalidate |= mVerticalEdgeEffect . isFinished ( ) ; } if ( needsInvalidate ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } void absorbGlows ( int velocityX , int velocityY ) { if ( velocityX != <NUM_LIT> ) { ensureHorizontalGlow ( ) ; if ( mHorizontalEdgeEffect . isFinished ( ) ) { mHorizontalEdgeEffect . onAbsorb ( velocityX ) ; } } if ( velocityY != <NUM_LIT> ) { ensureVerticalGlow ( ) ; if ( mVerticalEdgeEffect . isFinished ( ) ) { mVerticalEdgeEffect . onAbsorb ( velocityY ) ; } } if ( velocityX != <NUM_LIT> || velocityY != <NUM_LIT> ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } void ensureHorizontalGlow ( ) { if ( mHorizontalEdgeEffect != null ) { return ; } mHorizontalEdgeEffect = new EdgeEffectAdapter ( getContext ( ) ) ; mHorizontalEdgeEffect . updateViewportRange ( getWidth ( ) ) ; } void ensureVerticalGlow ( ) { if ( mVerticalEdgeEffect != null ) { return ; } mVerticalEdgeEffect = new EdgeEffectAdapter ( getContext ( ) ) ; mVerticalEdgeEffect . updateViewportRange ( getHeight ( ) ) ; } void invalidateGlows ( ) { mHorizontalEdgeEffect = mVerticalEdgeEffect = null ; } public void setEdgeEffectFactory ( @ NonNull EdgeEffectFactory edgeEffectFactory ) { } @ NonNull public EdgeEffectFactory getEdgeEffectFactory ( ) { return null ; } @ Override public View focusSearch ( View focused , int direction ) { View result = mLayout . onInterceptFocusSearch ( focused , direction ) ; if ( result != null ) { return result ; } final boolean canRunFocusFailure = mAdapter != null && mLayout != null && ! isComputingLayout ( ) && ! mLayoutSuppressed ; final FocusFinder ff = FocusFinder . getInstance ( ) ; if ( canRunFocusFailure && ( direction == View . FOCUS_FORWARD || direction == View . FOCUS_BACKWARD ) ) { boolean needsFocusFailureLayout = false ; if ( mLayout . canScrollVertically ( ) ) { final int absDir = direction == View . FOCUS_FORWARD ? View . FOCUS_DOWN : View . FOCUS_UP ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found == null ; if ( FORCE_ABS_FOCUS_SEARCH_DIRECTION ) { direction = absDir ; } } if ( ! needsFocusFailureLayout && mLayout . canScrollHorizontally ( ) ) { boolean rtl = mLayout . getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; final int absDir = ( direction == View . FOCUS_FORWARD ) ^ rtl ? View . FOCUS_RIGHT : View . FOCUS_LEFT ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found == null ; if ( FORCE_ABS_FOCUS_SEARCH_DIRECTION ) { direction = absDir ; } } if ( needsFocusFailureLayout ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView == null ) { return null ; } startInterceptRequestLayout ( ) ; mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; stopInterceptRequestLayout ( false ) ; } result = ff . findNextFocus ( this , focused , direction ) ; } else { result = ff . findNextFocus ( this , focused , direction ) ; if ( result == null && canRunFocusFailure ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView == null ) { return null ; } startInterceptRequestLayout ( ) ; result = mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; stopInterceptRequestLayout ( false ) ; } } if ( result != null && ! result . hasFocusable ( ) ) { if ( getFocusedChild ( ) == null ) { return super . focusSearch ( focused , direction ) ; } requestChildOnScreen ( result , null ) ; return focused ; } return isPreferredNextFocus ( focused , result , direction ) ? result : super . focusSearch ( focused , direction ) ; } private boolean isPreferredNextFocus ( View focused , View next , int direction ) { if ( next == null || next == this || next == focused ) { return false ; } if ( findContainingItemView ( next ) == null ) { return false ; } if ( focused == null ) { return true ; } if ( findContainingItemView ( focused ) == null ) { return true ; } mTempRect . set ( <NUM_LIT> , <NUM_LIT> , focused . getWidth ( ) , focused . getHeight ( ) ) ; mTempRect2 . set ( <NUM_LIT> , <NUM_LIT> , next . getWidth ( ) , next . getHeight ( ) ) ; offsetDescendantRectToMyCoords ( focused , mTempRect ) ; offsetDescendantRectToMyCoords ( next , mTempRect2 ) ; final int rtl = mLayout . getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ? - <NUM_LIT> : <NUM_LIT> ; int rightness = <NUM_LIT> ; if ( ( mTempRect . left < mTempRect2 . left || mTempRect . right <= mTempRect2 . left ) && mTempRect . right < mTempRect2 . right ) { rightness = <NUM_LIT> ; } else if ( ( mTempRect . right > mTempRect2 . right || mTempRect . left >= mTempRect2 . right ) && mTempRect . left > mTempRect2 . left ) { rightness = - <NUM_LIT> ; } int downness = <NUM_LIT> ; if ( ( mTempRect . top < mTempRect2 . top || mTempRect . bottom <= mTempRect2 . top ) && mTempRect . bottom < mTempRect2 . bottom ) { downness = <NUM_LIT> ; } else if ( ( mTempRect . bottom > mTempRect2 . bottom || mTempRect . top >= mTempRect2 . bottom ) && mTempRect . top > mTempRect2 . top ) { downness = - <NUM_LIT> ; } switch ( direction ) { case View . FOCUS_LEFT : return rightness < <NUM_LIT> ; case View . FOCUS_RIGHT : return rightness > <NUM_LIT> ; case View . FOCUS_UP : return downness < <NUM_LIT> ; case View . FOCUS_DOWN : return downness > <NUM_LIT> ; case View . FOCUS_FORWARD : return downness > <NUM_LIT> || ( downness == <NUM_LIT> && rightness * rtl > <NUM_LIT> ) ; case View . FOCUS_BACKWARD : return downness < <NUM_LIT> || ( downness == <NUM_LIT> && rightness * rtl < <NUM_LIT> ) ; } throw new IllegalArgumentException ( "<STR_LIT>" + direction + exceptionLabel ( ) ) ; } @ Override public void requestChildFocus ( View child , View focused ) { if ( ! mLayout . onRequestChildFocus ( this , mState , child , focused ) && focused != null ) { requestChildOnScreen ( child , focused ) ; } super . requestChildFocus ( child , focused ) ; } private void requestChildOnScreen ( @ NonNull View child , @ Nullable View focused ) { View rectView = ( focused != null ) ? focused : child ; mTempRect . set ( <NUM_LIT> , <NUM_LIT> , rectView . getWidth ( ) , rectView . getHeight ( ) ) ; final ViewGroup . LayoutParams focusedLayoutParams = rectView . getLayoutParams ( ) ; if ( focusedLayoutParams instanceof LayoutParams ) { final LayoutParams lp = ( LayoutParams ) focusedLayoutParams ; if ( ! lp . mInsetsDirty ) { final Rect insets = lp . mDecorInsets ; mTempRect . left -= insets . left ; mTempRect . right += insets . right ; mTempRect . top -= insets . top ; mTempRect . bottom += insets . bottom ; } } if ( focused != null ) { offsetDescendantRectToMyCoords ( focused , mTempRect ) ; offsetRectIntoDescendantCoords ( child , mTempRect ) ; } mLayout . requestChildRectangleOnScreen ( this , child , mTempRect , ! mFirstLayoutComplete , ( focused == null ) ) ; } @ Override public boolean requestChildRectangleOnScreen ( View child , Rect rect , boolean immediate ) { return mLayout . requestChildRectangleOnScreen ( this , child , rect , immediate ) ; } @ Override public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { if ( mLayout == null || ! mLayout . onAddFocusables ( this , views , direction , focusableMode ) ) { super . addFocusables ( views , direction , focusableMode ) ; } } @ Override protected boolean onRequestFocusInDescendants ( int direction , Rect previouslyFocusedRect ) { if ( isComputingLayout ( ) ) { return false ; } return super . onRequestFocusInDescendants ( direction , previouslyFocusedRect ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; mLayoutOrScrollCounter = <NUM_LIT> ; mIsAttached = true ; mFirstLayoutComplete = mFirstLayoutComplete && ! isLayoutRequested ( ) ; mRecycler . onAttachedToWindow ( ) ; if ( mLayout != null ) { mLayout . dispatchAttachedToWindow ( this ) ; } mPostedAnimatorRunner = false ; if ( ALLOW_THREAD_GAP_WORK ) { mGapWorker = GapWorker . sGapWorker . get ( ) ; if ( mGapWorker == null ) { mGapWorker = new GapWorker ( ) ; Display display = ViewCompat . getDisplay ( this ) ; float refreshRate = <NUM_LIT> ; if ( ! isInEditMode ( ) && display != null ) { float displayRefreshRate = display . getRefreshRate ( ) ; if ( displayRefreshRate >= <NUM_LIT> ) { refreshRate = displayRefreshRate ; } } mGapWorker . mFrameIntervalNs = ( long ) ( <NUM_LIT> / refreshRate ) ; GapWorker . sGapWorker . set ( mGapWorker ) ; } mGapWorker . add ( this ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; } stopScroll ( ) ; mIsAttached = false ; if ( mLayout != null ) { mLayout . dispatchDetachedFromWindow ( this , mRecycler ) ; } mPendingAccessibilityImportanceChange . clear ( ) ; removeCallbacks ( mItemAnimatorRunner ) ; mViewInfoStore . onDetach ( ) ; mRecycler . onDetachedFromWindow ( ) ; PoolingContainer . callPoolingContainerOnReleaseForChildren ( this ) ; if ( ALLOW_THREAD_GAP_WORK && mGapWorker != null ) { mGapWorker . remove ( this ) ; mGapWorker = null ; } } @ Override public boolean isAttachedToWindow ( ) { return mIsAttached ; } void assertInLayoutOrScroll ( String message ) { if ( ! isComputingLayout ( ) ) { if ( message == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } throw new IllegalStateException ( message + exceptionLabel ( ) ) ; } } void assertNotInLayoutOrScroll ( String message ) { if ( isComputingLayout ( ) ) { if ( message == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } throw new IllegalStateException ( message ) ; } if ( mDispatchScrollCounter > <NUM_LIT> ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" , new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ) ; } } public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchListeners . add ( listener ) ; } public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchListeners . remove ( listener ) ; if ( mInterceptingOnItemTouchListener == listener ) { mInterceptingOnItemTouchListener = null ; } } private boolean dispatchToOnItemTouchListeners ( MotionEvent e ) { if ( mInterceptingOnItemTouchListener == null ) { if ( e . getAction ( ) == MotionEvent . ACTION_DOWN ) { return false ; } return findInterceptingOnItemTouchListener ( e ) ; } else { mInterceptingOnItemTouchListener . onTouchEvent ( this , e ) ; final int action = e . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingOnItemTouchListener = null ; } return true ; } } private boolean findInterceptingOnItemTouchListener ( MotionEvent e ) { int action = e . getAction ( ) ; final int listenerCount = mOnItemTouchListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { final OnItemTouchListener listener = mOnItemTouchListeners . get ( i ) ; if ( listener . onInterceptTouchEvent ( this , e ) && action != MotionEvent . ACTION_CANCEL ) { mInterceptingOnItemTouchListener = listener ; return true ; } } return false ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent e ) { if ( mLayoutSuppressed ) { return false ; } mInterceptingOnItemTouchListener = null ; if ( findInterceptingOnItemTouchListener ( e ) ) { cancelScroll ( ) ; return true ; } if ( mLayout == null ) { return false ; } final boolean canScrollHorizontally = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertically = mLayout . canScrollVertically ( ) ; if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTrackerFactory . create ( getContext ( ) ) ; } mVelocityTracker . addMovement ( e ) ; final int action = e . getActionMasked ( ) ; final int actionIndex = e . getActionIndex ( ) ; switch ( action ) { case MotionEvent . ACTION_DOWN : if ( mIgnoreMotionEventTillDown ) { mIgnoreMotionEventTillDown = false ; } mScrollPointerId = e . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( ) + <NUM_LIT> ) ; if ( stopGlowAnimations ( e ) || mScrollState == SCROLL_STATE_SETTLING ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; setScrollState ( SCROLL_STATE_DRAGGING ) ; stopNestedScroll ( TYPE_NON_TOUCH ) ; } mNestedOffsets [ <NUM_LIT> ] = mNestedOffsets [ <NUM_LIT> ] = <NUM_LIT> ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontally ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertically ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_TOUCH ) ; break ; case MotionEvent . ACTION_POINTER_DOWN : mScrollPointerId = e . getPointerId ( actionIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( actionIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( actionIndex ) + <NUM_LIT> ) ; break ; case MotionEvent . ACTION_MOVE : { final int index = e . findPointerIndex ( mScrollPointerId ) ; if ( index < <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + mScrollPointerId + "<STR_LIT>" ) ; return false ; } final int x = ( int ) ( e . getX ( index ) + <NUM_LIT> ) ; final int y = ( int ) ( e . getY ( index ) + <NUM_LIT> ) ; if ( mScrollState != SCROLL_STATE_DRAGGING ) { final int dx = x - mInitialTouchX ; final int dy = y - mInitialTouchY ; boolean startScroll = false ; if ( canScrollHorizontally && Math . abs ( dx ) > mTouchSlop ) { mLastTouchX = x ; startScroll = true ; } if ( canScrollVertically && Math . abs ( dy ) > mTouchSlop ) { mLastTouchY = y ; startScroll = true ; } if ( startScroll ) { setScrollState ( SCROLL_STATE_DRAGGING ) ; } } } break ; case MotionEvent . ACTION_POINTER_UP : { onPointerUp ( e ) ; } break ; case MotionEvent . ACTION_UP : { mVelocityTracker . clear ( ) ; stopNestedScroll ( TYPE_TOUCH ) ; } break ; case MotionEvent . ACTION_CANCEL : { cancelScroll ( ) ; } } return mScrollState == SCROLL_STATE_DRAGGING ; } private boolean stopGlowAnimations ( MotionEvent e ) { boolean stopped = false ; if ( mHorizontalEdgeEffect != null && mHorizontalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { stopped = true ; } if ( mVerticalEdgeEffect != null && mVerticalEdgeEffect . getDistance ( ) != <NUM_LIT> ) { stopped = true ; } return stopped ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { final int listenerCount = mOnItemTouchListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { final OnItemTouchListener listener = mOnItemTouchListeners . get ( i ) ; listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ; } super . requestDisallowInterceptTouchEvent ( disallowIntercept ) ; } @ Override public boolean onTouchEvent ( MotionEvent e ) { if ( mLayoutSuppressed || mIgnoreMotionEventTillDown ) { return false ; } if ( dispatchToOnItemTouchListeners ( e ) ) { cancelScroll ( ) ; return true ; } if ( mLayout == null ) { return false ; } final boolean canScrollHorizontally = mLayout . canScrollHorizontally ( ) ; final boolean canScrollVertically = mLayout . canScrollVertically ( ) ; if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTrackerFactory . create ( getContext ( ) ) ; } boolean eventAddedToVelocityTracker = false ; final int action = e . getActionMasked ( ) ; final int actionIndex = e . getActionIndex ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { mNestedOffsets [ <NUM_LIT> ] = mNestedOffsets [ <NUM_LIT> ] = <NUM_LIT> ; } final MotionEvent vtev = MotionEvent . obtain ( e ) ; vtev . offsetLocation ( mNestedOffsets [ <NUM_LIT> ] , mNestedOffsets [ <NUM_LIT> ] ) ; switch ( action ) { case MotionEvent . ACTION_DOWN : { mScrollPointerId = e . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( ) + <NUM_LIT> ) ; int nestedScrollAxis = ViewCompat . SCROLL_AXIS_NONE ; if ( canScrollHorizontally ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_HORIZONTAL ; } if ( canScrollVertically ) { nestedScrollAxis |= ViewCompat . SCROLL_AXIS_VERTICAL ; } startNestedScroll ( nestedScrollAxis , TYPE_TOUCH ) ; } break ; case MotionEvent . ACTION_POINTER_DOWN : { mScrollPointerId = e . getPointerId ( actionIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( actionIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( actionIndex ) + <NUM_LIT> ) ; } break ; case MotionEvent . ACTION_MOVE : { final int index = e . findPointerIndex ( mScrollPointerId ) ; if ( index < <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + mScrollPointerId + "<STR_LIT>" ) ; return false ; } final int x = ( int ) ( e . getX ( index ) + <NUM_LIT> ) ; final int y = ( int ) ( e . getY ( index ) + <NUM_LIT> ) ; int dx = mLastTouchX - x ; int dy = mLastTouchY - y ; if ( mScrollState != SCROLL_STATE_DRAGGING ) { boolean startScroll = false ; if ( canScrollHorizontally ) { if ( dx > <NUM_LIT> ) { dx = Math . max ( <NUM_LIT> , dx - mTouchSlop ) ; } else { dx = Math . min ( <NUM_LIT> , dx + mTouchSlop ) ; } if ( dx != <NUM_LIT> ) { startScroll = true ; } } if ( canScrollVertically ) { if ( dy > <NUM_LIT> ) { dy = Math . max ( <NUM_LIT> , dy - mTouchSlop ) ; } else { dy = Math . min ( <NUM_LIT> , dy + mTouchSlop ) ; } if ( dy != <NUM_LIT> ) { startScroll = true ; } } if ( startScroll ) { setScrollState ( SCROLL_STATE_DRAGGING ) ; } } if ( mScrollState == SCROLL_STATE_DRAGGING ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dx -= releaseHorizontalGlow ( dx , e . getY ( ) ) ; dy -= releaseVerticalGlow ( dy , e . getX ( ) ) ; if ( dispatchNestedPreScroll ( canScrollHorizontally ? dx : <NUM_LIT> , canScrollVertically ? dy : <NUM_LIT> , mReusableIntPair , mScrollOffset , TYPE_TOUCH ) ) { dx -= mReusableIntPair [ <NUM_LIT> ] ; dy -= mReusableIntPair [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; mNestedOffsets [ <NUM_LIT> ] += mScrollOffset [ <NUM_LIT> ] ; getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mLastTouchX = x - mScrollOffset [ <NUM_LIT> ] ; mLastTouchY = y - mScrollOffset [ <NUM_LIT> ] ; if ( scrollByInternal ( canScrollHorizontally ? dx : <NUM_LIT> , canScrollVertically ? dy : <NUM_LIT> , e , TYPE_TOUCH ) ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } if ( mGapWorker != null && ( dx != <NUM_LIT> || dy != <NUM_LIT> ) ) { mGapWorker . postFromTraversal ( this , dx , dy ) ; } } } break ; case MotionEvent . ACTION_POINTER_UP : { onPointerUp ( e ) ; } break ; case MotionEvent . ACTION_UP : { mVelocityTracker . addMovement ( vtev ) ; eventAddedToVelocityTracker = true ; mVelocityTracker . computeCurrentVelocity ( <NUM_LIT> , mMaxFlingVelocity ) ; final float xvel = canScrollHorizontally ? - mVelocityTracker . getXVelocity ( mScrollPointerId ) : <NUM_LIT> ; final float yvel = canScrollVertically ? - mVelocityTracker . getYVelocity ( mScrollPointerId ) : <NUM_LIT> ; if ( ! ( ( xvel != <NUM_LIT> || yvel != <NUM_LIT> ) && fling ( ( int ) xvel , ( int ) yvel ) ) ) { setScrollState ( SCROLL_STATE_IDLE ) ; } resetScroll ( ) ; } break ; case MotionEvent . ACTION_CANCEL : { cancelScroll ( ) ; } break ; } if ( ! eventAddedToVelocityTracker ) { mVelocityTracker . addMovement ( vtev ) ; } vtev . recycle ( ) ; return true ; } private void resetScroll ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } stopNestedScroll ( TYPE_TOUCH ) ; releaseGlows ( ) ; } private void cancelScroll ( ) { resetScroll ( ) ; setScrollState ( SCROLL_STATE_IDLE ) ; } private void onPointerUp ( MotionEvent e ) { final int actionIndex = e . getActionIndex ( ) ; if ( e . getPointerId ( actionIndex ) == mScrollPointerId ) { final int newIndex = actionIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mScrollPointerId = e . getPointerId ( newIndex ) ; mInitialTouchX = mLastTouchX = ( int ) ( e . getX ( newIndex ) + <NUM_LIT> ) ; mInitialTouchY = mLastTouchY = ( int ) ( e . getY ( newIndex ) + <NUM_LIT> ) ; } } @ Override public boolean onGenericMotionEvent ( MotionEvent event ) { if ( mLayout == null ) { return false ; } if ( mLayoutSuppressed ) { return false ; } if ( event . getAction ( ) == MotionEvent . ACTION_SCROLL ) { final float vScroll , hScroll ; if ( ( event . getSource ( ) & InputDeviceCompat . SOURCE_CLASS_POINTER ) != <NUM_LIT> ) { if ( mLayout . canScrollVertically ( ) ) { vScroll = - event . getAxisValue ( MotionEvent . AXIS_VSCROLL ) ; } else { vScroll = <NUM_LIT> ; } if ( mLayout . canScrollHorizontally ( ) ) { hScroll = event . getAxisValue ( MotionEvent . AXIS_HSCROLL ) ; } else { hScroll = <NUM_LIT> ; } } else if ( ( event . getSource ( ) & InputDeviceCompat . SOURCE_ROTARY_ENCODER ) != <NUM_LIT> ) { final float axisScroll = event . getAxisValue ( MotionEventCompat . AXIS_SCROLL ) ; if ( mLayout . canScrollVertically ( ) ) { vScroll = - axisScroll ; hScroll = <NUM_LIT> ; } else if ( mLayout . canScrollHorizontally ( ) ) { vScroll = <NUM_LIT> ; hScroll = axisScroll ; } else { vScroll = <NUM_LIT> ; hScroll = <NUM_LIT> ; } } else { vScroll = <NUM_LIT> ; hScroll = <NUM_LIT> ; } if ( vScroll != <NUM_LIT> || hScroll != <NUM_LIT> ) { nestedScrollByInternal ( ( int ) ( hScroll * mScaledHorizontalScrollFactor ) , ( int ) ( vScroll * mScaledVerticalScrollFactor ) , event , TYPE_NON_TOUCH ) ; } } return false ; } @ Override protected void onMeasure ( int widthSpec , int heightSpec ) { if ( mLayout == null ) { defaultOnMeasure ( widthSpec , heightSpec ) ; return ; } if ( mLayout . isAutoMeasureEnabled ( ) ) { final int widthMode = MeasureSpec . getMode ( widthSpec ) ; final int heightMode = MeasureSpec . getMode ( heightSpec ) ; mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; mLastAutoMeasureSkippedDueToExact = widthMode == MeasureSpec . EXACTLY && heightMode == MeasureSpec . EXACTLY ; if ( mLastAutoMeasureSkippedDueToExact || mAdapter == null ) { return ; } if ( mState . mLayoutStep == State . STEP_START ) { dispatchLayoutStep1 ( ) ; } mLayout . setMeasureSpecs ( widthSpec , heightSpec ) ; mState . mIsMeasuring = true ; dispatchLayoutStep2 ( ) ; mLayout . setMeasuredDimensionFromChildren ( widthSpec , heightSpec ) ; if ( mLayout . shouldMeasureTwice ( ) ) { mLayout . setMeasureSpecs ( MeasureSpec . makeMeasureSpec ( getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ) ; mState . mIsMeasuring = true ; dispatchLayoutStep2 ( ) ; mLayout . setMeasuredDimensionFromChildren ( widthSpec , heightSpec ) ; } mLastAutoMeasureNonExactMeasuredWidth = getMeasuredWidth ( ) ; mLastAutoMeasureNonExactMeasuredHeight = getMeasuredHeight ( ) ; } else { if ( mHasFixedSize ) { mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; return ; } if ( mAdapterUpdateDuringMeasure ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; processAdapterUpdatesAndSetAnimationFlags ( ) ; onExitLayoutOrScroll ( ) ; if ( mState . mRunPredictiveAnimations ) { mState . mInPreLayout = true ; } else { mAdapterHelper . consumeUpdatesInOnePass ( ) ; mState . mInPreLayout = false ; } mAdapterUpdateDuringMeasure = false ; stopInterceptRequestLayout ( false ) ; } else if ( mState . mRunPredictiveAnimations ) { setMeasuredDimension ( getMeasuredWidth ( ) , getMeasuredHeight ( ) ) ; return ; } if ( mAdapter != null ) { mState . mItemCount = mAdapter . getItemCount ( ) ; } else { mState . mItemCount = <NUM_LIT> ; } startInterceptRequestLayout ( ) ; mLayout . onMeasure ( mRecycler , mState , widthSpec , heightSpec ) ; stopInterceptRequestLayout ( false ) ; mState . mInPreLayout = false ; } } void defaultOnMeasure ( int widthSpec , int heightSpec ) { final int width = LayoutManager . chooseSize ( widthSpec , getPaddingLeft ( ) + getPaddingRight ( ) , ViewCompat . getMinimumWidth ( this ) ) ; final int height = LayoutManager . chooseSize ( heightSpec , getPaddingTop ( ) + getPaddingBottom ( ) , ViewCompat . getMinimumHeight ( this ) ) ; setMeasuredDimension ( width , height ) ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( w != oldw || h != oldh ) { invalidateGlows ( ) ; } } public void setItemAnimator ( @ Nullable ItemAnimator animator ) { if ( mItemAnimator != null ) { mItemAnimator . endAnimations ( ) ; mItemAnimator . setListener ( null ) ; } mItemAnimator = animator ; if ( mItemAnimator != null ) { mItemAnimator . setListener ( mItemAnimatorListener ) ; } } void onEnterLayoutOrScroll ( ) { mLayoutOrScrollCounter ++ ; } void onExitLayoutOrScroll ( ) { onExitLayoutOrScroll ( true ) ; } void onExitLayoutOrScroll ( boolean enableChangeEvents ) { mLayoutOrScrollCounter -- ; if ( mLayoutOrScrollCounter < <NUM_LIT> ) { if ( sDebugAssertionsEnabled && mLayoutOrScrollCounter < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } mLayoutOrScrollCounter = <NUM_LIT> ; if ( enableChangeEvents ) { dispatchContentChangedIfNecessary ( ) ; dispatchPendingImportantForAccessibilityChanges ( ) ; } } } boolean isAccessibilityEnabled ( ) { return mAccessibilityManager != null && mAccessibilityManager . isEnabled ( ) ; } private void dispatchContentChangedIfNecessary ( ) { final int flags = mEatenAccessibilityChangeFlags ; mEatenAccessibilityChangeFlags = <NUM_LIT> ; if ( flags != <NUM_LIT> && isAccessibilityEnabled ( ) ) { final AccessibilityEvent event = AccessibilityEvent . obtain ( ) ; event . setEventType ( AccessibilityEvent . TYPE_WINDOW_CONTENT_CHANGED ) ; AccessibilityEventCompat . setContentChangeTypes ( event , flags ) ; sendAccessibilityEventUnchecked ( event ) ; } } public boolean isComputingLayout ( ) { return mLayoutOrScrollCounter > <NUM_LIT> ; } boolean shouldDeferAccessibilityEvent ( AccessibilityEvent event ) { if ( isComputingLayout ( ) ) { int type = <NUM_LIT> ; if ( event != null ) { type = AccessibilityEventCompat . getContentChangeTypes ( event ) ; } if ( type == <NUM_LIT> ) { type = AccessibilityEventCompat . CONTENT_CHANGE_TYPE_UNDEFINED ; } mEatenAccessibilityChangeFlags |= type ; return true ; } return false ; } @ Override public void sendAccessibilityEventUnchecked ( AccessibilityEvent event ) { if ( shouldDeferAccessibilityEvent ( event ) ) { return ; } super . sendAccessibilityEventUnchecked ( event ) ; } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { onPopulateAccessibilityEvent ( event ) ; return true ; } @ Nullable public ItemAnimator getItemAnimator ( ) { return mItemAnimator ; } void postAnimationRunner ( ) { if ( ! mPostedAnimatorRunner && mIsAttached ) { ViewCompat . postOnAnimation ( this , mItemAnimatorRunner ) ; mPostedAnimatorRunner = true ; } } private boolean predictiveItemAnimationsEnabled ( ) { return ( mItemAnimator != null && mLayout . supportsPredictiveItemAnimations ( ) ) ; } private void processAdapterUpdatesAndSetAnimationFlags ( ) { if ( mDataSetHasChangedAfterLayout ) { mAdapterHelper . reset ( ) ; if ( mDispatchItemsChangedEvent ) { mLayout . onItemsChanged ( this ) ; } } if ( predictiveItemAnimationsEnabled ( ) ) { mAdapterHelper . preProcess ( ) ; } else { mAdapterHelper . consumeUpdatesInOnePass ( ) ; } boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged ; mState . mRunSimpleAnimations = mFirstLayoutComplete && mItemAnimator != null && ( mDataSetHasChangedAfterLayout || animationTypeSupported || mLayout . mRequestedSimpleAnimations ) && ( ! mDataSetHasChangedAfterLayout || mAdapter . hasStableIds ( ) ) ; mState . mRunPredictiveAnimations = mState . mRunSimpleAnimations && animationTypeSupported && ! mDataSetHasChangedAfterLayout && predictiveItemAnimationsEnabled ( ) ; } void dispatchLayout ( ) { if ( mAdapter == null ) { Log . w ( TAG , "<STR_LIT>" ) ; return ; } if ( mLayout == null ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } mState . mIsMeasuring = false ; boolean needsRemeasureDueToExactSkip = mLastAutoMeasureSkippedDueToExact && ( mLastAutoMeasureNonExactMeasuredWidth != getWidth ( ) || mLastAutoMeasureNonExactMeasuredHeight != getHeight ( ) ) ; mLastAutoMeasureNonExactMeasuredWidth = <NUM_LIT> ; mLastAutoMeasureNonExactMeasuredHeight = <NUM_LIT> ; mLastAutoMeasureSkippedDueToExact = false ; if ( mState . mLayoutStep == State . STEP_START ) { dispatchLayoutStep1 ( ) ; mLayout . setExactMeasureSpecsFrom ( this ) ; dispatchLayoutStep2 ( ) ; } else if ( mAdapterHelper . hasUpdates ( ) || needsRemeasureDueToExactSkip || mLayout . getWidth ( ) != getWidth ( ) || mLayout . getHeight ( ) != getHeight ( ) ) { mLayout . setExactMeasureSpecsFrom ( this ) ; dispatchLayoutStep2 ( ) ; } else { mLayout . setExactMeasureSpecsFrom ( this ) ; } dispatchLayoutStep3 ( ) ; } private void saveFocusInfo ( ) { View child = null ; if ( mPreserveFocusAfterLayout && hasFocus ( ) && mAdapter != null ) { child = getFocusedChild ( ) ; } final ViewHolder focusedVh = child == null ? null : findContainingViewHolder ( child ) ; if ( focusedVh == null ) { resetFocusInfo ( ) ; } else { mState . mFocusedItemId = mAdapter . hasStableIds ( ) ? focusedVh . getItemId ( ) : NO_ID ; mState . mFocusedItemPosition = mDataSetHasChangedAfterLayout ? NO_POSITION : ( focusedVh . isRemoved ( ) ? focusedVh . mOldPosition : focusedVh . getAbsoluteAdapterPosition ( ) ) ; mState . mFocusedSubChildId = getDeepestFocusedViewWithId ( focusedVh . itemView ) ; } } private void resetFocusInfo ( ) { mState . mFocusedItemId = NO_ID ; mState . mFocusedItemPosition = NO_POSITION ; mState . mFocusedSubChildId = View . NO_ID ; } @ Nullable private View findNextViewToFocus ( ) { int startFocusSearchIndex = mState . mFocusedItemPosition != - <NUM_LIT> ? mState . mFocusedItemPosition : <NUM_LIT> ; ViewHolder nextFocus ; final int itemCount = mState . getItemCount ( ) ; for ( int i = startFocusSearchIndex ; i < itemCount ; i ++ ) { nextFocus = findViewHolderForAdapterPosition ( i ) ; if ( nextFocus == null ) { break ; } if ( nextFocus . itemView . hasFocusable ( ) ) { return nextFocus . itemView ; } } final int limit = Math . min ( itemCount , startFocusSearchIndex ) ; for ( int i = limit - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { nextFocus = findViewHolderForAdapterPosition ( i ) ; if ( nextFocus == null ) { return null ; } if ( nextFocus . itemView . hasFocusable ( ) ) { return nextFocus . itemView ; } } return null ; } private void recoverFocusFromState ( ) { if ( ! mPreserveFocusAfterLayout || mAdapter == null || ! hasFocus ( ) || getDescendantFocusability ( ) == FOCUS_BLOCK_DESCENDANTS || ( getDescendantFocusability ( ) == FOCUS_BEFORE_DESCENDANTS && isFocused ( ) ) ) { return ; } if ( ! isFocused ( ) ) { final View focusedChild = getFocusedChild ( ) ; if ( IGNORE_DETACHED_FOCUSED_CHILD && ( focusedChild . getParent ( ) == null || ! focusedChild . hasFocus ( ) ) ) { if ( mChildHelper . getChildCount ( ) == <NUM_LIT> ) { requestFocus ( ) ; return ; } } else if ( ! mChildHelper . isHidden ( focusedChild ) ) { return ; } } ViewHolder focusTarget = null ; if ( mState . mFocusedItemId != NO_ID && mAdapter . hasStableIds ( ) ) { focusTarget = findViewHolderForItemId ( mState . mFocusedItemId ) ; } View viewToFocus = null ; if ( focusTarget == null || mChildHelper . isHidden ( focusTarget . itemView ) || ! focusTarget . itemView . hasFocusable ( ) ) { if ( mChildHelper . getChildCount ( ) > <NUM_LIT> ) { viewToFocus = findNextViewToFocus ( ) ; } } else { viewToFocus = focusTarget . itemView ; } if ( viewToFocus != null ) { if ( mState . mFocusedSubChildId != NO_ID ) { View child = viewToFocus . findViewById ( mState . mFocusedSubChildId ) ; if ( child != null && child . isFocusable ( ) ) { viewToFocus = child ; } } viewToFocus . requestFocus ( ) ; } } private int getDeepestFocusedViewWithId ( View view ) { int lastKnownId = view . getId ( ) ; while ( ! view . isFocused ( ) && view instanceof ViewGroup && view . hasFocus ( ) ) { view = ( ( ViewGroup ) view ) . getFocusedChild ( ) ; final int id = view . getId ( ) ; if ( id != View . NO_ID ) { lastKnownId = view . getId ( ) ; } } return lastKnownId ; } final void fillRemainingScrollValues ( State state ) { if ( getScrollState ( ) == SCROLL_STATE_SETTLING ) { final OverScrollerAdapter scroller = mViewFlinger . mOverScroller ; state . mRemainingScrollHorizontal = scroller . getFinalX ( ) - scroller . getCurrX ( ) ; state . mRemainingScrollVertical = scroller . getFinalY ( ) - scroller . getCurrY ( ) ; } else { state . mRemainingScrollHorizontal = <NUM_LIT> ; state . mRemainingScrollVertical = <NUM_LIT> ; } } private void dispatchLayoutStep1 ( ) { mState . assertLayoutStep ( State . STEP_START ) ; fillRemainingScrollValues ( mState ) ; mState . mIsMeasuring = false ; startInterceptRequestLayout ( ) ; mViewInfoStore . clear ( ) ; onEnterLayoutOrScroll ( ) ; processAdapterUpdatesAndSetAnimationFlags ( ) ; saveFocusInfo ( ) ; mState . mTrackOldChangeHolders = mState . mRunSimpleAnimations && mItemsChanged ; mItemsAddedOrRemoved = mItemsChanged = false ; mState . mInPreLayout = mState . mRunPredictiveAnimations ; mState . mItemCount = mAdapter . getItemCount ( ) ; findMinMaxChildLayoutPositions ( mMinMaxLayoutPositions ) ; if ( mState . mRunSimpleAnimations ) { int count = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) || ( holder . isInvalid ( ) && ! mAdapter . hasStableIds ( ) ) ) { continue ; } final ItemHolderInfo animationInfo = mItemAnimator . recordPreLayoutInformation ( mState , holder , ItemAnimator . buildAdapterChangeFlagsForAnimations ( holder ) , holder . getUnmodifiedPayloads ( ) ) ; mViewInfoStore . addToPreLayout ( holder , animationInfo ) ; if ( mState . mTrackOldChangeHolders && holder . isUpdated ( ) && ! holder . isRemoved ( ) && ! holder . shouldIgnore ( ) && ! holder . isInvalid ( ) ) { long key = getChangedHolderKey ( holder ) ; mViewInfoStore . addToOldChangeHolders ( key , holder ) ; } } } if ( mState . mRunPredictiveAnimations ) { saveOldPositions ( ) ; final boolean didStructureChange = mState . mStructureChanged ; mState . mStructureChanged = false ; mLayout . onLayoutChildren ( mRecycler , mState ) ; mState . mStructureChanged = didStructureChange ; for ( int i = <NUM_LIT> ; i < mChildHelper . getChildCount ( ) ; ++ i ) { final View child = mChildHelper . getChildAt ( i ) ; final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; if ( viewHolder . shouldIgnore ( ) ) { continue ; } if ( ! mViewInfoStore . isInPreLayout ( viewHolder ) ) { int flags = ItemAnimator . buildAdapterChangeFlagsForAnimations ( viewHolder ) ; boolean wasHidden = viewHolder . hasAnyOfTheFlags ( ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( ! wasHidden ) { flags |= ItemAnimator . FLAG_APPEARED_IN_PRE_LAYOUT ; } final ItemHolderInfo animationInfo = mItemAnimator . recordPreLayoutInformation ( mState , viewHolder , flags , viewHolder . getUnmodifiedPayloads ( ) ) ; if ( wasHidden ) { recordAnimationInfoIfBouncedHiddenView ( viewHolder , animationInfo ) ; } else { mViewInfoStore . addToAppearedInPreLayoutHolders ( viewHolder , animationInfo ) ; } } } clearOldPositions ( ) ; } else { clearOldPositions ( ) ; } onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; mState . mLayoutStep = State . STEP_LAYOUT ; } private void dispatchLayoutStep2 ( ) { startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mState . assertLayoutStep ( State . STEP_LAYOUT | State . STEP_ANIMATIONS ) ; mAdapterHelper . consumeUpdatesInOnePass ( ) ; mState . mItemCount = mAdapter . getItemCount ( ) ; mState . mDeletedInvisibleItemCountSincePreviousLayout = <NUM_LIT> ; if ( mPendingSavedState != null && mAdapter . canRestoreState ( ) ) { if ( mPendingSavedState . mLayoutState != null ) { mLayout . onRestoreInstanceState ( mPendingSavedState . mLayoutState ) ; } mPendingSavedState = null ; } mState . mInPreLayout = false ; mLayout . onLayoutChildren ( mRecycler , mState ) ; mState . mStructureChanged = false ; mState . mRunSimpleAnimations = mState . mRunSimpleAnimations && mItemAnimator != null ; mState . mLayoutStep = State . STEP_ANIMATIONS ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; } private void dispatchLayoutStep3 ( ) { mState . assertLayoutStep ( State . STEP_ANIMATIONS ) ; startInterceptRequestLayout ( ) ; onEnterLayoutOrScroll ( ) ; mState . mLayoutStep = State . STEP_START ; if ( mState . mRunSimpleAnimations ) { for ( int i = mChildHelper . getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) ) { continue ; } long key = getChangedHolderKey ( holder ) ; final ItemHolderInfo animationInfo = mItemAnimator . recordPostLayoutInformation ( mState , holder ) ; ViewHolder oldChangeViewHolder = mViewInfoStore . getFromOldChangeHolders ( key ) ; if ( oldChangeViewHolder != null && ! oldChangeViewHolder . shouldIgnore ( ) ) { final boolean oldDisappearing = mViewInfoStore . isDisappearing ( oldChangeViewHolder ) ; final boolean newDisappearing = mViewInfoStore . isDisappearing ( holder ) ; if ( oldDisappearing && oldChangeViewHolder == holder ) { mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; } else { final ItemHolderInfo preInfo = mViewInfoStore . popFromPreLayout ( oldChangeViewHolder ) ; mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; ItemHolderInfo postInfo = mViewInfoStore . popFromPostLayout ( holder ) ; if ( preInfo == null ) { handleMissingPreInfoForChangeError ( key , holder , oldChangeViewHolder ) ; } else { animateChange ( oldChangeViewHolder , holder , preInfo , postInfo , oldDisappearing , newDisappearing ) ; } } } else { mViewInfoStore . addToPostLayout ( holder , animationInfo ) ; } } mViewInfoStore . process ( mViewInfoProcessCallback ) ; } mLayout . removeAndRecycleScrapInt ( mRecycler ) ; mState . mPreviousLayoutItemCount = mState . mItemCount ; mDataSetHasChangedAfterLayout = false ; mDispatchItemsChangedEvent = false ; mState . mRunSimpleAnimations = false ; mState . mRunPredictiveAnimations = false ; mLayout . mRequestedSimpleAnimations = false ; if ( mRecycler . mChangedScrap != null ) { mRecycler . mChangedScrap . clear ( ) ; } if ( mLayout . mPrefetchMaxObservedInInitialPrefetch ) { mLayout . mPrefetchMaxCountObserved = <NUM_LIT> ; mLayout . mPrefetchMaxObservedInInitialPrefetch = false ; mRecycler . updateViewCacheSize ( ) ; } mLayout . onLayoutCompleted ( mState ) ; onExitLayoutOrScroll ( ) ; stopInterceptRequestLayout ( false ) ; mViewInfoStore . clear ( ) ; if ( didChildRangeChange ( mMinMaxLayoutPositions [ <NUM_LIT> ] , mMinMaxLayoutPositions [ <NUM_LIT> ] ) ) { dispatchOnScrolled ( <NUM_LIT> , <NUM_LIT> ) ; } recoverFocusFromState ( ) ; resetFocusInfo ( ) ; } private void handleMissingPreInfoForChangeError ( long key , ViewHolder holder , ViewHolder oldChangeViewHolder ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mChildHelper . getChildAt ( i ) ; ViewHolder other = getChildViewHolderInt ( view ) ; if ( other == holder ) { continue ; } final long otherKey = getChangedHolderKey ( other ) ; if ( otherKey == key ) { if ( mAdapter != null && mAdapter . hasStableIds ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + other + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } else { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + other + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } } } Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" + oldChangeViewHolder + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } void recordAnimationInfoIfBouncedHiddenView ( ViewHolder viewHolder , ItemHolderInfo animationInfo ) { viewHolder . setFlags ( <NUM_LIT> , ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( mState . mTrackOldChangeHolders && viewHolder . isUpdated ( ) && ! viewHolder . isRemoved ( ) && ! viewHolder . shouldIgnore ( ) ) { long key = getChangedHolderKey ( viewHolder ) ; mViewInfoStore . addToOldChangeHolders ( key , viewHolder ) ; } mViewInfoStore . addToPreLayout ( viewHolder , animationInfo ) ; } private void findMinMaxChildLayoutPositions ( int [ ] into ) { final int count = mChildHelper . getChildCount ( ) ; if ( count == <NUM_LIT> ) { into [ <NUM_LIT> ] = NO_POSITION ; into [ <NUM_LIT> ] = NO_POSITION ; return ; } int minPositionPreLayout = Integer . MAX_VALUE ; int maxPositionPreLayout = Integer . MIN_VALUE ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getChildAt ( i ) ) ; if ( holder . shouldIgnore ( ) ) { continue ; } final int pos = holder . getLayoutPosition ( ) ; if ( pos < minPositionPreLayout ) { minPositionPreLayout = pos ; } if ( pos > maxPositionPreLayout ) { maxPositionPreLayout = pos ; } } into [ <NUM_LIT> ] = minPositionPreLayout ; into [ <NUM_LIT> ] = maxPositionPreLayout ; } private boolean didChildRangeChange ( int minPositionPreLayout , int maxPositionPreLayout ) { findMinMaxChildLayoutPositions ( mMinMaxLayoutPositions ) ; return mMinMaxLayoutPositions [ <NUM_LIT> ] != minPositionPreLayout || mMinMaxLayoutPositions [ <NUM_LIT> ] != maxPositionPreLayout ; } @ Override protected void removeDetachedView ( View child , boolean animate ) { ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh != null ) { if ( vh . isTmpDetached ( ) ) { vh . clearTmpDetachFlag ( ) ; } else if ( ! vh . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } } else { if ( sDebugAssertionsEnabled ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + exceptionLabel ( ) ) ; } } child . clearAnimation ( ) ; dispatchChildDetached ( child ) ; super . removeDetachedView ( child , animate ) ; } long getChangedHolderKey ( ViewHolder holder ) { return mAdapter . hasStableIds ( ) ? holder . getItemId ( ) : holder . mPosition ; } void animateAppearance ( @ NonNull ViewHolder itemHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { itemHolder . setIsRecyclable ( false ) ; if ( mItemAnimator . animateAppearance ( itemHolder , preLayoutInfo , postLayoutInfo ) ) { postAnimationRunner ( ) ; } } void animateDisappearance ( @ NonNull ViewHolder holder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { addAnimatingView ( holder ) ; holder . setIsRecyclable ( false ) ; if ( mItemAnimator . animateDisappearance ( holder , preLayoutInfo , postLayoutInfo ) ) { postAnimationRunner ( ) ; } } private void animateChange ( @ NonNull ViewHolder oldHolder , @ NonNull ViewHolder newHolder , @ NonNull ItemHolderInfo preInfo , @ NonNull ItemHolderInfo postInfo , boolean oldHolderDisappearing , boolean newHolderDisappearing ) { oldHolder . setIsRecyclable ( false ) ; if ( oldHolderDisappearing ) { addAnimatingView ( oldHolder ) ; } if ( oldHolder != newHolder ) { if ( newHolderDisappearing ) { addAnimatingView ( newHolder ) ; } oldHolder . mShadowedHolder = newHolder ; addAnimatingView ( oldHolder ) ; mRecycler . unscrapView ( oldHolder ) ; newHolder . setIsRecyclable ( false ) ; newHolder . mShadowingHolder = oldHolder ; } if ( mItemAnimator . animateChange ( oldHolder , newHolder , preInfo , postInfo ) ) { postAnimationRunner ( ) ; } } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { TraceCompat . beginSection ( TRACE_ON_LAYOUT_TAG ) ; dispatchLayout ( ) ; TraceCompat . endSection ( ) ; mFirstLayoutComplete = true ; } @ Override public void requestLayout ( ) { if ( mInterceptRequestLayoutDepth == <NUM_LIT> && ! mLayoutSuppressed ) { super . requestLayout ( ) ; } else { mLayoutWasDefered = true ; } } void markItemDecorInsetsDirty ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = mChildHelper . getUnfilteredChildAt ( i ) ; ( ( LayoutParams ) child . getLayoutParams ( ) ) . mInsetsDirty = true ; } mRecycler . markItemDecorInsetsDirty ( ) ; } @ Override public void draw ( Canvas c ) { c . save ( ) ; boolean needsInvalidate = false ; if ( mHorizontalEdgeEffect != null && ! mHorizontalEdgeEffect . isFinished ( ) ) { mHorizontalEdgeEffect . computeScrollOffset ( ) ; c . translate ( mHorizontalEdgeEffect . getDistance ( ) , <NUM_LIT> ) ; needsInvalidate = true ; } if ( mVerticalEdgeEffect != null && ! mVerticalEdgeEffect . isFinished ( ) ) { mVerticalEdgeEffect . computeScrollOffset ( ) ; c . translate ( <NUM_LIT> , mVerticalEdgeEffect . getDistance ( ) ) ; needsInvalidate = true ; } super . draw ( c ) ; final int count = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mItemDecorations . get ( i ) . onDrawOver ( c , this , mState ) ; } c . restore ( ) ; if ( ! needsInvalidate && mItemAnimator != null && mItemDecorations . size ( ) > <NUM_LIT> && mItemAnimator . isRunning ( ) ) { needsInvalidate = true ; } if ( needsInvalidate ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } @ Override public void onDraw ( Canvas c ) { super . onDraw ( c ) ; final int count = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mItemDecorations . get ( i ) . onDraw ( c , this , mState ) ; } } @ Override protected boolean checkLayoutParams ( ViewGroup . LayoutParams p ) { return p instanceof LayoutParams && mLayout . checkLayoutParams ( ( LayoutParams ) p ) ; } @ Override protected ViewGroup . LayoutParams generateDefaultLayoutParams ( ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateDefaultLayoutParams ( ) ; } @ Override public ViewGroup . LayoutParams generateLayoutParams ( AttributeSet attrs ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateLayoutParams ( getContext ( ) , attrs ) ; } @ Override protected ViewGroup . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams p ) { if ( mLayout == null ) { throw new IllegalStateException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } return mLayout . generateLayoutParams ( p ) ; } public boolean isAnimating ( ) { return mItemAnimator != null && mItemAnimator . isRunning ( ) ; } void saveOldPositions ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( sDebugAssertionsEnabled && holder . mPosition == - <NUM_LIT> && ! holder . isRemoved ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } if ( ! holder . shouldIgnore ( ) ) { holder . saveOldPosition ( ) ; } } } void clearOldPositions ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( ! holder . shouldIgnore ( ) ) { holder . clearOldPosition ( ) ; } } mRecycler . clearOldPositions ( ) ; } void offsetPositionRecordsForMove ( int from , int to ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; final int start , end , inBetweenOffset ; if ( from < to ) { start = from ; end = to ; inBetweenOffset = - <NUM_LIT> ; } else { start = to ; end = from ; inBetweenOffset = <NUM_LIT> ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder == null || holder . mPosition < start || holder . mPosition > end ) { continue ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder ) ; } if ( holder . mPosition == from ) { holder . offsetPosition ( to - from , false ) ; } else { holder . offsetPosition ( inBetweenOffset , false ) ; } mState . mStructureChanged = true ; } mRecycler . offsetPositionRecordsForMove ( from , to ) ; requestLayout ( ) ; } void offsetPositionRecordsForInsert ( int positionStart , int itemCount ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) && holder . mPosition >= positionStart ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition + itemCount ) ) ; } holder . offsetPosition ( itemCount , false ) ; mState . mStructureChanged = true ; } } mRecycler . offsetPositionRecordsForInsert ( positionStart , itemCount ) ; requestLayout ( ) ; } void offsetPositionRecordsForRemove ( int positionStart , int itemCount , boolean applyToPreLayout ) { final int positionEnd = positionStart + itemCount ; final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) ) { if ( holder . mPosition >= positionEnd ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition - itemCount ) ) ; } holder . offsetPosition ( - itemCount , applyToPreLayout ) ; mState . mStructureChanged = true ; } else if ( holder . mPosition >= positionStart ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" ) ; } holder . flagRemovedAndOffsetPosition ( positionStart - <NUM_LIT> , - itemCount , applyToPreLayout ) ; mState . mStructureChanged = true ; } } } mRecycler . offsetPositionRecordsForRemove ( positionStart , itemCount , applyToPreLayout ) ; requestLayout ( ) ; } void viewRangeUpdate ( int positionStart , int itemCount , Object payload ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; final int positionEnd = positionStart + itemCount ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = mChildHelper . getUnfilteredChildAt ( i ) ; final ViewHolder holder = getChildViewHolderInt ( child ) ; if ( holder == null || holder . shouldIgnore ( ) ) { continue ; } if ( holder . mPosition >= positionStart && holder . mPosition < positionEnd ) { holder . addFlags ( ViewHolder . FLAG_UPDATE ) ; holder . addChangePayload ( payload ) ; ( ( LayoutParams ) child . getLayoutParams ( ) ) . mInsetsDirty = true ; } } mRecycler . viewRangeUpdate ( positionStart , itemCount ) ; } boolean canReuseUpdatedViewHolder ( ViewHolder viewHolder ) { return mItemAnimator == null || mItemAnimator . canReuseUpdatedViewHolder ( viewHolder , viewHolder . getUnmodifiedPayloads ( ) ) ; } void processDataSetCompletelyChanged ( boolean dispatchItemsChanged ) { mDispatchItemsChangedEvent |= dispatchItemsChanged ; mDataSetHasChangedAfterLayout = true ; markKnownViewsInvalid ( ) ; } void markKnownViewsInvalid ( ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . shouldIgnore ( ) ) { holder . addFlags ( ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID ) ; } } markItemDecorInsetsDirty ( ) ; mRecycler . markKnownViewsInvalid ( ) ; } public void invalidateItemDecorations ( ) { if ( mItemDecorations . size ( ) == <NUM_LIT> ) { return ; } if ( mLayout != null ) { mLayout . assertNotInLayoutOrScroll ( "<STR_LIT>" + "<STR_LIT>" ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } public boolean getPreserveFocusAfterLayout ( ) { return mPreserveFocusAfterLayout ; } public void setPreserveFocusAfterLayout ( boolean preserveFocusAfterLayout ) { mPreserveFocusAfterLayout = preserveFocusAfterLayout ; } public ViewHolder getChildViewHolder ( @ NonNull View child ) { final ViewParent parent = child . getParent ( ) ; if ( parent != null && parent != this ) { throw new IllegalArgumentException ( "<STR_LIT>" + child + "<STR_LIT>" + this ) ; } return getChildViewHolderInt ( child ) ; } @ Nullable public View findContainingItemView ( @ NonNull View view ) { ViewParent parent = view . getParent ( ) ; while ( parent != null && parent != this && parent instanceof View ) { view = ( View ) parent ; parent = view . getParent ( ) ; } return parent == this ? view : null ; } @ Nullable public ViewHolder findContainingViewHolder ( @ NonNull View view ) { View itemView = findContainingItemView ( view ) ; return itemView == null ? null : getChildViewHolder ( itemView ) ; } static ViewHolder getChildViewHolderInt ( View child ) { if ( child == null ) { return null ; } return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mViewHolder ; } @ Deprecated public int getChildPosition ( @ NonNull View child ) { return getChildAdapterPosition ( child ) ; } public int getChildAdapterPosition ( @ NonNull View child ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getAbsoluteAdapterPosition ( ) : NO_POSITION ; } public int getChildLayoutPosition ( @ NonNull View child ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getLayoutPosition ( ) : NO_POSITION ; } public long getChildItemId ( @ NonNull View child ) { if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { return NO_ID ; } final ViewHolder holder = getChildViewHolderInt ( child ) ; return holder != null ? holder . getItemId ( ) : NO_ID ; } @ Deprecated @ Nullable public ViewHolder findViewHolderForPosition ( int position ) { return findViewHolderForPosition ( position , false ) ; } @ Nullable public ViewHolder findViewHolderForLayoutPosition ( int position ) { return findViewHolderForPosition ( position , false ) ; } @ Nullable public ViewHolder findViewHolderForAdapterPosition ( int position ) { if ( mDataSetHasChangedAfterLayout ) { return null ; } final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) && getAdapterPositionInRecyclerView ( holder ) == position ) { if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } @ Nullable ViewHolder findViewHolderForPosition ( int position , boolean checkNewPosition ) { final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) ) { if ( checkNewPosition ) { if ( holder . mPosition != position ) { continue ; } } else if ( holder . getLayoutPosition ( ) != position ) { continue ; } if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } public ViewHolder findViewHolderForItemId ( long id ) { if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { return null ; } final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; ViewHolder hidden = null ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder != null && ! holder . isRemoved ( ) && holder . getItemId ( ) == id ) { if ( mChildHelper . isHidden ( holder . itemView ) ) { hidden = holder ; } else { return holder ; } } } return hidden ; } @ Nullable public View findChildViewUnder ( float x , float y ) { final int count = mChildHelper . getChildCount ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View child = mChildHelper . getChildAt ( i ) ; final float translationX = child . getTranslationX ( ) ; final float translationY = child . getTranslationY ( ) ; if ( x >= child . getLeft ( ) + translationX && x <= child . getRight ( ) + translationX && y >= child . getTop ( ) + translationY && y <= child . getBottom ( ) + translationY ) { return child ; } } return null ; } @ Override public boolean drawChild ( Canvas canvas , View child , long drawingTime ) { return super . drawChild ( canvas , child , drawingTime ) ; } public void offsetChildrenVertical ( @ Px int dy ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { mChildHelper . getChildAt ( i ) . offsetTopAndBottom ( dy ) ; } } public void onChildAttachedToWindow ( @ NonNull View child ) { } public void onChildDetachedFromWindow ( @ NonNull View child ) { } public void offsetChildrenHorizontal ( @ Px int dx ) { final int childCount = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { mChildHelper . getChildAt ( i ) . offsetLeftAndRight ( dx ) ; } } public void getDecoratedBoundsWithMargins ( @ NonNull View view , @ NonNull Rect outBounds ) { getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } static void getDecoratedBoundsWithMarginsInt ( View view , Rect outBounds ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect insets = lp . mDecorInsets ; outBounds . set ( view . getLeft ( ) - insets . left - lp . leftMargin , view . getTop ( ) - insets . top - lp . topMargin , view . getRight ( ) + insets . right + lp . rightMargin , view . getBottom ( ) + insets . bottom + lp . bottomMargin ) ; } Rect getItemDecorInsetsForChild ( View child ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( ! lp . mInsetsDirty ) { return lp . mDecorInsets ; } if ( mState . isPreLayout ( ) && ( lp . isItemChanged ( ) || lp . isViewInvalid ( ) ) ) { return lp . mDecorInsets ; } final Rect insets = lp . mDecorInsets ; insets . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; final int decorCount = mItemDecorations . size ( ) ; for ( int i = <NUM_LIT> ; i < decorCount ; i ++ ) { mTempRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mItemDecorations . get ( i ) . getItemOffsets ( mTempRect , child , this , mState ) ; insets . left += mTempRect . left ; insets . top += mTempRect . top ; insets . right += mTempRect . right ; insets . bottom += mTempRect . bottom ; } lp . mInsetsDirty = false ; return insets ; } public void onScrolled ( @ Px int dx , @ Px int dy ) { } void dispatchOnScrolled ( int hresult , int vresult ) { mDispatchScrollCounter ++ ; final int scrollX = getScrollX ( ) ; final int scrollY = getScrollY ( ) ; onScrollChanged ( scrollX , scrollY , scrollX - hresult , scrollY - vresult ) ; onScrolled ( hresult , vresult ) ; if ( mScrollListener != null ) { mScrollListener . onScrolled ( this , hresult , vresult ) ; } if ( mScrollListeners != null ) { for ( int i = mScrollListeners . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mScrollListeners . get ( i ) . onScrolled ( this , hresult , vresult ) ; } } mDispatchScrollCounter -- ; } public void onScrollStateChanged ( int state ) { } private float getSplineFlingDistance ( int velocity ) { final double l = Math . log ( INFLEXION * Math . abs ( velocity ) / ( SCROLL_FRICTION * mPhysicalCoef ) ) ; final double decelMinusOne = DECELERATION_RATE - <NUM_LIT> ; return ( float ) ( SCROLL_FRICTION * mPhysicalCoef * Math . exp ( DECELERATION_RATE / decelMinusOne * l ) ) ; } void dispatchOnScrollStateChanged ( int state ) { if ( mLayout != null ) { mLayout . onScrollStateChanged ( state ) ; } onScrollStateChanged ( state ) ; if ( mScrollListener != null ) { mScrollListener . onScrollStateChanged ( this , state ) ; } if ( mScrollListeners != null ) { for ( int i = mScrollListeners . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mScrollListeners . get ( i ) . onScrollStateChanged ( this , state ) ; } } } public boolean hasPendingAdapterUpdates ( ) { return ! mFirstLayoutComplete || mDataSetHasChangedAfterLayout || mAdapterHelper . hasPendingUpdates ( ) ; } class ViewFlinger implements Runnable { private int mLastFlingX ; private int mLastFlingY ; OverScrollerAdapter mOverScroller ; Interpolator mInterpolator = sQuinticInterpolator ; private boolean mEatRunOnAnimationRequest = false ; private boolean mReSchedulePostAnimationCallback = false ; ViewFlinger ( ) { mOverScroller = new OverScrollerAdapter ( getContext ( ) , sQuinticInterpolator ) ; } @ Override public void run ( ) { if ( mLayout == null ) { stop ( ) ; return ; } mReSchedulePostAnimationCallback = false ; mEatRunOnAnimationRequest = true ; consumePendingUpdateOperations ( ) ; final OverScrollerAdapter scroller = mOverScroller ; if ( scroller . computeScrollOffset ( ) ) { final int x = scroller . getCurrX ( ) ; final int y = scroller . getCurrY ( ) ; int unconsumedX = x - mLastFlingX ; int unconsumedY = y - mLastFlingY ; mLastFlingX = x ; mLastFlingY = y ; unconsumedX = consumeFlingInHorizontalStretch ( unconsumedX ) ; unconsumedY = consumeFlingInVerticalStretch ( unconsumedY ) ; int consumedX = <NUM_LIT> ; int consumedY = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; if ( dispatchNestedPreScroll ( unconsumedX , unconsumedY , mReusableIntPair , null , TYPE_NON_TOUCH ) ) { unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; } if ( mAdapter != null ) { mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; scrollStep ( unconsumedX , unconsumedY , mReusableIntPair ) ; consumedX = mReusableIntPair [ <NUM_LIT> ] ; consumedY = mReusableIntPair [ <NUM_LIT> ] ; unconsumedX -= consumedX ; unconsumedY -= consumedY ; SmoothScroller smoothScroller = mLayout . mSmoothScroller ; if ( smoothScroller != null && ! smoothScroller . isPendingInitialRun ( ) && smoothScroller . isRunning ( ) ) { final int adapterSize = mState . getItemCount ( ) ; if ( adapterSize == <NUM_LIT> ) { smoothScroller . stop ( ) ; } else if ( smoothScroller . getTargetPosition ( ) >= adapterSize ) { smoothScroller . setTargetPosition ( adapterSize - <NUM_LIT> ) ; smoothScroller . onAnimation ( consumedX , consumedY ) ; } else { smoothScroller . onAnimation ( consumedX , consumedY ) ; } } } if ( ! mItemDecorations . isEmpty ( ) ) { invalidate ( ) ; } mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( consumedX , consumedY , unconsumedX , unconsumedY , null , TYPE_NON_TOUCH , mReusableIntPair ) ; unconsumedX -= mReusableIntPair [ <NUM_LIT> ] ; unconsumedY -= mReusableIntPair [ <NUM_LIT> ] ; if ( consumedX != <NUM_LIT> || consumedY != <NUM_LIT> ) { dispatchOnScrolled ( consumedX , consumedY ) ; } if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } boolean scrollerFinishedX = scroller . getCurrX ( ) == scroller . getFinalX ( ) ; boolean scrollerFinishedY = scroller . getCurrY ( ) == scroller . getFinalY ( ) ; final boolean doneScrolling = scroller . isFinished ( ) || ( ( scrollerFinishedX || unconsumedX != <NUM_LIT> ) && ( scrollerFinishedY || unconsumedY != <NUM_LIT> ) ) ; SmoothScroller smoothScroller = mLayout . mSmoothScroller ; boolean smoothScrollerPending = smoothScroller != null && smoothScroller . isPendingInitialRun ( ) ; if ( ! smoothScrollerPending && doneScrolling ) { if ( getOverScrollMode ( ) != View . OVER_SCROLL_NEVER ) { final int vel = ( int ) scroller . getCurrVelocity ( ) ; int velX = unconsumedX < <NUM_LIT> ? vel : unconsumedX > <NUM_LIT> ? - vel : <NUM_LIT> ; int velY = unconsumedY < <NUM_LIT> ? vel : unconsumedY > <NUM_LIT> ? - vel : <NUM_LIT> ; absorbGlows ( velX , velY ) ; } if ( ALLOW_THREAD_GAP_WORK ) { mPrefetchRegistry . clearPrefetchPositions ( ) ; } } else { postOnAnimation ( ) ; if ( mGapWorker != null ) { mGapWorker . postFromTraversal ( RecyclerView . this , consumedX , consumedY ) ; } } } SmoothScroller smoothScroller = mLayout . mSmoothScroller ; if ( smoothScroller != null && smoothScroller . isPendingInitialRun ( ) ) { smoothScroller . onAnimation ( <NUM_LIT> , <NUM_LIT> ) ; } mEatRunOnAnimationRequest = false ; if ( mReSchedulePostAnimationCallback ) { internalPostOnAnimation ( ) ; } else { setScrollState ( SCROLL_STATE_IDLE ) ; stopNestedScroll ( TYPE_NON_TOUCH ) ; } } void postOnAnimation ( ) { if ( mEatRunOnAnimationRequest ) { mReSchedulePostAnimationCallback = true ; } else { internalPostOnAnimation ( ) ; } } private void internalPostOnAnimation ( ) { removeCallbacks ( this ) ; ViewCompat . postOnAnimation ( RecyclerView . this , this ) ; } public void fling ( int velocityX , int velocityY ) { setScrollState ( SCROLL_STATE_SETTLING ) ; mLastFlingX = mLastFlingY = <NUM_LIT> ; if ( mInterpolator != sQuinticInterpolator ) { mInterpolator = sQuinticInterpolator ; mOverScroller = new OverScrollerAdapter ( getContext ( ) , sQuinticInterpolator ) ; } mOverScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; postOnAnimation ( ) ; } public void smoothScrollBy ( int dx , int dy , int duration , @ Nullable Interpolator interpolator ) { if ( duration == UNDEFINED_DURATION ) { duration = computeScrollDuration ( dx , dy ) ; } if ( interpolator == null ) { interpolator = sQuinticInterpolator ; } if ( mInterpolator != interpolator ) { mInterpolator = interpolator ; mOverScroller = new OverScrollerAdapter ( getContext ( ) , interpolator ) ; } mLastFlingX = mLastFlingY = <NUM_LIT> ; setScrollState ( SCROLL_STATE_SETTLING ) ; mOverScroller . startScroll ( <NUM_LIT> , <NUM_LIT> , dx , dy , duration ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { mOverScroller . computeScrollOffset ( ) ; } postOnAnimation ( ) ; } private int computeScrollDuration ( int dx , int dy ) { final int absDx = Math . abs ( dx ) ; final int absDy = Math . abs ( dy ) ; final boolean horizontal = absDx > absDy ; final int containerSize = horizontal ? getWidth ( ) : getHeight ( ) ; float absDelta = ( float ) ( horizontal ? absDx : absDy ) ; final int duration = ( int ) ( ( ( absDelta / containerSize ) + <NUM_LIT> ) * <NUM_LIT> ) ; return Math . min ( duration , MAX_SCROLL_DURATION ) ; } public void stop ( ) { removeCallbacks ( this ) ; mOverScroller . abortAnimation ( ) ; } } void repositionShadowingViews ( ) { int count = mChildHelper . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mChildHelper . getChildAt ( i ) ; ViewHolder holder = getChildViewHolder ( view ) ; if ( holder != null && holder . mShadowingHolder != null ) { View shadowingView = holder . mShadowingHolder . itemView ; int left = view . getLeft ( ) ; int top = view . getTop ( ) ; if ( left != shadowingView . getLeft ( ) || top != shadowingView . getTop ( ) ) { shadowingView . layout ( left , top , left + shadowingView . getWidth ( ) , top + shadowingView . getHeight ( ) ) ; } } } } private class RecyclerViewDataObserver extends AdapterDataObserver { RecyclerViewDataObserver ( ) { } @ Override public void onChanged ( ) { assertNotInLayoutOrScroll ( null ) ; mState . mStructureChanged = true ; processDataSetCompletelyChanged ( true ) ; if ( ! mAdapterHelper . hasPendingUpdates ( ) ) { requestLayout ( ) ; } } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeChanged ( positionStart , itemCount , payload ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeInserted ( positionStart , itemCount ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeRemoved ( positionStart , itemCount ) ) { triggerUpdateProcessor ( ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { assertNotInLayoutOrScroll ( null ) ; if ( mAdapterHelper . onItemRangeMoved ( fromPosition , toPosition , itemCount ) ) { triggerUpdateProcessor ( ) ; } } void triggerUpdateProcessor ( ) { if ( POST_UPDATES_ON_ANIMATION && mHasFixedSize && mIsAttached ) { ViewCompat . postOnAnimation ( RecyclerView . this , mUpdateChildViewsRunnable ) ; } else { mAdapterUpdateDuringMeasure = true ; requestLayout ( ) ; } } @ Override public void onStateRestorationPolicyChanged ( ) { if ( mPendingSavedState == null ) { return ; } Adapter < ? > adapter = mAdapter ; if ( adapter != null && adapter . canRestoreState ( ) ) { requestLayout ( ) ; } } } public static class EdgeEffectFactory { @ Retention ( RetentionPolicy . SOURCE ) @ IntDef ( { DIRECTION_LEFT , DIRECTION_TOP , DIRECTION_RIGHT , DIRECTION_BOTTOM } ) public @ interface EdgeDirection { } public static final int DIRECTION_LEFT = <NUM_LIT> ; public static final int DIRECTION_TOP = <NUM_LIT> ; public static final int DIRECTION_RIGHT = <NUM_LIT> ; public static final int DIRECTION_BOTTOM = <NUM_LIT> ; protected @ NonNull EdgeEffect createEdgeEffect ( @ NonNull RecyclerView view , @ EdgeDirection int direction ) { return new EdgeEffect ( view . getContext ( ) ) ; } } public static class RecycledViewPool { private static final int DEFAULT_MAX_SCRAP = <NUM_LIT> ; static class ScrapData { final ArrayList < ViewHolder > mScrapHeap = new ArrayList < > ( ) ; int mMaxScrap = DEFAULT_MAX_SCRAP ; long mCreateRunningAverageNs = <NUM_LIT> ; long mBindRunningAverageNs = <NUM_LIT> ; } SparseArray < ScrapData > mScrap = new SparseArray < > ( ) ; int mAttachCountForClearing = <NUM_LIT> ; Set < Adapter < ? > > mAttachedAdaptersForPoolingContainer = Collections . newSetFromMap ( new IdentityHashMap < > ( ) ) ; public void clear ( ) { for ( int i = <NUM_LIT> ; i < mScrap . size ( ) ; i ++ ) { ScrapData data = mScrap . valueAt ( i ) ; for ( ViewHolder scrap : data . mScrapHeap ) { PoolingContainer . callPoolingContainerOnRelease ( scrap . itemView ) ; } data . mScrapHeap . clear ( ) ; } } public void setMaxRecycledViews ( int viewType , int max ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mMaxScrap = max ; final ArrayList < ViewHolder > scrapHeap = scrapData . mScrapHeap ; while ( scrapHeap . size ( ) > max ) { scrapHeap . remove ( scrapHeap . size ( ) - <NUM_LIT> ) ; } } public int getRecycledViewCount ( int viewType ) { return getScrapDataForType ( viewType ) . mScrapHeap . size ( ) ; } @ Nullable public ViewHolder getRecycledView ( int viewType ) { final ScrapData scrapData = mScrap . get ( viewType ) ; if ( scrapData != null && ! scrapData . mScrapHeap . isEmpty ( ) ) { final ArrayList < ViewHolder > scrapHeap = scrapData . mScrapHeap ; for ( int i = scrapHeap . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! scrapHeap . get ( i ) . isAttachedToTransitionOverlay ( ) ) { return scrapHeap . remove ( i ) ; } } } return null ; } int size ( ) { int count = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < mScrap . size ( ) ; i ++ ) { ArrayList < ViewHolder > viewHolders = mScrap . valueAt ( i ) . mScrapHeap ; if ( viewHolders != null ) { count += viewHolders . size ( ) ; } } return count ; } public void putRecycledView ( ViewHolder scrap ) { final int viewType = scrap . getItemViewType ( ) ; final ArrayList < ViewHolder > scrapHeap = getScrapDataForType ( viewType ) . mScrapHeap ; if ( mScrap . get ( viewType ) . mMaxScrap <= scrapHeap . size ( ) ) { PoolingContainer . callPoolingContainerOnRelease ( scrap . itemView ) ; return ; } if ( sDebugAssertionsEnabled && scrapHeap . contains ( scrap ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } scrap . resetInternal ( ) ; scrapHeap . add ( scrap ) ; } long runningAverage ( long oldAverage , long newValue ) { if ( oldAverage == <NUM_LIT> ) { return newValue ; } return ( oldAverage / <NUM_LIT> * <NUM_LIT> ) + ( newValue / <NUM_LIT> ) ; } void factorInCreateTime ( int viewType , long createTimeNs ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mCreateRunningAverageNs = runningAverage ( scrapData . mCreateRunningAverageNs , createTimeNs ) ; } void factorInBindTime ( int viewType , long bindTimeNs ) { ScrapData scrapData = getScrapDataForType ( viewType ) ; scrapData . mBindRunningAverageNs = runningAverage ( scrapData . mBindRunningAverageNs , bindTimeNs ) ; } boolean willCreateInTime ( int viewType , long approxCurrentNs , long deadlineNs ) { long expectedDurationNs = getScrapDataForType ( viewType ) . mCreateRunningAverageNs ; return expectedDurationNs == <NUM_LIT> || ( approxCurrentNs + expectedDurationNs < deadlineNs ) ; } boolean willBindInTime ( int viewType , long approxCurrentNs , long deadlineNs ) { long expectedDurationNs = getScrapDataForType ( viewType ) . mBindRunningAverageNs ; return expectedDurationNs == <NUM_LIT> || ( approxCurrentNs + expectedDurationNs < deadlineNs ) ; } void attach ( ) { mAttachCountForClearing ++ ; } void detach ( ) { mAttachCountForClearing -- ; } void attachForPoolingContainer ( @ NonNull Adapter < ? > adapter ) { mAttachedAdaptersForPoolingContainer . add ( adapter ) ; } void detachForPoolingContainer ( @ NonNull Adapter < ? > adapter , boolean isBeingReplaced ) { mAttachedAdaptersForPoolingContainer . remove ( adapter ) ; if ( mAttachedAdaptersForPoolingContainer . size ( ) == <NUM_LIT> && ! isBeingReplaced ) { for ( int keyIndex = <NUM_LIT> ; keyIndex < mScrap . size ( ) ; keyIndex ++ ) { ArrayList < ViewHolder > scrapHeap = mScrap . get ( mScrap . keyAt ( keyIndex ) ) . mScrapHeap ; for ( int i = <NUM_LIT> ; i < scrapHeap . size ( ) ; i ++ ) { PoolingContainer . callPoolingContainerOnRelease ( scrapHeap . get ( i ) . itemView ) ; } } } } void onAdapterChanged ( Adapter < ? > oldAdapter , Adapter < ? > newAdapter , boolean compatibleWithPrevious ) { if ( oldAdapter != null ) { detach ( ) ; } if ( ! compatibleWithPrevious && mAttachCountForClearing == <NUM_LIT> ) { clear ( ) ; } if ( newAdapter != null ) { attach ( ) ; } } private ScrapData getScrapDataForType ( int viewType ) { ScrapData scrapData = mScrap . get ( viewType ) ; if ( scrapData == null ) { scrapData = new ScrapData ( ) ; mScrap . put ( viewType , scrapData ) ; } return scrapData ; } } @ Nullable static RecyclerView findNestedRecyclerView ( @ NonNull View view ) { if ( ! ( view instanceof ViewGroup ) ) { return null ; } if ( view instanceof RecyclerView ) { return ( RecyclerView ) view ; } final ViewGroup parent = ( ViewGroup ) view ; final int count = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View child = parent . getChildAt ( i ) ; final RecyclerView descendant = findNestedRecyclerView ( child ) ; if ( descendant != null ) { return descendant ; } } return null ; } static void clearNestedRecyclerViewIfNotNested ( @ NonNull ViewHolder holder ) { if ( holder . mNestedRecyclerView != null ) { View item = holder . mNestedRecyclerView . get ( ) ; while ( item != null ) { if ( item == holder . itemView ) { return ; } ViewParent parent = item . getParent ( ) ; if ( parent instanceof View ) { item = ( View ) parent ; } else { item = null ; } } holder . mNestedRecyclerView = null ; } } long getNanoTime ( ) { if ( ALLOW_THREAD_GAP_WORK ) { return System . nanoTime ( ) ; } else { return <NUM_LIT> ; } } public final class Recycler { final ArrayList < ViewHolder > mAttachedScrap = new ArrayList < > ( ) ; ArrayList < ViewHolder > mChangedScrap = null ; final ArrayList < ViewHolder > mCachedViews = new ArrayList < ViewHolder > ( ) ; private final List < ViewHolder > mUnmodifiableAttachedScrap = Collections . unmodifiableList ( mAttachedScrap ) ; private int mRequestedCacheMax = DEFAULT_CACHE_SIZE ; int mViewCacheMax = DEFAULT_CACHE_SIZE ; RecycledViewPool mRecyclerPool ; private ViewCacheExtension mViewCacheExtension ; static final int DEFAULT_CACHE_SIZE = <NUM_LIT> ; public void clear ( ) { mAttachedScrap . clear ( ) ; recycleAndClearCachedViews ( ) ; } public void setViewCacheSize ( int viewCount ) { mRequestedCacheMax = viewCount ; updateViewCacheSize ( ) ; } void updateViewCacheSize ( ) { int extraCache = mLayout != null ? mLayout . mPrefetchMaxCountObserved : <NUM_LIT> ; mViewCacheMax = mRequestedCacheMax + extraCache ; for ( int i = mCachedViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> && mCachedViews . size ( ) > mViewCacheMax ; i -- ) { recycleCachedViewAt ( i ) ; } } @ NonNull public List < ViewHolder > getScrapList ( ) { return mUnmodifiableAttachedScrap ; } boolean validateViewHolderForOffsetPosition ( ViewHolder holder ) { if ( holder . isRemoved ( ) ) { if ( sDebugAssertionsEnabled && ! mState . isPreLayout ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } return mState . isPreLayout ( ) ; } if ( holder . mPosition < <NUM_LIT> || holder . mPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( ! mState . isPreLayout ( ) ) { final int type = mAdapter . getItemViewType ( holder . mPosition ) ; if ( type != holder . getItemViewType ( ) ) { return false ; } } if ( mAdapter . hasStableIds ( ) ) { return holder . getItemId ( ) == mAdapter . getItemId ( holder . mPosition ) ; } return true ; } @ SuppressWarnings ( "<STR_LIT>" ) private boolean tryBindViewHolderByDeadline ( @ NonNull ViewHolder holder , int offsetPosition , int position , long deadlineNs ) { holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = RecyclerView . this ; final int viewType = holder . getItemViewType ( ) ; long startBindNs = getNanoTime ( ) ; if ( deadlineNs != FOREVER_NS && ! mRecyclerPool . willBindInTime ( viewType , startBindNs , deadlineNs ) ) { return false ; } boolean reattachedForBind = false ; if ( holder . isTmpDetached ( ) ) { attachViewToParent ( holder . itemView , getChildCount ( ) , holder . itemView . getLayoutParams ( ) ) ; reattachedForBind = true ; } mAdapter . bindViewHolder ( holder , offsetPosition ) ; if ( reattachedForBind ) { detachViewFromParent ( holder . itemView ) ; } long endBindNs = getNanoTime ( ) ; mRecyclerPool . factorInBindTime ( holder . getItemViewType ( ) , endBindNs - startBindNs ) ; attachAccessibilityDelegateOnBind ( holder ) ; if ( mState . isPreLayout ( ) ) { holder . mPreLayoutPosition = position ; } return true ; } public void bindViewToPosition ( @ NonNull View view , int position ) { ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition < <NUM_LIT> || offsetPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + position + "<STR_LIT>" + offsetPosition + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } tryBindViewHolderByDeadline ( holder , offsetPosition , position , FOREVER_NS ) ; final ViewGroup . LayoutParams lp = holder . itemView . getLayoutParams ( ) ; final LayoutParams rvLayoutParams ; if ( lp == null ) { rvLayoutParams = ( LayoutParams ) generateDefaultLayoutParams ( ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else if ( ! checkLayoutParams ( lp ) ) { rvLayoutParams = ( LayoutParams ) generateLayoutParams ( lp ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else { rvLayoutParams = ( LayoutParams ) lp ; } rvLayoutParams . mInsetsDirty = true ; rvLayoutParams . mViewHolder = holder ; rvLayoutParams . mPendingInvalidate = holder . itemView . getParent ( ) == null ; } public int convertPreLayoutPositionToPostLayout ( int position ) { if ( position < <NUM_LIT> || position >= mState . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + position + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } if ( ! mState . isPreLayout ( ) ) { return position ; } return mAdapterHelper . findPositionOffset ( position ) ; } @ NonNull public View getViewForPosition ( int position ) { return getViewForPosition ( position , false ) ; } View getViewForPosition ( int position , boolean dryRun ) { return tryGetViewHolderForPositionByDeadline ( position , dryRun , FOREVER_NS ) . itemView ; } @ Nullable ViewHolder tryGetViewHolderForPositionByDeadline ( int position , boolean dryRun , long deadlineNs ) { if ( position < <NUM_LIT> || position >= mState . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + position + "<STR_LIT>" + position + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } boolean fromScrapOrHiddenOrCache = false ; ViewHolder holder = null ; if ( mState . isPreLayout ( ) ) { holder = getChangedScrapViewForPosition ( position ) ; fromScrapOrHiddenOrCache = holder != null ; } if ( holder == null ) { holder = getScrapOrHiddenOrCachedHolderForPosition ( position , dryRun ) ; if ( holder != null ) { if ( ! validateViewHolderForOffsetPosition ( holder ) ) { if ( ! dryRun ) { holder . addFlags ( ViewHolder . FLAG_INVALID ) ; if ( holder . isScrap ( ) ) { removeDetachedView ( holder . itemView , false ) ; holder . unScrap ( ) ; } else if ( holder . wasReturnedFromScrap ( ) ) { holder . clearReturnedFromScrapFlag ( ) ; } recycleViewHolderInternal ( holder ) ; } holder = null ; } else { fromScrapOrHiddenOrCache = true ; } } } if ( holder == null ) { final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition < <NUM_LIT> || offsetPosition >= mAdapter . getItemCount ( ) ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + "<STR_LIT>" + position + "<STR_LIT>" + offsetPosition + "<STR_LIT>" + "<STR_LIT>" + mState . getItemCount ( ) + exceptionLabel ( ) ) ; } final int type = mAdapter . getItemViewType ( offsetPosition ) ; if ( mAdapter . hasStableIds ( ) ) { holder = getScrapOrCachedViewForId ( mAdapter . getItemId ( offsetPosition ) , type , dryRun ) ; if ( holder != null ) { holder . mPosition = offsetPosition ; fromScrapOrHiddenOrCache = true ; } } if ( holder == null && mViewCacheExtension != null ) { final View view = mViewCacheExtension . getViewForPositionAndType ( this , position , type ) ; if ( view != null ) { holder = getChildViewHolder ( view ) ; if ( holder == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } else if ( holder . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } } } if ( holder == null ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + position + "<STR_LIT>" ) ; } holder = getRecycledViewPool ( ) . getRecycledView ( type ) ; if ( holder != null ) { holder . resetInternal ( ) ; if ( FORCE_INVALIDATE_DISPLAY_LIST ) { invalidateDisplayListInt ( holder ) ; } } } if ( holder == null ) { long start = getNanoTime ( ) ; if ( deadlineNs != FOREVER_NS && ! mRecyclerPool . willCreateInTime ( type , start , deadlineNs ) ) { return null ; } holder = mAdapter . createViewHolder ( RecyclerView . this , type ) ; if ( ALLOW_THREAD_GAP_WORK ) { RecyclerView innerView = findNestedRecyclerView ( holder . itemView ) ; if ( innerView != null ) { holder . mNestedRecyclerView = new WeakReference < > ( innerView ) ; } } long end = getNanoTime ( ) ; mRecyclerPool . factorInCreateTime ( type , end - start ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } } } if ( fromScrapOrHiddenOrCache && ! mState . isPreLayout ( ) && holder . hasAnyOfTheFlags ( ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ) { holder . setFlags ( <NUM_LIT> , ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; if ( mState . mRunSimpleAnimations ) { int changeFlags = ItemAnimator . buildAdapterChangeFlagsForAnimations ( holder ) ; changeFlags |= ItemAnimator . FLAG_APPEARED_IN_PRE_LAYOUT ; final ItemHolderInfo info = mItemAnimator . recordPreLayoutInformation ( mState , holder , changeFlags , holder . getUnmodifiedPayloads ( ) ) ; recordAnimationInfoIfBouncedHiddenView ( holder , info ) ; } } boolean bound = false ; if ( mState . isPreLayout ( ) && holder . isBound ( ) ) { holder . mPreLayoutPosition = position ; } else if ( ! holder . isBound ( ) || holder . needsUpdate ( ) || holder . isInvalid ( ) ) { if ( sDebugAssertionsEnabled && holder . isRemoved ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; bound = tryBindViewHolderByDeadline ( holder , offsetPosition , position , deadlineNs ) ; } final ViewGroup . LayoutParams lp = holder . itemView . getLayoutParams ( ) ; final LayoutParams rvLayoutParams ; if ( lp == null ) { rvLayoutParams = ( LayoutParams ) generateDefaultLayoutParams ( ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else if ( ! checkLayoutParams ( lp ) ) { rvLayoutParams = ( LayoutParams ) generateLayoutParams ( lp ) ; holder . itemView . setLayoutParams ( rvLayoutParams ) ; } else { rvLayoutParams = ( LayoutParams ) lp ; } rvLayoutParams . mViewHolder = holder ; rvLayoutParams . mPendingInvalidate = fromScrapOrHiddenOrCache && bound ; return holder ; } private void attachAccessibilityDelegateOnBind ( ViewHolder holder ) { if ( isAccessibilityEnabled ( ) ) { final View itemView = holder . itemView ; if ( ViewCompat . getImportantForAccessibility ( itemView ) == ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ) { ViewCompat . setImportantForAccessibility ( itemView , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_YES ) ; } if ( mAccessibilityDelegate == null ) { return ; } AccessibilityDelegateCompat itemDelegate = mAccessibilityDelegate . getItemDelegate ( ) ; if ( itemDelegate instanceof RecyclerViewAccessibilityDelegate . ItemDelegate ) { ( ( RecyclerViewAccessibilityDelegate . ItemDelegate ) itemDelegate ) . saveOriginalDelegate ( itemView ) ; } ViewCompat . setAccessibilityDelegate ( itemView , itemDelegate ) ; } } private void invalidateDisplayListInt ( ViewHolder holder ) { if ( holder . itemView instanceof ViewGroup ) { invalidateDisplayListInt ( ( ViewGroup ) holder . itemView , false ) ; } } private void invalidateDisplayListInt ( ViewGroup viewGroup , boolean invalidateThis ) { for ( int i = viewGroup . getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = viewGroup . getChildAt ( i ) ; if ( view instanceof ViewGroup ) { invalidateDisplayListInt ( ( ViewGroup ) view , true ) ; } } if ( ! invalidateThis ) { return ; } if ( viewGroup . getVisibility ( ) == View . INVISIBLE ) { viewGroup . setVisibility ( View . VISIBLE ) ; viewGroup . setVisibility ( View . INVISIBLE ) ; } else { final int visibility = viewGroup . getVisibility ( ) ; viewGroup . setVisibility ( View . INVISIBLE ) ; viewGroup . setVisibility ( visibility ) ; } } public void recycleView ( @ NonNull View view ) { ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder . isTmpDetached ( ) ) { removeDetachedView ( view , false ) ; } if ( holder . isScrap ( ) ) { holder . unScrap ( ) ; } else if ( holder . wasReturnedFromScrap ( ) ) { holder . clearReturnedFromScrapFlag ( ) ; } recycleViewHolderInternal ( holder ) ; if ( mItemAnimator != null && ! holder . isRecyclable ( ) ) { mItemAnimator . endAnimation ( holder ) ; } } void recycleAndClearCachedViews ( ) { final int count = mCachedViews . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { recycleCachedViewAt ( i ) ; } mCachedViews . clear ( ) ; if ( ALLOW_THREAD_GAP_WORK ) { mPrefetchRegistry . clearPrefetchPositions ( ) ; } } void recycleCachedViewAt ( int cachedViewIndex ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + cachedViewIndex ) ; } ViewHolder viewHolder = mCachedViews . get ( cachedViewIndex ) ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + viewHolder ) ; } addViewHolderToRecycledViewPool ( viewHolder , true ) ; mCachedViews . remove ( cachedViewIndex ) ; } void recycleViewHolderInternal ( ViewHolder holder ) { if ( holder . isScrap ( ) || holder . itemView . getParent ( ) != null ) { throw new IllegalArgumentException ( "<STR_LIT>" + holder . isScrap ( ) + "<STR_LIT>" + ( holder . itemView . getParent ( ) != null ) + exceptionLabel ( ) ) ; } if ( holder . isTmpDetached ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( holder . shouldIgnore ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } final boolean transientStatePreventsRecycling = holder . doesTransientStatePreventRecycling ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) final boolean forceRecycle = mAdapter != null && transientStatePreventsRecycling && mAdapter . onFailedToRecycleView ( holder ) ; boolean cached = false ; boolean recycled = false ; if ( sDebugAssertionsEnabled && mCachedViews . contains ( holder ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + holder + exceptionLabel ( ) ) ; } if ( forceRecycle || holder . isRecyclable ( ) ) { if ( mViewCacheMax > <NUM_LIT> && ! holder . hasAnyOfTheFlags ( ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) ) { int cachedViewSize = mCachedViews . size ( ) ; if ( cachedViewSize >= mViewCacheMax && cachedViewSize > <NUM_LIT> ) { recycleCachedViewAt ( <NUM_LIT> ) ; cachedViewSize -- ; } int targetCacheIndex = cachedViewSize ; if ( ALLOW_THREAD_GAP_WORK && cachedViewSize > <NUM_LIT> && ! mPrefetchRegistry . lastPrefetchIncludedPosition ( holder . mPosition ) ) { int cacheIndex = cachedViewSize - <NUM_LIT> ; while ( cacheIndex >= <NUM_LIT> ) { int cachedPos = mCachedViews . get ( cacheIndex ) . mPosition ; if ( ! mPrefetchRegistry . lastPrefetchIncludedPosition ( cachedPos ) ) { break ; } cacheIndex -- ; } targetCacheIndex = cacheIndex + <NUM_LIT> ; } mCachedViews . add ( targetCacheIndex , holder ) ; cached = true ; } if ( ! cached ) { addViewHolderToRecycledViewPool ( holder , true ) ; recycled = true ; } } else { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } } mViewInfoStore . removeViewHolder ( holder ) ; if ( ! cached && ! recycled && transientStatePreventsRecycling ) { PoolingContainer . callPoolingContainerOnRelease ( holder . itemView ) ; holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = null ; } } void addViewHolderToRecycledViewPool ( @ NonNull ViewHolder holder , boolean dispatchRecycled ) { clearNestedRecyclerViewIfNotNested ( holder ) ; View itemView = holder . itemView ; if ( mAccessibilityDelegate != null ) { AccessibilityDelegateCompat itemDelegate = mAccessibilityDelegate . getItemDelegate ( ) ; AccessibilityDelegateCompat originalDelegate = null ; if ( itemDelegate instanceof RecyclerViewAccessibilityDelegate . ItemDelegate ) { originalDelegate = ( ( RecyclerViewAccessibilityDelegate . ItemDelegate ) itemDelegate ) . getAndRemoveOriginalDelegateForItem ( itemView ) ; } ViewCompat . setAccessibilityDelegate ( itemView , originalDelegate ) ; } if ( dispatchRecycled ) { dispatchViewRecycled ( holder ) ; } holder . mBindingAdapter = null ; holder . mOwnerRecyclerView = null ; getRecycledViewPool ( ) . putRecycledView ( holder ) ; } void quickRecycleScrapView ( View view ) { final ViewHolder holder = getChildViewHolderInt ( view ) ; holder . mScrapContainer = null ; holder . mInChangeScrap = false ; holder . clearReturnedFromScrapFlag ( ) ; recycleViewHolderInternal ( holder ) ; } void scrapView ( View view ) { final ViewHolder holder = getChildViewHolderInt ( view ) ; if ( holder . hasAnyOfTheFlags ( ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_INVALID ) || ! holder . isUpdated ( ) || canReuseUpdatedViewHolder ( holder ) ) { if ( holder . isInvalid ( ) && ! holder . isRemoved ( ) && ! mAdapter . hasStableIds ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + exceptionLabel ( ) ) ; } holder . setScrapContainer ( this , false ) ; mAttachedScrap . add ( holder ) ; } else { if ( mChangedScrap == null ) { mChangedScrap = new ArrayList < ViewHolder > ( ) ; } holder . setScrapContainer ( this , true ) ; mChangedScrap . add ( holder ) ; } } void unscrapView ( ViewHolder holder ) { if ( holder . mInChangeScrap ) { mChangedScrap . remove ( holder ) ; } else { mAttachedScrap . remove ( holder ) ; } holder . mScrapContainer = null ; holder . mInChangeScrap = false ; holder . clearReturnedFromScrapFlag ( ) ; } int getScrapCount ( ) { return mAttachedScrap . size ( ) ; } View getScrapViewAt ( int index ) { return mAttachedScrap . get ( index ) . itemView ; } void clearScrap ( ) { mAttachedScrap . clear ( ) ; if ( mChangedScrap != null ) { mChangedScrap . clear ( ) ; } } ViewHolder getChangedScrapViewForPosition ( int position ) { final int changedScrapSize ; if ( mChangedScrap == null || ( changedScrapSize = mChangedScrap . size ( ) ) == <NUM_LIT> ) { return null ; } for ( int i = <NUM_LIT> ; i < changedScrapSize ; i ++ ) { final ViewHolder holder = mChangedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getLayoutPosition ( ) == position ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } if ( mAdapter . hasStableIds ( ) ) { final int offsetPosition = mAdapterHelper . findPositionOffset ( position ) ; if ( offsetPosition > <NUM_LIT> && offsetPosition < mAdapter . getItemCount ( ) ) { final long id = mAdapter . getItemId ( offsetPosition ) ; for ( int i = <NUM_LIT> ; i < changedScrapSize ; i ++ ) { final ViewHolder holder = mChangedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getItemId ( ) == id ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } } } return null ; } ViewHolder getScrapOrHiddenOrCachedHolderForPosition ( int position , boolean dryRun ) { final int scrapCount = mAttachedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < scrapCount ; i ++ ) { final ViewHolder holder = mAttachedScrap . get ( i ) ; if ( ! holder . wasReturnedFromScrap ( ) && holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ( mState . mInPreLayout || ! holder . isRemoved ( ) ) ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; return holder ; } } if ( ! dryRun ) { View view = mChildHelper . findHiddenNonRemovedView ( position ) ; if ( view != null ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; mChildHelper . unhide ( view ) ; int layoutIndex = mChildHelper . indexOfChild ( view ) ; if ( layoutIndex == RecyclerView . NO_POSITION ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + vh + exceptionLabel ( ) ) ; } mChildHelper . detachViewFromParent ( layoutIndex ) ; scrapView ( view ) ; vh . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP | ViewHolder . FLAG_BOUNCED_FROM_HIDDEN_LIST ) ; return vh ; } } final int cacheSize = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cacheSize ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( ! holder . isInvalid ( ) && holder . getLayoutPosition ( ) == position && ! holder . isAttachedToTransitionOverlay ( ) ) { if ( ! dryRun ) { mCachedViews . remove ( i ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + position + "<STR_LIT>" + holder ) ; } return holder ; } } return null ; } ViewHolder getScrapOrCachedViewForId ( long id , int type , boolean dryRun ) { final int count = mAttachedScrap . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mAttachedScrap . get ( i ) ; if ( holder . getItemId ( ) == id && ! holder . wasReturnedFromScrap ( ) ) { if ( type == holder . getItemViewType ( ) ) { holder . addFlags ( ViewHolder . FLAG_RETURNED_FROM_SCRAP ) ; if ( holder . isRemoved ( ) ) { if ( ! mState . isPreLayout ( ) ) { holder . setFlags ( ViewHolder . FLAG_UPDATE , ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED ) ; } } return holder ; } else if ( ! dryRun ) { mAttachedScrap . remove ( i ) ; removeDetachedView ( holder . itemView , false ) ; quickRecycleScrapView ( holder . itemView ) ; } } } final int cacheSize = mCachedViews . size ( ) ; for ( int i = cacheSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder . getItemId ( ) == id && ! holder . isAttachedToTransitionOverlay ( ) ) { if ( type == holder . getItemViewType ( ) ) { if ( ! dryRun ) { mCachedViews . remove ( i ) ; } return holder ; } else if ( ! dryRun ) { recycleCachedViewAt ( i ) ; return null ; } } } return null ; } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchViewRecycled ( @ NonNull ViewHolder holder ) { if ( mRecyclerListener != null ) { mRecyclerListener . onViewRecycled ( holder ) ; } final int listenerCount = mRecyclerListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < listenerCount ; i ++ ) { mRecyclerListeners . get ( i ) . onViewRecycled ( holder ) ; } if ( mAdapter != null ) { mAdapter . onViewRecycled ( holder ) ; } if ( mState != null ) { mViewInfoStore . removeViewHolder ( holder ) ; } if ( sVerboseLoggingEnabled ) Log . d ( TAG , "<STR_LIT>" + holder ) ; } void onAdapterChanged ( Adapter < ? > oldAdapter , Adapter < ? > newAdapter , boolean compatibleWithPrevious ) { clear ( ) ; poolingContainerDetach ( oldAdapter , true ) ; getRecycledViewPool ( ) . onAdapterChanged ( oldAdapter , newAdapter , compatibleWithPrevious ) ; maybeSendPoolingContainerAttach ( ) ; } void offsetPositionRecordsForMove ( int from , int to ) { final int start , end , inBetweenOffset ; if ( from < to ) { start = from ; end = to ; inBetweenOffset = - <NUM_LIT> ; } else { start = to ; end = from ; inBetweenOffset = <NUM_LIT> ; } final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder == null || holder . mPosition < start || holder . mPosition > end ) { continue ; } if ( holder . mPosition == from ) { holder . offsetPosition ( to - from , false ) ; } else { holder . offsetPosition ( inBetweenOffset , false ) ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder ) ; } } } void offsetPositionRecordsForInsert ( int insertedAt , int count ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null && holder . mPosition >= insertedAt ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition + count ) ) ; } holder . offsetPosition ( count , false ) ; } } } void offsetPositionRecordsForRemove ( int removedFrom , int count , boolean applyToPreLayout ) { final int removedEnd = removedFrom + count ; final int cachedCount = mCachedViews . size ( ) ; for ( int i = cachedCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null ) { if ( holder . mPosition >= removedEnd ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + holder + "<STR_LIT>" + ( holder . mPosition - count ) ) ; } holder . offsetPosition ( - count , applyToPreLayout ) ; } else if ( holder . mPosition >= removedFrom ) { holder . addFlags ( ViewHolder . FLAG_REMOVED ) ; recycleCachedViewAt ( i ) ; } } } } void setViewCacheExtension ( ViewCacheExtension extension ) { mViewCacheExtension = extension ; } void setRecycledViewPool ( RecycledViewPool pool ) { poolingContainerDetach ( mAdapter ) ; if ( mRecyclerPool != null ) { mRecyclerPool . detach ( ) ; } mRecyclerPool = pool ; if ( mRecyclerPool != null && getAdapter ( ) != null ) { mRecyclerPool . attach ( ) ; } maybeSendPoolingContainerAttach ( ) ; } private void maybeSendPoolingContainerAttach ( ) { if ( mRecyclerPool != null && mAdapter != null && isAttachedToWindow ( ) ) { mRecyclerPool . attachForPoolingContainer ( mAdapter ) ; } } private void poolingContainerDetach ( Adapter < ? > adapter ) { poolingContainerDetach ( adapter , false ) ; } private void poolingContainerDetach ( Adapter < ? > adapter , boolean isBeingReplaced ) { if ( mRecyclerPool != null ) { mRecyclerPool . detachForPoolingContainer ( adapter , isBeingReplaced ) ; } } void onAttachedToWindow ( ) { maybeSendPoolingContainerAttach ( ) ; } void onDetachedFromWindow ( ) { for ( int i = <NUM_LIT> ; i < mCachedViews . size ( ) ; i ++ ) { PoolingContainer . callPoolingContainerOnRelease ( mCachedViews . get ( i ) . itemView ) ; } poolingContainerDetach ( mAdapter ) ; } RecycledViewPool getRecycledViewPool ( ) { if ( mRecyclerPool == null ) { mRecyclerPool = new RecycledViewPool ( ) ; maybeSendPoolingContainerAttach ( ) ; } return mRecyclerPool ; } void viewRangeUpdate ( int positionStart , int itemCount ) { final int positionEnd = positionStart + itemCount ; final int cachedCount = mCachedViews . size ( ) ; for ( int i = cachedCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder == null ) { continue ; } final int pos = holder . mPosition ; if ( pos >= positionStart && pos < positionEnd ) { holder . addFlags ( ViewHolder . FLAG_UPDATE ) ; recycleCachedViewAt ( i ) ; } } } void markKnownViewsInvalid ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; if ( holder != null ) { holder . addFlags ( ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID ) ; holder . addChangePayload ( null ) ; } } if ( mAdapter == null || ! mAdapter . hasStableIds ( ) ) { recycleAndClearCachedViews ( ) ; } } void clearOldPositions ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; holder . clearOldPosition ( ) ; } final int scrapCount = mAttachedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < scrapCount ; i ++ ) { mAttachedScrap . get ( i ) . clearOldPosition ( ) ; } if ( mChangedScrap != null ) { final int changedScrapCount = mChangedScrap . size ( ) ; for ( int i = <NUM_LIT> ; i < changedScrapCount ; i ++ ) { mChangedScrap . get ( i ) . clearOldPosition ( ) ; } } } void markItemDecorInsetsDirty ( ) { final int cachedCount = mCachedViews . size ( ) ; for ( int i = <NUM_LIT> ; i < cachedCount ; i ++ ) { final ViewHolder holder = mCachedViews . get ( i ) ; LayoutParams layoutParams = ( LayoutParams ) holder . itemView . getLayoutParams ( ) ; if ( layoutParams != null ) { layoutParams . mInsetsDirty = true ; } } } } public abstract static class ViewCacheExtension { @ Nullable public abstract View getViewForPositionAndType ( @ NonNull Recycler recycler , int position , int type ) ; } public abstract static class Adapter < VH extends ViewHolder > { private final AdapterDataObservable mObservable = new AdapterDataObservable ( ) ; private boolean mHasStableIds = false ; private StateRestorationPolicy mStateRestorationPolicy = StateRestorationPolicy . ALLOW ; @ NonNull public abstract VH onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) ; public abstract void onBindViewHolder ( @ NonNull VH holder , int position ) ; public void onBindViewHolder ( @ NonNull VH holder , int position , @ NonNull List < Object > payloads ) { onBindViewHolder ( holder , position ) ; } public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { if ( adapter == this ) { return localPosition ; } return NO_POSITION ; } @ NonNull public final VH createViewHolder ( @ NonNull ViewGroup parent , int viewType ) { try { TraceCompat . beginSection ( TRACE_CREATE_VIEW_TAG ) ; final VH holder = onCreateViewHolder ( parent , viewType ) ; if ( holder . itemView . getParent ( ) != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } holder . mItemViewType = viewType ; return holder ; } finally { TraceCompat . endSection ( ) ; } } public final void bindViewHolder ( @ NonNull VH holder , int position ) { boolean rootBind = holder . mBindingAdapter == null ; if ( rootBind ) { holder . mPosition = position ; if ( hasStableIds ( ) ) { holder . mItemId = getItemId ( position ) ; } holder . setFlags ( ViewHolder . FLAG_BOUND , ViewHolder . FLAG_BOUND | ViewHolder . FLAG_UPDATE | ViewHolder . FLAG_INVALID | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) ; TraceCompat . beginSection ( TRACE_BIND_VIEW_TAG ) ; } holder . mBindingAdapter = this ; if ( sDebugAssertionsEnabled ) { if ( holder . itemView . getParent ( ) == null && ( ViewCompat . isAttachedToWindow ( holder . itemView ) != holder . isTmpDetached ( ) ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder . isTmpDetached ( ) + "<STR_LIT>" + ViewCompat . isAttachedToWindow ( holder . itemView ) + "<STR_LIT>" + holder ) ; } if ( holder . itemView . getParent ( ) == null && ViewCompat . isAttachedToWindow ( holder . itemView ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + holder ) ; } } onBindViewHolder ( holder , position , holder . getUnmodifiedPayloads ( ) ) ; if ( rootBind ) { holder . clearPayload ( ) ; final ViewGroup . LayoutParams layoutParams = holder . itemView . getLayoutParams ( ) ; if ( layoutParams instanceof RecyclerView . LayoutParams ) { ( ( LayoutParams ) layoutParams ) . mInsetsDirty = true ; } TraceCompat . endSection ( ) ; } } public int getItemViewType ( int position ) { return <NUM_LIT> ; } public void setHasStableIds ( boolean hasStableIds ) { if ( hasObservers ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mHasStableIds = hasStableIds ; } public long getItemId ( int position ) { return NO_ID ; } public abstract int getItemCount ( ) ; public final boolean hasStableIds ( ) { return mHasStableIds ; } public void onViewRecycled ( @ NonNull VH holder ) { } public boolean onFailedToRecycleView ( @ NonNull VH holder ) { return false ; } public void onViewAttachedToWindow ( @ NonNull VH holder ) { } public void onViewDetachedFromWindow ( @ NonNull VH holder ) { } public final boolean hasObservers ( ) { return mObservable . hasObservers ( ) ; } public void registerAdapterDataObserver ( @ NonNull AdapterDataObserver observer ) { mObservable . registerObserver ( observer ) ; } public void unregisterAdapterDataObserver ( @ NonNull AdapterDataObserver observer ) { mObservable . unregisterObserver ( observer ) ; } public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { } public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { } public final void notifyDataSetChanged ( ) { mObservable . notifyChanged ( ) ; } public final void notifyItemChanged ( int position ) { mObservable . notifyItemRangeChanged ( position , <NUM_LIT> ) ; } public final void notifyItemChanged ( int position , @ Nullable Object payload ) { mObservable . notifyItemRangeChanged ( position , <NUM_LIT> , payload ) ; } public final void notifyItemRangeChanged ( int positionStart , int itemCount ) { mObservable . notifyItemRangeChanged ( positionStart , itemCount ) ; } public final void notifyItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mObservable . notifyItemRangeChanged ( positionStart , itemCount , payload ) ; } public final void notifyItemInserted ( int position ) { mObservable . notifyItemRangeInserted ( position , <NUM_LIT> ) ; } public final void notifyItemMoved ( int fromPosition , int toPosition ) { mObservable . notifyItemMoved ( fromPosition , toPosition ) ; } public final void notifyItemRangeInserted ( int positionStart , int itemCount ) { mObservable . notifyItemRangeInserted ( positionStart , itemCount ) ; } public final void notifyItemRemoved ( int position ) { mObservable . notifyItemRangeRemoved ( position , <NUM_LIT> ) ; } public final void notifyItemRangeRemoved ( int positionStart , int itemCount ) { mObservable . notifyItemRangeRemoved ( positionStart , itemCount ) ; } public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { mStateRestorationPolicy = strategy ; mObservable . notifyStateRestorationPolicyChanged ( ) ; } @ NonNull public final StateRestorationPolicy getStateRestorationPolicy ( ) { return mStateRestorationPolicy ; } boolean canRestoreState ( ) { switch ( mStateRestorationPolicy ) { case PREVENT : return false ; case PREVENT_WHEN_EMPTY : return getItemCount ( ) > <NUM_LIT> ; default : return true ; } } public enum StateRestorationPolicy { ALLOW , PREVENT_WHEN_EMPTY , PREVENT } } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchChildDetached ( View child ) { final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; onChildDetachedFromWindow ( child ) ; if ( mAdapter != null && viewHolder != null ) { mAdapter . onViewDetachedFromWindow ( viewHolder ) ; } if ( mOnChildAttachStateListeners != null ) { final int cnt = mOnChildAttachStateListeners . size ( ) ; for ( int i = cnt - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mOnChildAttachStateListeners . get ( i ) . onChildViewDetachedFromWindow ( child ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) void dispatchChildAttached ( View child ) { final ViewHolder viewHolder = getChildViewHolderInt ( child ) ; onChildAttachedToWindow ( child ) ; if ( mAdapter != null && viewHolder != null ) { mAdapter . onViewAttachedToWindow ( viewHolder ) ; } if ( mOnChildAttachStateListeners != null ) { final int cnt = mOnChildAttachStateListeners . size ( ) ; for ( int i = cnt - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mOnChildAttachStateListeners . get ( i ) . onChildViewAttachedToWindow ( child ) ; } } } public abstract static class LayoutManager { ChildHelper mChildHelper ; RecyclerView mRecyclerView ; private final ViewBoundsCheck . Callback mHorizontalBoundCheckCallback = new ViewBoundsCheck . Callback ( ) { @ Override public View getChildAt ( int index ) { return LayoutManager . this . getChildAt ( index ) ; } @ Override public int getParentStart ( ) { return LayoutManager . this . getPaddingLeft ( ) ; } @ Override public int getParentEnd ( ) { return LayoutManager . this . getWidth ( ) - LayoutManager . this . getPaddingRight ( ) ; } @ Override public int getChildStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getChildEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedRight ( view ) + params . rightMargin ; } } ; private final ViewBoundsCheck . Callback mVerticalBoundCheckCallback = new ViewBoundsCheck . Callback ( ) { @ Override public View getChildAt ( int index ) { return LayoutManager . this . getChildAt ( index ) ; } @ Override public int getParentStart ( ) { return LayoutManager . this . getPaddingTop ( ) ; } @ Override public int getParentEnd ( ) { return LayoutManager . this . getHeight ( ) - LayoutManager . this . getPaddingBottom ( ) ; } @ Override public int getChildStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedTop ( view ) - params . topMargin ; } @ Override public int getChildEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return LayoutManager . this . getDecoratedBottom ( view ) + params . bottomMargin ; } } ; ViewBoundsCheck mHorizontalBoundCheck = new ViewBoundsCheck ( mHorizontalBoundCheckCallback ) ; ViewBoundsCheck mVerticalBoundCheck = new ViewBoundsCheck ( mVerticalBoundCheckCallback ) ; @ Nullable SmoothScroller mSmoothScroller ; boolean mRequestedSimpleAnimations = false ; boolean mIsAttachedToWindow = false ; boolean mAutoMeasure = false ; private boolean mMeasurementCacheEnabled = true ; private boolean mItemPrefetchEnabled = true ; int mPrefetchMaxCountObserved ; boolean mPrefetchMaxObservedInInitialPrefetch ; private int mWidthMode , mHeightMode ; private int mWidth , mHeight ; public interface LayoutPrefetchRegistry { void addPosition ( int layoutPosition , int pixelDistance ) ; } void setRecyclerView ( RecyclerView recyclerView ) { if ( recyclerView == null ) { mRecyclerView = null ; mChildHelper = null ; mWidth = <NUM_LIT> ; mHeight = <NUM_LIT> ; } else { mRecyclerView = recyclerView ; mChildHelper = recyclerView . mChildHelper ; mWidth = recyclerView . getWidth ( ) ; mHeight = recyclerView . getHeight ( ) ; } mWidthMode = MeasureSpec . EXACTLY ; mHeightMode = MeasureSpec . EXACTLY ; } void setMeasureSpecs ( int wSpec , int hSpec ) { mWidth = MeasureSpec . getSize ( wSpec ) ; mWidthMode = MeasureSpec . getMode ( wSpec ) ; if ( mWidthMode == MeasureSpec . UNSPECIFIED && ! ALLOW_SIZE_IN_UNSPECIFIED_SPEC ) { mWidth = <NUM_LIT> ; } mHeight = MeasureSpec . getSize ( hSpec ) ; mHeightMode = MeasureSpec . getMode ( hSpec ) ; if ( mHeightMode == MeasureSpec . UNSPECIFIED && ! ALLOW_SIZE_IN_UNSPECIFIED_SPEC ) { mHeight = <NUM_LIT> ; } } void setMeasuredDimensionFromChildren ( int widthSpec , int heightSpec ) { final int count = getChildCount ( ) ; if ( count == <NUM_LIT> ) { mRecyclerView . defaultOnMeasure ( widthSpec , heightSpec ) ; return ; } int minX = Integer . MAX_VALUE ; int minY = Integer . MAX_VALUE ; int maxX = Integer . MIN_VALUE ; int maxY = Integer . MIN_VALUE ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View child = getChildAt ( i ) ; final Rect bounds = mRecyclerView . mTempRect ; getDecoratedBoundsWithMargins ( child , bounds ) ; if ( bounds . left < minX ) { minX = bounds . left ; } if ( bounds . right > maxX ) { maxX = bounds . right ; } if ( bounds . top < minY ) { minY = bounds . top ; } if ( bounds . bottom > maxY ) { maxY = bounds . bottom ; } } mRecyclerView . mTempRect . set ( minX , minY , maxX , maxY ) ; setMeasuredDimension ( mRecyclerView . mTempRect , widthSpec , heightSpec ) ; } public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { int usedWidth = childrenBounds . width ( ) + getPaddingLeft ( ) + getPaddingRight ( ) ; int usedHeight = childrenBounds . height ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; int width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; int height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; setMeasuredDimension ( width , height ) ; } public void requestLayout ( ) { if ( mRecyclerView != null ) { mRecyclerView . requestLayout ( ) ; } } public void assertInLayoutOrScroll ( String message ) { if ( mRecyclerView != null ) { mRecyclerView . assertInLayoutOrScroll ( message ) ; } } public static int chooseSize ( int spec , int desired , int min ) { final int mode = View . MeasureSpec . getMode ( spec ) ; final int size = View . MeasureSpec . getSize ( spec ) ; switch ( mode ) { case View . MeasureSpec . EXACTLY : return size ; case View . MeasureSpec . AT_MOST : return Math . min ( size , Math . max ( desired , min ) ) ; case View . MeasureSpec . UNSPECIFIED : default : return Math . max ( desired , min ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void assertNotInLayoutOrScroll ( String message ) { if ( mRecyclerView != null ) { mRecyclerView . assertNotInLayoutOrScroll ( message ) ; } } @ Deprecated public void setAutoMeasureEnabled ( boolean enabled ) { mAutoMeasure = enabled ; } public boolean isAutoMeasureEnabled ( ) { return mAutoMeasure ; } public boolean supportsPredictiveItemAnimations ( ) { return false ; } public final void setItemPrefetchEnabled ( boolean enabled ) { if ( enabled != mItemPrefetchEnabled ) { mItemPrefetchEnabled = enabled ; mPrefetchMaxCountObserved = <NUM_LIT> ; if ( mRecyclerView != null ) { mRecyclerView . mRecycler . updateViewCacheSize ( ) ; } } } public final boolean isItemPrefetchEnabled ( ) { return mItemPrefetchEnabled ; } @ SuppressLint ( "<STR_LIT>" ) public void collectAdjacentPrefetchPositions ( int dx , int dy , State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { } @ SuppressLint ( "<STR_LIT>" ) public void collectInitialPrefetchPositions ( int adapterItemCount , LayoutPrefetchRegistry layoutPrefetchRegistry ) { } void dispatchAttachedToWindow ( RecyclerView view ) { mIsAttachedToWindow = true ; onAttachedToWindow ( view ) ; } void dispatchDetachedFromWindow ( RecyclerView view , Recycler recycler ) { mIsAttachedToWindow = false ; onDetachedFromWindow ( view , recycler ) ; } public boolean isAttachedToWindow ( ) { return mIsAttachedToWindow ; } public void postOnAnimation ( Runnable action ) { if ( mRecyclerView != null ) { ViewCompat . postOnAnimation ( mRecyclerView , action ) ; } } public boolean removeCallbacks ( Runnable action ) { if ( mRecyclerView != null ) { return mRecyclerView . removeCallbacks ( action ) ; } return false ; } @ CallSuper public void onAttachedToWindow ( RecyclerView view ) { } @ Deprecated public void onDetachedFromWindow ( RecyclerView view ) { } @ CallSuper @ SuppressLint ( "<STR_LIT>" ) public void onDetachedFromWindow ( RecyclerView view , Recycler recycler ) { onDetachedFromWindow ( view ) ; } public boolean getClipToPadding ( ) { return mRecyclerView != null && mRecyclerView . mClipToPadding ; } @ SuppressLint ( "<STR_LIT>" ) public void onLayoutChildren ( Recycler recycler , State state ) { Log . e ( TAG , "<STR_LIT>" ) ; } @ SuppressLint ( "<STR_LIT>" ) public void onLayoutCompleted ( State state ) { } @ SuppressLint ( "<STR_LIT>" ) public abstract LayoutParams generateDefaultLayoutParams ( ) ; public boolean checkLayoutParams ( LayoutParams lp ) { return lp != null ; } @ SuppressLint ( "<STR_LIT>" ) public LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof LayoutParams ) { return new LayoutParams ( ( LayoutParams ) lp ) ; } else if ( lp instanceof MarginLayoutParams ) { return new LayoutParams ( ( MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ SuppressLint ( "<STR_LIT>" ) public LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ SuppressLint ( "<STR_LIT>" ) public int scrollHorizontallyBy ( int dx , Recycler recycler , State state ) { return <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public int scrollVerticallyBy ( int dy , Recycler recycler , State state ) { return <NUM_LIT> ; } public boolean canScrollHorizontally ( ) { return false ; } public boolean canScrollVertically ( ) { return false ; } public void scrollToPosition ( int position ) { if ( sVerboseLoggingEnabled ) { Log . e ( TAG , "<STR_LIT>" ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void smoothScrollToPosition ( RecyclerView recyclerView , State state , int position ) { Log . e ( TAG , "<STR_LIT>" ) ; } @ SuppressLint ( "<STR_LIT>" ) public void startSmoothScroll ( SmoothScroller smoothScroller ) { if ( mSmoothScroller != null && smoothScroller != mSmoothScroller && mSmoothScroller . isRunning ( ) ) { mSmoothScroller . stop ( ) ; } mSmoothScroller = smoothScroller ; mSmoothScroller . start ( mRecyclerView , this ) ; } public boolean isSmoothScrolling ( ) { return mSmoothScroller != null && mSmoothScroller . isRunning ( ) ; } public int getLayoutDirection ( ) { return ViewCompat . getLayoutDirection ( mRecyclerView ) ; } @ SuppressLint ( "<STR_LIT>" ) public void endAnimation ( View view ) { if ( mRecyclerView . mItemAnimator != null ) { mRecyclerView . mItemAnimator . endAnimation ( getChildViewHolderInt ( view ) ) ; } } @ SuppressLint ( "<STR_LIT>" ) public void addDisappearingView ( View child ) { addDisappearingView ( child , - <NUM_LIT> ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addDisappearingView ( View child , int index ) { addViewInt ( child , index , true ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addView ( View child ) { addView ( child , - <NUM_LIT> ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addView ( View child , int index ) { addViewInt ( child , index , false ) ; } private void addViewInt ( View child , int index , boolean disappearing ) { final ViewHolder holder = getChildViewHolderInt ( child ) ; if ( disappearing || holder . isRemoved ( ) ) { mRecyclerView . mViewInfoStore . addToDisappearedInLayout ( holder ) ; } else { mRecyclerView . mViewInfoStore . removeFromDisappearedInLayout ( holder ) ; } final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( holder . wasReturnedFromScrap ( ) || holder . isScrap ( ) ) { if ( holder . isScrap ( ) ) { holder . unScrap ( ) ; } else { holder . clearReturnedFromScrapFlag ( ) ; } mChildHelper . attachViewToParent ( child , index , child . getLayoutParams ( ) , false ) ; if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchFinishTemporaryDetach ( child ) ; } } else if ( child . getParent ( ) == mRecyclerView ) { int currentIndex = mChildHelper . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { index = mChildHelper . getChildCount ( ) ; } if ( currentIndex == - <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + mRecyclerView . indexOfChild ( child ) + mRecyclerView . exceptionLabel ( ) ) ; } if ( currentIndex != index ) { mRecyclerView . mLayout . moveView ( currentIndex , index ) ; } } else { mChildHelper . addView ( child , index , false ) ; lp . mInsetsDirty = true ; if ( mSmoothScroller != null && mSmoothScroller . isRunning ( ) ) { mSmoothScroller . onChildAttachedToWindow ( child ) ; } } if ( lp . mPendingInvalidate ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + lp . mViewHolder ) ; } holder . itemView . invalidate ( ) ; lp . mPendingInvalidate = false ; } } @ SuppressLint ( "<STR_LIT>" ) public void removeView ( View child ) { mChildHelper . removeView ( child ) ; } public void removeViewAt ( int index ) { final View child = getChildAt ( index ) ; if ( child != null ) { mChildHelper . removeViewAt ( index ) ; } } public void removeAllViews ( ) { final int childCount = getChildCount ( ) ; for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mChildHelper . removeViewAt ( i ) ; } } public int getBaseline ( ) { return - <NUM_LIT> ; } public int getPosition ( @ NonNull View view ) { return ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . getViewLayoutPosition ( ) ; } public int getItemViewType ( @ NonNull View view ) { return getChildViewHolderInt ( view ) . getItemViewType ( ) ; } @ Nullable public View findContainingItemView ( @ NonNull View view ) { if ( mRecyclerView == null ) { return null ; } View found = mRecyclerView . findContainingItemView ( view ) ; if ( found == null ) { return null ; } if ( mChildHelper . isHidden ( found ) ) { return null ; } return found ; } @ Nullable public View findViewByPosition ( int position ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh == null ) { continue ; } if ( vh . getLayoutPosition ( ) == position && ! vh . shouldIgnore ( ) && ( mRecyclerView . mState . isPreLayout ( ) || ! vh . isRemoved ( ) ) ) { return child ; } } return null ; } public void detachView ( @ NonNull View child ) { final int ind = mChildHelper . indexOfChild ( child ) ; if ( ind >= <NUM_LIT> ) { detachViewInternal ( ind , child ) ; } } public void detachViewAt ( int index ) { detachViewInternal ( index , getChildAt ( index ) ) ; } private void detachViewInternal ( int index , @ NonNull View view ) { if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchStartTemporaryDetach ( view ) ; } mChildHelper . detachViewFromParent ( index ) ; } public void attachView ( @ NonNull View child , int index , LayoutParams lp ) { ViewHolder vh = getChildViewHolderInt ( child ) ; if ( vh . isRemoved ( ) ) { mRecyclerView . mViewInfoStore . addToDisappearedInLayout ( vh ) ; } else { mRecyclerView . mViewInfoStore . removeFromDisappearedInLayout ( vh ) ; } mChildHelper . attachViewToParent ( child , index , lp , vh . isRemoved ( ) ) ; if ( DISPATCH_TEMP_DETACH ) { ViewCompat . dispatchFinishTemporaryDetach ( child ) ; } } public void attachView ( @ NonNull View child , int index ) { attachView ( child , index , ( LayoutParams ) child . getLayoutParams ( ) ) ; } public void attachView ( @ NonNull View child ) { attachView ( child , - <NUM_LIT> ) ; } public void removeDetachedView ( @ NonNull View child ) { mRecyclerView . removeDetachedView ( child , false ) ; } public void moveView ( int fromIndex , int toIndex ) { View view = getChildAt ( fromIndex ) ; if ( view == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + fromIndex + mRecyclerView . toString ( ) ) ; } detachViewAt ( fromIndex ) ; attachView ( view , toIndex ) ; } public void detachAndScrapView ( @ NonNull View child , @ NonNull Recycler recycler ) { int index = mChildHelper . indexOfChild ( child ) ; scrapOrRecycleView ( recycler , index , child ) ; } public void detachAndScrapViewAt ( int index , @ NonNull Recycler recycler ) { final View child = getChildAt ( index ) ; scrapOrRecycleView ( recycler , index , child ) ; } public void removeAndRecycleView ( @ NonNull View child , @ NonNull Recycler recycler ) { removeView ( child ) ; recycler . recycleView ( child ) ; } public void removeAndRecycleViewAt ( int index , @ NonNull Recycler recycler ) { final View view = getChildAt ( index ) ; removeViewAt ( index ) ; recycler . recycleView ( view ) ; } public int getChildCount ( ) { return mChildHelper != null ? mChildHelper . getChildCount ( ) : <NUM_LIT> ; } @ Nullable public View getChildAt ( int index ) { return mChildHelper != null ? mChildHelper . getChildAt ( index ) : null ; } public int getWidthMode ( ) { return mWidthMode ; } public int getHeightMode ( ) { return mHeightMode ; } @ Px public int getWidth ( ) { return mWidth ; } @ Px public int getHeight ( ) { return mHeight ; } @ Px public int getPaddingLeft ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingLeft ( ) : <NUM_LIT> ; } @ Px public int getPaddingTop ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingTop ( ) : <NUM_LIT> ; } @ Px public int getPaddingRight ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingRight ( ) : <NUM_LIT> ; } @ Px public int getPaddingBottom ( ) { return mRecyclerView != null ? mRecyclerView . getPaddingBottom ( ) : <NUM_LIT> ; } @ Px public int getPaddingStart ( ) { return mRecyclerView != null ? ViewCompat . getPaddingStart ( mRecyclerView ) : <NUM_LIT> ; } @ Px public int getPaddingEnd ( ) { return mRecyclerView != null ? ViewCompat . getPaddingEnd ( mRecyclerView ) : <NUM_LIT> ; } public boolean isFocused ( ) { return mRecyclerView != null && mRecyclerView . isFocused ( ) ; } public boolean hasFocus ( ) { return mRecyclerView != null && mRecyclerView . hasFocus ( ) ; } @ Nullable public View getFocusedChild ( ) { if ( mRecyclerView == null ) { return null ; } final View focused = mRecyclerView . getFocusedChild ( ) ; if ( focused == null || mChildHelper . isHidden ( focused ) ) { return null ; } return focused ; } public int getItemCount ( ) { final Adapter a = mRecyclerView != null ? mRecyclerView . getAdapter ( ) : null ; return a != null ? a . getItemCount ( ) : <NUM_LIT> ; } public void offsetChildrenHorizontal ( @ Px int dx ) { if ( mRecyclerView != null ) { mRecyclerView . offsetChildrenHorizontal ( dx ) ; } } public void offsetChildrenVertical ( @ Px int dy ) { if ( mRecyclerView != null ) { mRecyclerView . offsetChildrenVertical ( dy ) ; } } public void ignoreView ( @ NonNull View view ) { if ( view . getParent ( ) != mRecyclerView || mRecyclerView . indexOfChild ( view ) == - <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + mRecyclerView . exceptionLabel ( ) ) ; } final ViewHolder vh = getChildViewHolderInt ( view ) ; vh . addFlags ( ViewHolder . FLAG_IGNORE ) ; mRecyclerView . mViewInfoStore . removeViewHolder ( vh ) ; } public void stopIgnoringView ( @ NonNull View view ) { final ViewHolder vh = getChildViewHolderInt ( view ) ; vh . stopIgnoring ( ) ; vh . resetInternal ( ) ; vh . addFlags ( ViewHolder . FLAG_INVALID ) ; } public void detachAndScrapAttachedViews ( @ NonNull Recycler recycler ) { final int childCount = getChildCount ( ) ; for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View v = getChildAt ( i ) ; scrapOrRecycleView ( recycler , i , v ) ; } } private void scrapOrRecycleView ( Recycler recycler , int index , View view ) { final ViewHolder viewHolder = getChildViewHolderInt ( view ) ; if ( viewHolder . shouldIgnore ( ) ) { if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + viewHolder ) ; } return ; } if ( viewHolder . isInvalid ( ) && ! viewHolder . isRemoved ( ) && ! mRecyclerView . mAdapter . hasStableIds ( ) ) { removeViewAt ( index ) ; recycler . recycleViewHolderInternal ( viewHolder ) ; } else { detachViewAt ( index ) ; recycler . scrapView ( view ) ; mRecyclerView . mViewInfoStore . onViewDetached ( viewHolder ) ; } } void removeAndRecycleScrapInt ( Recycler recycler ) { final int scrapCount = recycler . getScrapCount ( ) ; for ( int i = scrapCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View scrap = recycler . getScrapViewAt ( i ) ; final ViewHolder vh = getChildViewHolderInt ( scrap ) ; if ( vh . shouldIgnore ( ) ) { continue ; } vh . setIsRecyclable ( false ) ; if ( vh . isTmpDetached ( ) ) { mRecyclerView . removeDetachedView ( scrap , false ) ; } if ( mRecyclerView . mItemAnimator != null ) { mRecyclerView . mItemAnimator . endAnimation ( vh ) ; } vh . setIsRecyclable ( true ) ; recycler . quickRecycleScrapView ( scrap ) ; } recycler . clearScrap ( ) ; if ( scrapCount > <NUM_LIT> ) { mRecyclerView . invalidate ( ) ; } } public void measureChild ( @ NonNull View child , int widthUsed , int heightUsed ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; widthUsed += insets . left + insets . right ; heightUsed += insets . top + insets . bottom ; final int widthSpec = getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) + widthUsed , lp . width , canScrollHorizontally ( ) ) ; final int heightSpec = getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) + heightUsed , lp . height , canScrollVertically ( ) ) ; if ( shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ) { child . measure ( widthSpec , heightSpec ) ; } } boolean shouldReMeasureChild ( View child , int widthSpec , int heightSpec , LayoutParams lp ) { return ! mMeasurementCacheEnabled || ! isMeasurementUpToDate ( child . getMeasuredWidth ( ) , widthSpec , lp . width ) || ! isMeasurementUpToDate ( child . getMeasuredHeight ( ) , heightSpec , lp . height ) ; } boolean shouldMeasureChild ( View child , int widthSpec , int heightSpec , LayoutParams lp ) { return child . isLayoutRequested ( ) || ! mMeasurementCacheEnabled || ! isMeasurementUpToDate ( child . getWidth ( ) , widthSpec , lp . width ) || ! isMeasurementUpToDate ( child . getHeight ( ) , heightSpec , lp . height ) ; } public boolean isMeasurementCacheEnabled ( ) { return mMeasurementCacheEnabled ; } public void setMeasurementCacheEnabled ( boolean measurementCacheEnabled ) { mMeasurementCacheEnabled = measurementCacheEnabled ; } private static boolean isMeasurementUpToDate ( int childSize , int spec , int dimension ) { final int specMode = MeasureSpec . getMode ( spec ) ; final int specSize = MeasureSpec . getSize ( spec ) ; if ( dimension > <NUM_LIT> && childSize != dimension ) { return false ; } switch ( specMode ) { case MeasureSpec . UNSPECIFIED : return true ; case MeasureSpec . AT_MOST : return specSize >= childSize ; case MeasureSpec . EXACTLY : return specSize == childSize ; } return false ; } public void measureChildWithMargins ( @ NonNull View child , int widthUsed , int heightUsed ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; widthUsed += insets . left + insets . right ; heightUsed += insets . top + insets . bottom ; final int widthSpec = getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) + lp . leftMargin + lp . rightMargin + widthUsed , lp . width , canScrollHorizontally ( ) ) ; final int heightSpec = getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) + lp . topMargin + lp . bottomMargin + heightUsed , lp . height , canScrollVertically ( ) ) ; if ( shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ) { child . measure ( widthSpec , heightSpec ) ; } } @ Deprecated public static int getChildMeasureSpec ( int parentSize , int padding , int childDimension , boolean canScroll ) { int size = Math . max ( <NUM_LIT> , parentSize - padding ) ; int resultSize = <NUM_LIT> ; int resultMode = <NUM_LIT> ; if ( canScroll ) { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else { resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; } } else { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { resultSize = size ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = size ; resultMode = MeasureSpec . AT_MOST ; } } return MeasureSpec . makeMeasureSpec ( resultSize , resultMode ) ; } public static int getChildMeasureSpec ( int parentSize , int parentMode , int padding , int childDimension , boolean canScroll ) { int size = Math . max ( <NUM_LIT> , parentSize - padding ) ; int resultSize = <NUM_LIT> ; int resultMode = <NUM_LIT> ; if ( canScroll ) { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { switch ( parentMode ) { case MeasureSpec . AT_MOST : case MeasureSpec . EXACTLY : resultSize = size ; resultMode = parentMode ; break ; case MeasureSpec . UNSPECIFIED : resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; break ; } } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = <NUM_LIT> ; resultMode = MeasureSpec . UNSPECIFIED ; } } else { if ( childDimension >= <NUM_LIT> ) { resultSize = childDimension ; resultMode = MeasureSpec . EXACTLY ; } else if ( childDimension == LayoutParams . MATCH_PARENT ) { resultSize = size ; resultMode = parentMode ; } else if ( childDimension == LayoutParams . WRAP_CONTENT ) { resultSize = size ; if ( parentMode == MeasureSpec . AT_MOST || parentMode == MeasureSpec . EXACTLY ) { resultMode = MeasureSpec . AT_MOST ; } else { resultMode = MeasureSpec . UNSPECIFIED ; } } } return MeasureSpec . makeMeasureSpec ( resultSize , resultMode ) ; } public int getDecoratedMeasuredWidth ( @ NonNull View child ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; return child . getMeasuredWidth ( ) + insets . left + insets . right ; } public int getDecoratedMeasuredHeight ( @ NonNull View child ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; return child . getMeasuredHeight ( ) + insets . top + insets . bottom ; } public void layoutDecorated ( @ NonNull View child , int left , int top , int right , int bottom ) { final Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; child . layout ( left + insets . left , top + insets . top , right - insets . right , bottom - insets . bottom ) ; } public void layoutDecoratedWithMargins ( @ NonNull View child , int left , int top , int right , int bottom ) { final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final Rect insets = lp . mDecorInsets ; child . layout ( left + insets . left + lp . leftMargin , top + insets . top + lp . topMargin , right - insets . right - lp . rightMargin , bottom - insets . bottom - lp . bottomMargin ) ; } public void getTransformedBoundingBox ( @ NonNull View child , boolean includeDecorInsets , @ NonNull Rect out ) { if ( includeDecorInsets ) { Rect insets = ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets ; out . set ( - insets . left , - insets . top , child . getWidth ( ) + insets . right , child . getHeight ( ) + insets . bottom ) ; } else { out . set ( <NUM_LIT> , <NUM_LIT> , child . getWidth ( ) , child . getHeight ( ) ) ; } if ( mRecyclerView != null ) { final Matrix childMatrix = child . getMatrix ( ) ; if ( childMatrix != null && ! childMatrix . isIdentity ( ) ) { final RectF tempRectF = mRecyclerView . mTempRectF ; tempRectF . set ( out ) ; childMatrix . mapRect ( tempRectF ) ; out . set ( ( int ) Math . floor ( tempRectF . left ) , ( int ) Math . floor ( tempRectF . top ) , ( int ) Math . ceil ( tempRectF . right ) , ( int ) Math . ceil ( tempRectF . bottom ) ) ; } } out . offset ( child . getLeft ( ) , child . getTop ( ) ) ; } public void getDecoratedBoundsWithMargins ( @ NonNull View view , @ NonNull Rect outBounds ) { RecyclerView . getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } public int getDecoratedLeft ( @ NonNull View child ) { return child . getLeft ( ) - getLeftDecorationWidth ( child ) ; } public int getDecoratedTop ( @ NonNull View child ) { return child . getTop ( ) - getTopDecorationHeight ( child ) ; } public int getDecoratedRight ( @ NonNull View child ) { return child . getRight ( ) + getRightDecorationWidth ( child ) ; } public int getDecoratedBottom ( @ NonNull View child ) { return child . getBottom ( ) + getBottomDecorationHeight ( child ) ; } public void calculateItemDecorationsForChild ( @ NonNull View child , @ NonNull Rect outRect ) { if ( mRecyclerView == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } Rect insets = mRecyclerView . getItemDecorInsetsForChild ( child ) ; outRect . set ( insets ) ; } public int getTopDecorationHeight ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . top ; } public int getBottomDecorationHeight ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . bottom ; } public int getLeftDecorationWidth ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . left ; } public int getRightDecorationWidth ( @ NonNull View child ) { return ( ( LayoutParams ) child . getLayoutParams ( ) ) . mDecorInsets . right ; } @ Nullable public View onFocusSearchFailed ( @ NonNull View focused , int direction , @ NonNull Recycler recycler , @ NonNull State state ) { return null ; } @ Nullable public View onInterceptFocusSearch ( @ NonNull View focused , int direction ) { return null ; } private int [ ] getChildRectangleOnScreenScrollAmount ( View child , Rect rect ) { int [ ] out = new int [ <NUM_LIT> ] ; final int parentLeft = getPaddingLeft ( ) ; final int parentTop = getPaddingTop ( ) ; final int parentRight = getWidth ( ) - getPaddingRight ( ) ; final int parentBottom = getHeight ( ) - getPaddingBottom ( ) ; final int childLeft = child . getLeft ( ) + rect . left - child . getScrollX ( ) ; final int childTop = child . getTop ( ) + rect . top - child . getScrollY ( ) ; final int childRight = childLeft + rect . width ( ) ; final int childBottom = childTop + rect . height ( ) ; final int offScreenLeft = Math . min ( <NUM_LIT> , childLeft - parentLeft ) ; final int offScreenTop = Math . min ( <NUM_LIT> , childTop - parentTop ) ; final int offScreenRight = Math . max ( <NUM_LIT> , childRight - parentRight ) ; final int offScreenBottom = Math . max ( <NUM_LIT> , childBottom - parentBottom ) ; final int dx ; if ( getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ) { dx = offScreenRight != <NUM_LIT> ? offScreenRight : Math . max ( offScreenLeft , childRight - parentRight ) ; } else { dx = offScreenLeft != <NUM_LIT> ? offScreenLeft : Math . min ( childLeft - parentLeft , offScreenRight ) ; } final int dy = offScreenTop != <NUM_LIT> ? offScreenTop : Math . min ( childTop - parentTop , offScreenBottom ) ; out [ <NUM_LIT> ] = dx ; out [ <NUM_LIT> ] = dy ; return out ; } public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate ) { return requestChildRectangleOnScreen ( parent , child , rect , immediate , false ) ; } public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate , boolean focusedChildVisible ) { int [ ] scrollAmount = getChildRectangleOnScreenScrollAmount ( child , rect ) ; int dx = scrollAmount [ <NUM_LIT> ] ; int dy = scrollAmount [ <NUM_LIT> ] ; if ( ! focusedChildVisible || isFocusedChildVisibleAfterScrolling ( parent , dx , dy ) ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { if ( immediate ) { parent . scrollBy ( dx , dy ) ; } else { parent . smoothScrollBy ( dx , dy ) ; } return true ; } } return false ; } public boolean isViewPartiallyVisible ( @ NonNull View child , boolean completelyVisible , boolean acceptEndPointInclusion ) { int boundsFlag = ( ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_EQ_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_EQ_PVE ) ; boolean isViewFullyVisible = mHorizontalBoundCheck . isViewWithinBoundFlags ( child , boundsFlag ) && mVerticalBoundCheck . isViewWithinBoundFlags ( child , boundsFlag ) ; if ( completelyVisible ) { return isViewFullyVisible ; } else { return ! isViewFullyVisible ; } } private boolean isFocusedChildVisibleAfterScrolling ( RecyclerView parent , int dx , int dy ) { final View focusedChild = parent . getFocusedChild ( ) ; if ( focusedChild == null ) { return false ; } final int parentLeft = getPaddingLeft ( ) ; final int parentTop = getPaddingTop ( ) ; final int parentRight = getWidth ( ) - getPaddingRight ( ) ; final int parentBottom = getHeight ( ) - getPaddingBottom ( ) ; final Rect bounds = mRecyclerView . mTempRect ; getDecoratedBoundsWithMargins ( focusedChild , bounds ) ; if ( bounds . left - dx >= parentRight || bounds . right - dx <= parentLeft || bounds . top - dy >= parentBottom || bounds . bottom - dy <= parentTop ) { return false ; } return true ; } @ Deprecated public boolean onRequestChildFocus ( @ NonNull RecyclerView parent , @ NonNull View child , @ Nullable View focused ) { return isSmoothScrolling ( ) || parent . isComputingLayout ( ) ; } public boolean onRequestChildFocus ( @ NonNull RecyclerView parent , @ NonNull State state , @ NonNull View child , @ Nullable View focused ) { return onRequestChildFocus ( parent , child , focused ) ; } public void onAdapterChanged ( @ Nullable Adapter oldAdapter , @ Nullable Adapter newAdapter ) { } public boolean onAddFocusables ( @ NonNull RecyclerView recyclerView , @ NonNull ArrayList < View > views , int direction , int focusableMode ) { return false ; } public void onItemsChanged ( @ NonNull RecyclerView recyclerView ) { } public void onItemsAdded ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsRemoved ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsUpdated ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount ) { } public void onItemsUpdated ( @ NonNull RecyclerView recyclerView , int positionStart , int itemCount , @ Nullable Object payload ) { onItemsUpdated ( recyclerView , positionStart , itemCount ) ; } public void onItemsMoved ( @ NonNull RecyclerView recyclerView , int from , int to , int itemCount ) { } public int computeHorizontalScrollExtent ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeHorizontalScrollOffset ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeHorizontalScrollRange ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollExtent ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollOffset ( @ NonNull State state ) { return <NUM_LIT> ; } public int computeVerticalScrollRange ( @ NonNull State state ) { return <NUM_LIT> ; } public void onMeasure ( @ NonNull Recycler recycler , @ NonNull State state , int widthSpec , int heightSpec ) { mRecyclerView . defaultOnMeasure ( widthSpec , heightSpec ) ; } public void setMeasuredDimension ( int widthSize , int heightSize ) { mRecyclerView . setMeasuredDimension ( widthSize , heightSize ) ; } @ Px public int getMinimumWidth ( ) { return ViewCompat . getMinimumWidth ( mRecyclerView ) ; } @ Px public int getMinimumHeight ( ) { return ViewCompat . getMinimumHeight ( mRecyclerView ) ; } @ Nullable public Parcelable onSaveInstanceState ( ) { return null ; } @ SuppressLint ( "<STR_LIT>" ) public void onRestoreInstanceState ( Parcelable state ) { } void stopSmoothScroller ( ) { if ( mSmoothScroller != null ) { mSmoothScroller . stop ( ) ; } } void onSmoothScrollerStopped ( SmoothScroller smoothScroller ) { if ( mSmoothScroller == smoothScroller ) { mSmoothScroller = null ; } } public void onScrollStateChanged ( int state ) { } public void removeAndRecycleAllViews ( @ NonNull Recycler recycler ) { for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = getChildAt ( i ) ; if ( ! getChildViewHolderInt ( view ) . shouldIgnore ( ) ) { removeAndRecycleViewAt ( i , recycler ) ; } } } void onInitializeAccessibilityNodeInfo ( AccessibilityNodeInfoCompat info ) { onInitializeAccessibilityNodeInfo ( mRecyclerView . mRecycler , mRecyclerView . mState , info ) ; } public void onInitializeAccessibilityNodeInfo ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull AccessibilityNodeInfoCompat info ) { if ( mRecyclerView . canScrollVertically ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; info . setScrollable ( true ) ; } if ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; info . setScrollable ( true ) ; } final AccessibilityNodeInfoCompat . CollectionInfoCompat collectionInfo = AccessibilityNodeInfoCompat . CollectionInfoCompat . obtain ( getRowCountForAccessibility ( recycler , state ) , getColumnCountForAccessibility ( recycler , state ) , isLayoutHierarchical ( recycler , state ) , getSelectionModeForAccessibility ( recycler , state ) ) ; info . setCollectionInfo ( collectionInfo ) ; } public void onInitializeAccessibilityEvent ( @ NonNull AccessibilityEvent event ) { onInitializeAccessibilityEvent ( mRecyclerView . mRecycler , mRecyclerView . mState , event ) ; } public void onInitializeAccessibilityEvent ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull AccessibilityEvent event ) { if ( mRecyclerView == null || event == null ) { return ; } event . setScrollable ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) || mRecyclerView . canScrollVertically ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) || mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) ; if ( mRecyclerView . mAdapter != null ) { event . setItemCount ( mRecyclerView . mAdapter . getItemCount ( ) ) ; } } void onInitializeAccessibilityNodeInfoForItem ( View host , AccessibilityNodeInfoCompat info ) { final ViewHolder vh = getChildViewHolderInt ( host ) ; if ( vh != null && ! vh . isRemoved ( ) && ! mChildHelper . isHidden ( vh . itemView ) ) { onInitializeAccessibilityNodeInfoForItem ( mRecyclerView . mRecycler , mRecyclerView . mState , host , info ) ; } } public void onInitializeAccessibilityNodeInfoForItem ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull View host , @ NonNull AccessibilityNodeInfoCompat info ) { } public void requestSimpleAnimationsInNextLayout ( ) { mRequestedSimpleAnimations = true ; } public int getSelectionModeForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return AccessibilityNodeInfoCompat . CollectionInfoCompat . SELECTION_MODE_NONE ; } public int getRowCountForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return - <NUM_LIT> ; } public int getColumnCountForAccessibility ( @ NonNull Recycler recycler , @ NonNull State state ) { return - <NUM_LIT> ; } public boolean isLayoutHierarchical ( @ NonNull Recycler recycler , @ NonNull State state ) { return false ; } boolean performAccessibilityAction ( int action , @ Nullable Bundle args ) { return performAccessibilityAction ( mRecyclerView . mRecycler , mRecyclerView . mState , action , args ) ; } public boolean performAccessibilityAction ( @ NonNull Recycler recycler , @ NonNull State state , int action , @ Nullable Bundle args ) { if ( mRecyclerView == null ) { return false ; } int vScroll = <NUM_LIT> , hScroll = <NUM_LIT> ; int height = getHeight ( ) ; int width = getWidth ( ) ; Rect rect = new Rect ( ) ; if ( mRecyclerView . getMatrix ( ) . isIdentity ( ) && mRecyclerView . getGlobalVisibleRect ( rect ) ) { height = rect . height ( ) ; width = rect . width ( ) ; } switch ( action ) { case AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD : if ( mRecyclerView . canScrollVertically ( - <NUM_LIT> ) ) { vScroll = - ( height - getPaddingTop ( ) - getPaddingBottom ( ) ) ; } if ( mRecyclerView . canScrollHorizontally ( - <NUM_LIT> ) ) { hScroll = - ( width - getPaddingLeft ( ) - getPaddingRight ( ) ) ; } break ; case AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD : if ( mRecyclerView . canScrollVertically ( <NUM_LIT> ) ) { vScroll = height - getPaddingTop ( ) - getPaddingBottom ( ) ; } if ( mRecyclerView . canScrollHorizontally ( <NUM_LIT> ) ) { hScroll = width - getPaddingLeft ( ) - getPaddingRight ( ) ; } break ; } if ( vScroll == <NUM_LIT> && hScroll == <NUM_LIT> ) { return false ; } mRecyclerView . smoothScrollBy ( hScroll , vScroll , null , UNDEFINED_DURATION , true ) ; return true ; } boolean performAccessibilityActionForItem ( @ NonNull View view , int action , @ Nullable Bundle args ) { return performAccessibilityActionForItem ( mRecyclerView . mRecycler , mRecyclerView . mState , view , action , args ) ; } public boolean performAccessibilityActionForItem ( @ NonNull Recycler recycler , @ NonNull State state , @ NonNull View view , int action , @ Nullable Bundle args ) { return false ; } public static Properties getProperties ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = new Properties ( ) ; TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . RecyclerView , defStyleAttr , defStyleRes ) ; properties . orientation = a . getInt ( R . styleable . RecyclerView_android_orientation , DEFAULT_ORIENTATION ) ; properties . spanCount = a . getInt ( R . styleable . RecyclerView_spanCount , <NUM_LIT> ) ; properties . reverseLayout = a . getBoolean ( R . styleable . RecyclerView_reverseLayout , false ) ; properties . stackFromEnd = a . getBoolean ( R . styleable . RecyclerView_stackFromEnd , false ) ; a . recycle ( ) ; return properties ; } void setExactMeasureSpecsFrom ( RecyclerView recyclerView ) { setMeasureSpecs ( MeasureSpec . makeMeasureSpec ( recyclerView . getWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( recyclerView . getHeight ( ) , MeasureSpec . EXACTLY ) ) ; } boolean shouldMeasureTwice ( ) { return false ; } boolean hasFlexibleChildInBothOrientations ( ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = getChildAt ( i ) ; final ViewGroup . LayoutParams lp = child . getLayoutParams ( ) ; if ( lp . width < <NUM_LIT> && lp . height < <NUM_LIT> ) { return true ; } } return false ; } public static class Properties { public int orientation ; public int spanCount ; public boolean reverseLayout ; public boolean stackFromEnd ; } } public abstract static class ItemDecoration { public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { onDraw ( c , parent ) ; } @ Deprecated public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { onDrawOver ( c , parent ) ; } @ Deprecated public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Deprecated public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) { getItemOffsets ( outRect , ( ( LayoutParams ) view . getLayoutParams ( ) ) . getViewLayoutPosition ( ) , parent ) ; } } public interface OnItemTouchListener { boolean onInterceptTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) ; void onTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) ; void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) ; } public static class SimpleOnItemTouchListener implements RecyclerView . OnItemTouchListener { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) { return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView rv , @ NonNull MotionEvent e ) { } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } } public abstract static class OnScrollListener { public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { } public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { } } public interface RecyclerListener { void onViewRecycled ( @ NonNull ViewHolder holder ) ; } public interface OnChildAttachStateChangeListener { void onChildViewAttachedToWindow ( @ NonNull View view ) ; void onChildViewDetachedFromWindow ( @ NonNull View view ) ; } public abstract static class ViewHolder { @ NonNull public final View itemView ; WeakReference < RecyclerView > mNestedRecyclerView ; int mPosition = NO_POSITION ; int mOldPosition = NO_POSITION ; long mItemId = NO_ID ; int mItemViewType = INVALID_TYPE ; int mPreLayoutPosition = NO_POSITION ; ViewHolder mShadowedHolder = null ; ViewHolder mShadowingHolder = null ; static final int FLAG_BOUND = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_INVALID = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_REMOVED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_NOT_RECYCLABLE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_RETURNED_FROM_SCRAP = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_IGNORE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_TMP_DETACHED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_ADAPTER_POSITION_UNKNOWN = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_ADAPTER_FULLUPDATE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_MOVED = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_APPEARED_IN_PRE_LAYOUT = <NUM_LIT> << <NUM_LIT> ; static final int PENDING_ACCESSIBILITY_STATE_NOT_SET = - <NUM_LIT> ; static final int FLAG_BOUNCED_FROM_HIDDEN_LIST = <NUM_LIT> << <NUM_LIT> ; int mFlags ; private static final List < Object > FULLUPDATE_PAYLOADS = Collections . emptyList ( ) ; List < Object > mPayloads = null ; List < Object > mUnmodifiedPayloads = null ; private int mIsRecyclableCount = <NUM_LIT> ; Recycler mScrapContainer = null ; boolean mInChangeScrap = false ; private int mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; @ VisibleForTesting int mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET ; RecyclerView mOwnerRecyclerView ; Adapter < ? extends ViewHolder > mBindingAdapter ; public ViewHolder ( @ NonNull View itemView ) { if ( itemView == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } this . itemView = itemView ; } void flagRemovedAndOffsetPosition ( int mNewPosition , int offset , boolean applyToPreLayout ) { addFlags ( ViewHolder . FLAG_REMOVED ) ; offsetPosition ( offset , applyToPreLayout ) ; mPosition = mNewPosition ; } void offsetPosition ( int offset , boolean applyToPreLayout ) { if ( mOldPosition == NO_POSITION ) { mOldPosition = mPosition ; } if ( mPreLayoutPosition == NO_POSITION ) { mPreLayoutPosition = mPosition ; } if ( applyToPreLayout ) { mPreLayoutPosition += offset ; } mPosition += offset ; if ( itemView . getLayoutParams ( ) != null ) { ( ( LayoutParams ) itemView . getLayoutParams ( ) ) . mInsetsDirty = true ; } } void clearOldPosition ( ) { mOldPosition = NO_POSITION ; mPreLayoutPosition = NO_POSITION ; } void saveOldPosition ( ) { if ( mOldPosition == NO_POSITION ) { mOldPosition = mPosition ; } } boolean shouldIgnore ( ) { return ( mFlags & FLAG_IGNORE ) != <NUM_LIT> ; } @ Deprecated public final int getPosition ( ) { return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition ; } public final int getLayoutPosition ( ) { return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition ; } @ Deprecated public final int getAdapterPosition ( ) { return getBindingAdapterPosition ( ) ; } public final int getBindingAdapterPosition ( ) { if ( mBindingAdapter == null ) { return NO_POSITION ; } if ( mOwnerRecyclerView == null ) { return NO_POSITION ; } @ SuppressWarnings ( "<STR_LIT>" ) Adapter < ? extends ViewHolder > rvAdapter = mOwnerRecyclerView . getAdapter ( ) ; if ( rvAdapter == null ) { return NO_POSITION ; } int globalPosition = mOwnerRecyclerView . getAdapterPositionInRecyclerView ( this ) ; if ( globalPosition == NO_POSITION ) { return NO_POSITION ; } return rvAdapter . findRelativeAdapterPositionIn ( mBindingAdapter , this , globalPosition ) ; } public final int getAbsoluteAdapterPosition ( ) { if ( mOwnerRecyclerView == null ) { return NO_POSITION ; } return mOwnerRecyclerView . getAdapterPositionInRecyclerView ( this ) ; } @ Nullable public final Adapter < ? extends ViewHolder > getBindingAdapter ( ) { return mBindingAdapter ; } public final int getOldPosition ( ) { return mOldPosition ; } public final long getItemId ( ) { return mItemId ; } public final int getItemViewType ( ) { return mItemViewType ; } boolean isScrap ( ) { return mScrapContainer != null ; } void unScrap ( ) { mScrapContainer . unscrapView ( this ) ; } boolean wasReturnedFromScrap ( ) { return ( mFlags & FLAG_RETURNED_FROM_SCRAP ) != <NUM_LIT> ; } void clearReturnedFromScrapFlag ( ) { mFlags = mFlags & ~ FLAG_RETURNED_FROM_SCRAP ; } void clearTmpDetachFlag ( ) { mFlags = mFlags & ~ FLAG_TMP_DETACHED ; } void stopIgnoring ( ) { mFlags = mFlags & ~ FLAG_IGNORE ; } void setScrapContainer ( Recycler recycler , boolean isChangeScrap ) { mScrapContainer = recycler ; mInChangeScrap = isChangeScrap ; } boolean isInvalid ( ) { return ( mFlags & FLAG_INVALID ) != <NUM_LIT> ; } boolean needsUpdate ( ) { return ( mFlags & FLAG_UPDATE ) != <NUM_LIT> ; } boolean isBound ( ) { return ( mFlags & FLAG_BOUND ) != <NUM_LIT> ; } boolean isRemoved ( ) { return ( mFlags & FLAG_REMOVED ) != <NUM_LIT> ; } boolean hasAnyOfTheFlags ( int flags ) { return ( mFlags & flags ) != <NUM_LIT> ; } boolean isTmpDetached ( ) { return ( mFlags & FLAG_TMP_DETACHED ) != <NUM_LIT> ; } boolean isAttachedToTransitionOverlay ( ) { return itemView . getParent ( ) != null && itemView . getParent ( ) != mOwnerRecyclerView ; } boolean isAdapterPositionUnknown ( ) { return ( mFlags & FLAG_ADAPTER_POSITION_UNKNOWN ) != <NUM_LIT> || isInvalid ( ) ; } void setFlags ( int flags , int mask ) { mFlags = ( mFlags & ~ mask ) | ( flags & mask ) ; } void addFlags ( int flags ) { mFlags |= flags ; } void addChangePayload ( Object payload ) { if ( payload == null ) { addFlags ( FLAG_ADAPTER_FULLUPDATE ) ; } else if ( ( mFlags & FLAG_ADAPTER_FULLUPDATE ) == <NUM_LIT> ) { createPayloadsIfNeeded ( ) ; mPayloads . add ( payload ) ; } } private void createPayloadsIfNeeded ( ) { if ( mPayloads == null ) { mPayloads = new ArrayList < Object > ( ) ; mUnmodifiedPayloads = Collections . unmodifiableList ( mPayloads ) ; } } void clearPayload ( ) { if ( mPayloads != null ) { mPayloads . clear ( ) ; } mFlags = mFlags & ~ FLAG_ADAPTER_FULLUPDATE ; } List < Object > getUnmodifiedPayloads ( ) { if ( ( mFlags & FLAG_ADAPTER_FULLUPDATE ) == <NUM_LIT> ) { if ( mPayloads == null || mPayloads . size ( ) == <NUM_LIT> ) { return FULLUPDATE_PAYLOADS ; } return mUnmodifiedPayloads ; } else { return FULLUPDATE_PAYLOADS ; } } void resetInternal ( ) { if ( sDebugAssertionsEnabled && isTmpDetached ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + this + "<STR_LIT>" ) ; } mFlags = <NUM_LIT> ; mPosition = NO_POSITION ; mOldPosition = NO_POSITION ; mItemId = NO_ID ; mPreLayoutPosition = NO_POSITION ; mIsRecyclableCount = <NUM_LIT> ; mShadowedHolder = null ; mShadowingHolder = null ; clearPayload ( ) ; mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET ; clearNestedRecyclerViewIfNotNested ( this ) ; } void onEnteredHiddenState ( RecyclerView parent ) { if ( mPendingAccessibilityState != PENDING_ACCESSIBILITY_STATE_NOT_SET ) { mWasImportantForAccessibilityBeforeHidden = mPendingAccessibilityState ; } else { mWasImportantForAccessibilityBeforeHidden = ViewCompat . getImportantForAccessibility ( itemView ) ; } parent . setChildImportantForAccessibilityInternal ( this , ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS ) ; } void onLeftHiddenState ( RecyclerView parent ) { parent . setChildImportantForAccessibilityInternal ( this , mWasImportantForAccessibilityBeforeHidden ) ; mWasImportantForAccessibilityBeforeHidden = ViewCompat . IMPORTANT_FOR_ACCESSIBILITY_AUTO ; } @ Override public String toString ( ) { String className = getClass ( ) . isAnonymousClass ( ) ? "<STR_LIT>" : getClass ( ) . getSimpleName ( ) ; final StringBuilder sb = new StringBuilder ( className + "<STR_LIT>" + Integer . toHexString ( hashCode ( ) ) + "<STR_LIT>" + mPosition + "<STR_LIT>" + mItemId + "<STR_LIT>" + mOldPosition + "<STR_LIT>" + mPreLayoutPosition ) ; if ( isScrap ( ) ) { sb . append ( "<STR_LIT>" ) . append ( mInChangeScrap ? "<STR_LIT>" : "<STR_LIT>" ) ; } if ( isInvalid ( ) ) sb . append ( "<STR_LIT>" ) ; if ( ! isBound ( ) ) sb . append ( "<STR_LIT>" ) ; if ( needsUpdate ( ) ) sb . append ( "<STR_LIT>" ) ; if ( isRemoved ( ) ) sb . append ( "<STR_LIT>" ) ; if ( shouldIgnore ( ) ) sb . append ( "<STR_LIT>" ) ; if ( isTmpDetached ( ) ) sb . append ( "<STR_LIT>" ) ; if ( ! isRecyclable ( ) ) sb . append ( "<STR_LIT>" + mIsRecyclableCount + "<STR_LIT>" ) ; if ( isAdapterPositionUnknown ( ) ) sb . append ( "<STR_LIT>" ) ; if ( itemView . getParent ( ) == null ) sb . append ( "<STR_LIT>" ) ; sb . append ( "<STR_LIT>" ) ; return sb . toString ( ) ; } public final void setIsRecyclable ( boolean recyclable ) { mIsRecyclableCount = recyclable ? mIsRecyclableCount - <NUM_LIT> : mIsRecyclableCount + <NUM_LIT> ; if ( mIsRecyclableCount < <NUM_LIT> ) { mIsRecyclableCount = <NUM_LIT> ; if ( sDebugAssertionsEnabled ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + this ) ; } Log . e ( VIEW_LOG_TAG , "<STR_LIT>" + "<STR_LIT>" + this ) ; } else if ( ! recyclable && mIsRecyclableCount == <NUM_LIT> ) { mFlags |= FLAG_NOT_RECYCLABLE ; } else if ( recyclable && mIsRecyclableCount == <NUM_LIT> ) { mFlags &= ~ FLAG_NOT_RECYCLABLE ; } if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" + recyclable + "<STR_LIT>" + this ) ; } } public final boolean isRecyclable ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) == <NUM_LIT> && ! ViewCompat . hasTransientState ( itemView ) ; } boolean shouldBeKeptAsChild ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) != <NUM_LIT> ; } boolean doesTransientStatePreventRecycling ( ) { return ( mFlags & FLAG_NOT_RECYCLABLE ) == <NUM_LIT> && ViewCompat . hasTransientState ( itemView ) ; } boolean isUpdated ( ) { return ( mFlags & FLAG_UPDATE ) != <NUM_LIT> ; } } @ VisibleForTesting boolean setChildImportantForAccessibilityInternal ( ViewHolder viewHolder , int importantForAccessibility ) { if ( isComputingLayout ( ) ) { viewHolder . mPendingAccessibilityState = importantForAccessibility ; mPendingAccessibilityImportanceChange . add ( viewHolder ) ; return false ; } ViewCompat . setImportantForAccessibility ( viewHolder . itemView , importantForAccessibility ) ; return true ; } void dispatchPendingImportantForAccessibilityChanges ( ) { for ( int i = mPendingAccessibilityImportanceChange . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ViewHolder viewHolder = mPendingAccessibilityImportanceChange . get ( i ) ; if ( viewHolder . itemView . getParent ( ) != this || viewHolder . shouldIgnore ( ) ) { continue ; } int state = viewHolder . mPendingAccessibilityState ; if ( state != ViewHolder . PENDING_ACCESSIBILITY_STATE_NOT_SET ) { ViewCompat . setImportantForAccessibility ( viewHolder . itemView , state ) ; viewHolder . mPendingAccessibilityState = ViewHolder . PENDING_ACCESSIBILITY_STATE_NOT_SET ; } } mPendingAccessibilityImportanceChange . clear ( ) ; } int getAdapterPositionInRecyclerView ( ViewHolder viewHolder ) { if ( viewHolder . hasAnyOfTheFlags ( ViewHolder . FLAG_INVALID | ViewHolder . FLAG_REMOVED | ViewHolder . FLAG_ADAPTER_POSITION_UNKNOWN ) || ! viewHolder . isBound ( ) ) { return RecyclerView . NO_POSITION ; } return mAdapterHelper . applyPendingUpdatesToPosition ( viewHolder . mPosition ) ; } @ VisibleForTesting void initFastScroller ( StateListDrawable verticalThumbDrawable , Drawable verticalTrackDrawable , StateListDrawable horizontalThumbDrawable , Drawable horizontalTrackDrawable ) { if ( verticalThumbDrawable == null || verticalTrackDrawable == null || horizontalThumbDrawable == null || horizontalTrackDrawable == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + exceptionLabel ( ) ) ; } Resources resources = getContext ( ) . getResources ( ) ; new FastScroller ( this , verticalThumbDrawable , verticalTrackDrawable , horizontalThumbDrawable , horizontalTrackDrawable , resources . getDimensionPixelSize ( R . dimen . fastscroll_default_thickness ) , resources . getDimensionPixelSize ( R . dimen . fastscroll_minimum_range ) , resources . getDimensionPixelOffset ( R . dimen . fastscroll_margin ) ) ; } @ Override public void setNestedScrollingEnabled ( boolean enabled ) { getScrollingChildHelper ( ) . setNestedScrollingEnabled ( enabled ) ; } @ Override public boolean isNestedScrollingEnabled ( ) { return getScrollingChildHelper ( ) . isNestedScrollingEnabled ( ) ; } @ Override public boolean startNestedScroll ( int axes ) { return getScrollingChildHelper ( ) . startNestedScroll ( axes ) ; } @ Override public boolean startNestedScroll ( int axes , int type ) { return getScrollingChildHelper ( ) . startNestedScroll ( axes , type ) ; } @ Override public void stopNestedScroll ( ) { getScrollingChildHelper ( ) . stopNestedScroll ( ) ; } @ Override public void stopNestedScroll ( int type ) { getScrollingChildHelper ( ) . stopNestedScroll ( type ) ; } @ Override public boolean hasNestedScrollingParent ( ) { return getScrollingChildHelper ( ) . hasNestedScrollingParent ( ) ; } @ Override public boolean hasNestedScrollingParent ( int type ) { return getScrollingChildHelper ( ) . hasNestedScrollingParent ( type ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow ) { return getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow , int type ) { return getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type ) ; } @ Override public final void dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow , int type , @ NonNull int [ ] consumed ) { getScrollingChildHelper ( ) . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type , consumed ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow ) { return getScrollingChildHelper ( ) . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow , int type ) { return getScrollingChildHelper ( ) . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow , type ) ; } @ Override public boolean dispatchNestedFling ( float velocityX , float velocityY , boolean consumed ) { return getScrollingChildHelper ( ) . dispatchNestedFling ( velocityX , velocityY , consumed ) ; } @ Override public boolean dispatchNestedPreFling ( float velocityX , float velocityY ) { return getScrollingChildHelper ( ) . dispatchNestedPreFling ( velocityX , velocityY ) ; } public static class LayoutParams extends android . view . ViewGroup . MarginLayoutParams { ViewHolder mViewHolder ; final Rect mDecorInsets = new Rect ( ) ; boolean mInsetsDirty = true ; boolean mPendingInvalidate = false ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( LayoutParams source ) { super ( ( ViewGroup . LayoutParams ) source ) ; } public boolean viewNeedsUpdate ( ) { return mViewHolder . needsUpdate ( ) ; } public boolean isViewInvalid ( ) { return mViewHolder . isInvalid ( ) ; } public boolean isItemRemoved ( ) { return mViewHolder . isRemoved ( ) ; } public boolean isItemChanged ( ) { return mViewHolder . isUpdated ( ) ; } @ Deprecated public int getViewPosition ( ) { return mViewHolder . getPosition ( ) ; } public int getViewLayoutPosition ( ) { return mViewHolder . getLayoutPosition ( ) ; } @ Deprecated public int getViewAdapterPosition ( ) { return mViewHolder . getBindingAdapterPosition ( ) ; } public int getAbsoluteAdapterPosition ( ) { return mViewHolder . getAbsoluteAdapterPosition ( ) ; } public int getBindingAdapterPosition ( ) { return mViewHolder . getBindingAdapterPosition ( ) ; } } public abstract static class AdapterDataObserver { public void onChanged ( ) { } public void onItemRangeChanged ( int positionStart , int itemCount ) { } public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onItemRangeChanged ( positionStart , itemCount ) ; } public void onItemRangeInserted ( int positionStart , int itemCount ) { } public void onItemRangeRemoved ( int positionStart , int itemCount ) { } public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { } public void onStateRestorationPolicyChanged ( ) { } } public abstract static class SmoothScroller { private int mTargetPosition = RecyclerView . NO_POSITION ; private RecyclerView mRecyclerView ; private LayoutManager mLayoutManager ; private boolean mPendingInitialRun ; private boolean mRunning ; private View mTargetView ; private final Action mRecyclingAction ; private boolean mStarted ; public SmoothScroller ( ) { mRecyclingAction = new Action ( <NUM_LIT> , <NUM_LIT> ) ; } void start ( RecyclerView recyclerView , LayoutManager layoutManager ) { recyclerView . mViewFlinger . stop ( ) ; if ( mStarted ) { Log . w ( TAG , "<STR_LIT>" + this . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + "<STR_LIT>" + this . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } mRecyclerView = recyclerView ; mLayoutManager = layoutManager ; if ( mTargetPosition == RecyclerView . NO_POSITION ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mRecyclerView . mState . mTargetPosition = mTargetPosition ; mRunning = true ; mPendingInitialRun = true ; mTargetView = findViewByPosition ( getTargetPosition ( ) ) ; onStart ( ) ; mRecyclerView . mViewFlinger . postOnAnimation ( ) ; mStarted = true ; } public void setTargetPosition ( int targetPosition ) { mTargetPosition = targetPosition ; } @ Nullable public PointF computeScrollVectorForPosition ( int targetPosition ) { LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager instanceof ScrollVectorProvider ) { return ( ( ScrollVectorProvider ) layoutManager ) . computeScrollVectorForPosition ( targetPosition ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + ScrollVectorProvider . class . getCanonicalName ( ) ) ; return null ; } @ Nullable public LayoutManager getLayoutManager ( ) { return mLayoutManager ; } protected final void stop ( ) { if ( ! mRunning ) { return ; } mRunning = false ; onStop ( ) ; mRecyclerView . mState . mTargetPosition = RecyclerView . NO_POSITION ; mTargetView = null ; mTargetPosition = RecyclerView . NO_POSITION ; mPendingInitialRun = false ; mLayoutManager . onSmoothScrollerStopped ( this ) ; mLayoutManager = null ; mRecyclerView = null ; } public boolean isPendingInitialRun ( ) { return mPendingInitialRun ; } public boolean isRunning ( ) { return mRunning ; } public int getTargetPosition ( ) { return mTargetPosition ; } void onAnimation ( int dx , int dy ) { final RecyclerView recyclerView = mRecyclerView ; if ( mTargetPosition == RecyclerView . NO_POSITION || recyclerView == null ) { stop ( ) ; } if ( mPendingInitialRun && mTargetView == null && mLayoutManager != null ) { PointF pointF = computeScrollVectorForPosition ( mTargetPosition ) ; if ( pointF != null && ( pointF . x != <NUM_LIT> || pointF . y != <NUM_LIT> ) ) { recyclerView . scrollStep ( ( int ) Math . signum ( pointF . x ) , ( int ) Math . signum ( pointF . y ) , null ) ; } } mPendingInitialRun = false ; if ( mTargetView != null ) { if ( getChildPosition ( mTargetView ) == mTargetPosition ) { onTargetFound ( mTargetView , recyclerView . mState , mRecyclingAction ) ; mRecyclingAction . runIfNecessary ( recyclerView ) ; stop ( ) ; } else { Log . e ( TAG , "<STR_LIT>" ) ; mTargetView = null ; } } if ( mRunning ) { onSeekTargetStep ( dx , dy , recyclerView . mState , mRecyclingAction ) ; boolean hadJumpTarget = mRecyclingAction . hasJumpTarget ( ) ; mRecyclingAction . runIfNecessary ( recyclerView ) ; if ( hadJumpTarget ) { if ( mRunning ) { mPendingInitialRun = true ; recyclerView . mViewFlinger . postOnAnimation ( ) ; } } } } public int getChildPosition ( View view ) { return mRecyclerView . getChildLayoutPosition ( view ) ; } public int getChildCount ( ) { return mRecyclerView . mLayout . getChildCount ( ) ; } public View findViewByPosition ( int position ) { return mRecyclerView . mLayout . findViewByPosition ( position ) ; } @ Deprecated public void instantScrollToPosition ( int position ) { mRecyclerView . scrollToPosition ( position ) ; } protected void onChildAttachedToWindow ( View child ) { if ( getChildPosition ( child ) == getTargetPosition ( ) ) { mTargetView = child ; if ( sVerboseLoggingEnabled ) { Log . d ( TAG , "<STR_LIT>" ) ; } } } protected void normalize ( @ NonNull PointF scrollVector ) { final float magnitude = ( float ) Math . sqrt ( scrollVector . x * scrollVector . x + scrollVector . y * scrollVector . y ) ; scrollVector . x /= magnitude ; scrollVector . y /= magnitude ; } protected abstract void onStart ( ) ; protected abstract void onStop ( ) ; protected abstract void onSeekTargetStep ( @ Px int dx , @ Px int dy , @ NonNull State state , @ NonNull Action action ) ; protected abstract void onTargetFound ( @ NonNull View targetView , @ NonNull State state , @ NonNull Action action ) ; public static class Action { public static final int UNDEFINED_DURATION = RecyclerView . UNDEFINED_DURATION ; private int mDx ; private int mDy ; private int mDuration ; private int mJumpToPosition = NO_POSITION ; private Interpolator mInterpolator ; private boolean mChanged = false ; private int mConsecutiveUpdates = <NUM_LIT> ; public Action ( @ Px int dx , @ Px int dy ) { this ( dx , dy , UNDEFINED_DURATION , null ) ; } public Action ( @ Px int dx , @ Px int dy , int duration ) { this ( dx , dy , duration , null ) ; } public Action ( @ Px int dx , @ Px int dy , int duration , @ Nullable Interpolator interpolator ) { mDx = dx ; mDy = dy ; mDuration = duration ; mInterpolator = interpolator ; } public void jumpTo ( int targetPosition ) { mJumpToPosition = targetPosition ; } boolean hasJumpTarget ( ) { return mJumpToPosition >= <NUM_LIT> ; } void runIfNecessary ( RecyclerView recyclerView ) { if ( mJumpToPosition >= <NUM_LIT> ) { final int position = mJumpToPosition ; mJumpToPosition = NO_POSITION ; recyclerView . jumpToPositionForSmoothScroller ( position ) ; mChanged = false ; return ; } if ( mChanged ) { validate ( ) ; recyclerView . mViewFlinger . smoothScrollBy ( mDx , mDy , mDuration , mInterpolator ) ; mConsecutiveUpdates ++ ; if ( mConsecutiveUpdates > <NUM_LIT> ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } mChanged = false ; } else { mConsecutiveUpdates = <NUM_LIT> ; } } private void validate ( ) { if ( mInterpolator != null && mDuration < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } else if ( mDuration < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } } @ Px public int getDx ( ) { return mDx ; } public void setDx ( @ Px int dx ) { mChanged = true ; mDx = dx ; } @ Px public int getDy ( ) { return mDy ; } public void setDy ( @ Px int dy ) { mChanged = true ; mDy = dy ; } public int getDuration ( ) { return mDuration ; } public void setDuration ( int duration ) { mChanged = true ; mDuration = duration ; } @ Nullable public Interpolator getInterpolator ( ) { return mInterpolator ; } public void setInterpolator ( @ Nullable Interpolator interpolator ) { mChanged = true ; mInterpolator = interpolator ; } public void update ( @ Px int dx , @ Px int dy , int duration , @ Nullable Interpolator interpolator ) { mDx = dx ; mDy = dy ; mDuration = duration ; mInterpolator = interpolator ; mChanged = true ; } } public interface ScrollVectorProvider { @ Nullable PointF computeScrollVectorForPosition ( int targetPosition ) ; } } static class AdapterDataObservable extends Observable < AdapterDataObserver > { public boolean hasObservers ( ) { return ! mObservers . isEmpty ( ) ; } public void notifyChanged ( ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onChanged ( ) ; } } public void notifyStateRestorationPolicyChanged ( ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onStateRestorationPolicyChanged ( ) ; } } public void notifyItemRangeChanged ( int positionStart , int itemCount ) { notifyItemRangeChanged ( positionStart , itemCount , null ) ; } public void notifyItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeChanged ( positionStart , itemCount , payload ) ; } } public void notifyItemRangeInserted ( int positionStart , int itemCount ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeInserted ( positionStart , itemCount ) ; } } public void notifyItemRangeRemoved ( int positionStart , int itemCount ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeRemoved ( positionStart , itemCount ) ; } } public void notifyItemMoved ( int fromPosition , int toPosition ) { for ( int i = mObservers . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mObservers . get ( i ) . onItemRangeMoved ( fromPosition , toPosition , <NUM_LIT> ) ; } } } @ RestrictTo ( LIBRARY ) public static class SavedState extends AbsSavedState { Parcelable mLayoutState ; @ SuppressWarnings ( "<STR_LIT>" ) SavedState ( Parcel in , ClassLoader loader ) { super ( in , loader ) ; mLayoutState = in . readParcelable ( loader != null ? loader : LayoutManager . class . getClassLoader ( ) ) ; } SavedState ( Parcelable superState ) { super ( superState ) ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeParcelable ( mLayoutState , <NUM_LIT> ) ; } void copyFrom ( SavedState other ) { mLayoutState = other . mLayoutState ; } public static final Creator < SavedState > CREATOR = new ClassLoaderCreator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in , ClassLoader loader ) { return new SavedState ( in , loader ) ; } @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in , null ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } public static class State { static final int STEP_START = <NUM_LIT> ; static final int STEP_LAYOUT = <NUM_LIT> << <NUM_LIT> ; static final int STEP_ANIMATIONS = <NUM_LIT> << <NUM_LIT> ; void assertLayoutStep ( int accepted ) { if ( ( accepted & mLayoutStep ) == <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + Integer . toBinaryString ( accepted ) + "<STR_LIT>" + Integer . toBinaryString ( mLayoutStep ) ) ; } } int mTargetPosition = RecyclerView . NO_POSITION ; private SparseArray < Object > mData ; int mPreviousLayoutItemCount = <NUM_LIT> ; int mDeletedInvisibleItemCountSincePreviousLayout = <NUM_LIT> ; @ IntDef ( flag = true , value = { STEP_START , STEP_LAYOUT , STEP_ANIMATIONS } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface LayoutState { } @ LayoutState int mLayoutStep = STEP_START ; int mItemCount = <NUM_LIT> ; boolean mStructureChanged = false ; boolean mInPreLayout = false ; boolean mTrackOldChangeHolders = false ; boolean mIsMeasuring = false ; boolean mRunSimpleAnimations = false ; boolean mRunPredictiveAnimations = false ; int mFocusedItemPosition ; long mFocusedItemId ; int mFocusedSubChildId ; int mRemainingScrollHorizontal ; int mRemainingScrollVertical ; void prepareForNestedPrefetch ( Adapter adapter ) { mLayoutStep = STEP_START ; mItemCount = adapter . getItemCount ( ) ; mInPreLayout = false ; mTrackOldChangeHolders = false ; mIsMeasuring = false ; } public boolean isMeasuring ( ) { return mIsMeasuring ; } public boolean isPreLayout ( ) { return mInPreLayout ; } public boolean willRunPredictiveAnimations ( ) { return mRunPredictiveAnimations ; } public boolean willRunSimpleAnimations ( ) { return mRunSimpleAnimations ; } public void remove ( int resourceId ) { if ( mData == null ) { return ; } mData . remove ( resourceId ) ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public < T > T get ( int resourceId ) { if ( mData == null ) { return null ; } return ( T ) mData . get ( resourceId ) ; } public void put ( int resourceId , Object data ) { if ( mData == null ) { mData = new SparseArray < Object > ( ) ; } mData . put ( resourceId , data ) ; } public int getTargetScrollPosition ( ) { return mTargetPosition ; } public boolean hasTargetScrollPosition ( ) { return mTargetPosition != RecyclerView . NO_POSITION ; } public boolean didStructureChange ( ) { return mStructureChanged ; } public int getItemCount ( ) { return mInPreLayout ? ( mPreviousLayoutItemCount - mDeletedInvisibleItemCountSincePreviousLayout ) : mItemCount ; } public int getRemainingScrollHorizontal ( ) { return mRemainingScrollHorizontal ; } public int getRemainingScrollVertical ( ) { return mRemainingScrollVertical ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mTargetPosition + "<STR_LIT>" + mData + "<STR_LIT>" + mItemCount + "<STR_LIT>" + mIsMeasuring + "<STR_LIT>" + mPreviousLayoutItemCount + "<STR_LIT>" + mDeletedInvisibleItemCountSincePreviousLayout + "<STR_LIT>" + mStructureChanged + "<STR_LIT>" + mInPreLayout + "<STR_LIT>" + mRunSimpleAnimations + "<STR_LIT>" + mRunPredictiveAnimations + '<STR_LIT>' ; } } public abstract static class OnFlingListener { public abstract boolean onFling ( int velocityX , int velocityY ) ; } private class ItemAnimatorRestoreListener implements ItemAnimator . ItemAnimatorListener { ItemAnimatorRestoreListener ( ) { } @ Override public void onAnimationFinished ( ViewHolder item ) { item . setIsRecyclable ( true ) ; if ( item . mShadowedHolder != null && item . mShadowingHolder == null ) { item . mShadowedHolder = null ; } item . mShadowingHolder = null ; if ( ! item . shouldBeKeptAsChild ( ) ) { if ( ! removeAnimatingView ( item . itemView ) && item . isTmpDetached ( ) ) { removeDetachedView ( item . itemView , false ) ; } } } } @ SuppressWarnings ( "<STR_LIT>" ) public abstract static class ItemAnimator { public static final int FLAG_CHANGED = ViewHolder . FLAG_UPDATE ; public static final int FLAG_REMOVED = ViewHolder . FLAG_REMOVED ; public static final int FLAG_INVALIDATED = ViewHolder . FLAG_INVALID ; public static final int FLAG_MOVED = ViewHolder . FLAG_MOVED ; public static final int FLAG_APPEARED_IN_PRE_LAYOUT = ViewHolder . FLAG_APPEARED_IN_PRE_LAYOUT ; @ IntDef ( flag = true , value = { FLAG_CHANGED , FLAG_REMOVED , FLAG_MOVED , FLAG_INVALIDATED , FLAG_APPEARED_IN_PRE_LAYOUT } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface AdapterChanges { } private ItemAnimatorListener mListener = null ; private ArrayList < ItemAnimatorFinishedListener > mFinishedListeners = new ArrayList < ItemAnimatorFinishedListener > ( ) ; private long mAddDuration = <NUM_LIT> ; private long mRemoveDuration = <NUM_LIT> ; private long mMoveDuration = <NUM_LIT> ; private long mChangeDuration = <NUM_LIT> ; public long getMoveDuration ( ) { return mMoveDuration ; } public void setMoveDuration ( long moveDuration ) { mMoveDuration = moveDuration ; } public long getAddDuration ( ) { return mAddDuration ; } public void setAddDuration ( long addDuration ) { mAddDuration = addDuration ; } public long getRemoveDuration ( ) { return mRemoveDuration ; } public void setRemoveDuration ( long removeDuration ) { mRemoveDuration = removeDuration ; } public long getChangeDuration ( ) { return mChangeDuration ; } public void setChangeDuration ( long changeDuration ) { mChangeDuration = changeDuration ; } void setListener ( ItemAnimatorListener listener ) { mListener = listener ; } public @ NonNull ItemHolderInfo recordPreLayoutInformation ( @ NonNull State state , @ NonNull ViewHolder viewHolder , @ AdapterChanges int changeFlags , @ NonNull List < Object > payloads ) { return obtainHolderInfo ( ) . setFrom ( viewHolder ) ; } public @ NonNull ItemHolderInfo recordPostLayoutInformation ( @ NonNull State state , @ NonNull ViewHolder viewHolder ) { return obtainHolderInfo ( ) . setFrom ( viewHolder ) ; } public abstract boolean animateDisappearance ( @ NonNull ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) ; public abstract boolean animateAppearance ( @ NonNull ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; public abstract boolean animatePersistence ( @ NonNull ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; public abstract boolean animateChange ( @ NonNull ViewHolder oldHolder , @ NonNull ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) ; @ AdapterChanges static int buildAdapterChangeFlagsForAnimations ( ViewHolder viewHolder ) { int flags = viewHolder . mFlags & ( FLAG_INVALIDATED | FLAG_REMOVED | FLAG_CHANGED ) ; if ( viewHolder . isInvalid ( ) ) { return FLAG_INVALIDATED ; } if ( ( flags & FLAG_INVALIDATED ) == <NUM_LIT> ) { final int oldPos = viewHolder . getOldPosition ( ) ; final int pos = viewHolder . getAbsoluteAdapterPosition ( ) ; if ( oldPos != NO_POSITION && pos != NO_POSITION && oldPos != pos ) { flags |= FLAG_MOVED ; } } return flags ; } public abstract void runPendingAnimations ( ) ; public abstract void endAnimation ( @ NonNull ViewHolder item ) ; public abstract void endAnimations ( ) ; public abstract boolean isRunning ( ) ; public final void dispatchAnimationFinished ( @ NonNull ViewHolder viewHolder ) { onAnimationFinished ( viewHolder ) ; if ( mListener != null ) { mListener . onAnimationFinished ( viewHolder ) ; } } public void onAnimationFinished ( @ NonNull ViewHolder viewHolder ) { } public final void dispatchAnimationStarted ( @ NonNull ViewHolder viewHolder ) { onAnimationStarted ( viewHolder ) ; } public void onAnimationStarted ( @ NonNull ViewHolder viewHolder ) { } public final boolean isRunning ( @ Nullable ItemAnimatorFinishedListener listener ) { boolean running = isRunning ( ) ; if ( listener != null ) { if ( ! running ) { listener . onAnimationsFinished ( ) ; } else { mFinishedListeners . add ( listener ) ; } } return running ; } public boolean canReuseUpdatedViewHolder ( @ NonNull ViewHolder viewHolder ) { return true ; } public boolean canReuseUpdatedViewHolder ( @ NonNull ViewHolder viewHolder , @ NonNull List < Object > payloads ) { return canReuseUpdatedViewHolder ( viewHolder ) ; } public final void dispatchAnimationsFinished ( ) { final int count = mFinishedListeners . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; ++ i ) { mFinishedListeners . get ( i ) . onAnimationsFinished ( ) ; } mFinishedListeners . clear ( ) ; } @ NonNull public ItemHolderInfo obtainHolderInfo ( ) { return new ItemHolderInfo ( ) ; } interface ItemAnimatorListener { void onAnimationFinished ( @ NonNull ViewHolder item ) ; } public interface ItemAnimatorFinishedListener { void onAnimationsFinished ( ) ; } public static class ItemHolderInfo { public int left ; public int top ; public int right ; public int bottom ; @ AdapterChanges public int changeFlags ; public ItemHolderInfo ( ) { } @ NonNull public ItemHolderInfo setFrom ( @ NonNull RecyclerView . ViewHolder holder ) { return setFrom ( holder , <NUM_LIT> ) ; } @ NonNull public ItemHolderInfo setFrom ( @ NonNull RecyclerView . ViewHolder holder , @ AdapterChanges int flags ) { final View view = holder . itemView ; this . left = view . getLeft ( ) ; this . top = view . getTop ( ) ; this . right = view . getRight ( ) ; this . bottom = view . getBottom ( ) ; return this ; } } } @ Override protected int getChildDrawingOrder ( int childCount , int i ) { if ( mChildDrawingOrderCallback == null ) { return super . getChildDrawingOrder ( childCount , i ) ; } else { return mChildDrawingOrderCallback . onGetChildDrawingOrder ( childCount , i ) ; } } public interface ChildDrawingOrderCallback { int onGetChildDrawingOrder ( int childCount , int i ) ; } private NestedScrollingChildHelper getScrollingChildHelper ( ) { if ( mScrollingChildHelper == null ) { mScrollingChildHelper = new NestedScrollingChildHelper ( this ) ; } return mScrollingChildHelper ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ; x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { "<STR_LIT>" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( "<STR_LIT>" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + oldListPosition + "<STR_LIT>" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + newListPosition + "<STR_LIT>" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( posX , newPos ) ; batchingCallback . onChanged ( updatedNewPos - <NUM_LIT> , <NUM_LIT> , changePayload ) ; } } else { postponedUpdates . add ( new PostponedUpdate ( posX , currentListSize - posX - <NUM_LIT> , true ) ) ; } } else { batchingCallback . onRemoved ( posX , <NUM_LIT> ) ; currentListSize -- ; } } while ( posY > endY ) { posY -- ; int status = mNewItemStatuses [ posY ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int oldPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , oldPos , true ) ; if ( postponedUpdate == null ) { postponedUpdates . add ( new PostponedUpdate ( posY , currentListSize - posX , false ) ) ; } else { int updatedOldPos = currentListSize - postponedUpdate . currentPos - <NUM_LIT> ; batchingCallback . onMoved ( updatedOldPos , posX ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( oldPos , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } } } else { batchingCallback . onInserted ( posX , <NUM_LIT> ) ; currentListSize ++ ; } } posX = diagonal . x ; posY = diagonal . y ; for ( int i = <NUM_LIT> ; i < diagonal . size ; i ++ ) { if ( ( mOldItemStatuses [ posX ] & FLAG_MASK ) == FLAG_CHANGED ) { Object changePayload = mCallback . getChangePayload ( posX , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } posX ++ ; posY ++ ; } posX = diagonal . x ; posY = diagonal . y ; } batchingCallback . dispatchLastEvent ( ) ; } @ Nullable private static PostponedUpdate getPostponedUpdate ( Collection < PostponedUpdate > postponedUpdates , int posInList , boolean removal ) { PostponedUpdate postponedUpdate = null ; Iterator < PostponedUpdate > itr = postponedUpdates . iterator ( ) ; while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( update . posInOwnerList == posInList && update . removal == removal ) { postponedUpdate = update ; itr . remove ( ) ; break ; } } while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( removal ) { update . currentPos -- ; } else { update . currentPos ++ ; } } return postponedUpdate ; } } private static class PostponedUpdate { int posInOwnerList ; int currentPos ; boolean removal ; PostponedUpdate ( int posInOwnerList , int currentPos , boolean removal ) { this . posInOwnerList = posInOwnerList ; this . currentPos = currentPos ; this . removal = removal ; } } static class CenteredArray { private final int [ ] mData ; private final int mMid ; CenteredArray ( int size ) { mData = new int [ size ] ; mMid = mData . length / <NUM_LIT> ; } int get ( int index ) { return mData [ index + mMid ] ; } int [ ] backingData ( ) { return mData ; } void set ( int index , int value ) { mData [ index + mMid ] = value ; } public void fill ( int value ) { Arrays . fill ( mData , value ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable { @ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ; mPath . close ( ) ; if ( needMirroring ( ) ) { mTempMatrix . setScale ( - <NUM_LIT> , <NUM_LIT> , width / <NUM_LIT> , <NUM_LIT> ) ; } else { mTempMatrix . reset ( ) ; } mTempMatrix . postTranslate ( bounds . left , bounds . top ) ; mPath . transform ( mTempMatrix ) ; } private static void pathArcTo ( @ NonNull Path path , float centerX , float centerY , float radius , float startAngle , float sweepAngle ) { path . arcTo ( centerX - radius , centerY - radius , centerX + radius , centerY + radius , startAngle , sweepAngle , false ) ; } @ Override public boolean getPadding ( @ NonNull Rect padding ) { if ( needMirroring ( ) ) { padding . set ( mPaddingEnd , <NUM_LIT> , mPaddingStart , <NUM_LIT> ) ; } else { padding . set ( mPaddingStart , <NUM_LIT> , mPaddingEnd , <NUM_LIT> ) ; } return true ; } @ Override public void getOutline ( @ NonNull Outline outline ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q && ! mPath . isConvex ( ) ) { super . getOutline ( outline ) ; return ; } outline . setConvexPath ( mPath ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op ) ; Log . d ( TAG , "<STR_LIT>" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op . positionStart + "<STR_LIT>" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + pos + "<STR_LIT>" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; Log . d ( TAG , "<STR_LIT>" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" ) ; Log . d ( TAG , "<STR_LIT>" + i + "<STR_LIT>" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ; Object payload ; int itemCount ; UpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { this . cmd = cmd ; this . positionStart = positionStart ; this . itemCount = itemCount ; this . payload = payload ; } String cmdToString ( ) { switch ( cmd ) { case ADD : return "<STR_LIT>" ; case REMOVE : return "<STR_LIT>" ; case UPDATE : return "<STR_LIT>" ; case MOVE : return "<STR_LIT>" ; } return "<STR_LIT>" ; } @ Override public String toString ( ) { return Integer . toHexString ( System . identityHashCode ( this ) ) + "<STR_LIT>" + cmdToString ( ) + "<STR_LIT>" + positionStart + "<STR_LIT>" + itemCount + "<STR_LIT>" + payload + "<STR_LIT>" ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof UpdateOp ) ) { return false ; } UpdateOp op = ( UpdateOp ) o ; if ( cmd != op . cmd ) { return false ; } if ( cmd == MOVE && Math . abs ( itemCount - positionStart ) == <NUM_LIT> ) { if ( itemCount == op . positionStart && positionStart == op . itemCount ) { return true ; } } if ( itemCount != op . itemCount ) { return false ; } if ( positionStart != op . positionStart ) { return false ; } if ( payload != null ) { if ( ! payload . equals ( op . payload ) ) { return false ; } } else if ( op . payload != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = cmd ; result = <NUM_LIT> * result + positionStart ; result = <NUM_LIT> * result + itemCount ; return result ; } } @ Override public UpdateOp obtainUpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { UpdateOp op = mUpdateOpPool . acquire ( ) ; if ( op == null ) { op = new UpdateOp ( cmd , positionStart , itemCount , payload ) ; } else { op . cmd = cmd ; op . positionStart = positionStart ; op . itemCount = itemCount ; op . payload = payload ; } return op ; } @ Override public void recycleUpdateOp ( UpdateOp op ) { if ( ! mDisableRecycler ) { op . payload = null ; mUpdateOpPool . release ( op ) ; } } void recycleUpdateOpsAndClearList ( List < UpdateOp > ops ) { final int count = ops . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { recycleUpdateOp ( ops . get ( i ) ) ; } ops . clear ( ) ; } interface Callback { RecyclerView . ViewHolder findViewHolder ( int position ) ; void offsetPositionsForRemovingInvisible ( int positionStart , int itemCount ) ; void offsetPositionsForRemovingLaidOutOrNewView ( int positionStart , int itemCount ) ; void markViewHoldersUpdated ( int positionStart , int itemCount , Object payloads ) ; void onDispatchFirstPass ( UpdateOp updateOp ) ; void onDispatchSecondPass ( UpdateOp updateOp ) ; void offsetPositionsForAdd ( int positionStart , int itemCount ) ; void offsetPositionsForMove ( int from , int to ) ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ; } @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ; i < count ; i ++ ) { ViewCompat . dispatchApplyWindowInsets ( rv . getChildAt ( i ) , new WindowInsetsCompat ( applied ) ) ; } return consumeAllInsets ( applied ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private WindowInsetsCompat consumeAllInsets ( @ NonNull WindowInsetsCompat insets ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( WindowInsetsCompat . CONSUMED . toWindowInsets ( ) != null ) { return WindowInsetsCompat . CONSUMED ; } return insets . consumeSystemWindowInsets ( ) . consumeStableInsets ( ) ; } return insets ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( "<STR_LIT>" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollScrollView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollScrollView . this . scrollTo ( x , y ) ; } } } </s>
<s> package me . zhanghai . android . fastscroll ; import androidx . annotation . NonNull ; public interface ViewHelperProvider { @ NonNull FastScroller . ViewHelper getViewHelper ( ) ; } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; } return a . getColorStateList ( <NUM_LIT> ) ; } finally { a . recycle ( ) ; } } @ Nullable public static Drawable getGradientDrawableWithTintAttr ( @ DrawableRes int drawableRes , @ AttrRes int tintAttrRes , @ NonNull Context context ) { Drawable drawable = AppCompatResources . getDrawable ( context , drawableRes ) ; if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . LOLLIPOP_MR1 && drawable instanceof GradientDrawable ) { drawable = DrawableCompat . wrap ( drawable ) ; drawable . setTintList ( getColorStateListFromAttrRes ( tintAttrRes , context ) ) ; } return drawable ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( "<STR_LIT>" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) { mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + index + "<STR_LIT>" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( "<STR_LIT>" + index + "<STR_LIT>" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; } public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback { @ Override abstract public int compare ( T2 o1 , T2 o2 ) ; abstract public void onChanged ( int position , int count ) ; @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { onChanged ( position , count ) ; } abstract public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) ; abstract public boolean areItemsTheSame ( T2 item1 , T2 item2 ) ; @ Nullable public Object getChangePayload ( T2 item1 , T2 item2 ) { return null ; } } public static class BatchedCallback < T2 > extends Callback < T2 > { final Callback < T2 > mWrappedCallback ; private final BatchingListUpdateCallback mBatchingListUpdateCallback ; @ SuppressLint ( "<STR_LIT>" ) public BatchedCallback ( Callback < T2 > wrappedCallback ) { mWrappedCallback = wrappedCallback ; mBatchingListUpdateCallback = new BatchingListUpdateCallback ( mWrappedCallback ) ; } @ Override public int compare ( T2 o1 , T2 o2 ) { return mWrappedCallback . compare ( o1 , o2 ) ; } @ Override public void onInserted ( int position , int count ) { mBatchingListUpdateCallback . onInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mBatchingListUpdateCallback . onRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mBatchingListUpdateCallback . onMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mBatchingListUpdateCallback . onChanged ( position , count , null ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mBatchingListUpdateCallback . onChanged ( position , count , payload ) ; } @ Override public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) { return mWrappedCallback . areContentsTheSame ( oldItem , newItem ) ; } @ Override public boolean areItemsTheSame ( T2 item1 , T2 item2 ) { return mWrappedCallback . areItemsTheSame ( item1 , item2 ) ; } @ Nullable @ Override public Object getChangePayload ( T2 item1 , T2 item2 ) { return mWrappedCallback . getChangePayload ( item1 , item2 ) ; } public void dispatchLastEvent ( ) { mBatchingListUpdateCallback . dispatchLastEvent ( ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . graphics . Rect ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . BitSet ; import java . util . List ; public class StaggeredGridLayoutManager extends RecyclerView . LayoutManager implements RecyclerView . SmoothScroller . ScrollVectorProvider { private static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; public static final int GAP_HANDLING_NONE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) @ Deprecated public static final int GAP_HANDLING_LAZY = <NUM_LIT> ; public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = <NUM_LIT> ; static final int INVALID_OFFSET = Integer . MIN_VALUE ; private static final float MAX_SCROLL_FACTOR = <NUM_LIT> / <NUM_LIT> ; private int mSpanCount = - <NUM_LIT> ; Span [ ] mSpans ; @ NonNull OrientationHelper mPrimaryOrientation ; @ NonNull OrientationHelper mSecondaryOrientation ; private int mOrientation ; private int mSizePerSpan ; @ NonNull private final LayoutState mLayoutState ; boolean mReverseLayout = false ; boolean mShouldReverseLayout = false ; private BitSet mRemainingSpans ; int mPendingScrollPosition = RecyclerView . NO_POSITION ; int mPendingScrollPositionOffset = INVALID_OFFSET ; LazySpanLookup mLazySpanLookup = new LazySpanLookup ( ) ; private int mGapStrategy = GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS ; private boolean mLastLayoutFromEnd ; private boolean mLastLayoutRTL ; private SavedState mPendingSavedState ; private int mFullSizeSpec ; private final Rect mTmpRect = new Rect ( ) ; private final AnchorInfo mAnchorInfo = new AnchorInfo ( ) ; private boolean mLaidOutInvalidFullSpan = false ; private boolean mSmoothScrollbarEnabled = true ; private int [ ] mPrefetchDistances ; private final Runnable mCheckForGapsRunnable = new Runnable ( ) { @ Override public void run ( ) { checkForGaps ( ) ; } } ; @ SuppressWarnings ( "<STR_LIT>" ) public StaggeredGridLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setOrientation ( properties . orientation ) ; setSpanCount ( properties . spanCount ) ; setReverseLayout ( properties . reverseLayout ) ; mLayoutState = new LayoutState ( ) ; createOrientationHelpers ( ) ; } public StaggeredGridLayoutManager ( int spanCount , int orientation ) { mOrientation = orientation ; setSpanCount ( spanCount ) ; mLayoutState = new LayoutState ( ) ; createOrientationHelpers ( ) ; } @ Override public boolean isAutoMeasureEnabled ( ) { return mGapStrategy != GAP_HANDLING_NONE ; } private void createOrientationHelpers ( ) { mPrimaryOrientation = OrientationHelper . createOrientationHelper ( this , mOrientation ) ; mSecondaryOrientation = OrientationHelper . createOrientationHelper ( this , <NUM_LIT> - mOrientation ) ; } boolean checkForGaps ( ) { if ( getChildCount ( ) == <NUM_LIT> || mGapStrategy == GAP_HANDLING_NONE || ! isAttachedToWindow ( ) ) { return false ; } final int minPos , maxPos ; if ( mShouldReverseLayout ) { minPos = getLastChildPosition ( ) ; maxPos = getFirstChildPosition ( ) ; } else { minPos = getFirstChildPosition ( ) ; maxPos = getLastChildPosition ( ) ; } if ( minPos == <NUM_LIT> ) { View gapView = hasGapsToFix ( ) ; if ( gapView != null ) { mLazySpanLookup . clear ( ) ; requestSimpleAnimationsInNextLayout ( ) ; requestLayout ( ) ; return true ; } } if ( ! mLaidOutInvalidFullSpan ) { return false ; } int invalidGapDir = mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; final LazySpanLookup . FullSpanItem invalidFsi = mLazySpanLookup . getFirstFullSpanItemInRange ( minPos , maxPos + <NUM_LIT> , invalidGapDir , true ) ; if ( invalidFsi == null ) { mLaidOutInvalidFullSpan = false ; mLazySpanLookup . forceInvalidateAfter ( maxPos + <NUM_LIT> ) ; return false ; } final LazySpanLookup . FullSpanItem validFsi = mLazySpanLookup . getFirstFullSpanItemInRange ( minPos , invalidFsi . mPosition , invalidGapDir * - <NUM_LIT> , true ) ; if ( validFsi == null ) { mLazySpanLookup . forceInvalidateAfter ( invalidFsi . mPosition ) ; } else { mLazySpanLookup . forceInvalidateAfter ( validFsi . mPosition + <NUM_LIT> ) ; } requestSimpleAnimationsInNextLayout ( ) ; requestLayout ( ) ; return true ; } @ Override public void onScrollStateChanged ( int state ) { if ( state == RecyclerView . SCROLL_STATE_IDLE ) { checkForGaps ( ) ; } } @ Override public void onDetachedFromWindow ( RecyclerView view , RecyclerView . Recycler recycler ) { super . onDetachedFromWindow ( view , recycler ) ; removeCallbacks ( mCheckForGapsRunnable ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; } view . requestLayout ( ) ; } View hasGapsToFix ( ) { int startChildIndex = <NUM_LIT> ; int endChildIndex = getChildCount ( ) - <NUM_LIT> ; BitSet mSpansToCheck = new BitSet ( mSpanCount ) ; mSpansToCheck . set ( <NUM_LIT> , mSpanCount , true ) ; final int firstChildIndex , childLimit ; final int preferredSpanDir = mOrientation == VERTICAL && isLayoutRTL ( ) ? <NUM_LIT> : - <NUM_LIT> ; if ( mShouldReverseLayout ) { firstChildIndex = endChildIndex ; childLimit = startChildIndex - <NUM_LIT> ; } else { firstChildIndex = startChildIndex ; childLimit = endChildIndex + <NUM_LIT> ; } final int nextChildDiff = firstChildIndex < childLimit ? <NUM_LIT> : - <NUM_LIT> ; for ( int i = firstChildIndex ; i != childLimit ; i += nextChildDiff ) { View child = getChildAt ( i ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( mSpansToCheck . get ( lp . mSpan . mIndex ) ) { if ( checkSpanForGap ( lp . mSpan ) ) { return child ; } mSpansToCheck . clear ( lp . mSpan . mIndex ) ; } if ( lp . mFullSpan ) { continue ; } if ( i + nextChildDiff != childLimit ) { View nextChild = getChildAt ( i + nextChildDiff ) ; boolean compareSpans = false ; if ( mShouldReverseLayout ) { int myEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; int nextEnd = mPrimaryOrientation . getDecoratedEnd ( nextChild ) ; if ( myEnd < nextEnd ) { return child ; } else if ( myEnd == nextEnd ) { compareSpans = true ; } } else { int myStart = mPrimaryOrientation . getDecoratedStart ( child ) ; int nextStart = mPrimaryOrientation . getDecoratedStart ( nextChild ) ; if ( myStart > nextStart ) { return child ; } else if ( myStart == nextStart ) { compareSpans = true ; } } if ( compareSpans ) { LayoutParams nextLp = ( LayoutParams ) nextChild . getLayoutParams ( ) ; if ( lp . mSpan . mIndex - nextLp . mSpan . mIndex < <NUM_LIT> != preferredSpanDir < <NUM_LIT> ) { return child ; } } } } return null ; } private boolean checkSpanForGap ( Span span ) { if ( mShouldReverseLayout ) { if ( span . getEndLine ( ) < mPrimaryOrientation . getEndAfterPadding ( ) ) { final View endView = span . mViews . get ( span . mViews . size ( ) - <NUM_LIT> ) ; final LayoutParams lp = span . getLayoutParams ( endView ) ; return ! lp . mFullSpan ; } } else if ( span . getStartLine ( ) > mPrimaryOrientation . getStartAfterPadding ( ) ) { final View startView = span . mViews . get ( <NUM_LIT> ) ; final LayoutParams lp = span . getLayoutParams ( startView ) ; return ! lp . mFullSpan ; } return false ; } public void setSpanCount ( int spanCount ) { assertNotInLayoutOrScroll ( null ) ; if ( spanCount != mSpanCount ) { invalidateSpanAssignments ( ) ; mSpanCount = spanCount ; mRemainingSpans = new BitSet ( mSpanCount ) ; mSpans = new Span [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] = new Span ( i ) ; } requestLayout ( ) ; } } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } assertNotInLayoutOrScroll ( null ) ; if ( orientation == mOrientation ) { return ; } mOrientation = orientation ; OrientationHelper tmp = mPrimaryOrientation ; mPrimaryOrientation = mSecondaryOrientation ; mSecondaryOrientation = tmp ; requestLayout ( ) ; } public void setReverseLayout ( boolean reverseLayout ) { assertNotInLayoutOrScroll ( null ) ; if ( mPendingSavedState != null && mPendingSavedState . mReverseLayout != reverseLayout ) { mPendingSavedState . mReverseLayout = reverseLayout ; } mReverseLayout = reverseLayout ; requestLayout ( ) ; } public int getGapStrategy ( ) { return mGapStrategy ; } public void setGapStrategy ( int gapStrategy ) { assertNotInLayoutOrScroll ( null ) ; if ( gapStrategy == mGapStrategy ) { return ; } if ( gapStrategy != GAP_HANDLING_NONE && gapStrategy != GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mGapStrategy = gapStrategy ; requestLayout ( ) ; } @ Override public void assertNotInLayoutOrScroll ( String message ) { if ( mPendingSavedState == null ) { super . assertNotInLayoutOrScroll ( message ) ; } } public int getSpanCount ( ) { return mSpanCount ; } public void invalidateSpanAssignments ( ) { mLazySpanLookup . clear ( ) ; requestLayout ( ) ; } private void resolveShouldLayoutReverse ( ) { if ( mOrientation == VERTICAL || ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } boolean isLayoutRTL ( ) { return getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } public boolean getReverseLayout ( ) { return mReverseLayout ; } @ Override public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { final int width , height ; final int horizontalPadding = getPaddingLeft ( ) + getPaddingRight ( ) ; final int verticalPadding = getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mOrientation == VERTICAL ) { final int usedHeight = childrenBounds . height ( ) + verticalPadding ; height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; width = chooseSize ( wSpec , mSizePerSpan * mSpanCount + horizontalPadding , getMinimumWidth ( ) ) ; } else { final int usedWidth = childrenBounds . width ( ) + horizontalPadding ; width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; height = chooseSize ( hSpec , mSizePerSpan * mSpanCount + verticalPadding , getMinimumHeight ( ) ) ; } setMeasuredDimension ( width , height ) ; } @ Override public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { onLayoutChildren ( recycler , state , true ) ; } @ Override public void onAdapterChanged ( @ Nullable RecyclerView . Adapter oldAdapter , @ Nullable RecyclerView . Adapter newAdapter ) { mLazySpanLookup . clear ( ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; } } private void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean shouldCheckForGaps ) { final AnchorInfo anchorInfo = mAnchorInfo ; if ( mPendingSavedState != null || mPendingScrollPosition != RecyclerView . NO_POSITION ) { if ( state . getItemCount ( ) == <NUM_LIT> ) { removeAndRecycleAllViews ( recycler ) ; anchorInfo . reset ( ) ; return ; } } boolean recalculateAnchor = ! anchorInfo . mValid || mPendingScrollPosition != RecyclerView . NO_POSITION || mPendingSavedState != null ; if ( recalculateAnchor ) { anchorInfo . reset ( ) ; if ( mPendingSavedState != null ) { applyPendingSavedState ( anchorInfo ) ; } else { resolveShouldLayoutReverse ( ) ; anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; } updateAnchorInfoForLayout ( state , anchorInfo ) ; anchorInfo . mValid = true ; } if ( mPendingSavedState == null && mPendingScrollPosition == RecyclerView . NO_POSITION ) { if ( anchorInfo . mLayoutFromEnd != mLastLayoutFromEnd || isLayoutRTL ( ) != mLastLayoutRTL ) { mLazySpanLookup . clear ( ) ; anchorInfo . mInvalidateOffsets = true ; } } if ( getChildCount ( ) > <NUM_LIT> && ( mPendingSavedState == null || mPendingSavedState . mSpanOffsetsSize < <NUM_LIT> ) ) { if ( anchorInfo . mInvalidateOffsets ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; if ( anchorInfo . mOffset != INVALID_OFFSET ) { mSpans [ i ] . setLine ( anchorInfo . mOffset ) ; } } } else { if ( recalculateAnchor || mAnchorInfo . mSpanReferenceLines == null ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . cacheReferenceLineAndClear ( mShouldReverseLayout , anchorInfo . mOffset ) ; } mAnchorInfo . saveSpanReferenceLines ( mSpans ) ; } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final Span span = mSpans [ i ] ; span . clear ( ) ; span . setLine ( mAnchorInfo . mSpanReferenceLines [ i ] ) ; } } } } detachAndScrapAttachedViews ( recycler ) ; mLayoutState . mRecycle = false ; mLaidOutInvalidFullSpan = false ; updateMeasureSpecs ( mSecondaryOrientation . getTotalSpace ( ) ) ; updateLayoutState ( anchorInfo . mPosition , state ) ; if ( anchorInfo . mLayoutFromEnd ) { setLayoutStateDirection ( LayoutState . LAYOUT_START ) ; fill ( recycler , mLayoutState , state ) ; setLayoutStateDirection ( LayoutState . LAYOUT_END ) ; mLayoutState . mCurrentPosition = anchorInfo . mPosition + mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state ) ; } else { setLayoutStateDirection ( LayoutState . LAYOUT_END ) ; fill ( recycler , mLayoutState , state ) ; setLayoutStateDirection ( LayoutState . LAYOUT_START ) ; mLayoutState . mCurrentPosition = anchorInfo . mPosition + mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state ) ; } repositionToWrapContentIfNecessary ( ) ; if ( getChildCount ( ) > <NUM_LIT> ) { if ( mShouldReverseLayout ) { fixEndGap ( recycler , state , true ) ; fixStartGap ( recycler , state , false ) ; } else { fixStartGap ( recycler , state , true ) ; fixEndGap ( recycler , state , false ) ; } } boolean hasGaps = false ; if ( shouldCheckForGaps && ! state . isPreLayout ( ) ) { final boolean needToCheckForGaps = mGapStrategy != GAP_HANDLING_NONE && getChildCount ( ) > <NUM_LIT> && ( mLaidOutInvalidFullSpan || hasGapsToFix ( ) != null ) ; if ( needToCheckForGaps ) { removeCallbacks ( mCheckForGapsRunnable ) ; if ( checkForGaps ( ) ) { hasGaps = true ; } } } if ( state . isPreLayout ( ) ) { mAnchorInfo . reset ( ) ; } mLastLayoutFromEnd = anchorInfo . mLayoutFromEnd ; mLastLayoutRTL = isLayoutRTL ( ) ; if ( hasGaps ) { mAnchorInfo . reset ( ) ; onLayoutChildren ( recycler , state , false ) ; } } @ Override public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; mPendingSavedState = null ; mAnchorInfo . reset ( ) ; } private void repositionToWrapContentIfNecessary ( ) { if ( mSecondaryOrientation . getMode ( ) == View . MeasureSpec . EXACTLY ) { return ; } float maxSize = <NUM_LIT> ; final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; float size = mSecondaryOrientation . getDecoratedMeasurement ( child ) ; if ( size < maxSize ) { continue ; } LayoutParams layoutParams = ( LayoutParams ) child . getLayoutParams ( ) ; if ( layoutParams . isFullSpan ( ) ) { size = <NUM_LIT> * size / mSpanCount ; } maxSize = Math . max ( maxSize , size ) ; } int before = mSizePerSpan ; int desired = Math . round ( maxSize * mSpanCount ) ; if ( mSecondaryOrientation . getMode ( ) == View . MeasureSpec . AT_MOST ) { desired = Math . min ( desired , mSecondaryOrientation . getTotalSpace ( ) ) ; } updateMeasureSpecs ( desired ) ; if ( mSizePerSpan == before ) { return ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { continue ; } if ( isLayoutRTL ( ) && mOrientation == VERTICAL ) { int newOffset = - ( mSpanCount - <NUM_LIT> - lp . mSpan . mIndex ) * mSizePerSpan ; int prevOffset = - ( mSpanCount - <NUM_LIT> - lp . mSpan . mIndex ) * before ; child . offsetLeftAndRight ( newOffset - prevOffset ) ; } else { int newOffset = lp . mSpan . mIndex * mSizePerSpan ; int prevOffset = lp . mSpan . mIndex * before ; if ( mOrientation == VERTICAL ) { child . offsetLeftAndRight ( newOffset - prevOffset ) ; } else { child . offsetTopAndBottom ( newOffset - prevOffset ) ; } } } } private void applyPendingSavedState ( AnchorInfo anchorInfo ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mPendingSavedState ) ; } if ( mPendingSavedState . mSpanOffsetsSize > <NUM_LIT> ) { if ( mPendingSavedState . mSpanOffsetsSize == mSpanCount ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . clear ( ) ; int line = mPendingSavedState . mSpanOffsets [ i ] ; if ( line != Span . INVALID_LINE ) { if ( mPendingSavedState . mAnchorLayoutFromEnd ) { line += mPrimaryOrientation . getEndAfterPadding ( ) ; } else { line += mPrimaryOrientation . getStartAfterPadding ( ) ; } } mSpans [ i ] . setLine ( line ) ; } } else { mPendingSavedState . invalidateSpanInfo ( ) ; mPendingSavedState . mAnchorPosition = mPendingSavedState . mVisibleAnchorPosition ; } } mLastLayoutRTL = mPendingSavedState . mLastLayoutRTL ; setReverseLayout ( mPendingSavedState . mReverseLayout ) ; resolveShouldLayoutReverse ( ) ; if ( mPendingSavedState . mAnchorPosition != RecyclerView . NO_POSITION ) { mPendingScrollPosition = mPendingSavedState . mAnchorPosition ; anchorInfo . mLayoutFromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; } else { anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; } if ( mPendingSavedState . mSpanLookupSize > <NUM_LIT> ) { mLazySpanLookup . mData = mPendingSavedState . mSpanLookup ; mLazySpanLookup . mFullSpanItems = mPendingSavedState . mFullSpanItems ; } } void updateAnchorInfoForLayout ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( updateAnchorFromPendingData ( state , anchorInfo ) ) { return ; } if ( updateAnchorFromChildren ( state , anchorInfo ) ) { return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } anchorInfo . assignCoordinateFromPadding ( ) ; anchorInfo . mPosition = <NUM_LIT> ; } private boolean updateAnchorFromChildren ( RecyclerView . State state , AnchorInfo anchorInfo ) { anchorInfo . mPosition = mLastLayoutFromEnd ? findLastReferenceChildPosition ( state . getItemCount ( ) ) : findFirstReferenceChildPosition ( state . getItemCount ( ) ) ; anchorInfo . mOffset = INVALID_OFFSET ; return true ; } boolean updateAnchorFromPendingData ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( state . isPreLayout ( ) || mPendingScrollPosition == RecyclerView . NO_POSITION ) { return false ; } if ( mPendingScrollPosition < <NUM_LIT> || mPendingScrollPosition >= state . getItemCount ( ) ) { mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; return false ; } if ( mPendingSavedState == null || mPendingSavedState . mAnchorPosition == RecyclerView . NO_POSITION || mPendingSavedState . mSpanOffsetsSize < <NUM_LIT> ) { final View child = findViewByPosition ( mPendingScrollPosition ) ; if ( child != null ) { anchorInfo . mPosition = mShouldReverseLayout ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; if ( mPendingScrollPositionOffset != INVALID_OFFSET ) { if ( anchorInfo . mLayoutFromEnd ) { final int target = mPrimaryOrientation . getEndAfterPadding ( ) - mPendingScrollPositionOffset ; anchorInfo . mOffset = target - mPrimaryOrientation . getDecoratedEnd ( child ) ; } else { final int target = mPrimaryOrientation . getStartAfterPadding ( ) + mPendingScrollPositionOffset ; anchorInfo . mOffset = target - mPrimaryOrientation . getDecoratedStart ( child ) ; } return true ; } final int childSize = mPrimaryOrientation . getDecoratedMeasurement ( child ) ; if ( childSize > mPrimaryOrientation . getTotalSpace ( ) ) { anchorInfo . mOffset = anchorInfo . mLayoutFromEnd ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; return true ; } final int startGap = mPrimaryOrientation . getDecoratedStart ( child ) - mPrimaryOrientation . getStartAfterPadding ( ) ; if ( startGap < <NUM_LIT> ) { anchorInfo . mOffset = - startGap ; return true ; } final int endGap = mPrimaryOrientation . getEndAfterPadding ( ) - mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( endGap < <NUM_LIT> ) { anchorInfo . mOffset = endGap ; return true ; } anchorInfo . mOffset = INVALID_OFFSET ; } else { anchorInfo . mPosition = mPendingScrollPosition ; if ( mPendingScrollPositionOffset == INVALID_OFFSET ) { final int position = calculateScrollDirectionForPosition ( anchorInfo . mPosition ) ; anchorInfo . mLayoutFromEnd = position == LayoutState . LAYOUT_END ; anchorInfo . assignCoordinateFromPadding ( ) ; } else { anchorInfo . assignCoordinateFromPadding ( mPendingScrollPositionOffset ) ; } anchorInfo . mInvalidateOffsets = true ; } } else { anchorInfo . mOffset = INVALID_OFFSET ; anchorInfo . mPosition = mPendingScrollPosition ; } return true ; } void updateMeasureSpecs ( int totalSpace ) { mSizePerSpan = totalSpace / mSpanCount ; mFullSizeSpec = View . MeasureSpec . makeMeasureSpec ( totalSpace , mSecondaryOrientation . getMode ( ) ) ; } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null ; } public int [ ] findFirstVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findFirstVisibleItemPosition ( ) ; } return into ; } public int [ ] findFirstCompletelyVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findFirstCompletelyVisibleItemPosition ( ) ; } return into ; } public int [ ] findLastVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findLastVisibleItemPosition ( ) ; } return into ; } public int [ ] findLastCompletelyVisibleItemPositions ( int [ ] into ) { if ( into == null ) { into = new int [ mSpanCount ] ; } else if ( into . length < mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + mSpanCount + "<STR_LIT>" + into . length ) ; } for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { into [ i ] = mSpans [ i ] . findLastCompletelyVisibleItemPosition ( ) ; } return into ; } @ Override public int computeHorizontalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } private int computeScrollOffset ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollOffset ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled , mShouldReverseLayout ) ; } @ Override public int computeVerticalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override public int computeHorizontalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } private int computeScrollExtent ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollExtent ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled ) ; } @ Override public int computeVerticalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override public int computeHorizontalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private int computeScrollRange ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } return ScrollbarHelper . computeScrollRange ( state , mPrimaryOrientation , findFirstVisibleItemClosestToStart ( ! mSmoothScrollbarEnabled ) , findFirstVisibleItemClosestToEnd ( ! mSmoothScrollbarEnabled ) , this , mSmoothScrollbarEnabled ) ; } @ Override public int computeVerticalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private void measureChildWithDecorationsAndMargin ( View child , LayoutParams lp , boolean alreadyMeasured ) { if ( lp . mFullSpan ) { if ( mOrientation == VERTICAL ) { measureChildWithDecorationsAndMargin ( child , mFullSizeSpec , getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) , lp . height , true ) , alreadyMeasured ) ; } else { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) , lp . width , true ) , mFullSizeSpec , alreadyMeasured ) ; } } else { if ( mOrientation == VERTICAL ) { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( mSizePerSpan , getWidthMode ( ) , <NUM_LIT> , lp . width , false ) , getChildMeasureSpec ( getHeight ( ) , getHeightMode ( ) , getPaddingTop ( ) + getPaddingBottom ( ) , lp . height , true ) , alreadyMeasured ) ; } else { measureChildWithDecorationsAndMargin ( child , getChildMeasureSpec ( getWidth ( ) , getWidthMode ( ) , getPaddingLeft ( ) + getPaddingRight ( ) , lp . width , true ) , getChildMeasureSpec ( mSizePerSpan , getHeightMode ( ) , <NUM_LIT> , lp . height , false ) , alreadyMeasured ) ; } } } private void measureChildWithDecorationsAndMargin ( View child , int widthSpec , int heightSpec , boolean alreadyMeasured ) { calculateItemDecorationsForChild ( child , mTmpRect ) ; LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; widthSpec = updateSpecWithExtra ( widthSpec , lp . leftMargin + mTmpRect . left , lp . rightMargin + mTmpRect . right ) ; heightSpec = updateSpecWithExtra ( heightSpec , lp . topMargin + mTmpRect . top , lp . bottomMargin + mTmpRect . bottom ) ; final boolean measure = alreadyMeasured ? shouldReMeasureChild ( child , widthSpec , heightSpec , lp ) : shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ; if ( measure ) { child . measure ( widthSpec , heightSpec ) ; } } private int updateSpecWithExtra ( int spec , int startInset , int endInset ) { if ( startInset == <NUM_LIT> && endInset == <NUM_LIT> ) { return spec ; } final int mode = View . MeasureSpec . getMode ( spec ) ; if ( mode == View . MeasureSpec . AT_MOST || mode == View . MeasureSpec . EXACTLY ) { return View . MeasureSpec . makeMeasureSpec ( Math . max ( <NUM_LIT> , View . MeasureSpec . getSize ( spec ) - startInset - endInset ) , mode ) ; } return spec ; } @ Override public void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof SavedState ) { mPendingSavedState = ( SavedState ) state ; if ( mPendingScrollPosition != RecyclerView . NO_POSITION ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; mPendingSavedState . invalidateSpanInfo ( ) ; } requestLayout ( ) ; } else if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } @ Override public Parcelable onSaveInstanceState ( ) { if ( mPendingSavedState != null ) { return new SavedState ( mPendingSavedState ) ; } SavedState state = new SavedState ( ) ; state . mReverseLayout = mReverseLayout ; state . mAnchorLayoutFromEnd = mLastLayoutFromEnd ; state . mLastLayoutRTL = mLastLayoutRTL ; if ( mLazySpanLookup != null && mLazySpanLookup . mData != null ) { state . mSpanLookup = mLazySpanLookup . mData ; state . mSpanLookupSize = state . mSpanLookup . length ; state . mFullSpanItems = mLazySpanLookup . mFullSpanItems ; } else { state . mSpanLookupSize = <NUM_LIT> ; } if ( getChildCount ( ) > <NUM_LIT> ) { state . mAnchorPosition = mLastLayoutFromEnd ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; state . mVisibleAnchorPosition = findFirstVisibleItemPositionInt ( ) ; state . mSpanOffsetsSize = mSpanCount ; state . mSpanOffsets = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { int line ; if ( mLastLayoutFromEnd ) { line = mSpans [ i ] . getEndLine ( Span . INVALID_LINE ) ; if ( line != Span . INVALID_LINE ) { line -= mPrimaryOrientation . getEndAfterPadding ( ) ; } } else { line = mSpans [ i ] . getStartLine ( Span . INVALID_LINE ) ; if ( line != Span . INVALID_LINE ) { line -= mPrimaryOrientation . getStartAfterPadding ( ) ; } } state . mSpanOffsets [ i ] = line ; } } else { state . mAnchorPosition = RecyclerView . NO_POSITION ; state . mVisibleAnchorPosition = RecyclerView . NO_POSITION ; state . mSpanOffsetsSize = <NUM_LIT> ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + state ) ; } return state ; } @ Override public void onInitializeAccessibilityEvent ( AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; if ( getChildCount ( ) > <NUM_LIT> ) { final View start = findFirstVisibleItemClosestToStart ( false ) ; final View end = findFirstVisibleItemClosestToEnd ( false ) ; if ( start == null || end == null ) { return ; } final int startPos = getPosition ( start ) ; final int endPos = getPosition ( end ) ; if ( startPos < endPos ) { event . setFromIndex ( startPos ) ; event . setToIndex ( endPos ) ; } else { event . setFromIndex ( endPos ) ; event . setToIndex ( startPos ) ; } } } int findFirstVisibleItemPositionInt ( ) { final View first = mShouldReverseLayout ? findFirstVisibleItemClosestToEnd ( true ) : findFirstVisibleItemClosestToStart ( true ) ; return first == null ? RecyclerView . NO_POSITION : getPosition ( first ) ; } View findFirstVisibleItemClosestToStart ( boolean fullyVisible ) { final int boundsStart = mPrimaryOrientation . getStartAfterPadding ( ) ; final int boundsEnd = mPrimaryOrientation . getEndAfterPadding ( ) ; final int limit = getChildCount ( ) ; View partiallyVisible = null ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View child = getChildAt ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( childEnd <= boundsStart || childStart >= boundsEnd ) { continue ; } if ( childStart >= boundsStart || ! fullyVisible ) { return child ; } if ( partiallyVisible == null ) { partiallyVisible = child ; } } return partiallyVisible ; } View findFirstVisibleItemClosestToEnd ( boolean fullyVisible ) { final int boundsStart = mPrimaryOrientation . getStartAfterPadding ( ) ; final int boundsEnd = mPrimaryOrientation . getEndAfterPadding ( ) ; View partiallyVisible = null ; for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View child = getChildAt ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; if ( childEnd <= boundsStart || childStart >= boundsEnd ) { continue ; } if ( childEnd <= boundsEnd || ! fullyVisible ) { return child ; } if ( partiallyVisible == null ) { partiallyVisible = child ; } } return partiallyVisible ; } private void fixEndGap ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { final int maxEndLine = getMaxEnd ( Integer . MIN_VALUE ) ; if ( maxEndLine == Integer . MIN_VALUE ) { return ; } int gap = mPrimaryOrientation . getEndAfterPadding ( ) - maxEndLine ; int fixOffset ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( - gap , recycler , state ) ; } else { return ; } gap -= fixOffset ; if ( canOffsetChildren && gap > <NUM_LIT> ) { mPrimaryOrientation . offsetChildren ( gap ) ; } } private void fixStartGap ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { final int minStartLine = getMinStart ( Integer . MAX_VALUE ) ; if ( minStartLine == Integer . MAX_VALUE ) { return ; } int gap = minStartLine - mPrimaryOrientation . getStartAfterPadding ( ) ; int fixOffset ; if ( gap > <NUM_LIT> ) { fixOffset = scrollBy ( gap , recycler , state ) ; } else { return ; } gap -= fixOffset ; if ( canOffsetChildren && gap > <NUM_LIT> ) { mPrimaryOrientation . offsetChildren ( - gap ) ; } } private void updateLayoutState ( int anchorPosition , RecyclerView . State state ) { mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . mCurrentPosition = anchorPosition ; int startExtra = <NUM_LIT> ; int endExtra = <NUM_LIT> ; if ( isSmoothScrolling ( ) ) { final int targetPos = state . getTargetScrollPosition ( ) ; if ( targetPos != RecyclerView . NO_POSITION ) { if ( mShouldReverseLayout == targetPos < anchorPosition ) { endExtra = mPrimaryOrientation . getTotalSpace ( ) ; } else { startExtra = mPrimaryOrientation . getTotalSpace ( ) ; } } } final boolean clipToPadding = getClipToPadding ( ) ; if ( clipToPadding ) { mLayoutState . mStartLine = mPrimaryOrientation . getStartAfterPadding ( ) - startExtra ; mLayoutState . mEndLine = mPrimaryOrientation . getEndAfterPadding ( ) + endExtra ; } else { mLayoutState . mEndLine = mPrimaryOrientation . getEnd ( ) + endExtra ; mLayoutState . mStartLine = - startExtra ; } mLayoutState . mStopInFocusable = false ; mLayoutState . mRecycle = true ; mLayoutState . mInfinite = mPrimaryOrientation . getMode ( ) == View . MeasureSpec . UNSPECIFIED && mPrimaryOrientation . getEnd ( ) == <NUM_LIT> ; } private void setLayoutStateDirection ( int direction ) { mLayoutState . mLayoutDirection = direction ; mLayoutState . mItemDirection = ( mShouldReverseLayout == ( direction == LayoutState . LAYOUT_START ) ) ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; } @ Override public void offsetChildrenHorizontal ( int dx ) { super . offsetChildrenHorizontal ( dx ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . onOffset ( dx ) ; } } @ Override public void offsetChildrenVertical ( int dy ) { super . offsetChildrenVertical ( dy ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { mSpans [ i ] . onOffset ( dy ) ; } } @ Override public void onItemsRemoved ( RecyclerView recyclerView , int positionStart , int itemCount ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . REMOVE ) ; } @ Override public void onItemsAdded ( RecyclerView recyclerView , int positionStart , int itemCount ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . ADD ) ; } @ Override public void onItemsChanged ( RecyclerView recyclerView ) { mLazySpanLookup . clear ( ) ; requestLayout ( ) ; } @ Override public void onItemsMoved ( RecyclerView recyclerView , int from , int to , int itemCount ) { handleUpdate ( from , to , AdapterHelper . UpdateOp . MOVE ) ; } @ Override public void onItemsUpdated ( RecyclerView recyclerView , int positionStart , int itemCount , Object payload ) { handleUpdate ( positionStart , itemCount , AdapterHelper . UpdateOp . UPDATE ) ; } private void handleUpdate ( int positionStart , int itemCountOrToPosition , int cmd ) { int minPosition = mShouldReverseLayout ? getLastChildPosition ( ) : getFirstChildPosition ( ) ; final int affectedRangeEnd ; final int affectedRangeStart ; if ( cmd == AdapterHelper . UpdateOp . MOVE ) { if ( positionStart < itemCountOrToPosition ) { affectedRangeEnd = itemCountOrToPosition + <NUM_LIT> ; affectedRangeStart = positionStart ; } else { affectedRangeEnd = positionStart + <NUM_LIT> ; affectedRangeStart = itemCountOrToPosition ; } } else { affectedRangeStart = positionStart ; affectedRangeEnd = positionStart + itemCountOrToPosition ; } mLazySpanLookup . invalidateAfter ( affectedRangeStart ) ; switch ( cmd ) { case AdapterHelper . UpdateOp . ADD : mLazySpanLookup . offsetForAddition ( positionStart , itemCountOrToPosition ) ; break ; case AdapterHelper . UpdateOp . REMOVE : mLazySpanLookup . offsetForRemoval ( positionStart , itemCountOrToPosition ) ; break ; case AdapterHelper . UpdateOp . MOVE : mLazySpanLookup . offsetForRemoval ( positionStart , <NUM_LIT> ) ; mLazySpanLookup . offsetForAddition ( itemCountOrToPosition , <NUM_LIT> ) ; break ; } if ( affectedRangeEnd <= minPosition ) { return ; } int maxPosition = mShouldReverseLayout ? getFirstChildPosition ( ) : getLastChildPosition ( ) ; if ( affectedRangeStart <= maxPosition ) { requestLayout ( ) ; } } private int fill ( RecyclerView . Recycler recycler , LayoutState layoutState , RecyclerView . State state ) { mRemainingSpans . set ( <NUM_LIT> , mSpanCount , true ) ; final int targetLine ; if ( mLayoutState . mInfinite ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { targetLine = Integer . MAX_VALUE ; } else { targetLine = Integer . MIN_VALUE ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { targetLine = layoutState . mEndLine + layoutState . mAvailable ; } else { targetLine = layoutState . mStartLine - layoutState . mAvailable ; } } updateAllRemainingSpans ( layoutState . mLayoutDirection , targetLine ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + targetLine + "<STR_LIT>" + "<STR_LIT>" + mRemainingSpans + "<STR_LIT>" + layoutState ) ; } final int defaultNewViewLine = mShouldReverseLayout ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; boolean added = false ; while ( layoutState . hasMore ( state ) && ( mLayoutState . mInfinite || ! mRemainingSpans . isEmpty ( ) ) ) { View view = layoutState . next ( recycler ) ; LayoutParams lp = ( ( LayoutParams ) view . getLayoutParams ( ) ) ; final int position = lp . getViewLayoutPosition ( ) ; final int spanIndex = mLazySpanLookup . getSpan ( position ) ; Span currentSpan ; final boolean assignSpan = spanIndex == LayoutParams . INVALID_SPAN_ID ; if ( assignSpan ) { currentSpan = lp . mFullSpan ? mSpans [ <NUM_LIT> ] : getNextSpan ( layoutState ) ; mLazySpanLookup . setSpan ( position , currentSpan ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + currentSpan . mIndex + "<STR_LIT>" + position ) ; } } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + spanIndex + "<STR_LIT>" + position ) ; } currentSpan = mSpans [ spanIndex ] ; } lp . mSpan = currentSpan ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } measureChildWithDecorationsAndMargin ( view , lp , false ) ; final int start ; final int end ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { start = lp . mFullSpan ? getMaxEnd ( defaultNewViewLine ) : currentSpan . getEndLine ( defaultNewViewLine ) ; end = start + mPrimaryOrientation . getDecoratedMeasurement ( view ) ; if ( assignSpan && lp . mFullSpan ) { LazySpanLookup . FullSpanItem fullSpanItem ; fullSpanItem = createFullSpanItemFromEnd ( start ) ; fullSpanItem . mGapDir = LayoutState . LAYOUT_START ; fullSpanItem . mPosition = position ; mLazySpanLookup . addFullSpanItem ( fullSpanItem ) ; } } else { end = lp . mFullSpan ? getMinStart ( defaultNewViewLine ) : currentSpan . getStartLine ( defaultNewViewLine ) ; start = end - mPrimaryOrientation . getDecoratedMeasurement ( view ) ; if ( assignSpan && lp . mFullSpan ) { LazySpanLookup . FullSpanItem fullSpanItem ; fullSpanItem = createFullSpanItemFromStart ( end ) ; fullSpanItem . mGapDir = LayoutState . LAYOUT_END ; fullSpanItem . mPosition = position ; mLazySpanLookup . addFullSpanItem ( fullSpanItem ) ; } } if ( lp . mFullSpan && layoutState . mItemDirection == LayoutState . ITEM_DIRECTION_HEAD ) { if ( assignSpan ) { mLaidOutInvalidFullSpan = true ; } else { final boolean hasInvalidGap ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { hasInvalidGap = ! areAllEndsEqual ( ) ; } else { hasInvalidGap = ! areAllStartsEqual ( ) ; } if ( hasInvalidGap ) { final LazySpanLookup . FullSpanItem fullSpanItem = mLazySpanLookup . getFullSpanItem ( position ) ; if ( fullSpanItem != null ) { fullSpanItem . mHasUnwantedGapAfter = true ; } mLaidOutInvalidFullSpan = true ; } } } attachViewToSpans ( view , lp , layoutState ) ; final int otherStart ; final int otherEnd ; if ( isLayoutRTL ( ) && mOrientation == VERTICAL ) { otherEnd = lp . mFullSpan ? mSecondaryOrientation . getEndAfterPadding ( ) : mSecondaryOrientation . getEndAfterPadding ( ) - ( mSpanCount - <NUM_LIT> - currentSpan . mIndex ) * mSizePerSpan ; otherStart = otherEnd - mSecondaryOrientation . getDecoratedMeasurement ( view ) ; } else { otherStart = lp . mFullSpan ? mSecondaryOrientation . getStartAfterPadding ( ) : currentSpan . mIndex * mSizePerSpan + mSecondaryOrientation . getStartAfterPadding ( ) ; otherEnd = otherStart + mSecondaryOrientation . getDecoratedMeasurement ( view ) ; } if ( mOrientation == VERTICAL ) { layoutDecoratedWithMargins ( view , otherStart , start , otherEnd , end ) ; } else { layoutDecoratedWithMargins ( view , start , otherStart , end , otherEnd ) ; } if ( lp . mFullSpan ) { updateAllRemainingSpans ( mLayoutState . mLayoutDirection , targetLine ) ; } else { updateRemainingSpans ( currentSpan , mLayoutState . mLayoutDirection , targetLine ) ; } recycle ( recycler , mLayoutState ) ; if ( mLayoutState . mStopInFocusable && view . hasFocusable ( ) ) { if ( lp . mFullSpan ) { mRemainingSpans . clear ( ) ; } else { mRemainingSpans . set ( currentSpan . mIndex , false ) ; } } added = true ; } if ( ! added ) { recycle ( recycler , mLayoutState ) ; } final int diff ; if ( mLayoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { final int minStart = getMinStart ( mPrimaryOrientation . getStartAfterPadding ( ) ) ; diff = mPrimaryOrientation . getStartAfterPadding ( ) - minStart ; } else { final int maxEnd = getMaxEnd ( mPrimaryOrientation . getEndAfterPadding ( ) ) ; diff = maxEnd - mPrimaryOrientation . getEndAfterPadding ( ) ; } return diff > <NUM_LIT> ? Math . min ( layoutState . mAvailable , diff ) : <NUM_LIT> ; } private LazySpanLookup . FullSpanItem createFullSpanItemFromEnd ( int newItemTop ) { LazySpanLookup . FullSpanItem fsi = new LazySpanLookup . FullSpanItem ( ) ; fsi . mGapPerSpan = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { fsi . mGapPerSpan [ i ] = newItemTop - mSpans [ i ] . getEndLine ( newItemTop ) ; } return fsi ; } private LazySpanLookup . FullSpanItem createFullSpanItemFromStart ( int newItemBottom ) { LazySpanLookup . FullSpanItem fsi = new LazySpanLookup . FullSpanItem ( ) ; fsi . mGapPerSpan = new int [ mSpanCount ] ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { fsi . mGapPerSpan [ i ] = mSpans [ i ] . getStartLine ( newItemBottom ) - newItemBottom ; } return fsi ; } private void attachViewToSpans ( View view , LayoutParams lp , LayoutState layoutState ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { if ( lp . mFullSpan ) { appendViewToAllSpans ( view ) ; } else { lp . mSpan . appendToSpan ( view ) ; } } else { if ( lp . mFullSpan ) { prependViewToAllSpans ( view ) ; } else { lp . mSpan . prependToSpan ( view ) ; } } } private void recycle ( RecyclerView . Recycler recycler , LayoutState layoutState ) { if ( ! layoutState . mRecycle || layoutState . mInfinite ) { return ; } if ( layoutState . mAvailable == <NUM_LIT> ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { recycleFromEnd ( recycler , layoutState . mEndLine ) ; } else { recycleFromStart ( recycler , layoutState . mStartLine ) ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { int scrolled = layoutState . mStartLine - getMaxStart ( layoutState . mStartLine ) ; final int line ; if ( scrolled < <NUM_LIT> ) { line = layoutState . mEndLine ; } else { line = layoutState . mEndLine - Math . min ( scrolled , layoutState . mAvailable ) ; } recycleFromEnd ( recycler , line ) ; } else { int scrolled = getMinEnd ( layoutState . mEndLine ) - layoutState . mEndLine ; final int line ; if ( scrolled < <NUM_LIT> ) { line = layoutState . mStartLine ; } else { line = layoutState . mStartLine + Math . min ( scrolled , layoutState . mAvailable ) ; } recycleFromStart ( recycler , line ) ; } } } private void appendViewToAllSpans ( View view ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mSpans [ i ] . appendToSpan ( view ) ; } } private void prependViewToAllSpans ( View view ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mSpans [ i ] . prependToSpan ( view ) ; } } private void updateAllRemainingSpans ( int layoutDir , int targetLine ) { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . mViews . isEmpty ( ) ) { continue ; } updateRemainingSpans ( mSpans [ i ] , layoutDir , targetLine ) ; } } private void updateRemainingSpans ( Span span , int layoutDir , int targetLine ) { final int deletedSize = span . getDeletedSize ( ) ; if ( layoutDir == LayoutState . LAYOUT_START ) { final int line = span . getStartLine ( ) ; if ( line + deletedSize <= targetLine ) { mRemainingSpans . set ( span . mIndex , false ) ; } } else { final int line = span . getEndLine ( ) ; if ( line - deletedSize >= targetLine ) { mRemainingSpans . set ( span . mIndex , false ) ; } } } private int getMaxStart ( int def ) { int maxStart = mSpans [ <NUM_LIT> ] . getStartLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanStart = mSpans [ i ] . getStartLine ( def ) ; if ( spanStart > maxStart ) { maxStart = spanStart ; } } return maxStart ; } private int getMinStart ( int def ) { int minStart = mSpans [ <NUM_LIT> ] . getStartLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanStart = mSpans [ i ] . getStartLine ( def ) ; if ( spanStart < minStart ) { minStart = spanStart ; } } return minStart ; } boolean areAllEndsEqual ( ) { int end = mSpans [ <NUM_LIT> ] . getEndLine ( Span . INVALID_LINE ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . getEndLine ( Span . INVALID_LINE ) != end ) { return false ; } } return true ; } boolean areAllStartsEqual ( ) { int start = mSpans [ <NUM_LIT> ] . getStartLine ( Span . INVALID_LINE ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { if ( mSpans [ i ] . getStartLine ( Span . INVALID_LINE ) != start ) { return false ; } } return true ; } private int getMaxEnd ( int def ) { int maxEnd = mSpans [ <NUM_LIT> ] . getEndLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanEnd = mSpans [ i ] . getEndLine ( def ) ; if ( spanEnd > maxEnd ) { maxEnd = spanEnd ; } } return maxEnd ; } private int getMinEnd ( int def ) { int minEnd = mSpans [ <NUM_LIT> ] . getEndLine ( def ) ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { final int spanEnd = mSpans [ i ] . getEndLine ( def ) ; if ( spanEnd < minEnd ) { minEnd = spanEnd ; } } return minEnd ; } private void recycleFromStart ( RecyclerView . Recycler recycler , int line ) { while ( getChildCount ( ) > <NUM_LIT> ) { View child = getChildAt ( <NUM_LIT> ) ; if ( mPrimaryOrientation . getDecoratedEnd ( child ) <= line && mPrimaryOrientation . getTransformedEndWithDecoration ( child ) <= line ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { if ( mSpans [ j ] . mViews . size ( ) == <NUM_LIT> ) { return ; } } for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { mSpans [ j ] . popStart ( ) ; } } else { if ( lp . mSpan . mViews . size ( ) == <NUM_LIT> ) { return ; } lp . mSpan . popStart ( ) ; } removeAndRecycleView ( child , recycler ) ; } else { return ; } } } private void recycleFromEnd ( RecyclerView . Recycler recycler , int line ) { final int childCount = getChildCount ( ) ; int i ; for ( i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mPrimaryOrientation . getDecoratedStart ( child ) >= line && mPrimaryOrientation . getTransformedStartWithDecoration ( child ) >= line ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mFullSpan ) { for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { if ( mSpans [ j ] . mViews . size ( ) == <NUM_LIT> ) { return ; } } for ( int j = <NUM_LIT> ; j < mSpanCount ; j ++ ) { mSpans [ j ] . popEnd ( ) ; } } else { if ( lp . mSpan . mViews . size ( ) == <NUM_LIT> ) { return ; } lp . mSpan . popEnd ( ) ; } removeAndRecycleView ( child , recycler ) ; } else { return ; } } } private boolean preferLastSpan ( int layoutDir ) { if ( mOrientation == HORIZONTAL ) { return ( layoutDir == LayoutState . LAYOUT_START ) != mShouldReverseLayout ; } return ( ( layoutDir == LayoutState . LAYOUT_START ) == mShouldReverseLayout ) == isLayoutRTL ( ) ; } private Span getNextSpan ( LayoutState layoutState ) { final boolean preferLastSpan = preferLastSpan ( layoutState . mLayoutDirection ) ; final int startIndex , endIndex , diff ; if ( preferLastSpan ) { startIndex = mSpanCount - <NUM_LIT> ; endIndex = - <NUM_LIT> ; diff = - <NUM_LIT> ; } else { startIndex = <NUM_LIT> ; endIndex = mSpanCount ; diff = <NUM_LIT> ; } if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_END ) { Span min = null ; int minLine = Integer . MAX_VALUE ; final int defaultLine = mPrimaryOrientation . getStartAfterPadding ( ) ; for ( int i = startIndex ; i != endIndex ; i += diff ) { final Span other = mSpans [ i ] ; int otherLine = other . getEndLine ( defaultLine ) ; if ( otherLine < minLine ) { min = other ; minLine = otherLine ; } } return min ; } else { Span max = null ; int maxLine = Integer . MIN_VALUE ; final int defaultLine = mPrimaryOrientation . getEndAfterPadding ( ) ; for ( int i = startIndex ; i != endIndex ; i += diff ) { final Span other = mSpans [ i ] ; int otherLine = other . getStartLine ( defaultLine ) ; if ( otherLine > maxLine ) { max = other ; maxLine = otherLine ; } } return max ; } } @ Override public boolean canScrollVertically ( ) { return mOrientation == VERTICAL ; } @ Override public boolean canScrollHorizontally ( ) { return mOrientation == HORIZONTAL ; } @ Override public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { return scrollBy ( dx , recycler , state ) ; } @ Override public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { return scrollBy ( dy , recycler , state ) ; } private int calculateScrollDirectionForPosition ( int position ) { if ( getChildCount ( ) == <NUM_LIT> ) { return mShouldReverseLayout ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; } final int firstChildPos = getFirstChildPosition ( ) ; return position < firstChildPos != mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; } @ Override public PointF computeScrollVectorForPosition ( int targetPosition ) { final int direction = calculateScrollDirectionForPosition ( targetPosition ) ; PointF outVector = new PointF ( ) ; if ( direction == <NUM_LIT> ) { return null ; } if ( mOrientation == HORIZONTAL ) { outVector . x = direction ; outVector . y = <NUM_LIT> ; } else { outVector . x = <NUM_LIT> ; outVector . y = direction ; } return outVector ; } @ Override public void smoothScrollToPosition ( RecyclerView recyclerView , RecyclerView . State state , int position ) { LinearSmoothScroller scroller = new LinearSmoothScroller ( recyclerView . getContext ( ) ) ; scroller . setTargetPosition ( position ) ; startSmoothScroll ( scroller ) ; } @ Override public void scrollToPosition ( int position ) { if ( mPendingSavedState != null && mPendingSavedState . mAnchorPosition != position ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; } mPendingScrollPosition = position ; mPendingScrollPositionOffset = INVALID_OFFSET ; requestLayout ( ) ; } public void scrollToPositionWithOffset ( int position , int offset ) { if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchorPositionInfo ( ) ; } mPendingScrollPosition = position ; mPendingScrollPositionOffset = offset ; requestLayout ( ) ; } @ Override @ RestrictTo ( LIBRARY ) public void collectAdjacentPrefetchPositions ( int dx , int dy , RecyclerView . State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int delta = ( mOrientation == HORIZONTAL ) ? dx : dy ; if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return ; } prepareLayoutStateForDelta ( delta , state ) ; if ( mPrefetchDistances == null || mPrefetchDistances . length < mSpanCount ) { mPrefetchDistances = new int [ mSpanCount ] ; } int itemPrefetchCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { int distance = mLayoutState . mItemDirection == LayoutState . LAYOUT_START ? mLayoutState . mStartLine - mSpans [ i ] . getStartLine ( mLayoutState . mStartLine ) : mSpans [ i ] . getEndLine ( mLayoutState . mEndLine ) - mLayoutState . mEndLine ; if ( distance >= <NUM_LIT> ) { mPrefetchDistances [ itemPrefetchCount ] = distance ; itemPrefetchCount ++ ; } } Arrays . sort ( mPrefetchDistances , <NUM_LIT> , itemPrefetchCount ) ; for ( int i = <NUM_LIT> ; i < itemPrefetchCount && mLayoutState . hasMore ( state ) ; i ++ ) { layoutPrefetchRegistry . addPosition ( mLayoutState . mCurrentPosition , mPrefetchDistances [ i ] ) ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; } } void prepareLayoutStateForDelta ( int delta , RecyclerView . State state ) { final int referenceChildPosition ; final int layoutDir ; if ( delta > <NUM_LIT> ) { layoutDir = LayoutState . LAYOUT_END ; referenceChildPosition = getLastChildPosition ( ) ; } else { layoutDir = LayoutState . LAYOUT_START ; referenceChildPosition = getFirstChildPosition ( ) ; } mLayoutState . mRecycle = true ; updateLayoutState ( referenceChildPosition , state ) ; setLayoutStateDirection ( layoutDir ) ; mLayoutState . mCurrentPosition = referenceChildPosition + mLayoutState . mItemDirection ; mLayoutState . mAvailable = Math . abs ( delta ) ; } int scrollBy ( int dt , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || dt == <NUM_LIT> ) { return <NUM_LIT> ; } prepareLayoutStateForDelta ( dt , state ) ; int consumed = fill ( recycler , mLayoutState , state ) ; final int available = mLayoutState . mAvailable ; final int totalScroll ; if ( available < consumed ) { totalScroll = dt ; } else if ( dt < <NUM_LIT> ) { totalScroll = - consumed ; } else { totalScroll = consumed ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + dt + "<STR_LIT>" + totalScroll ) ; } mPrimaryOrientation . offsetChildren ( - totalScroll ) ; mLastLayoutFromEnd = mShouldReverseLayout ; mLayoutState . mAvailable = <NUM_LIT> ; recycle ( recycler , mLayoutState ) ; return totalScroll ; } int getLastChildPosition ( ) { final int childCount = getChildCount ( ) ; return childCount == <NUM_LIT> ? <NUM_LIT> : getPosition ( getChildAt ( childCount - <NUM_LIT> ) ) ; } int getFirstChildPosition ( ) { final int childCount = getChildCount ( ) ; return childCount == <NUM_LIT> ? <NUM_LIT> : getPosition ( getChildAt ( <NUM_LIT> ) ) ; } private int findFirstReferenceChildPosition ( int itemCount ) { final int limit = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { return position ; } } return <NUM_LIT> ; } private int findLastReferenceChildPosition ( int itemCount ) { for ( int i = getChildCount ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { return position ; } } return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { if ( mOrientation == HORIZONTAL ) { return new LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; } else { return new LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } } @ Override public RecyclerView . LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ Override public RecyclerView . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof ViewGroup . MarginLayoutParams ) { return new LayoutParams ( ( ViewGroup . MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ Override public boolean checkLayoutParams ( RecyclerView . LayoutParams lp ) { return lp instanceof LayoutParams ; } public int getOrientation ( ) { return mOrientation ; } @ Nullable @ Override public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final View directChild = findContainingItemView ( focused ) ; if ( directChild == null ) { return null ; } resolveShouldLayoutReverse ( ) ; final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; if ( layoutDir == LayoutState . INVALID_LAYOUT ) { return null ; } LayoutParams prevFocusLayoutParams = ( LayoutParams ) directChild . getLayoutParams ( ) ; boolean prevFocusFullSpan = prevFocusLayoutParams . mFullSpan ; final Span prevFocusSpan = prevFocusLayoutParams . mSpan ; final int referenceChildPosition ; if ( layoutDir == LayoutState . LAYOUT_END ) { referenceChildPosition = getLastChildPosition ( ) ; } else { referenceChildPosition = getFirstChildPosition ( ) ; } updateLayoutState ( referenceChildPosition , state ) ; setLayoutStateDirection ( layoutDir ) ; mLayoutState . mCurrentPosition = referenceChildPosition + mLayoutState . mItemDirection ; mLayoutState . mAvailable = ( int ) ( MAX_SCROLL_FACTOR * mPrimaryOrientation . getTotalSpace ( ) ) ; mLayoutState . mStopInFocusable = true ; mLayoutState . mRecycle = false ; fill ( recycler , mLayoutState , state ) ; mLastLayoutFromEnd = mShouldReverseLayout ; if ( ! prevFocusFullSpan ) { View view = prevFocusSpan . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } if ( preferLastSpan ( layoutDir ) ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View view = mSpans [ i ] . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { View view = mSpans [ i ] . getFocusableViewAfter ( referenceChildPosition , layoutDir ) ; if ( view != null && view != directChild ) { return view ; } } } boolean shouldSearchFromStart = ! mReverseLayout == ( layoutDir == LayoutState . LAYOUT_START ) ; View unfocusableCandidate = null ; if ( ! prevFocusFullSpan ) { unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? prevFocusSpan . findFirstPartiallyVisibleItemPosition ( ) : prevFocusSpan . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } if ( preferLastSpan ( layoutDir ) ) { for ( int i = mSpanCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( i == prevFocusSpan . mIndex ) { continue ; } unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? mSpans [ i ] . findFirstPartiallyVisibleItemPosition ( ) : mSpans [ i ] . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } } else { for ( int i = <NUM_LIT> ; i < mSpanCount ; i ++ ) { unfocusableCandidate = findViewByPosition ( shouldSearchFromStart ? mSpans [ i ] . findFirstPartiallyVisibleItemPosition ( ) : mSpans [ i ] . findLastPartiallyVisibleItemPosition ( ) ) ; if ( unfocusableCandidate != null && unfocusableCandidate != directChild ) { return unfocusableCandidate ; } } } return null ; } private int convertFocusDirectionToLayoutDirection ( int focusDirection ) { switch ( focusDirection ) { case View . FOCUS_BACKWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_START ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_END ; } else { return LayoutState . LAYOUT_START ; } case View . FOCUS_FORWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_END ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_START ; } else { return LayoutState . LAYOUT_END ; } case View . FOCUS_UP : return mOrientation == VERTICAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_DOWN : return mOrientation == VERTICAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; case View . FOCUS_LEFT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_RIGHT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; default : if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + focusDirection ) ; } return LayoutState . INVALID_LAYOUT ; } } public static class LayoutParams extends RecyclerView . LayoutParams { public static final int INVALID_SPAN_ID = - <NUM_LIT> ; Span mSpan ; boolean mFullSpan ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( ViewGroup . MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( RecyclerView . LayoutParams source ) { super ( source ) ; } public void setFullSpan ( boolean fullSpan ) { mFullSpan = fullSpan ; } public boolean isFullSpan ( ) { return mFullSpan ; } public final int getSpanIndex ( ) { if ( mSpan == null ) { return INVALID_SPAN_ID ; } return mSpan . mIndex ; } } class Span { static final int INVALID_LINE = Integer . MIN_VALUE ; ArrayList < View > mViews = new ArrayList < > ( ) ; int mCachedStart = INVALID_LINE ; int mCachedEnd = INVALID_LINE ; int mDeletedSize = <NUM_LIT> ; final int mIndex ; Span ( int index ) { mIndex = index ; } int getStartLine ( int def ) { if ( mCachedStart != INVALID_LINE ) { return mCachedStart ; } if ( mViews . size ( ) == <NUM_LIT> ) { return def ; } calculateCachedStart ( ) ; return mCachedStart ; } void calculateCachedStart ( ) { final View startView = mViews . get ( <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( startView ) ; mCachedStart = mPrimaryOrientation . getDecoratedStart ( startView ) ; if ( lp . mFullSpan ) { LazySpanLookup . FullSpanItem fsi = mLazySpanLookup . getFullSpanItem ( lp . getViewLayoutPosition ( ) ) ; if ( fsi != null && fsi . mGapDir == LayoutState . LAYOUT_START ) { mCachedStart -= fsi . getGapForSpan ( mIndex ) ; } } } int getStartLine ( ) { if ( mCachedStart != INVALID_LINE ) { return mCachedStart ; } calculateCachedStart ( ) ; return mCachedStart ; } int getEndLine ( int def ) { if ( mCachedEnd != INVALID_LINE ) { return mCachedEnd ; } final int size = mViews . size ( ) ; if ( size == <NUM_LIT> ) { return def ; } calculateCachedEnd ( ) ; return mCachedEnd ; } void calculateCachedEnd ( ) { final View endView = mViews . get ( mViews . size ( ) - <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( endView ) ; mCachedEnd = mPrimaryOrientation . getDecoratedEnd ( endView ) ; if ( lp . mFullSpan ) { LazySpanLookup . FullSpanItem fsi = mLazySpanLookup . getFullSpanItem ( lp . getViewLayoutPosition ( ) ) ; if ( fsi != null && fsi . mGapDir == LayoutState . LAYOUT_END ) { mCachedEnd += fsi . getGapForSpan ( mIndex ) ; } } } int getEndLine ( ) { if ( mCachedEnd != INVALID_LINE ) { return mCachedEnd ; } calculateCachedEnd ( ) ; return mCachedEnd ; } void prependToSpan ( View view ) { LayoutParams lp = getLayoutParams ( view ) ; lp . mSpan = this ; mViews . add ( <NUM_LIT> , view ) ; mCachedStart = INVALID_LINE ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedEnd = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize += mPrimaryOrientation . getDecoratedMeasurement ( view ) ; } } void appendToSpan ( View view ) { LayoutParams lp = getLayoutParams ( view ) ; lp . mSpan = this ; mViews . add ( view ) ; mCachedEnd = INVALID_LINE ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedStart = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize += mPrimaryOrientation . getDecoratedMeasurement ( view ) ; } } void cacheReferenceLineAndClear ( boolean reverseLayout , int offset ) { int reference ; if ( reverseLayout ) { reference = getEndLine ( INVALID_LINE ) ; } else { reference = getStartLine ( INVALID_LINE ) ; } clear ( ) ; if ( reference == INVALID_LINE ) { return ; } if ( ( reverseLayout && reference < mPrimaryOrientation . getEndAfterPadding ( ) ) || ( ! reverseLayout && reference > mPrimaryOrientation . getStartAfterPadding ( ) ) ) { return ; } if ( offset != INVALID_OFFSET ) { reference += offset ; } mCachedStart = mCachedEnd = reference ; } void clear ( ) { mViews . clear ( ) ; invalidateCache ( ) ; mDeletedSize = <NUM_LIT> ; } void invalidateCache ( ) { mCachedStart = INVALID_LINE ; mCachedEnd = INVALID_LINE ; } void setLine ( int line ) { mCachedEnd = mCachedStart = line ; } void popEnd ( ) { final int size = mViews . size ( ) ; View end = mViews . remove ( size - <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( end ) ; lp . mSpan = null ; if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize -= mPrimaryOrientation . getDecoratedMeasurement ( end ) ; } if ( size == <NUM_LIT> ) { mCachedStart = INVALID_LINE ; } mCachedEnd = INVALID_LINE ; } void popStart ( ) { View start = mViews . remove ( <NUM_LIT> ) ; final LayoutParams lp = getLayoutParams ( start ) ; lp . mSpan = null ; if ( mViews . size ( ) == <NUM_LIT> ) { mCachedEnd = INVALID_LINE ; } if ( lp . isItemRemoved ( ) || lp . isItemChanged ( ) ) { mDeletedSize -= mPrimaryOrientation . getDecoratedMeasurement ( start ) ; } mCachedStart = INVALID_LINE ; } public int getDeletedSize ( ) { return mDeletedSize ; } LayoutParams getLayoutParams ( View view ) { return ( LayoutParams ) view . getLayoutParams ( ) ; } void onOffset ( int dt ) { if ( mCachedStart != INVALID_LINE ) { mCachedStart += dt ; } if ( mCachedEnd != INVALID_LINE ) { mCachedEnd += dt ; } } public int findFirstVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , false ) : findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , false ) ; } public int findFirstPartiallyVisibleItemPosition ( ) { return mReverseLayout ? findOnePartiallyVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) : findOnePartiallyVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) ; } public int findFirstCompletelyVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) : findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) ; } public int findLastVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , false ) : findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , false ) ; } public int findLastPartiallyVisibleItemPosition ( ) { return mReverseLayout ? findOnePartiallyVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) : findOnePartiallyVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) ; } public int findLastCompletelyVisibleItemPosition ( ) { return mReverseLayout ? findOneVisibleChild ( <NUM_LIT> , mViews . size ( ) , true ) : findOneVisibleChild ( mViews . size ( ) - <NUM_LIT> , - <NUM_LIT> , true ) ; } int findOnePartiallyOrCompletelyVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible , boolean acceptCompletelyVisible , boolean acceptEndPointInclusion ) { final int start = mPrimaryOrientation . getStartAfterPadding ( ) ; final int end = mPrimaryOrientation . getEndAfterPadding ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : - <NUM_LIT> ; for ( int i = fromIndex ; i != toIndex ; i += next ) { final View child = mViews . get ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; boolean childStartInclusion = acceptEndPointInclusion ? ( childStart <= end ) : ( childStart < end ) ; boolean childEndInclusion = acceptEndPointInclusion ? ( childEnd >= start ) : ( childEnd > start ) ; if ( childStartInclusion && childEndInclusion ) { if ( completelyVisible && acceptCompletelyVisible ) { if ( childStart >= start && childEnd <= end ) { return getPosition ( child ) ; } } else if ( acceptCompletelyVisible ) { return getPosition ( child ) ; } else if ( childStart < start || childEnd > end ) { return getPosition ( child ) ; } } } return RecyclerView . NO_POSITION ; } int findOneVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible ) { return findOnePartiallyOrCompletelyVisibleChild ( fromIndex , toIndex , completelyVisible , true , false ) ; } int findOnePartiallyVisibleChild ( int fromIndex , int toIndex , boolean acceptEndPointInclusion ) { return findOnePartiallyOrCompletelyVisibleChild ( fromIndex , toIndex , false , false , acceptEndPointInclusion ) ; } public View getFocusableViewAfter ( int referenceChildPosition , int layoutDir ) { View candidate = null ; if ( layoutDir == LayoutState . LAYOUT_START ) { final int limit = mViews . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { final View view = mViews . get ( i ) ; if ( ( mReverseLayout && getPosition ( view ) <= referenceChildPosition ) || ( ! mReverseLayout && getPosition ( view ) >= referenceChildPosition ) ) { break ; } if ( view . hasFocusable ( ) ) { candidate = view ; } else { break ; } } } else { for ( int i = mViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final View view = mViews . get ( i ) ; if ( ( mReverseLayout && getPosition ( view ) >= referenceChildPosition ) || ( ! mReverseLayout && getPosition ( view ) <= referenceChildPosition ) ) { break ; } if ( view . hasFocusable ( ) ) { candidate = view ; } else { break ; } } } return candidate ; } } static class LazySpanLookup { private static final int MIN_SIZE = <NUM_LIT> ; int [ ] mData ; List < FullSpanItem > mFullSpanItems ; int forceInvalidateAfter ( int position ) { if ( mFullSpanItems != null ) { for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= position ) { mFullSpanItems . remove ( i ) ; } } } return invalidateAfter ( position ) ; } int invalidateAfter ( int position ) { if ( mData == null ) { return RecyclerView . NO_POSITION ; } if ( position >= mData . length ) { return RecyclerView . NO_POSITION ; } int endPosition = invalidateFullSpansAfter ( position ) ; if ( endPosition == RecyclerView . NO_POSITION ) { Arrays . fill ( mData , position , mData . length , LayoutParams . INVALID_SPAN_ID ) ; return mData . length ; } else { final int invalidateToIndex = Math . min ( endPosition + <NUM_LIT> , mData . length ) ; Arrays . fill ( mData , position , invalidateToIndex , LayoutParams . INVALID_SPAN_ID ) ; return invalidateToIndex ; } } int getSpan ( int position ) { if ( mData == null || position >= mData . length ) { return LayoutParams . INVALID_SPAN_ID ; } else { return mData [ position ] ; } } void setSpan ( int position , Span span ) { ensureSize ( position ) ; mData [ position ] = span . mIndex ; } int sizeForPosition ( int position ) { int len = mData . length ; while ( len <= position ) { len *= <NUM_LIT> ; } return len ; } void ensureSize ( int position ) { if ( mData == null ) { mData = new int [ Math . max ( position , MIN_SIZE ) + <NUM_LIT> ] ; Arrays . fill ( mData , LayoutParams . INVALID_SPAN_ID ) ; } else if ( position >= mData . length ) { int [ ] old = mData ; mData = new int [ sizeForPosition ( position ) ] ; System . arraycopy ( old , <NUM_LIT> , mData , <NUM_LIT> , old . length ) ; Arrays . fill ( mData , old . length , mData . length , LayoutParams . INVALID_SPAN_ID ) ; } } void clear ( ) { if ( mData != null ) { Arrays . fill ( mData , LayoutParams . INVALID_SPAN_ID ) ; } mFullSpanItems = null ; } void offsetForRemoval ( int positionStart , int itemCount ) { if ( mData == null || positionStart >= mData . length ) { return ; } ensureSize ( positionStart + itemCount ) ; System . arraycopy ( mData , positionStart + itemCount , mData , positionStart , mData . length - positionStart - itemCount ) ; Arrays . fill ( mData , mData . length - itemCount , mData . length , LayoutParams . INVALID_SPAN_ID ) ; offsetFullSpansForRemoval ( positionStart , itemCount ) ; } private void offsetFullSpansForRemoval ( int positionStart , int itemCount ) { if ( mFullSpanItems == null ) { return ; } final int end = positionStart + itemCount ; for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition < positionStart ) { continue ; } if ( fsi . mPosition < end ) { mFullSpanItems . remove ( i ) ; } else { fsi . mPosition -= itemCount ; } } } void offsetForAddition ( int positionStart , int itemCount ) { if ( mData == null || positionStart >= mData . length ) { return ; } ensureSize ( positionStart + itemCount ) ; System . arraycopy ( mData , positionStart , mData , positionStart + itemCount , mData . length - positionStart - itemCount ) ; Arrays . fill ( mData , positionStart , positionStart + itemCount , LayoutParams . INVALID_SPAN_ID ) ; offsetFullSpansForAddition ( positionStart , itemCount ) ; } private void offsetFullSpansForAddition ( int positionStart , int itemCount ) { if ( mFullSpanItems == null ) { return ; } for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition < positionStart ) { continue ; } fsi . mPosition += itemCount ; } } private int invalidateFullSpansAfter ( int position ) { if ( mFullSpanItems == null ) { return RecyclerView . NO_POSITION ; } final FullSpanItem item = getFullSpanItem ( position ) ; if ( item != null ) { mFullSpanItems . remove ( item ) ; } int nextFsiIndex = - <NUM_LIT> ; final int count = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= position ) { nextFsiIndex = i ; break ; } } if ( nextFsiIndex != - <NUM_LIT> ) { FullSpanItem fsi = mFullSpanItems . get ( nextFsiIndex ) ; mFullSpanItems . remove ( nextFsiIndex ) ; return fsi . mPosition ; } return RecyclerView . NO_POSITION ; } public void addFullSpanItem ( FullSpanItem fullSpanItem ) { if ( mFullSpanItems == null ) { mFullSpanItems = new ArrayList < > ( ) ; } final int size = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { FullSpanItem other = mFullSpanItems . get ( i ) ; if ( other . mPosition == fullSpanItem . mPosition ) { if ( DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } else { mFullSpanItems . remove ( i ) ; } } if ( other . mPosition >= fullSpanItem . mPosition ) { mFullSpanItems . add ( i , fullSpanItem ) ; return ; } } mFullSpanItems . add ( fullSpanItem ) ; } public FullSpanItem getFullSpanItem ( int position ) { if ( mFullSpanItems == null ) { return null ; } for ( int i = mFullSpanItems . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition == position ) { return fsi ; } } return null ; } public FullSpanItem getFirstFullSpanItemInRange ( int minPos , int maxPos , int gapDir , boolean hasUnwantedGapAfter ) { if ( mFullSpanItems == null ) { return null ; } final int limit = mFullSpanItems . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { FullSpanItem fsi = mFullSpanItems . get ( i ) ; if ( fsi . mPosition >= maxPos ) { return null ; } if ( fsi . mPosition >= minPos && ( gapDir == <NUM_LIT> || fsi . mGapDir == gapDir || ( hasUnwantedGapAfter && fsi . mHasUnwantedGapAfter ) ) ) { return fsi ; } } return null ; } @ SuppressLint ( "<STR_LIT>" ) static class FullSpanItem implements Parcelable { int mPosition ; int mGapDir ; int [ ] mGapPerSpan ; boolean mHasUnwantedGapAfter ; FullSpanItem ( Parcel in ) { mPosition = in . readInt ( ) ; mGapDir = in . readInt ( ) ; mHasUnwantedGapAfter = in . readInt ( ) == <NUM_LIT> ; int spanCount = in . readInt ( ) ; if ( spanCount > <NUM_LIT> ) { mGapPerSpan = new int [ spanCount ] ; in . readIntArray ( mGapPerSpan ) ; } } FullSpanItem ( ) { } int getGapForSpan ( int spanIndex ) { return mGapPerSpan == null ? <NUM_LIT> : mGapPerSpan [ spanIndex ] ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mPosition ) ; dest . writeInt ( mGapDir ) ; dest . writeInt ( mHasUnwantedGapAfter ? <NUM_LIT> : <NUM_LIT> ) ; if ( mGapPerSpan != null && mGapPerSpan . length > <NUM_LIT> ) { dest . writeInt ( mGapPerSpan . length ) ; dest . writeIntArray ( mGapPerSpan ) ; } else { dest . writeInt ( <NUM_LIT> ) ; } } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mPosition + "<STR_LIT>" + mGapDir + "<STR_LIT>" + mHasUnwantedGapAfter + "<STR_LIT>" + Arrays . toString ( mGapPerSpan ) + '<STR_LIT>' ; } public static final Parcelable . Creator < FullSpanItem > CREATOR = new Parcelable . Creator < FullSpanItem > ( ) { @ Override public FullSpanItem createFromParcel ( Parcel in ) { return new FullSpanItem ( in ) ; } @ Override public FullSpanItem [ ] newArray ( int size ) { return new FullSpanItem [ size ] ; } } ; } } @ RestrictTo ( LIBRARY ) @ SuppressLint ( "<STR_LIT>" ) public static class SavedState implements Parcelable { int mAnchorPosition ; int mVisibleAnchorPosition ; int mSpanOffsetsSize ; int [ ] mSpanOffsets ; int mSpanLookupSize ; int [ ] mSpanLookup ; List < LazySpanLookup . FullSpanItem > mFullSpanItems ; boolean mReverseLayout ; boolean mAnchorLayoutFromEnd ; boolean mLastLayoutRTL ; public SavedState ( ) { } SavedState ( Parcel in ) { mAnchorPosition = in . readInt ( ) ; mVisibleAnchorPosition = in . readInt ( ) ; mSpanOffsetsSize = in . readInt ( ) ; if ( mSpanOffsetsSize > <NUM_LIT> ) { mSpanOffsets = new int [ mSpanOffsetsSize ] ; in . readIntArray ( mSpanOffsets ) ; } mSpanLookupSize = in . readInt ( ) ; if ( mSpanLookupSize > <NUM_LIT> ) { mSpanLookup = new int [ mSpanLookupSize ] ; in . readIntArray ( mSpanLookup ) ; } mReverseLayout = in . readInt ( ) == <NUM_LIT> ; mAnchorLayoutFromEnd = in . readInt ( ) == <NUM_LIT> ; mLastLayoutRTL = in . readInt ( ) == <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) List < LazySpanLookup . FullSpanItem > fullSpanItems = in . readArrayList ( LazySpanLookup . FullSpanItem . class . getClassLoader ( ) ) ; mFullSpanItems = fullSpanItems ; } public SavedState ( SavedState other ) { mSpanOffsetsSize = other . mSpanOffsetsSize ; mAnchorPosition = other . mAnchorPosition ; mVisibleAnchorPosition = other . mVisibleAnchorPosition ; mSpanOffsets = other . mSpanOffsets ; mSpanLookupSize = other . mSpanLookupSize ; mSpanLookup = other . mSpanLookup ; mReverseLayout = other . mReverseLayout ; mAnchorLayoutFromEnd = other . mAnchorLayoutFromEnd ; mLastLayoutRTL = other . mLastLayoutRTL ; mFullSpanItems = other . mFullSpanItems ; } void invalidateSpanInfo ( ) { mSpanOffsets = null ; mSpanOffsetsSize = <NUM_LIT> ; mSpanLookupSize = <NUM_LIT> ; mSpanLookup = null ; mFullSpanItems = null ; } void invalidateAnchorPositionInfo ( ) { mSpanOffsets = null ; mSpanOffsetsSize = <NUM_LIT> ; mAnchorPosition = RecyclerView . NO_POSITION ; mVisibleAnchorPosition = RecyclerView . NO_POSITION ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mAnchorPosition ) ; dest . writeInt ( mVisibleAnchorPosition ) ; dest . writeInt ( mSpanOffsetsSize ) ; if ( mSpanOffsetsSize > <NUM_LIT> ) { dest . writeIntArray ( mSpanOffsets ) ; } dest . writeInt ( mSpanLookupSize ) ; if ( mSpanLookupSize > <NUM_LIT> ) { dest . writeIntArray ( mSpanLookup ) ; } dest . writeInt ( mReverseLayout ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeInt ( mAnchorLayoutFromEnd ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeInt ( mLastLayoutRTL ? <NUM_LIT> : <NUM_LIT> ) ; dest . writeList ( mFullSpanItems ) ; } public static final Parcelable . Creator < SavedState > CREATOR = new Parcelable . Creator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } class AnchorInfo { int mPosition ; int mOffset ; boolean mLayoutFromEnd ; boolean mInvalidateOffsets ; boolean mValid ; int [ ] mSpanReferenceLines ; AnchorInfo ( ) { reset ( ) ; } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = INVALID_OFFSET ; mLayoutFromEnd = false ; mInvalidateOffsets = false ; mValid = false ; if ( mSpanReferenceLines != null ) { Arrays . fill ( mSpanReferenceLines , - <NUM_LIT> ) ; } } void saveSpanReferenceLines ( Span [ ] spans ) { int spanCount = spans . length ; if ( mSpanReferenceLines == null || mSpanReferenceLines . length < spanCount ) { mSpanReferenceLines = new int [ mSpans . length ] ; } for ( int i = <NUM_LIT> ; i < spanCount ; i ++ ) { mSpanReferenceLines [ i ] = spans [ i ] . getStartLine ( Span . INVALID_LINE ) ; } } void assignCoordinateFromPadding ( ) { mOffset = mLayoutFromEnd ? mPrimaryOrientation . getEndAfterPadding ( ) : mPrimaryOrientation . getStartAfterPadding ( ) ; } void assignCoordinateFromPadding ( int addedDistance ) { if ( mLayoutFromEnd ) { mOffset = mPrimaryOrientation . getEndAfterPadding ( ) - addedDistance ; } else { mOffset = mPrimaryOrientation . getStartAfterPadding ( ) + addedDistance ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnTouchEvent ( event ) ; } return true ; } } } return superOnTouchEvent ( event ) ; } @ Override public int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } @ Override public int getScrollOffset ( ) { return computeVerticalScrollOffset ( ) ; } @ Override public void scrollTo ( int offset ) { scrollTo ( getScrollX ( ) , offset ) ; } protected abstract void superDraw ( @ NonNull Canvas canvas ) ; protected abstract void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) ; protected abstract boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract boolean superOnTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract int computeVerticalScrollRange ( ) ; protected abstract int computeVerticalScrollOffset ( ) ; protected abstract int getScrollX ( ) ; protected abstract void scrollTo ( int x , int y ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( "<STR_LIT>" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( "<STR_LIT>" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) { return mDiffer . getCurrentList ( ) . size ( ) ; } @ NonNull public List < T > getCurrentList ( ) { return mDiffer . getCurrentList ( ) ; } public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , "<STR_LIT>" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + "<STR_LIT>" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( "<STR_LIT>" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , "<STR_LIT>" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( "<STR_LIT>" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , "<STR_LIT>" + position ) ; return ; } if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( "<STR_LIT>" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) { return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( "<STR_LIT>" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( "<STR_LIT>" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( "<STR_LIT>" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( "<STR_LIT>" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( "<STR_LIT>" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( "<STR_LIT>" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; } else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) { removeTile ( lastLoadedTileStart ) ; } else { return ; } } } private void log ( String s , Object ... args ) { Log . d ( TAG , "<STR_LIT>" + String . format ( s , args ) ) ; } } ; public static abstract class DataCallback < T > { @ WorkerThread public abstract int refreshData ( ) ; @ WorkerThread public abstract void fillData ( @ NonNull T [ ] data , int startPosition , int itemCount ) ; @ WorkerThread public void recycleData ( @ NonNull T [ ] data , int itemCount ) { } @ WorkerThread public int getMaxCachedTiles ( ) { return <NUM_LIT> ; } } public static abstract class ViewCallback { public static final int HINT_SCROLL_NONE = <NUM_LIT> ; public static final int HINT_SCROLL_DESC = <NUM_LIT> ; public static final int HINT_SCROLL_ASC = <NUM_LIT> ; @ UiThread public abstract void getItemRangeInto ( @ NonNull int [ ] outRange ) ; @ UiThread public void extendRangeInto ( @ NonNull int [ ] range , @ NonNull int [ ] outRange , int scrollHint ) { final int fullRange = range [ <NUM_LIT> ] - range [ <NUM_LIT> ] + <NUM_LIT> ; final int halfRange = fullRange / <NUM_LIT> ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] - ( scrollHint == HINT_SCROLL_DESC ? fullRange : halfRange ) ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] + ( scrollHint == HINT_SCROLL_ASC ? fullRange : halfRange ) ; } @ UiThread public abstract void onDataRefresh ( ) ; @ UiThread public abstract void onItemLoaded ( int position ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; return ( int ) ( ( float ) laidOutArea / laidOutRange * state . getItemCount ( ) ) ; } private ScrollbarHelper ( ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( "<STR_LIT>" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = "<STR_LIT>" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ; } @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { return mController . getWrappedAdapterAndPosition ( globalPosition ) ; } public static final class Config { public final boolean isolateViewTypes ; @ NonNull public final StableIdMode stableIdMode ; @ NonNull public static final Config DEFAULT = new Config ( true , NO_STABLE_IDS ) ; Config ( boolean isolateViewTypes , @ NonNull StableIdMode stableIdMode ) { this . isolateViewTypes = isolateViewTypes ; this . stableIdMode = stableIdMode ; } public enum StableIdMode { NO_STABLE_IDS , ISOLATED_STABLE_IDS , SHARED_STABLE_IDS } public static final class Builder { private boolean mIsolateViewTypes = DEFAULT . isolateViewTypes ; private StableIdMode mStableIdMode = DEFAULT . stableIdMode ; @ NonNull public Builder setIsolateViewTypes ( boolean isolateViewTypes ) { mIsolateViewTypes = isolateViewTypes ; return this ; } @ NonNull public Builder setStableIdMode ( @ NonNull StableIdMode stableIdMode ) { mStableIdMode = stableIdMode ; return this ; } @ NonNull public Config build ( ) { return new Config ( mIsolateViewTypes , mStableIdMode ) ; } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } } </s>
<s> package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) { pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( "<STR_LIT>" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } } public interface TabConfigurationStrategy { void onConfigureTab ( @ NonNull TabLayout . Tab tab , int position ) ; } private static class TabLayoutOnPageChangeCallback extends ViewPager2 . OnPageChangeCallback { @ NonNull private final WeakReference < TabLayout > tabLayoutRef ; private int previousScrollState ; private int scrollState ; TabLayoutOnPageChangeCallback ( TabLayout tabLayout ) { tabLayoutRef = new WeakReference < > ( tabLayout ) ; reset ( ) ; } @ Override public void onPageScrollStateChanged ( final int state ) { previousScrollState = scrollState ; scrollState = state ; TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { tabLayout . updateViewPagerScrollState ( scrollState ) ; } } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { boolean updateSelectedTabView = scrollState != SCROLL_STATE_SETTLING || previousScrollState == SCROLL_STATE_DRAGGING ; boolean updateIndicator = ! ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . setScrollPosition ( position , positionOffset , updateSelectedTabView , updateIndicator , false ) ; } } @ Override public void onPageSelected ( final int position ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null && tabLayout . getSelectedTabPosition ( ) != position && position < tabLayout . getTabCount ( ) ) { boolean updateIndicator = scrollState == SCROLL_STATE_IDLE || ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . selectTab ( tabLayout . getTabAt ( position ) , updateIndicator ) ; } } void reset ( ) { previousScrollState = scrollState = SCROLL_STATE_IDLE ; } } private static class ViewPagerOnTabSelectedListener implements TabLayout . OnTabSelectedListener { private final ViewPager2 viewPager ; private final boolean smoothScroll ; ViewPagerOnTabSelectedListener ( ViewPager2 viewPager , boolean smoothScroll ) { this . viewPager = viewPager ; this . smoothScroll = smoothScroll ; } @ Override public void onTabSelected ( @ NonNull TabLayout . Tab tab ) { viewPager . setCurrentItem ( tab . getPosition ( ) , smoothScroll ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } private class PagerAdapterObserver extends RecyclerView . AdapterDataObserver { PagerAdapterObserver ( ) { } @ Override public void onChanged ( ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import androidx . annotation . Nullable ; public interface ListUpdateCallback { void onInserted ( int position , int count ) ; void onRemoved ( int position , int count ) ; void onMoved ( int fromPosition , int toPosition ) ; void onChanged ( int position , int count , @ Nullable Object payload ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mAvailable + "<STR_LIT>" + mCurrentPosition + "<STR_LIT>" + mItemDirection + "<STR_LIT>" + mLayoutDirection + "<STR_LIT>" + mStartLine + "<STR_LIT>" + mEndLine + '<STR_LIT>' ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . content . Context ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . util . Log ; import android . util . SparseIntArray ; import android . view . View ; import android . view . ViewGroup ; import android . widget . GridView ; import androidx . annotation . NonNull ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import java . util . Arrays ; public class GridLayoutManager extends LinearLayoutManager { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; public static final int DEFAULT_SPAN_COUNT = - <NUM_LIT> ; boolean mPendingSpanCountChange = false ; int mSpanCount = DEFAULT_SPAN_COUNT ; int [ ] mCachedBorders ; View [ ] mSet ; final SparseIntArray mPreLayoutSpanSizeCache = new SparseIntArray ( ) ; final SparseIntArray mPreLayoutSpanIndexCache = new SparseIntArray ( ) ; SpanSizeLookup mSpanSizeLookup = new DefaultSpanSizeLookup ( ) ; final Rect mDecorInsets = new Rect ( ) ; private boolean mUsingSpansToEstimateScrollBarDimensions ; public GridLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setSpanCount ( properties . spanCount ) ; } public GridLayoutManager ( Context context , int spanCount ) { super ( context ) ; setSpanCount ( spanCount ) ; } public GridLayoutManager ( Context context , int spanCount , @ RecyclerView . Orientation int orientation , boolean reverseLayout ) { super ( context , orientation , reverseLayout ) ; setSpanCount ( spanCount ) ; } @ Override public void setStackFromEnd ( boolean stackFromEnd ) { if ( stackFromEnd ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } super . setStackFromEnd ( false ) ; } @ Override public int getRowCountForAccessibility ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == HORIZONTAL ) { return mSpanCount ; } if ( state . getItemCount ( ) < <NUM_LIT> ) { return <NUM_LIT> ; } return getSpanGroupIndex ( recycler , state , state . getItemCount ( ) - <NUM_LIT> ) + <NUM_LIT> ; } @ Override public int getColumnCountForAccessibility ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == VERTICAL ) { return mSpanCount ; } if ( state . getItemCount ( ) < <NUM_LIT> ) { return <NUM_LIT> ; } return getSpanGroupIndex ( recycler , state , state . getItemCount ( ) - <NUM_LIT> ) + <NUM_LIT> ; } @ Override public void onInitializeAccessibilityNodeInfoForItem ( RecyclerView . Recycler recycler , RecyclerView . State state , View host , AccessibilityNodeInfoCompat info ) { ViewGroup . LayoutParams lp = host . getLayoutParams ( ) ; if ( ! ( lp instanceof LayoutParams ) ) { super . onInitializeAccessibilityNodeInfoForItem ( host , info ) ; return ; } LayoutParams glp = ( LayoutParams ) lp ; int spanGroupIndex = getSpanGroupIndex ( recycler , state , glp . getViewLayoutPosition ( ) ) ; if ( mOrientation == HORIZONTAL ) { info . setCollectionItemInfo ( AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( glp . getSpanIndex ( ) , glp . getSpanSize ( ) , spanGroupIndex , <NUM_LIT> , false , false ) ) ; } else { info . setCollectionItemInfo ( AccessibilityNodeInfoCompat . CollectionItemInfoCompat . obtain ( spanGroupIndex , <NUM_LIT> , glp . getSpanIndex ( ) , glp . getSpanSize ( ) , false , false ) ) ; } } @ Override public void onInitializeAccessibilityNodeInfo ( @ NonNull RecyclerView . Recycler recycler , @ NonNull RecyclerView . State state , @ NonNull AccessibilityNodeInfoCompat info ) { super . onInitializeAccessibilityNodeInfo ( recycler , state , info ) ; info . setClassName ( GridView . class . getName ( ) ) ; } @ Override public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( state . isPreLayout ( ) ) { cachePreLayoutSpanMapping ( ) ; } super . onLayoutChildren ( recycler , state ) ; if ( DEBUG ) { validateChildOrder ( ) ; } clearPreLayoutSpanMappingCache ( ) ; } @ Override public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingSpanCountChange = false ; } private void clearPreLayoutSpanMappingCache ( ) { mPreLayoutSpanSizeCache . clear ( ) ; mPreLayoutSpanIndexCache . clear ( ) ; } private void cachePreLayoutSpanMapping ( ) { final int childCount = getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final LayoutParams lp = ( LayoutParams ) getChildAt ( i ) . getLayoutParams ( ) ; final int viewPosition = lp . getViewLayoutPosition ( ) ; mPreLayoutSpanSizeCache . put ( viewPosition , lp . getSpanSize ( ) ) ; mPreLayoutSpanIndexCache . put ( viewPosition , lp . getSpanIndex ( ) ) ; } } @ Override public void onItemsAdded ( RecyclerView recyclerView , int positionStart , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsChanged ( RecyclerView recyclerView ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsRemoved ( RecyclerView recyclerView , int positionStart , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsUpdated ( RecyclerView recyclerView , int positionStart , int itemCount , Object payload ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public void onItemsMoved ( RecyclerView recyclerView , int from , int to , int itemCount ) { mSpanSizeLookup . invalidateSpanIndexCache ( ) ; mSpanSizeLookup . invalidateSpanGroupIndexCache ( ) ; } @ Override public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { if ( mOrientation == HORIZONTAL ) { return new LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; } else { return new LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } } @ Override public RecyclerView . LayoutParams generateLayoutParams ( Context c , AttributeSet attrs ) { return new LayoutParams ( c , attrs ) ; } @ Override public RecyclerView . LayoutParams generateLayoutParams ( ViewGroup . LayoutParams lp ) { if ( lp instanceof ViewGroup . MarginLayoutParams ) { return new LayoutParams ( ( ViewGroup . MarginLayoutParams ) lp ) ; } else { return new LayoutParams ( lp ) ; } } @ Override public boolean checkLayoutParams ( RecyclerView . LayoutParams lp ) { return lp instanceof LayoutParams ; } public void setSpanSizeLookup ( SpanSizeLookup spanSizeLookup ) { mSpanSizeLookup = spanSizeLookup ; } public SpanSizeLookup getSpanSizeLookup ( ) { return mSpanSizeLookup ; } private void updateMeasurements ( ) { int totalSpace ; if ( getOrientation ( ) == VERTICAL ) { totalSpace = getWidth ( ) - getPaddingRight ( ) - getPaddingLeft ( ) ; } else { totalSpace = getHeight ( ) - getPaddingBottom ( ) - getPaddingTop ( ) ; } calculateItemBorders ( totalSpace ) ; } @ Override public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { if ( mCachedBorders == null ) { super . setMeasuredDimension ( childrenBounds , wSpec , hSpec ) ; } final int width , height ; final int horizontalPadding = getPaddingLeft ( ) + getPaddingRight ( ) ; final int verticalPadding = getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mOrientation == VERTICAL ) { final int usedHeight = childrenBounds . height ( ) + verticalPadding ; height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; width = chooseSize ( wSpec , mCachedBorders [ mCachedBorders . length - <NUM_LIT> ] + horizontalPadding , getMinimumWidth ( ) ) ; } else { final int usedWidth = childrenBounds . width ( ) + horizontalPadding ; width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; height = chooseSize ( hSpec , mCachedBorders [ mCachedBorders . length - <NUM_LIT> ] + verticalPadding , getMinimumHeight ( ) ) ; } setMeasuredDimension ( width , height ) ; } private void calculateItemBorders ( int totalSpace ) { mCachedBorders = calculateItemBorders ( mCachedBorders , mSpanCount , totalSpace ) ; } static int [ ] calculateItemBorders ( int [ ] cachedBorders , int spanCount , int totalSpace ) { if ( cachedBorders == null || cachedBorders . length != spanCount + <NUM_LIT> || cachedBorders [ cachedBorders . length - <NUM_LIT> ] != totalSpace ) { cachedBorders = new int [ spanCount + <NUM_LIT> ] ; } cachedBorders [ <NUM_LIT> ] = <NUM_LIT> ; int sizePerSpan = totalSpace / spanCount ; int sizePerSpanRemainder = totalSpace % spanCount ; int consumedPixels = <NUM_LIT> ; int additionalSize = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i <= spanCount ; i ++ ) { int itemSize = sizePerSpan ; additionalSize += sizePerSpanRemainder ; if ( additionalSize > <NUM_LIT> && ( spanCount - additionalSize ) < sizePerSpanRemainder ) { itemSize += <NUM_LIT> ; additionalSize -= spanCount ; } consumedPixels += itemSize ; cachedBorders [ i ] = consumedPixels ; } return cachedBorders ; } int getSpaceForSpanRange ( int startSpan , int spanSize ) { if ( mOrientation == VERTICAL && isLayoutRTL ( ) ) { return mCachedBorders [ mSpanCount - startSpan ] - mCachedBorders [ mSpanCount - startSpan - spanSize ] ; } else { return mCachedBorders [ startSpan + spanSize ] - mCachedBorders [ startSpan ] ; } } @ Override void onAnchorReady ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int itemDirection ) { super . onAnchorReady ( recycler , state , anchorInfo , itemDirection ) ; updateMeasurements ( ) ; if ( state . getItemCount ( ) > <NUM_LIT> && ! state . isPreLayout ( ) ) { ensureAnchorIsInCorrectSpan ( recycler , state , anchorInfo , itemDirection ) ; } ensureViewSet ( ) ; } private void ensureViewSet ( ) { if ( mSet == null || mSet . length != mSpanCount ) { mSet = new View [ mSpanCount ] ; } } @ Override public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { updateMeasurements ( ) ; ensureViewSet ( ) ; return super . scrollHorizontallyBy ( dx , recycler , state ) ; } @ Override public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { updateMeasurements ( ) ; ensureViewSet ( ) ; return super . scrollVerticallyBy ( dy , recycler , state ) ; } private void ensureAnchorIsInCorrectSpan ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int itemDirection ) { final boolean layingOutInPrimaryDirection = itemDirection == LayoutState . ITEM_DIRECTION_TAIL ; int span = getSpanIndex ( recycler , state , anchorInfo . mPosition ) ; if ( layingOutInPrimaryDirection ) { while ( span > <NUM_LIT> && anchorInfo . mPosition > <NUM_LIT> ) { anchorInfo . mPosition -- ; span = getSpanIndex ( recycler , state , anchorInfo . mPosition ) ; } } else { final int indexLimit = state . getItemCount ( ) - <NUM_LIT> ; int pos = anchorInfo . mPosition ; int bestSpan = span ; while ( pos < indexLimit ) { int next = getSpanIndex ( recycler , state , pos + <NUM_LIT> ) ; if ( next > bestSpan ) { pos += <NUM_LIT> ; bestSpan = next ; } else { break ; } } anchorInfo . mPosition = pos ; } } @ Override View findReferenceChild ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean layoutFromEnd , boolean traverseChildrenInReverseOrder ) { int start = <NUM_LIT> ; int end = getChildCount ( ) ; int diff = <NUM_LIT> ; if ( traverseChildrenInReverseOrder ) { start = getChildCount ( ) - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } int itemCount = state . getItemCount ( ) ; ensureLayoutState ( ) ; View invalidMatch = null ; View outOfBoundsMatch = null ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; for ( int i = start ; i != end ; i += diff ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { final int span = getSpanIndex ( recycler , state , position ) ; if ( span != <NUM_LIT> ) { continue ; } if ( ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . isItemRemoved ( ) ) { if ( invalidMatch == null ) { invalidMatch = view ; } } else if ( mOrientationHelper . getDecoratedStart ( view ) >= boundsEnd || mOrientationHelper . getDecoratedEnd ( view ) < boundsStart ) { if ( outOfBoundsMatch == null ) { outOfBoundsMatch = view ; } } else { return view ; } } } return outOfBoundsMatch != null ? outOfBoundsMatch : invalidMatch ; } private int getSpanGroupIndex ( RecyclerView . Recycler recycler , RecyclerView . State state , int viewPosition ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getCachedSpanGroupIndex ( viewPosition , mSpanCount ) ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( viewPosition ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + viewPosition ) ; } Log . w ( TAG , "<STR_LIT>" + viewPosition ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getCachedSpanGroupIndex ( adapterPosition , mSpanCount ) ; } private int getSpanIndex ( RecyclerView . Recycler recycler , RecyclerView . State state , int pos ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getCachedSpanIndex ( pos , mSpanCount ) ; } final int cached = mPreLayoutSpanIndexCache . get ( pos , - <NUM_LIT> ) ; if ( cached != - <NUM_LIT> ) { return cached ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( pos ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + pos ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + pos ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getCachedSpanIndex ( adapterPosition , mSpanCount ) ; } private int getSpanSize ( RecyclerView . Recycler recycler , RecyclerView . State state , int pos ) { if ( ! state . isPreLayout ( ) ) { return mSpanSizeLookup . getSpanSize ( pos ) ; } final int cached = mPreLayoutSpanSizeCache . get ( pos , - <NUM_LIT> ) ; if ( cached != - <NUM_LIT> ) { return cached ; } final int adapterPosition = recycler . convertPreLayoutPositionToPostLayout ( pos ) ; if ( adapterPosition == - <NUM_LIT> ) { if ( DEBUG ) { throw new RuntimeException ( "<STR_LIT>" + "<STR_LIT>" + pos ) ; } Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" + pos ) ; return <NUM_LIT> ; } return mSpanSizeLookup . getSpanSize ( adapterPosition ) ; } @ Override void collectPrefetchPositionsForLayoutState ( RecyclerView . State state , LayoutState layoutState , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int remainingSpan = mSpanCount ; int count = <NUM_LIT> ; while ( count < mSpanCount && layoutState . hasMore ( state ) && remainingSpan > <NUM_LIT> ) { final int pos = layoutState . mCurrentPosition ; layoutPrefetchRegistry . addPosition ( pos , Math . max ( <NUM_LIT> , layoutState . mScrollingOffset ) ) ; final int spanSize = mSpanSizeLookup . getSpanSize ( pos ) ; remainingSpan -= spanSize ; layoutState . mCurrentPosition += layoutState . mItemDirection ; count ++ ; } } @ Override void layoutChunk ( RecyclerView . Recycler recycler , RecyclerView . State state , LayoutState layoutState , LayoutChunkResult result ) { final int otherDirSpecMode = mOrientationHelper . getModeInOther ( ) ; final boolean flexibleInOtherDir = otherDirSpecMode != View . MeasureSpec . EXACTLY ; final int currentOtherDirSize = getChildCount ( ) > <NUM_LIT> ? mCachedBorders [ mSpanCount ] : <NUM_LIT> ; if ( flexibleInOtherDir ) { updateMeasurements ( ) ; } final boolean layingOutInPrimaryDirection = layoutState . mItemDirection == LayoutState . ITEM_DIRECTION_TAIL ; int count = <NUM_LIT> ; int remainingSpan = mSpanCount ; if ( ! layingOutInPrimaryDirection ) { int itemSpanIndex = getSpanIndex ( recycler , state , layoutState . mCurrentPosition ) ; int itemSpanSize = getSpanSize ( recycler , state , layoutState . mCurrentPosition ) ; remainingSpan = itemSpanIndex + itemSpanSize ; } while ( count < mSpanCount && layoutState . hasMore ( state ) && remainingSpan > <NUM_LIT> ) { int pos = layoutState . mCurrentPosition ; final int spanSize = getSpanSize ( recycler , state , pos ) ; if ( spanSize > mSpanCount ) { throw new IllegalArgumentException ( "<STR_LIT>" + pos + "<STR_LIT>" + spanSize + "<STR_LIT>" + mSpanCount + "<STR_LIT>" ) ; } remainingSpan -= spanSize ; if ( remainingSpan < <NUM_LIT> ) { break ; } View view = layoutState . next ( recycler ) ; if ( view == null ) { break ; } mSet [ count ] = view ; count ++ ; } if ( count == <NUM_LIT> ) { result . mFinished = true ; return ; } int maxSize = <NUM_LIT> ; float maxSizeInOther = <NUM_LIT> ; assignSpans ( recycler , state , count , layingOutInPrimaryDirection ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; if ( layoutState . mScrapList == null ) { if ( layingOutInPrimaryDirection ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } } else { if ( layingOutInPrimaryDirection ) { addDisappearingView ( view ) ; } else { addDisappearingView ( view , <NUM_LIT> ) ; } } calculateItemDecorationsForChild ( view , mDecorInsets ) ; measureChild ( view , otherDirSpecMode , false ) ; final int size = mOrientationHelper . getDecoratedMeasurement ( view ) ; if ( size > maxSize ) { maxSize = size ; } final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final float otherSize = <NUM_LIT> * mOrientationHelper . getDecoratedMeasurementInOther ( view ) / lp . mSpanSize ; if ( otherSize > maxSizeInOther ) { maxSizeInOther = otherSize ; } } if ( flexibleInOtherDir ) { guessMeasurement ( maxSizeInOther , currentOtherDirSize ) ; maxSize = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; measureChild ( view , View . MeasureSpec . EXACTLY , true ) ; final int size = mOrientationHelper . getDecoratedMeasurement ( view ) ; if ( size > maxSize ) { maxSize = size ; } } } for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mSet [ i ] ; if ( mOrientationHelper . getDecoratedMeasurement ( view ) != maxSize ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect decorInsets = lp . mDecorInsets ; final int verticalInsets = decorInsets . top + decorInsets . bottom + lp . topMargin + lp . bottomMargin ; final int horizontalInsets = decorInsets . left + decorInsets . right + lp . leftMargin + lp . rightMargin ; final int totalSpaceInOther = getSpaceForSpanRange ( lp . mSpanIndex , lp . mSpanSize ) ; final int wSpec ; final int hSpec ; if ( mOrientation == VERTICAL ) { wSpec = getChildMeasureSpec ( totalSpaceInOther , View . MeasureSpec . EXACTLY , horizontalInsets , lp . width , false ) ; hSpec = View . MeasureSpec . makeMeasureSpec ( maxSize - verticalInsets , View . MeasureSpec . EXACTLY ) ; } else { wSpec = View . MeasureSpec . makeMeasureSpec ( maxSize - horizontalInsets , View . MeasureSpec . EXACTLY ) ; hSpec = getChildMeasureSpec ( totalSpaceInOther , View . MeasureSpec . EXACTLY , verticalInsets , lp . height , false ) ; } measureChildWithDecorationsAndMargin ( view , wSpec , hSpec , true ) ; } } result . mConsumed = maxSize ; int left = <NUM_LIT> , right = <NUM_LIT> , top = <NUM_LIT> , bottom = <NUM_LIT> ; if ( mOrientation == VERTICAL ) { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { bottom = layoutState . mOffset ; top = bottom - maxSize ; } else { top = layoutState . mOffset ; bottom = top + maxSize ; } } else { if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { right = layoutState . mOffset ; left = right - maxSize ; } else { left = layoutState . mOffset ; right = left + maxSize ; } } for ( int i = <NUM_LIT> ; i < count ; i ++ ) { View view = mSet [ i ] ; LayoutParams params = ( LayoutParams ) view . getLayoutParams ( ) ; if ( mOrientation == VERTICAL ) { if ( isLayoutRTL ( ) ) { right = getPaddingLeft ( ) + mCachedBorders [ mSpanCount - params . mSpanIndex ] ; left = right - mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } else { left = getPaddingLeft ( ) + mCachedBorders [ params . mSpanIndex ] ; right = left + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } } else { top = getPaddingTop ( ) + mCachedBorders [ params . mSpanIndex ] ; bottom = top + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } layoutDecoratedWithMargins ( view , left , top , right , bottom ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + getPosition ( view ) + "<STR_LIT>" + ( left + params . leftMargin ) + "<STR_LIT>" + ( top + params . topMargin ) + "<STR_LIT>" + ( right - params . rightMargin ) + "<STR_LIT>" + ( bottom - params . bottomMargin ) + "<STR_LIT>" + params . mSpanIndex + "<STR_LIT>" + params . mSpanSize ) ; } if ( params . isItemRemoved ( ) || params . isItemChanged ( ) ) { result . mIgnoreConsumed = true ; } result . mFocusable |= view . hasFocusable ( ) ; } Arrays . fill ( mSet , null ) ; } private void measureChild ( View view , int otherDirParentSpecMode , boolean alreadyMeasured ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect decorInsets = lp . mDecorInsets ; final int verticalInsets = decorInsets . top + decorInsets . bottom + lp . topMargin + lp . bottomMargin ; final int horizontalInsets = decorInsets . left + decorInsets . right + lp . leftMargin + lp . rightMargin ; final int availableSpaceInOther = getSpaceForSpanRange ( lp . mSpanIndex , lp . mSpanSize ) ; final int wSpec ; final int hSpec ; if ( mOrientation == VERTICAL ) { wSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , horizontalInsets , lp . width , false ) ; hSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getHeightMode ( ) , verticalInsets , lp . height , true ) ; } else { hSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , verticalInsets , lp . height , false ) ; wSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getWidthMode ( ) , horizontalInsets , lp . width , true ) ; } measureChildWithDecorationsAndMargin ( view , wSpec , hSpec , alreadyMeasured ) ; } private void guessMeasurement ( float maxSizeInOther , int currentOtherDirSize ) { final int contentSize = Math . round ( maxSizeInOther * mSpanCount ) ; calculateItemBorders ( Math . max ( contentSize , currentOtherDirSize ) ) ; } private void measureChildWithDecorationsAndMargin ( View child , int widthSpec , int heightSpec , boolean alreadyMeasured ) { RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; final boolean measure ; if ( alreadyMeasured ) { measure = shouldReMeasureChild ( child , widthSpec , heightSpec , lp ) ; } else { measure = shouldMeasureChild ( child , widthSpec , heightSpec , lp ) ; } if ( measure ) { child . measure ( widthSpec , heightSpec ) ; } } private void assignSpans ( RecyclerView . Recycler recycler , RecyclerView . State state , int count , boolean layingOutInPrimaryDirection ) { int span , start , end , diff ; if ( layingOutInPrimaryDirection ) { start = <NUM_LIT> ; end = count ; diff = <NUM_LIT> ; } else { start = count - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } span = <NUM_LIT> ; for ( int i = start ; i != end ; i += diff ) { View view = mSet [ i ] ; LayoutParams params = ( LayoutParams ) view . getLayoutParams ( ) ; params . mSpanSize = getSpanSize ( recycler , state , getPosition ( view ) ) ; params . mSpanIndex = span ; span += params . mSpanSize ; } } public int getSpanCount ( ) { return mSpanCount ; } public void setSpanCount ( int spanCount ) { if ( spanCount == mSpanCount ) { return ; } mPendingSpanCountChange = true ; if ( spanCount < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + spanCount ) ; } mSpanCount = spanCount ; mSpanSizeLookup . invalidateSpanIndexCache ( ) ; requestLayout ( ) ; } public abstract static class SpanSizeLookup { final SparseIntArray mSpanIndexCache = new SparseIntArray ( ) ; final SparseIntArray mSpanGroupIndexCache = new SparseIntArray ( ) ; private boolean mCacheSpanIndices = false ; private boolean mCacheSpanGroupIndices = false ; public abstract int getSpanSize ( int position ) ; public void setSpanIndexCacheEnabled ( boolean cacheSpanIndices ) { if ( ! cacheSpanIndices ) { mSpanGroupIndexCache . clear ( ) ; } mCacheSpanIndices = cacheSpanIndices ; } public void setSpanGroupIndexCacheEnabled ( boolean cacheSpanGroupIndices ) { if ( ! cacheSpanGroupIndices ) { mSpanGroupIndexCache . clear ( ) ; } mCacheSpanGroupIndices = cacheSpanGroupIndices ; } public void invalidateSpanIndexCache ( ) { mSpanIndexCache . clear ( ) ; } public void invalidateSpanGroupIndexCache ( ) { mSpanGroupIndexCache . clear ( ) ; } public boolean isSpanIndexCacheEnabled ( ) { return mCacheSpanIndices ; } public boolean isSpanGroupIndexCacheEnabled ( ) { return mCacheSpanGroupIndices ; } int getCachedSpanIndex ( int position , int spanCount ) { if ( ! mCacheSpanIndices ) { return getSpanIndex ( position , spanCount ) ; } final int existing = mSpanIndexCache . get ( position , - <NUM_LIT> ) ; if ( existing != - <NUM_LIT> ) { return existing ; } final int value = getSpanIndex ( position , spanCount ) ; mSpanIndexCache . put ( position , value ) ; return value ; } int getCachedSpanGroupIndex ( int position , int spanCount ) { if ( ! mCacheSpanGroupIndices ) { return getSpanGroupIndex ( position , spanCount ) ; } final int existing = mSpanGroupIndexCache . get ( position , - <NUM_LIT> ) ; if ( existing != - <NUM_LIT> ) { return existing ; } final int value = getSpanGroupIndex ( position , spanCount ) ; mSpanGroupIndexCache . put ( position , value ) ; return value ; } public int getSpanIndex ( int position , int spanCount ) { int positionSpanSize = getSpanSize ( position ) ; if ( positionSpanSize == spanCount ) { return <NUM_LIT> ; } int span = <NUM_LIT> ; int startPos = <NUM_LIT> ; if ( mCacheSpanIndices ) { int prevKey = findFirstKeyLessThan ( mSpanIndexCache , position ) ; if ( prevKey >= <NUM_LIT> ) { span = mSpanIndexCache . get ( prevKey ) + getSpanSize ( prevKey ) ; startPos = prevKey + <NUM_LIT> ; } } for ( int i = startPos ; i < position ; i ++ ) { int size = getSpanSize ( i ) ; span += size ; if ( span == spanCount ) { span = <NUM_LIT> ; } else if ( span > spanCount ) { span = size ; } } if ( span + positionSpanSize <= spanCount ) { return span ; } return <NUM_LIT> ; } static int findFirstKeyLessThan ( SparseIntArray cache , int position ) { int lo = <NUM_LIT> ; int hi = cache . size ( ) - <NUM_LIT> ; while ( lo <= hi ) { final int mid = ( lo + hi ) > > > <NUM_LIT> ; final int midVal = cache . keyAt ( mid ) ; if ( midVal < position ) { lo = mid + <NUM_LIT> ; } else { hi = mid - <NUM_LIT> ; } } int index = lo - <NUM_LIT> ; if ( index >= <NUM_LIT> && index < cache . size ( ) ) { return cache . keyAt ( index ) ; } return - <NUM_LIT> ; } public int getSpanGroupIndex ( int adapterPosition , int spanCount ) { int span = <NUM_LIT> ; int group = <NUM_LIT> ; int start = <NUM_LIT> ; if ( mCacheSpanGroupIndices ) { int prevKey = findFirstKeyLessThan ( mSpanGroupIndexCache , adapterPosition ) ; if ( prevKey != - <NUM_LIT> ) { group = mSpanGroupIndexCache . get ( prevKey ) ; start = prevKey + <NUM_LIT> ; span = getCachedSpanIndex ( prevKey , spanCount ) + getSpanSize ( prevKey ) ; if ( span == spanCount ) { span = <NUM_LIT> ; group ++ ; } } } int positionSpanSize = getSpanSize ( adapterPosition ) ; for ( int i = start ; i < adapterPosition ; i ++ ) { int size = getSpanSize ( i ) ; span += size ; if ( span == spanCount ) { span = <NUM_LIT> ; group ++ ; } else if ( span > spanCount ) { span = size ; group ++ ; } } if ( span + positionSpanSize > spanCount ) { group ++ ; } return group ; } } @ Override public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { View prevFocusedChild = findContainingItemView ( focused ) ; if ( prevFocusedChild == null ) { return null ; } LayoutParams lp = ( LayoutParams ) prevFocusedChild . getLayoutParams ( ) ; final int prevSpanStart = lp . mSpanIndex ; final int prevSpanEnd = lp . mSpanIndex + lp . mSpanSize ; View view = super . onFocusSearchFailed ( focused , direction , recycler , state ) ; if ( view == null ) { return null ; } final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; final boolean ascend = ( layoutDir == LayoutState . LAYOUT_END ) != mShouldReverseLayout ; final int start , inc , limit ; if ( ascend ) { start = getChildCount ( ) - <NUM_LIT> ; inc = - <NUM_LIT> ; limit = - <NUM_LIT> ; } else { start = <NUM_LIT> ; inc = <NUM_LIT> ; limit = getChildCount ( ) ; } final boolean preferLastSpan = mOrientation == VERTICAL && isLayoutRTL ( ) ; View focusableWeakCandidate = null ; int focusableWeakCandidateSpanIndex = - <NUM_LIT> ; int focusableWeakCandidateOverlap = <NUM_LIT> ; View unfocusableWeakCandidate = null ; int unfocusableWeakCandidateSpanIndex = - <NUM_LIT> ; int unfocusableWeakCandidateOverlap = <NUM_LIT> ; int focusableSpanGroupIndex = getSpanGroupIndex ( recycler , state , start ) ; for ( int i = start ; i != limit ; i += inc ) { int spanGroupIndex = getSpanGroupIndex ( recycler , state , i ) ; View candidate = getChildAt ( i ) ; if ( candidate == prevFocusedChild ) { break ; } if ( candidate . hasFocusable ( ) && spanGroupIndex != focusableSpanGroupIndex ) { if ( focusableWeakCandidate != null ) { break ; } continue ; } final LayoutParams candidateLp = ( LayoutParams ) candidate . getLayoutParams ( ) ; final int candidateStart = candidateLp . mSpanIndex ; final int candidateEnd = candidateLp . mSpanIndex + candidateLp . mSpanSize ; if ( candidate . hasFocusable ( ) && candidateStart == prevSpanStart && candidateEnd == prevSpanEnd ) { return candidate ; } boolean assignAsWeek = false ; if ( ( candidate . hasFocusable ( ) && focusableWeakCandidate == null ) || ( ! candidate . hasFocusable ( ) && unfocusableWeakCandidate == null ) ) { assignAsWeek = true ; } else { int maxStart = Math . max ( candidateStart , prevSpanStart ) ; int minEnd = Math . min ( candidateEnd , prevSpanEnd ) ; int overlap = minEnd - maxStart ; if ( candidate . hasFocusable ( ) ) { if ( overlap > focusableWeakCandidateOverlap ) { assignAsWeek = true ; } else if ( overlap == focusableWeakCandidateOverlap && preferLastSpan == ( candidateStart > focusableWeakCandidateSpanIndex ) ) { assignAsWeek = true ; } } else if ( focusableWeakCandidate == null && isViewPartiallyVisible ( candidate , false , true ) ) { if ( overlap > unfocusableWeakCandidateOverlap ) { assignAsWeek = true ; } else if ( overlap == unfocusableWeakCandidateOverlap && preferLastSpan == ( candidateStart > unfocusableWeakCandidateSpanIndex ) ) { assignAsWeek = true ; } } } if ( assignAsWeek ) { if ( candidate . hasFocusable ( ) ) { focusableWeakCandidate = candidate ; focusableWeakCandidateSpanIndex = candidateLp . mSpanIndex ; focusableWeakCandidateOverlap = Math . min ( candidateEnd , prevSpanEnd ) - Math . max ( candidateStart , prevSpanStart ) ; } else { unfocusableWeakCandidate = candidate ; unfocusableWeakCandidateSpanIndex = candidateLp . mSpanIndex ; unfocusableWeakCandidateOverlap = Math . min ( candidateEnd , prevSpanEnd ) - Math . max ( candidateStart , prevSpanStart ) ; } } } return ( focusableWeakCandidate != null ) ? focusableWeakCandidate : unfocusableWeakCandidate ; } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null && ! mPendingSpanCountChange ; } @ Override public int computeHorizontalScrollRange ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollRangeWithSpanInfo ( state ) ; } else { return super . computeHorizontalScrollRange ( state ) ; } } @ Override public int computeVerticalScrollRange ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollRangeWithSpanInfo ( state ) ; } else { return super . computeVerticalScrollRange ( state ) ; } } @ Override public int computeHorizontalScrollOffset ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollOffsetWithSpanInfo ( state ) ; } else { return super . computeHorizontalScrollOffset ( state ) ; } } @ Override public int computeVerticalScrollOffset ( RecyclerView . State state ) { if ( mUsingSpansToEstimateScrollBarDimensions ) { return computeScrollOffsetWithSpanInfo ( state ) ; } else { return super . computeVerticalScrollOffset ( state ) ; } } public void setUsingSpansToEstimateScrollbarDimensions ( boolean useSpansToEstimateScrollBarDimensions ) { mUsingSpansToEstimateScrollBarDimensions = useSpansToEstimateScrollBarDimensions ; } public boolean isUsingSpansToEstimateScrollbarDimensions ( ) { return mUsingSpansToEstimateScrollBarDimensions ; } private int computeScrollRangeWithSpanInfo ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; View startChild = findFirstVisibleChildClosestToStart ( ! isSmoothScrollbarEnabled ( ) , true ) ; View endChild = findFirstVisibleChildClosestToEnd ( ! isSmoothScrollbarEnabled ( ) , true ) ; if ( startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! isSmoothScrollbarEnabled ( ) ) { return mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; } final int laidOutArea = mOrientationHelper . getDecoratedEnd ( endChild ) - mOrientationHelper . getDecoratedStart ( startChild ) ; final int firstVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; final int lastVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int totalSpans = mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; final int laidOutSpans = lastVisibleSpan - firstVisibleSpan + <NUM_LIT> ; return ( int ) ( ( ( float ) laidOutArea / laidOutSpans ) * totalSpans ) ; } private int computeScrollOffsetWithSpanInfo ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; boolean smoothScrollEnabled = isSmoothScrollbarEnabled ( ) ; View startChild = findFirstVisibleChildClosestToStart ( ! smoothScrollEnabled , true ) ; View endChild = findFirstVisibleChildClosestToEnd ( ! smoothScrollEnabled , true ) ; if ( startChild == null || endChild == null ) { return <NUM_LIT> ; } int startChildSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; int endChildSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int minSpan = Math . min ( startChildSpan , endChildSpan ) ; final int maxSpan = Math . max ( startChildSpan , endChildSpan ) ; final int totalSpans = mSpanSizeLookup . getCachedSpanGroupIndex ( state . getItemCount ( ) - <NUM_LIT> , mSpanCount ) + <NUM_LIT> ; final int spansBefore = mShouldReverseLayout ? Math . max ( <NUM_LIT> , totalSpans - maxSpan - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minSpan ) ; if ( ! smoothScrollEnabled ) { return spansBefore ; } final int laidOutArea = Math . abs ( mOrientationHelper . getDecoratedEnd ( endChild ) - mOrientationHelper . getDecoratedStart ( startChild ) ) ; final int firstVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( startChild ) , mSpanCount ) ; final int lastVisibleSpan = mSpanSizeLookup . getCachedSpanGroupIndex ( getPosition ( endChild ) , mSpanCount ) ; final int laidOutSpans = lastVisibleSpan - firstVisibleSpan + <NUM_LIT> ; final float avgSizePerSpan = ( float ) laidOutArea / laidOutSpans ; return Math . round ( spansBefore * avgSizePerSpan + ( mOrientationHelper . getStartAfterPadding ( ) - mOrientationHelper . getDecoratedStart ( startChild ) ) ) ; } public static final class DefaultSpanSizeLookup extends SpanSizeLookup { @ Override public int getSpanSize ( int position ) { return <NUM_LIT> ; } @ Override public int getSpanIndex ( int position , int spanCount ) { return position % spanCount ; } } public static class LayoutParams extends RecyclerView . LayoutParams { public static final int INVALID_SPAN_ID = - <NUM_LIT> ; int mSpanIndex = INVALID_SPAN_ID ; int mSpanSize = <NUM_LIT> ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; } public LayoutParams ( ViewGroup . MarginLayoutParams source ) { super ( source ) ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } public LayoutParams ( RecyclerView . LayoutParams source ) { super ( source ) ; } public int getSpanIndex ( ) { return mSpanIndex ; } public int getSpanSize ( ) { return mSpanSize ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; } values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } throw new IllegalStateException ( String . format ( Locale . US , "<STR_LIT>" + "<STR_LIT>" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; if ( hasNewTarget ) { dispatchSelected ( target ) ; } } void notifyBeginFakeDrag ( ) { mAdapterState = STATE_IN_PROGRESS_FAKE_DRAG ; startDrag ( true ) ; } void notifyEndFakeDrag ( ) { if ( isDragging ( ) && ! mFakeDragging ) { return ; } mFakeDragging = false ; updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mScrollValues . mPosition != mDragStartPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } else { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; } } void setOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallback = callback ; } int getScrollState ( ) { return mScrollState ; } boolean isIdle ( ) { return mScrollState == SCROLL_STATE_IDLE ; } boolean isDragging ( ) { return mScrollState == SCROLL_STATE_DRAGGING ; } boolean isFakeDragging ( ) { return mFakeDragging ; } private boolean isInAnyDraggingState ( ) { return mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG || mAdapterState == STATE_IN_PROGRESS_FAKE_DRAG ; } double getRelativeScrollPosition ( ) { updateScrollEventValues ( ) ; return mScrollValues . mPosition + ( double ) mScrollValues . mOffset ; } private void dispatchStateChanged ( @ ScrollState int state ) { if ( mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE ) { return ; } if ( mScrollState == state ) { return ; } mScrollState = state ; if ( mCallback != null ) { mCallback . onPageScrollStateChanged ( state ) ; } } private void dispatchSelected ( int target ) { if ( mCallback != null ) { mCallback . onPageSelected ( target ) ; } } private void dispatchScrolled ( int position , float offset , int offsetPx ) { if ( mCallback != null ) { mCallback . onPageScrolled ( position , offset , offsetPx ) ; } } private int getPosition ( ) { return mLayoutManager . findFirstVisibleItemPosition ( ) ; } @ Retention ( SOURCE ) @ IntDef ( { STATE_IDLE , STATE_IN_PROGRESS_MANUAL_DRAG , STATE_IN_PROGRESS_SMOOTH_SCROLL , STATE_IN_PROGRESS_IMMEDIATE_SCROLL , STATE_IN_PROGRESS_FAKE_DRAG } ) private @ interface AdapterState { } private static final class ScrollEventValues { int mPosition ; float mOffset ; int mOffsetPx ; ScrollEventValues ( ) { } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = <NUM_LIT> ; mOffsetPx = <NUM_LIT> ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; } return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processPersistent ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void unused ( RecyclerView . ViewHolder holder ) ; } static class InfoRecord { static final int FLAG_DISAPPEARED = <NUM_LIT> ; static final int FLAG_APPEAR = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_PRE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_POST = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_APPEAR_AND_DISAPPEAR = FLAG_APPEAR | FLAG_DISAPPEARED ; static final int FLAG_PRE_AND_POST = FLAG_PRE | FLAG_POST ; static final int FLAG_APPEAR_PRE_AND_POST = FLAG_APPEAR | FLAG_PRE | FLAG_POST ; int flags ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ; static Pools . Pool < InfoRecord > sPool = new Pools . SimplePool < > ( <NUM_LIT> ) ; private InfoRecord ( ) { } static InfoRecord obtain ( ) { InfoRecord record = sPool . acquire ( ) ; return record == null ? new InfoRecord ( ) : record ; } static void recycle ( InfoRecord record ) { record . flags = <NUM_LIT> ; record . preInfo = null ; record . postInfo = null ; sPool . release ( record ) ; } static void drainCache ( ) { while ( sPool . acquire ( ) != null ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( "<STR_LIT>" ) void addTile ( int generation , TileList . Tile < T > tile ) ; void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > { void refresh ( int generation ) ; void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) ; void loadTile ( int position , int scrollHint ) ; @ SuppressLint ( "<STR_LIT>" ) void recycleTile ( TileList . Tile < T > tile ) ; } MainThreadCallback < T > getMainThreadProxy ( MainThreadCallback < T > callback ) ; BackgroundCallback < T > getBackgroundProxy ( BackgroundCallback < T > callback ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( "<STR_LIT>" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } void snapToTargetExistingView ( ) { if ( mRecyclerView == null ) { return ; } RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return ; } View snapView = findSnapView ( layoutManager ) ; if ( snapView == null ) { return ; } int [ ] snapDistance = calculateDistanceToFinalSnap ( layoutManager , snapView ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] ) ; } } @ Nullable protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { return createSnapScroller ( layoutManager ) ; } @ Nullable @ Deprecated protected LinearSmoothScroller createSnapScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { if ( mRecyclerView == null ) { return ; } int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } } ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable public abstract int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) ; @ SuppressWarnings ( "<STR_LIT>" ) @ Nullable @ SuppressLint ( "<STR_LIT>" ) public abstract View findSnapView ( RecyclerView . LayoutManager layoutManager ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ; if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; } if ( moveOp . positionStart < addOp . positionStart ) { offset ++ ; } if ( addOp . positionStart <= moveOp . positionStart ) { moveOp . positionStart += addOp . itemCount ; } if ( addOp . positionStart <= moveOp . itemCount ) { moveOp . itemCount += addOp . itemCount ; } addOp . positionStart += offset ; list . set ( move , addOp ) ; list . set ( add , moveOp ) ; } void swapMoveUpdate ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int update , AdapterHelper . UpdateOp updateOp ) { AdapterHelper . UpdateOp extraUp1 = null ; AdapterHelper . UpdateOp extraUp2 = null ; if ( moveOp . itemCount < updateOp . positionStart ) { updateOp . positionStart -- ; } else if ( moveOp . itemCount < updateOp . positionStart + updateOp . itemCount ) { updateOp . itemCount -- ; extraUp1 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart , <NUM_LIT> , updateOp . payload ) ; } if ( moveOp . positionStart <= updateOp . positionStart ) { updateOp . positionStart ++ ; } else if ( moveOp . positionStart < updateOp . positionStart + updateOp . itemCount ) { final int remaining = updateOp . positionStart + updateOp . itemCount - moveOp . positionStart ; extraUp2 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart + <NUM_LIT> , remaining , updateOp . payload ) ; updateOp . itemCount -= remaining ; } list . set ( update , moveOp ) ; if ( updateOp . itemCount > <NUM_LIT> ) { list . set ( move , updateOp ) ; } else { list . remove ( move ) ; mCallback . recycleUpdateOp ( updateOp ) ; } if ( extraUp1 != null ) { list . add ( move , extraUp1 ) ; } if ( extraUp2 != null ) { list . add ( move , extraUp2 ) ; } } private int getLastMoveOutOfOrder ( List < AdapterHelper . UpdateOp > list ) { boolean foundNonMove = false ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final AdapterHelper . UpdateOp op1 = list . get ( i ) ; if ( op1 . cmd == AdapterHelper . UpdateOp . MOVE ) { if ( foundNonMove ) { return i ; } } else { foundNonMove = true ; } } return - <NUM_LIT> ; } interface Callback { AdapterHelper . UpdateOp obtainUpdateOp ( int cmd , int startPosition , int itemCount , Object payload ) ; void recycleUpdateOp ( AdapterHelper . UpdateOp op ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oldHolder + "<STR_LIT>" + newHolder + "<STR_LIT>" + fromX + "<STR_LIT>" + fromY + "<STR_LIT>" + toX + "<STR_LIT>" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) { dispatchAnimationsFinished ( ) ; } } @ Override public void endAnimations ( ) { int count = mPendingMoves . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo item = mPendingMoves . get ( i ) ; View view = item . holder . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item . holder ) ; mPendingMoves . remove ( i ) ; } count = mPendingRemovals . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingRemovals . get ( i ) ; dispatchRemoveFinished ( item ) ; mPendingRemovals . remove ( i ) ; } count = mPendingAdditions . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingAdditions . get ( i ) ; item . itemView . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; mPendingAdditions . remove ( i ) ; } count = mPendingChanges . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { endChangeAnimationIfNecessary ( mPendingChanges . get ( i ) ) ; } mPendingChanges . clear ( ) ; if ( ! isRunning ( ) ) { return ; } int listCount = mMovesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; count = moves . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; RecyclerView . ViewHolder item = moveInfo . holder ; View view = item . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( moveInfo . holder ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( moves ) ; } } } listCount = mAdditionsList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; count = additions . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { RecyclerView . ViewHolder item = additions . get ( j ) ; View view = item . itemView ; view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; additions . remove ( j ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( additions ) ; } } } listCount = mChangesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; count = changes . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { endChangeAnimationIfNecessary ( changes . get ( j ) ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( changes ) ; } } } cancelAll ( mRemoveAnimations ) ; cancelAll ( mMoveAnimations ) ; cancelAll ( mAddAnimations ) ; cancelAll ( mChangeAnimations ) ; dispatchAnimationsFinished ( ) ; } void cancelAll ( List < RecyclerView . ViewHolder > viewHolders ) { for ( int i = viewHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { viewHolders . get ( i ) . itemView . animate ( ) . cancel ( ) ; } } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull List < Object > payloads ) { return ! payloads . isEmpty ( ) || super . canReuseUpdatedViewHolder ( viewHolder , payloads ) ; } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = "<STR_LIT>" ; private static final String KEY_PREFIX_STATE = "<STR_LIT>" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( "<STR_LIT>" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( "<STR_LIT>" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , "<STR_LIT>" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( "<STR_LIT>" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ; mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageScrollStateChanged ( int state ) { updateFragmentMaxLifecycle ( false ) ; } @ Override public void onPageSelected ( int position ) { updateFragmentMaxLifecycle ( false ) ; } } ; mViewPager . registerOnPageChangeCallback ( mPageChangeCallback ) ; mDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updateFragmentMaxLifecycle ( true ) ; } } ; registerAdapterDataObserver ( mDataObserver ) ; mLifecycleObserver = new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { updateFragmentMaxLifecycle ( false ) ; } } ; mLifecycle . addObserver ( mLifecycleObserver ) ; } void unregister ( @ NonNull RecyclerView recyclerView ) { androidx . fluidviewpager2 . widget . ViewPager2 viewPager = inferViewPager ( recyclerView ) ; viewPager . unregisterOnPageChangeCallback ( mPageChangeCallback ) ; unregisterAdapterDataObserver ( mDataObserver ) ; mLifecycle . removeObserver ( mLifecycleObserver ) ; mViewPager = null ; } void updateFragmentMaxLifecycle ( boolean dataSetChanged ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } if ( mViewPager . getScrollState ( ) != androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ) { return ; } if ( mFragments . isEmpty ( ) || getItemCount ( ) == <NUM_LIT> ) { return ; } final int currentItem = mViewPager . getCurrentItem ( ) ; if ( currentItem >= getItemCount ( ) ) { return ; } long currentItemId = getItemId ( currentItem ) ; if ( currentItemId == mPrimaryItemId && ! dataSetChanged ) { return ; } Fragment currentItemFragment = mFragments . get ( currentItemId ) ; if ( currentItemFragment == null || ! currentItemFragment . isAdded ( ) ) { return ; } mPrimaryItemId = currentItemId ; FragmentTransaction transaction = mFragmentManager . beginTransaction ( ) ; Fragment toResume = null ; List < List < OnPostEventListener > > onPost = new ArrayList < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . valueAt ( ix ) ; if ( ! fragment . isAdded ( ) ) { continue ; } if ( itemId != mPrimaryItemId ) { transaction . setMaxLifecycle ( fragment , STARTED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( fragment , STARTED ) ) ; } else { toResume = fragment ; } fragment . setMenuVisibility ( itemId == mPrimaryItemId ) ; } if ( toResume != null ) { transaction . setMaxLifecycle ( toResume , RESUMED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( toResume , RESUMED ) ) ; } if ( ! transaction . isEmpty ( ) ) { transaction . commitNow ( ) ; Collections . reverse ( onPost ) ; for ( List < OnPostEventListener > event : onPost ) { mFragmentEventDispatcher . dispatchPostEvents ( event ) ; } } } @ NonNull private androidx . fluidviewpager2 . widget . ViewPager2 inferViewPager ( @ NonNull RecyclerView recyclerView ) { ViewParent parent = recyclerView . getParent ( ) ; if ( parent instanceof androidx . fluidviewpager2 . widget . ViewPager2 ) { return ( ViewPager2 ) parent ; } throw new IllegalStateException ( "<STR_LIT>" + parent ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) { int previousEnd = mLastEventPosition + mLastEventCount ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; mLastEventCount = Math . max ( previousEnd , position + count ) - mLastEventPosition ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventPayload = payload ; mLastEventType = TYPE_CHANGE ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ; mTrackingListeners . clear ( ) ; mInterceptingListener = listener ; return true ; } else { mTrackingListeners . add ( listener ) ; } } return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { if ( mInterceptingListener == null ) { return ; } mInterceptingListener . onTouchEvent ( recyclerView , event ) ; int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingListener = null ; } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { for ( OnItemTouchListener listener : mListeners ) { listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ; } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( "<STR_LIT>" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ; int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + viewHolder + "<STR_LIT>" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + oldHolder + "<STR_LIT>" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( "<STR_LIT>" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( "<STR_LIT>" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeFinished ( item , oldItem ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchRemoveStarting ( RecyclerView . ViewHolder item ) { onRemoveStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchMoveStarting ( RecyclerView . ViewHolder item ) { onMoveStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchAddStarting ( RecyclerView . ViewHolder item ) { onAddStarting ( item ) ; } @ SuppressLint ( "<STR_LIT>" ) public final void dispatchChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeStarting ( item , oldItem ) ; } @ SuppressLint ( "<STR_LIT>" ) @ SuppressWarnings ( "<STR_LIT>" ) public void onRemoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onRemoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public void onAddStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onAddFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public void onMoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) public void onMoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( "<STR_LIT>" ) @ SuppressWarnings ( "<STR_LIT>" ) public void onChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { } @ SuppressLint ( "<STR_LIT>" ) public void onChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; } @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { NestedAdapterWrapper wrapper = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( wrapper == null ) { throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" + globalViewType ) ; } return wrapper ; } @ Override @ NonNull public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { NestedAdapterWrapper existingWrapper = mGlobalTypeToWrapper . valueAt ( i ) ; if ( existingWrapper == wrapper ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } class WrapperViewTypeLookup implements ViewTypeLookup { private SparseIntArray mLocalToGlobalMapping = new SparseIntArray ( <NUM_LIT> ) ; private SparseIntArray mGlobalToLocalMapping = new SparseIntArray ( <NUM_LIT> ) ; final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { int index = mLocalToGlobalMapping . indexOfKey ( localType ) ; if ( index > - <NUM_LIT> ) { return mLocalToGlobalMapping . valueAt ( index ) ; } int globalType = obtainViewType ( mWrapper ) ; mLocalToGlobalMapping . put ( localType , globalType ) ; mGlobalToLocalMapping . put ( globalType , localType ) ; return globalType ; } @ Override public int globalToLocal ( int globalType ) { int index = mGlobalToLocalMapping . indexOfKey ( globalType ) ; if ( index < <NUM_LIT> ) { throw new IllegalStateException ( "<STR_LIT>" + globalType + "<STR_LIT>" + "<STR_LIT>" + mWrapper . adapter ) ; } return mGlobalToLocalMapping . valueAt ( index ) ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; } offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) { return null ; } LinearLayoutManager linearLayoutManager = ( LinearLayoutManager ) layoutManager ; if ( linearLayoutManager . getOrientation ( ) != RecyclerView . VERTICAL ) { return null ; } return linearLayoutManager ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( "<STR_LIT>" ) final Callback mCallback ; @ SuppressWarnings ( "<STR_LIT>" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , "<STR_LIT>" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) { adapter . bindViewHolder ( viewHolder , localPosition ) ; } public long getItemId ( int localPosition ) { long localItemId = adapter . getItemId ( localPosition ) ; return mStableIdLookup . localToGlobal ( localItemId ) ; } interface Callback { void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) ; void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) ; void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) ; } } </s>
<s> package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ; } } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) { return mItemDecoration ; } public State getState ( ) { return mState ; } @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { mState = state ; } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { mItemDecoration . getItemOffsets ( outRect , itemPosition , parent ) ; } @ Override public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) { mItemDecoration . getItemOffsets ( outRect , view , parent , state ) ; } } } </s>
<s> package com . google . android . material . slider ; import static androidx . core . math . MathUtils . clamp ; import static androidx . core . view . accessibility . AccessibilityNodeInfoCompat . RangeInfoCompat . RANGE_TYPE_FLOAT ; import static com . google . android . material . slider . LabelFormatter . LABEL_FLOATING ; import static com . google . android . material . slider . LabelFormatter . LABEL_GONE ; import static com . google . android . material . slider . LabelFormatter . LABEL_VISIBLE ; import static com . google . android . material . slider . LabelFormatter . LABEL_WITHIN_BOUNDS ; import static com . google . android . material . theme . overlay . MaterialThemeOverlay . wrap ; import static java . lang . Float . compare ; import static java . lang . Math . abs ; import static java . lang . Math . max ; import static java . lang . Math . min ; import static java . util . Collections . max ; import static java . util . Collections . min ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . animation . ValueAnimator . AnimatorUpdateListener ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . graphics . Paint . Cap ; import android . graphics . Paint . Style ; import android . graphics . Path ; import android . graphics . PorterDuff . Mode ; import android . graphics . PorterDuffXfermode ; import android . graphics . Rect ; import android . graphics . RectF ; import android . graphics . Region . Op ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . RippleDrawable ; import android . os . Build . VERSION ; import android . os . Build . VERSION_CODES ; import android . os . Bundle ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . view . accessibility . AccessibilityEvent ; import android . view . accessibility . AccessibilityManager ; import android . widget . SeekBar ; import androidx . annotation . ColorInt ; import androidx . annotation . ColorRes ; import androidx . annotation . DimenRes ; import androidx . annotation . Dimension ; import androidx . annotation . DrawableRes ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . content . ContextCompat ; import androidx . core . graphics . drawable . DrawableCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat ; import androidx . core . view . accessibility . AccessibilityNodeInfoCompat . RangeInfoCompat ; import androidx . customview . widget . ExploreByTouchHelper ; import com . google . android . material . R ; import com . google . android . material . animation . AnimationUtils ; import com . google . android . material . drawable . DrawableUtils ; import com . google . android . material . internal . DescendantOffsetUtils ; import com . google . android . material . internal . ThemeEnforcement ; import com . google . android . material . internal . ViewOverlayImpl ; import com . google . android . material . internal . ViewUtils ; import com . google . android . material . motion . MotionUtils ; import com . google . android . material . resources . MaterialResources ; import com . google . android . material . shape . CornerFamily ; import com . google . android . material . shape . MaterialShapeDrawable ; import com . google . android . material . shape . ShapeAppearanceModel ; import com . google . android . material . tooltip . TooltipDrawable ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . math . BigDecimal ; import java . math . MathContext ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; @ SuppressLint ( "<STR_LIT>" ) abstract class BaseOverlaySlider < S extends BaseOverlaySlider < S , L , T > , L extends BaseOnChangeListener < S > , T extends BaseOnSliderTouchListener < S > > extends View { static final int DEF_STYLE_RES = R . style . Widget_MaterialComponents_Slider ; static final int UNIT_VALUE = <NUM_LIT> ; static final int UNIT_PX = <NUM_LIT> ; private static final String TAG = BaseOverlaySlider . class . getSimpleName ( ) ; private static final String EXCEPTION_ILLEGAL_VALUE = "<STR_LIT>" + "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_DISCRETE_VALUE = "<STR_LIT>" + "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_VALUE_FROM = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_VALUE_TO = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_STEP_SIZE = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE_UNIT = "<STR_LIT>" ; private static final String EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE = "<STR_LIT>" + "<STR_LIT>" ; private static final String WARNING_FLOATING_POINT_ERROR = "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; private static final int TIMEOUT_SEND_ACCESSIBILITY_EVENT = <NUM_LIT> ; private static final int HALO_ALPHA = <NUM_LIT> ; private static final double THRESHOLD = <NUM_LIT> ; private static final int DEFAULT_LABEL_ANIMATION_ENTER_DURATION = <NUM_LIT> ; private static final int DEFAULT_LABEL_ANIMATION_EXIT_DURATION = <NUM_LIT> ; private static final int LABEL_ANIMATION_ENTER_DURATION_ATTR = R . attr . motionDurationMedium4 ; private static final int LABEL_ANIMATION_EXIT_DURATION_ATTR = R . attr . motionDurationShort3 ; private static final int LABEL_ANIMATION_ENTER_EASING_ATTR = R . attr . motionEasingEmphasizedInterpolator ; private static final int LABEL_ANIMATION_EXIT_EASING_ATTR = R . attr . motionEasingEmphasizedAccelerateInterpolator ; @ Dimension private static final int MIN_TOUCH_TARGET_DP = <NUM_LIT> ; @ NonNull private final Paint inactiveTrackPaint ; @ NonNull private final Paint inactiveTrackPaintUnder ; @ NonNull private final Paint activeTrackPaint ; @ NonNull private final Paint activeTrackPaintUnder ; @ NonNull private final Paint thumbPaint ; @ NonNull private final Paint haloPaint ; @ NonNull private final Paint inactiveTicksPaint ; @ NonNull private final Paint activeTicksPaint ; @ NonNull private final AccessibilityHelper accessibilityHelper ; private final AccessibilityManager accessibilityManager ; @ NonNull private final List < TooltipDrawable > labels = new ArrayList < > ( ) ; @ NonNull private final List < L > changeListeners = new ArrayList < > ( ) ; @ NonNull private final List < T > touchListeners = new ArrayList < > ( ) ; private final int scaledTouchSlop ; @ NonNull private final MaterialShapeDrawable defaultThumbDrawable = new MaterialShapeDrawable ( ) ; private AccessibilityEventSender accessibilityEventSender ; private int labelStyle ; private boolean labelsAreAnimatedIn = false ; private ValueAnimator labelsInAnimator ; private ValueAnimator labelsOutAnimator ; private int minTrackSidePadding ; private int defaultThumbRadius ; private int defaultTrackHeight ; private int defaultTickActiveRadius ; private int defaultTickInactiveRadius ; @ Dimension ( unit = Dimension . PX ) private int minTouchTargetSize ; private int minWidgetHeight ; private int widgetHeight ; private int labelBehavior ; private int trackHeight ; private int trackSidePadding ; private int thumbRadius ; private int haloRadius ; private RectF boundRectF = new RectF ( ) ; private Path boundPath = new Path ( ) ; private int labelPadding ; private float touchDownX ; private MotionEvent lastEvent ; private LabelFormatter formatter ; private boolean thumbIsPressed = false ; private float valueFrom ; private float valueTo ; private ArrayList < Float > values = new ArrayList < > ( ) ; private int activeThumbIdx = - <NUM_LIT> ; private int focusedThumbIdx = - <NUM_LIT> ; private float stepSize = <NUM_LIT> ; private float [ ] ticksCoordinates ; private boolean tickVisible = true ; private int tickActiveRadius ; private int tickInactiveRadius ; private int trackWidth ; private boolean forceDrawCompatHalo ; private boolean isLongPress = false ; private boolean dirtyConfig ; @ NonNull private ColorStateList haloColor ; @ NonNull private ColorStateList tickColorActive ; @ NonNull private ColorStateList tickColorInactive ; @ NonNull private ColorStateList trackColorActive ; @ NonNull private ColorStateList trackColorInactive ; @ Nullable private Drawable customThumbDrawable ; @ NonNull private List < Drawable > customThumbDrawablesForValues = Collections . emptyList ( ) ; private float touchPosition ; @ SeparationUnit private int separationUnit = UNIT_PX ; public BaseOverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public BaseOverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public BaseOverlaySlider ( @ NonNull Context context , @ Nullable final AttributeSet attrs , final int defStyleAttr ) { super ( wrap ( context , attrs , defStyleAttr , DEF_STYLE_RES ) , attrs , defStyleAttr ) ; context = getContext ( ) ; inactiveTrackPaintUnder = new Paint ( ) ; inactiveTrackPaintUnder . setXfermode ( new PorterDuffXfermode ( Mode . OVERLAY ) ) ; inactiveTrackPaintUnder . setStyle ( Style . STROKE ) ; inactiveTrackPaintUnder . setColor ( ContextCompat . getColor ( context , org . akanework . gramophone . R . color . contrast_secondaryOverlayColor ) ) ; inactiveTrackPaint = new Paint ( ) ; inactiveTrackPaint . setStyle ( Style . STROKE ) ; activeTrackPaintUnder = new Paint ( ) ; activeTrackPaintUnder . setXfermode ( new PorterDuffXfermode ( Mode . OVERLAY ) ) ; activeTrackPaintUnder . setStyle ( Style . STROKE ) ; activeTrackPaintUnder . setColor ( ContextCompat . getColor ( context , org . akanework . gramophone . R . color . contrast_primaryOverlayColor ) ) ; activeTrackPaint = new Paint ( ) ; activeTrackPaint . setStyle ( Style . STROKE ) ; thumbPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; thumbPaint . setStyle ( Style . FILL ) ; thumbPaint . setXfermode ( new PorterDuffXfermode ( Mode . CLEAR ) ) ; haloPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; haloPaint . setStyle ( Style . FILL ) ; inactiveTicksPaint = new Paint ( ) ; inactiveTicksPaint . setStyle ( Style . STROKE ) ; inactiveTicksPaint . setStrokeCap ( Cap . ROUND ) ; activeTicksPaint = new Paint ( ) ; activeTicksPaint . setStyle ( Style . STROKE ) ; activeTicksPaint . setStrokeCap ( Cap . ROUND ) ; loadResources ( context . getResources ( ) ) ; processAttributes ( context , attrs , defStyleAttr ) ; setFocusable ( true ) ; setClickable ( true ) ; defaultThumbDrawable . setShadowCompatibilityMode ( MaterialShapeDrawable . SHADOW_COMPAT_MODE_ALWAYS ) ; scaledTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; accessibilityHelper = new AccessibilityHelper ( this ) ; ViewCompat . setAccessibilityDelegate ( this , accessibilityHelper ) ; accessibilityManager = ( AccessibilityManager ) getContext ( ) . getSystemService ( Context . ACCESSIBILITY_SERVICE ) ; } private static int pivotIndex ( float [ ] coordinates , float position ) { return Math . round ( position * ( coordinates . length / <NUM_LIT> - <NUM_LIT> ) ) ; } private static float getAnimatorCurrentValueOrDefault ( ValueAnimator animator , float defaultValue ) { if ( animator != null && animator . isRunning ( ) ) { float value = ( float ) animator . getAnimatedValue ( ) ; animator . cancel ( ) ; return value ; } return defaultValue ; } private static boolean isMouseEvent ( MotionEvent event ) { return event . getToolType ( <NUM_LIT> ) == MotionEvent . TOOL_TYPE_MOUSE ; } private void loadResources ( @ NonNull Resources resources ) { minWidgetHeight = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_widget_height ) ; minTrackSidePadding = resources . getDimensionPixelOffset ( R . dimen . mtrl_slider_track_side_padding ) ; trackSidePadding = minTrackSidePadding ; defaultThumbRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_thumb_radius ) ; defaultTrackHeight = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_track_height ) ; defaultTickActiveRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_tick_radius ) ; defaultTickInactiveRadius = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_tick_radius ) ; labelPadding = resources . getDimensionPixelSize ( R . dimen . mtrl_slider_label_padding ) ; } private void processAttributes ( Context context , AttributeSet attrs , int defStyleAttr ) { TypedArray a = ThemeEnforcement . obtainStyledAttributes ( context , attrs , R . styleable . Slider , defStyleAttr , DEF_STYLE_RES ) ; labelStyle = a . getResourceId ( R . styleable . Slider_labelStyle , R . style . Widget_MaterialComponents_Tooltip ) ; valueFrom = a . getFloat ( R . styleable . Slider_android_valueFrom , <NUM_LIT> ) ; valueTo = a . getFloat ( R . styleable . Slider_android_valueTo , <NUM_LIT> ) ; setValues ( valueFrom ) ; stepSize = a . getFloat ( R . styleable . Slider_android_stepSize , <NUM_LIT> ) ; @ SuppressLint ( "<STR_LIT>" ) float defaultMinTouchTargetSize = ( float ) Math . ceil ( ViewUtils . dpToPx ( getContext ( ) , MIN_TOUCH_TARGET_DP ) ) ; minTouchTargetSize = ( int ) Math . ceil ( a . getDimension ( R . styleable . Slider_minTouchTargetSize , defaultMinTouchTargetSize ) ) ; boolean hasTrackColor = a . hasValue ( R . styleable . Slider_trackColor ) ; int trackColorInactiveRes = hasTrackColor ? R . styleable . Slider_trackColor : R . styleable . Slider_trackColorInactive ; int trackColorActiveRes = hasTrackColor ? R . styleable . Slider_trackColor : R . styleable . Slider_trackColorActive ; ColorStateList trackColorInactive = MaterialResources . getColorStateList ( context , a , trackColorInactiveRes ) ; setTrackInactiveTintList ( trackColorInactive != null ? trackColorInactive : AppCompatResources . getColorStateList ( context , R . color . material_slider_inactive_track_color ) ) ; ColorStateList trackColorActive = MaterialResources . getColorStateList ( context , a , trackColorActiveRes ) ; setTrackActiveTintList ( trackColorActive != null ? trackColorActive : AppCompatResources . getColorStateList ( context , R . color . material_slider_active_track_color ) ) ; ColorStateList thumbColor = MaterialResources . getColorStateList ( context , a , R . styleable . Slider_thumbColor ) ; defaultThumbDrawable . setFillColor ( thumbColor ) ; if ( a . hasValue ( R . styleable . Slider_thumbStrokeColor ) ) { setThumbStrokeColor ( MaterialResources . getColorStateList ( context , a , R . styleable . Slider_thumbStrokeColor ) ) ; } setThumbStrokeWidth ( a . getDimension ( R . styleable . Slider_thumbStrokeWidth , <NUM_LIT> ) ) ; ColorStateList haloColor = MaterialResources . getColorStateList ( context , a , R . styleable . Slider_haloColor ) ; setHaloTintList ( haloColor != null ? haloColor : AppCompatResources . getColorStateList ( context , R . color . material_slider_halo_color ) ) ; tickVisible = a . getBoolean ( R . styleable . Slider_tickVisible , true ) ; boolean hasTickColor = a . hasValue ( R . styleable . Slider_tickColor ) ; int tickColorInactiveRes = hasTickColor ? R . styleable . Slider_tickColor : R . styleable . Slider_tickColorInactive ; int tickColorActiveRes = hasTickColor ? R . styleable . Slider_tickColor : R . styleable . Slider_tickColorActive ; ColorStateList tickColorInactive = MaterialResources . getColorStateList ( context , a , tickColorInactiveRes ) ; setTickInactiveTintList ( tickColorInactive != null ? tickColorInactive : AppCompatResources . getColorStateList ( context , R . color . material_slider_inactive_tick_marks_color ) ) ; ColorStateList tickColorActive = MaterialResources . getColorStateList ( context , a , tickColorActiveRes ) ; setTickActiveTintList ( tickColorActive != null ? tickColorActive : AppCompatResources . getColorStateList ( context , R . color . material_slider_active_tick_marks_color ) ) ; setThumbRadius ( a . getDimensionPixelSize ( R . styleable . Slider_thumbRadius , <NUM_LIT> ) ) ; setHaloRadius ( a . getDimensionPixelSize ( R . styleable . Slider_haloRadius , <NUM_LIT> ) ) ; setThumbElevation ( a . getDimension ( R . styleable . Slider_thumbElevation , <NUM_LIT> ) ) ; setTrackHeight ( a . getDimensionPixelSize ( R . styleable . Slider_trackHeight , <NUM_LIT> ) ) ; setTickActiveRadius ( a . getDimensionPixelSize ( R . styleable . Slider_tickRadiusActive , <NUM_LIT> ) ) ; setTickInactiveRadius ( a . getDimensionPixelSize ( R . styleable . Slider_tickRadiusInactive , <NUM_LIT> ) ) ; setLabelBehavior ( a . getInt ( R . styleable . Slider_labelBehavior , LABEL_FLOATING ) ) ; if ( ! a . getBoolean ( R . styleable . Slider_android_enabled , true ) ) { setEnabled ( false ) ; } a . recycle ( ) ; } private boolean maybeIncreaseTrackSidePadding ( ) { int increasedSidePaddingByThumb = max ( thumbRadius - defaultThumbRadius , <NUM_LIT> ) ; int increasedSidePaddingByTrack = max ( ( trackHeight - defaultTrackHeight ) / <NUM_LIT> , <NUM_LIT> ) ; int increasedSidePaddingByActiveTick = max ( tickActiveRadius - defaultTickActiveRadius , <NUM_LIT> ) ; int increasedSidePaddingByInactiveTick = max ( tickInactiveRadius - defaultTickInactiveRadius , <NUM_LIT> ) ; int newTrackSidePadding = minTrackSidePadding + max ( max ( increasedSidePaddingByThumb , increasedSidePaddingByTrack ) , max ( increasedSidePaddingByActiveTick , increasedSidePaddingByInactiveTick ) ) ; if ( trackSidePadding == newTrackSidePadding ) { return false ; } trackSidePadding = newTrackSidePadding ; if ( ViewCompat . isLaidOut ( this ) ) { updateTrackWidth ( getWidth ( ) ) ; } return true ; } private void validateValueFrom ( ) { if ( valueFrom >= valueTo ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE_FROM , valueFrom , valueTo ) ) ; } } private void validateValueTo ( ) { if ( valueTo <= valueFrom ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE_TO , valueTo , valueFrom ) ) ; } } private boolean valueLandsOnTick ( float value ) { return isMultipleOfStepSize ( value - valueFrom ) ; } private boolean isMultipleOfStepSize ( float value ) { double result = new BigDecimal ( Float . toString ( value ) ) . divide ( new BigDecimal ( Float . toString ( stepSize ) ) , MathContext . DECIMAL64 ) . doubleValue ( ) ; return Math . abs ( Math . round ( result ) - result ) < THRESHOLD ; } private void validateStepSize ( ) { if ( stepSize > <NUM_LIT> && ! valueLandsOnTick ( valueTo ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_STEP_SIZE , stepSize , valueFrom , valueTo ) ) ; } } private void validateValues ( ) { for ( Float value : values ) { if ( value < valueFrom || value > valueTo ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_VALUE , value , valueFrom , valueTo ) ) ; } if ( stepSize > <NUM_LIT> && ! valueLandsOnTick ( value ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_DISCRETE_VALUE , value , valueFrom , stepSize , stepSize ) ) ; } } } private void validateMinSeparation ( ) { final float minSeparation = getMinSeparation ( ) ; if ( minSeparation < <NUM_LIT> ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION , minSeparation ) ) ; } if ( stepSize > <NUM_LIT> && minSeparation > <NUM_LIT> ) { if ( separationUnit != UNIT_VALUE ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE_UNIT , minSeparation , stepSize ) ) ; } if ( minSeparation < stepSize || ! isMultipleOfStepSize ( minSeparation ) ) { throw new IllegalStateException ( String . format ( EXCEPTION_ILLEGAL_MIN_SEPARATION_STEP_SIZE , minSeparation , stepSize , stepSize ) ) ; } } } private void warnAboutFloatingPointError ( ) { if ( stepSize == <NUM_LIT> ) { return ; } if ( ( int ) stepSize != stepSize ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , stepSize ) ) ; } if ( ( int ) valueFrom != valueFrom ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , valueFrom ) ) ; } if ( ( int ) valueTo != valueTo ) { Log . w ( TAG , String . format ( WARNING_FLOATING_POINT_ERROR , "<STR_LIT>" , valueTo ) ) ; } } private void validateConfigurationIfDirty ( ) { if ( dirtyConfig ) { validateValueFrom ( ) ; validateValueTo ( ) ; validateStepSize ( ) ; validateValues ( ) ; validateMinSeparation ( ) ; warnAboutFloatingPointError ( ) ; dirtyConfig = false ; } } public float getValueFrom ( ) { return valueFrom ; } public void setValueFrom ( float valueFrom ) { this . valueFrom = valueFrom ; dirtyConfig = true ; postInvalidate ( ) ; } public float getValueTo ( ) { return valueTo ; } public void setValueTo ( float valueTo ) { this . valueTo = valueTo ; dirtyConfig = true ; postInvalidate ( ) ; } @ NonNull List < Float > getValues ( ) { return new ArrayList < > ( values ) ; } void setValues ( @ NonNull Float ... values ) { ArrayList < Float > list = new ArrayList < > ( ) ; Collections . addAll ( list , values ) ; setValuesInternal ( list ) ; } void setValues ( @ NonNull List < Float > values ) { setValuesInternal ( new ArrayList < > ( values ) ) ; } private void setValuesInternal ( @ NonNull ArrayList < Float > values ) { if ( values . isEmpty ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } Collections . sort ( values ) ; if ( this . values . size ( ) == values . size ( ) ) { if ( this . values . equals ( values ) ) { return ; } } this . values = values ; dirtyConfig = true ; focusedThumbIdx = <NUM_LIT> ; updateHaloHotspot ( ) ; createLabelPool ( ) ; dispatchOnChangedProgrammatically ( ) ; postInvalidate ( ) ; } private void createLabelPool ( ) { if ( labels . size ( ) > values . size ( ) ) { List < TooltipDrawable > tooltipDrawables = labels . subList ( values . size ( ) , labels . size ( ) ) ; for ( TooltipDrawable label : tooltipDrawables ) { if ( ViewCompat . isAttachedToWindow ( this ) ) { detachLabelFromContentView ( label ) ; } } tooltipDrawables . clear ( ) ; } while ( labels . size ( ) < values . size ( ) ) { TooltipDrawable tooltipDrawable = TooltipDrawable . createFromAttributes ( getContext ( ) , null , <NUM_LIT> , labelStyle ) ; labels . add ( tooltipDrawable ) ; if ( ViewCompat . isAttachedToWindow ( this ) ) { attachLabelToContentView ( tooltipDrawable ) ; } } int strokeWidth = labels . size ( ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; for ( TooltipDrawable label : labels ) { label . setStrokeWidth ( strokeWidth ) ; } } public float getStepSize ( ) { return stepSize ; } public void setStepSize ( float stepSize ) { if ( stepSize < <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( EXCEPTION_ILLEGAL_STEP_SIZE , stepSize , valueFrom , valueTo ) ) ; } if ( this . stepSize != stepSize ) { this . stepSize = stepSize ; dirtyConfig = true ; postInvalidate ( ) ; } } void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { setCustomThumbDrawable ( getResources ( ) . getDrawable ( drawableResId ) ) ; } void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { customThumbDrawable = initializeCustomThumbDrawable ( drawable ) ; customThumbDrawablesForValues . clear ( ) ; postInvalidate ( ) ; } void setCustomThumbDrawablesForValues ( @ NonNull @ DrawableRes int ... customThumbDrawableResIds ) { Drawable [ ] customThumbDrawables = new Drawable [ customThumbDrawableResIds . length ] ; for ( int i = <NUM_LIT> ; i < customThumbDrawableResIds . length ; i ++ ) { customThumbDrawables [ i ] = getResources ( ) . getDrawable ( customThumbDrawableResIds [ i ] ) ; } setCustomThumbDrawablesForValues ( customThumbDrawables ) ; } void setCustomThumbDrawablesForValues ( @ NonNull Drawable ... customThumbDrawables ) { this . customThumbDrawable = null ; this . customThumbDrawablesForValues = new ArrayList < > ( ) ; for ( Drawable originalDrawable : customThumbDrawables ) { this . customThumbDrawablesForValues . add ( initializeCustomThumbDrawable ( originalDrawable ) ) ; } postInvalidate ( ) ; } private Drawable initializeCustomThumbDrawable ( Drawable originalDrawable ) { Drawable drawable = originalDrawable . mutate ( ) . getConstantState ( ) . newDrawable ( ) ; adjustCustomThumbDrawableBounds ( drawable ) ; return drawable ; } private void adjustCustomThumbDrawableBounds ( Drawable drawable ) { int thumbDiameter = thumbRadius * <NUM_LIT> ; int originalWidth = drawable . getIntrinsicWidth ( ) ; int originalHeight = drawable . getIntrinsicHeight ( ) ; if ( originalWidth == - <NUM_LIT> && originalHeight == - <NUM_LIT> ) { drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , thumbDiameter , thumbDiameter ) ; } else { float scaleRatio = ( float ) thumbDiameter / max ( originalWidth , originalHeight ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( originalWidth * scaleRatio ) , ( int ) ( originalHeight * scaleRatio ) ) ; } } public int getFocusedThumbIndex ( ) { return focusedThumbIdx ; } public void setFocusedThumbIndex ( int index ) { if ( index < <NUM_LIT> || index >= values . size ( ) ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } focusedThumbIdx = index ; accessibilityHelper . requestKeyboardFocusForVirtualView ( focusedThumbIdx ) ; postInvalidate ( ) ; } public int getActiveThumbIndex ( ) { return activeThumbIdx ; } protected void setActiveThumbIndex ( int index ) { activeThumbIdx = index ; } public void addOnChangeListener ( @ NonNull L listener ) { changeListeners . add ( listener ) ; } public void removeOnChangeListener ( @ NonNull L listener ) { changeListeners . remove ( listener ) ; } public void clearOnChangeListeners ( ) { changeListeners . clear ( ) ; } public void addOnSliderTouchListener ( @ NonNull T listener ) { touchListeners . add ( listener ) ; } public void removeOnSliderTouchListener ( @ NonNull T listener ) { touchListeners . remove ( listener ) ; } public void clearOnSliderTouchListeners ( ) { touchListeners . clear ( ) ; } public boolean hasLabelFormatter ( ) { return formatter != null ; } public void setLabelFormatter ( @ Nullable LabelFormatter formatter ) { this . formatter = formatter ; } public float getThumbElevation ( ) { return defaultThumbDrawable . getElevation ( ) ; } public void setThumbElevation ( float elevation ) { defaultThumbDrawable . setElevation ( elevation ) ; } public void setThumbElevationResource ( @ DimenRes int elevation ) { setThumbElevation ( getResources ( ) . getDimension ( elevation ) ) ; } @ Dimension public int getThumbRadius ( ) { return thumbRadius ; } public void setThumbRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int radius ) { if ( radius == thumbRadius ) { return ; } thumbRadius = radius ; defaultThumbDrawable . setShapeAppearanceModel ( ShapeAppearanceModel . builder ( ) . setAllCorners ( CornerFamily . ROUNDED , thumbRadius ) . build ( ) ) ; defaultThumbDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , thumbRadius * <NUM_LIT> , thumbRadius * <NUM_LIT> ) ; if ( customThumbDrawable != null ) { adjustCustomThumbDrawableBounds ( customThumbDrawable ) ; } for ( Drawable customDrawable : customThumbDrawablesForValues ) { adjustCustomThumbDrawableBounds ( customDrawable ) ; } updateWidgetLayout ( ) ; } public void setThumbRadiusResource ( @ DimenRes int radius ) { setThumbRadius ( getResources ( ) . getDimensionPixelSize ( radius ) ) ; } public void setThumbStrokeColorResource ( @ ColorRes int thumbStrokeColorResourceId ) { if ( thumbStrokeColorResourceId != <NUM_LIT> ) { setThumbStrokeColor ( AppCompatResources . getColorStateList ( getContext ( ) , thumbStrokeColorResourceId ) ) ; } } public ColorStateList getThumbStrokeColor ( ) { return defaultThumbDrawable . getStrokeColor ( ) ; } public void setThumbStrokeColor ( @ Nullable ColorStateList thumbStrokeColor ) { defaultThumbDrawable . setStrokeColor ( thumbStrokeColor ) ; postInvalidate ( ) ; } public void setThumbStrokeWidthResource ( @ DimenRes int thumbStrokeWidthResourceId ) { if ( thumbStrokeWidthResourceId != <NUM_LIT> ) { setThumbStrokeWidth ( getResources ( ) . getDimension ( thumbStrokeWidthResourceId ) ) ; } } public float getThumbStrokeWidth ( ) { return defaultThumbDrawable . getStrokeWidth ( ) ; } public void setThumbStrokeWidth ( float thumbStrokeWidth ) { defaultThumbDrawable . setStrokeWidth ( thumbStrokeWidth ) ; postInvalidate ( ) ; } @ Dimension ( ) public int getHaloRadius ( ) { return haloRadius ; } public void setHaloRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int radius ) { if ( radius == haloRadius ) { return ; } haloRadius = radius ; Drawable background = getBackground ( ) ; if ( ! shouldDrawCompatHalo ( ) && background instanceof RippleDrawable ) { DrawableUtils . setRippleDrawableRadius ( ( RippleDrawable ) background , haloRadius ) ; return ; } postInvalidate ( ) ; } public void setHaloRadiusResource ( @ DimenRes int radius ) { setHaloRadius ( getResources ( ) . getDimensionPixelSize ( radius ) ) ; } @ LabelBehavior public int getLabelBehavior ( ) { return labelBehavior ; } public void setLabelBehavior ( @ LabelBehavior int labelBehavior ) { if ( this . labelBehavior != labelBehavior ) { this . labelBehavior = labelBehavior ; requestLayout ( ) ; } } private boolean shouldAlwaysShowLabel ( ) { return this . labelBehavior == LABEL_VISIBLE ; } @ Dimension ( ) public int getTrackSidePadding ( ) { return trackSidePadding ; } @ Dimension ( ) public int getTrackWidth ( ) { return trackWidth ; } @ Dimension ( ) public int getTrackHeight ( ) { return trackHeight ; } public void setTrackHeight ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int trackHeight ) { if ( this . trackHeight != trackHeight ) { this . trackHeight = trackHeight ; invalidateTrack ( ) ; updateWidgetLayout ( ) ; } } private void updateTrackBound ( ) { int yCenter = calculateTrackCenter ( ) ; boundRectF . set ( trackSidePadding , yCenter - trackHeight / <NUM_LIT> , trackSidePadding + trackWidth , yCenter + trackHeight / <NUM_LIT> ) ; boundPath . addRoundRect ( boundRectF , trackHeight / <NUM_LIT> , trackHeight / <NUM_LIT> , Path . Direction . CW ) ; } @ Dimension ( ) public int getTickActiveRadius ( ) { return tickActiveRadius ; } public void setTickActiveRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int tickActiveRadius ) { if ( this . tickActiveRadius != tickActiveRadius ) { this . tickActiveRadius = tickActiveRadius ; activeTicksPaint . setStrokeWidth ( tickActiveRadius * <NUM_LIT> ) ; updateWidgetLayout ( ) ; } } @ Dimension ( ) public int getTickInactiveRadius ( ) { return tickInactiveRadius ; } public void setTickInactiveRadius ( @ IntRange ( from = <NUM_LIT> ) @ Dimension int tickInactiveRadius ) { if ( this . tickInactiveRadius != tickInactiveRadius ) { this . tickInactiveRadius = tickInactiveRadius ; inactiveTicksPaint . setStrokeWidth ( tickInactiveRadius * <NUM_LIT> ) ; updateWidgetLayout ( ) ; } } private void updateWidgetLayout ( ) { boolean sizeChanged = maybeIncreaseWidgetHeight ( ) ; boolean sidePaddingChanged = maybeIncreaseTrackSidePadding ( ) ; if ( sizeChanged ) { requestLayout ( ) ; } else if ( sidePaddingChanged ) { postInvalidate ( ) ; } } private boolean maybeIncreaseWidgetHeight ( ) { int topAndBottomPaddings = getPaddingTop ( ) + getPaddingBottom ( ) ; int minHeightRequiredByTrack = trackHeight + topAndBottomPaddings ; int minHeightRequiredByThumb = thumbRadius * <NUM_LIT> + getPaddingTop ( ) + getPaddingBottom ( ) ; int newWidgetHeight = max ( minWidgetHeight , max ( minHeightRequiredByTrack , minHeightRequiredByThumb ) ) ; if ( newWidgetHeight == widgetHeight ) { return false ; } widgetHeight = newWidgetHeight ; return true ; } @ NonNull public ColorStateList getHaloTintList ( ) { return haloColor ; } public void setHaloTintList ( @ NonNull ColorStateList haloColor ) { if ( haloColor . equals ( this . haloColor ) ) { return ; } this . haloColor = haloColor ; Drawable background = getBackground ( ) ; if ( ! shouldDrawCompatHalo ( ) && background instanceof RippleDrawable ) { ( ( RippleDrawable ) background ) . setColor ( haloColor ) ; return ; } haloPaint . setColor ( getColorForState ( haloColor ) ) ; haloPaint . setAlpha ( HALO_ALPHA ) ; invalidate ( ) ; } @ NonNull public ColorStateList getThumbTintList ( ) { return defaultThumbDrawable . getFillColor ( ) ; } public void setThumbTintList ( @ NonNull ColorStateList thumbColor ) { if ( thumbColor . equals ( defaultThumbDrawable . getFillColor ( ) ) ) { return ; } defaultThumbDrawable . setFillColor ( thumbColor ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTickTintList ( ) { if ( ! tickColorInactive . equals ( tickColorActive ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return tickColorActive ; } public void setTickTintList ( @ NonNull ColorStateList tickColor ) { setTickInactiveTintList ( tickColor ) ; setTickActiveTintList ( tickColor ) ; } @ NonNull public ColorStateList getTickActiveTintList ( ) { return tickColorActive ; } public void setTickActiveTintList ( @ NonNull ColorStateList tickColor ) { if ( tickColor . equals ( tickColorActive ) ) { return ; } tickColorActive = tickColor ; activeTicksPaint . setColor ( getColorForState ( tickColorActive ) ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTickInactiveTintList ( ) { return tickColorInactive ; } public void setTickInactiveTintList ( @ NonNull ColorStateList tickColor ) { if ( tickColor . equals ( tickColorInactive ) ) { return ; } tickColorInactive = tickColor ; inactiveTicksPaint . setColor ( getColorForState ( tickColorInactive ) ) ; invalidate ( ) ; } public boolean isTickVisible ( ) { return tickVisible ; } public void setTickVisible ( boolean tickVisible ) { if ( this . tickVisible != tickVisible ) { this . tickVisible = tickVisible ; postInvalidate ( ) ; } } @ NonNull public ColorStateList getTrackTintList ( ) { if ( ! trackColorInactive . equals ( trackColorActive ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return trackColorActive ; } public void setTrackTintList ( @ NonNull ColorStateList trackColor ) { setTrackInactiveTintList ( trackColor ) ; setTrackActiveTintList ( trackColor ) ; } @ NonNull public ColorStateList getTrackActiveTintList ( ) { return trackColorActive ; } public void setTrackActiveTintList ( @ NonNull ColorStateList trackColor ) { if ( trackColor . equals ( trackColorActive ) ) { return ; } trackColorActive = trackColor ; activeTrackPaint . setColor ( getColorForState ( trackColorActive ) ) ; invalidate ( ) ; } @ NonNull public ColorStateList getTrackInactiveTintList ( ) { return trackColorInactive ; } public void setTrackInactiveTintList ( @ NonNull ColorStateList trackColor ) { if ( trackColor . equals ( trackColorInactive ) ) { return ; } trackColorInactive = trackColor ; inactiveTrackPaint . setColor ( getColorForState ( trackColorInactive ) ) ; invalidate ( ) ; } public void setTrackColorInactiveOverlay ( @ ColorInt int color ) { inactiveTrackPaintUnder . setColor ( color ) ; invalidate ( ) ; } public void setTrackColorActiveOverlay ( @ ColorInt int color ) { activeTrackPaintUnder . setColor ( color ) ; invalidate ( ) ; } @ Override protected void onVisibilityChanged ( @ NonNull View changedView , int visibility ) { super . onVisibilityChanged ( changedView , visibility ) ; if ( visibility != VISIBLE ) { ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( this ) ; if ( contentViewOverlay == null ) { return ; } for ( TooltipDrawable label : labels ) { contentViewOverlay . remove ( label ) ; } } } @ Override public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; setLayerType ( enabled ? LAYER_TYPE_NONE : LAYER_TYPE_HARDWARE , null ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; for ( TooltipDrawable label : labels ) { attachLabelToContentView ( label ) ; } } private void attachLabelToContentView ( TooltipDrawable label ) { label . setRelativeToView ( ViewUtils . getContentView ( this ) ) ; } @ Override protected void onDetachedFromWindow ( ) { if ( accessibilityEventSender != null ) { removeCallbacks ( accessibilityEventSender ) ; } labelsAreAnimatedIn = false ; for ( TooltipDrawable label : labels ) { detachLabelFromContentView ( label ) ; } super . onDetachedFromWindow ( ) ; } private void detachLabelFromContentView ( TooltipDrawable label ) { ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( this ) ; if ( contentViewOverlay != null ) { contentViewOverlay . remove ( label ) ; label . detachView ( ViewUtils . getContentView ( this ) ) ; } } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( widgetHeight + ( labelBehavior == LABEL_WITHIN_BOUNDS || shouldAlwaysShowLabel ( ) ? labels . get ( <NUM_LIT> ) . getIntrinsicHeight ( ) : <NUM_LIT> ) , MeasureSpec . EXACTLY ) ) ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { updateTrackWidth ( w ) ; updateHaloHotspot ( ) ; } private void maybeCalculateTicksCoordinates ( ) { if ( stepSize <= <NUM_LIT> ) { return ; } validateConfigurationIfDirty ( ) ; int tickCount = ( int ) ( ( valueTo - valueFrom ) / stepSize + <NUM_LIT> ) ; tickCount = min ( tickCount , trackWidth / ( trackHeight * <NUM_LIT> ) + <NUM_LIT> ) ; if ( ticksCoordinates == null || ticksCoordinates . length != tickCount * <NUM_LIT> ) { ticksCoordinates = new float [ tickCount * <NUM_LIT> ] ; } float interval = trackWidth / ( float ) ( tickCount - <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < tickCount * <NUM_LIT> ; i += <NUM_LIT> ) { ticksCoordinates [ i ] = trackSidePadding + i / <NUM_LIT> * interval ; ticksCoordinates [ i + <NUM_LIT> ] = calculateTrackCenter ( ) ; } } private void updateTrackWidth ( int width ) { trackWidth = max ( width - trackSidePadding * <NUM_LIT> , <NUM_LIT> ) ; maybeCalculateTicksCoordinates ( ) ; updateTrackBound ( ) ; } private void updateHaloHotspot ( ) { if ( ! shouldDrawCompatHalo ( ) && getMeasuredWidth ( ) > <NUM_LIT> ) { final Drawable background = getBackground ( ) ; if ( background instanceof RippleDrawable ) { int x = ( int ) ( normalizeValue ( values . get ( focusedThumbIdx ) ) * trackWidth + trackSidePadding ) ; int y = calculateTrackCenter ( ) ; DrawableCompat . setHotspotBounds ( background , x - haloRadius , y - haloRadius , x + haloRadius , y + haloRadius ) ; } } } private int calculateTrackCenter ( ) { return widgetHeight / <NUM_LIT> + ( labelBehavior == LABEL_WITHIN_BOUNDS || shouldAlwaysShowLabel ( ) ? labels . get ( <NUM_LIT> ) . getIntrinsicHeight ( ) : <NUM_LIT> ) ; } @ Override protected void onDraw ( @ NonNull Canvas canvas ) { if ( dirtyConfig ) { validateConfigurationIfDirty ( ) ; maybeCalculateTicksCoordinates ( ) ; } super . onDraw ( canvas ) ; int yCenter = calculateTrackCenter ( ) ; canvas . clipPath ( boundPath ) ; drawInactiveTrackOverlay ( canvas , trackWidth , yCenter ) ; drawInactiveTrack ( canvas , trackWidth , yCenter ) ; if ( max ( getValues ( ) ) > valueFrom ) { drawActiveTrackOverlay ( canvas , trackWidth , yCenter ) ; drawActiveTrack ( canvas , trackWidth , yCenter ) ; } maybeDrawTicks ( canvas ) ; if ( ( thumbIsPressed || isFocused ( ) ) && isEnabled ( ) ) { maybeDrawCompatHalo ( canvas , trackWidth , yCenter ) ; } if ( ( activeThumbIdx != - <NUM_LIT> || shouldAlwaysShowLabel ( ) ) && isEnabled ( ) ) { ensureLabelsAdded ( ) ; } else { ensureLabelsRemoved ( ) ; } drawThumbs ( canvas , trackWidth , yCenter ) ; } private float [ ] getActiveRange ( ) { float max = max ( getValues ( ) ) ; float min = min ( getValues ( ) ) ; float left = normalizeValue ( values . size ( ) == <NUM_LIT> ? valueFrom : min ) ; float right = normalizeValue ( max ) ; return isRtl ( ) ? new float [ ] { right , left } : new float [ ] { left , right } ; } private void drawInactiveTrackOverlay ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( right < trackSidePadding + width ) { canvas . drawLine ( right , yCenter , trackSidePadding + width , yCenter , inactiveTrackPaintUnder ) ; } float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( left > trackSidePadding ) { canvas . drawLine ( trackSidePadding , yCenter , left , yCenter , inactiveTrackPaintUnder ) ; } } private void drawInactiveTrack ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( right < trackSidePadding + width ) { canvas . drawLine ( right , yCenter , trackSidePadding + width , yCenter , inactiveTrackPaint ) ; } float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; if ( left > trackSidePadding ) { canvas . drawLine ( trackSidePadding , yCenter , left , yCenter , inactiveTrackPaint ) ; } } private float normalizeValue ( float value ) { float normalized = ( value - valueFrom ) / ( valueTo - valueFrom ) ; if ( isRtl ( ) ) { return <NUM_LIT> - normalized ; } return normalized ; } private void drawActiveTrackOverlay ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; canvas . drawLine ( left , yCenter , right , yCenter , activeTrackPaintUnder ) ; } private void drawActiveTrack ( @ NonNull Canvas canvas , int width , int yCenter ) { float [ ] activeRange = getActiveRange ( ) ; float right = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; float left = trackSidePadding + activeRange [ <NUM_LIT> ] * width ; canvas . drawLine ( left , yCenter , right , yCenter , activeTrackPaint ) ; } private void maybeDrawTicks ( @ NonNull Canvas canvas ) { if ( ! tickVisible || stepSize <= <NUM_LIT> ) { return ; } float [ ] activeRange = getActiveRange ( ) ; int leftPivotIndex = pivotIndex ( ticksCoordinates , activeRange [ <NUM_LIT> ] ) ; int rightPivotIndex = pivotIndex ( ticksCoordinates , activeRange [ <NUM_LIT> ] ) ; canvas . drawPoints ( ticksCoordinates , <NUM_LIT> , leftPivotIndex * <NUM_LIT> , inactiveTicksPaint ) ; canvas . drawPoints ( ticksCoordinates , leftPivotIndex * <NUM_LIT> , rightPivotIndex * <NUM_LIT> - leftPivotIndex * <NUM_LIT> , activeTicksPaint ) ; canvas . drawPoints ( ticksCoordinates , rightPivotIndex * <NUM_LIT> , ticksCoordinates . length - rightPivotIndex * <NUM_LIT> , inactiveTicksPaint ) ; } private void drawThumbs ( @ NonNull Canvas canvas , int width , int yCenter ) { for ( int i = <NUM_LIT> ; i < values . size ( ) ; i ++ ) { float value = values . get ( i ) ; if ( customThumbDrawable != null ) { drawThumbDrawable ( canvas , width , yCenter , value , customThumbDrawable ) ; } else if ( i < customThumbDrawablesForValues . size ( ) ) { drawThumbDrawable ( canvas , width , yCenter , value , customThumbDrawablesForValues . get ( i ) ) ; } else { if ( ! isEnabled ( ) ) { canvas . drawCircle ( trackSidePadding + normalizeValue ( value ) * width , yCenter , thumbRadius , thumbPaint ) ; } drawThumbDrawable ( canvas , width , yCenter , value , defaultThumbDrawable ) ; } } } private void drawThumbDrawable ( @ NonNull Canvas canvas , int width , int top , float value , @ NonNull Drawable thumbDrawable ) { canvas . save ( ) ; canvas . translate ( trackSidePadding + ( int ) ( normalizeValue ( value ) * width ) - ( thumbDrawable . getBounds ( ) . width ( ) / <NUM_LIT> ) , top - ( thumbDrawable . getBounds ( ) . height ( ) / <NUM_LIT> ) ) ; thumbDrawable . draw ( canvas ) ; canvas . restore ( ) ; } private void maybeDrawCompatHalo ( @ NonNull Canvas canvas , int width , int top ) { if ( shouldDrawCompatHalo ( ) ) { int centerX = ( int ) ( trackSidePadding + normalizeValue ( values . get ( focusedThumbIdx ) ) * width ) ; if ( VERSION . SDK_INT < VERSION_CODES . P ) { canvas . clipRect ( centerX - haloRadius , top - haloRadius , centerX + haloRadius , top + haloRadius , Op . UNION ) ; } canvas . drawCircle ( centerX , top , haloRadius , haloPaint ) ; } } private boolean shouldDrawCompatHalo ( ) { return forceDrawCompatHalo || VERSION . SDK_INT < VERSION_CODES . LOLLIPOP || ! ( getBackground ( ) instanceof RippleDrawable ) ; } @ Override public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! isEnabled ( ) ) { return false ; } float x = event . getX ( ) ; touchPosition = ( x - trackSidePadding ) / trackWidth ; touchPosition = max ( <NUM_LIT> , touchPosition ) ; touchPosition = min ( <NUM_LIT> , touchPosition ) ; switch ( event . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : touchDownX = x ; if ( isPotentialVerticalScroll ( event ) ) { break ; } getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; if ( ! pickActiveThumb ( ) ) { break ; } requestFocus ( ) ; thumbIsPressed = true ; snapTouchPosition ( ) ; updateHaloHotspot ( ) ; invalidate ( ) ; onStartTrackingTouch ( ) ; break ; case MotionEvent . ACTION_MOVE : if ( ! thumbIsPressed ) { if ( isPotentialVerticalScroll ( event ) && abs ( x - touchDownX ) < scaledTouchSlop ) { return false ; } getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; onStartTrackingTouch ( ) ; } if ( ! pickActiveThumb ( ) ) { break ; } thumbIsPressed = true ; snapTouchPosition ( ) ; updateHaloHotspot ( ) ; invalidate ( ) ; break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : thumbIsPressed = false ; if ( lastEvent != null && lastEvent . getActionMasked ( ) == MotionEvent . ACTION_DOWN && abs ( lastEvent . getX ( ) - event . getX ( ) ) <= scaledTouchSlop && abs ( lastEvent . getY ( ) - event . getY ( ) ) <= scaledTouchSlop ) { if ( pickActiveThumb ( ) ) { onStartTrackingTouch ( ) ; } } if ( activeThumbIdx != - <NUM_LIT> ) { snapTouchPosition ( ) ; updateHaloHotspot ( ) ; activeThumbIdx = - <NUM_LIT> ; onStopTrackingTouch ( ) ; } invalidate ( ) ; break ; default : } setPressed ( thumbIsPressed ) ; lastEvent = MotionEvent . obtain ( event ) ; return true ; } private double snapPosition ( float position ) { if ( stepSize > <NUM_LIT> ) { int stepCount = ( int ) ( ( valueTo - valueFrom ) / stepSize ) ; return Math . round ( position * stepCount ) / ( double ) stepCount ; } return position ; } protected boolean pickActiveThumb ( ) { if ( activeThumbIdx != - <NUM_LIT> ) { return true ; } float touchValue = getValueOfTouchPositionAbsolute ( ) ; float touchX = valueToX ( touchValue ) ; activeThumbIdx = <NUM_LIT> ; float activeThumbDiff = abs ( values . get ( activeThumbIdx ) - touchValue ) ; for ( int i = <NUM_LIT> ; i < values . size ( ) ; i ++ ) { float valueDiff = abs ( values . get ( i ) - touchValue ) ; float valueX = valueToX ( values . get ( i ) ) ; if ( compare ( valueDiff , activeThumbDiff ) > <NUM_LIT> ) { break ; } boolean movingForward = isRtl ( ) ? ( valueX - touchX ) > <NUM_LIT> : ( valueX - touchX ) < <NUM_LIT> ; if ( compare ( valueDiff , activeThumbDiff ) < <NUM_LIT> ) { activeThumbDiff = valueDiff ; activeThumbIdx = i ; continue ; } if ( compare ( valueDiff , activeThumbDiff ) == <NUM_LIT> ) { if ( abs ( valueX - touchX ) < scaledTouchSlop ) { activeThumbIdx = - <NUM_LIT> ; return false ; } if ( movingForward ) { activeThumbDiff = valueDiff ; activeThumbIdx = i ; } } } return activeThumbIdx != - <NUM_LIT> ; } private float getValueOfTouchPositionAbsolute ( ) { float position = touchPosition ; if ( isRtl ( ) ) { position = <NUM_LIT> - position ; } return ( position * ( valueTo - valueFrom ) + valueFrom ) ; } private boolean snapTouchPosition ( ) { return snapActiveThumbToValue ( getValueOfTouchPosition ( ) ) ; } private boolean snapActiveThumbToValue ( float value ) { return snapThumbToValue ( activeThumbIdx , value ) ; } private boolean snapThumbToValue ( int idx , float value ) { focusedThumbIdx = idx ; if ( abs ( value - values . get ( idx ) ) < THRESHOLD ) { return false ; } float newValue = getClampedValue ( idx , value ) ; values . set ( idx , newValue ) ; dispatchOnChangedFromUser ( idx ) ; return true ; } private float getClampedValue ( int idx , float value ) { float minSeparation = getMinSeparation ( ) ; minSeparation = separationUnit == UNIT_PX ? dimenToValue ( minSeparation ) : minSeparation ; if ( isRtl ( ) ) { minSeparation = - minSeparation ; } float upperBound = idx + <NUM_LIT> >= values . size ( ) ? valueTo : values . get ( idx + <NUM_LIT> ) - minSeparation ; float lowerBound = idx - <NUM_LIT> < <NUM_LIT> ? valueFrom : values . get ( idx - <NUM_LIT> ) + minSeparation ; return clamp ( value , lowerBound , upperBound ) ; } private float dimenToValue ( float dimen ) { if ( dimen == <NUM_LIT> ) { return <NUM_LIT> ; } return ( ( dimen - trackSidePadding ) / trackWidth ) * ( valueFrom - valueTo ) + valueFrom ; } protected void setSeparationUnit ( int separationUnit ) { this . separationUnit = separationUnit ; dirtyConfig = true ; postInvalidate ( ) ; } protected float getMinSeparation ( ) { return <NUM_LIT> ; } private float getValueOfTouchPosition ( ) { double position = snapPosition ( touchPosition ) ; if ( isRtl ( ) ) { position = <NUM_LIT> - position ; } return ( float ) ( position * ( valueTo - valueFrom ) + valueFrom ) ; } private float valueToX ( float value ) { return normalizeValue ( value ) * trackWidth + trackSidePadding ; } private ValueAnimator createLabelAnimator ( boolean enter ) { float startFraction = enter ? <NUM_LIT> : <NUM_LIT> ; startFraction = getAnimatorCurrentValueOrDefault ( enter ? labelsOutAnimator : labelsInAnimator , startFraction ) ; float endFraction = enter ? <NUM_LIT> : <NUM_LIT> ; ValueAnimator animator = ValueAnimator . ofFloat ( startFraction , endFraction ) ; int duration ; TimeInterpolator interpolator ; if ( enter ) { duration = MotionUtils . resolveThemeDuration ( getContext ( ) , LABEL_ANIMATION_ENTER_DURATION_ATTR , DEFAULT_LABEL_ANIMATION_ENTER_DURATION ) ; interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , LABEL_ANIMATION_ENTER_EASING_ATTR , AnimationUtils . DECELERATE_INTERPOLATOR ) ; } else { duration = MotionUtils . resolveThemeDuration ( getContext ( ) , LABEL_ANIMATION_EXIT_DURATION_ATTR , DEFAULT_LABEL_ANIMATION_EXIT_DURATION ) ; interpolator = MotionUtils . resolveThemeInterpolator ( getContext ( ) , LABEL_ANIMATION_EXIT_EASING_ATTR , AnimationUtils . FAST_OUT_LINEAR_IN_INTERPOLATOR ) ; } animator . setDuration ( duration ) ; animator . setInterpolator ( interpolator ) ; animator . addUpdateListener ( new AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { float fraction = ( float ) animation . getAnimatedValue ( ) ; for ( TooltipDrawable label : labels ) { label . setRevealFraction ( fraction ) ; } ViewCompat . postInvalidateOnAnimation ( BaseOverlaySlider . this ) ; } } ) ; return animator ; } private void ensureLabelsRemoved ( ) { if ( labelsAreAnimatedIn ) { labelsAreAnimatedIn = false ; labelsOutAnimator = createLabelAnimator ( false ) ; labelsInAnimator = null ; labelsOutAnimator . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { super . onAnimationEnd ( animation ) ; ViewOverlayImpl contentViewOverlay = ViewUtils . getContentViewOverlay ( BaseOverlaySlider . this ) ; for ( TooltipDrawable label : labels ) { contentViewOverlay . remove ( label ) ; } } } ) ; labelsOutAnimator . start ( ) ; } } private void ensureLabelsAdded ( ) { if ( labelBehavior == LABEL_GONE ) { return ; } if ( ! labelsAreAnimatedIn ) { labelsAreAnimatedIn = true ; labelsInAnimator = createLabelAnimator ( true ) ; labelsOutAnimator = null ; labelsInAnimator . start ( ) ; } Iterator < TooltipDrawable > labelItr = labels . iterator ( ) ; for ( int i = <NUM_LIT> ; i < values . size ( ) && labelItr . hasNext ( ) ; i ++ ) { if ( i == focusedThumbIdx ) { continue ; } setValueForLabel ( labelItr . next ( ) , values . get ( i ) ) ; } if ( ! labelItr . hasNext ( ) ) { throw new IllegalStateException ( String . format ( "<STR_LIT>" , labels . size ( ) , values . size ( ) ) ) ; } setValueForLabel ( labelItr . next ( ) , values . get ( focusedThumbIdx ) ) ; } private String formatValue ( float value ) { if ( hasLabelFormatter ( ) ) { return formatter . getFormattedValue ( value ) ; } return String . format ( ( int ) value == value ? "<STR_LIT>" : "<STR_LIT>" , value ) ; } private void setValueForLabel ( TooltipDrawable label , float value ) { label . setText ( formatValue ( value ) ) ; int left = trackSidePadding + ( int ) ( normalizeValue ( value ) * trackWidth ) - label . getIntrinsicWidth ( ) / <NUM_LIT> ; int top = calculateTrackCenter ( ) - ( labelPadding + thumbRadius ) ; label . setBounds ( left , top - label . getIntrinsicHeight ( ) , left + label . getIntrinsicWidth ( ) , top ) ; Rect rect = new Rect ( label . getBounds ( ) ) ; DescendantOffsetUtils . offsetDescendantRect ( ViewUtils . getContentView ( this ) , this , rect ) ; label . setBounds ( rect ) ; ViewUtils . getContentViewOverlay ( this ) . add ( label ) ; } private void invalidateTrack ( ) { activeTrackPaint . setStrokeWidth ( trackHeight ) ; activeTrackPaintUnder . setStrokeWidth ( trackHeight ) ; inactiveTrackPaint . setStrokeWidth ( trackHeight ) ; inactiveTrackPaintUnder . setStrokeWidth ( trackHeight ) ; } private boolean isInVerticalScrollingContainer ( ) { ViewParent p = getParent ( ) ; while ( p instanceof ViewGroup ) { ViewGroup parent = ( ViewGroup ) p ; boolean canScrollVertically = parent . canScrollVertically ( <NUM_LIT> ) || parent . canScrollVertically ( - <NUM_LIT> ) ; if ( canScrollVertically && parent . shouldDelayChildPressedState ( ) ) { return true ; } p = p . getParent ( ) ; } return false ; } private boolean isPotentialVerticalScroll ( MotionEvent event ) { return ! isMouseEvent ( event ) && isInVerticalScrollingContainer ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void dispatchOnChangedProgrammatically ( ) { for ( L listener : changeListeners ) { for ( Float value : values ) { listener . onValueChange ( ( S ) this , value , false ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) private void dispatchOnChangedFromUser ( int idx ) { for ( L listener : changeListeners ) { listener . onValueChange ( ( S ) this , values . get ( idx ) , true ) ; } if ( accessibilityManager != null && accessibilityManager . isEnabled ( ) ) { scheduleAccessibilityEventSender ( idx ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) private void onStartTrackingTouch ( ) { for ( T listener : touchListeners ) { listener . onStartTrackingTouch ( ( S ) this ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) private void onStopTrackingTouch ( ) { for ( T listener : touchListeners ) { listener . onStopTrackingTouch ( ( S ) this ) ; } } @ Override protected void drawableStateChanged ( ) { super . drawableStateChanged ( ) ; inactiveTrackPaint . setColor ( getColorForState ( trackColorInactive ) ) ; activeTrackPaint . setColor ( getColorForState ( trackColorActive ) ) ; inactiveTicksPaint . setColor ( getColorForState ( tickColorInactive ) ) ; activeTicksPaint . setColor ( getColorForState ( tickColorActive ) ) ; for ( TooltipDrawable label : labels ) { if ( label . isStateful ( ) ) { label . setState ( getDrawableState ( ) ) ; } } if ( defaultThumbDrawable . isStateful ( ) ) { defaultThumbDrawable . setState ( getDrawableState ( ) ) ; } haloPaint . setColor ( getColorForState ( haloColor ) ) ; haloPaint . setAlpha ( HALO_ALPHA ) ; } @ ColorInt private int getColorForState ( @ NonNull ColorStateList colorStateList ) { return colorStateList . getColorForState ( getDrawableState ( ) , colorStateList . getDefaultColor ( ) ) ; } @ VisibleForTesting void forceDrawCompatHalo ( boolean force ) { forceDrawCompatHalo = force ; } @ Override public boolean onKeyDown ( int keyCode , @ NonNull KeyEvent event ) { if ( ! isEnabled ( ) ) { return super . onKeyDown ( keyCode , event ) ; } if ( values . size ( ) == <NUM_LIT> ) { activeThumbIdx = <NUM_LIT> ; } if ( activeThumbIdx == - <NUM_LIT> ) { Boolean handled = onKeyDownNoActiveThumb ( keyCode , event ) ; return handled != null ? handled : super . onKeyDown ( keyCode , event ) ; } isLongPress |= event . isLongPress ( ) ; Float increment = calculateIncrementForKey ( keyCode ) ; if ( increment != null ) { if ( snapActiveThumbToValue ( values . get ( activeThumbIdx ) + increment ) ) { updateHaloHotspot ( ) ; postInvalidate ( ) ; } return true ; } switch ( keyCode ) { case KeyEvent . KEYCODE_TAB : if ( event . hasNoModifiers ( ) ) { return moveFocus ( <NUM_LIT> ) ; } if ( event . isShiftPressed ( ) ) { return moveFocus ( - <NUM_LIT> ) ; } return false ; case KeyEvent . KEYCODE_DPAD_CENTER : case KeyEvent . KEYCODE_ENTER : activeThumbIdx = - <NUM_LIT> ; postInvalidate ( ) ; return true ; default : } return super . onKeyDown ( keyCode , event ) ; } @ Nullable private Boolean onKeyDownNoActiveThumb ( int keyCode , @ NonNull KeyEvent event ) { switch ( keyCode ) { case KeyEvent . KEYCODE_TAB : if ( event . hasNoModifiers ( ) ) { return moveFocus ( <NUM_LIT> ) ; } if ( event . isShiftPressed ( ) ) { return moveFocus ( - <NUM_LIT> ) ; } return false ; case KeyEvent . KEYCODE_DPAD_LEFT : moveFocusInAbsoluteDirection ( - <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_MINUS : moveFocus ( - <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_DPAD_RIGHT : moveFocusInAbsoluteDirection ( <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_EQUALS : case KeyEvent . KEYCODE_PLUS : moveFocus ( <NUM_LIT> ) ; return true ; case KeyEvent . KEYCODE_DPAD_CENTER : case KeyEvent . KEYCODE_ENTER : activeThumbIdx = focusedThumbIdx ; postInvalidate ( ) ; return true ; default : } return null ; } @ Override public boolean onKeyUp ( int keyCode , @ NonNull KeyEvent event ) { isLongPress = false ; return super . onKeyUp ( keyCode , event ) ; } final boolean isRtl ( ) { return ViewCompat . getLayoutDirection ( this ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } private boolean moveFocus ( int direction ) { int oldFocusedThumbIdx = focusedThumbIdx ; final long newFocusedThumbIdx = ( long ) oldFocusedThumbIdx + direction ; focusedThumbIdx = ( int ) clamp ( newFocusedThumbIdx , <NUM_LIT> , values . size ( ) - <NUM_LIT> ) ; if ( focusedThumbIdx == oldFocusedThumbIdx ) { return false ; } if ( activeThumbIdx != - <NUM_LIT> ) { activeThumbIdx = focusedThumbIdx ; } updateHaloHotspot ( ) ; postInvalidate ( ) ; return true ; } private boolean moveFocusInAbsoluteDirection ( int direction ) { if ( isRtl ( ) ) { direction = direction == Integer . MIN_VALUE ? Integer . MAX_VALUE : - direction ; } return moveFocus ( direction ) ; } @ Nullable private Float calculateIncrementForKey ( int keyCode ) { float increment = isLongPress ? calculateStepIncrement ( <NUM_LIT> ) : calculateStepIncrement ( ) ; switch ( keyCode ) { case KeyEvent . KEYCODE_DPAD_LEFT : return isRtl ( ) ? increment : - increment ; case KeyEvent . KEYCODE_DPAD_RIGHT : return isRtl ( ) ? - increment : increment ; case KeyEvent . KEYCODE_MINUS : return - increment ; case KeyEvent . KEYCODE_EQUALS : case KeyEvent . KEYCODE_PLUS : return increment ; default : return null ; } } private float calculateStepIncrement ( ) { return stepSize == <NUM_LIT> ? <NUM_LIT> : stepSize ; } private float calculateStepIncrement ( int stepFactor ) { float increment = calculateStepIncrement ( ) ; float numSteps = ( valueTo - valueFrom ) / increment ; if ( numSteps <= stepFactor ) { return increment ; } return Math . round ( ( numSteps / stepFactor ) ) * increment ; } @ Override protected void onFocusChanged ( boolean gainFocus , int direction , @ Nullable Rect previouslyFocusedRect ) { super . onFocusChanged ( gainFocus , direction , previouslyFocusedRect ) ; if ( ! gainFocus ) { activeThumbIdx = - <NUM_LIT> ; accessibilityHelper . clearKeyboardFocusForVirtualView ( focusedThumbIdx ) ; } else { focusThumbOnFocusGained ( direction ) ; accessibilityHelper . requestKeyboardFocusForVirtualView ( focusedThumbIdx ) ; } } private void focusThumbOnFocusGained ( int direction ) { switch ( direction ) { case FOCUS_BACKWARD : moveFocus ( Integer . MAX_VALUE ) ; break ; case FOCUS_LEFT : moveFocusInAbsoluteDirection ( Integer . MAX_VALUE ) ; break ; case FOCUS_FORWARD : moveFocus ( Integer . MIN_VALUE ) ; break ; case FOCUS_RIGHT : moveFocusInAbsoluteDirection ( Integer . MIN_VALUE ) ; break ; case FOCUS_UP : case FOCUS_DOWN : default : } } @ VisibleForTesting final int getAccessibilityFocusedVirtualViewId ( ) { return accessibilityHelper . getAccessibilityFocusedVirtualViewId ( ) ; } @ NonNull @ Override public CharSequence getAccessibilityClassName ( ) { return SeekBar . class . getName ( ) ; } @ Override public boolean dispatchHoverEvent ( @ NonNull MotionEvent event ) { return accessibilityHelper . dispatchHoverEvent ( event ) || super . dispatchHoverEvent ( event ) ; } @ Override public boolean dispatchKeyEvent ( @ NonNull KeyEvent event ) { return super . dispatchKeyEvent ( event ) ; } private void scheduleAccessibilityEventSender ( int idx ) { if ( accessibilityEventSender == null ) { accessibilityEventSender = new AccessibilityEventSender ( ) ; } else { removeCallbacks ( accessibilityEventSender ) ; } accessibilityEventSender . setVirtualViewId ( idx ) ; postDelayed ( accessibilityEventSender , TIMEOUT_SEND_ACCESSIBILITY_EVENT ) ; } @ Override protected Parcelable onSaveInstanceState ( ) { Parcelable superState = super . onSaveInstanceState ( ) ; SliderState sliderState = new SliderState ( superState ) ; sliderState . valueFrom = valueFrom ; sliderState . valueTo = valueTo ; sliderState . values = new ArrayList < > ( values ) ; sliderState . stepSize = stepSize ; sliderState . hasFocus = hasFocus ( ) ; return sliderState ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { SliderState sliderState = ( SliderState ) state ; super . onRestoreInstanceState ( sliderState . getSuperState ( ) ) ; valueFrom = sliderState . valueFrom ; valueTo = sliderState . valueTo ; setValuesInternal ( sliderState . values ) ; stepSize = sliderState . stepSize ; if ( sliderState . hasFocus ) { requestFocus ( ) ; } } void updateBoundsForVirtualViewId ( int virtualViewId , Rect virtualViewBounds ) { int x = trackSidePadding + ( int ) ( normalizeValue ( getValues ( ) . get ( virtualViewId ) ) * trackWidth ) ; int y = calculateTrackCenter ( ) ; int touchTargetRadius = ( thumbRadius > minTouchTargetSize ? thumbRadius : minTouchTargetSize ) / <NUM_LIT> ; virtualViewBounds . set ( x - touchTargetRadius , y - touchTargetRadius , x + touchTargetRadius , y + touchTargetRadius ) ; } @ IntDef ( { LABEL_FLOATING , LABEL_WITHIN_BOUNDS , LABEL_GONE , LABEL_VISIBLE } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface LabelBehavior { } @ IntDef ( { UNIT_PX , UNIT_VALUE } ) @ Retention ( RetentionPolicy . SOURCE ) @ interface SeparationUnit { } static class SliderState extends BaseSavedState { public static final Creator < SliderState > CREATOR = new Creator < SliderState > ( ) { @ NonNull @ Override public SliderState createFromParcel ( @ NonNull Parcel source ) { return new SliderState ( source ) ; } @ NonNull @ Override public SliderState [ ] newArray ( int size ) { return new SliderState [ size ] ; } } ; float valueFrom ; float valueTo ; ArrayList < Float > values ; float stepSize ; boolean hasFocus ; SliderState ( Parcelable superState ) { super ( superState ) ; } private SliderState ( @ NonNull Parcel source ) { super ( source ) ; valueFrom = source . readFloat ( ) ; valueTo = source . readFloat ( ) ; values = new ArrayList < > ( ) ; source . readList ( values , Float . class . getClassLoader ( ) ) ; stepSize = source . readFloat ( ) ; hasFocus = source . createBooleanArray ( ) [ <NUM_LIT> ] ; } @ Override public void writeToParcel ( @ NonNull Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeFloat ( valueFrom ) ; dest . writeFloat ( valueTo ) ; dest . writeList ( values ) ; dest . writeFloat ( stepSize ) ; boolean [ ] booleans = new boolean [ <NUM_LIT> ] ; booleans [ <NUM_LIT> ] = hasFocus ; dest . writeBooleanArray ( booleans ) ; } } private static class AccessibilityHelper extends ExploreByTouchHelper { final Rect virtualViewBounds = new Rect ( ) ; private final BaseOverlaySlider < ? , ? , ? > slider ; AccessibilityHelper ( BaseOverlaySlider < ? , ? , ? > slider ) { super ( slider ) ; this . slider = slider ; } @ Override protected int getVirtualViewAt ( float x , float y ) { for ( int i = <NUM_LIT> ; i < slider . getValues ( ) . size ( ) ; i ++ ) { slider . updateBoundsForVirtualViewId ( i , virtualViewBounds ) ; if ( virtualViewBounds . contains ( ( int ) x , ( int ) y ) ) { return i ; } } return ExploreByTouchHelper . HOST_ID ; } @ Override protected void getVisibleVirtualViews ( List < Integer > virtualViewIds ) { for ( int i = <NUM_LIT> ; i < slider . getValues ( ) . size ( ) ; i ++ ) { virtualViewIds . add ( i ) ; } } @ Override protected void onPopulateNodeForVirtualView ( int virtualViewId , AccessibilityNodeInfoCompat info ) { info . addAction ( AccessibilityNodeInfoCompat . AccessibilityActionCompat . ACTION_SET_PROGRESS ) ; List < Float > values = slider . getValues ( ) ; final float value = values . get ( virtualViewId ) ; float valueFrom = slider . getValueFrom ( ) ; float valueTo = slider . getValueTo ( ) ; if ( slider . isEnabled ( ) ) { if ( value > valueFrom ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) ; } if ( value < valueTo ) { info . addAction ( AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD ) ; } } info . setRangeInfo ( RangeInfoCompat . obtain ( RANGE_TYPE_FLOAT , valueFrom , valueTo , value ) ) ; info . setClassName ( SeekBar . class . getName ( ) ) ; StringBuilder contentDescription = new StringBuilder ( ) ; if ( slider . getContentDescription ( ) != null ) { contentDescription . append ( slider . getContentDescription ( ) ) . append ( "<STR_LIT>" ) ; } String verbalValue = slider . formatValue ( value ) ; String verbalValueType = slider . getContext ( ) . getString ( R . string . material_slider_value ) ; if ( values . size ( ) > <NUM_LIT> ) { verbalValueType = startOrEndDescription ( virtualViewId ) ; } contentDescription . append ( String . format ( Locale . US , "<STR_LIT>" , verbalValueType , verbalValue ) ) ; info . setContentDescription ( contentDescription . toString ( ) ) ; slider . updateBoundsForVirtualViewId ( virtualViewId , virtualViewBounds ) ; info . setBoundsInParent ( virtualViewBounds ) ; } @ NonNull private String startOrEndDescription ( int virtualViewId ) { List < Float > values = slider . getValues ( ) ; if ( virtualViewId == values . size ( ) - <NUM_LIT> ) { return slider . getContext ( ) . getString ( R . string . material_slider_range_end ) ; } if ( virtualViewId == <NUM_LIT> ) { return slider . getContext ( ) . getString ( R . string . material_slider_range_start ) ; } return "<STR_LIT>" ; } @ Override protected boolean onPerformActionForVirtualView ( int virtualViewId , int action , Bundle arguments ) { if ( ! slider . isEnabled ( ) ) { return false ; } switch ( action ) { case android . R . id . accessibilityActionSetProgress : { if ( arguments == null || ! arguments . containsKey ( AccessibilityNodeInfoCompat . ACTION_ARGUMENT_PROGRESS_VALUE ) ) { return false ; } float value = arguments . getFloat ( AccessibilityNodeInfoCompat . ACTION_ARGUMENT_PROGRESS_VALUE ) ; if ( slider . snapThumbToValue ( virtualViewId , value ) ) { slider . updateHaloHotspot ( ) ; slider . postInvalidate ( ) ; invalidateVirtualView ( virtualViewId ) ; return true ; } return false ; } case AccessibilityNodeInfoCompat . ACTION_SCROLL_FORWARD : case AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD : { float increment = slider . calculateStepIncrement ( <NUM_LIT> ) ; if ( action == AccessibilityNodeInfoCompat . ACTION_SCROLL_BACKWARD ) { increment = - increment ; } if ( slider . isRtl ( ) ) { increment = - increment ; } List < Float > values = slider . getValues ( ) ; float clamped = clamp ( values . get ( virtualViewId ) + increment , slider . getValueFrom ( ) , slider . getValueTo ( ) ) ; if ( slider . snapThumbToValue ( virtualViewId , clamped ) ) { slider . updateHaloHotspot ( ) ; slider . postInvalidate ( ) ; invalidateVirtualView ( virtualViewId ) ; return true ; } return false ; } default : return false ; } } } private class AccessibilityEventSender implements Runnable { int virtualViewId = - <NUM_LIT> ; void setVirtualViewId ( int virtualViewId ) { this . virtualViewId = virtualViewId ; } @ Override public void run ( ) { accessibilityHelper . sendEventForVirtualView ( virtualViewId , AccessibilityEvent . TYPE_VIEW_SELECTED ) ; } } } </s>
<s> package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageSelected ( int position ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageSelected ( position ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageScrollStateChanged ( @ ViewPager2 . ScrollState int state ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrollStateChanged ( state ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } private void throwCallbackListModifiedWhileInUse ( ConcurrentModificationException parent ) { throw new IllegalStateException ( "<STR_LIT>" , parent ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( "<STR_LIT>" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( "<STR_LIT>" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( "<STR_LIT>" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; } if ( oldItem == null && newItem == null ) { return true ; } throw new AssertionError ( ) ; } @ Nullable @ Override public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . getChangePayload ( oldItem , newItem ) ; } throw new AssertionError ( ) ; } } ) ; mMainThreadExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( mMaxScheduledGeneration == runGeneration ) { latchList ( newList , result , commitCallback ) ; } } } ) ; } } ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void latchList ( @ NonNull List < T > newList , @ NonNull DiffUtil . DiffResult diffResult , @ Nullable Runnable commitCallback ) { final List < T > previousList = mReadOnlyList ; mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; diffResult . dispatchUpdatesTo ( mUpdateCallback ) ; onCurrentListChanged ( previousList , commitCallback ) ; } private void onCurrentListChanged ( @ NonNull List < T > previousList , @ Nullable Runnable commitCallback ) { for ( ListListener < T > listener : mListeners ) { listener . onCurrentListChanged ( previousList , mReadOnlyList ) ; } if ( commitCallback != null ) { commitCallback . run ( ) ; } } public void addListListener ( @ NonNull ListListener < T > listener ) { mListeners . add ( listener ) ; } public void removeListListener ( @ NonNull ListListener < T > listener ) { mListeners . remove ( listener ) ; } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ; container . setSaveEnabled ( false ) ; return new FragmentViewHolder ( container ) ; } @ NonNull FrameLayout getContainer ( ) { return ( FrameLayout ) itemView ; } } </s>
<s> package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , "<STR_LIT>" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ; } else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ; ViewParent parentParent = parent . getParent ( ) ; if ( parent instanceof RecyclerView && parentParent instanceof ViewPager2 ) { return ( ViewPager2 ) parentParent ; } throw new IllegalStateException ( "<STR_LIT>" ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = "<STR_LIT>" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( "<STR_LIT>" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ; } if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getLayoutManager ( ) . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int right = mBounds . right + Math . round ( child . getTranslationX ( ) ) ; final int left = right - mDivider . getIntrinsicWidth ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mDivider == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } if ( mOrientation == VERTICAL ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicHeight ( ) ) ; } else { outRect . set ( <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicWidth ( ) , <NUM_LIT> ) ; } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( "<STR_LIT>" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( "<STR_LIT>" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( "<STR_LIT>" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( "<STR_LIT>" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( "<STR_LIT>" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( "<STR_LIT>" + "<STR_LIT>" ) ; } return <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( "<STR_LIT>" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ; final int right = layoutManager . getDecoratedRight ( view ) + params . rightMargin ; final int start = layoutManager . getPaddingLeft ( ) ; final int end = layoutManager . getWidth ( ) - layoutManager . getPaddingRight ( ) ; return calculateDtToFit ( left , right , start , end , snapPreference ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ; } Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ; if ( mLastAccessedTile == tile ) { mLastAccessedTile = null ; } mTiles . delete ( startPosition ) ; return tile ; } public static class Tile < T > { public final T [ ] mItems ; public int mStartPosition ; public int mItemCount ; Tile < T > mNext ; Tile ( @ NonNull Class < T > klass , int size ) { @ SuppressWarnings ( "<STR_LIT>" ) T [ ] items = ( T [ ] ) Array . newInstance ( klass , size ) ; mItems = items ; } boolean containsPosition ( int pos ) { return mStartPosition <= pos && pos < mStartPosition + mItemCount ; } T getByPosition ( int pos ) { return mItems [ pos - mStartPosition ] ; } } } </s>
<s> package androidx . fluidviewpager2 . adapter ; import android . os . Parcelable ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . fluidviewpager2 . widget . ViewPager2 ; public interface StatefulAdapter { @ NonNull Parcelable saveState ( ) ; void restoreState ( @ NonNull Parcelable savedState ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( "<STR_LIT>" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( "<STR_LIT>" , "<STR_LIT>" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( "<STR_LIT>" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( "<STR_LIT>" , "<STR_LIT>" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) { item . next = mRoot ; mRoot = item ; } } void sendMessage ( SyncQueueItem item ) { synchronized ( mLock ) { if ( mRoot == null ) { mRoot = item ; return ; } SyncQueueItem last = mRoot ; while ( last . next != null ) { last = last . next ; } last . next = item ; } } void removeMessages ( int what ) { synchronized ( mLock ) { while ( mRoot != null && mRoot . what == what ) { SyncQueueItem item = mRoot ; mRoot = mRoot . next ; item . recycle ( ) ; } if ( mRoot != null ) { SyncQueueItem prev = mRoot ; SyncQueueItem item = prev . next ; while ( item != null ) { SyncQueueItem next = item . next ; if ( item . what == what ) { prev . next = next ; item . recycle ( ) ; } else { prev = item ; } item = next ; } } } } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . os . Build ; import android . util . Log ; import android . view . GestureDetector ; import android . view . HapticFeedbackConstants ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewParent ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . view . GestureDetectorCompat ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; import androidx . fluidrecyclerview . widget . RecyclerView . OnItemTouchListener ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . ArrayList ; import java . util . List ; public class ItemTouchHelper extends RecyclerView . ItemDecoration implements RecyclerView . OnChildAttachStateChangeListener { public static final int UP = <NUM_LIT> ; public static final int DOWN = <NUM_LIT> << <NUM_LIT> ; public static final int LEFT = <NUM_LIT> << <NUM_LIT> ; public static final int RIGHT = <NUM_LIT> << <NUM_LIT> ; public static final int START = LEFT << <NUM_LIT> ; public static final int END = RIGHT << <NUM_LIT> ; public static final int ACTION_STATE_IDLE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ACTION_STATE_SWIPE = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ACTION_STATE_DRAG = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_SWIPE_SUCCESS = <NUM_LIT> << <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_SWIPE_CANCEL = <NUM_LIT> << <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int ANIMATION_TYPE_DRAG = <NUM_LIT> << <NUM_LIT> ; private static final String TAG = "<STR_LIT>" ; private static final boolean DEBUG = false ; private static final int ACTIVE_POINTER_ID_NONE = - <NUM_LIT> ; static final int DIRECTION_FLAG_COUNT = <NUM_LIT> ; private static final int ACTION_MODE_IDLE_MASK = ( <NUM_LIT> << DIRECTION_FLAG_COUNT ) - <NUM_LIT> ; static final int ACTION_MODE_SWIPE_MASK = ACTION_MODE_IDLE_MASK << DIRECTION_FLAG_COUNT ; static final int ACTION_MODE_DRAG_MASK = ACTION_MODE_SWIPE_MASK << DIRECTION_FLAG_COUNT ; private static final int PIXELS_PER_SECOND = <NUM_LIT> ; final List < View > mPendingCleanup = new ArrayList < > ( ) ; private final float [ ] mTmpPosition = new float [ <NUM_LIT> ] ; @ SuppressWarnings ( "<STR_LIT>" ) ViewHolder mSelected = null ; float mInitialTouchX ; float mInitialTouchY ; private float mSwipeEscapeVelocity ; private float mMaxSwipeVelocity ; float mDx ; float mDy ; private float mSelectedStartX ; private float mSelectedStartY ; @ SuppressWarnings ( "<STR_LIT>" ) int mActivePointerId = ACTIVE_POINTER_ID_NONE ; @ NonNull Callback mCallback ; private int mActionState = ACTION_STATE_IDLE ; @ SuppressWarnings ( "<STR_LIT>" ) int mSelectedFlags ; @ VisibleForTesting List < RecoverAnimation > mRecoverAnimations = new ArrayList < > ( ) ; private int mSlop ; RecyclerView mRecyclerView ; @ SuppressWarnings ( "<STR_LIT>" ) final Runnable mScrollRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( mSelected != null && scrollIfNecessary ( ) ) { if ( mSelected != null ) { moveIfNecessary ( mSelected ) ; } mRecyclerView . removeCallbacks ( mScrollRunnable ) ; ViewCompat . postOnAnimation ( mRecyclerView , this ) ; } } } ; VelocityTracker mVelocityTracker ; private List < ViewHolder > mSwapTargets ; private List < Integer > mDistances ; private RecyclerView . ChildDrawingOrderCallback mChildDrawingOrderCallback = null ; @ SuppressWarnings ( "<STR_LIT>" ) View mOverdrawChild = null ; @ SuppressWarnings ( "<STR_LIT>" ) int mOverdrawChildPosition = - <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) GestureDetectorCompat mGestureDetector ; private ItemTouchHelperGestureListener mItemTouchHelperGestureListener ; private final OnItemTouchListener mOnItemTouchListener = new OnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { mGestureDetector . onTouchEvent ( event ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + event . getX ( ) + "<STR_LIT>" + event . getY ( ) + "<STR_LIT>" + event ) ; } final int action = event . getActionMasked ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { mActivePointerId = event . getPointerId ( <NUM_LIT> ) ; mInitialTouchX = event . getX ( ) ; mInitialTouchY = event . getY ( ) ; obtainVelocityTracker ( ) ; if ( mSelected == null ) { final RecoverAnimation animation = findAnimation ( event ) ; if ( animation != null ) { mInitialTouchX -= animation . mX ; mInitialTouchY -= animation . mY ; endRecoverAnimation ( animation . mViewHolder , true ) ; if ( mPendingCleanup . remove ( animation . mViewHolder . itemView ) ) { mCallback . clearView ( mRecyclerView , animation . mViewHolder ) ; } select ( animation . mViewHolder , animation . mActionState ) ; updateDxDy ( event , mSelectedFlags , <NUM_LIT> ) ; } } } else if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mActivePointerId = ACTIVE_POINTER_ID_NONE ; select ( null , ACTION_STATE_IDLE ) ; } else if ( mActivePointerId != ACTIVE_POINTER_ID_NONE ) { final int index = event . findPointerIndex ( mActivePointerId ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index ) ; } if ( index >= <NUM_LIT> ) { checkSelectForSwipe ( action , event , index ) ; } } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( event ) ; } return mSelected != null ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { mGestureDetector . onTouchEvent ( event ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mInitialTouchX + "<STR_LIT>" + mInitialTouchY + "<STR_LIT>" + event ) ; } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( event ) ; } if ( mActivePointerId == ACTIVE_POINTER_ID_NONE ) { return ; } final int action = event . getActionMasked ( ) ; final int activePointerIndex = event . findPointerIndex ( mActivePointerId ) ; if ( activePointerIndex >= <NUM_LIT> ) { checkSelectForSwipe ( action , event , activePointerIndex ) ; } ViewHolder viewHolder = mSelected ; if ( viewHolder == null ) { return ; } switch ( action ) { case MotionEvent . ACTION_MOVE : { if ( activePointerIndex >= <NUM_LIT> ) { updateDxDy ( event , mSelectedFlags , activePointerIndex ) ; moveIfNecessary ( viewHolder ) ; mRecyclerView . removeCallbacks ( mScrollRunnable ) ; mScrollRunnable . run ( ) ; mRecyclerView . invalidate ( ) ; } break ; } case MotionEvent . ACTION_CANCEL : if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } case MotionEvent . ACTION_UP : select ( null , ACTION_STATE_IDLE ) ; mActivePointerId = ACTIVE_POINTER_ID_NONE ; break ; case MotionEvent . ACTION_POINTER_UP : { final int pointerIndex = event . getActionIndex ( ) ; final int pointerId = event . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mActivePointerId = event . getPointerId ( newPointerIndex ) ; updateDxDy ( event , mSelectedFlags , pointerIndex ) ; } break ; } } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { if ( ! disallowIntercept ) { return ; } select ( null , ACTION_STATE_IDLE ) ; } } ; private Rect mTmpRect ; private long mDragScrollStartTimeInMs ; public ItemTouchHelper ( @ NonNull Callback callback ) { mCallback = callback ; } private static boolean hitTest ( View child , float x , float y , float left , float top ) { return x >= left && x <= left + child . getWidth ( ) && y >= top && y <= top + child . getHeight ( ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( recyclerView != null ) { final Resources resources = recyclerView . getResources ( ) ; mSwipeEscapeVelocity = resources . getDimension ( R . dimen . item_touch_helper_swipe_escape_velocity ) ; mMaxSwipeVelocity = resources . getDimension ( R . dimen . item_touch_helper_swipe_escape_max_velocity ) ; setupCallbacks ( ) ; } } private void setupCallbacks ( ) { ViewConfiguration vc = ViewConfiguration . get ( mRecyclerView . getContext ( ) ) ; mSlop = vc . getScaledTouchSlop ( ) ; mRecyclerView . addItemDecoration ( this ) ; mRecyclerView . addOnItemTouchListener ( mOnItemTouchListener ) ; mRecyclerView . addOnChildAttachStateChangeListener ( this ) ; startGestureDetection ( ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeItemDecoration ( this ) ; mRecyclerView . removeOnItemTouchListener ( mOnItemTouchListener ) ; mRecyclerView . removeOnChildAttachStateChangeListener ( this ) ; final int recoverAnimSize = mRecoverAnimations . size ( ) ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation recoverAnimation = mRecoverAnimations . get ( <NUM_LIT> ) ; recoverAnimation . cancel ( ) ; mCallback . clearView ( mRecyclerView , recoverAnimation . mViewHolder ) ; } mRecoverAnimations . clear ( ) ; mOverdrawChild = null ; mOverdrawChildPosition = - <NUM_LIT> ; releaseVelocityTracker ( ) ; stopGestureDetection ( ) ; } private void startGestureDetection ( ) { mItemTouchHelperGestureListener = new ItemTouchHelperGestureListener ( ) ; mGestureDetector = new GestureDetectorCompat ( mRecyclerView . getContext ( ) , mItemTouchHelperGestureListener ) ; } private void stopGestureDetection ( ) { if ( mItemTouchHelperGestureListener != null ) { mItemTouchHelperGestureListener . doNotReactToLongPress ( ) ; mItemTouchHelperGestureListener = null ; } if ( mGestureDetector != null ) { mGestureDetector = null ; } } private void getSelectedDxDy ( float [ ] outPosition ) { if ( ( mSelectedFlags & ( LEFT | RIGHT ) ) != <NUM_LIT> ) { outPosition [ <NUM_LIT> ] = mSelectedStartX + mDx - mSelected . itemView . getLeft ( ) ; } else { outPosition [ <NUM_LIT> ] = mSelected . itemView . getTranslationX ( ) ; } if ( ( mSelectedFlags & ( UP | DOWN ) ) != <NUM_LIT> ) { outPosition [ <NUM_LIT> ] = mSelectedStartY + mDy - mSelected . itemView . getTop ( ) ; } else { outPosition [ <NUM_LIT> ] = mSelected . itemView . getTranslationY ( ) ; } } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { float dx = <NUM_LIT> , dy = <NUM_LIT> ; if ( mSelected != null ) { getSelectedDxDy ( mTmpPosition ) ; dx = mTmpPosition [ <NUM_LIT> ] ; dy = mTmpPosition [ <NUM_LIT> ] ; } mCallback . onDrawOver ( c , parent , mSelected , mRecoverAnimations , mActionState , dx , dy ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { mOverdrawChildPosition = - <NUM_LIT> ; float dx = <NUM_LIT> , dy = <NUM_LIT> ; if ( mSelected != null ) { getSelectedDxDy ( mTmpPosition ) ; dx = mTmpPosition [ <NUM_LIT> ] ; dy = mTmpPosition [ <NUM_LIT> ] ; } mCallback . onDraw ( c , parent , mSelected , mRecoverAnimations , mActionState , dx , dy ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void select ( @ Nullable ViewHolder selected , int actionState ) { if ( selected == mSelected && actionState == mActionState ) { return ; } mDragScrollStartTimeInMs = Long . MIN_VALUE ; final int prevActionState = mActionState ; endRecoverAnimation ( selected , true ) ; mActionState = actionState ; if ( actionState == ACTION_STATE_DRAG ) { if ( selected == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } mOverdrawChild = selected . itemView ; addChildDrawingOrderCallback ( ) ; } int actionStateMask = ( <NUM_LIT> << ( DIRECTION_FLAG_COUNT + DIRECTION_FLAG_COUNT * actionState ) ) - <NUM_LIT> ; boolean preventLayout = false ; if ( mSelected != null ) { final ViewHolder prevSelected = mSelected ; if ( prevSelected . itemView . getParent ( ) != null ) { final int swipeDir = prevActionState == ACTION_STATE_DRAG ? <NUM_LIT> : swipeIfNecessary ( prevSelected ) ; releaseVelocityTracker ( ) ; final float targetTranslateX , targetTranslateY ; int animationType ; switch ( swipeDir ) { case LEFT : case RIGHT : case START : case END : targetTranslateY = <NUM_LIT> ; targetTranslateX = Math . signum ( mDx ) * mRecyclerView . getWidth ( ) ; break ; case UP : case DOWN : targetTranslateX = <NUM_LIT> ; targetTranslateY = Math . signum ( mDy ) * mRecyclerView . getHeight ( ) ; break ; default : targetTranslateX = <NUM_LIT> ; targetTranslateY = <NUM_LIT> ; } if ( prevActionState == ACTION_STATE_DRAG ) { animationType = ANIMATION_TYPE_DRAG ; } else if ( swipeDir > <NUM_LIT> ) { animationType = ANIMATION_TYPE_SWIPE_SUCCESS ; } else { animationType = ANIMATION_TYPE_SWIPE_CANCEL ; } getSelectedDxDy ( mTmpPosition ) ; final float currentTranslateX = mTmpPosition [ <NUM_LIT> ] ; final float currentTranslateY = mTmpPosition [ <NUM_LIT> ] ; final RecoverAnimation rv = new RecoverAnimation ( prevSelected , animationType , prevActionState , currentTranslateX , currentTranslateY , targetTranslateX , targetTranslateY ) { @ Override public void onAnimationEnd ( Animator animation ) { super . onAnimationEnd ( animation ) ; if ( this . mOverridden ) { return ; } if ( swipeDir <= <NUM_LIT> ) { mCallback . clearView ( mRecyclerView , prevSelected ) ; } else { mPendingCleanup . add ( prevSelected . itemView ) ; mIsPendingCleanup = true ; if ( swipeDir > <NUM_LIT> ) { postDispatchSwipe ( this , swipeDir ) ; } } if ( mOverdrawChild == prevSelected . itemView ) { removeChildDrawingOrderCallbackIfNecessary ( prevSelected . itemView ) ; } } } ; final long duration = mCallback . getAnimationDuration ( mRecyclerView , animationType , targetTranslateX - currentTranslateX , targetTranslateY - currentTranslateY ) ; rv . setDuration ( duration ) ; mRecoverAnimations . add ( rv ) ; rv . start ( ) ; preventLayout = true ; } else { removeChildDrawingOrderCallbackIfNecessary ( prevSelected . itemView ) ; mCallback . clearView ( mRecyclerView , prevSelected ) ; } mSelected = null ; } if ( selected != null ) { mSelectedFlags = ( mCallback . getAbsoluteMovementFlags ( mRecyclerView , selected ) & actionStateMask ) > > ( mActionState * DIRECTION_FLAG_COUNT ) ; mSelectedStartX = selected . itemView . getLeft ( ) ; mSelectedStartY = selected . itemView . getTop ( ) ; mSelected = selected ; if ( actionState == ACTION_STATE_DRAG ) { mSelected . itemView . performHapticFeedback ( HapticFeedbackConstants . LONG_PRESS ) ; } } final ViewParent rvParent = mRecyclerView . getParent ( ) ; if ( rvParent != null ) { rvParent . requestDisallowInterceptTouchEvent ( mSelected != null ) ; } if ( ! preventLayout ) { mRecyclerView . getLayoutManager ( ) . requestSimpleAnimationsInNextLayout ( ) ; } mCallback . onSelectedChanged ( mSelected , mActionState ) ; mRecyclerView . invalidate ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void postDispatchSwipe ( final RecoverAnimation anim , final int swipeDir ) { mRecyclerView . post ( new Runnable ( ) { @ Override public void run ( ) { if ( mRecyclerView != null && mRecyclerView . isAttachedToWindow ( ) && ! anim . mOverridden && anim . mViewHolder . getAbsoluteAdapterPosition ( ) != RecyclerView . NO_POSITION ) { final RecyclerView . ItemAnimator animator = mRecyclerView . getItemAnimator ( ) ; if ( ( animator == null || ! animator . isRunning ( null ) ) && ! hasRunningRecoverAnim ( ) ) { mCallback . onSwiped ( anim . mViewHolder , swipeDir ) ; } else { mRecyclerView . post ( this ) ; } } } } ) ; } @ SuppressWarnings ( "<STR_LIT>" ) boolean hasRunningRecoverAnim ( ) { final int size = mRecoverAnimations . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { if ( ! mRecoverAnimations . get ( i ) . mEnded ) { return true ; } } return false ; } @ SuppressWarnings ( "<STR_LIT>" ) boolean scrollIfNecessary ( ) { if ( mSelected == null ) { mDragScrollStartTimeInMs = Long . MIN_VALUE ; return false ; } final long now = System . currentTimeMillis ( ) ; final long scrollDuration = mDragScrollStartTimeInMs == Long . MIN_VALUE ? <NUM_LIT> : now - mDragScrollStartTimeInMs ; RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; if ( mTmpRect == null ) { mTmpRect = new Rect ( ) ; } int scrollX = <NUM_LIT> ; int scrollY = <NUM_LIT> ; lm . calculateItemDecorationsForChild ( mSelected . itemView , mTmpRect ) ; if ( lm . canScrollHorizontally ( ) ) { int curX = ( int ) ( mSelectedStartX + mDx ) ; final int leftDiff = curX - mTmpRect . left - mRecyclerView . getPaddingLeft ( ) ; if ( mDx < <NUM_LIT> && leftDiff < <NUM_LIT> ) { scrollX = leftDiff ; } else if ( mDx > <NUM_LIT> ) { final int rightDiff = curX + mSelected . itemView . getWidth ( ) + mTmpRect . right - ( mRecyclerView . getWidth ( ) - mRecyclerView . getPaddingRight ( ) ) ; if ( rightDiff > <NUM_LIT> ) { scrollX = rightDiff ; } } } if ( lm . canScrollVertically ( ) ) { int curY = ( int ) ( mSelectedStartY + mDy ) ; final int topDiff = curY - mTmpRect . top - mRecyclerView . getPaddingTop ( ) ; if ( mDy < <NUM_LIT> && topDiff < <NUM_LIT> ) { scrollY = topDiff ; } else if ( mDy > <NUM_LIT> ) { final int bottomDiff = curY + mSelected . itemView . getHeight ( ) + mTmpRect . bottom - ( mRecyclerView . getHeight ( ) - mRecyclerView . getPaddingBottom ( ) ) ; if ( bottomDiff > <NUM_LIT> ) { scrollY = bottomDiff ; } } } if ( scrollX != <NUM_LIT> ) { scrollX = mCallback . interpolateOutOfBoundsScroll ( mRecyclerView , mSelected . itemView . getWidth ( ) , scrollX , mRecyclerView . getWidth ( ) , scrollDuration ) ; } if ( scrollY != <NUM_LIT> ) { scrollY = mCallback . interpolateOutOfBoundsScroll ( mRecyclerView , mSelected . itemView . getHeight ( ) , scrollY , mRecyclerView . getHeight ( ) , scrollDuration ) ; } if ( scrollX != <NUM_LIT> || scrollY != <NUM_LIT> ) { if ( mDragScrollStartTimeInMs == Long . MIN_VALUE ) { mDragScrollStartTimeInMs = now ; } mRecyclerView . scrollBy ( scrollX , scrollY ) ; return true ; } mDragScrollStartTimeInMs = Long . MIN_VALUE ; return false ; } private List < ViewHolder > findSwapTargets ( ViewHolder viewHolder ) { if ( mSwapTargets == null ) { mSwapTargets = new ArrayList < > ( ) ; mDistances = new ArrayList < > ( ) ; } else { mSwapTargets . clear ( ) ; mDistances . clear ( ) ; } final int margin = mCallback . getBoundingBoxMargin ( ) ; final int left = Math . round ( mSelectedStartX + mDx ) - margin ; final int top = Math . round ( mSelectedStartY + mDy ) - margin ; final int right = left + viewHolder . itemView . getWidth ( ) + <NUM_LIT> * margin ; final int bottom = top + viewHolder . itemView . getHeight ( ) + <NUM_LIT> * margin ; final int centerX = ( left + right ) / <NUM_LIT> ; final int centerY = ( top + bottom ) / <NUM_LIT> ; final RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; final int childCount = lm . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View other = lm . getChildAt ( i ) ; if ( other == viewHolder . itemView ) { continue ; } if ( other . getBottom ( ) < top || other . getTop ( ) > bottom || other . getRight ( ) < left || other . getLeft ( ) > right ) { continue ; } final ViewHolder otherVh = mRecyclerView . getChildViewHolder ( other ) ; if ( mCallback . canDropOver ( mRecyclerView , mSelected , otherVh ) ) { final int dx = Math . abs ( centerX - ( other . getLeft ( ) + other . getRight ( ) ) / <NUM_LIT> ) ; final int dy = Math . abs ( centerY - ( other . getTop ( ) + other . getBottom ( ) ) / <NUM_LIT> ) ; final int dist = dx * dx + dy * dy ; int pos = <NUM_LIT> ; final int cnt = mSwapTargets . size ( ) ; for ( int j = <NUM_LIT> ; j < cnt ; j ++ ) { if ( dist > mDistances . get ( j ) ) { pos ++ ; } else { break ; } } mSwapTargets . add ( pos , otherVh ) ; mDistances . add ( pos , dist ) ; } } return mSwapTargets ; } @ SuppressWarnings ( "<STR_LIT>" ) void moveIfNecessary ( ViewHolder viewHolder ) { if ( mRecyclerView . isLayoutRequested ( ) ) { return ; } if ( mActionState != ACTION_STATE_DRAG ) { return ; } final float threshold = mCallback . getMoveThreshold ( viewHolder ) ; final int x = ( int ) ( mSelectedStartX + mDx ) ; final int y = ( int ) ( mSelectedStartY + mDy ) ; if ( Math . abs ( y - viewHolder . itemView . getTop ( ) ) < viewHolder . itemView . getHeight ( ) * threshold && Math . abs ( x - viewHolder . itemView . getLeft ( ) ) < viewHolder . itemView . getWidth ( ) * threshold ) { return ; } List < ViewHolder > swapTargets = findSwapTargets ( viewHolder ) ; if ( swapTargets . size ( ) == <NUM_LIT> ) { return ; } ViewHolder target = mCallback . chooseDropTarget ( viewHolder , swapTargets , x , y ) ; if ( target == null ) { mSwapTargets . clear ( ) ; mDistances . clear ( ) ; return ; } final int toPosition = target . getAbsoluteAdapterPosition ( ) ; final int fromPosition = viewHolder . getAbsoluteAdapterPosition ( ) ; if ( mCallback . onMove ( mRecyclerView , viewHolder , target ) ) { mCallback . onMoved ( mRecyclerView , viewHolder , fromPosition , target , toPosition , x , y ) ; } } @ Override public void onChildViewAttachedToWindow ( @ NonNull View view ) { } @ Override public void onChildViewDetachedFromWindow ( @ NonNull View view ) { removeChildDrawingOrderCallbackIfNecessary ( view ) ; final ViewHolder holder = mRecyclerView . getChildViewHolder ( view ) ; if ( holder == null ) { return ; } if ( mSelected != null && holder == mSelected ) { select ( null , ACTION_STATE_IDLE ) ; } else { endRecoverAnimation ( holder , false ) ; if ( mPendingCleanup . remove ( holder . itemView ) ) { mCallback . clearView ( mRecyclerView , holder ) ; } } } @ SuppressWarnings ( "<STR_LIT>" ) void endRecoverAnimation ( ViewHolder viewHolder , boolean override ) { final int recoverAnimSize = mRecoverAnimations . size ( ) ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; if ( anim . mViewHolder == viewHolder ) { anim . mOverridden |= override ; if ( ! anim . mEnded ) { anim . cancel ( ) ; } mRecoverAnimations . remove ( i ) ; return ; } } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { outRect . setEmpty ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void obtainVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; } mVelocityTracker = VelocityTracker . obtain ( ) ; } private void releaseVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } } private ViewHolder findSwipedView ( MotionEvent motionEvent ) { final RecyclerView . LayoutManager lm = mRecyclerView . getLayoutManager ( ) ; if ( mActivePointerId == ACTIVE_POINTER_ID_NONE ) { return null ; } final int pointerIndex = motionEvent . findPointerIndex ( mActivePointerId ) ; final float dx = motionEvent . getX ( pointerIndex ) - mInitialTouchX ; final float dy = motionEvent . getY ( pointerIndex ) - mInitialTouchY ; final float absDx = Math . abs ( dx ) ; final float absDy = Math . abs ( dy ) ; if ( absDx < mSlop && absDy < mSlop ) { return null ; } if ( absDx > absDy && lm . canScrollHorizontally ( ) ) { return null ; } else if ( absDy > absDx && lm . canScrollVertically ( ) ) { return null ; } View child = findChildView ( motionEvent ) ; if ( child == null ) { return null ; } return mRecyclerView . getChildViewHolder ( child ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void checkSelectForSwipe ( int action , MotionEvent motionEvent , int pointerIndex ) { if ( mSelected != null || action != MotionEvent . ACTION_MOVE || mActionState == ACTION_STATE_DRAG || ! mCallback . isItemViewSwipeEnabled ( ) ) { return ; } if ( mRecyclerView . getScrollState ( ) == RecyclerView . SCROLL_STATE_DRAGGING ) { return ; } final ViewHolder vh = findSwipedView ( motionEvent ) ; if ( vh == null ) { return ; } final int movementFlags = mCallback . getAbsoluteMovementFlags ( mRecyclerView , vh ) ; final int swipeFlags = ( movementFlags & ACTION_MODE_SWIPE_MASK ) > > ( DIRECTION_FLAG_COUNT * ACTION_STATE_SWIPE ) ; if ( swipeFlags == <NUM_LIT> ) { return ; } final float x = motionEvent . getX ( pointerIndex ) ; final float y = motionEvent . getY ( pointerIndex ) ; final float dx = x - mInitialTouchX ; final float dy = y - mInitialTouchY ; final float absDx = Math . abs ( dx ) ; final float absDy = Math . abs ( dy ) ; if ( absDx < mSlop && absDy < mSlop ) { return ; } if ( absDx > absDy ) { if ( dx < <NUM_LIT> && ( swipeFlags & LEFT ) == <NUM_LIT> ) { return ; } if ( dx > <NUM_LIT> && ( swipeFlags & RIGHT ) == <NUM_LIT> ) { return ; } } else { if ( dy < <NUM_LIT> && ( swipeFlags & UP ) == <NUM_LIT> ) { return ; } if ( dy > <NUM_LIT> && ( swipeFlags & DOWN ) == <NUM_LIT> ) { return ; } } mDx = mDy = <NUM_LIT> ; mActivePointerId = motionEvent . getPointerId ( <NUM_LIT> ) ; select ( vh , ACTION_STATE_SWIPE ) ; } @ SuppressWarnings ( "<STR_LIT>" ) View findChildView ( MotionEvent event ) { final float x = event . getX ( ) ; final float y = event . getY ( ) ; if ( mSelected != null ) { final View selectedView = mSelected . itemView ; if ( hitTest ( selectedView , x , y , mSelectedStartX + mDx , mSelectedStartY + mDy ) ) { return selectedView ; } } for ( int i = mRecoverAnimations . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; final View view = anim . mViewHolder . itemView ; if ( hitTest ( view , x , y , anim . mX , anim . mY ) ) { return view ; } } return mRecyclerView . findChildViewUnder ( x , y ) ; } public void startDrag ( @ NonNull ViewHolder viewHolder ) { if ( ! mCallback . hasDragFlag ( mRecyclerView , viewHolder ) ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } if ( viewHolder . itemView . getParent ( ) != mRecyclerView ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } obtainVelocityTracker ( ) ; mDx = mDy = <NUM_LIT> ; select ( viewHolder , ACTION_STATE_DRAG ) ; } public void startSwipe ( @ NonNull ViewHolder viewHolder ) { if ( ! mCallback . hasSwipeFlag ( mRecyclerView , viewHolder ) ) { Log . e ( TAG , "<STR_LIT>" ) ; return ; } if ( viewHolder . itemView . getParent ( ) != mRecyclerView ) { Log . e ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; return ; } obtainVelocityTracker ( ) ; mDx = mDy = <NUM_LIT> ; select ( viewHolder , ACTION_STATE_SWIPE ) ; } @ SuppressWarnings ( "<STR_LIT>" ) RecoverAnimation findAnimation ( MotionEvent event ) { if ( mRecoverAnimations . isEmpty ( ) ) { return null ; } View target = findChildView ( event ) ; for ( int i = mRecoverAnimations . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = mRecoverAnimations . get ( i ) ; if ( anim . mViewHolder . itemView == target ) { return anim ; } } return null ; } @ SuppressWarnings ( "<STR_LIT>" ) void updateDxDy ( MotionEvent ev , int directionFlags , int pointerIndex ) { final float x = ev . getX ( pointerIndex ) ; final float y = ev . getY ( pointerIndex ) ; mDx = x - mInitialTouchX ; mDy = y - mInitialTouchY ; if ( ( directionFlags & LEFT ) == <NUM_LIT> ) { mDx = Math . max ( <NUM_LIT> , mDx ) ; } if ( ( directionFlags & RIGHT ) == <NUM_LIT> ) { mDx = Math . min ( <NUM_LIT> , mDx ) ; } if ( ( directionFlags & UP ) == <NUM_LIT> ) { mDy = Math . max ( <NUM_LIT> , mDy ) ; } if ( ( directionFlags & DOWN ) == <NUM_LIT> ) { mDy = Math . min ( <NUM_LIT> , mDy ) ; } } private int swipeIfNecessary ( ViewHolder viewHolder ) { if ( mActionState == ACTION_STATE_DRAG ) { return <NUM_LIT> ; } final int originalMovementFlags = mCallback . getMovementFlags ( mRecyclerView , viewHolder ) ; final int absoluteMovementFlags = mCallback . convertToAbsoluteDirection ( originalMovementFlags , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; final int flags = ( absoluteMovementFlags & ACTION_MODE_SWIPE_MASK ) > > ( ACTION_STATE_SWIPE * DIRECTION_FLAG_COUNT ) ; if ( flags == <NUM_LIT> ) { return <NUM_LIT> ; } final int originalFlags = ( originalMovementFlags & ACTION_MODE_SWIPE_MASK ) > > ( ACTION_STATE_SWIPE * DIRECTION_FLAG_COUNT ) ; int swipeDir ; if ( Math . abs ( mDx ) > Math . abs ( mDy ) ) { if ( ( swipeDir = checkHorizontalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { if ( ( originalFlags & swipeDir ) == <NUM_LIT> ) { return Callback . convertToRelativeDirection ( swipeDir , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; } return swipeDir ; } if ( ( swipeDir = checkVerticalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { return swipeDir ; } } else { if ( ( swipeDir = checkVerticalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { return swipeDir ; } if ( ( swipeDir = checkHorizontalSwipe ( viewHolder , flags ) ) > <NUM_LIT> ) { if ( ( originalFlags & swipeDir ) == <NUM_LIT> ) { return Callback . convertToRelativeDirection ( swipeDir , ViewCompat . getLayoutDirection ( mRecyclerView ) ) ; } return swipeDir ; } } return <NUM_LIT> ; } private int checkHorizontalSwipe ( ViewHolder viewHolder , int flags ) { if ( ( flags & ( LEFT | RIGHT ) ) != <NUM_LIT> ) { final int dirFlag = mDx > <NUM_LIT> ? RIGHT : LEFT ; if ( mVelocityTracker != null && mActivePointerId > - <NUM_LIT> ) { mVelocityTracker . computeCurrentVelocity ( PIXELS_PER_SECOND , mCallback . getSwipeVelocityThreshold ( mMaxSwipeVelocity ) ) ; final float xVelocity = mVelocityTracker . getXVelocity ( mActivePointerId ) ; final float yVelocity = mVelocityTracker . getYVelocity ( mActivePointerId ) ; final int velDirFlag = xVelocity > <NUM_LIT> ? RIGHT : LEFT ; final float absXVelocity = Math . abs ( xVelocity ) ; if ( ( velDirFlag & flags ) != <NUM_LIT> && dirFlag == velDirFlag && absXVelocity >= mCallback . getSwipeEscapeVelocity ( mSwipeEscapeVelocity ) && absXVelocity > Math . abs ( yVelocity ) ) { return velDirFlag ; } } final float threshold = mRecyclerView . getWidth ( ) * mCallback . getSwipeThreshold ( viewHolder ) ; if ( ( flags & dirFlag ) != <NUM_LIT> && Math . abs ( mDx ) > threshold ) { return dirFlag ; } } return <NUM_LIT> ; } private int checkVerticalSwipe ( ViewHolder viewHolder , int flags ) { if ( ( flags & ( UP | DOWN ) ) != <NUM_LIT> ) { final int dirFlag = mDy > <NUM_LIT> ? DOWN : UP ; if ( mVelocityTracker != null && mActivePointerId > - <NUM_LIT> ) { mVelocityTracker . computeCurrentVelocity ( PIXELS_PER_SECOND , mCallback . getSwipeVelocityThreshold ( mMaxSwipeVelocity ) ) ; final float xVelocity = mVelocityTracker . getXVelocity ( mActivePointerId ) ; final float yVelocity = mVelocityTracker . getYVelocity ( mActivePointerId ) ; final int velDirFlag = yVelocity > <NUM_LIT> ? DOWN : UP ; final float absYVelocity = Math . abs ( yVelocity ) ; if ( ( velDirFlag & flags ) != <NUM_LIT> && velDirFlag == dirFlag && absYVelocity >= mCallback . getSwipeEscapeVelocity ( mSwipeEscapeVelocity ) && absYVelocity > Math . abs ( xVelocity ) ) { return velDirFlag ; } } final float threshold = mRecyclerView . getHeight ( ) * mCallback . getSwipeThreshold ( viewHolder ) ; if ( ( flags & dirFlag ) != <NUM_LIT> && Math . abs ( mDy ) > threshold ) { return dirFlag ; } } return <NUM_LIT> ; } private void addChildDrawingOrderCallback ( ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { return ; } if ( mChildDrawingOrderCallback == null ) { mChildDrawingOrderCallback = new RecyclerView . ChildDrawingOrderCallback ( ) { @ Override public int onGetChildDrawingOrder ( int childCount , int i ) { if ( mOverdrawChild == null ) { return i ; } int childPosition = mOverdrawChildPosition ; if ( childPosition == - <NUM_LIT> ) { childPosition = mRecyclerView . indexOfChild ( mOverdrawChild ) ; mOverdrawChildPosition = childPosition ; } if ( i == childCount - <NUM_LIT> ) { return childPosition ; } return i < childPosition ? i : i + <NUM_LIT> ; } } ; } mRecyclerView . setChildDrawingOrderCallback ( mChildDrawingOrderCallback ) ; } @ SuppressWarnings ( "<STR_LIT>" ) void removeChildDrawingOrderCallbackIfNecessary ( View view ) { if ( view == mOverdrawChild ) { mOverdrawChild = null ; if ( mChildDrawingOrderCallback != null ) { mRecyclerView . setChildDrawingOrderCallback ( null ) ; } } } public interface ViewDropHandler { void prepareForDrop ( @ NonNull View view , @ NonNull View target , int x , int y ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public abstract static class Callback { @ SuppressWarnings ( "<STR_LIT>" ) public static final int DEFAULT_DRAG_ANIMATION_DURATION = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) public static final int DEFAULT_SWIPE_ANIMATION_DURATION = <NUM_LIT> ; static final int RELATIVE_DIR_FLAGS = START | END | ( ( START | END ) << DIRECTION_FLAG_COUNT ) | ( ( START | END ) << ( <NUM_LIT> * DIRECTION_FLAG_COUNT ) ) ; private static final int ABS_HORIZONTAL_DIR_FLAGS = LEFT | RIGHT | ( ( LEFT | RIGHT ) << DIRECTION_FLAG_COUNT ) | ( ( LEFT | RIGHT ) << ( <NUM_LIT> * DIRECTION_FLAG_COUNT ) ) ; private static final Interpolator sDragScrollInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { return t * t * t * t * t ; } } ; private static final Interpolator sDragViewScrollCapInterpolator = new Interpolator ( ) { @ Override public float getInterpolation ( float t ) { t -= <NUM_LIT> ; return t * t * t * t * t + <NUM_LIT> ; } } ; private static final long DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS = <NUM_LIT> ; private int mCachedMaxScrollSpeed = - <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull public static ItemTouchUIUtil getDefaultUIUtil ( ) { return ItemTouchUIUtilImpl . INSTANCE ; } @ SuppressWarnings ( "<STR_LIT>" ) public static int convertToRelativeDirection ( int flags , int layoutDirection ) { int masked = flags & ABS_HORIZONTAL_DIR_FLAGS ; if ( masked == <NUM_LIT> ) { return flags ; } flags &= ~ masked ; if ( layoutDirection == ViewCompat . LAYOUT_DIRECTION_LTR ) { flags |= masked << <NUM_LIT> ; return flags ; } else { flags |= ( ( masked << <NUM_LIT> ) & ~ ABS_HORIZONTAL_DIR_FLAGS ) ; flags |= ( ( masked << <NUM_LIT> ) & ABS_HORIZONTAL_DIR_FLAGS ) << <NUM_LIT> ; } return flags ; } public static int makeMovementFlags ( int dragFlags , int swipeFlags ) { return makeFlag ( ACTION_STATE_IDLE , swipeFlags | dragFlags ) | makeFlag ( ACTION_STATE_SWIPE , swipeFlags ) | makeFlag ( ACTION_STATE_DRAG , dragFlags ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public static int makeFlag ( int actionState , int directions ) { return directions << ( actionState * DIRECTION_FLAG_COUNT ) ; } public abstract int getMovementFlags ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) ; @ SuppressWarnings ( "<STR_LIT>" ) public int convertToAbsoluteDirection ( int flags , int layoutDirection ) { int masked = flags & RELATIVE_DIR_FLAGS ; if ( masked == <NUM_LIT> ) { return flags ; } flags &= ~ masked ; if ( layoutDirection == ViewCompat . LAYOUT_DIRECTION_LTR ) { flags |= masked > > <NUM_LIT> ; return flags ; } else { flags |= ( ( masked > > <NUM_LIT> ) & ~ RELATIVE_DIR_FLAGS ) ; flags |= ( ( masked > > <NUM_LIT> ) & RELATIVE_DIR_FLAGS ) > > <NUM_LIT> ; } return flags ; } final int getAbsoluteMovementFlags ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getMovementFlags ( recyclerView , viewHolder ) ; return convertToAbsoluteDirection ( flags , ViewCompat . getLayoutDirection ( recyclerView ) ) ; } boolean hasDragFlag ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getAbsoluteMovementFlags ( recyclerView , viewHolder ) ; return ( flags & ACTION_MODE_DRAG_MASK ) != <NUM_LIT> ; } boolean hasSwipeFlag ( RecyclerView recyclerView , ViewHolder viewHolder ) { final int flags = getAbsoluteMovementFlags ( recyclerView , viewHolder ) ; return ( flags & ACTION_MODE_SWIPE_MASK ) != <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public boolean canDropOver ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder current , @ NonNull ViewHolder target ) { return true ; } public abstract boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder , @ NonNull ViewHolder target ) ; public boolean isLongPressDragEnabled ( ) { return true ; } public boolean isItemViewSwipeEnabled ( ) { return true ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getBoundingBoxMargin ( ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeThreshold ( @ NonNull ViewHolder viewHolder ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getMoveThreshold ( @ NonNull ViewHolder viewHolder ) { return <NUM_LIT> ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeEscapeVelocity ( float defaultValue ) { return defaultValue ; } @ SuppressWarnings ( "<STR_LIT>" ) public float getSwipeVelocityThreshold ( float defaultValue ) { return defaultValue ; } @ SuppressWarnings ( "<STR_LIT>" ) @ SuppressLint ( "<STR_LIT>" ) public ViewHolder chooseDropTarget ( @ NonNull ViewHolder selected , @ NonNull List < ViewHolder > dropTargets , int curX , int curY ) { int right = curX + selected . itemView . getWidth ( ) ; int bottom = curY + selected . itemView . getHeight ( ) ; ViewHolder winner = null ; int winnerScore = - <NUM_LIT> ; final int dx = curX - selected . itemView . getLeft ( ) ; final int dy = curY - selected . itemView . getTop ( ) ; final int targetsSize = dropTargets . size ( ) ; for ( int i = <NUM_LIT> ; i < targetsSize ; i ++ ) { final ViewHolder target = dropTargets . get ( i ) ; if ( dx > <NUM_LIT> ) { int diff = target . itemView . getRight ( ) - right ; if ( diff < <NUM_LIT> && target . itemView . getRight ( ) > selected . itemView . getRight ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dx < <NUM_LIT> ) { int diff = target . itemView . getLeft ( ) - curX ; if ( diff > <NUM_LIT> && target . itemView . getLeft ( ) < selected . itemView . getLeft ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dy < <NUM_LIT> ) { int diff = target . itemView . getTop ( ) - curY ; if ( diff > <NUM_LIT> && target . itemView . getTop ( ) < selected . itemView . getTop ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } if ( dy > <NUM_LIT> ) { int diff = target . itemView . getBottom ( ) - bottom ; if ( diff < <NUM_LIT> && target . itemView . getBottom ( ) > selected . itemView . getBottom ( ) ) { final int score = Math . abs ( diff ) ; if ( score > winnerScore ) { winnerScore = score ; winner = target ; } } } } return winner ; } public abstract void onSwiped ( @ NonNull ViewHolder viewHolder , int direction ) ; public void onSelectedChanged ( @ Nullable ViewHolder viewHolder , int actionState ) { if ( viewHolder != null ) { ItemTouchUIUtilImpl . INSTANCE . onSelected ( viewHolder . itemView ) ; } } private int getMaxDragScroll ( RecyclerView recyclerView ) { if ( mCachedMaxScrollSpeed == - <NUM_LIT> ) { mCachedMaxScrollSpeed = recyclerView . getResources ( ) . getDimensionPixelSize ( R . dimen . item_touch_helper_max_drag_scroll_per_frame ) ; } return mCachedMaxScrollSpeed ; } public void onMoved ( @ NonNull final RecyclerView recyclerView , @ NonNull final ViewHolder viewHolder , int fromPos , @ NonNull final ViewHolder target , int toPos , int x , int y ) { final RecyclerView . LayoutManager layoutManager = recyclerView . getLayoutManager ( ) ; if ( layoutManager instanceof ViewDropHandler ) { ( ( ViewDropHandler ) layoutManager ) . prepareForDrop ( viewHolder . itemView , target . itemView , x , y ) ; return ; } if ( layoutManager . canScrollHorizontally ( ) ) { final int minLeft = layoutManager . getDecoratedLeft ( target . itemView ) ; if ( minLeft <= recyclerView . getPaddingLeft ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } final int maxRight = layoutManager . getDecoratedRight ( target . itemView ) ; if ( maxRight >= recyclerView . getWidth ( ) - recyclerView . getPaddingRight ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } } if ( layoutManager . canScrollVertically ( ) ) { final int minTop = layoutManager . getDecoratedTop ( target . itemView ) ; if ( minTop <= recyclerView . getPaddingTop ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } final int maxBottom = layoutManager . getDecoratedBottom ( target . itemView ) ; if ( maxBottom >= recyclerView . getHeight ( ) - recyclerView . getPaddingBottom ( ) ) { recyclerView . scrollToPosition ( toPos ) ; } } } void onDraw ( Canvas c , RecyclerView parent , ViewHolder selected , List < ItemTouchHelper . RecoverAnimation > recoverAnimationList , int actionState , float dX , float dY ) { final int recoverAnimSize = recoverAnimationList . size ( ) ; for ( int i = <NUM_LIT> ; i < recoverAnimSize ; i ++ ) { final ItemTouchHelper . RecoverAnimation anim = recoverAnimationList . get ( i ) ; anim . update ( ) ; final int count = c . save ( ) ; onChildDraw ( c , parent , anim . mViewHolder , anim . mX , anim . mY , anim . mActionState , false ) ; c . restoreToCount ( count ) ; } if ( selected != null ) { final int count = c . save ( ) ; onChildDraw ( c , parent , selected , dX , dY , actionState , true ) ; c . restoreToCount ( count ) ; } } void onDrawOver ( Canvas c , RecyclerView parent , ViewHolder selected , List < ItemTouchHelper . RecoverAnimation > recoverAnimationList , int actionState , float dX , float dY ) { final int recoverAnimSize = recoverAnimationList . size ( ) ; for ( int i = <NUM_LIT> ; i < recoverAnimSize ; i ++ ) { final ItemTouchHelper . RecoverAnimation anim = recoverAnimationList . get ( i ) ; final int count = c . save ( ) ; onChildDrawOver ( c , parent , anim . mViewHolder , anim . mX , anim . mY , anim . mActionState , false ) ; c . restoreToCount ( count ) ; } if ( selected != null ) { final int count = c . save ( ) ; onChildDrawOver ( c , parent , selected , dX , dY , actionState , true ) ; c . restoreToCount ( count ) ; } boolean hasRunningAnimation = false ; for ( int i = recoverAnimSize - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final RecoverAnimation anim = recoverAnimationList . get ( i ) ; if ( anim . mEnded && ! anim . mIsPendingCleanup ) { recoverAnimationList . remove ( i ) ; } else if ( ! anim . mEnded ) { hasRunningAnimation = true ; } } if ( hasRunningAnimation ) { parent . invalidate ( ) ; } } public void clearView ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) { ItemTouchUIUtilImpl . INSTANCE . clearView ( viewHolder . itemView ) ; } public void onChildDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder , float dX , float dY , int actionState , boolean isCurrentlyActive ) { ItemTouchUIUtilImpl . INSTANCE . onDraw ( c , recyclerView , viewHolder . itemView , dX , dY , actionState , isCurrentlyActive ) ; } public void onChildDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ SuppressLint ( "<STR_LIT>" ) ViewHolder viewHolder , float dX , float dY , int actionState , boolean isCurrentlyActive ) { ItemTouchUIUtilImpl . INSTANCE . onDrawOver ( c , recyclerView , viewHolder . itemView , dX , dY , actionState , isCurrentlyActive ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public long getAnimationDuration ( @ NonNull RecyclerView recyclerView , int animationType , float animateDx , float animateDy ) { final RecyclerView . ItemAnimator itemAnimator = recyclerView . getItemAnimator ( ) ; if ( itemAnimator == null ) { return animationType == ANIMATION_TYPE_DRAG ? DEFAULT_DRAG_ANIMATION_DURATION : DEFAULT_SWIPE_ANIMATION_DURATION ; } else { return animationType == ANIMATION_TYPE_DRAG ? itemAnimator . getMoveDuration ( ) : itemAnimator . getRemoveDuration ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public int interpolateOutOfBoundsScroll ( @ NonNull RecyclerView recyclerView , int viewSize , int viewSizeOutOfBounds , int totalSize , long msSinceStartScroll ) { final int maxScroll = getMaxDragScroll ( recyclerView ) ; final int absOutOfBounds = Math . abs ( viewSizeOutOfBounds ) ; final int direction = ( int ) Math . signum ( viewSizeOutOfBounds ) ; float outOfBoundsRatio = Math . min ( <NUM_LIT> , <NUM_LIT> * absOutOfBounds / viewSize ) ; final int cappedScroll = ( int ) ( direction * maxScroll * sDragViewScrollCapInterpolator . getInterpolation ( outOfBoundsRatio ) ) ; final float timeRatio ; if ( msSinceStartScroll > DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ) { timeRatio = <NUM_LIT> ; } else { timeRatio = ( float ) msSinceStartScroll / DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS ; } final int value = ( int ) ( cappedScroll * sDragScrollInterpolator . getInterpolation ( timeRatio ) ) ; if ( value == <NUM_LIT> ) { return viewSizeOutOfBounds > <NUM_LIT> ? <NUM_LIT> : - <NUM_LIT> ; } return value ; } } public abstract static class SimpleCallback extends Callback { private int mDefaultSwipeDirs ; private int mDefaultDragDirs ; public SimpleCallback ( int dragDirs , int swipeDirs ) { mDefaultSwipeDirs = swipeDirs ; mDefaultDragDirs = dragDirs ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public void setDefaultSwipeDirs ( @ SuppressWarnings ( "<STR_LIT>" ) int defaultSwipeDirs ) { mDefaultSwipeDirs = defaultSwipeDirs ; } @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public void setDefaultDragDirs ( @ SuppressWarnings ( "<STR_LIT>" ) int defaultDragDirs ) { mDefaultDragDirs = defaultDragDirs ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getSwipeDirs ( @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull RecyclerView recyclerView , @ NonNull @ SuppressWarnings ( "<STR_LIT>" ) ViewHolder viewHolder ) { return mDefaultSwipeDirs ; } @ SuppressWarnings ( "<STR_LIT>" ) public int getDragDirs ( @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull RecyclerView recyclerView , @ SuppressWarnings ( "<STR_LIT>" ) @ NonNull ViewHolder viewHolder ) { return mDefaultDragDirs ; } @ Override public int getMovementFlags ( @ NonNull RecyclerView recyclerView , @ NonNull ViewHolder viewHolder ) { return makeMovementFlags ( getDragDirs ( recyclerView , viewHolder ) , getSwipeDirs ( recyclerView , viewHolder ) ) ; } } private class ItemTouchHelperGestureListener extends GestureDetector . SimpleOnGestureListener { private boolean mShouldReactToLongPress = true ; ItemTouchHelperGestureListener ( ) { } void doNotReactToLongPress ( ) { mShouldReactToLongPress = false ; } @ Override public boolean onDown ( MotionEvent e ) { return true ; } @ Override public void onLongPress ( MotionEvent e ) { if ( ! mShouldReactToLongPress ) { return ; } View child = findChildView ( e ) ; if ( child != null ) { ViewHolder vh = mRecyclerView . getChildViewHolder ( child ) ; if ( vh != null ) { if ( ! mCallback . hasDragFlag ( mRecyclerView , vh ) ) { return ; } int pointerId = e . getPointerId ( <NUM_LIT> ) ; if ( pointerId == mActivePointerId ) { final int index = e . findPointerIndex ( mActivePointerId ) ; final float x = e . getX ( index ) ; final float y = e . getY ( index ) ; mInitialTouchX = x ; mInitialTouchY = y ; mDx = mDy = <NUM_LIT> ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mInitialTouchX + "<STR_LIT>" + mInitialTouchY ) ; } if ( mCallback . isLongPressDragEnabled ( ) ) { select ( vh , ACTION_STATE_DRAG ) ; } } } } } } @ VisibleForTesting static class RecoverAnimation implements Animator . AnimatorListener { final float mStartDx ; final float mStartDy ; final float mTargetX ; final float mTargetY ; final ViewHolder mViewHolder ; final int mActionState ; @ VisibleForTesting final ValueAnimator mValueAnimator ; final int mAnimationType ; boolean mIsPendingCleanup ; float mX ; float mY ; boolean mOverridden = false ; boolean mEnded = false ; private float mFraction ; RecoverAnimation ( ViewHolder viewHolder , int animationType , int actionState , float startDx , float startDy , float targetX , float targetY ) { mActionState = actionState ; mAnimationType = animationType ; mViewHolder = viewHolder ; mStartDx = startDx ; mStartDy = startDy ; mTargetX = targetX ; mTargetY = targetY ; mValueAnimator = ValueAnimator . ofFloat ( <NUM_LIT> , <NUM_LIT> ) ; mValueAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { setFraction ( animation . getAnimatedFraction ( ) ) ; } } ) ; mValueAnimator . setTarget ( viewHolder . itemView ) ; mValueAnimator . addListener ( this ) ; setFraction ( <NUM_LIT> ) ; } public void setDuration ( long duration ) { mValueAnimator . setDuration ( duration ) ; } public void start ( ) { mViewHolder . setIsRecyclable ( false ) ; mValueAnimator . start ( ) ; } public void cancel ( ) { mValueAnimator . cancel ( ) ; } public void setFraction ( float fraction ) { mFraction = fraction ; } public void update ( ) { if ( mStartDx == mTargetX ) { mX = mViewHolder . itemView . getTranslationX ( ) ; } else { mX = mStartDx + mFraction * ( mTargetX - mStartDx ) ; } if ( mStartDy == mTargetY ) { mY = mViewHolder . itemView . getTranslationY ( ) ; } else { mY = mStartDy + mFraction * ( mTargetY - mStartDy ) ; } } @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { if ( ! mEnded ) { mViewHolder . setIsRecyclable ( true ) ; } mEnded = true ; } @ Override public void onAnimationCancel ( Animator animation ) { setFraction ( <NUM_LIT> ) ; } @ Override public void onAnimationRepeat ( Animator animation ) { } } } </s>
<s> package androidx . fluidrecyclerview . widget ; import static androidx . annotation . RestrictTo . Scope . LIBRARY ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . os . Parcel ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import android . view . accessibility . AccessibilityEvent ; import androidx . annotation . NonNull ; import androidx . annotation . RestrictTo ; import androidx . core . os . TraceCompat ; import androidx . core . view . ViewCompat ; import java . util . List ; public class LinearLayoutManager extends RecyclerView . LayoutManager implements ItemTouchHelper . ViewDropHandler , RecyclerView . SmoothScroller . ScrollVectorProvider { private static final String TAG = "<STR_LIT>" ; static final boolean DEBUG = false ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; public static final int INVALID_OFFSET = Integer . MIN_VALUE ; private static final float MAX_SCROLL_FACTOR = <NUM_LIT> / <NUM_LIT> ; @ RecyclerView . Orientation int mOrientation = RecyclerView . DEFAULT_ORIENTATION ; private LayoutState mLayoutState ; OrientationHelper mOrientationHelper ; private boolean mLastStackFromEnd ; private boolean mReverseLayout = false ; boolean mShouldReverseLayout = false ; private boolean mStackFromEnd = false ; private boolean mSmoothScrollbarEnabled = true ; int mPendingScrollPosition = RecyclerView . NO_POSITION ; int mPendingScrollPositionOffset = INVALID_OFFSET ; private boolean mRecycleChildrenOnDetach ; SavedState mPendingSavedState = null ; final AnchorInfo mAnchorInfo = new AnchorInfo ( ) ; private final LayoutChunkResult mLayoutChunkResult = new LayoutChunkResult ( ) ; private int mInitialPrefetchItemCount = <NUM_LIT> ; private int [ ] mReusableIntPair = new int [ <NUM_LIT> ] ; public LinearLayoutManager ( @ SuppressLint ( "<STR_LIT>" ) Context context ) { this ( context , RecyclerView . DEFAULT_ORIENTATION , false ) ; } public LinearLayoutManager ( @ SuppressLint ( "<STR_LIT>" ) Context context , @ RecyclerView . Orientation int orientation , boolean reverseLayout ) { setOrientation ( orientation ) ; setReverseLayout ( reverseLayout ) ; } @ SuppressLint ( "<STR_LIT>" ) public LinearLayoutManager ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { Properties properties = getProperties ( context , attrs , defStyleAttr , defStyleRes ) ; setOrientation ( properties . orientation ) ; setReverseLayout ( properties . reverseLayout ) ; setStackFromEnd ( properties . stackFromEnd ) ; } @ Override public boolean isAutoMeasureEnabled ( ) { return true ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public RecyclerView . LayoutParams generateDefaultLayoutParams ( ) { return new RecyclerView . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; } public boolean getRecycleChildrenOnDetach ( ) { return mRecycleChildrenOnDetach ; } public void setRecycleChildrenOnDetach ( boolean recycleChildrenOnDetach ) { mRecycleChildrenOnDetach = recycleChildrenOnDetach ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onDetachedFromWindow ( RecyclerView view , RecyclerView . Recycler recycler ) { super . onDetachedFromWindow ( view , recycler ) ; if ( mRecycleChildrenOnDetach ) { removeAndRecycleAllViews ( recycler ) ; recycler . clear ( ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onInitializeAccessibilityEvent ( AccessibilityEvent event ) { super . onInitializeAccessibilityEvent ( event ) ; if ( getChildCount ( ) > <NUM_LIT> ) { event . setFromIndex ( findFirstVisibleItemPosition ( ) ) ; event . setToIndex ( findLastVisibleItemPosition ( ) ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public Parcelable onSaveInstanceState ( ) { if ( mPendingSavedState != null ) { return new SavedState ( mPendingSavedState ) ; } SavedState state = new SavedState ( ) ; if ( getChildCount ( ) > <NUM_LIT> ) { ensureLayoutState ( ) ; boolean didLayoutFromEnd = mLastStackFromEnd ^ mShouldReverseLayout ; state . mAnchorLayoutFromEnd = didLayoutFromEnd ; if ( didLayoutFromEnd ) { final View refChild = getChildClosestToEnd ( ) ; state . mAnchorOffset = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( refChild ) ; state . mAnchorPosition = getPosition ( refChild ) ; } else { final View refChild = getChildClosestToStart ( ) ; state . mAnchorPosition = getPosition ( refChild ) ; state . mAnchorOffset = mOrientationHelper . getDecoratedStart ( refChild ) - mOrientationHelper . getStartAfterPadding ( ) ; } } else { state . invalidateAnchor ( ) ; } return state ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof SavedState ) { mPendingSavedState = ( SavedState ) state ; if ( mPendingScrollPosition != RecyclerView . NO_POSITION ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } else if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } @ Override public boolean canScrollHorizontally ( ) { return mOrientation == HORIZONTAL ; } @ Override public boolean canScrollVertically ( ) { return mOrientation == VERTICAL ; } public void setStackFromEnd ( boolean stackFromEnd ) { assertNotInLayoutOrScroll ( null ) ; if ( mStackFromEnd == stackFromEnd ) { return ; } mStackFromEnd = stackFromEnd ; requestLayout ( ) ; } public boolean getStackFromEnd ( ) { return mStackFromEnd ; } @ RecyclerView . Orientation public int getOrientation ( ) { return mOrientation ; } public void setOrientation ( @ RecyclerView . Orientation int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( "<STR_LIT>" + orientation ) ; } assertNotInLayoutOrScroll ( null ) ; if ( orientation != mOrientation || mOrientationHelper == null ) { mOrientationHelper = OrientationHelper . createOrientationHelper ( this , orientation ) ; mAnchorInfo . mOrientationHelper = mOrientationHelper ; mOrientation = orientation ; requestLayout ( ) ; } } private void resolveShouldLayoutReverse ( ) { if ( mOrientation == VERTICAL || ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } public boolean getReverseLayout ( ) { return mReverseLayout ; } public void setReverseLayout ( boolean reverseLayout ) { assertNotInLayoutOrScroll ( null ) ; if ( reverseLayout == mReverseLayout ) { return ; } mReverseLayout = reverseLayout ; requestLayout ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public View findViewByPosition ( int position ) { final int childCount = getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } final int firstChild = getPosition ( getChildAt ( <NUM_LIT> ) ) ; final int viewPosition = position - firstChild ; if ( viewPosition >= <NUM_LIT> && viewPosition < childCount ) { final View child = getChildAt ( viewPosition ) ; if ( getPosition ( child ) == position ) { return child ; } } return super . findViewByPosition ( position ) ; } @ SuppressWarnings ( "<STR_LIT>" ) @ Deprecated protected int getExtraLayoutSpace ( RecyclerView . State state ) { if ( state . hasTargetScrollPosition ( ) ) { return mOrientationHelper . getTotalSpace ( ) ; } else { return <NUM_LIT> ; } } protected void calculateExtraLayoutSpace ( @ NonNull RecyclerView . State state , @ NonNull int [ ] extraLayoutSpace ) { int extraLayoutSpaceStart = <NUM_LIT> ; int extraLayoutSpaceEnd = <NUM_LIT> ; @ SuppressWarnings ( "<STR_LIT>" ) int extraScrollSpace = getExtraLayoutSpace ( state ) ; if ( mLayoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { extraLayoutSpaceStart = extraScrollSpace ; } else { extraLayoutSpaceEnd = extraScrollSpace ; } extraLayoutSpace [ <NUM_LIT> ] = extraLayoutSpaceStart ; extraLayoutSpace [ <NUM_LIT> ] = extraLayoutSpaceEnd ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void smoothScrollToPosition ( RecyclerView recyclerView , RecyclerView . State state , int position ) { LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller ( recyclerView . getContext ( ) ) ; linearSmoothScroller . setTargetPosition ( position ) ; startSmoothScroll ( linearSmoothScroller ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public PointF computeScrollVectorForPosition ( int targetPosition ) { if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final int firstChildPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; final int direction = targetPosition < firstChildPos != mShouldReverseLayout ? - <NUM_LIT> : <NUM_LIT> ; if ( mOrientation == HORIZONTAL ) { return new PointF ( direction , <NUM_LIT> ) ; } else { return new PointF ( <NUM_LIT> , direction ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onLayoutChildren ( RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + state . isPreLayout ( ) ) ; } if ( mPendingSavedState != null || mPendingScrollPosition != RecyclerView . NO_POSITION ) { if ( state . getItemCount ( ) == <NUM_LIT> ) { removeAndRecycleAllViews ( recycler ) ; return ; } } if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { mPendingScrollPosition = mPendingSavedState . mAnchorPosition ; } ensureLayoutState ( ) ; mLayoutState . mRecycle = false ; resolveShouldLayoutReverse ( ) ; final View focused = getFocusedChild ( ) ; if ( ! mAnchorInfo . mValid || mPendingScrollPosition != RecyclerView . NO_POSITION || mPendingSavedState != null ) { mAnchorInfo . reset ( ) ; mAnchorInfo . mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd ; updateAnchorInfoForLayout ( recycler , state , mAnchorInfo ) ; mAnchorInfo . mValid = true ; } else if ( focused != null && ( mOrientationHelper . getDecoratedStart ( focused ) >= mOrientationHelper . getEndAfterPadding ( ) || mOrientationHelper . getDecoratedEnd ( focused ) <= mOrientationHelper . getStartAfterPadding ( ) ) ) { mAnchorInfo . assignFromViewAndKeepVisibleRect ( focused , getPosition ( focused ) ) ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + mAnchorInfo ) ; } mLayoutState . mLayoutDirection = mLayoutState . mLastScrollDelta >= <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; calculateExtraLayoutSpace ( state , mReusableIntPair ) ; int extraForStart = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) + mOrientationHelper . getStartAfterPadding ( ) ; int extraForEnd = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) + mOrientationHelper . getEndPadding ( ) ; if ( state . isPreLayout ( ) && mPendingScrollPosition != RecyclerView . NO_POSITION && mPendingScrollPositionOffset != INVALID_OFFSET ) { final View existing = findViewByPosition ( mPendingScrollPosition ) ; if ( existing != null ) { final int current ; final int upcomingOffset ; if ( mShouldReverseLayout ) { current = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( existing ) ; upcomingOffset = current - mPendingScrollPositionOffset ; } else { current = mOrientationHelper . getDecoratedStart ( existing ) - mOrientationHelper . getStartAfterPadding ( ) ; upcomingOffset = mPendingScrollPositionOffset - current ; } if ( upcomingOffset > <NUM_LIT> ) { extraForStart += upcomingOffset ; } else { extraForEnd -= upcomingOffset ; } } } int startOffset ; int endOffset ; final int firstLayoutDirection ; if ( mAnchorInfo . mLayoutFromEnd ) { firstLayoutDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; } else { firstLayoutDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; } onAnchorReady ( recycler , state , mAnchorInfo , firstLayoutDirection ) ; detachAndScrapAttachedViews ( recycler ) ; mLayoutState . mInfinite = resolveIsInfinite ( ) ; mLayoutState . mIsPreLayout = state . isPreLayout ( ) ; mLayoutState . mNoRecycleSpace = <NUM_LIT> ; if ( mAnchorInfo . mLayoutFromEnd ) { updateLayoutStateToFillStart ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForStart ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; final int firstElement = mLayoutState . mCurrentPosition ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForEnd += mLayoutState . mAvailable ; } updateLayoutStateToFillEnd ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForEnd ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForStart = mLayoutState . mAvailable ; updateLayoutStateToFillStart ( firstElement , startOffset ) ; mLayoutState . mExtraFillSpace = extraForStart ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; } } else { updateLayoutStateToFillEnd ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForEnd ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; final int lastElement = mLayoutState . mCurrentPosition ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForStart += mLayoutState . mAvailable ; } updateLayoutStateToFillStart ( mAnchorInfo ) ; mLayoutState . mExtraFillSpace = extraForStart ; mLayoutState . mCurrentPosition += mLayoutState . mItemDirection ; fill ( recycler , mLayoutState , state , false ) ; startOffset = mLayoutState . mOffset ; if ( mLayoutState . mAvailable > <NUM_LIT> ) { extraForEnd = mLayoutState . mAvailable ; updateLayoutStateToFillEnd ( lastElement , endOffset ) ; mLayoutState . mExtraFillSpace = extraForEnd ; fill ( recycler , mLayoutState , state , false ) ; endOffset = mLayoutState . mOffset ; } } if ( getChildCount ( ) > <NUM_LIT> ) { if ( mShouldReverseLayout ^ mStackFromEnd ) { int fixOffset = fixLayoutEndGap ( endOffset , recycler , state , true ) ; startOffset += fixOffset ; endOffset += fixOffset ; fixOffset = fixLayoutStartGap ( startOffset , recycler , state , false ) ; startOffset += fixOffset ; endOffset += fixOffset ; } else { int fixOffset = fixLayoutStartGap ( startOffset , recycler , state , true ) ; startOffset += fixOffset ; endOffset += fixOffset ; fixOffset = fixLayoutEndGap ( endOffset , recycler , state , false ) ; startOffset += fixOffset ; endOffset += fixOffset ; } } layoutForPredictiveAnimations ( recycler , state , startOffset , endOffset ) ; if ( ! state . isPreLayout ( ) ) { mOrientationHelper . onLayoutComplete ( ) ; } else { mAnchorInfo . reset ( ) ; } mLastStackFromEnd = mStackFromEnd ; if ( DEBUG ) { validateChildOrder ( ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void onLayoutCompleted ( RecyclerView . State state ) { super . onLayoutCompleted ( state ) ; mPendingSavedState = null ; mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; mAnchorInfo . reset ( ) ; } void onAnchorReady ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo , int firstLayoutItemDirection ) { } private void layoutForPredictiveAnimations ( RecyclerView . Recycler recycler , RecyclerView . State state , int startOffset , int endOffset ) { if ( ! state . willRunPredictiveAnimations ( ) || getChildCount ( ) == <NUM_LIT> || state . isPreLayout ( ) || ! supportsPredictiveItemAnimations ( ) ) { return ; } int scrapExtraStart = <NUM_LIT> , scrapExtraEnd = <NUM_LIT> ; final List < RecyclerView . ViewHolder > scrapList = recycler . getScrapList ( ) ; final int scrapSize = scrapList . size ( ) ; final int firstChildPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; for ( int i = <NUM_LIT> ; i < scrapSize ; i ++ ) { RecyclerView . ViewHolder scrap = scrapList . get ( i ) ; if ( scrap . isRemoved ( ) ) { continue ; } final int position = scrap . getLayoutPosition ( ) ; final int direction = position < firstChildPos != mShouldReverseLayout ? LayoutState . LAYOUT_START : LayoutState . LAYOUT_END ; if ( direction == LayoutState . LAYOUT_START ) { scrapExtraStart += mOrientationHelper . getDecoratedMeasurement ( scrap . itemView ) ; } else { scrapExtraEnd += mOrientationHelper . getDecoratedMeasurement ( scrap . itemView ) ; } } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + scrapExtraStart + "<STR_LIT>" + scrapExtraEnd + "<STR_LIT>" ) ; } mLayoutState . mScrapList = scrapList ; if ( scrapExtraStart > <NUM_LIT> ) { View anchor = getChildClosestToStart ( ) ; updateLayoutStateToFillStart ( getPosition ( anchor ) , startOffset ) ; mLayoutState . mExtraFillSpace = scrapExtraStart ; mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . assignPositionFromScrapList ( ) ; fill ( recycler , mLayoutState , state , false ) ; } if ( scrapExtraEnd > <NUM_LIT> ) { View anchor = getChildClosestToEnd ( ) ; updateLayoutStateToFillEnd ( getPosition ( anchor ) , endOffset ) ; mLayoutState . mExtraFillSpace = scrapExtraEnd ; mLayoutState . mAvailable = <NUM_LIT> ; mLayoutState . assignPositionFromScrapList ( ) ; fill ( recycler , mLayoutState , state , false ) ; } mLayoutState . mScrapList = null ; } private void updateAnchorInfoForLayout ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo ) { if ( updateAnchorFromPendingData ( state , anchorInfo ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return ; } if ( updateAnchorFromChildren ( recycler , state , anchorInfo ) ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } anchorInfo . assignCoordinateFromPadding ( ) ; anchorInfo . mPosition = mStackFromEnd ? state . getItemCount ( ) - <NUM_LIT> : <NUM_LIT> ; } private boolean updateAnchorFromChildren ( RecyclerView . Recycler recycler , RecyclerView . State state , AnchorInfo anchorInfo ) { if ( getChildCount ( ) == <NUM_LIT> ) { return false ; } final View focused = getFocusedChild ( ) ; if ( focused != null && anchorInfo . isViewValidAsAnchor ( focused , state ) ) { anchorInfo . assignFromViewAndKeepVisibleRect ( focused , getPosition ( focused ) ) ; return true ; } if ( mLastStackFromEnd != mStackFromEnd ) { return false ; } View referenceChild = findReferenceChild ( recycler , state , anchorInfo . mLayoutFromEnd , mStackFromEnd ) ; if ( referenceChild != null ) { anchorInfo . assignFromView ( referenceChild , getPosition ( referenceChild ) ) ; if ( ! state . isPreLayout ( ) && supportsPredictiveItemAnimations ( ) ) { final int childStart = mOrientationHelper . getDecoratedStart ( referenceChild ) ; final int childEnd = mOrientationHelper . getDecoratedEnd ( referenceChild ) ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; boolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart ; boolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd ; if ( outOfBoundsBefore || outOfBoundsAfter ) { anchorInfo . mCoordinate = anchorInfo . mLayoutFromEnd ? boundsEnd : boundsStart ; } } return true ; } return false ; } private boolean updateAnchorFromPendingData ( RecyclerView . State state , AnchorInfo anchorInfo ) { if ( state . isPreLayout ( ) || mPendingScrollPosition == RecyclerView . NO_POSITION ) { return false ; } if ( mPendingScrollPosition < <NUM_LIT> || mPendingScrollPosition >= state . getItemCount ( ) ) { mPendingScrollPosition = RecyclerView . NO_POSITION ; mPendingScrollPositionOffset = INVALID_OFFSET ; if ( DEBUG ) { Log . e ( TAG , "<STR_LIT>" + mPendingScrollPosition ) ; } return false ; } anchorInfo . mPosition = mPendingScrollPosition ; if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { anchorInfo . mLayoutFromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; if ( anchorInfo . mLayoutFromEnd ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - mPendingSavedState . mAnchorOffset ; } else { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) + mPendingSavedState . mAnchorOffset ; } return true ; } if ( mPendingScrollPositionOffset == INVALID_OFFSET ) { View child = findViewByPosition ( mPendingScrollPosition ) ; if ( child != null ) { final int childSize = mOrientationHelper . getDecoratedMeasurement ( child ) ; if ( childSize > mOrientationHelper . getTotalSpace ( ) ) { anchorInfo . assignCoordinateFromPadding ( ) ; return true ; } final int startGap = mOrientationHelper . getDecoratedStart ( child ) - mOrientationHelper . getStartAfterPadding ( ) ; if ( startGap < <NUM_LIT> ) { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) ; anchorInfo . mLayoutFromEnd = false ; return true ; } final int endGap = mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( child ) ; if ( endGap < <NUM_LIT> ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) ; anchorInfo . mLayoutFromEnd = true ; return true ; } anchorInfo . mCoordinate = anchorInfo . mLayoutFromEnd ? ( mOrientationHelper . getDecoratedEnd ( child ) + mOrientationHelper . getTotalSpaceChange ( ) ) : mOrientationHelper . getDecoratedStart ( child ) ; } else { if ( getChildCount ( ) > <NUM_LIT> ) { int pos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; anchorInfo . mLayoutFromEnd = mPendingScrollPosition < pos == mShouldReverseLayout ; } anchorInfo . assignCoordinateFromPadding ( ) ; } return true ; } anchorInfo . mLayoutFromEnd = mShouldReverseLayout ; if ( mShouldReverseLayout ) { anchorInfo . mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - mPendingScrollPositionOffset ; } else { anchorInfo . mCoordinate = mOrientationHelper . getStartAfterPadding ( ) + mPendingScrollPositionOffset ; } return true ; } private int fixLayoutEndGap ( int endOffset , RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { int gap = mOrientationHelper . getEndAfterPadding ( ) - endOffset ; int fixOffset = <NUM_LIT> ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( - gap , recycler , state ) ; } else { return <NUM_LIT> ; } endOffset += fixOffset ; if ( canOffsetChildren ) { gap = mOrientationHelper . getEndAfterPadding ( ) - endOffset ; if ( gap > <NUM_LIT> ) { mOrientationHelper . offsetChildren ( gap ) ; return gap + fixOffset ; } } return fixOffset ; } private int fixLayoutStartGap ( int startOffset , RecyclerView . Recycler recycler , RecyclerView . State state , boolean canOffsetChildren ) { int gap = startOffset - mOrientationHelper . getStartAfterPadding ( ) ; int fixOffset = <NUM_LIT> ; if ( gap > <NUM_LIT> ) { fixOffset = - scrollBy ( gap , recycler , state ) ; } else { return <NUM_LIT> ; } startOffset += fixOffset ; if ( canOffsetChildren ) { gap = startOffset - mOrientationHelper . getStartAfterPadding ( ) ; if ( gap > <NUM_LIT> ) { mOrientationHelper . offsetChildren ( - gap ) ; return fixOffset - gap ; } } return fixOffset ; } private void updateLayoutStateToFillEnd ( AnchorInfo anchorInfo ) { updateLayoutStateToFillEnd ( anchorInfo . mPosition , anchorInfo . mCoordinate ) ; } private void updateLayoutStateToFillEnd ( int itemPosition , int offset ) { mLayoutState . mAvailable = mOrientationHelper . getEndAfterPadding ( ) - offset ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; mLayoutState . mCurrentPosition = itemPosition ; mLayoutState . mLayoutDirection = LayoutState . LAYOUT_END ; mLayoutState . mOffset = offset ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; } private void updateLayoutStateToFillStart ( AnchorInfo anchorInfo ) { updateLayoutStateToFillStart ( anchorInfo . mPosition , anchorInfo . mCoordinate ) ; } private void updateLayoutStateToFillStart ( int itemPosition , int offset ) { mLayoutState . mAvailable = offset - mOrientationHelper . getStartAfterPadding ( ) ; mLayoutState . mCurrentPosition = itemPosition ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; mLayoutState . mLayoutDirection = LayoutState . LAYOUT_START ; mLayoutState . mOffset = offset ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; } protected boolean isLayoutRTL ( ) { return getLayoutDirection ( ) == ViewCompat . LAYOUT_DIRECTION_RTL ; } void ensureLayoutState ( ) { if ( mLayoutState == null ) { mLayoutState = createLayoutState ( ) ; } } LayoutState createLayoutState ( ) { return new LayoutState ( ) ; } @ Override public void scrollToPosition ( int position ) { mPendingScrollPosition = position ; mPendingScrollPositionOffset = INVALID_OFFSET ; if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; } public void scrollToPositionWithOffset ( int position , int offset ) { mPendingScrollPosition = position ; mPendingScrollPositionOffset = offset ; if ( mPendingSavedState != null ) { mPendingSavedState . invalidateAnchor ( ) ; } requestLayout ( ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int scrollHorizontallyBy ( int dx , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == VERTICAL ) { return <NUM_LIT> ; } return scrollBy ( dx , recycler , state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int scrollVerticallyBy ( int dy , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( mOrientation == HORIZONTAL ) { return <NUM_LIT> ; } return scrollBy ( dy , recycler , state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollOffset ( RecyclerView . State state ) { return computeScrollOffset ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollExtent ( RecyclerView . State state ) { return computeScrollExtent ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeHorizontalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public int computeVerticalScrollRange ( RecyclerView . State state ) { return computeScrollRange ( state ) ; } private int computeScrollOffset ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollOffset ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled , mShouldReverseLayout ) ; } private int computeScrollExtent ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollExtent ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled ) ; } private int computeScrollRange ( RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; return ScrollbarHelper . computeScrollRange ( state , mOrientationHelper , findFirstVisibleChildClosestToStart ( ! mSmoothScrollbarEnabled , true ) , findFirstVisibleChildClosestToEnd ( ! mSmoothScrollbarEnabled , true ) , this , mSmoothScrollbarEnabled ) ; } public void setSmoothScrollbarEnabled ( boolean enabled ) { mSmoothScrollbarEnabled = enabled ; } public boolean isSmoothScrollbarEnabled ( ) { return mSmoothScrollbarEnabled ; } private void updateLayoutState ( int layoutDirection , int requiredSpace , boolean canUseExistingSpace , RecyclerView . State state ) { mLayoutState . mInfinite = resolveIsInfinite ( ) ; mLayoutState . mLayoutDirection = layoutDirection ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; mReusableIntPair [ <NUM_LIT> ] = <NUM_LIT> ; calculateExtraLayoutSpace ( state , mReusableIntPair ) ; int extraForStart = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) ; int extraForEnd = Math . max ( <NUM_LIT> , mReusableIntPair [ <NUM_LIT> ] ) ; boolean layoutToEnd = layoutDirection == LayoutState . LAYOUT_END ; mLayoutState . mExtraFillSpace = layoutToEnd ? extraForEnd : extraForStart ; mLayoutState . mNoRecycleSpace = layoutToEnd ? extraForStart : extraForEnd ; int scrollingOffset ; if ( layoutToEnd ) { mLayoutState . mExtraFillSpace += mOrientationHelper . getEndPadding ( ) ; final View child = getChildClosestToEnd ( ) ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; mLayoutState . mCurrentPosition = getPosition ( child ) + mLayoutState . mItemDirection ; mLayoutState . mOffset = mOrientationHelper . getDecoratedEnd ( child ) ; scrollingOffset = mOrientationHelper . getDecoratedEnd ( child ) - mOrientationHelper . getEndAfterPadding ( ) ; } else { final View child = getChildClosestToStart ( ) ; mLayoutState . mExtraFillSpace += mOrientationHelper . getStartAfterPadding ( ) ; mLayoutState . mItemDirection = mShouldReverseLayout ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; mLayoutState . mCurrentPosition = getPosition ( child ) + mLayoutState . mItemDirection ; mLayoutState . mOffset = mOrientationHelper . getDecoratedStart ( child ) ; scrollingOffset = - mOrientationHelper . getDecoratedStart ( child ) + mOrientationHelper . getStartAfterPadding ( ) ; } mLayoutState . mAvailable = requiredSpace ; if ( canUseExistingSpace ) { mLayoutState . mAvailable -= scrollingOffset ; } mLayoutState . mScrollingOffset = scrollingOffset ; } boolean resolveIsInfinite ( ) { return mOrientationHelper . getMode ( ) == View . MeasureSpec . UNSPECIFIED && mOrientationHelper . getEnd ( ) == <NUM_LIT> ; } void collectPrefetchPositionsForLayoutState ( RecyclerView . State state , LayoutState layoutState , LayoutPrefetchRegistry layoutPrefetchRegistry ) { final int pos = layoutState . mCurrentPosition ; if ( pos >= <NUM_LIT> && pos < state . getItemCount ( ) ) { layoutPrefetchRegistry . addPosition ( pos , Math . max ( <NUM_LIT> , layoutState . mScrollingOffset ) ) ; } } @ Override @ SuppressLint ( "<STR_LIT>" ) public void collectInitialPrefetchPositions ( int adapterItemCount , LayoutPrefetchRegistry layoutPrefetchRegistry ) { final boolean fromEnd ; final int anchorPos ; if ( mPendingSavedState != null && mPendingSavedState . hasValidAnchor ( ) ) { fromEnd = mPendingSavedState . mAnchorLayoutFromEnd ; anchorPos = mPendingSavedState . mAnchorPosition ; } else { resolveShouldLayoutReverse ( ) ; fromEnd = mShouldReverseLayout ; if ( mPendingScrollPosition == RecyclerView . NO_POSITION ) { anchorPos = fromEnd ? adapterItemCount - <NUM_LIT> : <NUM_LIT> ; } else { anchorPos = mPendingScrollPosition ; } } final int direction = fromEnd ? LayoutState . ITEM_DIRECTION_HEAD : LayoutState . ITEM_DIRECTION_TAIL ; int targetPos = anchorPos ; for ( int i = <NUM_LIT> ; i < mInitialPrefetchItemCount ; i ++ ) { if ( targetPos >= <NUM_LIT> && targetPos < adapterItemCount ) { layoutPrefetchRegistry . addPosition ( targetPos , <NUM_LIT> ) ; } else { break ; } targetPos += direction ; } } public void setInitialPrefetchItemCount ( int itemCount ) { mInitialPrefetchItemCount = itemCount ; } public int getInitialPrefetchItemCount ( ) { return mInitialPrefetchItemCount ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void collectAdjacentPrefetchPositions ( int dx , int dy , RecyclerView . State state , LayoutPrefetchRegistry layoutPrefetchRegistry ) { int delta = ( mOrientation == HORIZONTAL ) ? dx : dy ; if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return ; } ensureLayoutState ( ) ; final int layoutDirection = delta > <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; final int absDelta = Math . abs ( delta ) ; updateLayoutState ( layoutDirection , absDelta , true , state ) ; collectPrefetchPositionsForLayoutState ( state , mLayoutState , layoutPrefetchRegistry ) ; } int scrollBy ( int delta , RecyclerView . Recycler recycler , RecyclerView . State state ) { if ( getChildCount ( ) == <NUM_LIT> || delta == <NUM_LIT> ) { return <NUM_LIT> ; } ensureLayoutState ( ) ; mLayoutState . mRecycle = true ; final int layoutDirection = delta > <NUM_LIT> ? LayoutState . LAYOUT_END : LayoutState . LAYOUT_START ; final int absDelta = Math . abs ( delta ) ; updateLayoutState ( layoutDirection , absDelta , true , state ) ; final int consumed = mLayoutState . mScrollingOffset + fill ( recycler , mLayoutState , state , false ) ; if ( consumed < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } return <NUM_LIT> ; } final int scrolled = absDelta > consumed ? layoutDirection * consumed : delta ; mOrientationHelper . offsetChildren ( - scrolled ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + delta + "<STR_LIT>" + scrolled ) ; } mLayoutState . mLastScrollDelta = scrolled ; return scrolled ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void assertNotInLayoutOrScroll ( String message ) { if ( mPendingSavedState == null ) { super . assertNotInLayoutOrScroll ( message ) ; } } private void recycleChildren ( RecyclerView . Recycler recycler , int startIndex , int endIndex ) { if ( startIndex == endIndex ) { return ; } if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + Math . abs ( startIndex - endIndex ) + "<STR_LIT>" ) ; } if ( endIndex > startIndex ) { for ( int i = endIndex - <NUM_LIT> ; i >= startIndex ; i -- ) { removeAndRecycleViewAt ( i , recycler ) ; } } else { for ( int i = startIndex ; i > endIndex ; i -- ) { removeAndRecycleViewAt ( i , recycler ) ; } } } private void recycleViewsFromStart ( RecyclerView . Recycler recycler , int scrollingOffset , int noRecycleSpace ) { if ( scrollingOffset < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } return ; } final int limit = scrollingOffset - noRecycleSpace ; final int childCount = getChildCount ( ) ; if ( mShouldReverseLayout ) { for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedEnd ( child ) > limit || mOrientationHelper . getTransformedEndWithDecoration ( child ) > limit ) { recycleChildren ( recycler , childCount - <NUM_LIT> , i ) ; return ; } } } else { for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedEnd ( child ) > limit || mOrientationHelper . getTransformedEndWithDecoration ( child ) > limit ) { recycleChildren ( recycler , <NUM_LIT> , i ) ; return ; } } } } private void recycleViewsFromEnd ( RecyclerView . Recycler recycler , int scrollingOffset , int noRecycleSpace ) { final int childCount = getChildCount ( ) ; if ( scrollingOffset < <NUM_LIT> ) { if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + "<STR_LIT>" ) ; } return ; } final int limit = mOrientationHelper . getEnd ( ) - scrollingOffset + noRecycleSpace ; if ( mShouldReverseLayout ) { for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit || mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { recycleChildren ( recycler , <NUM_LIT> , i ) ; return ; } } } else { for ( int i = childCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit || mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { recycleChildren ( recycler , childCount - <NUM_LIT> , i ) ; return ; } } } } private void recycleByLayoutState ( RecyclerView . Recycler recycler , LayoutState layoutState ) { if ( ! layoutState . mRecycle || layoutState . mInfinite ) { return ; } int scrollingOffset = layoutState . mScrollingOffset ; int noRecycleSpace = layoutState . mNoRecycleSpace ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { recycleViewsFromEnd ( recycler , scrollingOffset , noRecycleSpace ) ; } else { recycleViewsFromStart ( recycler , scrollingOffset , noRecycleSpace ) ; } } int fill ( RecyclerView . Recycler recycler , LayoutState layoutState , RecyclerView . State state , boolean stopOnFocusable ) { final int start = layoutState . mAvailable ; if ( layoutState . mScrollingOffset != LayoutState . SCROLLING_OFFSET_NaN ) { if ( layoutState . mAvailable < <NUM_LIT> ) { layoutState . mScrollingOffset += layoutState . mAvailable ; } recycleByLayoutState ( recycler , layoutState ) ; } int remainingSpace = layoutState . mAvailable + layoutState . mExtraFillSpace ; LayoutChunkResult layoutChunkResult = mLayoutChunkResult ; while ( ( layoutState . mInfinite || remainingSpace > <NUM_LIT> ) && layoutState . hasMore ( state ) ) { layoutChunkResult . resetInternal ( ) ; if ( RecyclerView . VERBOSE_TRACING ) { TraceCompat . beginSection ( "<STR_LIT>" ) ; } layoutChunk ( recycler , state , layoutState , layoutChunkResult ) ; if ( RecyclerView . VERBOSE_TRACING ) { TraceCompat . endSection ( ) ; } if ( layoutChunkResult . mFinished ) { break ; } layoutState . mOffset += layoutChunkResult . mConsumed * layoutState . mLayoutDirection ; if ( ! layoutChunkResult . mIgnoreConsumed || layoutState . mScrapList != null || ! state . isPreLayout ( ) ) { layoutState . mAvailable -= layoutChunkResult . mConsumed ; remainingSpace -= layoutChunkResult . mConsumed ; } if ( layoutState . mScrollingOffset != LayoutState . SCROLLING_OFFSET_NaN ) { layoutState . mScrollingOffset += layoutChunkResult . mConsumed ; if ( layoutState . mAvailable < <NUM_LIT> ) { layoutState . mScrollingOffset += layoutState . mAvailable ; } recycleByLayoutState ( recycler , layoutState ) ; } if ( stopOnFocusable && layoutChunkResult . mFocusable ) { break ; } } if ( DEBUG ) { validateChildOrder ( ) ; } return start - layoutState . mAvailable ; } void layoutChunk ( RecyclerView . Recycler recycler , RecyclerView . State state , LayoutState layoutState , LayoutChunkResult result ) { View view = layoutState . next ( recycler ) ; if ( view == null ) { if ( DEBUG && layoutState . mScrapList == null ) { throw new RuntimeException ( "<STR_LIT>" ) ; } result . mFinished = true ; return ; } RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( layoutState . mScrapList == null ) { if ( mShouldReverseLayout == ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) ) { addView ( view ) ; } else { addView ( view , <NUM_LIT> ) ; } } else { if ( mShouldReverseLayout == ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) ) { addDisappearingView ( view ) ; } else { addDisappearingView ( view , <NUM_LIT> ) ; } } measureChildWithMargins ( view , <NUM_LIT> , <NUM_LIT> ) ; result . mConsumed = mOrientationHelper . getDecoratedMeasurement ( view ) ; int left , top , right , bottom ; if ( mOrientation == VERTICAL ) { if ( isLayoutRTL ( ) ) { right = getWidth ( ) - getPaddingRight ( ) ; left = right - mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } else { left = getPaddingLeft ( ) ; right = left + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; } if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { bottom = layoutState . mOffset ; top = layoutState . mOffset - result . mConsumed ; } else { top = layoutState . mOffset ; bottom = layoutState . mOffset + result . mConsumed ; } } else { top = getPaddingTop ( ) ; bottom = top + mOrientationHelper . getDecoratedMeasurementInOther ( view ) ; if ( layoutState . mLayoutDirection == LayoutState . LAYOUT_START ) { right = layoutState . mOffset ; left = layoutState . mOffset - result . mConsumed ; } else { left = layoutState . mOffset ; right = layoutState . mOffset + result . mConsumed ; } } layoutDecoratedWithMargins ( view , left , top , right , bottom ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + getPosition ( view ) + "<STR_LIT>" + ( left + params . leftMargin ) + "<STR_LIT>" + ( top + params . topMargin ) + "<STR_LIT>" + ( right - params . rightMargin ) + "<STR_LIT>" + ( bottom - params . bottomMargin ) ) ; } if ( params . isItemRemoved ( ) || params . isItemChanged ( ) ) { result . mIgnoreConsumed = true ; } result . mFocusable = view . hasFocusable ( ) ; } @ Override boolean shouldMeasureTwice ( ) { return getHeightMode ( ) != View . MeasureSpec . EXACTLY && getWidthMode ( ) != View . MeasureSpec . EXACTLY && hasFlexibleChildInBothOrientations ( ) ; } int convertFocusDirectionToLayoutDirection ( int focusDirection ) { switch ( focusDirection ) { case View . FOCUS_BACKWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_START ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_END ; } else { return LayoutState . LAYOUT_START ; } case View . FOCUS_FORWARD : if ( mOrientation == VERTICAL ) { return LayoutState . LAYOUT_END ; } else if ( isLayoutRTL ( ) ) { return LayoutState . LAYOUT_START ; } else { return LayoutState . LAYOUT_END ; } case View . FOCUS_UP : return mOrientation == VERTICAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_DOWN : return mOrientation == VERTICAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; case View . FOCUS_LEFT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_START : LayoutState . INVALID_LAYOUT ; case View . FOCUS_RIGHT : return mOrientation == HORIZONTAL ? LayoutState . LAYOUT_END : LayoutState . INVALID_LAYOUT ; default : if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + focusDirection ) ; } return LayoutState . INVALID_LAYOUT ; } } private View getChildClosestToStart ( ) { return getChildAt ( mShouldReverseLayout ? getChildCount ( ) - <NUM_LIT> : <NUM_LIT> ) ; } private View getChildClosestToEnd ( ) { return getChildAt ( mShouldReverseLayout ? <NUM_LIT> : getChildCount ( ) - <NUM_LIT> ) ; } View findFirstVisibleChildClosestToStart ( boolean completelyVisible , boolean acceptPartiallyVisible ) { if ( mShouldReverseLayout ) { return findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , completelyVisible , acceptPartiallyVisible ) ; } else { return findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , completelyVisible , acceptPartiallyVisible ) ; } } View findFirstVisibleChildClosestToEnd ( boolean completelyVisible , boolean acceptPartiallyVisible ) { if ( mShouldReverseLayout ) { return findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , completelyVisible , acceptPartiallyVisible ) ; } else { return findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , completelyVisible , acceptPartiallyVisible ) ; } } View findReferenceChild ( RecyclerView . Recycler recycler , RecyclerView . State state , boolean layoutFromEnd , boolean traverseChildrenInReverseOrder ) { ensureLayoutState ( ) ; int start = <NUM_LIT> ; int end = getChildCount ( ) ; int diff = <NUM_LIT> ; if ( traverseChildrenInReverseOrder ) { start = getChildCount ( ) - <NUM_LIT> ; end = - <NUM_LIT> ; diff = - <NUM_LIT> ; } int itemCount = state . getItemCount ( ) ; final int boundsStart = mOrientationHelper . getStartAfterPadding ( ) ; final int boundsEnd = mOrientationHelper . getEndAfterPadding ( ) ; View invalidMatch = null ; View bestFirstFind = null ; View bestSecondFind = null ; for ( int i = start ; i != end ; i += diff ) { final View view = getChildAt ( i ) ; final int position = getPosition ( view ) ; final int childStart = mOrientationHelper . getDecoratedStart ( view ) ; final int childEnd = mOrientationHelper . getDecoratedEnd ( view ) ; if ( position >= <NUM_LIT> && position < itemCount ) { if ( ( ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ) . isItemRemoved ( ) ) { if ( invalidMatch == null ) { invalidMatch = view ; } } else { boolean outOfBoundsBefore = childEnd <= boundsStart && childStart < boundsStart ; boolean outOfBoundsAfter = childStart >= boundsEnd && childEnd > boundsEnd ; if ( outOfBoundsBefore || outOfBoundsAfter ) { if ( layoutFromEnd ) { if ( outOfBoundsAfter ) { bestFirstFind = view ; } else if ( bestSecondFind == null ) { bestSecondFind = view ; } } else { if ( outOfBoundsBefore ) { bestFirstFind = view ; } else if ( bestSecondFind == null ) { bestSecondFind = view ; } } } else { return view ; } } } } return bestSecondFind != null ? bestSecondFind : ( bestFirstFind != null ? bestFirstFind : invalidMatch ) ; } private View findPartiallyOrCompletelyInvisibleChildClosestToEnd ( ) { return mShouldReverseLayout ? findFirstPartiallyOrCompletelyInvisibleChild ( ) : findLastPartiallyOrCompletelyInvisibleChild ( ) ; } private View findPartiallyOrCompletelyInvisibleChildClosestToStart ( ) { return mShouldReverseLayout ? findLastPartiallyOrCompletelyInvisibleChild ( ) : findFirstPartiallyOrCompletelyInvisibleChild ( ) ; } private View findFirstPartiallyOrCompletelyInvisibleChild ( ) { return findOnePartiallyOrCompletelyInvisibleChild ( <NUM_LIT> , getChildCount ( ) ) ; } private View findLastPartiallyOrCompletelyInvisibleChild ( ) { return findOnePartiallyOrCompletelyInvisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> ) ; } public int findFirstVisibleItemPosition ( ) { final View child = findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , false , true ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findFirstCompletelyVisibleItemPosition ( ) { final View child = findOneVisibleChild ( <NUM_LIT> , getChildCount ( ) , true , false ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findLastVisibleItemPosition ( ) { final View child = findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , false , true ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } public int findLastCompletelyVisibleItemPosition ( ) { final View child = findOneVisibleChild ( getChildCount ( ) - <NUM_LIT> , - <NUM_LIT> , true , false ) ; return child == null ? RecyclerView . NO_POSITION : getPosition ( child ) ; } View findOneVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible , boolean acceptPartiallyVisible ) { ensureLayoutState ( ) ; @ ViewBoundsCheck . ViewBounds int preferredBoundsFlag = <NUM_LIT> ; @ ViewBoundsCheck . ViewBounds int acceptableBoundsFlag = <NUM_LIT> ; if ( completelyVisible ) { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_EQ_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_EQ_PVE ) ; } else { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; } if ( acceptPartiallyVisible ) { acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; } return ( mOrientation == HORIZONTAL ) ? mHorizontalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) : mVerticalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) ; } View findOnePartiallyOrCompletelyInvisibleChild ( int fromIndex , int toIndex ) { ensureLayoutState ( ) ; final int next = toIndex > fromIndex ? <NUM_LIT> : ( toIndex < fromIndex ? - <NUM_LIT> : <NUM_LIT> ) ; if ( next == <NUM_LIT> ) { return getChildAt ( fromIndex ) ; } @ ViewBoundsCheck . ViewBounds int preferredBoundsFlag = <NUM_LIT> ; @ ViewBoundsCheck . ViewBounds int acceptableBoundsFlag = <NUM_LIT> ; if ( mOrientationHelper . getDecoratedStart ( getChildAt ( fromIndex ) ) < mOrientationHelper . getStartAfterPadding ( ) ) { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE | ViewBoundsCheck . FLAG_CVE_GT_PVS ) ; acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVS_LT_PVS | ViewBoundsCheck . FLAG_CVE_LT_PVE ) ; } else { preferredBoundsFlag = ( ViewBoundsCheck . FLAG_CVE_GT_PVE | ViewBoundsCheck . FLAG_CVS_GT_PVS | ViewBoundsCheck . FLAG_CVS_LT_PVE ) ; acceptableBoundsFlag = ( ViewBoundsCheck . FLAG_CVE_GT_PVE | ViewBoundsCheck . FLAG_CVS_GT_PVS ) ; } return ( mOrientation == HORIZONTAL ) ? mHorizontalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) : mVerticalBoundCheck . findOneViewWithinBoundFlags ( fromIndex , toIndex , preferredBoundsFlag , acceptableBoundsFlag ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public View onFocusSearchFailed ( View focused , int direction , RecyclerView . Recycler recycler , RecyclerView . State state ) { resolveShouldLayoutReverse ( ) ; if ( getChildCount ( ) == <NUM_LIT> ) { return null ; } final int layoutDir = convertFocusDirectionToLayoutDirection ( direction ) ; if ( layoutDir == LayoutState . INVALID_LAYOUT ) { return null ; } ensureLayoutState ( ) ; final int maxScroll = ( int ) ( MAX_SCROLL_FACTOR * mOrientationHelper . getTotalSpace ( ) ) ; updateLayoutState ( layoutDir , maxScroll , false , state ) ; mLayoutState . mScrollingOffset = LayoutState . SCROLLING_OFFSET_NaN ; mLayoutState . mRecycle = false ; fill ( recycler , mLayoutState , state , true ) ; final View nextCandidate ; if ( layoutDir == LayoutState . LAYOUT_START ) { nextCandidate = findPartiallyOrCompletelyInvisibleChildClosestToStart ( ) ; } else { nextCandidate = findPartiallyOrCompletelyInvisibleChildClosestToEnd ( ) ; } final View nextFocus ; if ( layoutDir == LayoutState . LAYOUT_START ) { nextFocus = getChildClosestToStart ( ) ; } else { nextFocus = getChildClosestToEnd ( ) ; } if ( nextFocus . hasFocusable ( ) ) { if ( nextCandidate == null ) { return null ; } return nextFocus ; } return nextCandidate ; } private void logChildren ( ) { Log . d ( TAG , "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; Log . d ( TAG , "<STR_LIT>" + getPosition ( child ) + "<STR_LIT>" + mOrientationHelper . getDecoratedStart ( child ) ) ; } Log . d ( TAG , "<STR_LIT>" ) ; } void validateChildOrder ( ) { Log . d ( TAG , "<STR_LIT>" + getChildCount ( ) ) ; if ( getChildCount ( ) < <NUM_LIT> ) { return ; } int lastPos = getPosition ( getChildAt ( <NUM_LIT> ) ) ; int lastScreenLoc = mOrientationHelper . getDecoratedStart ( getChildAt ( <NUM_LIT> ) ) ; if ( mShouldReverseLayout ) { for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int pos = getPosition ( child ) ; int screenLoc = mOrientationHelper . getDecoratedStart ( child ) ; if ( pos < lastPos ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" + ( screenLoc < lastScreenLoc ) ) ; } if ( screenLoc > lastScreenLoc ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } } } else { for ( int i = <NUM_LIT> ; i < getChildCount ( ) ; i ++ ) { View child = getChildAt ( i ) ; int pos = getPosition ( child ) ; int screenLoc = mOrientationHelper . getDecoratedStart ( child ) ; if ( pos < lastPos ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" + ( screenLoc < lastScreenLoc ) ) ; } if ( screenLoc < lastScreenLoc ) { logChildren ( ) ; throw new RuntimeException ( "<STR_LIT>" ) ; } } } } @ Override public boolean supportsPredictiveItemAnimations ( ) { return mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd ; } @ Override public void prepareForDrop ( @ NonNull View view , @ NonNull View target , int x , int y ) { assertNotInLayoutOrScroll ( "<STR_LIT>" ) ; ensureLayoutState ( ) ; resolveShouldLayoutReverse ( ) ; final int myPos = getPosition ( view ) ; final int targetPos = getPosition ( target ) ; final int dropDirection = myPos < targetPos ? LayoutState . ITEM_DIRECTION_TAIL : LayoutState . ITEM_DIRECTION_HEAD ; if ( mShouldReverseLayout ) { if ( dropDirection == LayoutState . ITEM_DIRECTION_TAIL ) { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getEndAfterPadding ( ) - ( mOrientationHelper . getDecoratedStart ( target ) + mOrientationHelper . getDecoratedMeasurement ( view ) ) ) ; } else { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getEndAfterPadding ( ) - mOrientationHelper . getDecoratedEnd ( target ) ) ; } } else { if ( dropDirection == LayoutState . ITEM_DIRECTION_HEAD ) { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getDecoratedStart ( target ) ) ; } else { scrollToPositionWithOffset ( targetPos , mOrientationHelper . getDecoratedEnd ( target ) - mOrientationHelper . getDecoratedMeasurement ( view ) ) ; } } } static class LayoutState { static final String TAG = "<STR_LIT>" ; static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; static final int SCROLLING_OFFSET_NaN = Integer . MIN_VALUE ; boolean mRecycle = true ; int mOffset ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mScrollingOffset ; int mExtraFillSpace = <NUM_LIT> ; int mNoRecycleSpace = <NUM_LIT> ; boolean mIsPreLayout = false ; int mLastScrollDelta ; List < RecyclerView . ViewHolder > mScrapList = null ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ; } View next ( RecyclerView . Recycler recycler ) { if ( mScrapList != null ) { return nextViewFromScrapList ( ) ; } final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } private View nextViewFromScrapList ( ) { final int size = mScrapList . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { final View view = mScrapList . get ( i ) . itemView ; final RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( lp . isItemRemoved ( ) ) { continue ; } if ( mCurrentPosition == lp . getViewLayoutPosition ( ) ) { assignPositionFromScrapList ( view ) ; return view ; } } return null ; } public void assignPositionFromScrapList ( ) { assignPositionFromScrapList ( null ) ; } public void assignPositionFromScrapList ( View ignore ) { final View closest = nextViewInLimitedList ( ignore ) ; if ( closest == null ) { mCurrentPosition = RecyclerView . NO_POSITION ; } else { mCurrentPosition = ( ( RecyclerView . LayoutParams ) closest . getLayoutParams ( ) ) . getViewLayoutPosition ( ) ; } } public View nextViewInLimitedList ( View ignore ) { int size = mScrapList . size ( ) ; View closest = null ; int closestDistance = Integer . MAX_VALUE ; if ( DEBUG && mIsPreLayout ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } for ( int i = <NUM_LIT> ; i < size ; i ++ ) { View view = mScrapList . get ( i ) . itemView ; final RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; if ( view == ignore || lp . isItemRemoved ( ) ) { continue ; } final int distance = ( lp . getViewLayoutPosition ( ) - mCurrentPosition ) * mItemDirection ; if ( distance < <NUM_LIT> ) { continue ; } if ( distance < closestDistance ) { closest = view ; closestDistance = distance ; if ( distance == <NUM_LIT> ) { break ; } } } return closest ; } void log ( ) { Log . d ( TAG , "<STR_LIT>" + mAvailable + "<STR_LIT>" + mCurrentPosition + "<STR_LIT>" + mItemDirection + "<STR_LIT>" + mOffset + "<STR_LIT>" + mLayoutDirection ) ; } } @ RestrictTo ( LIBRARY ) @ SuppressLint ( "<STR_LIT>" ) public static class SavedState implements Parcelable { int mAnchorPosition ; int mAnchorOffset ; boolean mAnchorLayoutFromEnd ; public SavedState ( ) { } SavedState ( Parcel in ) { mAnchorPosition = in . readInt ( ) ; mAnchorOffset = in . readInt ( ) ; mAnchorLayoutFromEnd = in . readInt ( ) == <NUM_LIT> ; } @ SuppressLint ( "<STR_LIT>" ) public SavedState ( SavedState other ) { mAnchorPosition = other . mAnchorPosition ; mAnchorOffset = other . mAnchorOffset ; mAnchorLayoutFromEnd = other . mAnchorLayoutFromEnd ; } boolean hasValidAnchor ( ) { return mAnchorPosition >= <NUM_LIT> ; } void invalidateAnchor ( ) { mAnchorPosition = RecyclerView . NO_POSITION ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mAnchorPosition ) ; dest . writeInt ( mAnchorOffset ) ; dest . writeInt ( mAnchorLayoutFromEnd ? <NUM_LIT> : <NUM_LIT> ) ; } public static final Parcelable . Creator < SavedState > CREATOR = new Parcelable . Creator < SavedState > ( ) { @ Override public SavedState createFromParcel ( Parcel in ) { return new SavedState ( in ) ; } @ Override public SavedState [ ] newArray ( int size ) { return new SavedState [ size ] ; } } ; } static class AnchorInfo { OrientationHelper mOrientationHelper ; int mPosition ; int mCoordinate ; boolean mLayoutFromEnd ; boolean mValid ; AnchorInfo ( ) { reset ( ) ; } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mCoordinate = INVALID_OFFSET ; mLayoutFromEnd = false ; mValid = false ; } void assignCoordinateFromPadding ( ) { mCoordinate = mLayoutFromEnd ? mOrientationHelper . getEndAfterPadding ( ) : mOrientationHelper . getStartAfterPadding ( ) ; } @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + mPosition + "<STR_LIT>" + mCoordinate + "<STR_LIT>" + mLayoutFromEnd + "<STR_LIT>" + mValid + '<STR_LIT>' ; } boolean isViewValidAsAnchor ( View child , RecyclerView . State state ) { RecyclerView . LayoutParams lp = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; return ! lp . isItemRemoved ( ) && lp . getViewLayoutPosition ( ) >= <NUM_LIT> && lp . getViewLayoutPosition ( ) < state . getItemCount ( ) ; } public void assignFromViewAndKeepVisibleRect ( View child , int position ) { final int spaceChange = mOrientationHelper . getTotalSpaceChange ( ) ; if ( spaceChange >= <NUM_LIT> ) { assignFromView ( child , position ) ; return ; } mPosition = position ; if ( mLayoutFromEnd ) { final int prevLayoutEnd = mOrientationHelper . getEndAfterPadding ( ) - spaceChange ; final int childEnd = mOrientationHelper . getDecoratedEnd ( child ) ; final int previousEndMargin = prevLayoutEnd - childEnd ; mCoordinate = mOrientationHelper . getEndAfterPadding ( ) - previousEndMargin ; if ( previousEndMargin > <NUM_LIT> ) { final int childSize = mOrientationHelper . getDecoratedMeasurement ( child ) ; final int estimatedChildStart = mCoordinate - childSize ; final int layoutStart = mOrientationHelper . getStartAfterPadding ( ) ; final int previousStartMargin = mOrientationHelper . getDecoratedStart ( child ) - layoutStart ; final int startReference = layoutStart + Math . min ( previousStartMargin , <NUM_LIT> ) ; final int startMargin = estimatedChildStart - startReference ; if ( startMargin < <NUM_LIT> ) { mCoordinate += Math . min ( previousEndMargin , - startMargin ) ; } } } else { final int childStart = mOrientationHelper . getDecoratedStart ( child ) ; final int startMargin = childStart - mOrientationHelper . getStartAfterPadding ( ) ; mCoordinate = childStart ; if ( startMargin > <NUM_LIT> ) { final int estimatedEnd = childStart + mOrientationHelper . getDecoratedMeasurement ( child ) ; final int previousLayoutEnd = mOrientationHelper . getEndAfterPadding ( ) - spaceChange ; final int previousEndMargin = previousLayoutEnd - mOrientationHelper . getDecoratedEnd ( child ) ; final int endReference = mOrientationHelper . getEndAfterPadding ( ) - Math . min ( <NUM_LIT> , previousEndMargin ) ; final int endMargin = endReference - estimatedEnd ; if ( endMargin < <NUM_LIT> ) { mCoordinate -= Math . min ( startMargin , - endMargin ) ; } } } } public void assignFromView ( View child , int position ) { if ( mLayoutFromEnd ) { mCoordinate = mOrientationHelper . getDecoratedEnd ( child ) + mOrientationHelper . getTotalSpaceChange ( ) ; } else { mCoordinate = mOrientationHelper . getDecoratedStart ( child ) ; } mPosition = position ; } } protected static class LayoutChunkResult { public int mConsumed ; public boolean mFinished ; public boolean mIgnoreConsumed ; public boolean mFocusable ; void resetInternal ( ) { mConsumed = <NUM_LIT> ; mFinished = false ; mIgnoreConsumed = false ; mFocusable = false ; } } } </s>
<s> package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( "<STR_LIT>" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ; } public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; } setActiveThumbIndex ( <NUM_LIT> ) ; return true ; } public interface OnChangeListener extends BaseOnChangeListener < OverlaySlider > { @ Override void onValueChange ( @ NonNull OverlaySlider slider , float value , boolean fromUser ) ; } public interface OnSliderTouchListener extends BaseOnSliderTouchListener < OverlaySlider > { @ Override void onStartTrackingTouch ( @ NonNull OverlaySlider slider ) ; @ Override void onStopTrackingTouch ( @ NonNull OverlaySlider slider ) ; } } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( "<STR_LIT>" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( "<STR_LIT>" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( "<STR_LIT>" ) void clearView ( View view ) ; @ SuppressLint ( "<STR_LIT>" ) void onSelected ( View view ) ; } </s>
<s> package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = "<STR_LIT>" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + hidden + "<STR_LIT>" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset + "<STR_LIT>" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset + "<STR_LIT>" + "<STR_LIT>" + hidden + "<STR_LIT>" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + index + "<STR_LIT>" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( "<STR_LIT>" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , "<STR_LIT>" + view + "<STR_LIT>" + offset + "<STR_LIT>" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( "<STR_LIT>" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + "<STR_LIT>" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } } boolean get ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . get ( index - BITS_PER_WORD ) ; } else { return ( mData & ( <NUM_LIT> << index ) ) != <NUM_LIT> ; } } void reset ( ) { mData = <NUM_LIT> ; if ( mNext != null ) { mNext . reset ( ) ; } } void insert ( int index , boolean value ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . insert ( index - BITS_PER_WORD , value ) ; } else { final boolean lastBit = ( mData & LAST_BIT ) != <NUM_LIT> ; long mask = ( <NUM_LIT> << index ) - <NUM_LIT> ; final long before = mData & mask ; final long after = ( mData & ~ mask ) << <NUM_LIT> ; mData = before | after ; if ( value ) { set ( index ) ; } else { clear ( index ) ; } if ( lastBit || mNext != null ) { ensureNext ( ) ; mNext . insert ( <NUM_LIT> , lastBit ) ; } } } boolean remove ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . remove ( index - BITS_PER_WORD ) ; } else { long mask = ( <NUM_LIT> << index ) ; final boolean value = ( mData & mask ) != <NUM_LIT> ; mData &= ~ mask ; mask = mask - <NUM_LIT> ; final long before = mData & mask ; final long after = Long . rotateRight ( mData & ~ mask , <NUM_LIT> ) ; mData = before | after ; if ( mNext != null ) { if ( mNext . get ( <NUM_LIT> ) ) { set ( BITS_PER_WORD - <NUM_LIT> ) ; } mNext . remove ( <NUM_LIT> ) ; } return value ; } } int countOnesBefore ( int index ) { if ( mNext == null ) { if ( index >= BITS_PER_WORD ) { return Long . bitCount ( mData ) ; } return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } if ( index < BITS_PER_WORD ) { return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } else { return mNext . countOnesBefore ( index - BITS_PER_WORD ) + Long . bitCount ( mData ) ; } } @ Override public String toString ( ) { return mNext == null ? Long . toBinaryString ( mData ) : mNext . toString ( ) + "<STR_LIT>" + Long . toBinaryString ( mData ) ; } } interface Callback { int getChildCount ( ) ; void addView ( View child , int index ) ; int indexOfChild ( View view ) ; void removeViewAt ( int index ) ; View getChildAt ( int offset ) ; void removeAllViews ( ) ; RecyclerView . ViewHolder getChildViewHolder ( View view ) ; void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams ) ; void detachViewFromParent ( int offset ) ; void onEnteredHiddenState ( View child ) ; void onLeftHiddenState ( View child ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetVersionNameResult implements Result { @ NonNull private String versionName ; public GetVersionNameResult ( @ NonNull String versionName ) { this . versionName = versionName ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , versionName ) ; return result ; } } </s>
<s> package com . getcapacitor . android ; import static org . junit . Assert . * ; import android . content . Context ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import androidx . test . platform . app . InstrumentationRegistry ; import org . junit . Test ; import org . junit . runner . RunWith ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) throws Exception { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( "<STR_LIT>" , appContext . getPackageName ( ) ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . interfaces ; import com . getcapacitor . JSObject ; public interface Result { JSObject toJSObject ( ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; import androidx . annotation . Nullable ; import java . util . Date ; public class PresentResultCallback { interface SuccessListener { void onSuccess ( Date date ) ; } interface CancelListener { void onCancel ( ) ; } interface DismissListener { void onDismiss ( ) ; } @ Nullable private SuccessListener successListener ; @ Nullable private CancelListener cancelListener ; @ Nullable private DismissListener dismissListener ; public void setSuccessListener ( @ Nullable SuccessListener listener ) { this . successListener = listener ; } public void setCancelListener ( @ Nullable CancelListener listener ) { this . cancelListener = listener ; } public void setDismissListener ( @ Nullable DismissListener listener ) { this . dismissListener = listener ; } public void success ( Date date ) { if ( successListener != null ) { successListener . onSuccess ( date ) ; } this . removeAllListener ( ) ; } public void cancel ( ) { if ( cancelListener != null ) { cancelListener . onCancel ( ) ; } this . removeAllListener ( ) ; } public void dismiss ( ) { if ( dismissListener != null ) { dismissListener . onDismiss ( ) ; } this . removeAllListener ( ) ; } private void removeAllListener ( ) { successListener = null ; cancelListener = null ; dismissListener = null ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . interfaces ; public interface Callback { void error ( Exception exception ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class SetBundleOptions { @ NonNull private String bundleId ; public SetBundleOptions ( @ NonNull String bundleId ) { this . bundleId = bundleId ; } @ NonNull public String getBundleId ( ) { return bundleId ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; import android . app . DatePickerDialog ; import android . app . Dialog ; import android . app . TimePickerDialog ; import android . content . res . Configuration ; import android . text . format . DateFormat ; import android . widget . Button ; import android . widget . DatePicker ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; public class DatetimePicker { private final DatetimePickerPlugin plugin ; private final DatetimePickerConfig config ; public DatetimePicker ( DatetimePickerPlugin plugin , DatetimePickerConfig config ) { this . plugin = plugin ; this . config = config ; } public void presentDateTimePicker ( Date date , @ Nullable Date minDate , @ Nullable Date maxDate , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { PresentResultCallback dateResultCallback = new PresentResultCallback ( ) ; dateResultCallback . setSuccessListener ( selectedDate -> { PresentResultCallback timeResultCallback = new PresentResultCallback ( ) ; timeResultCallback . setSuccessListener ( ( Date selectedDateAndTime ) -> resultCallback . success ( selectedDateAndTime ) ) ; timeResultCallback . setCancelListener ( ( ) -> resultCallback . cancel ( ) ) ; timeResultCallback . setDismissListener ( ( ) -> resultCallback . dismiss ( ) ) ; presentTimePicker ( selectedDate , locale , cancelButtonText , doneButtonText , theme , timeResultCallback , androidDatePickerMode , androidTimePickerMode ) ; } ) ; dateResultCallback . setCancelListener ( ( ) -> resultCallback . cancel ( ) ) ; dateResultCallback . setDismissListener ( ( ) -> resultCallback . dismiss ( ) ) ; presentDatePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , dateResultCallback , androidDatePickerMode , androidTimePickerMode ) ; } public void presentDatePicker ( Date date , @ Nullable Date minDate , @ Nullable Date maxDate , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { if ( locale != null ) { this . updateLocaleConfiguration ( locale ) ; } Calendar calendar = this . createCalendarFromDate ( date ) ; final DatePickerDialog dialog = new DatePickerDialog ( plugin . getContext ( ) , getTheme ( theme , androidDatePickerMode , androidTimePickerMode ) , ( view , year , month , dayOfMonth ) -> { calendar . set ( year , month , dayOfMonth ) ; resultCallback . success ( calendar . getTime ( ) ) ; } , calendar . get ( Calendar . YEAR ) , calendar . get ( Calendar . MONTH ) , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; dialog . setOnDismissListener ( _dialog -> resultCallback . dismiss ( ) ) ; dialog . create ( ) ; Button doneButton = dialog . getButton ( Dialog . BUTTON_POSITIVE ) ; doneButton . setText ( doneButtonText ) ; Button cancelButton = dialog . getButton ( Dialog . BUTTON_NEGATIVE ) ; cancelButton . setText ( cancelButtonText ) ; cancelButton . setOnClickListener ( view -> { resultCallback . cancel ( ) ; dialog . dismiss ( ) ; } ) ; DatePicker picker = dialog . getDatePicker ( ) ; if ( minDate != null ) { picker . setMinDate ( minDate . getTime ( ) ) ; } if ( maxDate != null ) { picker . setMaxDate ( maxDate . getTime ( ) ) ; } dialog . show ( ) ; } public void presentTimePicker ( Date date , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { if ( locale != null ) { this . updateLocaleConfiguration ( locale ) ; } Calendar calendar = this . createCalendarFromDate ( date ) ; boolean is24HourView = DateFormat . is24HourFormat ( plugin . getContext ( ) ) ; if ( locale != null ) { is24HourView = DatetimePickerHelper . is24HourLocale ( locale ) ; } final TimePickerDialog dialog = new TimePickerDialog ( plugin . getContext ( ) , getTheme ( theme , androidDatePickerMode , androidTimePickerMode ) , ( view , hourOfDay , minute ) -> { calendar . set ( calendar . get ( Calendar . YEAR ) , calendar . get ( Calendar . MONTH ) , calendar . get ( Calendar . DAY_OF_MONTH ) , hourOfDay , minute ) ; resultCallback . success ( calendar . getTime ( ) ) ; } , calendar . get ( Calendar . HOUR_OF_DAY ) , calendar . get ( Calendar . MINUTE ) , is24HourView ) ; dialog . setOnDismissListener ( _dialog -> resultCallback . dismiss ( ) ) ; dialog . create ( ) ; Button doneButton = dialog . getButton ( Dialog . BUTTON_POSITIVE ) ; doneButton . setText ( doneButtonText ) ; Button cancelButton = dialog . getButton ( Dialog . BUTTON_NEGATIVE ) ; cancelButton . setText ( cancelButtonText ) ; cancelButton . setOnClickListener ( view -> { resultCallback . cancel ( ) ; dialog . dismiss ( ) ; } ) ; dialog . show ( ) ; } private Calendar createCalendarFromDate ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } private int getTheme ( @ Nullable String unconvertedTheme , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { Theme theme = config . getTheme ( ) ; Theme overrideConfig = DatetimePickerHelper . convertStringToTheme ( unconvertedTheme ) ; if ( overrideConfig != null ) { theme = overrideConfig ; } if ( androidDatePickerMode != AndroidDatePickerMode . SPINNER && androidTimePickerMode != AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme ; case DARK : return R . style . MaterialDarkTheme ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme ; } } } } if ( androidDatePickerMode == AndroidDatePickerMode . SPINNER && androidTimePickerMode != AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_DatePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_DatePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; } } } } if ( androidDatePickerMode != AndroidDatePickerMode . SPINNER && androidTimePickerMode == AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_TimePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_TimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; } } } } if ( androidDatePickerMode == AndroidDatePickerMode . SPINNER && androidTimePickerMode == AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_DateTimePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_DateTimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; } } } } return R . style . MaterialLightTheme ; } private void updateLocaleConfiguration ( @ NonNull Locale locale ) { Configuration config = new Configuration ( ) ; config . locale = locale ; plugin . getContext ( ) . getResources ( ) . updateConfiguration ( config , plugin . getContext ( ) . getResources ( ) . getDisplayMetrics ( ) ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . filepicker ; public class FileResolution { public int height ; public int width ; public FileResolution ( int height , int width ) { this . height = height ; this . width = width ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . filepicker ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . util . Log ; import androidx . activity . result . ActivityResult ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . ArrayList ; import java . util . List ; import org . json . JSONException ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class FilePickerPlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_PICK_FILE_FAILED = "<STR_LIT>" ; public static final String ERROR_PICK_FILE_CANCELED = "<STR_LIT>" ; private FilePicker implementation ; public void load ( ) { implementation = new FilePicker ( this . getBridge ( ) ) ; } @ PluginMethod public void convertHeicToJpeg ( PluginCall call ) { call . unimplemented ( "<STR_LIT>" ) ; } @ PluginMethod public void pickFiles ( PluginCall call ) { try { int limit = call . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; JSArray types = call . getArray ( "<STR_LIT>" , null ) ; String [ ] parsedTypes = parseTypesOption ( types ) ; Intent intent = new Intent ( Intent . ACTION_GET_CONTENT ) ; intent . setType ( "<STR_LIT>" ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; if ( limit == <NUM_LIT> && parsedTypes != null && parsedTypes . length > <NUM_LIT> ) { intent . putExtra ( Intent . EXTRA_MIME_TYPES , parsedTypes ) ; } startActivityForResult ( call , intent , "<STR_LIT>" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickImages ( PluginCall call ) { try { int limit = call . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { "<STR_LIT>" } ) ; startActivityForResult ( call , intent , "<STR_LIT>" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickMedia ( PluginCall call ) { try { int limit = call . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { "<STR_LIT>" , "<STR_LIT>" } ) ; startActivityForResult ( call , intent , "<STR_LIT>" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickVideos ( PluginCall call ) { try { int limit = call . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { "<STR_LIT>" } ) ; startActivityForResult ( call , intent , "<STR_LIT>" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ Nullable private String [ ] parseTypesOption ( @ Nullable JSArray types ) { if ( types == null ) { return null ; } try { List < String > typesList = types . toList ( ) ; if ( typesList . contains ( "<STR_LIT>" ) ) { typesList . add ( "<STR_LIT>" ) ; } return typesList . toArray ( new String [ <NUM_LIT> ] ) ; } catch ( JSONException exception ) { Logger . error ( "<STR_LIT>" , exception ) ; return null ; } } @ ActivityCallback private void pickFilesResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { return ; } boolean readData = call . getBoolean ( "<STR_LIT>" , false ) ; int resultCode = result . getResultCode ( ) ; switch ( resultCode ) { case Activity . RESULT_OK : JSObject callResult = createPickFilesResult ( result . getData ( ) , readData ) ; call . resolve ( callResult ) ; break ; case Activity . RESULT_CANCELED : call . reject ( ERROR_PICK_FILE_CANCELED ) ; break ; default : call . reject ( ERROR_PICK_FILE_FAILED ) ; } } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } private JSObject createPickFilesResult ( @ Nullable Intent data , boolean readData ) { JSObject callResult = new JSObject ( ) ; List < JSObject > filesResultList = new ArrayList < > ( ) ; if ( data == null ) { callResult . put ( "<STR_LIT>" , JSArray . from ( filesResultList ) ) ; return callResult ; } List < Uri > uris = new ArrayList < > ( ) ; if ( data . getClipData ( ) == null ) { Uri uri = data . getData ( ) ; uris . add ( uri ) ; } else { for ( int i = <NUM_LIT> ; i < data . getClipData ( ) . getItemCount ( ) ; i ++ ) { Uri uri = data . getClipData ( ) . getItemAt ( i ) . getUri ( ) ; uris . add ( uri ) ; } } for ( int i = <NUM_LIT> ; i < uris . size ( ) ; i ++ ) { Uri uri = uris . get ( i ) ; if ( uri == null ) { continue ; } JSObject fileResult = new JSObject ( ) ; if ( readData ) { fileResult . put ( "<STR_LIT>" , implementation . getDataFromUri ( uri ) ) ; } Long duration = implementation . getDurationFromUri ( uri ) ; if ( duration != null ) { fileResult . put ( "<STR_LIT>" , duration ) ; } FileResolution resolution = implementation . getHeightAndWidthFromUri ( uri ) ; if ( resolution != null ) { fileResult . put ( "<STR_LIT>" , resolution . height ) ; fileResult . put ( "<STR_LIT>" , resolution . width ) ; } fileResult . put ( "<STR_LIT>" , implementation . getMimeTypeFromUri ( uri ) ) ; Long modifiedAt = implementation . getModifiedAtFromUri ( uri ) ; if ( modifiedAt != null ) { fileResult . put ( "<STR_LIT>" , modifiedAt ) ; } fileResult . put ( "<STR_LIT>" , implementation . getNameFromUri ( uri ) ) ; fileResult . put ( "<STR_LIT>" , implementation . getPathFromUri ( uri ) ) ; fileResult . put ( "<STR_LIT>" , implementation . getSizeFromUri ( uri ) ) ; filesResultList . add ( fileResult ) ; } callResult . put ( "<STR_LIT>" , JSArray . from ( filesResultList . toArray ( ) ) ) ; return callResult ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . backgroundtask ; public class BackgroundTask { public String echo ( String value ) { return value ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . foregroundservice ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import com . getcapacitor . Logger ; public class NotificationActionBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { try { int buttonId = intent . getExtras ( ) . getInt ( "<STR_LIT>" ) ; ForegroundServicePlugin . onButtonClicked ( buttonId ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . interfaces ; public interface EmptyCallback extends Callback { void success ( ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; import android . util . Log ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . Date ; import java . util . Locale ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class DatetimePickerPlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_MODE_INVALID = "<STR_LIT>" ; public static final String ERROR_PICKER_CANCELED = "<STR_LIT>" ; public static final String ERROR_PICKER_DISMISSED = "<STR_LIT>" ; public static final String ERROR_CODE_CANCELED = "<STR_LIT>" ; public static final String ERROR_CODE_DISMISSED = "<STR_LIT>" ; private DatetimePicker implementation ; public void load ( ) { DatetimePickerConfig config = getDatetimePickerConfig ( ) ; implementation = new DatetimePicker ( this , config ) ; } @ PluginMethod public void present ( PluginCall call ) { try { String format = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; String localeString = call . getString ( "<STR_LIT>" ) ; String max = call . getString ( "<STR_LIT>" ) ; String min = call . getString ( "<STR_LIT>" ) ; String mode = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; String theme = call . getString ( "<STR_LIT>" ) ; String value = call . getString ( "<STR_LIT>" ) ; String cancelButtonText = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; String doneButtonText = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; String androidTimePickerModeText = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; String androidDatePickerModeText = call . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; AndroidDatePickerMode androidDatePickerMode = null ; if ( androidDatePickerModeText != null ) { androidDatePickerMode = DatetimePickerHelper . convertStringToDatePickerMode ( androidDatePickerModeText ) ; } AndroidTimePickerMode androidTimePickerMode = null ; if ( androidTimePickerModeText != null ) { androidTimePickerMode = DatetimePickerHelper . convertStringToTimePickerMode ( androidTimePickerModeText ) ; } Locale locale = null ; if ( localeString != null ) { locale = DatetimePickerHelper . convertStringToLocale ( localeString ) ; } Date date = new Date ( ) ; if ( value != null ) { date = DatetimePickerHelper . convertStringToDate ( format , value ) ; } Date minDate = null ; if ( min != null ) { minDate = DatetimePickerHelper . convertStringToDate ( format , min ) ; } Date maxDate = null ; if ( max != null ) { maxDate = DatetimePickerHelper . convertStringToDate ( format , max ) ; } PresentResultCallback resultCallback = new PresentResultCallback ( ) ; resultCallback . setSuccessListener ( selectedDate -> { String dateAsString = DatetimePickerHelper . convertDateToString ( format , selectedDate ) ; JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , dateAsString ) ; call . resolve ( result ) ; } ) ; resultCallback . setCancelListener ( ( ) -> call . reject ( ERROR_PICKER_CANCELED , ERROR_CODE_CANCELED ) ) ; resultCallback . setDismissListener ( ( ) -> call . reject ( ERROR_PICKER_DISMISSED , ERROR_CODE_DISMISSED ) ) ; if ( mode . equals ( "<STR_LIT>" ) ) { implementation . presentDateTimePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else if ( mode . equals ( "<STR_LIT>" ) ) { implementation . presentDatePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else if ( mode . equals ( "<STR_LIT>" ) ) { implementation . presentTimePicker ( date , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else { call . reject ( ERROR_MODE_INVALID ) ; } } catch ( Exception ex ) { String message = ex . getLocalizedMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } private DatetimePickerConfig getDatetimePickerConfig ( ) { DatetimePickerConfig config = new DatetimePickerConfig ( ) ; String theme = getConfig ( ) . getString ( "<STR_LIT>" ) ; config . setTheme ( theme , config . getTheme ( ) ) ; return config ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import java . security . Key ; public class LiveUpdateConfig { @ Nullable private String appId = null ; private boolean autoDeleteBundles = false ; private boolean enabled = true ; @ Nullable private String location = null ; @ Nullable private String publicKey = null ; private int readyTimeout = <NUM_LIT> ; private boolean resetOnUpdate = true ; @ Nullable public String getAppId ( ) { return appId ; } public boolean getAutoDeleteBundles ( ) { return autoDeleteBundles ; } public boolean getEnabled ( ) { return enabled ; } @ Nullable public String getLocation ( ) { return location ; } @ Nullable public String getPublicKey ( ) { return publicKey ; } public int getReadyTimeout ( ) { return readyTimeout ; } public boolean getResetOnUpdate ( ) { return resetOnUpdate ; } public void setAppId ( @ Nullable String appId ) { this . appId = appId ; } public void setAutoDeleteBundles ( boolean autoDeleteBundles ) { this . autoDeleteBundles = autoDeleteBundles ; } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public void setLocation ( @ Nullable String location ) { this . location = location ; } public void setPublicKey ( @ Nullable String publicKey ) { this . publicKey = publicKey ; } public void setReadyTimeout ( int readyTimeout ) { this . readyTimeout = readyTimeout ; } public void setResetOnUpdate ( boolean resetOnUpdate ) { this . resetOnUpdate = resetOnUpdate ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . batteryoptimization ; import android . os . Build ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class BatteryOptimizationPlugin extends Plugin { public static final String ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE = "<STR_LIT>" ; public static final String ERROR_CODE_UNAVAILABLE = "<STR_LIT>" ; private BatteryOptimization implementation ; @ Override public void load ( ) { implementation = new BatteryOptimization ( this ) ; } @ PluginMethod public void isBatteryOptimizationEnabled ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , implementation . isBatteryOptimizationEnabled ( ) ) ; call . resolve ( ret ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openBatteryOptimizationSettings ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } implementation . openBatteryOptimizationSettings ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void requestIgnoreBatteryOptimization ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } implementation . requestIgnoreBatteryOptimization ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class DeleteBundleOptions { @ NonNull private String bundleId ; public DeleteBundleOptions ( @ NonNull String bundleId ) { this . bundleId = bundleId ; } @ NonNull public String getBundleId ( ) { return bundleId ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . batteryoptimization ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . PowerManager ; import android . provider . Settings ; import androidx . annotation . RequiresApi ; public class BatteryOptimization { private final BatteryOptimizationPlugin plugin ; public BatteryOptimization ( BatteryOptimizationPlugin plugin ) { this . plugin = plugin ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public boolean isBatteryOptimizationEnabled ( ) { PowerManager powerManager = ( PowerManager ) plugin . getContext ( ) . getSystemService ( Context . POWER_SERVICE ) ; return ! powerManager . isIgnoringBatteryOptimizations ( plugin . getContext ( ) . getPackageName ( ) ) ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public void openBatteryOptimizationSettings ( ) { Intent intent = new Intent ( ) ; intent . setAction ( Settings . ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; plugin . getContext ( ) . startActivity ( intent ) ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public void requestIgnoreBatteryOptimization ( ) { Intent intent = new Intent ( ) ; intent . setAction ( Settings . ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + plugin . getContext ( ) . getPackageName ( ) ) ) ; plugin . getContext ( ) . startActivity ( intent ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . screenorientation ; public class ScreenOrientationType { public static final String LANDSCAPE = "<STR_LIT>" ; public static final String LANDSCAPE_PRIMARY = "<STR_LIT>" ; public static final String LANDSCAPE_SECONDARY = "<STR_LIT>" ; public static final String PORTRAIT = "<STR_LIT>" ; public static final String PORTRAIT_PRIMARY = "<STR_LIT>" ; public static final String PORTRAIT_SECONDARY = "<STR_LIT>" ; } </s>
<s> package io . capawesome . capacitorjs . plugins . foregroundservice ; import android . app . Notification ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import java . util . ArrayList ; public class AndroidForegroundService extends Service { @ Nullable @ Override public IBinder onBind ( Intent intent ) { return null ; } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { try { Bundle extras = intent . getExtras ( ) ; Bundle notificationBundle = extras . getBundle ( "<STR_LIT>" ) ; String body = notificationBundle . getString ( "<STR_LIT>" ) ; int id = notificationBundle . getInt ( "<STR_LIT>" ) ; int icon = notificationBundle . getInt ( "<STR_LIT>" ) ; String title = notificationBundle . getString ( "<STR_LIT>" ) ; ArrayList < Bundle > buttonsBundle = notificationBundle . getParcelableArrayList ( "<STR_LIT>" ) ; PendingIntent contentIntent = buildContentIntent ( id ) ; Notification . Builder builder ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { builder = new Notification . Builder ( getApplicationContext ( ) , ForegroundService . DEFAULT_NOTIFICATION_CHANNEL_ID ) ; } else { builder = new Notification . Builder ( getApplicationContext ( ) ) ; } builder . setContentTitle ( title ) . setContentText ( body ) . setContentIntent ( contentIntent ) . setOngoing ( true ) . setSmallIcon ( icon ) . setPriority ( Notification . PRIORITY_HIGH ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Notification . Action [ ] actions = convertBundlesToNotificationActions ( buttonsBundle . toArray ( new Bundle [ buttonsBundle . size ( ) ] ) ) ; builder . setActions ( actions ) ; } Notification notification = builder . build ( ) ; startForeground ( id , notification ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } return START_STICKY ; } private PendingIntent buildContentIntent ( int id ) { String packageName = getApplicationContext ( ) . getPackageName ( ) ; Intent intent = getApplicationContext ( ) . getPackageManager ( ) . getLaunchIntentForPackage ( packageName ) ; int pendingIntentFlags ; if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . S ) { pendingIntentFlags = PendingIntent . FLAG_CANCEL_CURRENT | PendingIntent . FLAG_MUTABLE ; } else { pendingIntentFlags = PendingIntent . FLAG_CANCEL_CURRENT ; } return PendingIntent . getActivity ( getApplicationContext ( ) , id , intent , pendingIntentFlags ) ; } private Notification . Action [ ] convertBundlesToNotificationActions ( Bundle [ ] bundles ) { Notification . Action [ ] actions = new Notification . Action [ bundles . length ] ; for ( int i = <NUM_LIT> ; i < bundles . length ; i ++ ) { String title = bundles [ i ] . getString ( "<STR_LIT>" ) ; int id = bundles [ i ] . getInt ( "<STR_LIT>" ) ; Intent intent = new Intent ( this , NotificationActionBroadcastReceiver . class ) ; intent . putExtra ( "<STR_LIT>" , id ) ; PendingIntent pendingIntent = PendingIntent . getBroadcast ( this , id , intent , PendingIntent . FLAG_IMMUTABLE | PendingIntent . FLAG_CANCEL_CURRENT ) ; Notification . Action action = new Notification . Action ( <NUM_LIT> , title , pendingIntent ) ; actions [ i ] = action ; } return actions ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; public enum Theme { LIGHT , DARK , AUTO } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetDeviceIdResult implements Result { @ NonNull private String deviceId ; public GetDeviceIdResult ( @ NonNull String deviceId ) { this . deviceId = deviceId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , deviceId == null ? JSONObject . NULL : deviceId ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . cloudinary ; import java . util . Map ; public interface UploadResourceResultCallback { void success ( Map resultData ) ; void error ( String message ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetBundlesResult implements Result { @ NonNull private String [ ] bundleIds ; public GetBundlesResult ( @ NonNull String [ ] bundleIds ) { this . bundleIds = bundleIds ; } public JSObject toJSObject ( ) { JSArray bundleIdsResult = new JSArray ( ) ; for ( String bundleId : bundleIds ) { bundleIdsResult . put ( bundleId ) ; } JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , bundleIdsResult ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class SyncResult implements Result { @ Nullable private final String nextBundleId ; public SyncResult ( @ Nullable String nextBundleId ) { this . nextBundleId = nextBundleId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , nextBundleId == null ? JSONObject . NULL : nextBundleId ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . cloudinary ; import android . app . DownloadManager ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import com . getcapacitor . Logger ; public class DownloadBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { try { String action = intent . getAction ( ) ; if ( DownloadManager . ACTION_DOWNLOAD_COMPLETE . equals ( action ) ) { long downloadId = intent . getLongExtra ( DownloadManager . EXTRA_DOWNLOAD_ID , - <NUM_LIT> ) ; CloudinaryPlugin . onDownloadCompleted ( downloadId ) ; } } catch ( Exception exception ) { Logger . error ( CloudinaryPlugin . TAG , exception . getMessage ( ) , exception ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . api ; import androidx . annotation . Nullable ; import org . json . JSONObject ; public class GetLatestBundleResponse { private String bundleId ; @ Nullable private String checksum ; @ Nullable private String signature ; private String url ; public GetLatestBundleResponse ( JSONObject responseJson ) { this . bundleId = responseJson . optString ( "<STR_LIT>" ) ; String checksum = responseJson . optString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( checksum . equals ( "<STR_LIT>" ) ) { this . checksum = null ; } else { this . checksum = checksum ; } String signature = responseJson . optString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( signature . equals ( "<STR_LIT>" ) ) { this . signature = null ; } else { this . signature = signature ; } this . url = responseJson . optString ( "<STR_LIT>" ) ; } public String getBundleId ( ) { return bundleId ; } @ Nullable public String getChecksum ( ) { return checksum ; } @ Nullable public String getSignature ( ) { return signature ; } public String getUrl ( ) { return url ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . badge ; public class BadgeConfig { private boolean persist = true ; private boolean autoClear = false ; public boolean getPersist ( ) { return persist ; } public void setPersist ( boolean persist ) { this . persist = persist ; } public boolean getAutoClear ( ) { return autoClear ; } public void setAutoClear ( boolean autoClear ) { this . autoClear = autoClear ; } } </s>
<s> package com . getcapacitor ; import static org . junit . Assert . * ; import org . junit . Test ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . badge ; import static me . leolin . shortcutbadger . ShortcutBadger . isBadgeCounterSupported ; import android . content . Context ; import android . content . SharedPreferences ; import com . getcapacitor . Logger ; import me . leolin . shortcutbadger . ShortcutBadger ; public class Badge { private static final String STORAGE_KEY = "<STR_LIT>" ; private Context context ; private BadgeConfig config ; Badge ( Context context , BadgeConfig config ) { this . config = config ; if ( isBadgeCounterSupported ( context ) ) { this . context = context ; } else { this . context = context . getApplicationContext ( ) ; } boolean restoreCount = this . config . getPersist ( ) ; if ( restoreCount ) { restore ( ) ; } } public void handleOnResume ( ) { try { boolean resetCount = this . config . getAutoClear ( ) ; if ( resetCount ) { set ( <NUM_LIT> ) ; } } catch ( Exception ex ) { Logger . error ( ex . getLocalizedMessage ( ) , ex ) ; } } public int get ( ) { return getPrefs ( ) . getInt ( STORAGE_KEY , <NUM_LIT> ) ; } public void set ( int count ) { SharedPreferences . Editor editor = getPrefs ( ) . edit ( ) ; editor . putInt ( STORAGE_KEY , count ) ; editor . apply ( ) ; ShortcutBadger . applyCount ( context , count ) ; } public void increase ( ) { int count = get ( ) ; set ( count + <NUM_LIT> ) ; } public void decrease ( ) { int count = get ( ) ; if ( count < <NUM_LIT> ) { return ; } set ( count - <NUM_LIT> ) ; } public void clear ( ) { set ( <NUM_LIT> ) ; } public boolean isSupported ( ) { int count = get ( ) ; boolean isSupported = ShortcutBadger . isBadgeCounterSupported ( context ) ; if ( isSupported ) { set ( count ) ; } return isSupported ; } private void restore ( ) { try { int count = get ( ) ; ShortcutBadger . applyCount ( context , count ) ; } catch ( Exception ex ) { Logger . error ( ex . getLocalizedMessage ( ) , ex ) ; } } private SharedPreferences getPrefs ( ) { return context . getSharedPreferences ( STORAGE_KEY , Context . MODE_PRIVATE ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DownloadBundleOptions { @ NonNull private String bundleId ; @ Nullable private String checksum ; @ NonNull private String url ; public DownloadBundleOptions ( @ NonNull String bundleId , @ Nullable String checksum , @ NonNull String url ) { this . bundleId = bundleId ; this . checksum = checksum ; this . url = url ; } @ NonNull public String getBundleId ( ) { return bundleId ; } @ Nullable public String getChecksum ( ) { return checksum ; } @ NonNull public String getUrl ( ) { return url ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate ; import android . app . Activity ; import android . content . SharedPreferences ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Handler ; import android . util . Base64 ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import com . getcapacitor . plugin . WebView ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . api . GetLatestBundleResponse ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DeleteBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . DownloadBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetBundleOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetChannelOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . options . SetCustomIdOptions ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetBundleResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetBundlesResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetChannelResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetCustomIdResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetDeviceIdResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetVersionCodeResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . GetVersionNameResult ; import io . capawesome . capacitorjs . plugins . liveupdate . classes . results . SyncResult ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . EmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . NonEmptyCallback ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import java . io . File ; import java . io . IOException ; import java . security . KeyFactory ; import java . security . MessageDigest ; import java . security . PublicKey ; import java . security . Signature ; import java . security . spec . X509EncodedKeySpec ; import java . util . Arrays ; import java . util . UUID ; import net . lingala . zip4j . ZipFile ; import okhttp3 . Call ; import okhttp3 . Callback ; import okhttp3 . HttpUrl ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; import okio . Buffer ; import okio . BufferedSink ; import okio . BufferedSource ; import okio . Okio ; import org . json . JSONException ; import org . json . JSONObject ; public class LiveUpdate { @ NonNull private final LiveUpdateConfig config ; private final String defaultWebAssetDir ; @ NonNull private final LiveUpdatePlugin plugin ; @ NonNull private final LiveUpdatePreferences preferences ; @ NonNull private final SharedPreferences . Editor webViewSettingsEditor ; private final String bundlesDirectory = "<STR_LIT>" ; private final Handler rollbackHandler = new Handler ( ) ; public LiveUpdate ( @ NonNull LiveUpdateConfig config , @ NonNull LiveUpdatePlugin plugin ) throws PackageManager . NameNotFoundException { this . config = config ; this . defaultWebAssetDir = plugin . getBridge ( ) . DEFAULT_WEB_ASSET_DIR ; this . plugin = plugin ; this . preferences = new LiveUpdatePreferences ( plugin . getContext ( ) ) ; this . webViewSettingsEditor = plugin . getContext ( ) . getSharedPreferences ( WebView . WEBVIEW_PREFS_NAME , Activity . MODE_PRIVATE ) . edit ( ) ; if ( config . getEnabled ( ) ) { if ( wasUpdated ( ) && config . getResetOnUpdate ( ) ) { reset ( ) ; } else { startRollbackTimer ( ) ; } saveCurrentVersionCode ( ) ; } } public void deleteBundle ( @ NonNull DeleteBundleOptions options , @ NonNull EmptyCallback callback ) { String bundleId = options . getBundleId ( ) ; if ( ! hasBundle ( bundleId ) ) { Exception exception = new Exception ( LiveUpdatePlugin . ERROR_BUNDLE_NOT_FOUND ) ; callback . error ( exception ) ; return ; } deleteBundle ( bundleId ) ; callback . success ( ) ; } public void downloadBundle ( @ NonNull DownloadBundleOptions options , @ NonNull EmptyCallback callback ) throws Exception { String bundleId = options . getBundleId ( ) ; String checksum = options . getChecksum ( ) ; String url = options . getUrl ( ) ; if ( hasBundle ( bundleId ) ) { Exception exception = new Exception ( LiveUpdatePlugin . ERROR_BUNDLE_EXISTS ) ; callback . error ( exception ) ; return ; } downloadBundle ( bundleId , checksum , null , url , callback ) ; } public void getBundle ( @ NonNull NonEmptyCallback callback ) { String bundleId = getCurrentBundleId ( ) ; if ( bundleId . equals ( defaultWebAssetDir ) ) { bundleId = null ; } GetBundleResult result = new GetBundleResult ( bundleId ) ; callback . success ( result ) ; } public void getBundles ( @ NonNull NonEmptyCallback callback ) { String [ ] bundleIds = getBundleIds ( ) ; GetBundlesResult result = new GetBundlesResult ( bundleIds ) ; callback . success ( result ) ; } public void getChannel ( @ NonNull NonEmptyCallback callback ) { String channel = preferences . getChannel ( ) ; GetChannelResult result = new GetChannelResult ( channel ) ; callback . success ( result ) ; } public void getCustomId ( @ NonNull NonEmptyCallback callback ) { String customId = preferences . getCustomId ( ) ; GetCustomIdResult result = new GetCustomIdResult ( customId ) ; callback . success ( result ) ; } public void getDeviceId ( @ NonNull NonEmptyCallback callback ) { String deviceId = getDeviceId ( ) ; GetDeviceIdResult result = new GetDeviceIdResult ( deviceId ) ; callback . success ( result ) ; } public void getVersionCode ( @ NonNull NonEmptyCallback callback ) throws PackageManager . NameNotFoundException { String versionCode = getVersionCode ( ) ; GetVersionCodeResult result = new GetVersionCodeResult ( versionCode ) ; callback . success ( result ) ; } public void getVersionName ( @ NonNull NonEmptyCallback callback ) throws PackageManager . NameNotFoundException { String versionName = getVersionName ( ) ; GetVersionNameResult result = new GetVersionNameResult ( versionName ) ; callback . success ( result ) ; } public void ready ( ) { Logger . debug ( LiveUpdatePlugin . TAG , "<STR_LIT>" ) ; stopRollbackTimer ( ) ; if ( config . getAutoDeleteBundles ( ) ) { deleteUnusedBundles ( ) ; } } public void reload ( ) { String path = getNextCapacitorServerPath ( ) ; setCurrentCapacitorServerPath ( path ) ; startRollbackTimer ( ) ; } public void reset ( ) { setNextCapacitorServerPathToDefaultWebAssetDir ( ) ; } public void setBundle ( @ NonNull SetBundleOptions options , @ NonNull EmptyCallback callback ) { String bundleId = options . getBundleId ( ) ; if ( ! hasBundle ( bundleId ) ) { Exception exception = new Exception ( LiveUpdatePlugin . ERROR_BUNDLE_NOT_FOUND ) ; callback . error ( exception ) ; return ; } setNextBundle ( bundleId ) ; callback . success ( ) ; } public void setChannel ( @ NonNull SetChannelOptions options , @ NonNull EmptyCallback callback ) { String channel = options . getChannel ( ) ; preferences . setChannel ( channel ) ; callback . success ( ) ; } public void setCustomId ( @ NonNull SetCustomIdOptions options , @ NonNull EmptyCallback callback ) { String customId = options . getCustomId ( ) ; preferences . setCustomId ( customId ) ; callback . success ( ) ; } public void sync ( @ NonNull NonEmptyCallback < Result > callback ) throws Exception { fetchLatestBundle ( new NonEmptyCallback < GetLatestBundleResponse > ( ) { @ Override public void error ( Exception exception ) { Logger . debug ( LiveUpdatePlugin . TAG , "<STR_LIT>" ) ; SyncResult syncResult = new SyncResult ( null ) ; callback . success ( syncResult ) ; } @ Override public void success ( @ NonNull GetLatestBundleResponse result ) { String latestBundleId = result . getBundleId ( ) ; String checksum = result . getChecksum ( ) ; String signature = result . getSignature ( ) ; String url = result . getUrl ( ) ; if ( hasBundle ( latestBundleId ) ) { String nextBundleId = null ; String currentBundleId = getCurrentBundleId ( ) ; if ( ! latestBundleId . equals ( currentBundleId ) ) { setNextBundle ( latestBundleId ) ; nextBundleId = latestBundleId ; } SyncResult syncResult = new SyncResult ( nextBundleId ) ; callback . success ( syncResult ) ; return ; } downloadBundle ( latestBundleId , checksum , signature , url , new EmptyCallback ( ) { @ Override public void success ( ) { setNextBundle ( latestBundleId ) ; SyncResult syncResult = new SyncResult ( latestBundleId ) ; callback . success ( syncResult ) ; } @ Override public void error ( Exception exception ) { callback . error ( exception ) ; } } ) ; } } ) ; } private void addBundle ( @ NonNull String bundleId , @ NonNull File zipFile ) throws Exception { File unzippedDirectory = unzipFile ( zipFile ) ; File indexHtmlFile = searchIndexHtmlFile ( unzippedDirectory ) ; if ( indexHtmlFile == null ) { throw new Exception ( LiveUpdatePlugin . ERROR_BUNDLE_INDEX_HTML_MISSING ) ; } createBundlesDirectory ( ) ; File bundleDirectory = buildBundleDirectoryFor ( bundleId ) ; indexHtmlFile . getParentFile ( ) . renameTo ( bundleDirectory ) ; } private File buildTemporaryDirectory ( ) { String fileName = UUID . randomUUID ( ) . toString ( ) ; return new File ( plugin . getContext ( ) . getCacheDir ( ) , fileName ) ; } private File buildTemporaryZipFile ( ) { String fileName = UUID . randomUUID ( ) . toString ( ) + "<STR_LIT>" ; return new File ( plugin . getContext ( ) . getCacheDir ( ) , fileName ) ; } private File buildBundlesDirectory ( ) { return new File ( plugin . getContext ( ) . getFilesDir ( ) , bundlesDirectory ) ; } private File buildBundleDirectoryFor ( @ NonNull String bundle ) { return new File ( plugin . getContext ( ) . getFilesDir ( ) , bundlesDirectory + "<STR_LIT>" + bundle ) ; } private byte [ ] getChecksumForFileAsBytes ( @ NonNull File file ) throws Exception { try { MessageDigest digest = MessageDigest . getInstance ( "<STR_LIT>" ) ; BufferedSource source = Okio . buffer ( Okio . source ( file ) ) ; Buffer buffer = new Buffer ( ) ; for ( long bytesRead ; ( bytesRead = source . read ( buffer , <NUM_LIT> ) ) != - <NUM_LIT> ; ) { digest . update ( buffer . readByteArray ( ) ) ; } source . close ( ) ; return digest . digest ( ) ; } catch ( IOException exception ) { Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; throw new Exception ( LiveUpdatePlugin . ERROR_CHECKSUM_CALCULATION_FAILED ) ; } } private String getChecksumForFileAsString ( @ NonNull File file ) throws Exception { byte [ ] checksumBytes = getChecksumForFileAsBytes ( file ) ; StringBuilder checksum = new StringBuilder ( ) ; for ( byte checksumByte : checksumBytes ) { checksum . append ( Integer . toString ( ( checksumByte & <NUM_LIT> ) + <NUM_LIT> , <NUM_LIT> ) . substring ( <NUM_LIT> ) ) ; } return checksum . toString ( ) ; } private void createBundlesDirectory ( ) { File bundlesDirectory = buildBundlesDirectory ( ) ; if ( ! bundlesDirectory . exists ( ) ) { bundlesDirectory . mkdir ( ) ; } } private PublicKey createPublicKeyFromString ( @ NonNull String value ) throws Exception { try { value = value . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; byte [ ] byteKey = Base64 . decode ( value , Base64 . DEFAULT ) ; X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec ( byteKey ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; return keyFactory . generatePublic ( X509publicKey ) ; } catch ( Exception exception ) { Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; throw new Exception ( LiveUpdatePlugin . ERROR_PUBLIC_KEY_INVALID ) ; } } private void deleteBundle ( @ NonNull String bundleId ) { File bundleDirectory = buildBundleDirectoryFor ( bundleId ) ; deleteFileRecursively ( bundleDirectory ) ; } private void deleteFileRecursively ( @ NonNull File file ) { if ( file . isDirectory ( ) ) { for ( File child : file . listFiles ( ) ) { deleteFileRecursively ( child ) ; } } file . delete ( ) ; } private void deleteUnusedBundles ( ) { String [ ] bundleIds = getBundleIds ( ) ; for ( String bundleId : bundleIds ) { if ( ! isBundleInUse ( bundleId ) ) { deleteBundle ( bundleId ) ; } } } private void downloadBundle ( @ NonNull String bundleId , @ Nullable String expectedChecksum , @ Nullable String signature , @ NonNull String url , @ NonNull EmptyCallback callback ) { downloadFile ( url , new NonEmptyCallback < File > ( ) { @ Override public void error ( Exception exception ) { callback . error ( exception ) ; } @ Override public void success ( @ NonNull File result ) { try { String publicKey = config . getPublicKey ( ) ; if ( publicKey != null ) { if ( signature == null ) { throw new Exception ( LiveUpdatePlugin . ERROR_SIGNATURE_MISSING ) ; } PublicKey key = createPublicKeyFromString ( publicKey ) ; boolean verified = verifySignatureForFile ( result , signature , key ) ; if ( ! verified ) { throw new Exception ( LiveUpdatePlugin . ERROR_SIGNATURE_VERIFICATION_FAILED ) ; } } else if ( expectedChecksum != null ) { String receivedChecksum = getChecksumForFileAsString ( result ) ; if ( ! expectedChecksum . equals ( receivedChecksum ) ) { throw new Exception ( LiveUpdatePlugin . ERROR_CHECKSUM_MISMATCH ) ; } } addBundle ( bundleId , result ) ; result . delete ( ) ; callback . success ( ) ; } catch ( Exception exception ) { callback . error ( exception ) ; } } } ) ; } private void downloadFile ( @ NonNull String url , @ NonNull NonEmptyCallback < File > callback ) { OkHttpClient okHttpClient = new OkHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; okHttpClient . newCall ( request ) . enqueue ( new Callback ( ) { @ Override public void onFailure ( @ NonNull Call call , @ NonNull IOException exception ) { callback . error ( exception ) ; } @ Override public void onResponse ( @ NonNull Call call , @ NonNull Response response ) throws IOException { ResponseBody responseBody = response . body ( ) ; if ( response . isSuccessful ( ) ) { File destinationFile = buildTemporaryZipFile ( ) ; long contentLength = responseBody . contentLength ( ) ; BufferedSource source = responseBody . source ( ) ; BufferedSink sink = Okio . buffer ( Okio . sink ( destinationFile ) ) ; Buffer sinkBuffer = sink . getBuffer ( ) ; long totalBytesRead = <NUM_LIT> ; int bufferSize = <NUM_LIT> * <NUM_LIT> ; for ( long bytesRead ; ( bytesRead = source . read ( sinkBuffer , bufferSize ) ) != - <NUM_LIT> ; ) { sink . emit ( ) ; totalBytesRead += bytesRead ; int progress = ( int ) ( ( totalBytesRead * <NUM_LIT> ) / contentLength ) ; } sink . flush ( ) ; sink . close ( ) ; source . close ( ) ; callback . success ( destinationFile ) ; } else { Exception exception = new Exception ( responseBody . string ( ) ) ; Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; callback . error ( new Exception ( LiveUpdatePlugin . ERROR_DOWNLOAD_FAILED ) ) ; } } } ) ; } @ Nullable private void fetchLatestBundle ( @ NonNull NonEmptyCallback < GetLatestBundleResponse > callback ) throws PackageManager . NameNotFoundException { String host = "<STR_LIT>" ; if ( config . getLocation ( ) != null && config . getLocation ( ) . equals ( "<STR_LIT>" ) ) { host = "<STR_LIT>" ; } HttpUrl url = new HttpUrl . Builder ( ) . scheme ( "<STR_LIT>" ) . host ( host ) . addPathSegment ( "<STR_LIT>" ) . addPathSegment ( "<STR_LIT>" ) . addPathSegment ( config . getAppId ( ) ) . addPathSegment ( "<STR_LIT>" ) . addPathSegment ( "<STR_LIT>" ) . addQueryParameter ( "<STR_LIT>" , getVersionCode ( ) ) . addQueryParameter ( "<STR_LIT>" , getVersionName ( ) ) . addQueryParameter ( "<STR_LIT>" , getCurrentBundleId ( ) ) . addQueryParameter ( "<STR_LIT>" , preferences . getChannel ( ) ) . addQueryParameter ( "<STR_LIT>" , preferences . getCustomId ( ) ) . addQueryParameter ( "<STR_LIT>" , getDeviceId ( ) ) . addQueryParameter ( "<STR_LIT>" , String . valueOf ( Build . VERSION . SDK_INT ) ) . addQueryParameter ( "<STR_LIT>" , "<STR_LIT>" ) . addQueryParameter ( "<STR_LIT>" , LiveUpdatePlugin . VERSION ) . build ( ) ; Logger . debug ( LiveUpdatePlugin . TAG , "<STR_LIT>" + url ) ; OkHttpClient client = new OkHttpClient ( ) ; okhttp3 . Request request = new okhttp3 . Request . Builder ( ) . url ( url ) . build ( ) ; client . newCall ( request ) . enqueue ( new okhttp3 . Callback ( ) { @ Override public void onFailure ( @ NonNull okhttp3 . Call call , @ NonNull IOException exception ) { Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; callback . error ( exception ) ; } @ Override public void onResponse ( @ NonNull okhttp3 . Call call , @ NonNull okhttp3 . Response response ) throws IOException { ResponseBody responseBody = response . body ( ) ; if ( response . isSuccessful ( ) ) { String responseBodyString = responseBody . string ( ) ; JSONObject responseJson = null ; try { responseJson = new JSONObject ( responseBodyString ) ; } catch ( JSONException exception ) { callback . error ( exception ) ; } GetLatestBundleResponse getLatestBundleResponse = new GetLatestBundleResponse ( responseJson ) ; callback . success ( getLatestBundleResponse ) ; } else { Exception exception = new Exception ( responseBody . string ( ) ) ; Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; callback . error ( exception ) ; } } } ) ; } private String getVersionCode ( ) throws PackageManager . NameNotFoundException { return String . valueOf ( getPackageInfo ( ) . versionCode ) ; } private String getVersionName ( ) throws PackageManager . NameNotFoundException { return getPackageInfo ( ) . versionName ; } private String [ ] getBundleIds ( ) { File bundlesDirectory = buildBundlesDirectory ( ) ; File [ ] bundles = bundlesDirectory . listFiles ( ) ; if ( bundles == null ) { return new String [ <NUM_LIT> ] ; } String [ ] bundleIds = new String [ bundles . length ] ; for ( int i = <NUM_LIT> ; i < bundles . length ; i ++ ) { bundleIds [ i ] = bundles [ i ] . getName ( ) ; } return bundleIds ; } private String getCurrentBundleId ( ) { String currentPath = getCurrentCapacitorServerPath ( ) ; if ( currentPath . equals ( defaultWebAssetDir ) ) { return defaultWebAssetDir ; } return new File ( currentPath ) . getName ( ) ; } private String getCurrentCapacitorServerPath ( ) { return plugin . getBridge ( ) . getServerBasePath ( ) ; } @ NonNull private String getDeviceId ( ) { String deviceId = preferences . getDeviceIdForApp ( config . getAppId ( ) ) ; if ( deviceId == null ) { deviceId = UUID . randomUUID ( ) . toString ( ) . toLowerCase ( ) ; preferences . setDeviceIdForApp ( config . getAppId ( ) , deviceId ) ; } return deviceId ; } @ NonNull private String getNextBundleId ( ) { String nextPath = getNextCapacitorServerPath ( ) ; if ( nextPath . equals ( defaultWebAssetDir ) ) { return defaultWebAssetDir ; } return new File ( nextPath ) . getName ( ) ; } @ NonNull private String getNextCapacitorServerPath ( ) { return plugin . getContext ( ) . getSharedPreferences ( WebView . WEBVIEW_PREFS_NAME , Activity . MODE_PRIVATE ) . getString ( WebView . CAP_SERVER_PATH , defaultWebAssetDir ) ; } private boolean hasBundle ( @ NonNull String bundleId ) { File bundleDirectory = buildBundleDirectoryFor ( bundleId ) ; return bundleDirectory . exists ( ) ; } private boolean isBundleInUse ( @ NonNull String bundleId ) { String currentBundleId = getCurrentBundleId ( ) ; String nextBundleId = getNextBundleId ( ) ; return bundleId . equals ( currentBundleId ) || bundleId . equals ( nextBundleId ) ; } private void rollback ( ) { if ( getCurrentBundleId ( ) == defaultWebAssetDir ) { Logger . debug ( LiveUpdatePlugin . TAG , "<STR_LIT>" ) ; return ; } Logger . debug ( LiveUpdatePlugin . TAG , "<STR_LIT>" ) ; setNextCapacitorServerPathToDefaultWebAssetDir ( ) ; setCurrentCapacitorServerPathToDefaultWebAssetDir ( ) ; } private void saveCurrentVersionCode ( ) throws PackageManager . NameNotFoundException { int currentVersionCode = getPackageInfo ( ) . versionCode ; preferences . setLastVersionCode ( currentVersionCode ) ; } @ Nullable private File searchIndexHtmlFile ( @ NonNull File directory ) { File [ ] files = directory . listFiles ( ) ; if ( files == null ) { return null ; } String [ ] fileNames = new String [ files . length ] ; for ( int i = <NUM_LIT> ; i < files . length ; i ++ ) { fileNames [ i ] = files [ i ] . getName ( ) ; } if ( Arrays . asList ( fileNames ) . contains ( "<STR_LIT>" ) ) { return new File ( directory , "<STR_LIT>" ) ; } else { for ( File file : files ) { if ( file . isDirectory ( ) ) { File indexHtmlFile = searchIndexHtmlFile ( file ) ; if ( indexHtmlFile != null ) { return indexHtmlFile ; } } } } return null ; } private void setCurrentCapacitorServerPath ( @ NonNull String path ) { if ( path . equals ( defaultWebAssetDir ) ) { this . plugin . getBridge ( ) . setServerAssetPath ( path ) ; } else { this . plugin . getBridge ( ) . setServerBasePath ( path ) ; } this . plugin . getBridge ( ) . reload ( ) ; } private void setCurrentCapacitorServerPathToDefaultWebAssetDir ( ) { setCurrentCapacitorServerPath ( defaultWebAssetDir ) ; } private void setNextBundle ( @ NonNull String bundleId ) { File bundleDirectory = buildBundleDirectoryFor ( bundleId ) ; setNextCapacitorServerPath ( bundleDirectory . getPath ( ) ) ; } private void setNextCapacitorServerPath ( @ NonNull String path ) { this . webViewSettingsEditor . putString ( WebView . CAP_SERVER_PATH , path ) ; this . webViewSettingsEditor . commit ( ) ; } private void setNextCapacitorServerPathToDefaultWebAssetDir ( ) { setNextCapacitorServerPath ( defaultWebAssetDir ) ; } private void startRollbackTimer ( ) { stopRollbackTimer ( ) ; rollbackHandler . postDelayed ( ( ) -> rollback ( ) , config . getReadyTimeout ( ) ) ; } private void stopRollbackTimer ( ) { rollbackHandler . removeCallbacksAndMessages ( null ) ; } private File unzipFile ( @ NonNull File zipFile ) throws IOException { File destination = buildTemporaryDirectory ( ) ; String destinationPath = destination . getPath ( ) ; new ZipFile ( zipFile ) . extractAll ( destinationPath ) ; return destination ; } private boolean verifySignatureForFile ( @ NonNull File file , @ NonNull String signature , @ NonNull PublicKey key ) throws Exception { try { byte [ ] signatureBytes = Base64 . decode ( signature , Base64 . DEFAULT ) ; Signature sig = Signature . getInstance ( "<STR_LIT>" ) ; sig . initVerify ( key ) ; BufferedSource source = Okio . buffer ( Okio . source ( file ) ) ; Buffer buffer = new Buffer ( ) ; for ( long bytesRead ; ( bytesRead = source . read ( buffer , <NUM_LIT> ) ) != - <NUM_LIT> ; ) { sig . update ( buffer . readByteArray ( ) ) ; } source . close ( ) ; return sig . verify ( signatureBytes ) ; } catch ( Exception exception ) { Logger . error ( LiveUpdatePlugin . TAG , exception . getMessage ( ) , exception ) ; throw new Exception ( LiveUpdatePlugin . ERROR_SIGNATURE_VERIFICATION_FAILED ) ; } } private boolean wasUpdated ( ) throws PackageManager . NameNotFoundException { int lastVersionCode = preferences . getLastVersionCode ( ) ; int currentVersionCode = getPackageInfo ( ) . versionCode ; return lastVersionCode != currentVersionCode ; } private PackageInfo getPackageInfo ( ) throws PackageManager . NameNotFoundException { String packageName = this . plugin . getContext ( ) . getPackageName ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { return this . plugin . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , PackageManager . PackageInfoFlags . of ( <NUM_LIT> ) ) ; } else { return this . plugin . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , <NUM_LIT> ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . fileopener ; import android . content . ActivityNotFoundException ; import android . content . Intent ; import android . net . Uri ; import android . util . Log ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class FileOpenerPlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_PATH_MISSING = "<STR_LIT>" ; public static final String ERROR_FILE_NOT_EXIST = "<STR_LIT>" ; public static final String ERROR_CANNOT_OPEN_FILE = "<STR_LIT>" ; private FileOpener implementation ; @ Override public void load ( ) { implementation = new FileOpener ( this ) ; } @ PluginMethod public void openFile ( PluginCall call ) { try { String path = call . getString ( "<STR_LIT>" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } String mimeType = call . getString ( "<STR_LIT>" ) ; Uri uri = implementation . getUriByPath ( path ) ; boolean fileExists = implementation . isFileExists ( uri ) ; if ( ! fileExists ) { call . reject ( ERROR_FILE_NOT_EXIST ) ; return ; } try { Intent intent = implementation . createIntent ( uri , mimeType ) ; getActivity ( ) . startActivity ( intent ) ; call . resolve ( ) ; } catch ( ActivityNotFoundException exception ) { call . reject ( ERROR_CANNOT_OPEN_FILE ) ; } } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . managedconfigurations ; import android . content . res . Configuration ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import org . json . JSONObject ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class ManagedConfigurationsPlugin extends Plugin { public static final String ERROR_KEY_MISSING = "<STR_LIT>" ; private ManagedConfigurations implementation ; @ Override public void load ( ) { implementation = new ManagedConfigurations ( getBridge ( ) ) ; } @ Override public void handleOnConfigurationChanged ( Configuration newConfig ) { super . handleOnConfigurationChanged ( newConfig ) ; implementation . refreshApplicationRestrictions ( ) ; } @ PluginMethod public void getString ( PluginCall call ) { String key = call . getString ( "<STR_LIT>" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } String value = implementation . getString ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , value == null ? JSONObject . NULL : value ) ; call . resolve ( ret ) ; } @ PluginMethod public void getNumber ( PluginCall call ) { String key = call . getString ( "<STR_LIT>" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } Integer value = implementation . getInteger ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , value == null ? JSONObject . NULL : value ) ; call . resolve ( ret ) ; } @ PluginMethod public void getBoolean ( PluginCall call ) { String key = call . getString ( "<STR_LIT>" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } Boolean value = implementation . getBoolean ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , value == null ? JSONObject . NULL : value ) ; call . resolve ( ret ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . appupdate ; import static android . app . Activity . RESULT_CANCELED ; import static android . app . Activity . RESULT_OK ; import static com . google . android . play . core . install . model . ActivityResult . RESULT_IN_APP_UPDATE_FAILED ; import android . content . ActivityNotFoundException ; import android . content . Intent ; import android . content . IntentSender ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . net . Uri ; import android . os . Build ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . android . gms . common . ConnectionResult ; import com . google . android . gms . common . GoogleApiAvailability ; import com . google . android . gms . tasks . Task ; import com . google . android . play . core . appupdate . AppUpdateInfo ; import com . google . android . play . core . appupdate . AppUpdateManager ; import com . google . android . play . core . appupdate . AppUpdateManagerFactory ; import com . google . android . play . core . install . InstallStateUpdatedListener ; import com . google . android . play . core . install . model . AppUpdateType ; import com . google . android . play . core . install . model . InstallStatus ; import com . google . android . play . core . install . model . UpdateAvailability ; @ CapacitorPlugin ( name = "<STR_LIT>" , requestCodes = { AppUpdatePlugin . REQUEST_IMMEDIATE_UPDATE , AppUpdatePlugin . REQUEST_FLEXIBLE_UPDATE } ) public class AppUpdatePlugin extends Plugin { public static final String TAG = "<STR_LIT>" ; public static final String ERROR_GET_APP_INFO_FAILED = "<STR_LIT>" ; public static final int UPDATE_OK = <NUM_LIT> ; public static final int UPDATE_CANCELED = <NUM_LIT> ; public static final int UPDATE_FAILED = <NUM_LIT> ; public static final int UPDATE_NOT_AVAILABLE = <NUM_LIT> ; public static final int UPDATE_NOT_ALLOWED = <NUM_LIT> ; public static final int UPDATE_INFO_MISSING = <NUM_LIT> ; public static final int REQUEST_IMMEDIATE_UPDATE = <NUM_LIT> ; public static final int REQUEST_FLEXIBLE_UPDATE = <NUM_LIT> ; public static final String ERROR_GOOGLE_PLAY_SERVICES_UNAVAILABLE = "<STR_LIT>" ; private AppUpdateManager appUpdateManager ; private AppUpdateInfo appUpdateInfo ; private InstallStateUpdatedListener listener ; private PluginCall savedPluginCall ; public void load ( ) { this . appUpdateManager = AppUpdateManagerFactory . create ( this . getContext ( ) ) ; } @ PluginMethod public void getAppUpdateInfo ( PluginCall call ) { try { boolean isGooglePlayServicesAvailable = this . isGooglePlayServicesAvailable ( ) ; if ( ! isGooglePlayServicesAvailable ) { call . reject ( ERROR_GOOGLE_PLAY_SERVICES_UNAVAILABLE ) ; return ; } Task < AppUpdateInfo > appUpdateInfoTask = this . appUpdateManager . getAppUpdateInfo ( ) ; appUpdateInfoTask . addOnSuccessListener ( appUpdateInfo -> { this . appUpdateInfo = appUpdateInfo ; PackageInfo pInfo ; try { pInfo = this . getPackageInfo ( ) ; } catch ( PackageManager . NameNotFoundException e ) { call . reject ( ERROR_GET_APP_INFO_FAILED ) ; return ; } JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , pInfo . versionName ) ; ret . put ( "<STR_LIT>" , String . valueOf ( pInfo . versionCode ) ) ; ret . put ( "<STR_LIT>" , String . valueOf ( appUpdateInfo . availableVersionCode ( ) ) ) ; ret . put ( "<STR_LIT>" , appUpdateInfo . updateAvailability ( ) ) ; ret . put ( "<STR_LIT>" , appUpdateInfo . updatePriority ( ) ) ; ret . put ( "<STR_LIT>" , appUpdateInfo . isUpdateTypeAllowed ( AppUpdateType . IMMEDIATE ) ) ; ret . put ( "<STR_LIT>" , appUpdateInfo . isUpdateTypeAllowed ( AppUpdateType . FLEXIBLE ) ) ; Integer clientVersionStalenessDays = appUpdateInfo . clientVersionStalenessDays ( ) ; if ( clientVersionStalenessDays != null ) { ret . put ( "<STR_LIT>" , clientVersionStalenessDays ) ; } ret . put ( "<STR_LIT>" , appUpdateInfo . installStatus ( ) ) ; call . resolve ( ret ) ; } ) ; appUpdateInfoTask . addOnFailureListener ( failure -> { String message = failure . getMessage ( ) ; call . reject ( message ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openAppStore ( PluginCall call ) { try { String packageName = this . getContext ( ) . getPackageName ( ) ; Intent launchIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( "<STR_LIT>" + packageName ) ) ; try { this . getBridge ( ) . getActivity ( ) . startActivity ( launchIntent ) ; } catch ( ActivityNotFoundException ex ) { launchIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( "<STR_LIT>" + packageName ) ) ; this . getBridge ( ) . getActivity ( ) . startActivity ( launchIntent ) ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void performImmediateUpdate ( PluginCall call ) { try { boolean ready = this . readyForUpdate ( call , AppUpdateType . IMMEDIATE ) ; if ( ! ready ) { return ; } savedPluginCall = call ; try { this . appUpdateManager . startUpdateFlowForResult ( this . appUpdateInfo , AppUpdateType . IMMEDIATE , getActivity ( ) , AppUpdatePlugin . REQUEST_IMMEDIATE_UPDATE ) ; } catch ( IntentSender . SendIntentException e ) { call . reject ( e . getMessage ( ) ) ; } } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void startFlexibleUpdate ( PluginCall call ) { try { boolean ready = this . readyForUpdate ( call , AppUpdateType . FLEXIBLE ) ; if ( ! ready ) { return ; } savedPluginCall = call ; this . listener = state -> { int installStatus = state . installStatus ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , installStatus ) ; if ( installStatus == InstallStatus . DOWNLOADING ) { ret . put ( "<STR_LIT>" , state . bytesDownloaded ( ) ) ; ret . put ( "<STR_LIT>" , state . totalBytesToDownload ( ) ) ; } notifyListeners ( "<STR_LIT>" , ret ) ; } ; this . appUpdateManager . registerListener ( this . listener ) ; this . appUpdateManager . startUpdateFlowForResult ( this . appUpdateInfo , AppUpdateType . FLEXIBLE , getActivity ( ) , AppUpdatePlugin . REQUEST_FLEXIBLE_UPDATE ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void completeFlexibleUpdate ( PluginCall call ) { try { this . unregisterListener ( ) ; this . appUpdateManager . completeUpdate ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override protected void handleOnActivityResult ( int requestCode , int resultCode , Intent data ) { try { super . handleOnActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK && requestCode == REQUEST_FLEXIBLE_UPDATE ) { this . unregisterListener ( ) ; } this . appUpdateInfo = null ; if ( savedPluginCall == null ) { return ; } JSObject ret = new JSObject ( ) ; if ( resultCode == RESULT_OK ) { ret . put ( "<STR_LIT>" , UPDATE_OK ) ; } else if ( resultCode == RESULT_CANCELED ) { ret . put ( "<STR_LIT>" , UPDATE_CANCELED ) ; } else if ( resultCode == RESULT_IN_APP_UPDATE_FAILED ) { ret . put ( "<STR_LIT>" , UPDATE_FAILED ) ; } savedPluginCall . resolve ( ret ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; if ( savedPluginCall == null ) { return ; } savedPluginCall . reject ( exception . getMessage ( ) ) ; } } private boolean isGooglePlayServicesAvailable ( ) { GoogleApiAvailability googleApiAvailability = GoogleApiAvailability . getInstance ( ) ; int resultCode = googleApiAvailability . isGooglePlayServicesAvailable ( bridge . getContext ( ) ) ; return resultCode == ConnectionResult . SUCCESS ; } private PackageInfo getPackageInfo ( ) throws PackageManager . NameNotFoundException { String packageName = this . getContext ( ) . getPackageName ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { return this . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , PackageManager . PackageInfoFlags . of ( <NUM_LIT> ) ) ; } else { return this . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , <NUM_LIT> ) ; } } private boolean readyForUpdate ( PluginCall call , int appUpdateType ) { JSObject ret = new JSObject ( ) ; if ( this . appUpdateInfo == null ) { ret . put ( "<STR_LIT>" , UPDATE_INFO_MISSING ) ; call . resolve ( ret ) ; return false ; } if ( this . appUpdateInfo . updateAvailability ( ) != UpdateAvailability . UPDATE_AVAILABLE ) { ret . put ( "<STR_LIT>" , UPDATE_NOT_AVAILABLE ) ; call . resolve ( ret ) ; return false ; } if ( ! this . appUpdateInfo . isUpdateTypeAllowed ( appUpdateType ) ) { ret . put ( "<STR_LIT>" , UPDATE_NOT_ALLOWED ) ; call . resolve ( ret ) ; return false ; } return true ; } private void unregisterListener ( ) { if ( this . listener == null || this . appUpdateManager == null ) { return ; } this . appUpdateManager . unregisterListener ( this . listener ) ; this . listener = null ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . foregroundservice ; import static android . content . Context . POWER_SERVICE ; import android . app . NotificationChannel ; import android . app . NotificationManager ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import androidx . annotation . Nullable ; import com . getcapacitor . plugin . util . AssetUtil ; import java . util . ArrayList ; public class ForegroundService { public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = "<STR_LIT>" ; private final ForegroundServicePlugin plugin ; @ Nullable private PowerManager . WakeLock activeWakeLock ; public ForegroundService ( ForegroundServicePlugin plugin ) { this . plugin = plugin ; createNotificationChannel ( ) ; } public void startForegroundService ( String body , String icon , int id , String title , ArrayList < Bundle > buttons ) { acquireWakeLock ( ) ; int iconResourceId = AssetUtil . getResourceID ( plugin . getContext ( ) , AssetUtil . getResourceBaseName ( icon ) , "<STR_LIT>" ) ; Bundle notificationBundle = new Bundle ( ) ; notificationBundle . putString ( "<STR_LIT>" , body ) ; notificationBundle . putInt ( "<STR_LIT>" , iconResourceId ) ; notificationBundle . putInt ( "<STR_LIT>" , id ) ; notificationBundle . putString ( "<STR_LIT>" , title ) ; notificationBundle . putParcelableArrayList ( "<STR_LIT>" , new ArrayList < Bundle > ( buttons ) ) ; Context context = plugin . getContext ( ) ; Intent intent = new Intent ( context , AndroidForegroundService . class ) ; intent . putExtra ( "<STR_LIT>" , notificationBundle ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { context . startForegroundService ( intent ) ; } else { context . startService ( intent ) ; } } public void stopForegroundService ( ) { releaseWakeLock ( ) ; Context context = plugin . getContext ( ) ; Intent intent = new Intent ( context , AndroidForegroundService . class ) ; context . stopService ( intent ) ; } private void acquireWakeLock ( ) { if ( activeWakeLock != null ) { return ; } PowerManager powerManager = ( PowerManager ) plugin . getContext ( ) . getSystemService ( POWER_SERVICE ) ; PowerManager . WakeLock wakeLock = powerManager . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , "<STR_LIT>" ) ; wakeLock . acquire ( ) ; activeWakeLock = wakeLock ; } private void releaseWakeLock ( ) { if ( activeWakeLock == null ) { return ; } activeWakeLock . release ( ) ; activeWakeLock = null ; } private void createNotificationChannel ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { CharSequence name = "<STR_LIT>" ; String description = "<STR_LIT>" ; int importance = NotificationManager . IMPORTANCE_DEFAULT ; NotificationChannel channel = new NotificationChannel ( DEFAULT_NOTIFICATION_CHANNEL_ID , name , importance ) ; channel . setDescription ( description ) ; NotificationManager notificationManager = plugin . getContext ( ) . getSystemService ( NotificationManager . class ) ; notificationManager . createNotificationChannel ( channel ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . backgroundtask ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class BackgroundTaskPlugin extends Plugin { private BackgroundTask implementation = new BackgroundTask ( ) ; @ PluginMethod ( returnType = PluginMethod . RETURN_CALLBACK ) public void beforeExit ( PluginCall call ) { String callbackId = call . getCallbackId ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( "<STR_LIT>" , callbackId ) ; call . resolve ( ret ) ; } @ PluginMethod public void finish ( PluginCall call ) { call . resolve ( ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; public class DatetimePickerConfig { private Theme theme = Theme . AUTO ; public Theme getTheme ( ) { return theme ; } public void setTheme ( String value , Theme fallback ) { Theme theme = DatetimePickerHelper . convertStringToTheme ( value ) ; if ( theme == null ) { this . theme = fallback ; } else { this . theme = theme ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate ; import android . app . Activity ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . UUID ; public class LiveUpdatePreferences { @ NonNull private final Context context ; @ NonNull private final SharedPreferences . Editor settingsEditor ; private final String channelKey = "<STR_LIT>" ; private final String deviceIdKey = "<STR_LIT>" ; private final String customIdKey = "<STR_LIT>" ; private final String lastVersionCodeKey = "<STR_LIT>" ; public LiveUpdatePreferences ( @ NonNull Context context ) { this . context = context ; this . settingsEditor = context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . edit ( ) ; } @ Nullable public String getChannel ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( channelKey , null ) ; } @ Nullable public String getCustomId ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( customIdKey , null ) ; } @ Nullable public String getDeviceIdForApp ( @ Nullable String appId ) { if ( appId == null ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( deviceIdKey , null ) ; } else { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( deviceIdKey + "<STR_LIT>" + appId , null ) ; } } public int getLastVersionCode ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getInt ( lastVersionCodeKey , <NUM_LIT> ) ; } public void setChannel ( @ Nullable String channel ) { if ( channel == null ) { settingsEditor . remove ( channelKey ) ; } else { settingsEditor . putString ( channelKey , channel ) ; } settingsEditor . apply ( ) ; } public void setCustomId ( @ Nullable String customId ) { if ( customId == null ) { settingsEditor . remove ( customIdKey ) ; } else { settingsEditor . putString ( customIdKey , customId ) ; } settingsEditor . apply ( ) ; } public void setDeviceIdForApp ( @ Nullable String appId , @ NonNull String deviceId ) { if ( appId == null ) { settingsEditor . putString ( deviceIdKey , deviceId ) ; } else { settingsEditor . putString ( deviceIdKey + "<STR_LIT>" + appId , deviceId ) ; } settingsEditor . apply ( ) ; } public void setLastVersionCode ( int lastVersionCode ) { settingsEditor . putInt ( lastVersionCodeKey , lastVersionCode ) ; settingsEditor . apply ( ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . photoeditor ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . content . pm . ResolveInfo ; import android . net . Uri ; import android . provider . MediaStore ; import androidx . core . content . FileProvider ; import com . getcapacitor . Bridge ; import com . getcapacitor . Logger ; import java . io . File ; import java . net . URI ; import java . util . List ; public class PhotoEditor { private Bridge bridge ; PhotoEditor ( Bridge bridge ) { this . bridge = bridge ; } public Intent createEditPhotoIntent ( String path ) { try { File file = new File ( new URI ( path ) ) ; String contextPackageName = bridge . getContext ( ) . getPackageName ( ) ; Uri uri = FileProvider . getUriForFile ( bridge . getActivity ( ) , contextPackageName + "<STR_LIT>" , file ) ; Intent intent = new Intent ( Intent . ACTION_EDIT ) ; intent . setDataAndType ( uri , "<STR_LIT>" ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , uri ) ; int flags = Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION ; intent . addFlags ( flags ) ; List < ResolveInfo > resolveInfoList = bridge . getContext ( ) . getPackageManager ( ) . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; for ( ResolveInfo resolveInfo : resolveInfoList ) { String packageName = resolveInfo . activityInfo . packageName ; bridge . getContext ( ) . grantUriPermission ( packageName , uri , flags ) ; } return intent ; } catch ( Exception exception ) { Logger . error ( "<STR_LIT>" , exception ) ; return null ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class SetCustomIdOptions { @ NonNull private String customId ; public SetCustomIdOptions ( @ NonNull String customId ) { this . customId = customId ; } @ NonNull public String getCustomId ( ) { return customId ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetChannelResult implements Result { @ Nullable private String channel ; public GetChannelResult ( @ Nullable String channel ) { this . channel = channel ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , channel ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . photoeditor ; import android . app . Activity ; import android . content . Intent ; import androidx . activity . result . ActivityResult ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class PhotoEditorPlugin extends Plugin { public static final String ERROR_PATH_MISSING = "<STR_LIT>" ; public static final String ERROR_EDIT_PHOTO_FAILED = "<STR_LIT>" ; public static final String ERROR_EDIT_PHOTO_CANCELED = "<STR_LIT>" ; private PhotoEditor implementation ; @ Override public void load ( ) { implementation = new PhotoEditor ( getBridge ( ) ) ; } @ PluginMethod public void editPhoto ( PluginCall call ) { String path = call . getString ( "<STR_LIT>" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Intent intent = implementation . createEditPhotoIntent ( path ) ; if ( intent == null ) { call . reject ( ERROR_EDIT_PHOTO_FAILED ) ; return ; } startActivityForResult ( call , intent , "<STR_LIT>" ) ; } @ ActivityCallback private void handleEditPhotoResult ( PluginCall call , ActivityResult result ) { if ( call == null ) { return ; } int resultCode = result . getResultCode ( ) ; switch ( resultCode ) { case Activity . RESULT_OK : call . resolve ( ) ; break ; case Activity . RESULT_CANCELED : call . reject ( ERROR_EDIT_PHOTO_CANCELED ) ; break ; default : call . reject ( ERROR_EDIT_PHOTO_FAILED ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetBundleResult implements Result { @ Nullable private String bundleId ; public GetBundleResult ( @ Nullable String bundleId ) { this . bundleId = bundleId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , bundleId == null ? JSONObject . NULL : bundleId ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . screenorientation ; import android . content . pm . ActivityInfo ; import android . content . res . Configuration ; import android . view . Surface ; import androidx . annotation . Nullable ; import com . getcapacitor . Bridge ; public class ScreenOrientation { interface ScreenOrientationChangeListener { void onScreenOrientationChanged ( ) ; } @ Nullable private ScreenOrientationChangeListener orientationChangeListener ; @ Nullable private int lastOrientationConfiguration ; private Bridge bridge ; ScreenOrientation ( Bridge bridge ) { this . bridge = bridge ; } public void handleOnConfigurationChanged ( Configuration newConfig ) { if ( newConfig . orientation == lastOrientationConfiguration ) { return ; } this . lastOrientationConfiguration = newConfig . orientation ; if ( this . orientationChangeListener == null ) { return ; } this . orientationChangeListener . onScreenOrientationChanged ( ) ; } public void setOrientationChangeListener ( @ Nullable ScreenOrientationChangeListener listener ) { this . orientationChangeListener = listener ; } @ Nullable public ScreenOrientationChangeListener getOrientationChangeListener ( ) { return orientationChangeListener ; } public void lock ( String orientationType ) { switch ( orientationType ) { case ScreenOrientationType . LANDSCAPE : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_SENSOR_LANDSCAPE ) ; break ; case ScreenOrientationType . LANDSCAPE_PRIMARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LANDSCAPE ) ; break ; case ScreenOrientationType . LANDSCAPE_SECONDARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE ) ; break ; case ScreenOrientationType . PORTRAIT : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_SENSOR_PORTRAIT ) ; break ; case ScreenOrientationType . PORTRAIT_PRIMARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; break ; case ScreenOrientationType . PORTRAIT_SECONDARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_PORTRAIT ) ; break ; } } public void unlock ( ) { bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_USER ) ; } public String getCurrentOrientationType ( ) { int rotation = bridge . getActivity ( ) . getWindowManager ( ) . getDefaultDisplay ( ) . getRotation ( ) ; switch ( rotation ) { case Surface . ROTATION_90 : return ScreenOrientationType . LANDSCAPE_PRIMARY ; case Surface . ROTATION_180 : return ScreenOrientationType . PORTRAIT_SECONDARY ; case Surface . ROTATION_270 : return ScreenOrientationType . LANDSCAPE_SECONDARY ; default : return ScreenOrientationType . PORTRAIT_PRIMARY ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . filepicker ; import android . database . Cursor ; import android . graphics . BitmapFactory ; import android . media . MediaMetadataRetriever ; import android . net . Uri ; import android . provider . DocumentsContract ; import android . provider . OpenableColumns ; import android . util . Base64 ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . Bridge ; import com . getcapacitor . Logger ; import java . io . ByteArrayOutputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public class FilePicker { public static final String TAG = "<STR_LIT>" ; private Bridge bridge ; FilePicker ( Bridge bridge ) { this . bridge = bridge ; } public String getPathFromUri ( @ NonNull Uri uri ) { return uri . toString ( ) ; } public String getNameFromUri ( @ NonNull Uri uri ) { String displayName = "<STR_LIT>" ; String [ ] projection = { OpenableColumns . DISPLAY_NAME } ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( projection [ <NUM_LIT> ] ) ; displayName = cursor . getString ( columnIdx ) ; cursor . close ( ) ; } if ( displayName == null || displayName . length ( ) < <NUM_LIT> ) { displayName = uri . getLastPathSegment ( ) ; } return displayName ; } public String getDataFromUri ( @ NonNull Uri uri ) { try { InputStream stream = bridge . getActivity ( ) . getContentResolver ( ) . openInputStream ( uri ) ; byte [ ] bytes = getBytesFromInputStream ( stream ) ; return Base64 . encodeToString ( bytes , Base64 . NO_WRAP ) ; } catch ( FileNotFoundException e ) { Logger . error ( TAG , "<STR_LIT>" , e ) ; } catch ( IOException e ) { Logger . error ( TAG , "<STR_LIT>" , e ) ; } return "<STR_LIT>" ; } @ Nullable public String getMimeTypeFromUri ( @ NonNull Uri uri ) { return bridge . getContext ( ) . getContentResolver ( ) . getType ( uri ) ; } @ Nullable public Long getModifiedAtFromUri ( @ NonNull Uri uri ) { try { long modifiedAt = <NUM_LIT> ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , null , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( DocumentsContract . Document . COLUMN_LAST_MODIFIED ) ; modifiedAt = cursor . getLong ( columnIdx ) ; cursor . close ( ) ; } return modifiedAt ; } catch ( Exception e ) { Logger . error ( TAG , "<STR_LIT>" , e ) ; return null ; } } public long getSizeFromUri ( @ NonNull Uri uri ) { long size = <NUM_LIT> ; String [ ] projection = { OpenableColumns . SIZE } ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( projection [ <NUM_LIT> ] ) ; size = cursor . getLong ( columnIdx ) ; cursor . close ( ) ; } return size ; } @ Nullable public Long getDurationFromUri ( @ NonNull Uri uri ) { if ( isVideoUri ( uri ) ) { MediaMetadataRetriever retriever = new MediaMetadataRetriever ( ) ; retriever . setDataSource ( bridge . getContext ( ) , uri ) ; String time = retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_DURATION ) ; long durationMs = Long . parseLong ( time ) ; try { retriever . release ( ) ; } catch ( Exception e ) { Logger . error ( TAG , "<STR_LIT>" , e ) ; } return durationMs / <NUM_LIT> ; } return null ; } @ Nullable public FileResolution getHeightAndWidthFromUri ( @ NonNull Uri uri ) { if ( isImageUri ( uri ) ) { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; try { BitmapFactory . decodeStream ( bridge . getContext ( ) . getContentResolver ( ) . openInputStream ( uri ) , null , options ) ; return new FileResolution ( options . outHeight , options . outWidth ) ; } catch ( FileNotFoundException exception ) { exception . printStackTrace ( ) ; return null ; } } else if ( isVideoUri ( uri ) ) { MediaMetadataRetriever retriever = new MediaMetadataRetriever ( ) ; retriever . setDataSource ( bridge . getContext ( ) , uri ) ; int width = Integer . valueOf ( retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_VIDEO_WIDTH ) ) ; int height = Integer . valueOf ( retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_VIDEO_HEIGHT ) ) ; try { retriever . release ( ) ; } catch ( Exception e ) { Logger . error ( TAG , "<STR_LIT>" , e ) ; } return new FileResolution ( height , width ) ; } return null ; } private boolean isImageUri ( Uri uri ) { String mimeType = getMimeTypeFromUri ( uri ) ; if ( mimeType == null ) { return false ; } return mimeType . startsWith ( "<STR_LIT>" ) ; } private boolean isVideoUri ( Uri uri ) { String mimeType = getMimeTypeFromUri ( uri ) ; if ( mimeType == null ) { return false ; } return mimeType . startsWith ( "<STR_LIT>" ) ; } private static byte [ ] getBytesFromInputStream ( InputStream is ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; for ( int len = is . read ( buffer ) ; len != - <NUM_LIT> ; len = is . read ( buffer ) ) { os . write ( buffer , <NUM_LIT> , len ) ; } return os . toByteArray ( ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . screenorientation ; import android . content . res . Configuration ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = "<STR_LIT>" ) public class ScreenOrientationPlugin extends Plugin { public static final String SCREEN_ORIENTATION_CHANGE_EVENT = "<STR_LIT>" ; private ScreenOrientation implementation ; @ Override public void load ( ) { implementation = new ScreenOrientation ( getBridge ( ) ) ; implementation . setOrientationChangeListener ( this :: updateOrientation ) ; } @ Override public void handleOnConfigurationChanged ( Configuration newConfig ) { super . handleOnConfigurationChanged ( newConfig ) ; implementation . handleOnConfigurationChanged ( newConfig ) ; } @ PluginMethod public void lock ( PluginCall call ) { String orientationType = call . getString ( "<STR_LIT>" ) ; implementation . lock ( orientationType ) ; call . resolve ( ) ; } @ PluginMethod public void unlock ( PluginCall call ) { implementation . unlock ( ) ; call . resolve ( ) ; } @ PluginMethod public void getCurrentOrientation ( PluginCall call ) { JSObject ret = new JSObject ( ) ; String orientationType = implementation . getCurrentOrientationType ( ) ; ret . put ( "<STR_LIT>" , orientationType ) ; call . resolve ( ret ) ; } private void updateOrientation ( ) { JSObject ret = new JSObject ( ) ; String orientationType = implementation . getCurrentOrientationType ( ) ; ret . put ( "<STR_LIT>" , orientationType ) ; notifyListeners ( SCREEN_ORIENTATION_CHANGE_EVENT , ret ) ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetCustomIdResult implements Result { @ Nullable private String customId ; public GetCustomIdResult ( @ Nullable String customId ) { this . customId = customId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( "<STR_LIT>" , customId == null ? JSONObject . NULL : customId ) ; return result ; } } </s>
<s> package io . capawesome . capacitorjs . plugins . datetimepicker ; public enum AndroidDatePickerMode { CALENDAR , SPINNER } </s>
<s> package io . capawesome . capacitorjs . plugins . fileopener ; import android . content . ContentResolver ; import android . content . Intent ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . FileProvider ; import androidx . documentfile . provider . DocumentFile ; import java . io . File ; public class FileOpener { private FileOpenerPlugin plugin ; FileOpener ( FileOpenerPlugin plugin ) { this . plugin = plugin ; } public Intent createIntent ( @ NonNull Uri uri , @ Nullable String mimeType ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; if ( mimeType == null || mimeType . trim ( ) . equals ( "<STR_LIT>" ) ) { intent . setDataAndNormalize ( uri ) ; } else { intent . setDataAndTypeAndNormalize ( uri , mimeType ) ; } intent . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION ) ; return intent ; } public boolean isFileExists ( @ NonNull Uri uri ) { DocumentFile document = DocumentFile . fromSingleUri ( plugin . getContext ( ) , uri ) ; return document . exists ( ) ; } public Uri getUriByPath ( @ NonNull String path ) { Uri uri = Uri . parse ( path ) ; if ( uri . getScheme ( ) != null && uri . getScheme ( ) . equals ( ContentResolver . SCHEME_CONTENT ) ) { return uri ; } else if ( uri . getScheme ( ) == null || uri . getScheme ( ) . equals ( ContentResolver . SCHEME_FILE ) ) { return FileProvider . getUriForFile ( plugin . getActivity ( ) , plugin . getContext ( ) . getPackageName ( ) + "<STR_LIT>" , new File ( uri . getPath ( ) ) ) ; } else { return FileProvider . getUriForFile ( plugin . getActivity ( ) , plugin . getContext ( ) . getPackageName ( ) + "<STR_LIT>" , new File ( path ) ) ; } } } </s>
<s> package io . capawesome . capacitorjs . plugins . cloudinary ; public interface DownloadResourceResultCallback { void success ( String path ) ; void error ( String message ) ; } </s>
<s> package io . capawesome . capacitorjs . plugins . managedconfigurations ; import android . content . RestrictionsManager ; import android . os . Bundle ; import com . getcapacitor . Bridge ; public class ManagedConfigurations { private RestrictionsManager myRestrictionsMgr ; private Bundle appRestrictions ; ManagedConfigurations ( Bridge bridge ) { myRestrictionsMgr = ( RestrictionsManager ) bridge . getActivity ( ) . getSystemService ( bridge . getContext ( ) . RESTRICTIONS_SERVICE ) ; this . refreshApplicationRestrictions ( ) ; } public void refreshApplicationRestrictions ( ) { appRestrictions = myRestrictionsMgr . getApplicationRestrictions ( ) ; } public String getString ( String key ) { if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getString ( key ) ; } return null ; } public Integer getInteger ( String key ) { if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getInt ( key ) ; } return null ; } public Boolean getBoolean ( String key ) { if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getBoolean ( key ) ; } return null ; } } </s>
<s> package icu . freedomIntrovert . async ; public abstract class BackstageTask < T extends EventHandler > implements Runnable { private final T handle ; public BackstageTask ( T handle ) { this . handle = handle ; } @ Override public void run ( ) { try { onStart ( handle ) ; } catch ( Throwable e ) { handle . sendError ( e ) ; } } public void execute ( ) { TaskManger . execute ( this ) ; } protected abstract void onStart ( T eventHandler ) throws Throwable ; protected void sleep ( long time ) { try { Thread . sleep ( time ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostDanmakuHook extends BaseHook { public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { AtomicLong currentOid = new AtomicLong ( ) ; AtomicLong currentAvid = new AtomicLong ( ) ; AtomicReference < String > currentContent = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , Context . class , String . class , classLoader . loadClass ( "<STR_LIT>" ) , int . class , String . class , String . class , String . class , String . class , Long . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . toString ( ) ) . append ( "<STR_LIT>" ) ; } else { sb . append ( i ) . append ( "<STR_LIT>" ) ; } currentContent . set ( ( String ) param . args [ <NUM_LIT> ] ) ; currentOid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; currentAvid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . toString ( ) ) . append ( "<STR_LIT>" ) ; } else { sb . append ( i ) . append ( "<STR_LIT>" ) ; } Class < ? > biliAccountsClass = classLoader . loadClass ( "<STR_LIT>" ) ; Field contextField = param . thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; contextField . setAccessible ( true ) ; Context context = ( Context ) contextField . get ( param . thisObject ) ; XposedBridge . log ( "<STR_LIT>" + context . toString ( ) ) ; Object biliAccounts = biliAccountsClass . getMethod ( "<STR_LIT>" , Context . class ) . invoke ( null , context ) ; String accessKey = ( String ) biliAccounts . getClass ( ) . getMethod ( "<STR_LIT>" ) . invoke ( biliAccounts ) ; XposedBridge . log ( "<STR_LIT>" + accessKey ) ; Object danmakuSendResponse = param . args [ <NUM_LIT> ] ; Method dmidMethod = danmakuSendResponse . getClass ( ) . getMethod ( "<STR_LIT>" ) ; long dmid = ( long ) dmidMethod . invoke ( danmakuSendResponse ) ; Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_DANMAKU ) ; intent . putExtra ( "<STR_LIT>" , currentOid . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , dmid ) ; intent . putExtra ( "<STR_LIT>" , currentContent . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , accessKey ) ; intent . putExtra ( "<STR_LIT>" , currentAvid . get ( ) ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) ) ; context . startActivity ( intent ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . net . Uri ; import android . os . Handler ; import android . text . Spannable ; import android . text . SpannableStringBuilder ; import android . text . style . ForegroundColorSpan ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import android . widget . TextView ; import android . widget . Toast ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . AreaMartialLawCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . BannedOnlyInThisAreaCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . CommentCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . SensitiveScannerTask ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class DialogCommCheckWorker implements BiliBiliApiRequestHandler . DialogErrorHandle . OnDialogMessageListener { public static final int BANNED_TYPE_SHADOW_BAN = <NUM_LIT> ; public static final int BANNED_TYPE_QUICK_DELETE = <NUM_LIT> ; public static final int BANNED_TYPE_UNDER_REVIEW = <NUM_LIT> ; public static final int BANNED_TYPE_INVISIBLE = <NUM_LIT> ; private Context context ; private Config config ; private StatisticsDBOpenHelper statDB ; private Handler handler ; private CommentManipulator commentManipulator ; private CommentUtil commentUtil ; private OnExitListener exitListener ; public DialogCommCheckWorker ( Context context , Config config , StatisticsDBOpenHelper statDB , CommentManipulator commentManipulator , CommentUtil commentUtil ) { this . context = context ; this . config = config ; this . statDB = statDB ; this . commentManipulator = commentManipulator ; this . commentUtil = commentUtil ; this . handler = new Handler ( ) ; } public void setExitListener ( OnExitListener exitListener ) { this . exitListener = exitListener ; } public void checkComment ( Comment comment , ProgressBarDialog dialog ) { if ( commentManipulator . cookieAreSet ( ) ) { DialogCommentCheckEventHandler handle = new DialogCommentCheckEventHandler ( dialog , comment , this ) ; new CommentCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil . getRandomComment ( comment . commentArea ) ) . execute ( ) ; } else { dialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; } } private static class DialogCommentCheckEventHandler extends CommentCheckTask . EventHandler { private final ProgressBarDialog dialog ; private final Comment comment ; private final DialogCommCheckWorker worker ; public DialogCommentCheckEventHandler ( ProgressBarDialog dialog , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( dialog , worker ) ) ; this . dialog = dialog ; this . comment = comment ; this . worker = worker ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_START_COMMENT_CHECK : dialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_ON_COMMENT_NOT_FOUND : dialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY : dialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_THEN_COMMENT_OK : dialog . dismiss ( ) ; worker . showCommentIsOkResult ( comment . comment , comment . rpid ) ; break ; case WHAT_THEN_SHADOW_BAN : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_SHADOW_BAN , comment ) ; break ; case WHAT_THEN_DELETED : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_QUICK_DELETE , comment ) ; break ; case WHAT_THEN_UNDER_REVIEW : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_UNDER_REVIEW , comment ) ; break ; case WHAT_THEN_INVISIBLE : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_INVISIBLE , comment ) ; break ; } } } private void showCommentIsOkResult ( String comment , long rpid ) { onNewCommentRpid ( rpid ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + comment + "<STR_LIT>" ) . setCancelable ( false ) . setOnDismissListener ( dialog13 -> exit ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; } private void showCommentBannedResult ( int bannedType , Comment comment ) { onNewCommentRpid ( comment . rpid ) ; CommentArea commentArea = comment . commentArea ; long rpid = comment . rpid ; String commentText = comment . comment ; AlertDialog . Builder resultDialogBuilder = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) ; switch ( bannedType ) { case BANNED_TYPE_SHADOW_BAN : resultDialogBuilder . setIcon ( R . drawable . hide_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } else { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } break ; case BANNED_TYPE_UNDER_REVIEW : resultDialogBuilder . setIcon ( R . drawable . i_black ) ; resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; break ; case BANNED_TYPE_QUICK_DELETE : resultDialogBuilder . setIcon ( R . drawable . deleted_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } else { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } break ; case BANNED_TYPE_INVISIBLE : resultDialogBuilder . setIcon ( R . drawable . ghost_black ) ; resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; break ; } resultDialogBuilder . setOnDismissListener ( dialog -> exit ( ) ) ; resultDialogBuilder . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; resultDialogBuilder . setNeutralButton ( "<STR_LIT>" , null ) ; resultDialogBuilder . setNegativeButton ( "<STR_LIT>" , null ) ; AlertDialog resultDialog = resultDialogBuilder . show ( ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEUTRAL ) . setOnClickListener ( v -> new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" } , ( dialog , which ) -> { boolean isDeputyAccount = which == <NUM_LIT> ; checkAreaMartialLaw ( comment , null , isDeputyAccount ) ; } ) . show ( ) ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEGATIVE ) . setOnClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case <NUM_LIT> : scanSensitiveWord ( comment ) ; break ; case <NUM_LIT> : AlertDialog dialog1 = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog23 , which1 ) -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog24 , which1 ) -> { AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , handler , commentManipulator ) ; appealDialogPresenter . appeal ( CommentUtil . sourceIdToUrl ( commentArea ) , commentText , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { if ( code == <NUM_LIT> ) { statDB . updateHistoryCommentLastState ( rpid , HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ; toastLong ( toastText + "<STR_LIT>" ) ; } else { toastLong ( toastText ) ; } } @ Override public void onNetErrInUI ( String msg ) { toastNetError ( msg ) ; } } ) ; } ) . show ( ) ; break ; case <NUM_LIT> : commentManipulator . createDeleteCommentCall ( commentArea , rpid ) . enqueue ( new BiliApiCallback < GeneralResponse < Object > > ( ) { @ Override public void onError ( Throwable th ) { toastNetError ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < Object > unused ) { resultDialog . dismiss ( ) ; if ( unused . isSuccess ( ) ) { toastLong ( "<STR_LIT>" ) ; } else { toastLong ( "<STR_LIT>" ) ; } } } ) ; break ; case <NUM_LIT> : ClipboardManager cm = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData mClipData = ClipData . newPlainText ( "<STR_LIT>" , "<STR_LIT>" + rpid + "<STR_LIT>" + commentArea . oid + "<STR_LIT>" + commentArea . type ) ; cm . setPrimaryClip ( mClipData ) ; toastShort ( "<STR_LIT>" ) ; } } } ) . show ( ) ; } ) ; } public void checkAreaMartialLaw ( Comment comment , DialogInterface . OnDismissListener onDismissListener , boolean isDeputyAccount ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; if ( ! isDeputyAccount ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } else { if ( commentManipulator . deputyCookieAreSet ( ) ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } else { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; } } AreaCheckHandler handle = new AreaCheckHandler ( progressDialog , onDismissListener , comment , this ) ; new AreaMartialLawCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil , isDeputyAccount ) . execute ( ) ; } private static class AreaCheckHandler extends AreaMartialLawCheckTask . EventHandler { ProgressDialog progressDialog ; Comment comment ; DialogCommCheckWorker worker ; DialogInterface . OnDismissListener onDismissListener ; public AreaCheckHandler ( ProgressDialog progressDialog , DialogInterface . OnDismissListener onDismissListener , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . progressDialog = progressDialog ; this . comment = comment ; this . worker = worker ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_TEST_COMMENT_SENT : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , String . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_THEN_AREA_OK : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , ( dialog1 , which ) -> { CommentArea yourCommentArea = worker . commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { worker . commentUtil . setYourCommentArea ( worker . context , worker . commentManipulator ) ; } else { worker . checkIfBannedOnlyInThisArea ( comment , onDismissListener , yourCommentArea ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; case WHAT_THEN_MARTIAL_LAW : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; } } } private void checkIfBannedOnlyInThisArea ( Comment comment , DialogInterface . OnDismissListener onDismissListener , CommentArea yourCommentArea ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; BannedOnlyInThisAreaCheckHandler handler = new BannedOnlyInThisAreaCheckHandler ( this , onDismissListener , progressDialog ) ; new BannedOnlyInThisAreaCheckTask ( handler , commentManipulator , config , statDB , comment , yourCommentArea ) . execute ( ) ; } private static class BannedOnlyInThisAreaCheckHandler extends BannedOnlyInThisAreaCheckTask . EventHandler { DialogCommCheckWorker worker ; ProgressDialog progressDialog ; DialogInterface . OnDismissListener onDismissListener ; public BannedOnlyInThisAreaCheckHandler ( DialogCommCheckWorker worker , DialogInterface . OnDismissListener onDismissListener , ProgressDialog progressDialog ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . worker = worker ; this . progressDialog = progressDialog ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_COMMENT_SENT_TO_YOUR_AREA : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , String . class ) ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_THEN_ONLY_BANNED_IN_THIS_AREA : progressDialog . dismiss ( ) ; showResult ( "<STR_LIT>" ) ; break ; case WHAT_THEN_BANNED_IN_YOUR_AREA : showResult ( "<STR_LIT>" ) ; break ; } } private void showResult ( String message ) { progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( message ) . setOnDismissListener ( onDismissListener ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } } public void scanSensitiveWord ( Comment mainComment ) { if ( mainComment . comment . length ( ) < <NUM_LIT> ) { toastShort ( "<STR_LIT>" ) ; return ; } final int [ ] commentAreaSelect = new int [ ] { <NUM_LIT> } ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setSingleChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , } , commentAreaSelect [ <NUM_LIT> ] , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { commentAreaSelect [ <NUM_LIT> ] = which ; } } ) . setNegativeButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { switch ( commentAreaSelect [ <NUM_LIT> ] ) { case <NUM_LIT> : CommentArea yourCommentArea = commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setYourCommentArea ( context , commentManipulator ) ; } else { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , yourCommentArea , commentManipulator , config , statDB ) . execute ( ) ; } break ; case <NUM_LIT> : if ( ! commentManipulator . deputyCookieAreSet ( ) ) { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; return ; } String dynamicId = commentUtil . getForwardDynamicId ( ) ; if ( dynamicId != null ) { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , dynamicId , commentManipulator , config , statDB ) . execute ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setDynamicIdToBeForward ( context , commentManipulator ) ; } break ; case <NUM_LIT> : SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , mainComment . commentArea , commentManipulator , config , statDB ) . execute ( ) ; break ; } } ) . show ( ) ; } private static class SensitiveScannerHandler extends SensitiveScannerTask . EventHandler { private final DialogCommCheckWorker worker ; private final AlertDialog dialog ; private final Comment mainComment ; private final String commentText ; private final TextView txv_comment_content ; private final ProgressBar pb_scanning_ssw ; private final ProgressBar pb_wait ; private final TextView txv_scanning_status ; private final TextView txv_scanning_progress ; Button buttonClose ; private final ForegroundColorSpan greenSpan ; private final ForegroundColorSpan redSpan ; private final ForegroundColorSpan yellowSpan ; private final ForegroundColorSpan blueSpan ; public SensitiveScannerHandler ( DialogCommCheckWorker worker , Comment mainComment ) { super ( null ) ; this . worker = worker ; this . mainComment = mainComment ; Context context = worker . context ; View dialogView = View . inflate ( context , R . layout . dialog_scanning_sensitive_word , null ) ; txv_comment_content = dialogView . findViewById ( R . id . txv_scanning_result_of_sensitive_world ) ; pb_scanning_ssw = dialogView . findViewById ( R . id . prog_scanning_ssw ) ; pb_wait = dialogView . findViewById ( R . id . prog_wait ) ; txv_scanning_status = dialogView . findViewById ( R . id . txv_scanning_status ) ; txv_scanning_progress = dialogView . findViewById ( R . id . txv_scanning_progress ) ; this . dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setCancelable ( false ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; buttonClose = dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) ; buttonClose . setEnabled ( false ) ; commentText = mainComment . comment ; txv_comment_content . setText ( commentText ) ; greenSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . green ) ) ; redSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . red ) ) ; yellowSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . yellow ) ) ; blueSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . blue ) ) ; setErrorHandle ( new DialogErrorHandle ( dialog , worker ) ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override protected void handleEvent ( EventMessage message ) { SpannableStringBuilder builder ; switch ( message . getWhat ( ) ) { case WHAT_COMMENT_FULL_TEXT_SENT : txv_scanning_status . setText ( String . format ( "<STR_LIT>" , message . getObject ( <NUM_LIT> , Long . class ) ) ) ; SpannableStringBuilder stringBuilder = new SpannableStringBuilder ( commentText ) ; stringBuilder . setSpan ( blueSpan , <NUM_LIT> , commentText . length ( ) , SpannableStringBuilder . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( stringBuilder ) ; break ; case WHAT_COMMENT_FULL_TEXT_IS_NORMAL : builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , commentText . length ( ) , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; CommentArea commentArea = message . getObject ( <NUM_LIT> , CommentArea . class ) ; if ( commentArea == mainComment . commentArea ) { txv_scanning_status . setText ( "<STR_LIT>" + commentArea . sourceId + "<STR_LIT>" ) ; } else { txv_scanning_status . setText ( "<STR_LIT>" ) ; } dialog . setTitle ( "<STR_LIT>" ) ; pb_scanning_ssw . setMax ( <NUM_LIT> ) ; pb_scanning_ssw . setProgress ( <NUM_LIT> ) ; pb_wait . setIndeterminate ( false ) ; buttonClose . setEnabled ( true ) ; break ; case WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT : int normalPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitLeftPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitRightPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; long waitTime = message . getObject ( <NUM_LIT> , Long . class ) ; builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( yellowSpan , normalPosition , splitLeftPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( blueSpan , splitLeftPosition , splitRightPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; txv_scanning_status . setText ( String . format ( "<STR_LIT>" , waitTime ) ) ; break ; case WHAT_ON_CHECKING_COMMENT : int currProgress = message . getObject ( <NUM_LIT> , Integer . class ) ; int max = message . getObject ( <NUM_LIT> , Integer . class ) ; pb_scanning_ssw . setMax ( max ) ; pb_scanning_ssw . setProgress ( currProgress ) ; txv_scanning_progress . setText ( String . format ( "<STR_LIT>" , currProgress , max ) ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_ON_CHECK_RESULT : SensitiveScanResult result = message . getObject ( <NUM_LIT> , SensitiveScanResult . class ) ; SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder ( commentText ) ; spannableStringBuilder . setSpan ( greenSpan , <NUM_LIT> , result . normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; System . out . println ( result . unusualPosition ) ; spannableStringBuilder . setSpan ( redSpan , result . normalPosition , result . unusualPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( spannableStringBuilder ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_ON_SCAN_COMPLETE : dialog . setTitle ( "<STR_LIT>" ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; buttonClose . setEnabled ( true ) ; buttonClose . setOnClickListener ( v -> { dialog . dismiss ( ) ; } ) ; pb_wait . setIndeterminate ( false ) ; worker . onCommentStatusUpdated ( mainComment . rpid ) ; break ; case WHAT_NEW_SLEEP_PROGRESS_MAX : int progressMax = message . getObject ( <NUM_LIT> , Integer . class ) ; if ( progressMax >= <NUM_LIT> ) { pb_wait . setIndeterminate ( false ) ; pb_wait . setMax ( progressMax ) ; } else { pb_wait . setIndeterminate ( true ) ; } break ; case WHAT_NEW_SLEEP_PROGRESS : pb_wait . setProgress ( message . getObject ( <NUM_LIT> , Integer . class ) ) ; break ; case WHAT_FORWARD_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_FORWARDED_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; break ; case WHAT_DELETE_FORWARDED_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" ) ; } } } public void toAppeal ( String comment , CommentArea commentArea , String parent , String root , String areaIdentifier ) { } private void toastShort ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastLong ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } private void toastNetError ( String msg ) { toastShort ( "<STR_LIT>" + msg ) ; } public void dialogMessage ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setPositiveButton ( android . R . string . ok , null ) . setOnDismissListener ( dialog -> exit ( ) ) . show ( ) ; } private void exit ( ) { if ( exitListener != null ) { exitListener . exit ( ) ; } } private void onNewCommentRpid ( long rpid ) { if ( exitListener != null ) { exitListener . onNewCommentRpid ( rpid ) ; } } private void onCommentStatusUpdated ( long rpid ) { if ( exitListener != null ) { exitListener . onCommentStatusUpdated ( rpid ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . async . EventHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public abstract class CommentOperateTask < T extends EventHandler > extends BackstageTask < T > { protected final CommentManipulator commentManipulator ; protected final Comment comment ; protected final Config config ; protected final StatisticsDBOpenHelper statisticsDB ; public CommentOperateTask ( T handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . comment = comment ; this . config = config ; this . statisticsDB = statisticsDB ; } public void insertHistoryComment ( HistoryComment historyComment ) { if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . insertHistoryComment ( historyComment ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . view ; public class ProgressTimer { private final long TimeMs ; private final int max ; private final ProgressLister progressLister ; private boolean isStopped = false ; public ProgressTimer ( long timeMs , int max , ProgressLister progressLister ) { TimeMs = timeMs ; this . max = max ; this . progressLister = progressLister ; } public void start ( ) { long sleepSeg = TimeMs / max ; for ( int i = <NUM_LIT> ; i <= max && ! isStopped ; i ++ ) { try { Thread . sleep ( sleepSeg ) ; progressLister . onNewProgress ( i , sleepSeg ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } public void stop ( ) { isStopped = true ; } public interface ProgressLister { void onNewProgress ( int progress , long sleepSeg ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . os . Build ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Date ; import java . util . Locale ; public class Logger { private static final int MAX_LOG_FILES = <NUM_LIT> ; private static final String LOG_FILE_EXTENSION = "<STR_LIT>" ; private final File logDirectory ; private PrintWriter logWriter ; public Logger ( File logDirectory ) { this . logDirectory = logDirectory ; if ( ! logDirectory . exists ( ) ) { logDirectory . mkdirs ( ) ; } createNewLogFile ( ) ; } private void createNewLogFile ( ) { String fileName = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + LOG_FILE_EXTENSION ; File logFile = new File ( logDirectory , fileName ) ; try { logFile . createNewFile ( ) ; logWriter = new PrintWriter ( new FileWriter ( logFile , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } deleteOldLogFiles ( ) ; } private void deleteOldLogFiles ( ) { File [ ] logFiles = logDirectory . listFiles ( ( dir , name ) -> name . endsWith ( LOG_FILE_EXTENSION ) ) ; if ( logFiles == null ) return ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Arrays . sort ( logFiles , Comparator . comparingLong ( File :: lastModified ) ) ; int numFilesToDelete = logFiles . length - MAX_LOG_FILES ; if ( numFilesToDelete > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < numFilesToDelete ; i ++ ) { logFiles [ i ] . delete ( ) ; } } } } public synchronized void log ( String message ) { if ( logWriter == null ) return ; logWriter . println ( message ) ; logWriter . flush ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostPictureHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . content . Intent . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; int requestCode = ( Integer ) param . args [ <NUM_LIT> ] ; if ( requestCode == <NUM_LIT> ) { Intent newIntent = new Intent ( ) ; newIntent . setAction ( Intent . ACTION_PICK ) ; newIntent . setType ( "<STR_LIT>" ) ; param . args [ <NUM_LIT> ] = newIntent ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , int . class , android . content . Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; if ( ( Integer ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { if ( intent != null && intent . getData ( ) != null ) { String fileName = "<STR_LIT>" + System . currentTimeMillis ( ) + "<STR_LIT>" ; try ( InputStream inputStream = activity . getContentResolver ( ) . openInputStream ( intent . getData ( ) ) ; FileOutputStream fos = new FileOutputStream ( fileName ) ) { if ( inputStream == null ) { XposedBridge . log ( "<STR_LIT>" ) ; return ; } byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } XposedBridge . log ( "<STR_LIT>" ) ; } catch ( IOException e ) { XposedBridge . log ( "<STR_LIT>" + e ) ; } for ( Method declaredMethod : activity . getClass ( ) . getDeclaredMethods ( ) ) { Class < ? > [ ] parameterTypes = declaredMethod . getParameterTypes ( ) ; if ( Arrays . equals ( new Class [ ] { String . class } , parameterTypes ) ) { XposedHelpers . callMethod ( activity , declaredMethod . getName ( ) , fileName ) ; } } } else { activity . finish ( ) ; } } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; public class CommentAddResult { public static final int CODE_SUCCESS = <NUM_LIT> ; public static final int CODE_DELETED = <NUM_LIT> ; public static final int CODE_CONTAIN_SENSITIVE = <NUM_LIT> ; public static final int CODE_NOT_THE_COMMENT = <NUM_LIT> ; @ JSONField ( name = "<STR_LIT>" ) public long rpid ; @ JSONField ( name = "<STR_LIT>" ) public String success_toast ; @ JSONField ( name = "<STR_LIT>" ) public int success_action ; public long root ; public long parent ; public BiliComment reply ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public interface NetworkCallBack { public void onNetworkError ( Throwable th ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class CommentCheckTask extends CommentOperateTask < CommentCheckTask . EventHandler > { private final String testCommentText ; public CommentCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , String testCommentText ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . testCommentText = testCommentText ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; HistoryComment historyComment = new HistoryComment ( comment ) ; historyComment . lastCheckDate = new Date ( ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_COMMENT_CHECK ) ; if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } BiliComment biliComment = commentManipulator . findComment ( comment . commentArea , comment . rpid , comment . root ) ; if ( biliComment != null ) { if ( biliComment . invisible ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_INVISIBLE ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_INVISIBLE ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_NORMAL ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_COMMENT_OK ) ; } } else { if ( comment . root == <NUM_LIT> ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_COMMENT_NOT_FOUND ) ; GeneralResponse < CommentReplyPage > response = commentManipulator . getCommentReplyHasAccount ( commentArea , comment . rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( response ) ; if ( response . code == CommentAddResult . CODE_SUCCESS ) { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } GeneralResponse < CommentReplyPage > noACResp = commentManipulator . getCommentReplyNoAccount ( commentArea , comment . rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( noACResp ) ; if ( noACResp . isSuccess ( ) ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNDER_REVIEW ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_UNDER_REVIEW ) ; } else if ( noACResp . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( noACResp , null ) ) ; } } else if ( response . code == CommentAddResult . CODE_DELETED ) { GeneralResponse < CommentAddResult > response1 = commentManipulator . getSendCommentCall ( testCommentText , comment . rpid , comment . root , commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( response1 ) ; if ( response1 . isSuccess ( ) ) { sleep ( config . getWaitTime ( ) ) ; commentManipulator . deleteComment ( comment . commentArea , comment . rpid , false ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else if ( response1 . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( response1 . code , response1 . message , null ) ) ; } } else { eventHandler . sendError ( new BiliBiliApiException ( response . code , response . message , null ) ) ; } } else { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , comment . rpid , comment . root , true ) ; if ( foundReply != null ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } } } } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_START_COMMENT_CHECK = <NUM_LIT> ; public static final int WHAT_ON_COMMENT_NOT_FOUND = <NUM_LIT> ; public static final int WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY = <NUM_LIT> ; public static final int WHAT_THEN_COMMENT_OK = <NUM_LIT> ; public static final int WHAT_THEN_SHADOW_BAN = <NUM_LIT> ; public static final int WHAT_THEN_DELETED = <NUM_LIT> ; public static final int WHAT_THEN_UNDER_REVIEW = <NUM_LIT> ; public static final int WHAT_THEN_INVISIBLE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; public class TaskManger { private static volatile Handler mainThreadHandler ; private static Handler getUiThreadHandler ( ) { if ( mainThreadHandler == null ) { synchronized ( TaskManger . class ) { if ( mainThreadHandler == null ) { mainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; } } } return mainThreadHandler ; } public static void postOnUiThread ( Runnable runnable ) { getUiThreadHandler ( ) . post ( runnable ) ; } private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; public static void start ( Runnable runnable ) { executorService . execute ( runnable ) ; } public static void execute ( BackstageTask < ? > backstageTask ) { start ( backstageTask ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . Dialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; public class DialogUtil { public static Dialog dialogMessage ( Context context , String title , String message ) { return dialogMessage ( context , title , message , null ) ; } public static Dialog dialogMessage ( Context context , String title , String message , DialogInterface . OnClickListener onClose ) { AlertDialog . Builder dialogBuilder = new AlertDialog . Builder ( context ) . setMessage ( message ) ; if ( onClose == null ) { dialogBuilder . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; } else { dialogBuilder . setPositiveButton ( "<STR_LIT>" , onClose ) ; } if ( title != null ) { dialogBuilder . setTitle ( title ) ; } return dialogBuilder . show ( ) ; } public static ProgressDialog newProgressDialog ( Context context , String title , String message ) { ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( message ) ; if ( title != null ) { progressDialog . setTitle ( title ) ; } return progressDialog ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . SearchView ; import android . widget . Spinner ; import android . widget . Toast ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContract ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . alibaba . fastjson . JSON ; import com . opencsv . CSVReader ; import com . opencsv . CSVWriter ; import com . opencsv . exceptions . CsvValidationException ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipOutputStream ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . BatchReviewCommentStatusTask ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResult ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResultCallbackForSaveDoc ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResultForFile ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class HistoryCommentActivity extends AppCompatActivity { private static final String [ ] csv_header_after_v500 = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; private static final int REQUEST_CODE_EXPORT = <NUM_LIT> ; private static final int REQUEST_CODE_IMPORT = <NUM_LIT> ; StatisticsDBOpenHelper statisticsDBOpenHelper ; HistoryCommentAdapter adapter ; RecyclerView recyclerView ; Context context ; Config config ; private LoadingHistoryCommentFragment loadingHistoryCommentFragment ; private HistoryCommentFragment historyCommentFragment ; public ActivityResultLauncher < File > savePicFileLauncher ; public ActivityResultLauncher < Intent > exportLauncher ; public CommentManipulator commentManipulator ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_history_comment ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } ByXposedLaunchedActivity . lastActivity = this ; context = this ; config = new Config ( context ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; adapter = new HistoryCommentAdapter ( this , commentManipulator , statisticsDBOpenHelper ) ; loadingHistoryCommentFragment = new LoadingHistoryCommentFragment ( ) ; historyCommentFragment = new HistoryCommentFragment ( adapter ) ; reloadData ( null ) ; savePicFileLauncher = registerForActivityResult ( new ActivityResultContract < File , ActivityResultForFile > ( ) { File inputFile ; @ NonNull @ Override public Intent createIntent ( @ NonNull Context context , File file ) { inputFile = file ; Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . setType ( "<STR_LIT>" ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . putExtra ( Intent . EXTRA_TITLE , file . getName ( ) ) ; return intent ; } @ Override public ActivityResultForFile parseResult ( int i , @ Nullable Intent intent ) { return new ActivityResultForFile ( intent , inputFile ) ; } } , new ActivityResultCallbackForSaveDoc < ActivityResultForFile > ( context ) { @ Override protected void onOpenOutputStream ( OutputStream outputStream , ActivityResultForFile result ) throws IOException { FileInputStream inputStream = new FileInputStream ( result . file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { outputStream . write ( buffer , <NUM_LIT> , read ) ; } HistoryCommentActivity . this . toastInUi ( "<STR_LIT>" ) ; inputStream . close ( ) ; outputStream . close ( ) ; } @ Override protected void onNullOutputStream ( ) { toastInUi ( "<STR_LIT>" ) ; } @ Override protected void onIOException ( Exception e ) { toastInUi ( "<STR_LIT>" + e . getMessage ( ) ) ; } } ) ; exportLauncher = registerForActivityResult ( new ActivityResultContract < Intent , ActivityResult > ( ) { @ NonNull @ Override public Intent createIntent ( @ NonNull Context context , Intent intent ) { return intent ; } @ Override public ActivityResult parseResult ( int i , @ Nullable Intent intent ) { return new ActivityResult ( intent ) ; } } , new ActivityResultCallbackForSaveDoc < ActivityResult > ( context ) { ProgressDialog progressDialog ; @ Override protected void onHasResult ( ) { progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; } @ Override protected void onOpenOutputStream ( OutputStream outputStream , ActivityResult result ) throws IOException { ZipOutputStream zos = new ZipOutputStream ( outputStream ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; List < HistoryComment > historyCommentList = statisticsDBOpenHelper . queryAllHistoryComments ( StatisticsDBOpenHelper . ORDER_BY_DATE_ASC ) ; ZipEntry csvEntry = new ZipEntry ( "<STR_LIT>" ) ; zos . putNextEntry ( csvEntry ) ; CSVWriter csvWriter = new CSVWriter ( new OutputStreamWriter ( zos ) ) ; csvWriter . writeNext ( csv_header_after_v500 ) ; for ( HistoryComment comment : historyCommentList ) { csvWriter . writeNext ( new String [ ] { String . valueOf ( comment . rpid ) , String . valueOf ( comment . parent ) , String . valueOf ( comment . root ) , String . valueOf ( comment . commentArea . oid ) , String . valueOf ( comment . commentArea . type ) , comment . commentArea . sourceId , comment . comment , String . valueOf ( comment . like ) , String . valueOf ( comment . replyCount ) , comment . lastState , String . valueOf ( comment . lastCheckDate . getTime ( ) ) , String . valueOf ( comment . date . getTime ( ) ) , String . valueOf ( comment . checkedArea ) , comment . firstState , comment . pictures , comment . sensitiveScanResult != null ? JSON . toJSONString ( comment . sensitiveScanResult ) : null } ) ; } csvWriter . flush ( ) ; zos . closeEntry ( ) ; File file = PictureStorage . getPicturesDir ( context ) ; File [ ] fileList = file . listFiles ( ) ; if ( fileList != null ) { for ( File fileToZip : fileList ) { try ( FileInputStream fis = new FileInputStream ( fileToZip ) ) { ZipEntry zipEntry = new ZipEntry ( "<STR_LIT>" + fileToZip . getName ( ) ) ; zos . putNextEntry ( zipEntry ) ; int length ; while ( ( length = fis . read ( buffer ) ) >= <NUM_LIT> ) { zos . write ( buffer , <NUM_LIT> , length ) ; } zos . closeEntry ( ) ; } } } zos . close ( ) ; outputStream . close ( ) ; toastInUi ( "<STR_LIT>" ) ; HistoryCommentActivity . this . runOnUiThread ( ( progressDialog :: dismiss ) ) ; } @ Override protected void onNullOutputStream ( ) { progressDialog . dismiss ( ) ; toastInUi ( "<STR_LIT>" ) ; } @ Override protected void onIOException ( Exception e ) { progressDialog . dismiss ( ) ; toastInUi ( "<STR_LIT>" + e . getMessage ( ) ) ; } } ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_more_options , menu ) ; MenuItem menuItem = menu . findItem ( R . id . search ) ; SearchView searchView = ( SearchView ) menuItem . getActionView ( ) ; assert searchView != null ; searchView . setSubmitButtonEnabled ( true ) ; menu . findItem ( R . id . 花里胡哨 ) . setChecked ( config . get花里胡哨Enable ( ) ) ; searchView . setOnQueryTextListener ( new SearchView . OnQueryTextListener ( ) { @ Override public boolean onQueryTextSubmit ( String query ) { reloadData ( query ) ; return false ; } @ Override public boolean onQueryTextChange ( String newText ) { if ( TextUtils . isEmpty ( newText ) ) { reloadData ( newText ) ; } return false ; } } ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == android . R . id . home ) { finish ( ) ; } else if ( itemId == R . id . item_sort ) { AtomicInteger sortRuler = new AtomicInteger ( config . getSortRuler ( ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setIcon ( R . drawable . baseline_sort_24 ) . setSingleChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , sortRuler . get ( ) , ( dialog , which ) -> { sortRuler . set ( which ) ; } ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_DATE_DESC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_DATE_ASC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_LIKE_DESC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_REPLY_COUNT_DESC ) ; } } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } else if ( itemId == R . id . item_filter ) { AtomicBoolean enableNormal = new AtomicBoolean ( config . getFilterRulerEnableNormal ( ) ) ; AtomicBoolean enableShadowBan = new AtomicBoolean ( config . getFilterRulerEnableShadowBan ( ) ) ; AtomicBoolean enableDeleted = new AtomicBoolean ( config . getFilterRulerEnableDelete ( ) ) ; AtomicBoolean enableOther = new AtomicBoolean ( config . getFilterRulerEnableOther ( ) ) ; AtomicBoolean enableType1 = new AtomicBoolean ( config . getFilterRulerEnableType1 ( ) ) ; AtomicBoolean enableType12 = new AtomicBoolean ( config . getFilterRulerEnableType12 ( ) ) ; AtomicBoolean enableType11 = new AtomicBoolean ( config . getFilterRulerEnableType11 ( ) ) ; AtomicBoolean enableType17 = new AtomicBoolean ( config . getFilterRulerEnableType17 ( ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setIcon ( R . drawable . baseline_filter_alt_24 ) . setMultiChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , new boolean [ ] { enableNormal . get ( ) , enableShadowBan . get ( ) , enableDeleted . get ( ) , enableOther . get ( ) , enableType1 . get ( ) , enableType12 . get ( ) , enableType11 . get ( ) , enableType17 . get ( ) } , ( dialog , which , isChecked ) -> { if ( which == <NUM_LIT> ) { enableNormal . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableShadowBan . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableDeleted . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableOther . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType1 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType12 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType11 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType17 . set ( isChecked ) ; } } ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { onFilterRulerSet ( enableNormal . get ( ) , enableShadowBan . get ( ) , enableDeleted . get ( ) , enableOther . get ( ) , enableType1 . get ( ) , enableType12 . get ( ) , enableType11 . get ( ) , enableType17 . get ( ) ) ; } } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } else if ( itemId == R . id . item_export ) { Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; exportLauncher . launch ( intent ) ; } else if ( itemId == R . id . item_import ) { Intent intent = new Intent ( Intent . ACTION_GET_CONTENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { "<STR_LIT>" , "<STR_LIT>" } ) ; startActivityForResult ( intent , REQUEST_CODE_IMPORT ) ; } else if ( itemId == R . id . 花里胡哨 ) { boolean enable = ! item . isChecked ( ) ; config . set花里胡哨Enable ( enable ) ; item . setChecked ( enable ) ; adapter . set花里胡哨Enable ( enable ) ; } else if ( itemId == R . id . batch_recheck ) { View dialogView = View . inflate ( context , R . layout . dialog_batch_recheck_start , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; Spinner spinner = dialogView . findViewById ( R . id . spinner_before_by ) ; spinner . setSelection ( <NUM_LIT> ) ; AlertDialog dialog = new AlertDialog . Builder ( this ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( android . R . string . ok , null ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setOnClickListener ( v -> { if ( TextUtils . isEmpty ( editText . getText ( ) . toString ( ) ) ) { editText . setError ( "<STR_LIT>" ) ; return ; } int inputNumber = Integer . parseInt ( editText . getText ( ) . toString ( ) ) ; switch ( spinner . getSelectedItemPosition ( ) ) { case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsByDateGT ( getPreviousNDaysTimestamp ( inputNumber ) ) ) ; break ; case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsByDateGT ( System . currentTimeMillis ( ) - ( long ) inputNumber * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; break ; case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsCountLimit ( inputNumber ) ) ; break ; } dialog . dismiss ( ) ; } ) ; } return true ; } private long getPreviousNDaysTimestamp ( int day ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . add ( Calendar . DAY_OF_MONTH , - day ) ; calendar . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MILLISECOND , <NUM_LIT> ) ; Date previousDate = calendar . getTime ( ) ; return previousDate . getTime ( ) ; } private void batchCheck ( List < HistoryComment > pendingCheckComments ) { System . out . println ( pendingCheckComments ) ; if ( pendingCheckComments . isEmpty ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } View dialogView = View . inflate ( context , R . layout . dialog_batch_check , null ) ; RecyclerView recyclerView = dialogView . findViewById ( R . id . rv_batch_checking_comments ) ; RecyclerView . LayoutManager layoutManager = new LinearLayoutManager ( context ) ; recyclerView . setLayoutManager ( layoutManager ) ; BatchCheckAdapter adapter = new BatchCheckAdapter ( context ) ; recyclerView . setAdapter ( adapter ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( String . format ( "<STR_LIT>" , <NUM_LIT> , pendingCheckComments . size ( ) ) ) . setView ( dialogView ) . setCancelable ( false ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; BatchReviewCommentStatusTask task = new BatchReviewCommentStatusTask ( commentManipulator , statisticsDBOpenHelper , pendingCheckComments , new BatchReviewCommentStatusTask . EventHandler ( ) { @ Override public void onStartCheck ( HistoryComment checkingComment ) { adapter . setCheckingComment ( checkingComment ) ; dialog . setTitle ( String . format ( "<STR_LIT>" , adapter . getItemCount ( ) , pendingCheckComments . size ( ) ) ) ; } @ Override public void onCheckOver ( String newStatus ) { adapter . overCheckComment ( newStatus ) ; recyclerView . scrollToPosition ( adapter . getItemCount ( ) ) ; } @ Override public void onComplete ( ) { dialog . setTitle ( pendingCheckComments . size ( ) + "<STR_LIT>" ) ; reloadData ( null ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setText ( "<STR_LIT>" ) ; } @ Override public void onError ( Throwable th ) { dialog . dismiss ( ) ; reloadData ( null ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , th . toString ( ) ) ; } } ) ; task . execute ( ) ; Button button = dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) ; button . setOnClickListener ( v -> { task . breakRun ( ) ; dialog . dismiss ( ) ; } ) ; } private void reloadData ( String searchText ) { replaceFragment ( loadingHistoryCommentFragment ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { String sortRuler = null ; switch ( config . getSortRuler ( ) ) { case Config . SORT_RULER_DATE_ASC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_DATE_ASC ; break ; case Config . SORT_RULER_DATE_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_DATE_DESC ; break ; case Config . SORT_RULER_LIKE_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_LIKE_DESC ; break ; case Config . SORT_RULER_REPLY_COUNT_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_REPLY_COUNT_DESC ; break ; default : throw new RuntimeException ( "<STR_LIT>" + config . getSortRuler ( ) ) ; } List < HistoryComment > historyCommentList = statisticsDBOpenHelper . queryAllHistoryComments ( sortRuler ) ; List < HistoryComment > sortedCommentList = new ArrayList < > ( historyCommentList . size ( ) ) ; boolean enableNormal = config . getFilterRulerEnableNormal ( ) ; boolean enableShadowBan = config . getFilterRulerEnableShadowBan ( ) ; boolean enableDelete = config . getFilterRulerEnableDelete ( ) ; boolean enableOther = config . getFilterRulerEnableOther ( ) ; boolean enableType1 = config . getFilterRulerEnableType1 ( ) ; boolean enableType12 = config . getFilterRulerEnableType12 ( ) ; boolean enableType11 = config . getFilterRulerEnableType11 ( ) ; boolean enableType17 = config . getFilterRulerEnableType17 ( ) ; if ( ! TextUtils . isEmpty ( searchText ) && searchText . startsWith ( "<STR_LIT>" ) ) { Pattern pattern = Pattern . compile ( "<STR_LIT>" ) ; Matcher matcher = pattern . matcher ( searchText ) ; if ( matcher . find ( ) ) { String startDateStr = matcher . group ( <NUM_LIT> ) ; String endDateStr = matcher . group ( <NUM_LIT> ) ; try { @ SuppressLint ( "<STR_LIT>" ) SimpleDateFormat dateFormat = new SimpleDateFormat ( "<STR_LIT>" ) ; if ( startDateStr != null && endDateStr != null ) { Date startDate = dateFormat . parse ( startDateStr ) ; Date endDate = dateFormat . parse ( endDateStr ) ; historyCommentList = filterCommentsWithinRange ( historyCommentList , startDate , endDate ) ; } else { toastInUi ( "<STR_LIT>" ) ; } } catch ( ParseException e ) { toastInUi ( "<STR_LIT>" ) ; } } else { toastInUi ( "<STR_LIT>" ) ; } } boolean continueToSearching = ! TextUtils . isEmpty ( searchText ) && ! searchText . startsWith ( "<STR_LIT>" ) ; for ( HistoryComment historyComment : historyCommentList ) { if ( continueToSearching && ! ( historyComment . comment . contains ( searchText ) || historyComment . commentArea . sourceId . contains ( searchText ) ) ) { continue ; } int type = historyComment . commentArea . type ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { if ( ! enableType1 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { if ( ! enableType12 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_DYNAMIC11 ) { if ( ! enableType11 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { if ( ! enableType17 ) { continue ; } } if ( historyComment . lastState . equals ( HistoryComment . STATE_NORMAL ) ) { if ( enableNormal ) { sortedCommentList . add ( historyComment ) ; } } else if ( historyComment . lastState . equals ( HistoryComment . STATE_SHADOW_BAN ) ) { if ( enableShadowBan ) { sortedCommentList . add ( historyComment ) ; } } else if ( historyComment . lastState . equals ( HistoryComment . STATE_DELETED ) ) { if ( enableDelete ) { sortedCommentList . add ( historyComment ) ; } } else if ( enableOther ) { sortedCommentList . add ( historyComment ) ; } } runOnUiThread ( ( ) -> { if ( ! TextUtils . isEmpty ( searchText ) ) { Toast . makeText ( context , "<STR_LIT>" + sortedCommentList . size ( ) + "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } adapter . reloadData ( sortedCommentList ) ; replaceFragment ( historyCommentFragment ) ; } ) ; } } ) . start ( ) ; } protected void onFilterRulerSet ( boolean enableNormal , boolean enableShadowBan , boolean enableDeleted , boolean enableOther , boolean e1 , boolean e12 , boolean e11 , boolean e17 ) { config . setFilterRulerEnableNormal ( enableNormal ) ; config . setFilterRulerEnableShadowBan ( enableShadowBan ) ; config . setFilterRulerEnableDeleted ( enableDeleted ) ; config . setFilterRulerEnableOther ( enableOther ) ; config . setFilterRulerEnableType1 ( e1 ) ; config . setFilterRulerEnableType12 ( e12 ) ; config . setFilterRulerEnableType11 ( e11 ) ; config . setFilterRulerEnableType17 ( e17 ) ; reloadData ( null ) ; } protected void onSortTypeSet ( int sortRuler ) { config . setSortRuler ( sortRuler ) ; reloadData ( null ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent intent ) { super . onActivityResult ( requestCode , resultCode , intent ) ; switch ( requestCode ) { case REQUEST_CODE_IMPORT : ProgressDialog progressDialog1 = new ProgressDialog ( context ) ; progressDialog1 . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog1 . setMessage ( "<STR_LIT>" ) ; progressDialog1 . setCancelable ( false ) ; progressDialog1 . show ( ) ; Executor executor = Executors . newSingleThreadExecutor ( ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( intent == null || intent . getData ( ) == null ) { error ( "<STR_LIT>" ) ; return ; } String type = getContentResolver ( ) . getType ( intent . getData ( ) ) ; try { List < HistoryComment > readComments = null ; InputStream inputStream = getContentResolver ( ) . openInputStream ( intent . getData ( ) ) ; if ( inputStream == null ) { error ( "<STR_LIT>" ) ; return ; } if ( "<STR_LIT>" . equals ( type ) ) { ZipInputStream zis = new ZipInputStream ( inputStream ) ; ZipEntry nextEntry ; while ( ( nextEntry = zis . getNextEntry ( ) ) != null ) { String name = nextEntry . getName ( ) ; System . out . println ( name ) ; if ( name . equals ( "<STR_LIT>" ) ) { readComments = readCSVToHistoryComments ( new CSVReader ( new InputStreamReader ( zis ) ) ) ; } else if ( name . startsWith ( "<STR_LIT>" ) ) { String [ ] split = name . split ( "<STR_LIT>" ) ; PictureStorage . save ( context , zis , split [ split . length - <NUM_LIT> ] ) ; } zis . closeEntry ( ) ; } zis . close ( ) ; } else if ( "<STR_LIT>" . equals ( type ) ) { readComments = readCSVToHistoryComments ( new CSVReader ( new InputStreamReader ( inputStream ) ) ) ; inputStream . close ( ) ; } else { error ( "<STR_LIT>" ) ; return ; } int successCount = <NUM_LIT> ; int failCount = <NUM_LIT> ; if ( readComments == null ) { error ( "<STR_LIT>" ) ; return ; } List < HistoryComment > newHistoryCommentList = new ArrayList < > ( ) ; for ( HistoryComment comment : readComments ) { if ( statisticsDBOpenHelper . insertHistoryComment ( comment ) > <NUM_LIT> ) { System . out . println ( "<STR_LIT>" + comment ) ; newHistoryCommentList . add ( comment ) ; successCount ++ ; } else { System . out . println ( "<STR_LIT>" + comment ) ; failCount ++ ; } } int finalSuccessCount = successCount ; int finalFailCount = failCount ; runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; adapter . addSomeData ( newHistoryCommentList ) ; Toast . makeText ( context , "<STR_LIT>" + finalSuccessCount + "<STR_LIT>" + finalFailCount + "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } catch ( IOException e ) { error ( "<STR_LIT>" + e . getMessage ( ) ) ; } catch ( CsvValidationException e ) { error ( "<STR_LIT>" + e . getMessage ( ) ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) ; } } private List < HistoryComment > readCSVToHistoryComments ( CSVReader csvReader ) throws CsvValidationException , IOException { String [ ] header_before_v500 = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] header_banned = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] data ; if ( ( data = csvReader . readNext ( ) ) == null ) { return null ; } if ( Arrays . equals ( header_before_v500 , data ) ) { return readCSVToHistoryComments_before_v500 ( csvReader ) ; } else if ( Arrays . equals ( csv_header_after_v500 , data ) ) { return readCSVToHistoryComments_after_v500 ( csvReader ) ; } else if ( Arrays . equals ( header_banned , data ) ) { return readCSVToHistoryComments_banned_to_history ( csvReader ) ; } else { return null ; } } private List < HistoryComment > readCSVToHistoryComments_before_v500 ( CSVReader csvReader ) throws CsvValidationException , IOException { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; String [ ] data ; while ( ( data = csvReader . readNext ( ) ) != null ) { HistoryComment historyComment = new HistoryComment ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) ) ; historyCommentList . add ( historyComment ) ; } return historyCommentList ; } private List < HistoryComment > readCSVToHistoryComments_after_v500 ( CSVReader csvReader ) throws CsvValidationException , IOException { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; String [ ] data ; while ( ( data = csvReader . readNext ( ) ) != null ) { CommentArea commentArea = new CommentArea ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) ) ; HistoryComment comment = new HistoryComment ( commentArea , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , data [ <NUM_LIT> ] , JSON . parseObject ( data [ <NUM_LIT> ] , SensitiveScanResult . class ) ) ; historyCommentList . add ( comment ) ; } return historyCommentList ; } private List < HistoryComment > readCSVToHistoryComments_banned_to_history ( CSVReader csvReader ) throws CsvValidationException , IOException { String [ ] data ; List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; while ( ( data = csvReader . readNext ( ) ) != null ) { CommentArea commentArea = new CommentArea ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) ) ; String state = data [ <NUM_LIT> ] ; HistoryComment comment = new HistoryComment ( commentArea , Long . parseLong ( data [ <NUM_LIT> ] ) , <NUM_LIT> , <NUM_LIT> , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , <NUM_LIT> , <NUM_LIT> , state , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , state , null , null ) ; if ( comment . firstState . equals ( "<STR_LIT>" ) ) { comment . firstState = HistoryComment . STATE_NORMAL ; } if ( comment . firstState . equals ( "<STR_LIT>" ) ) { comment . firstState = HistoryComment . STATE_DELETED ; } if ( comment . lastState . equals ( "<STR_LIT>" ) ) { comment . lastState = HistoryComment . STATE_SHADOW_BAN ; } if ( comment . lastState . equals ( "<STR_LIT>" ) ) { comment . lastState = HistoryComment . STATE_DELETED ; } historyCommentList . add ( comment ) ; } return historyCommentList ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } private void replaceFragment ( Fragment fragment ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; fragmentTransaction . replace ( R . id . frame , fragment ) ; fragmentTransaction . commit ( ) ; } public static List < HistoryComment > filterCommentsWithinRange ( List < HistoryComment > historyCommentList , Date startDate , Date endDate ) { List < HistoryComment > filteredComments = new ArrayList < > ( ) ; for ( HistoryComment comment : historyCommentList ) { if ( comment . date . after ( startDate ) && comment . date . before ( endDate ) ) { filteredComments . add ( comment ) ; } } return filteredComments ; } public void toastInUi ( String message ) { runOnUiThread ( ( ) -> { Toast . makeText ( context , message , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . Nullable ; import java . util . List ; public class CommentPage { public Page page ; public List < BiliComment > replies ; @ Nullable public List < BiliComment > top_replies ; public static class Page { public int num ; public int size ; public int count ; public int acount ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; public class LoadingHistoryCommentFragment extends Fragment { private View rootView ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_loading_history_comment , container , false ) ; return rootView ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . database . Cursor ; public class GreatCursor { Cursor cursor ; public GreatCursor ( Cursor cursor ) { this . cursor = cursor ; } public int getInt ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getInt ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public long getLong ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getLong ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public String getString ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getString ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public boolean moveToNext ( ) { return cursor . moveToNext ( ) ; } public void close ( ) { cursor . close ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . SharedPreferences ; public class XConfig { public static final String PREF_NAME = "<STR_LIT>" ; private final SharedPreferences sp ; protected XConfig ( SharedPreferences sharedPreferences ) { this . sp = sharedPreferences ; } public void setHookPictureSelectEnable ( boolean enable ) { sp . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getHookPictureSelectIsEnable ( ) { return sp . getBoolean ( "<STR_LIT>" , true ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class VideoInfo { public String bvid ; public long aid ; public String title ; public String desc ; public String pic ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import androidx . annotation . NonNull ; import java . io . File ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; import okhttp3 . Interceptor ; import okhttp3 . MediaType ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class LoggerInterceptor implements Interceptor { private final Logger logger ; public LoggerInterceptor ( ) { File logDir = new File ( "<STR_LIT>" + BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; if ( ! logDir . exists ( ) ) { logDir . mkdirs ( ) ; } logger = new Logger ( logDir ) ; } @ NonNull @ Override public Response intercept ( @ NonNull Chain chain ) throws IOException { Request request = chain . request ( ) ; Response response = null ; response = chain . proceed ( request ) ; String time = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) ; logger . log ( "<STR_LIT>" + time + "<STR_LIT>" ) ; logger . log ( "<STR_LIT>" + request . url ( ) ) ; logger . log ( "<STR_LIT>" + request . method ( ) ) ; logger . log ( "<STR_LIT>" + request . headers ( ) ) ; logger . log ( "<STR_LIT>" + response . code ( ) ) ; logger . log ( "<STR_LIT>" + response . message ( ) ) ; logger . log ( "<STR_LIT>" + response . headers ( ) ) ; ResponseBody body = response . body ( ) ; if ( body != null ) { MediaType contentType = body . contentType ( ) ; if ( contentType != null && contentType . toString ( ) . contains ( "<STR_LIT>" ) ) { String responseBody = body . string ( ) ; logger . log ( "<STR_LIT>" + responseBody ) ; logger . log ( "<STR_LIT>" ) ; return response . newBuilder ( ) . body ( ResponseBody . create ( contentType , responseBody ) ) . build ( ) ; } } logger . log ( "<STR_LIT>" ) ; return response ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XposedBridge ; public class HookStater { public int appVersionCode ; public ClassLoader classLoader ; public HookStater ( int appVersionCode , ClassLoader classLoader ) { this . appVersionCode = appVersionCode ; this . classLoader = classLoader ; } public void startHook ( BaseHook baseHook ) { try { baseHook . startHook ( appVersionCode , classLoader ) ; } catch ( Throwable throwable ) { XposedBridge . log ( baseHook . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + throwable ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; @ SuppressLint ( "<STR_LIT>" ) public class BatchCheckAdapter extends RecyclerView . Adapter < BatchCheckAdapter . ViewHolder > { private final Context context ; private final List < String > oldStatusList = new ArrayList < > ( ) ; private final List < HistoryComment > checkedComments = new ArrayList < > ( ) ; private HistoryComment checkingComment ; public BatchCheckAdapter ( Context context ) { this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_one_batch_checking_comment , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { if ( position == checkedComments . size ( ) ) { holder . txv_comment_content . setText ( checkingComment . comment ) ; setStatus ( checkingComment . lastState , holder . txv_old_status , holder . img_old_status ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( new ProgressBar ( context ) ) ; return ; } HistoryComment comment = checkedComments . get ( position ) ; holder . txv_comment_content . setText ( comment . comment ) ; setStatus ( oldStatusList . get ( position ) , holder . txv_old_status , holder . img_old_status ) ; ImageView imageView = new ImageView ( context ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( imageView ) ; setStatus ( comment . lastState , holder . txv_new_status , imageView ) ; } @ Override public int getItemCount ( ) { int size = checkedComments . size ( ) ; if ( checkingComment != null ) { size ++ ; } return size ; } private void setStatus ( String status , TextView textView , ImageView imageView ) { switch ( status ) { case HistoryComment . STATE_NORMAL : imageView . setImageDrawable ( context . getDrawable ( R . drawable . normal ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SHADOW_BAN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNDER_REVIEW : imageView . setImageDrawable ( context . getDrawable ( R . drawable . i ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_DELETED : imageView . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SENSITIVE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . sensitive ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_INVISIBLE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ghost ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNKNOWN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . unknown ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_access_time_24 ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; default : textView . setText ( status ) ; } } public void setCheckingComment ( HistoryComment historyComment ) { checkingComment = historyComment ; oldStatusList . add ( historyComment . lastState ) ; notifyItemInserted ( getItemCount ( ) - <NUM_LIT> ) ; } public void overCheckComment ( String newStatus ) { if ( checkingComment == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } checkingComment . lastState = newStatus ; checkedComments . add ( checkingComment ) ; checkingComment = null ; notifyItemChanged ( getItemCount ( ) - <NUM_LIT> ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { ImageView img_old_status = itemView . findViewById ( R . id . img_old_status ) ; TextView txv_old_status = itemView . findViewById ( R . id . txv_old_status ) ; FrameLayout new_status_icon_frame = itemView . findViewById ( R . id . new_status_icon_frame ) ; TextView txv_new_status = itemView . findViewById ( R . id . txv_new_status ) ; TextView txv_comment_content = itemView . findViewById ( R . id . txv_comment_content ) ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import icu . freedomIntrovert . async . BackstageTaskByMVP ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class BatchReviewCommentStatusTask extends BackstageTaskByMVP < BatchReviewCommentStatusTask . EventHandler > { private final AtomicBoolean isBreak = new AtomicBoolean ( false ) ; private final CommentManipulator commentManipulator ; private final StatisticsDBOpenHelper statisticsDB ; private final List < HistoryComment > comments ; public BatchReviewCommentStatusTask ( CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , List < HistoryComment > comments , EventHandler uiHandler ) { super ( uiHandler ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . comments = comments ; } @ Override protected void onStart ( EventHandler eventHandlerProxy ) throws Throwable { for ( HistoryComment comment : comments ) { if ( isBreak . get ( ) ) { System . out . println ( "<STR_LIT>" ) ; break ; } eventHandlerProxy . onStartCheck ( comment ) ; eventHandlerProxy . onCheckOver ( checkComment ( comment ) ) ; } } public void breakRun ( ) { isBreak . set ( true ) ; } public String checkComment ( HistoryComment historyComment ) throws IOException , CookieFailedException , BiliBiliApiException { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { throw new CookieFailedException ( ) ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_UNDER_REVIEW ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } } } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_SHADOW_BAN , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } } else if ( resp . code == CommentAddResult . CODE_DELETED ) { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } else if ( resp . code == <NUM_LIT> ) { return "<STR_LIT>" ; } else { throw new BiliBiliApiException ( resp , "<STR_LIT>" ) ; } } public interface EventHandler extends BaseEventHandler { void onStartCheck ( HistoryComment checkingComment ) ; void onCheckOver ( String newStatus ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class AreaMartialLawCheckTask extends CommentOperateTask < AreaMartialLawCheckTask . EventHandler > { private final CommentUtil commentUtil ; private final boolean isDeputyAccount ; public AreaMartialLawCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentUtil commentUtil , boolean isDeputyAccount ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . commentUtil = commentUtil ; this . isDeputyAccount = isDeputyAccount ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; String randomComment = commentUtil . getRandomComment ( commentArea ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( randomComment , <NUM_LIT> , <NUM_LIT> , commentArea , isDeputyAccount ) ; eventHandler . sendEventMessage ( new EventMessage ( EventHandler . WHAT_ON_TEST_COMMENT_SENT , randomComment ) ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( commentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_MARTIAL_LAW ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_AREA_OK ) ; } else { if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_MARTIAL_LAW ) ; statisticsDB . insertMartialLawCommentArea ( commentManipulator . getMartialLawCommentArea ( commentArea , testCommentRpid , isDeputyAccount ) ) ; } commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_MARTIAL_LAW ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_TEST_COMMENT_SENT = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_AREA_OK = <NUM_LIT> ; public static final int WHAT_THEN_MARTIAL_LAW = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; public class ActivityResult { public ActivityResult ( Intent intent ) { this . intent = intent ; } public Intent intent ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ResendCommentTask extends BackstageTask < ResendCommentTask . EventHandler > { private final CommentManipulator commentManipulator ; private final Config config ; private final String newCommentText ; private final HistoryComment historyComment ; public ResendCommentTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , String newCommentText , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . config = config ; this . newCommentText = newCommentText ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { GeneralResponse < CommentAddResult > body = commentManipulator . getSendCommentCall ( newCommentText , historyComment . parent , historyComment . root , historyComment . commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; long waitTime = config . getWaitTime ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_SUCCESS_AND_SLEEP , waitTime ) ; if ( body . isSuccess ( ) ) { new ProgressTimer ( waitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , ( progress , sleepSeg ) -> eventHandler . sendEventMessage ( EventHandler . WHAT_ON_NEW_PROGRESS , progress , sleepSeg , waitTime ) ) . start ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_RESENT_COMMENT , body . data ) ; } else { if ( body . code == <NUM_LIT> ) { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CONTAIN_SENSITIVE , body . message , newCommentText ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( body , "<STR_LIT>" ) ) ; } } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_SEND_SUCCESS_AND_SLEEP = <NUM_LIT> ; public static final int WHAT_ON_NEW_PROGRESS = <NUM_LIT> ; public static final int WHAT_ON_RESENT_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CONTAIN_SENSITIVE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import android . util . Log ; import java . io . IOException ; import java . util . Arrays ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . ForwardDynamicResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class SensitiveScannerTask extends BackstageTask < SensitiveScannerTask . EventHandler > { private final Comment mainComment ; private CommentArea commentAreaForTest ; private String dynamicIdToBeForward ; private final CommentManipulator commentManipulator ; private final Config config ; private final StatisticsDBOpenHelper helper ; public SensitiveScannerTask ( EventHandler handle , Comment mainComment , CommentArea yourCommentArea , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . commentAreaForTest = yourCommentArea ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } public SensitiveScannerTask ( EventHandler handle , Comment mainComment , String dynamicIdToBeForward , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . dynamicIdToBeForward = dynamicIdToBeForward ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { String commentText = mainComment . comment ; long waitTime = config . getWaitTime ( ) ; if ( dynamicIdToBeForward != null ) { commentAreaForTest = forwardDynamicToCreateNewCommentArea ( eventHandler ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_SENT , waitTime ) ; sleepAndSendProgress ( waitTime , eventHandler ) ; long fulltextRpid = commentManipulator . sendComment ( commentText , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) . rpid ; BiliComment foundComment = commentManipulator . findComment ( commentAreaForTest , fulltextRpid , <NUM_LIT> ) ; commentManipulator . deleteComment ( commentAreaForTest , fulltextRpid , false ) ; if ( foundComment != null ) { deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_IS_NORMAL , commentAreaForTest ) ; return ; } int max = ( int ) ( Math . log ( ( double ) commentText . length ( ) / <NUM_LIT> ) / Math . log ( <NUM_LIT> ) ) ; int currProg = <NUM_LIT> ; Log . i ( "<STR_LIT>" , String . valueOf ( commentText . length ( ) ) ) ; Log . i ( "<STR_LIT>" , String . valueOf ( max ) ) ; String passText = "<STR_LIT>" ; String [ ] split = splitFromTheMiddle ( commentText ) ; SensitiveScanResult result = new SensitiveScanResult ( ) ; while ( split != null ) { System . out . println ( Arrays . toString ( split ) ) ; String [ ] finalSplit = split ; int normalPosition = passText . length ( ) ; int splitLeftPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; int splitRightPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT , normalPosition , splitLeftPosition , splitRightPosition , waitTime ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( passText + split [ <NUM_LIT> ] , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) ; long rpid = commentAddResult . rpid ; sleepAndSendProgress ( waitTime , eventHandler ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECKING_COMMENT , currProg , max ) ; if ( commentManipulator . findComment ( commentAreaForTest , rpid , <NUM_LIT> ) != null ) { result . normalPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; passText += split [ <NUM_LIT> ] ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ; } else { result . normalPosition = passText . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECK_RESULT , result ) ; commentManipulator . deleteComment ( commentAreaForTest , rpid , false ) ; System . out . println ( passText ) ; sleep ( <NUM_LIT> ) ; currProg ++ ; } helper . addSensitiveScanResultToHistoryComment ( mainComment . rpid , result ) ; deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_SCAN_COMPLETE ) ; } private CommentArea forwardDynamicToCreateNewCommentArea ( EventHandler eventHandler ) throws IOException , BiliBiliApiException { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_FORWARD_DYNAMIC ) ; ForwardDynamicResult forwardDynamicResult = commentManipulator . forwardDynamicUsingSubAccount ( dynamicIdToBeForward ) ; long dynRid = forwardDynamicResult . dyn_rid ; eventHandler . sendEventMessage ( EventHandler . WHAT_FORWARDED_DYNAMIC , dynRid ) ; sleepAndSendProgress ( <NUM_LIT> , eventHandler ) ; return new CommentArea ( dynRid , String . valueOf ( dynRid ) , CommentArea . AREA_TYPE_DYNAMIC17 ) ; } private void deleteForwardedDynamic ( EventHandler eventHandler , String dynamicId ) throws BiliBiliApiException , IOException { if ( dynamicIdToBeForward != null ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_DELETE_FORWARDED_DYNAMIC ) ; commentManipulator . deleteDynamicUsingSubAccount ( dynamicId ) ; } } public static String [ ] splitFromTheMiddle ( String input ) { if ( input . length ( ) >= <NUM_LIT> ) { return new String [ ] { input . substring ( <NUM_LIT> , input . length ( ) / <NUM_LIT> ) , input . substring ( input . length ( ) / <NUM_LIT> ) } ; } else { return null ; } } public void sleepAndSendProgress ( long time1 , EventHandler eventHandler ) { int time = ( int ) time1 ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , time ) ; int sleepSeg = <NUM_LIT> ; int sleepCount = time / sleepSeg ; for ( int i = <NUM_LIT> ; i <= sleepCount ; i ++ ) { sleep ( sleepSeg ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS , sleepSeg * i ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , - <NUM_LIT> ) ; } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_COMMENT_FULL_TEXT_SENT = <NUM_LIT> ; public static final int WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT = <NUM_LIT> ; public static final int WHAT_ON_CHECKING_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CHECK_RESULT = <NUM_LIT> ; public static final int WHAT_COMMENT_FULL_TEXT_IS_NORMAL = <NUM_LIT> ; public static final int WHAT_ON_SCAN_COMPLETE = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS_MAX = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS = <NUM_LIT> ; public static final int WHAT_FORWARD_DYNAMIC = <NUM_LIT> ; public static final int WHAT_FORWARDED_DYNAMIC = <NUM_LIT> ; public static final int WHAT_DELETE_FORWARDED_DYNAMIC = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import java . util . ArrayList ; public class CommentReplyPage { public BiliComment root ; public ArrayList < BiliComment > replies ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class HistoryCommentFragment extends Fragment { private View rootView ; private RecyclerView recyclerView ; private HistoryCommentAdapter adapter ; public HistoryCommentFragment ( ) { } public HistoryCommentFragment ( HistoryCommentAdapter adapter ) { this . adapter = adapter ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_history_comment , container , false ) ; recyclerView = rootView . findViewById ( R . id . rv_history_comments ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( getContext ( ) ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; return rootView ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . NotificationManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . provider . Settings ; import android . view . Window ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ByXposedLaunchedActivity extends AppCompatActivity { public static final int TODO_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_CHECK_DANMAKU = <NUM_LIT> ; public static final int TODO_CONTINUE_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_SAVE_CONTAIN_SENSITIVE_CONTENT = <NUM_LIT> ; public static Activity lastActivity ; Context context ; Handler handler ; CommentManipulator commentManipulator ; CommentUtil commentUtil ; StatisticsDBOpenHelper statisticsDBOpenHelper ; DanmakuManipulator danmakuManipulator ; boolean toContinueTo = true ; Config config ; @ Override protected void onCreate ( Bundle savedInstanceState ) { if ( lastActivity != null ) { System . out . println ( "<STR_LIT>" + lastActivity . getClass ( ) . getCanonicalName ( ) + "<STR_LIT>" ) ; lastActivity . finish ( ) ; } super . onCreate ( savedInstanceState ) ; supportRequestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . activity_by_xposed_launched ) ; this . context = this ; config = new Config ( context ) ; handler = new Handler ( ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; commentUtil = new CommentUtil ( context ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; danmakuManipulator = new DanmakuManipulator ( ) ; Intent intent = getIntent ( ) ; int todo = intent . getIntExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; long waitTime = config . getWaitTime ( ) ; long waitTimeByHasPictures = config . getWaitTimeByHasPictures ( ) ; Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { showExtrasError ( null ) ; } else if ( todo == TODO_CHECK_COMMENT ) { String message = extras . getString ( "<STR_LIT>" ) ; String s_oid = extras . getString ( "<STR_LIT>" ) ; String s_type = extras . getString ( "<STR_LIT>" ) ; String s_resultRpid = extras . getString ( "<STR_LIT>" ) ; String s_root = extras . getString ( "<STR_LIT>" ) ; String s_parent = extras . getString ( "<STR_LIT>" ) ; String commentText = extras . getString ( "<STR_LIT>" ) ; String dynamicId = extras . getString ( "<STR_LIT>" ) ; String bvid = extras . getString ( "<STR_LIT>" ) ; String pictures = extras . getString ( "<STR_LIT>" ) ; long ctime = extras . getLong ( "<STR_LIT>" , <NUM_LIT> ) * <NUM_LIT> ; if ( message == null || s_oid == null || s_type == null || s_resultRpid == null || s_root == null || s_parent == null || commentText == null ) { showExtrasError ( extras ) ; return ; } long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; long resultRpid = Long . parseLong ( s_resultRpid ) ; long root = Long . parseLong ( s_root ) ; long parent = Long . parseLong ( s_parent ) ; CommentArea commentArea = null ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentArea = new CommentArea ( oid , bvid , type ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { commentArea = new CommentArea ( oid , s_oid , type ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { commentArea = new CommentArea ( oid , "<STR_LIT>" + oid , type ) ; } else { commentArea = new CommentArea ( oid , dynamicId != null ? dynamicId : "<STR_LIT>" , type ) ; } Comment comment = new Comment ( commentArea , resultRpid , parent , root , commentText , pictures , new Date ( ctime ) ) ; statisticsDBOpenHelper . insertPendingCheckComment ( comment ) ; boolean hasPictures = comment . hasPictures ( ) ; long totalWaitTime ; String proMsg ; if ( hasPictures ) { totalWaitTime = waitTime + waitTimeByHasPictures ; proMsg = "<STR_LIT>" + waitTime + "<STR_LIT>" + waitTimeByHasPictures + "<STR_LIT>" + totalWaitTime + "<STR_LIT>" ; } else { totalWaitTime = waitTime ; proMsg = "<STR_LIT>" + waitTime + "<STR_LIT>" ; } ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( String . format ( proMsg , <NUM_LIT> ) ) . setPositiveButton ( "<STR_LIT>" , null ) . setCancelable ( false ) . show ( ) ; ProgressTimer progressTimer = new ProgressTimer ( totalWaitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , new ProgressTimer . ProgressLister ( ) { @ Override public void onNewProgress ( int progress , long sleepSeg ) { runOnUiThread ( ( ) -> { progressBarDialog . setProgress ( progress ) ; progressBarDialog . setMessage ( String . format ( proMsg , progress * sleepSeg ) ) ; } ) ; } } ) ; long lastTime = System . currentTimeMillis ( ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( v -> { if ( checkNotificationPermission ( context ) ) { Intent intent1 = new Intent ( context , WaitService . class ) ; if ( hasPictures ) { intent1 . putExtra ( "<STR_LIT>" , totalWaitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } else { intent1 . putExtra ( "<STR_LIT>" , waitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } intent1 . putExtra ( "<STR_LIT>" , resultRpid ) ; intent1 . putExtra ( "<STR_LIT>" , commentText ) ; startService ( intent1 ) ; toContinueTo = false ; finish ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; requestNotificationPermission ( context ) ; } } ) ; new Thread ( ( ) -> { progressTimer . start ( ) ; if ( toContinueTo ) { runOnUiThread ( ( ) -> { progressBarDialog . setIndeterminate ( true ) ; progressBarDialog . setTitle ( "<STR_LIT>" ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( false ) ; toCheckComment ( comment , progressBarDialog ) ; } ) ; } } ) . start ( ) ; } else if ( todo == TODO_CONTINUE_CHECK_COMMENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; long rpid = intent . getLongExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; Comment comment = statisticsDBOpenHelper . getPendingCheckCommentByRpid ( rpid ) ; System . out . println ( comment ) ; if ( comment == null ) { dialogMessageAndExit ( "<STR_LIT>" , "<STR_LIT>" + rpid + "<STR_LIT>" ) ; } else { toCheckComment ( comment , progressBarDialog ) ; } } else if ( todo == TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; String comment = intent . getStringExtra ( "<STR_LIT>" ) ; String message = intent . getStringExtra ( "<STR_LIT>" ) ; String s_oid = intent . getStringExtra ( "<STR_LIT>" ) ; String s_type = intent . getStringExtra ( "<STR_LIT>" ) ; String dynamicId = intent . getStringExtra ( "<STR_LIT>" ) ; DialogInterface . OnClickListener onClose = ( dialog , which ) -> finish ( ) ; if ( comment != null && s_oid != null && s_type != null ) { long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentManipulator . getVideoInfoByAid ( oid ) . enqueue ( new BiliApiCallback < GeneralResponse < VideoInfo > > ( ) { @ Override public void onError ( Throwable th ) { progressBarDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , th . getMessage ( ) , onClose ) ; } @ Override public void onSuccess ( GeneralResponse < VideoInfo > videoInfoGeneralResponse ) { progressBarDialog . dismiss ( ) ; if ( videoInfoGeneralResponse . isSuccess ( ) ) { addSensitiveComment ( new CommentArea ( oid , videoInfoGeneralResponse . data . bvid , type ) , comment , message , onClose ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , videoInfoGeneralResponse . message , onClose ) ; } } } ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { addSensitiveComment ( new CommentArea ( oid , "<STR_LIT>" + oid , type ) , comment , message , onClose ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { addSensitiveComment ( new CommentArea ( oid , String . valueOf ( oid ) , type ) , comment , message , onClose ) ; } else { addSensitiveComment ( new CommentArea ( oid , dynamicId != null ? dynamicId : "<STR_LIT>" , type ) , comment , message , onClose ) ; } } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + intent . getExtras ( ) , onClose ) ; } } } private void addSensitiveComment ( CommentArea commentArea , String commentText , String message , DialogInterface . OnClickListener onClose ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , - System . currentTimeMillis ( ) , <NUM_LIT> , <NUM_LIT> , commentText , null , new Date ( ) ) ) ; historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SENSITIVE ) ; if ( statisticsDBOpenHelper . insertHistoryComment ( historyComment ) > <NUM_LIT> ) { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + message + "<STR_LIT>" + commentText , onClose ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" , onClose ) ; } } private void showExtrasError ( @ Nullable Bundle extras ) { dialogMessageAndExit ( "<STR_LIT>" , "<STR_LIT>" + extras ) ; } private void dialogMessageAndExit ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> finish ( ) ) . show ( ) ; } private void toCheckComment ( Comment comment , ProgressBarDialog progressDialog ) { DialogCommCheckWorker worker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , commentUtil ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void exit ( ) { finish ( ) ; } } ) ; List < Comment . PictureInfo > pictureInfoList = comment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { TaskManger . start ( ( ) -> { try { for ( int i = <NUM_LIT> ; i < pictureInfoList . size ( ) ; i ++ ) { int finalI = i ; runOnUiThread ( ( ) -> { progressDialog . setMessage ( "<STR_LIT>" + ( finalI + <NUM_LIT> ) + "<STR_LIT>" + pictureInfoList . size ( ) + "<STR_LIT>" ) ; } ) ; PictureStorage . save ( context , pictureInfoList . get ( i ) . img_src ) ; } runOnUiThread ( ( ) -> { progressDialog . setMessage ( "<STR_LIT>" ) ; worker . checkComment ( comment , progressDialog ) ; } ) ; } catch ( IOException e ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + e . getMessage ( ) ) ; } ) ; e . printStackTrace ( ) ; } } ) ; } else { worker . checkComment ( comment , progressDialog ) ; } } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; System . out . println ( "<STR_LIT>" ) ; System . out . println ( this ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } public static boolean checkNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; if ( notificationManager != null ) { return notificationManager . areNotificationsEnabled ( ) ; } } else { return true ; } return false ; } public static void requestNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { Intent intent = new Intent ( Settings . ACTION_APP_NOTIFICATION_SETTINGS ) ; intent . putExtra ( Settings . EXTRA_APP_PACKAGE , context . getPackageName ( ) ) ; context . startActivity ( intent ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } } </s>
<s> package icu . freedomIntrovert . async ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class BackstageTaskByMVP < T extends BackstageTaskByMVP . BaseEventHandler > implements Runnable { private final T uiHandler ; public BackstageTaskByMVP ( T uiHandler ) { this . uiHandler = uiHandler ; } protected abstract void onStart ( T eventHandlerProxy ) throws Throwable ; @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void run ( ) { T proxyInstance = ( T ) Proxy . newProxyInstance ( uiHandler . getClass ( ) . getClassLoader ( ) , uiHandler . getClass ( ) . getInterfaces ( ) , new EvProxyHandler ( uiHandler ) ) ; try { onStart ( proxyInstance ) ; TaskManger . postOnUiThread ( uiHandler :: onComplete ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; TaskManger . postOnUiThread ( ( ) -> uiHandler . onError ( e ) ) ; } } public void execute ( ) { TaskManger . start ( this ) ; } public static class EvProxyHandler implements InvocationHandler { Object evHandler ; public EvProxyHandler ( Object evHandler ) { this . evHandler = evHandler ; } @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) == Object . class ) { return method . invoke ( proxy , args ) ; } TaskManger . postOnUiThread ( ( ) -> { try { method . invoke ( evHandler , args ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } ) ; return null ; } } public interface BaseEventHandler { default void onError ( Throwable th ) { throw new RuntimeException ( th ) ; } default void onComplete ( ) { } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHookByGlobal extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { Handler handler = new Handler ( ) ; AtomicReference < Context > currentContext = new AtomicReference < > ( ) ; AtomicReference < String > currentDynId = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( "<STR_LIT>" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( "<STR_LIT>" ) ; String dynamicId = fragment_args . getString ( "<STR_LIT>" ) ; if ( dynamicId == null ) { dynamicId = fragment_args . getString ( "<STR_LIT>" ) ; } XposedBridge . log ( "<STR_LIT>" + dynamicId ) ; currentDynId . set ( dynamicId ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( "<STR_LIT>" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; if ( arg == null ) { return ; } Object body = XposedHelpers . callMethod ( arg , "<STR_LIT>" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( "<STR_LIT>" ) ) { Object data = XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ; if ( data != null && "<STR_LIT>" . equals ( data . getClass ( ) . getCanonicalName ( ) ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , "<STR_LIT>" ) ; Object content = XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( "<STR_LIT>" , ( String ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( oid ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( type ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( content , "<STR_LIT>" ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( "<STR_LIT>" , Utils . getBvidFormAvid ( oid ) ) ; } long ctime = XposedHelpers . getLongField ( reply , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , ctime ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; try { Field picturesField = content . getClass ( ) . getField ( "<STR_LIT>" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( "<STR_LIT>" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( "<STR_LIT>" ) ; } XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . FutureTask ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . ServiceGenerator ; public class Utils { public static String picturesObjToString ( List < ? > obj ) { List < BiliComment . Picture > pictures = new ArrayList < > ( ) ; if ( obj == null || obj . size ( ) == <NUM_LIT> ) { return null ; } for ( Object o : obj ) { BiliComment . Picture picture = new BiliComment . Picture ( ) ; picture . img_src = ( String ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_width = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_height = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_size = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; pictures . add ( picture ) ; } return JSON . toJSONString ( pictures ) ; } public static String getBvidFormAvid ( long avid ) throws ExecutionException , InterruptedException { Callable < String > callable = ( ) -> { BiliApiService biliApiService = ServiceGenerator . getBiliApiService ( ) ; GeneralResponse < VideoInfo > body = biliApiService . getVideoInfoByAid ( avid ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; return body . data . bvid ; } ; FutureTask < String > task = new FutureTask < > ( callable ) ; task . run ( ) ; return task . get ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import java . lang . reflect . Field ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class ShowInvisibleCommentHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodReplacement ( ) { @ Override protected Object replaceHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object thisObject = methodHookParam . thisObject ; Field invisibleField = thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; invisibleField . setAccessible ( true ) ; boolean invisible = invisibleField . getBoolean ( thisObject ) ; Field locationField = thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; locationField . setAccessible ( true ) ; String location = ( String ) locationField . get ( thisObject ) ; if ( invisible ) { return location + "<STR_LIT>" ; } else { return location ; } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import retrofit2 . Retrofit ; import retrofit2 . converter . fastjson . FastJsonConverterFactory ; public class ServiceGenerator { private static Retrofit retrofit ; private static BiliApiService biliApiService ; public static < T > T createService ( Class < T > cls ) { return ( T ) getRetrofit ( ) . create ( cls ) ; } public synchronized static Retrofit getRetrofit ( ) { if ( retrofit == null ) { retrofit = new Retrofit . Builder ( ) . baseUrl ( "<STR_LIT>" ) . addConverterFactory ( FastJsonConverterFactory . create ( ) ) . client ( OkHttpUtil . getHttpClient ( ) ) . build ( ) ; } return retrofit ; } public synchronized static BiliApiService getBiliApiService ( ) { if ( biliApiService == null ) { biliApiService = getRetrofit ( ) . create ( BiliApiService . class ) ; } return biliApiService ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . JSON ; public class SensitiveScanResult { public SensitiveScanResult ( int normalPosition , int unusualPosition ) { this . normalPosition = normalPosition ; this . unusualPosition = unusualPosition ; } public SensitiveScanResult ( ) { } public int normalPosition ; public int unusualPosition ; @ NonNull @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public abstract class OnExitListener { public void onNewCommentRpid ( long rpid ) { } public void onCommentStatusUpdated ( long rpid ) { } public void exit ( ) { } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . view ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class ProgressBarDialog implements DialogInterface { public static final int DEFAULT_MAX_PROGRESS = <NUM_LIT> ; public final AlertDialog alertDialog ; final ProgressBar progressBar ; ProgressBarDialog ( AlertDialog alertDialog , ProgressBar progressBar ) { this . alertDialog = alertDialog ; this . progressBar = progressBar ; } public void setProgress ( int progress ) { progressBar . setProgress ( progress ) ; } public void setMax ( int max ) { progressBar . setMax ( max ) ; } public void setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; } public void setMessage ( String message ) { alertDialog . setMessage ( message ) ; } public void setTitle ( String title ) { alertDialog . setTitle ( title ) ; } public Button getButton ( int whichButton ) { return alertDialog . getButton ( whichButton ) ; } @ Override public void cancel ( ) { alertDialog . cancel ( ) ; } @ Override public void dismiss ( ) { alertDialog . dismiss ( ) ; } public static class Builder { private final AlertDialog . Builder dialogBuilder ; private final ProgressBar progressBar ; public Builder ( Context context ) { dialogBuilder = new AlertDialog . Builder ( context ) ; View view = View . inflate ( context , R . layout . dialog_wait_progress , null ) ; progressBar = view . findViewById ( R . id . wait_progress_bar ) ; dialogBuilder . setView ( view ) ; progressBar . setMax ( DEFAULT_MAX_PROGRESS ) ; } public Builder setTitle ( String title ) { dialogBuilder . setTitle ( title ) ; return this ; } public Builder setMessage ( String message ) { dialogBuilder . setMessage ( message ) ; return this ; } public Builder setPositiveButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setPositiveButton ( text , listener ) ; return this ; } public Builder setNegativeButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNegativeButton ( text , listener ) ; return this ; } public Builder setNeutralButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNeutralButton ( text , listener ) ; return this ; } public Builder setCancelable ( boolean cancelable ) { dialogBuilder . setCancelable ( cancelable ) ; return this ; } public Builder setOnCancelListener ( DialogInterface . OnCancelListener listener ) { dialogBuilder . setOnCancelListener ( listener ) ; return this ; } public Builder setOnDismissListener ( DialogInterface . OnDismissListener listener ) { dialogBuilder . setOnDismissListener ( listener ) ; return this ; } public Builder setProgress ( int progress ) { progressBar . setProgress ( progress ) ; return this ; } public Builder setMax ( int max ) { progressBar . setMax ( max ) ; return this ; } public Builder setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; return this ; } public ProgressBarDialog show ( ) { return new ProgressBarDialog ( dialogBuilder . show ( ) , progressBar ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; public class InHookXConfig extends XConfig { public static final InHookXConfig config = new InHookXConfig ( new XSharedPreferences ( BuildConfig . APPLICATION_ID , PREF_NAME ) ) ; protected InHookXConfig ( XSharedPreferences sharedPreferences ) { super ( sharedPreferences ) ; XposedBridge . log ( sharedPreferences . getFile ( ) . toString ( ) ) ; } public static InHookXConfig getInstance ( ) { return config ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; public abstract class BaseHook { public abstract void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuPresenter ; public class DialogDanmakuCheckWorker { private Context context ; private Handler handler ; private DanmakuPresenter danmakuPresenter ; private OnExitListener exitListener ; public DialogDanmakuCheckWorker ( Context context , Handler handler , DanmakuPresenter danmakuPresenter , OnExitListener exitListener ) { this . context = context ; this . handler = handler ; this . danmakuPresenter = danmakuPresenter ; this . exitListener = exitListener ; } public void startCheckDanmaku ( long oid , long dmid , String content , String accessKey , long avid ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; danmakuPresenter . checkDanmaku ( oid , dmid , content , accessKey , avid , new DanmakuPresenter . CheckDanmakuCallBack ( ) { @ Override public void onSleeping ( long waitTime ) { progressDialog . setMessage ( "<STR_LIT>" + waitTime + "<STR_LIT>" ) ; } @ Override public void onGettingHasAccountDMList ( ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } @ Override public void onGettingNoAccountDMList ( ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } @ Override public void thenOk ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void thenDeleted ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void thenShadowBan ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void onNetworkError ( Throwable th ) { progressDialog . dismiss ( ) ; } } ) ; } private void showCheckResult ( String message ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( message ) . setCancelable ( false ) . setNegativeButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { exitListener . exit ( ) ; } } ) . show ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . SharedPreferences ; import android . util . Log ; import android . view . View ; import android . widget . EditText ; import android . widget . Toast ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Random ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentUtil { private CommentArea yourCommentArea ; private String sourceRandomComments ; private String [ ] randomComments ; private HashMap < CommentArea , LinkedList < String > > usedTestCommentMap ; SharedPreferences sp_config ; public CommentUtil ( Context context ) { sp_config = context . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; this . sourceRandomComments = sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; this . randomComments = sourceRandomComments . split ( "<STR_LIT>" ) ; usedTestCommentMap = new HashMap < > ( ) ; if ( sp_config . contains ( "<STR_LIT>" ) ) { this . yourCommentArea = new CommentArea ( Long . parseLong ( sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) , sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) , sp_config . getInt ( "<STR_LIT>" , <NUM_LIT> ) ) ; } } public String getSourceRandomComments ( ) { return sourceRandomComments ; } public String getAreaSourceText ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public CommentArea getYourCommentArea ( ) { return yourCommentArea ; } public boolean setYourCommentArea ( String sourceAreaText , CommentManipulator commentManipulator ) throws IOException { CommentArea commentArea = commentManipulator . matchCommentArea ( sourceAreaText ) ; if ( commentArea != null ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , String . valueOf ( commentArea . oid ) ) . putInt ( "<STR_LIT>" , commentArea . type ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . putString ( "<STR_LIT>" , sourceAreaText ) . apply ( ) ; yourCommentArea = commentArea ; return true ; } else { return false ; } } public void setYourCommentArea ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( getAreaSourceText ( ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , String . valueOf ( commentArea . oid ) ) . putInt ( "<STR_LIT>" , commentArea . type ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . putString ( "<STR_LIT>" , editText . getText ( ) . toString ( ) ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } } ) ; } } ) ; } public String getForwardDynamicId ( ) { return sp_config . getString ( "<STR_LIT>" , null ) ; } public void setDynamicIdToBeForward ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { if ( commentArea . type == CommentArea . AREA_TYPE_DYNAMIC17 || commentArea . type == CommentArea . AREA_TYPE_DYNAMIC11 ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , editText . getText ( ) . toString ( ) ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } else { editText . setError ( "<STR_LIT>" ) ; } } } ) ; } } ) ; } public String getRandomComment ( CommentArea area ) { if ( usedTestCommentMap . get ( area ) == null ) { LinkedList < String > noUsedCommentList = new LinkedList < > ( Arrays . asList ( randomComments ) ) ; usedTestCommentMap . put ( area , noUsedCommentList ) ; } Random random = new Random ( ) ; LinkedList < String > noUsedCommentList = usedTestCommentMap . get ( area ) ; int randomNum = random . nextInt ( noUsedCommentList . size ( ) ) ; String randomComment = noUsedCommentList . get ( randomNum ) ; noUsedCommentList . remove ( randomNum ) ; Log . i ( "<STR_LIT>" , randomComment ) ; return randomComment ; } public void updateRandomComments ( String sourceRandomComments ) { this . sourceRandomComments = sourceRandomComments ; sp_config . edit ( ) . putString ( "<STR_LIT>" , sourceRandomComments ) . apply ( ) ; } public static String sourceIdToUrl ( CommentArea area ) { String url = null ; if ( area . type == CommentArea . AREA_TYPE_VIDEO ) { url = "<STR_LIT>" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_ARTICLE ) { url = "<STR_LIT>" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_DYNAMIC11 || area . type == CommentArea . AREA_TYPE_DYNAMIC17 ) { url = "<STR_LIT>" + area . sourceId ; } return url ; } public static String subComment ( String comment , int length ) { if ( comment . length ( ) > length ) { return comment . substring ( <NUM_LIT> , length - <NUM_LIT> ) + "<STR_LIT>" ; } else { return comment ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class PendingCheckCommentsActivity extends AppCompatActivity { RecyclerView recyclerView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_pending_check_comments ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } LinearLayoutManager layoutManager = new LinearLayoutManager ( this ) ; layoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView = findViewById ( R . id . recycler_view ) ; recyclerView . setLayoutManager ( layoutManager ) ; recyclerView . setAdapter ( new PendingCommentListAdapter ( this ) ) ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; break ; } return true ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import android . view . View ; import android . widget . EditText ; import com . alibaba . fastjson . JSONObject ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; public class AppealDialogPresenter { Context context ; Handler handler ; CommentManipulator commentManipulator ; public AppealDialogPresenter ( Context context , Handler handler , CommentManipulator commentManipulator ) { this . context = context ; this . handler = handler ; this . commentManipulator = commentManipulator ; } public void appeal ( String areaIdentifier , String comment , CallBack callBack ) { View dialogView = View . inflate ( context , R . layout . dialog_appeal_comment , null ) ; EditText edt_appeal_area_location = dialogView . findViewById ( R . id . edt_appeal_area_location ) ; EditText edt_reason = dialogView . findViewById ( R . id . edt_reason ) ; edt_appeal_area_location . setText ( areaIdentifier ) ; edt_reason . setText ( "<STR_LIT>" + CommentUtil . subComment ( comment , <NUM_LIT> ) ) ; AlertDialog editAppealInfoDialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; editAppealInfoDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( edt_appeal_area_location . getText ( ) . toString ( ) . equals ( "<STR_LIT>" ) ) { edt_appeal_area_location . setError ( "<STR_LIT>" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) < <NUM_LIT> ) { edt_reason . setError ( "<STR_LIT>" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) > <NUM_LIT> ) { edt_reason . setError ( "<STR_LIT>" ) ; } else { new Thread ( ( ) -> { try { JSONObject appealRespJson = commentManipulator . appealComment ( edt_appeal_area_location . getText ( ) . toString ( ) , edt_reason . getText ( ) . toString ( ) ) ; int code = appealRespJson . getInteger ( "<STR_LIT>" ) ; String respMsg ; if ( code == <NUM_LIT> ) { respMsg = appealRespJson . getJSONObject ( "<STR_LIT>" ) . getString ( "<STR_LIT>" ) ; } else { respMsg = appealRespJson . getString ( "<STR_LIT>" ) ; } handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ; callBack . onRespInUI ( code , respMsg ) ; } ) ; } catch ( IOException e ) { handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ; callBack . onNetErrInUI ( e . getMessage ( ) ) ; } ) ; } } ) . start ( ) ; } } } ) ; } public interface CallBack { public void onRespInUI ( int code , String toastText ) ; public void onNetErrInUI ( String msg ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; import java . util . List ; public class BiliComment { public long rpid ; public long oid ; public int type ; public long mid ; public long root ; public long parent ; public Content content ; public Member member ; public int rcount ; public List < BiliComment > replies ; public int like ; public boolean invisible ; public long ctime ; public static class Member { public long mid ; public String uname ; public String avatar ; public LevelInFo level_info ; } public static class LevelInFo { @ JSONField ( name = "<STR_LIT>" ) public int currentLevel ; } public static class Content { public String message ; public List < Picture > pictures ; public int max_line ; } public static class Picture { public String img_src ; public Double img_width ; public Double img_height ; public Double img_size ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class RemoveDynamicReqObject { public RemoveDynamicReqObject ( String dyn_id_str ) { this . dyn_id_str = dyn_id_str ; } public String dyn_id_str ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . Context ; import java . util . Arrays ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . IntentTransferStationHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHookByGlobal ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostPictureHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . ShowInvisibleCommentHook ; public class XposedInit implements IXposedHookLoadPackage { @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam loadPackageParam ) throws Throwable { if ( loadPackageParam . packageName . equals ( "<STR_LIT>" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( "<STR_LIT>" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHook ( ) ) ; hookStater . startHook ( new ShowInvisibleCommentHook ( ) ) ; hookStater . startHook ( new IntentTransferStationHook ( ) ) ; hookStater . startHook ( new PostPictureHook ( ) ) ; } else if ( loadPackageParam . packageName . equals ( "<STR_LIT>" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( "<STR_LIT>" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHookByGlobal ( ) ) ; } } public static Context systemContext ( ) { Object obj = null ; Class < ? > findClassIfExists = XposedHelpers . findClass ( "<STR_LIT>" , null ) ; if ( findClassIfExists != null ) { obj = XposedHelpers . callStaticMethod ( findClassIfExists , "<STR_LIT>" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } return ( Context ) XposedHelpers . callMethod ( obj , "<STR_LIT>" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async ; import androidx . annotation . NonNull ; import org . jetbrains . annotations . Nullable ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; public class BiliBiliApiException extends Exception { public final int code ; public final String message ; public final String tipsMessage ; public BiliBiliApiException ( int code , String message , @ Nullable String tipsMessage ) { this . code = code ; this . message = message ; this . tipsMessage = tipsMessage ; } public BiliBiliApiException ( GeneralResponse < ? > response , @ Nullable String tipsMessage ) { super ( String . format ( "<STR_LIT>" , tipsMessage , response . code , response . message ) ) ; this . code = response . code ; this . message = response . message ; this . tipsMessage = tipsMessage ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + code + "<STR_LIT>" + message + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class PendingCommentListAdapter extends RecyclerView . Adapter < PendingCommentListAdapter . ViewHolder > { private final Context context ; private final StatisticsDBOpenHelper helper ; private final List < Comment > comments ; private final DialogCommCheckWorker worker ; public PendingCommentListAdapter ( Context context ) { this . context = context ; helper = new StatisticsDBOpenHelper ( context ) ; comments = helper . getAllPendingCheckComments ( ) ; Config config = new Config ( context ) ; worker = new DialogCommCheckWorker ( context , config , helper , new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) , new CommentUtil ( context ) ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . item_pending_check_comment , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { Comment comment = comments . get ( position ) ; holder . txv_comment . setText ( comment . comment ) ; holder . txv_info . setText ( comment . commentArea . sourceId ) ; holder . txv_date . setText ( comment . getFormatDateFor_yMdHms ( ) ) ; holder . itemView . setOnClickListener ( view -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( comment . comment ) . setPositiveButton ( android . R . string . ok , ( dialogInterface , i ) -> { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void onNewCommentRpid ( long rpid ) { comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } } ) ; worker . checkComment ( comment , progressBarDialog ) ; } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialogInterface , i ) -> { helper . deletePendingCheckComment ( comment . rpid ) ; comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } ) . show ( ) ; } ) ; } @ Override public int getItemCount ( ) { return comments . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { TextView txv_comment , txv_info , txv_date ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; txv_comment = itemView . findViewById ( R . id . txv_comment_content ) ; txv_info = itemView . findViewById ( R . id . txv_info ) ; txv_date = itemView . findViewById ( R . id . txv_date ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async ; public class CookieFailedException extends Exception { } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class IntentTransferStationHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; positioningActivity ( activity , activity . getIntent ( ) , classLoader ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; positioningActivity ( ( Activity ) param . thisObject , ( Intent ) param . args [ <NUM_LIT> ] , classLoader ) ; } } ) ; } private void positioningActivity ( Activity activity , Intent intent , ClassLoader classLoader ) throws ClassNotFoundException { Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { return ; } String transferActivity = extras . getString ( "<STR_LIT>" ) ; if ( transferActivity == null ) { return ; } Bundle transferExtras = extras . getBundle ( "<STR_LIT>" ) ; Intent newIntent = new Intent ( activity , classLoader . loadClass ( transferActivity ) ) ; String transferUri = extras . getString ( "<STR_LIT>" , null ) ; if ( transferUri != null ) { newIntent . setData ( Uri . parse ( transferUri ) ) ; } if ( transferExtras != null ) { newIntent . putExtras ( transferExtras ) ; } activity . startActivity ( newIntent ) ; } } </s>
<s> package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; public abstract class EventHandler extends Handler { public EventHandler ( ) { super ( ) ; } public EventHandler ( @ NonNull Looper looper ) { super ( looper ) ; } public void sendEventMessage ( EventMessage message ) { post ( ( ) -> handleEvent ( message ) ) ; } public void sendEventMessage ( int what , Object ... objects ) { post ( ( ) -> handleEvent ( new EventMessage ( what , objects ) ) ) ; } public void sendEmptyEventMessage ( int what ) { post ( ( ) -> handleEvent ( new EventMessage ( what ) ) ) ; } public void sendError ( Throwable th ) { post ( ( ) -> handleError ( th ) ) ; } protected abstract void handleEvent ( EventMessage message ) ; protected abstract void handleError ( Throwable th ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Context ; import android . net . Uri ; import androidx . activity . result . ActivityResultCallback ; import java . io . IOException ; import java . io . OutputStream ; import icu . freedomIntrovert . async . TaskManger ; public abstract class ActivityResultCallbackForSaveDoc < T extends ActivityResult > implements ActivityResultCallback < T > { public ActivityResultCallbackForSaveDoc ( Context context ) { this . context = context ; } Context context ; @ Override public void onActivityResult ( T result ) { if ( result . intent == null ) { onVoidResult ( ) ; return ; } Uri data = result . intent . getData ( ) ; if ( data == null ) { onVoidResult ( ) ; return ; } onHasResult ( ) ; TaskManger . start ( ( ) -> { try { OutputStream outputStream = context . getContentResolver ( ) . openOutputStream ( data ) ; if ( outputStream != null ) { onOpenOutputStream ( outputStream , result ) ; } else { onNullOutputStream ( ) ; } } catch ( IOException e ) { onIOException ( e ) ; } } ) ; } protected void onHasResult ( ) { } ; protected abstract void onOpenOutputStream ( OutputStream outputStream , T result ) throws IOException ; protected abstract void onNullOutputStream ( ) ; protected void onVoidResult ( ) { } ; protected abstract void onIOException ( Exception e ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import static android . view . KeyEvent . KEYCODE_BACK ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Bundle ; import android . util . Log ; import android . view . KeyEvent ; import android . view . MenuItem ; import android . webkit . CookieManager ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . ProgressBar ; import androidx . appcompat . app . AppCompatActivity ; public class WebViewLoginActivity extends AppCompatActivity { WebView webView ; public Context context ; Config config ; ProgressBar progressBar ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_web_view_login ) ; progressBar = findViewById ( R . id . progressBar ) ; context = this ; config = new Config ( context ) ; webView = findViewById ( R . id . web_view ) ; webView . loadUrl ( "<STR_LIT>" ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } @ Override public void onPageFinished ( WebView view , String url ) { CookieManager cookieManager = CookieManager . getInstance ( ) ; String cookieStr = cookieManager . getCookie ( url ) ; if ( cookieStr != null ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + cookieStr ) ; if ( cookieStr . contains ( "<STR_LIT>" ) ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( cookieStr ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { onCookieSet ( cookieStr ) ; finish ( ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { cookieManager . removeAllCookies ( value -> { } ) ; finish ( ) ; } ) . show ( ) ; } } super . onPageFinished ( view , url ) ; } } ) ; webView . setWebChromeClient ( new WebChromeClient ( ) { @ Override public void onProgressChanged ( WebView view , int newProgress ) { super . onProgressChanged ( view , newProgress ) ; progressBar . setProgress ( newProgress ) ; if ( newProgress == <NUM_LIT> ) { progressBar . setProgress ( <NUM_LIT> ) ; } } } ) ; } protected void onCookieSet ( String cookie ) { config . setCookie ( cookie ) ; } public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( ( keyCode == KEYCODE_BACK ) && webView . canGoBack ( ) ) { if ( webView . canGoBack ( ) ) { webView . goBack ( ) ; return true ; } else { finish ( ) ; return true ; } } return super . onKeyDown ( keyCode , event ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } return true ; } @ Override protected void onDestroy ( ) { if ( webView != null ) { webView . clearHistory ( ) ; webView . destroy ( ) ; webView = null ; } super . onDestroy ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class BannedOnlyInThisAreaCheckTask extends CommentOperateTask < BannedOnlyInThisAreaCheckTask . EventHandler > { CommentArea yourCommentArea ; public BannedOnlyInThisAreaCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentArea yourCommentArea ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . yourCommentArea = yourCommentArea ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_COMMENT_SENT_TO_YOUR_AREA , yourCommentArea . sourceId ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( comment . comment , <NUM_LIT> , <NUM_LIT> , yourCommentArea , false ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( yourCommentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( comment . commentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_ONLY_BANNED_IN_THIS_AREA ) ; } else { commentManipulator . deleteComment ( yourCommentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_BANNED_IN_YOUR_AREA ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_COMMENT_SENT_TO_YOUR_AREA = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_ONLY_BANNED_IN_THIS_AREA = <NUM_LIT> ; public static final int WHAT_THEN_BANNED_IN_YOUR_AREA = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import okhttp3 . OkHttpClient ; import okhttp3 . ResponseBody ; import retrofit2 . Response ; public class OkHttpUtil { private static OkHttpClient okHttpClient ; public static synchronized OkHttpClient getHttpClient ( ) { if ( okHttpClient == null ) { okHttpClient = new OkHttpClient . Builder ( ) . addInterceptor ( new LoggerInterceptor ( ) ) . build ( ) ; } return okHttpClient ; } public static void respNotNull ( GeneralResponse < ? > generalResponse ) throws IOException { if ( generalResponse == null ) { throw new IOException ( "<STR_LIT>" ) ; } } public static void respNotNull ( ResponseBody resp ) throws IOException { if ( resp == null ) { throw new IOException ( "<STR_LIT>" ) ; } } public static < T > GeneralResponse < T > getBody ( Response < GeneralResponse < T > > response ) throws IOException { if ( response . isSuccessful ( ) ) { return response . body ( ) ; } else { throw new IOException ( "<STR_LIT>" + response . code ( ) ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . util . Base64 ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . opencsv . CSVReader ; import com . opencsv . CSVWriter ; import com . opencsv . exceptions . CsvValidationException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; public class MartialLawCommentAreaListActivity extends AppCompatActivity { private static final int REQUEST_CODE_EXPORT = <NUM_LIT> ; private static final int REQUEST_CODE_IMPORT = <NUM_LIT> ; RecyclerView recyclerView ; StatisticsDBOpenHelper dbOpenHelper ; Context context ; ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList ; MartialLawCommentAreaListAdapter adapter ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_martial_law_comment_area_list ) ; ByXposedLaunchedActivity . lastActivity = this ; context = this ; dbOpenHelper = new StatisticsDBOpenHelper ( context ) ; martialLawCommentAreaArrayList = dbOpenHelper . queryMartialLawCommentAreas ( ) ; recyclerView = findViewById ( R . id . rv_martial_law_comment_area ) ; adapter = new MartialLawCommentAreaListAdapter ( martialLawCommentAreaArrayList , context ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( RecyclerView . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { case REQUEST_CODE_EXPORT : ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( data != null ) { try ( OutputStream outputStream = getContentResolver ( ) . openOutputStream ( data . getData ( ) ) ; CSVWriter csvWriter = new CSVWriter ( new OutputStreamWriter ( outputStream ) ) ) { List < String [ ] > csvData = new ArrayList < > ( ) ; String [ ] csvHeader = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; csvData . add ( csvHeader ) ; Collections . reverse ( martialLawCommentAreaArrayList ) ; for ( MartialLawCommentArea area : martialLawCommentAreaArrayList ) { byte [ ] imageData = dbOpenHelper . selectMartialLawCommentAreaCoverImage ( area . oid ) ; String [ ] csvRow = area . toStringArrays ( ) ; if ( imageData != null ) { csvRow [ <NUM_LIT> ] = Base64 . encodeToString ( imageData , Base64 . DEFAULT ) ; } csvData . add ( csvRow ) ; } Collections . reverse ( martialLawCommentAreaArrayList ) ; csvWriter . writeAll ( csvData ) ; runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; error ( "<STR_LIT>" + e . getMessage ( ) ) ; } } else { error ( "<STR_LIT>" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) . start ( ) ; break ; case REQUEST_CODE_IMPORT : ProgressDialog progressDialog1 = new ProgressDialog ( context ) ; progressDialog1 . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog1 . setMessage ( "<STR_LIT>" ) ; progressDialog1 . setCancelable ( false ) ; progressDialog1 . show ( ) ; Executor executor = Executors . newSingleThreadExecutor ( ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { List < MartialLawCommentArea > martialLawCommentAreas = new ArrayList < > ( ) ; if ( data != null ) { try ( InputStreamReader inputStreamReader = new InputStreamReader ( context . getContentResolver ( ) . openInputStream ( data . getData ( ) ) ) ; CSVReader csvReader = new CSVReader ( inputStreamReader ) ; ) { String [ ] fileds = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] csvLine ; int successCount = <NUM_LIT> ; int failCount = <NUM_LIT> ; if ( ( csvLine = csvReader . readNext ( ) ) != null ) { if ( Arrays . equals ( fileds , csvLine ) ) { while ( ( csvLine = csvReader . readNext ( ) ) != null ) { byte [ ] coverImageData = Base64 . decode ( csvLine [ <NUM_LIT> ] , Base64 . DEFAULT ) ; MartialLawCommentArea martialLawCommentArea = new MartialLawCommentArea ( csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , Integer . parseInt ( csvLine [ <NUM_LIT> ] ) , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , coverImageData ) ; System . out . println ( martialLawCommentArea ) ; if ( dbOpenHelper . insertMartialLawCommentArea ( martialLawCommentArea ) > <NUM_LIT> ) { martialLawCommentAreas . add ( martialLawCommentArea ) ; successCount ++ ; } else { failCount ++ ; } } int finalSuccessCount = successCount ; int finalFailCount = failCount ; runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; adapter . addData ( martialLawCommentAreas ) ; Toast . makeText ( context , "<STR_LIT>" + finalSuccessCount + "<STR_LIT>" + finalFailCount + "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } else { error ( "<STR_LIT>" ) ; } } else { error ( "<STR_LIT>" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } catch ( CsvValidationException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } } else { error ( "<STR_LIT>" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_export_and_input , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } else if ( item . getItemId ( ) == R . id . item_export ) { Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . CHINA ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; startActivityForResult ( intent , REQUEST_CODE_EXPORT ) ; } else if ( item . getItemId ( ) == R . id . item_import ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; startActivityForResult ( intent , REQUEST_CODE_IMPORT ) ; } return true ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . inputmethod . EditorInfo ; import android . widget . Button ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . Spinner ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . ActionBarDrawerToggle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . SwitchCompat ; import androidx . appcompat . widget . Toolbar ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . drawerlayout . widget . DrawerLayout ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class MainActivity extends AppCompatActivity { private static final int RESULT_CODE_SAVE_LOG_ZIP = <NUM_LIT> ; EditText edt_bvid , edt_comment ; Button btn_send , btn_clean , btn_send_and_appeal , btn_test ; CommentManipulator commentManipulator ; DrawerLayout drawerLayout ; SwitchCompat sw_recorde_history ; SwitchCompat sw_hook_picture_select ; ConstraintLayout cl_recorde_history_comment_sw ; LinearLayout ll_pending_check_comments , ll_martial_law_comment_area_list , ll_history_comment , ll_wait_time , ll_github_project ; Toolbar toolbar ; private Context context ; StatisticsDBOpenHelper statisticsDBOpenHelper ; boolean enableRecordeHistoryComment ; LinearLayout ll_test_comment_pool ; LinearLayout ll_you_comment_area ; LinearLayout ll_export_logs ; LinearLayout ll_targeting ; CommentUtil commentUtil ; Handler handler ; DialogCommCheckWorker dialogCommSendWorker ; Config config ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; ByXposedLaunchedActivity . lastActivity = this ; context = this ; config = new Config ( context ) ; commentUtil = new CommentUtil ( context ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; handler = new Handler ( ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; dialogCommSendWorker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , commentUtil ) ; initView ( ) ; initRecordeHistoryCommentSW ( ) ; initTestCommentPoolItem ( ) ; initWaitTimeItem ( ) ; initHomePageCommentCheck ( ) ; initToNewActivityItem ( ) ; initExportLogs ( ) ; initTargetingComment ( ) ; ll_you_comment_area . setOnClickListener ( v -> { commentUtil . setYourCommentArea ( context , commentManipulator ) ; } ) ; findViewById ( R . id . ll_forward_dynamic ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentUtil . setDynamicIdToBeForward ( context , commentManipulator ) ; } } ) ; } private void initTargetingComment ( ) { ll_targeting . setOnClickListener ( v -> { View dialogView = View . inflate ( context , R . layout . dialog_targeting_comment , null ) ; Spinner spinner = dialogView . findViewById ( R . id . spinner_area_type ) ; EditText oid = dialogView . findViewById ( R . id . edit_oid ) ; EditText rpid = dialogView . findViewById ( R . id . edit_rpid ) ; EditText root = dialogView . findViewById ( R . id . edit_root ) ; EditText sourceId = dialogView . findViewById ( R . id . edit_source_id ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { int type = CommentArea . AREA_TYPE_VIDEO ; switch ( spinner . getSelectedItemPosition ( ) ) { case <NUM_LIT> : type = CommentArea . AREA_TYPE_ARTICLE ; break ; case <NUM_LIT> : type = CommentArea . AREA_TYPE_DYNAMIC11 ; break ; case <NUM_LIT> : type = CommentArea . AREA_TYPE_DYNAMIC17 ; break ; default : break ; } CommentLocator . lunch ( context , type , Long . parseLong ( oid . getText ( ) . toString ( ) ) , Long . parseLong ( rpid . getText ( ) . toString ( ) ) , TextUtils . isEmpty ( root . getText ( ) . toString ( ) ) ? <NUM_LIT> : Long . parseLong ( root . getText ( ) . toString ( ) ) , TextUtils . isEmpty ( sourceId . getText ( ) . toString ( ) ) ? oid . getText ( ) . toString ( ) : sourceId . getText ( ) . toString ( ) ) ; } ) . setNegativeButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( data != null && data . getData ( ) != null ) { switch ( requestCode ) { case RESULT_CODE_SAVE_LOG_ZIP : ProgressBarDialog dialog = new ProgressBarDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . show ( ) ; new Thread ( ( ) -> { try { File sourceFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; OutputStream outputStream = getContentResolver ( ) . openOutputStream ( data . getData ( ) ) ; ZipOutputStream zos = new ZipOutputStream ( outputStream ) ; zipDirectory ( sourceFolder , sourceFolder , zos ) ; zos . close ( ) ; outputStream . close ( ) ; runOnUiThread ( ( ) -> { dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } ) ; } catch ( IOException e ) { runOnUiThread ( ( ) -> { dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } ) ; } } ) . start ( ) ; break ; default : throw new RuntimeException ( ) ; } } } private static void zipDirectory ( File rootPath , File sourceFolder , ZipOutputStream zos ) throws IOException { for ( File file : sourceFolder . listFiles ( ) ) { if ( file . isDirectory ( ) ) { zipDirectory ( rootPath , file , zos ) ; } else { addToZip ( rootPath , file , zos ) ; } } } private static void addToZip ( File rootPath , File file , ZipOutputStream zos ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; String zipFilePath = file . getAbsolutePath ( ) . substring ( rootPath . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; ZipEntry zipEntry = new ZipEntry ( zipFilePath ) ; zos . putNextEntry ( zipEntry ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; int length ; while ( ( length = fis . read ( bytes ) ) >= <NUM_LIT> ) { zos . write ( bytes , <NUM_LIT> , length ) ; } zos . closeEntry ( ) ; fis . close ( ) ; } private static long calculateFolderSize ( File folder ) { long size = <NUM_LIT> ; if ( folder . isDirectory ( ) ) { File [ ] files = folder . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { if ( file . isFile ( ) ) { size += file . length ( ) ; } else { size += calculateFolderSize ( file ) ; } } } } else if ( folder . isFile ( ) ) { size += folder . length ( ) ; } return size ; } private static boolean deleteFolder ( File folder ) { if ( folder . isDirectory ( ) ) { File [ ] files = folder . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { deleteFolder ( file ) ; } } } return folder . delete ( ) ; } private void initExportLogs ( ) { ll_export_logs . setOnClickListener ( v -> { File sourceFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; if ( ! sourceFolder . exists ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . CHINA ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; startActivityForResult ( intent , RESULT_CODE_SAVE_LOG_ZIP ) ; } ) ; ll_export_logs . setOnLongClickListener ( v -> { File logsFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setMessage ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , ( double ) calculateFolderSize ( logsFolder ) / ( <NUM_LIT> * <NUM_LIT> ) ) ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { deleteFolder ( logsFolder ) ; Toast . makeText ( MainActivity . this , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return false ; } ) ; } private void initView ( ) { drawerLayout = findViewById ( R . id . drawerLayout ) ; toolbar = findViewById ( R . id . toolbar ) ; edt_bvid = findViewById ( R . id . edt_bvid ) ; edt_comment = findViewById ( R . id . edt_comment ) ; btn_send = findViewById ( R . id . btn_send ) ; btn_clean = findViewById ( R . id . btn_clean ) ; ll_pending_check_comments = findViewById ( R . id . ll_pending_check_comment_list ) ; ll_martial_law_comment_area_list = findViewById ( R . id . ll_martial_law_comment_area_list ) ; ll_history_comment = findViewById ( R . id . ll_history_comment ) ; ll_test_comment_pool = findViewById ( R . id . ll_test_comment_pool ) ; ll_you_comment_area = findViewById ( R . id . ll_your_comment_area ) ; ll_wait_time = findViewById ( R . id . ll_wait_time ) ; ll_export_logs = findViewById ( R . id . ll_export_logs ) ; cl_recorde_history_comment_sw = findViewById ( R . id . cl_recorde_history_comment_sw ) ; ll_targeting = findViewById ( R . id . ll_targeting ) ; ll_github_project = findViewById ( R . id . ll_github_project ) ; sw_recorde_history = findViewById ( R . id . sw_recorde_history ) ; btn_send_and_appeal = findViewById ( R . id . btn_send_and_appeal ) ; setSupportActionBar ( toolbar ) ; ActionBarDrawerToggle toggle = new ActionBarDrawerToggle ( this , drawerLayout , toolbar , R . string . drawer_open , R . string . drawer_close ) ; drawerLayout . addDrawerListener ( toggle ) ; toggle . syncState ( ) ; } private void initRecordeHistoryCommentSW ( ) { enableRecordeHistoryComment = config . getRecordeHistory ( ) ; sw_recorde_history . setChecked ( enableRecordeHistoryComment ) ; cl_recorde_history_comment_sw . setOnClickListener ( v -> { sw_recorde_history . setChecked ( ! enableRecordeHistoryComment ) ; } ) ; sw_recorde_history . setOnCheckedChangeListener ( ( buttonView , isChecked ) -> { if ( isChecked ) { enableRecordeHistoryComment = true ; config . setRecordeHistory ( true ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { enableRecordeHistoryComment = false ; config . setRecordeHistory ( false ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } private void initToNewActivityItem ( ) { ll_pending_check_comments . setOnClickListener ( v -> { startActivity ( new Intent ( MainActivity . this , PendingCheckCommentsActivity . class ) ) ; } ) ; ll_martial_law_comment_area_list . setOnClickListener ( v -> { startActivity ( new Intent ( context , MartialLawCommentAreaListActivity . class ) ) ; } ) ; ll_history_comment . setOnClickListener ( v -> { startActivity ( new Intent ( context , HistoryCommentActivity . class ) ) ; } ) ; ll_github_project . setOnClickListener ( v -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) ; } private void initTestCommentPoolItem ( ) { ll_test_comment_pool . setOnClickListener ( v -> { View edtView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( commentUtil . getSourceRandomComments ( ) ) ; AlertDialog setRandomDialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , null ) . setNeutralButton ( "<STR_LIT>" , null ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; setRandomDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( v1 -> { if ( editText . getText ( ) . toString ( ) . split ( "<STR_LIT>" ) . length > <NUM_LIT> ) { commentUtil . updateRandomComments ( editText . getText ( ) . toString ( ) ) ; setRandomDialog . dismiss ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } ) ; setRandomDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) . setOnClickListener ( v12 -> { new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } ) ; } private void initWaitTimeItem ( ) { ll_wait_time . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { View dialogView = View . inflate ( context , R . layout . dialog_set_wait_time , null ) ; EditText editTextWTByCommentSent = dialogView . findViewById ( R . id . edit_text_wt_by_after_comment_sent ) ; EditText editTextWTByHasPictures = dialogView . findViewById ( R . id . edit_text_wt_by_has_pictures ) ; EditText editTextWTByDanmakuSent = dialogView . findViewById ( R . id . edit_text_wt_danmaku_sent ) ; editTextWTByCommentSent . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByCommentSent . setText ( String . valueOf ( config . getWaitTime ( ) ) ) ; editTextWTByHasPictures . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByHasPictures . setText ( String . valueOf ( config . getWaitTimeByHasPictures ( ) ) ) ; editTextWTByDanmakuSent . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByDanmakuSent . setText ( String . valueOf ( config . getWaitTimeByDanmakuSend ( ) ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { long waitTime = Long . parseLong ( editTextWTByCommentSent . getText ( ) . toString ( ) ) ; long waitTimeByHasPictures = Long . parseLong ( editTextWTByHasPictures . getText ( ) . toString ( ) ) ; long waitTimeByDanmakuSent = Long . parseLong ( editTextWTByDanmakuSent . getText ( ) . toString ( ) ) ; config . setWaitTime ( waitTime ) ; config . setWaitTimeByHasPictures ( waitTimeByHasPictures ) ; config . setWaitTimeByDanmakuSend ( waitTimeByDanmakuSent ) ; toastLong ( "<STR_LIT>" ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } } ) ; } private void initHomePageCommentCheck ( ) { btn_send . setOnClickListener ( v -> { ProgressBarDialog dialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; commentManipulator . matchCommentAreaInUi ( edt_bvid . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { dialog . dismiss ( ) ; toastNetErr ( e . getMessage ( ) ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { dialog . setMessage ( "<STR_LIT>" ) ; String comment = edt_comment . getText ( ) . toString ( ) ; commentManipulator . getSendCommentCall ( comment , <NUM_LIT> , <NUM_LIT> , commentArea , false ) . enqueue ( new BiliApiCallback < GeneralResponse < CommentAddResult > > ( ) { @ Override public void onError ( Throwable th ) { dialog . dismiss ( ) ; toastNetErr ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < CommentAddResult > response ) { if ( commentSendSuccess ( response , commentArea , comment , dialog ) ) { dialog . setIndeterminate ( false ) ; new Thread ( ( ) -> { long waitTime = config . getWaitTime ( ) ; new ProgressTimer ( waitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , new ProgressTimer . ProgressLister ( ) { @ Override public void onNewProgress ( int progress , long sleepSeg ) { runOnUiThread ( ( ) -> { dialog . setMessage ( "<STR_LIT>" + progress * sleepSeg + "<STR_LIT>" + waitTime + "<STR_LIT>" ) ; dialog . setProgress ( progress ) ; } ) ; } } ) . start ( ) ; runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { dialogCommSendWorker . checkComment ( new Comment ( commentArea , response . data . rpid , <NUM_LIT> , <NUM_LIT> , comment , null , new Date ( response . data . reply . ctime * <NUM_LIT> ) ) , dialog ) ; } } ) ; } ) . start ( ) ; } } } ) ; } else { Toast . makeText ( context , R . string . bv_cv_url_typo , Toast . LENGTH_SHORT ) . show ( ) ; dialog . dismiss ( ) ; } } } ) ; } ) ; btn_send_and_appeal . setOnClickListener ( v -> { if ( commentManipulator . cookieAreSet ( ) ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , null , "<STR_LIT>" ) ; progressDialog . show ( ) ; String comment = edt_comment . getText ( ) . toString ( ) ; commentManipulator . matchCommentAreaInUi ( edt_bvid . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { progressDialog . dismiss ( ) ; toastShort ( e . getMessage ( ) ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { progressDialog . setMessage ( "<STR_LIT>" ) ; AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , handler , commentManipulator ) ; commentManipulator . getSendCommentCall ( comment , <NUM_LIT> , <NUM_LIT> , commentArea , false ) . enqueue ( new BiliApiCallback < GeneralResponse < CommentAddResult > > ( ) { @ Override public void onError ( Throwable th ) { progressDialog . dismiss ( ) ; toastLong ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < CommentAddResult > response ) { progressDialog . dismiss ( ) ; toastLong ( "<STR_LIT>" ) ; if ( commentSendSuccess ( response , commentArea , comment , progressDialog ) ) { appealDialogPresenter . appeal ( edt_bvid . getText ( ) . toString ( ) , comment , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , response . data . rpid , <NUM_LIT> , <NUM_LIT> , comment , HistoryComment . STATE_UNKNOWN , new Date ( response . data . reply . ctime ) ) ) ; if ( code == <NUM_LIT> ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNKNOWN ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } else if ( code == <NUM_LIT> ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_NORMAL ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNKNOWN ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; return ; } if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDBOpenHelper . insertHistoryComment ( historyComment ) ; } } @ Override public void onNetErrInUI ( String msg ) { toastNetErr ( msg ) ; } } ) ; } } } ) ; } else { progressDialog . dismiss ( ) ; toastShort ( R . string . bv_cv_url_typo ) ; } } } ) ; } else { toastShort ( "<STR_LIT>" ) ; } } ) ; btn_clean . setOnClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { edt_bvid . setText ( "<STR_LIT>" ) ; edt_comment . setText ( "<STR_LIT>" ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } private boolean commentSendSuccess ( GeneralResponse < CommentAddResult > response , CommentArea commentArea , String comment , DialogInterface dialog ) { if ( response . isSuccess ( ) ) { if ( response . data . success_action == <NUM_LIT> ) { return true ; } else { dialog . dismiss ( ) ; new AlertDialog . Builder ( context ) . setMessage ( response . data . success_toast ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNegativeButton ( "<STR_LIT>" , ( dialog1 , which ) -> { commentManipulator . createDeleteCommentCall ( commentArea , response . data . rpid ) . enqueue ( new BiliApiCallback < GeneralResponse < Object > > ( ) { @ Override public void onError ( Throwable th ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onSuccess ( GeneralResponse < Object > unused ) { if ( unused . isSuccess ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; } ) . show ( ) ; } } else if ( response . code == CommentAddResult . CODE_CONTAIN_SENSITIVE ) { if ( config . getRecordeHistoryIsEnable ( ) ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , - System . currentTimeMillis ( ) , <NUM_LIT> , <NUM_LIT> , comment , null , new Date ( ) ) ) ; historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SENSITIVE ) ; statisticsDBOpenHelper . insertHistoryComment ( historyComment ) ; } dialog . dismiss ( ) ; toastLong ( response . message ) ; } else { dialog . dismiss ( ) ; toastLong ( response . message ) ; } return false ; } private void toastShort ( String text ) { Toast . makeText ( context , text , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastShort ( int text ) { Toast . makeText ( context , text , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastLong ( String text ) { Toast . makeText ( context , text , Toast . LENGTH_LONG ) . show ( ) ; } private void toastNetErr ( String e ) { toastShort ( "<STR_LIT>" + e ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_cookie , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == R . id . main_account_cookie ) { View edtView = View . inflate ( MainActivity . this , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( config . getCookie ( ) ) ; new AlertDialog . Builder ( MainActivity . this ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { String cookie = editText . getText ( ) . toString ( ) ; config . setCookie ( cookie ) ; commentManipulator . setCookie ( cookie ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { startActivity ( new Intent ( context , WebViewLoginActivity . class ) ) ; } ) . show ( ) ; } else if ( item . getItemId ( ) == R . id . deputy_account_cookie ) { View edtView = View . inflate ( MainActivity . this , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( config . getDeputyCookie ( ) ) ; new AlertDialog . Builder ( MainActivity . this ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { String cookie = editText . getText ( ) . toString ( ) ; config . setDeputyCookie ( cookie ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { startActivity ( new Intent ( context , WebViewLoginByDeputyActivity . class ) ) ; } ) . show ( ) ; } return true ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; import java . io . File ; public class ActivityResultForFile extends ActivityResult { public ActivityResultForFile ( Intent intent , File file ) { super ( intent ) ; this . file = file ; } public File file ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public class WebViewLoginByDeputyActivity extends WebViewLoginActivity { @ Override protected void onCookieSet ( String cookie ) { config . setDeputyCookie ( cookie ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . graphics . Paint ; import android . net . Uri ; import android . os . Handler ; import android . text . Spannable ; import android . text . SpannableStringBuilder ; import android . text . style . ForegroundColorSpan ; import android . util . TypedValue ; import android . view . LayoutInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageView ; import android . widget . PopupMenu ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . ResendCommentTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . ReviewCommentStatusTask ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class HistoryCommentAdapter extends RecyclerView . Adapter < HistoryCommentAdapter . ViewHolder > implements BiliBiliApiRequestHandler . DialogErrorHandle . OnDialogMessageListener { HistoryCommentActivity context ; StatisticsDBOpenHelper statisticsDBOpenHelper ; List < HistoryComment > historyCommentList ; CommentManipulator commentManipulator ; DialogCommCheckWorker dialogCommCheckWorker ; Config config ; boolean 花里胡哨 ; public HistoryCommentAdapter ( HistoryCommentActivity context , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDBOpenHelper ) { this . context = context ; config = new Config ( context ) ; this . statisticsDBOpenHelper = statisticsDBOpenHelper ; Config config = new Config ( context ) ; this . commentManipulator = commentManipulator ; this . dialogCommCheckWorker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , new CommentUtil ( context ) ) ; 花里胡哨 = config . get花里胡哨Enable ( ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View itemView = LayoutInflater . from ( context ) . inflate ( R . layout . item_history_comment , parent , false ) ; return new ViewHolder ( itemView ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { HistoryComment historyComment = historyCommentList . get ( position ) ; holder . txv_comment . setText ( historyComment . comment ) ; if ( historyComment . hasPictures ( ) ) { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long_pic ) ) ; } else if ( historyComment . root != <NUM_LIT> ) { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long_reply ) ) ; } else { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long ) ) ; } switch ( historyComment . checkedArea ) { case HistoryComment . CHECKED_NO_CHECK : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . GRAY ) ) ; break ; case HistoryComment . CHECKED_NOT_MARTIAL_LAW : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . blue ) ) ; break ; case HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . yellow ) ) ; break ; case HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . green ) ) ; break ; case HistoryComment . CHECKED_MARTIAL_LAW : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; break ; } switch ( historyComment . lastState ) { case HistoryComment . STATE_NORMAL : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . normal ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SHADOW_BAN : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; if ( historyComment . firstState != null && historyComment . firstState . equals ( HistoryComment . STATE_NORMAL ) ) { holder . txv_banned_type . setText ( "<STR_LIT>" ) ; } else { holder . txv_banned_type . setText ( "<STR_LIT>" ) ; } break ; case HistoryComment . STATE_UNDER_REVIEW : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . i ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_DELETED : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SENSITIVE : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . sensitive ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_INVISIBLE : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . ghost ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNKNOWN : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . unknown ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_access_time_24 ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; } if ( 花里胡哨 ) { switch ( historyComment . lastState ) { case HistoryComment . STATE_DELETED : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . STRIKE_THRU_TEXT_FLAG | Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SHADOW_BAN : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_INVISIBLE : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . gray ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_UNDER_REVIEW : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . orange ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . blue ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SENSITIVE : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_violet ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; default : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_font ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; } } else { holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_font ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; } holder . txv_date . setText ( historyComment . getFormatDateFor_yMd ( ) ) ; holder . txv_info . setText ( historyComment . commentArea . sourceId ) ; holder . txv_like . setText ( formatCount ( historyComment . like ) ) ; if ( historyComment . like > <NUM_LIT> || historyComment . replyCount > <NUM_LIT> ) { holder . txv_like . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; holder . txv_reply_count . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; } holder . txv_reply_count . setText ( formatCount ( historyComment . replyCount ) ) ; holder . itemView . setOnClickListener ( v -> { showCommentInfoDialog ( historyComment , holder ) ; } ) ; holder . itemView . setOnLongClickListener ( v -> { View view = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = view . findViewById ( R . id . edit_text ) ; editText . setText ( historyComment . comment ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( view ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; ResendCommentHandler handler = new ResendCommentHandler ( this , progressBarDialog , historyComment , holder ) ; new ResendCommentTask ( handler , commentManipulator , config , editText . getText ( ) . toString ( ) , historyComment ) . execute ( ) ; } ) . show ( ) ; return false ; } ) ; } private void showCommentInfoDialog ( HistoryComment historyComment , ViewHolder holder ) { View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . dialog_history_comment_info , null , true ) ; TextView txv_comment = dialogView . findViewById ( R . id . txv_comment_content ) ; TextView txv_last_state = dialogView . findViewById ( R . id . txv_last_state ) ; TextView txv_source_id = dialogView . findViewById ( R . id . txv_source_id ) ; TextView txv_oid = dialogView . findViewById ( R . id . txv_oid ) ; TextView txv_area_type = dialogView . findViewById ( R . id . txv_area_type ) ; TextView txv_rpid = dialogView . findViewById ( R . id . txv_rpid ) ; TextView txv_parent = dialogView . findViewById ( R . id . txv_parent ) ; TextView txv_root = dialogView . findViewById ( R . id . txv_root ) ; TextView txv_check_date = dialogView . findViewById ( R . id . txv_check_date ) ; TextView txv_send_date = dialogView . findViewById ( R . id . txv_send_date ) ; TextView txv_first_state = dialogView . findViewById ( R . id . txv_first_state ) ; TextView txv_checked_area = dialogView . findViewById ( R . id . txv_checked_area ) ; SensitiveScanResult scr = historyComment . sensitiveScanResult ; if ( scr != null ) { ForegroundColorSpan greenSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . green ) ) ; ForegroundColorSpan redSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . red ) ) ; SpannableStringBuilder builder0 = new SpannableStringBuilder ( historyComment . comment ) ; builder0 . setSpan ( greenSpan , <NUM_LIT> , scr . normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder0 . setSpan ( redSpan , scr . normalPosition , scr . unusualPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment . setText ( builder0 ) ; System . out . println ( scr . normalPosition ) ; } else { txv_comment . setText ( historyComment . comment ) ; } txv_last_state . setText ( HistoryComment . getStateDesc ( historyComment . lastState ) ) ; txv_first_state . setText ( HistoryComment . getStateDesc ( historyComment . firstState ) ) ; txv_source_id . setText ( historyComment . commentArea . sourceId ) ; txv_oid . setText ( String . valueOf ( historyComment . commentArea . oid ) ) ; txv_area_type . setText ( historyComment . commentArea . getAreaTypeDesc ( ) ) ; txv_rpid . setText ( String . valueOf ( historyComment . rpid ) ) ; txv_parent . setText ( String . valueOf ( historyComment . parent ) ) ; txv_root . setText ( String . valueOf ( historyComment . root ) ) ; txv_check_date . setText ( historyComment . getFormatLastCheckDateFor_yMdHms ( ) ) ; txv_send_date . setText ( historyComment . getFormatDateFor_yMdHms ( ) ) ; switch ( historyComment . checkedArea ) { case HistoryComment . CHECKED_NO_CHECK : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_NOT_MARTIAL_LAW : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_MARTIAL_LAW : txv_checked_area . setText ( "<STR_LIT>" ) ; } List < Comment . PictureInfo > pictureInfoList = historyComment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { RecyclerView rv_images = dialogView . findViewById ( R . id . rv_pictures ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . HORIZONTAL ) ; rv_images . setLayoutManager ( linearLayoutManager ) ; PicturesAdapter picturesAdapter = new PicturesAdapter ( context , pictureInfoList , linearLayoutManager ) ; rv_images . setAdapter ( picturesAdapter ) ; } AlertDialog . Builder builder = new AlertDialog . Builder ( context ) . setView ( dialogView ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; if ( ! HistoryComment . STATE_SENSITIVE . equals ( historyComment . firstState ) ) { builder . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , null , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; ReviewCommentStatusHandler handle = new ReviewCommentStatusHandler ( this , historyComment , progressDialog , holder ) ; new ReviewCommentStatusTask ( handle , commentManipulator , statisticsDBOpenHelper , historyComment ) . execute ( ) ; } ) ; } AlertDialog infoDialog = builder . setNeutralButton ( "<STR_LIT>" , null ) . show ( ) ; Button buttonMore = infoDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) ; buttonMore . setOnClickListener ( v1 -> showSubMenu ( buttonMore , infoDialog , holder , historyComment ) ) ; } private static class ReviewCommentStatusHandler extends ReviewCommentStatusTask . EventHandler { private final HistoryCommentAdapter adapter ; private final HistoryComment historyComment ; private final ProgressDialog progressDialog ; private final ViewHolder holder ; public ReviewCommentStatusHandler ( HistoryCommentAdapter adapter , HistoryComment historyComment , ProgressDialog progressDialog , ViewHolder holder ) { super ( new DialogErrorHandle ( progressDialog , adapter ) ) ; this . adapter = adapter ; this . historyComment = historyComment ; this . progressDialog = progressDialog ; this . holder = holder ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_PAGE_TURN_FOR_NO_ACC_REPLY : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_OK : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_NORMAL ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_SHADOW_BANNED : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_SHADOW_BAN ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_DELETED : progressDialog . dismiss ( ) ; historyComment . lastCheckDate = new Date ( ) ; historyComment . lastState = HistoryComment . STATE_DELETED ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_INVISIBLE : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_INVISIBLE ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_UNDER_REVIEW : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_UNDER_REVIEW ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_REPLY_OK : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_NORMAL ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_ROOT_COMMENT_IS_SHADOW_BAN : progressDialog . dismiss ( ) ; historyComment . lastState = HistoryComment . STATE_SHADOW_BAN ; historyComment . lastCheckDate = new Date ( ) ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; } } private void updateCommentInfo ( BiliComment resultComment , String newState ) { historyComment . lastState = newState ; historyComment . like = resultComment . like ; historyComment . replyCount = resultComment . rcount ; historyComment . lastCheckDate = new Date ( ) ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; } private void dialogCheckResult ( String result ) { DialogUtil . dialogMessage ( adapter . context , "<STR_LIT>" , result ) ; } } private static class ResendCommentHandler extends ResendCommentTask . EventHandler { ProgressBarDialog progressBarDialog ; HistoryComment historyComment ; HistoryCommentAdapter adapter ; DialogCommCheckWorker worker ; ViewHolder holder ; StatisticsDBOpenHelper helper ; public ResendCommentHandler ( HistoryCommentAdapter adapter , ProgressBarDialog progressBarDialog , HistoryComment historyComment , ViewHolder viewHolder ) { super ( new DialogErrorHandle ( progressBarDialog , adapter ) ) ; this . progressBarDialog = progressBarDialog ; this . historyComment = historyComment ; this . adapter = adapter ; this . worker = adapter . dialogCommCheckWorker ; this . holder = viewHolder ; this . helper = adapter . statisticsDBOpenHelper ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_SEND_SUCCESS_AND_SLEEP : progressBarDialog . setIndeterminate ( false ) ; progressBarDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_NEW_PROGRESS : int progress = message . getObject ( <NUM_LIT> , Integer . class ) ; progressBarDialog . setMessage ( "<STR_LIT>" + progress * message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; progressBarDialog . setProgress ( progress ) ; break ; case WHAT_ON_RESENT_COMMENT : progressBarDialog . setIndeterminate ( true ) ; BiliComment c = message . getObject ( <NUM_LIT> , CommentAddResult . class ) . reply ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void onNewCommentRpid ( long rpid ) { HistoryComment comment = helper . getHistoryComment ( c . rpid ) ; adapter . historyCommentList . add ( <NUM_LIT> , comment ) ; adapter . notifyItemInserted ( <NUM_LIT> ) ; } } ) ; worker . checkComment ( new Comment ( historyComment . commentArea , c . rpid , c . parent , c . root , c . content . message , null , new Date ( c . ctime * <NUM_LIT> ) ) , progressBarDialog ) ; break ; case WHAT_ON_CONTAIN_SENSITIVE : progressBarDialog . dismiss ( ) ; String title = message . getObject ( <NUM_LIT> , String . class ) ; String newComment = message . getObject ( <NUM_LIT> , String . class ) ; new AlertDialog . Builder ( adapter . context ) . setTitle ( title ) . setMessage ( "<STR_LIT>" + newComment ) . setOnDismissListener ( dialog -> { HistoryComment sensitiveComment = new HistoryComment ( historyComment . commentArea , - System . currentTimeMillis ( ) , historyComment . parent , historyComment . root , newComment , new Date ( ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_SENSITIVE , new Date ( ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_SENSITIVE , null , null ) ; adapter . statisticsDBOpenHelper . insertHistoryComment ( sensitiveComment ) ; adapter . historyCommentList . add ( <NUM_LIT> , sensitiveComment ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; break ; } } } private void showSubMenu ( Button button , DialogInterface dialog , ViewHolder holder , HistoryComment historyComment ) { PopupMenu popupMenu = new PopupMenu ( context , button ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { dialog . dismiss ( ) ; new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog14 , which2 ) -> { if ( statisticsDBOpenHelper . deleteHistoryComment ( historyComment . rpid ) != <NUM_LIT> ) { List < Comment . PictureInfo > pictureInfoList = historyComment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { for ( Comment . PictureInfo pictureInfo : pictureInfoList ) { PictureStorage . delete ( context , pictureInfo . img_src ) ; } } historyCommentList . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return false ; } ) ; if ( ! historyComment . lastState . equals ( HistoryComment . STATE_NORMAL ) && ! historyComment . lastState . equals ( HistoryComment . STATE_SENSITIVE ) ) { popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { AlertDialog dialog1 = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog23 , which1 ) -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog24 , which1 ) -> { AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , new Handler ( ) , commentManipulator ) ; appealDialogPresenter . appeal ( CommentUtil . sourceIdToUrl ( historyComment . commentArea ) , historyComment . comment , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { if ( code == <NUM_LIT> ) { statisticsDBOpenHelper . updateHistoryCommentLastState ( historyComment . rpid , HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText + "<STR_LIT>" ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } } @ Override public void onNetErrInUI ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } ) . show ( ) ; return false ; } } ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( android . R . string . ok , ( dialog12 , which ) -> { dialogCommCheckWorker . setExitListener ( new OnExitListener ( ) { @ Override public void onCommentStatusUpdated ( long rpid ) { historyCommentList . set ( holder . getBindingAdapterPosition ( ) , statisticsDBOpenHelper . getHistoryComment ( rpid ) ) ; notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; } } ) ; dialog . dismiss ( ) ; dialogCommCheckWorker . scanSensitiveWord ( historyComment ) ; } ) . show ( ) ; return false ; } ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , ( dialog15 , which ) -> { checkArea ( true ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog13 , which ) -> { checkArea ( false ) ; } ) . setNeutralButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; return false ; } public void checkArea ( boolean isDeputyAccount ) { dialog . dismiss ( ) ; int position = holder . getBindingAdapterPosition ( ) ; DialogInterface . OnDismissListener listener = dialog16 -> { System . out . println ( position ) ; historyCommentList . set ( position , statisticsDBOpenHelper . getHistoryComment ( historyComment . rpid ) ) ; notifyItemChanged ( position ) ; } ; dialogCommCheckWorker . checkAreaMartialLaw ( historyComment , listener , isDeputyAccount ) ; } } ) ; } if ( ! historyComment . lastState . equals ( HistoryComment . STATE_SENSITIVE ) ) { popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { CommentLocator . lunch ( context , historyComment . commentArea . type , historyComment . commentArea . oid , historyComment . rpid , historyComment . root , historyComment . commentArea . sourceId ) ; return false ; } ) ; } popupMenu . show ( ) ; } @ Override public int getItemCount ( ) { return historyCommentList . size ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addSomeData ( List < HistoryComment > historyCommentList ) { Collections . reverse ( historyCommentList ) ; this . historyCommentList . addAll ( <NUM_LIT> , historyCommentList ) ; notifyDataSetChanged ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void reloadData ( List < HistoryComment > historyCommentList ) { this . historyCommentList = historyCommentList ; notifyDataSetChanged ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void set花里胡哨Enable ( boolean enable ) { this . 花里胡哨 = enable ; notifyDataSetChanged ( ) ; } public static String formatCount ( int count ) { if ( count < <NUM_LIT> ) { return String . valueOf ( count ) ; } else { return String . format ( Locale . getDefault ( ) , "<STR_LIT>" , count / <NUM_LIT> ) ; } } public static class ViewHolder extends RecyclerView . ViewHolder { View itemView ; TextView txv_comment , txv_like , txv_reply_count , txv_info , txv_date , txv_banned_type ; ImageView imgv_banned_type , imgv_cover_image ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; this . itemView = itemView ; txv_comment = itemView . findViewById ( R . id . txv_comment_content ) ; txv_like = itemView . findViewById ( R . id . txv_like ) ; txv_info = itemView . findViewById ( R . id . txv_info ) ; txv_date = itemView . findViewById ( R . id . txv_date ) ; txv_reply_count = itemView . findViewById ( R . id . txv_reply_count ) ; txv_banned_type = itemView . findViewById ( R . id . txv_old_status ) ; imgv_banned_type = itemView . findViewById ( R . id . img_old_status ) ; imgv_cover_image = itemView . findViewById ( R . id . cover_image ) ; } } @ Override public void dialogMessage ( String title , String message ) { DialogUtil . dialogMessage ( context , title , message ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . SharedPreferences ; public class Config { public static final int SORT_RULER_DATE_DESC = <NUM_LIT> ; public static final int SORT_RULER_DATE_ASC = <NUM_LIT> ; public static final int SORT_RULER_LIKE_DESC = <NUM_LIT> ; public static final int SORT_RULER_REPLY_COUNT_DESC = <NUM_LIT> ; Context context ; public SharedPreferences sp_config ; public Config ( Context context ) { this . context = context ; sp_config = context . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; } public boolean getRecordeHistory ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setRecordeHistory ( boolean recordeHistory ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , recordeHistory ) . apply ( ) ; } public String getCookie ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public void setCookie ( String cookie ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , cookie ) . apply ( ) ; } public String getDeputyCookie ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public void setDeputyCookie ( String cookie ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , cookie ) . apply ( ) ; } public long getWaitTime ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTime ( long waitTime ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTime ) . apply ( ) ; } public long getWaitTimeByDanmakuSend ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTimeByDanmakuSend ( long waitTimeByDanmakuSend ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTimeByDanmakuSend ) . apply ( ) ; } public long getWaitTimeByHasPictures ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTimeByHasPictures ( long waitTimeByHasPictures ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTimeByHasPictures ) . apply ( ) ; } public boolean getEnableRecordeBannedComments ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setEnableRecordeBannedComments ( boolean autoRecorde ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , autoRecorde ) . apply ( ) ; } public boolean getRecordeHistoryIsEnable ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setSortRuler ( int sortRuler ) { sp_config . edit ( ) . putInt ( "<STR_LIT>" , sortRuler ) . apply ( ) ; } public int getSortRuler ( ) { return sp_config . getInt ( "<STR_LIT>" , SORT_RULER_DATE_DESC ) ; } public void setFilterRulerEnableNormal ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableNormal ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableShadowBan ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableShadowBan ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableDeleted ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableDelete ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableOther ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableOther ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public boolean getFilterRulerEnableType1 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType1 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType12 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType12 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public void setFilterRulerEnableType11 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType11 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType17 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType17 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public boolean get花里胡哨Enable ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void set花里胡哨Enable ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class PictureStorage { private static final Map < String , Bitmap > bitmapMap = new HashMap < > ( ) ; private static final LinkedList < String > bitmapLink = new LinkedList < > ( ) ; public synchronized static boolean save ( Context context , String url ) throws IOException { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( ! pictureFile . exists ( ) ) { OkHttpClient httpClient = OkHttpUtil . getHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( ! response . isSuccessful ( ) ) { return false ; } ResponseBody body = response . body ( ) ; OkHttpUtil . respNotNull ( body ) ; InputStream inputStream = body . byteStream ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( pictureFile ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) != - <NUM_LIT> ) { fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; } fileOutputStream . close ( ) ; } return true ; } public synchronized static void save ( Context context , InputStream inputStream , String name ) throws IOException { byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileOutputStream fos = new FileOutputStream ( new File ( getPicturesDir ( context ) , name ) ) ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } fos . close ( ) ; } public synchronized static Bitmap getBitMap ( String url ) { Bitmap bitmap = bitmapMap . get ( url ) ; if ( bitmap != null ) { bitmapLink . remove ( url ) ; bitmapLink . addFirst ( url ) ; } return bitmap ; } public synchronized static boolean loadImage ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { FileInputStream fileInputStream = null ; try { fileInputStream = new FileInputStream ( pictureFile ) ; } catch ( FileNotFoundException e ) { return false ; } bitmapMap . put ( url , BitmapFactory . decodeStream ( fileInputStream ) ) ; bitmapLink . addFirst ( url ) ; if ( bitmapLink . size ( ) > <NUM_LIT> ) { bitmapMap . remove ( bitmapLink . getLast ( ) ) ; bitmapLink . removeLast ( ) ; } return true ; } else { return false ; } } public synchronized static void delete ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { pictureFile . delete ( ) ; } } public static File getPictureFile ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { return pictureFile ; } return null ; } public static File getPicturesDir ( Context context ) { return context . getExternalFilesDir ( "<STR_LIT>" ) ; } private static String getPicFileNameFromUrl ( String url ) { String [ ] split = url . split ( "<STR_LIT>" ) ; return split [ split . length - <NUM_LIT> ] ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . annotation . JSONField ; import org . jetbrains . annotations . Nullable ; import kotlin . jvm . JvmField ; public abstract class BaseResponse { @ JvmField public int code ; @ JvmField @ Nullable public String message ; @ JvmField public int ttl ; @ JSONField ( deserialize = false , serialize = false ) public boolean isSuccess ( ) { return this . code == <NUM_LIT> ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + code + "<STR_LIT>" + message + '<STR_LIT>' + "<STR_LIT>" + ttl + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class ForwardDynamicResult { public long dyn_id ; public String dyn_id_str ; public int dyn_type ; public long dyn_rid ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . DialogInterface ; public class VoidDialogInterfaceOnClickListener implements DialogInterface . OnClickListener { @ Override public void onClick ( DialogInterface dialog , int which ) { } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHook extends BaseHook { AtomicReference < Context > currentContext ; AtomicReference < String > currentOid ; AtomicReference < String > currentDynId ; AtomicReference < String > currentAreaType ; AtomicReference < String > currentComment ; AtomicReference < String > currentPictures ; public PostCommentHook ( ) { currentContext = new AtomicReference < > ( ) ; currentOid = new AtomicReference < > ( ) ; currentDynId = new AtomicReference < > ( ) ; currentAreaType = new AtomicReference < > ( ) ; currentComment = new AtomicReference < > ( ) ; currentPictures = new AtomicReference < > ( ) ; } @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { try { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( "<STR_LIT>" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( "<STR_LIT>" ) ; XposedBridge . log ( "<STR_LIT>" + fragment_args . getString ( "<STR_LIT>" ) ) ; currentDynId . set ( fragment_args . getString ( "<STR_LIT>" ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } catch ( XposedHelpers . ClassNotFoundError e ) { XposedBridge . log ( "<STR_LIT>" ) ; } XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( "<STR_LIT>" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , java . lang . Class . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object result = param . getResult ( ) ; if ( result != null ) { Class < ? > resultClass = result . getClass ( ) ; for ( Class < ? > classInterface : resultClass . getInterfaces ( ) ) { if ( classInterface . getCanonicalName ( ) . equals ( "<STR_LIT>" ) ) { XposedHelpers . findAndHookMethod ( resultClass , "<STR_LIT>" , java . util . Map . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Map < String , String > arrayMap = ( Map < String , String > ) param . args [ <NUM_LIT> ] ; currentComment . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentOid . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentAreaType . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentPictures . set ( arrayMap . get ( "<STR_LIT>" ) ) ; } } ) ; } } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; Object body = XposedHelpers . callMethod ( arg , "<STR_LIT>" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( "<STR_LIT>" ) ) { Object data = XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ; if ( data != null && data . getClass ( ) . getCanonicalName ( ) . equals ( "<STR_LIT>" ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , "<STR_LIT>" ) ; Object content = XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( "<STR_LIT>" , ( String ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( oid ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( type ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( content , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( "<STR_LIT>" , Utils . getBvidFormAvid ( oid ) ) ; } try { Field picturesField = content . getClass ( ) . getField ( "<STR_LIT>" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( "<STR_LIT>" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( "<STR_LIT>" ) ; } long ctime = XposedHelpers . getLongField ( reply , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , ctime ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } else if ( XposedHelpers . getIntField ( body , "<STR_LIT>" ) == CommentAddResult . CODE_CONTAIN_SENSITIVE ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) ; intent . putExtra ( "<STR_LIT>" , currentOid . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , currentComment . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , currentAreaType . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . drawable . Drawable ; import android . widget . ImageView ; import androidx . appcompat . content . res . AppCompatResources ; import java . io . IOException ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class PictureLoader { private final Context context ; private String url ; private PictureLoader ( Context context ) { this . context = context ; } public static PictureLoader with ( Context context ) { return new PictureLoader ( context ) ; } public PictureLoader load ( String url ) { this . url = url ; return this ; } public PictureLoader into ( ImageView imageView ) { Bitmap bitmap = PictureStorage . getBitMap ( url ) ; if ( bitmap != null ) { imageView . setImageBitmap ( bitmap ) ; return this ; } TaskManger . start ( ( ) -> { boolean loaded = PictureStorage . loadImage ( context , url ) ; if ( loaded ) { setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; return ; } try { if ( PictureStorage . save ( context , url ) ) { PictureStorage . loadImage ( context , url ) ; setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; } else { setFailed ( imageView ) ; } } catch ( IOException e ) { setFailed ( imageView ) ; } } ) ; return this ; } private static void setBitMap ( ImageView imageView , Bitmap bitmap ) { TaskManger . postOnUiThread ( ( ) -> imageView . setImageBitmap ( bitmap ) ) ; } private void setFailed ( ImageView imageView ) { TaskManger . postOnUiThread ( ( ) -> { Drawable drawable = AppCompatResources . getDrawable ( context , R . drawable . picture_failed ) ; imageView . setImageDrawable ( drawable ) ; } ) ; } } </s>
<s> package icu . freedomIntrovert . async ; public class EventMessage { private final int what ; private final Object [ ] objects ; public EventMessage ( Object [ ] objects , int what ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what , Object ... objects ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what ) { this . what = what ; this . objects = new Object [ <NUM_LIT> ] ; } public < T > T getObject ( int index , Class < T > clazz ) { return clazz . cast ( objects [ index ] ) ; } public int getWhat ( ) { return what ; } public Object [ ] getObjects ( ) { return objects ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class MartialLawCommentArea extends CommentArea { public static final String DISPOSAL_METHOD_SHADOW_BAN = "<STR_LIT>" ; public static final String DISPOSAL_METHOD_QUICK_DELETE = "<STR_LIT>" ; public String title , defaultDisposalMethod , up ; public byte [ ] coverImageData ; public MartialLawCommentArea ( CommentArea commentArea , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { this ( String . valueOf ( commentArea . oid ) , commentArea . sourceId , commentArea . type , defaultDisposalMethod , title , up , coverImageData ) ; } public MartialLawCommentArea ( String oid , String sourceId , int areaType , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { super ( Long . parseLong ( oid ) , sourceId , areaType ) ; this . up = up ; this . title = title ; this . defaultDisposalMethod = defaultDisposalMethod ; this . coverImageData = coverImageData ; } public String [ ] toStringArrays ( ) { return new String [ ] { String . valueOf ( oid ) , sourceId , String . valueOf ( type ) , defaultDisposalMethod , title , up , null } ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oid + '<STR_LIT>' + "<STR_LIT>" + sourceId + '<STR_LIT>' + "<STR_LIT>" + type + "<STR_LIT>" + title + '<STR_LIT>' + "<STR_LIT>" + defaultDisposalMethod + '<STR_LIT>' + "<STR_LIT>" + up + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class GeneralResponse < T > extends BaseResponse { public T data ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class CommentArea { public static final String AREA_VIDEO = "<STR_LIT>" ; public static final String AREA_ARTICLE = "<STR_LIT>" ; public static final String AREA_DYNAMIC = "<STR_LIT>" ; public static final int AREA_TYPE_VIDEO = <NUM_LIT> ; public static final int AREA_TYPE_ARTICLE = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC11 = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC17 = <NUM_LIT> ; public long oid ; public String sourceId ; public int type ; public CommentArea ( long oid , String sourceId , int type ) { this . oid = oid ; this . sourceId = sourceId ; this . type = type ; } public String getAreaTypeDesc ( ) { switch ( type ) { case CommentArea . AREA_TYPE_VIDEO : return "<STR_LIT>" + type + "<STR_LIT>" ; case CommentArea . AREA_TYPE_ARTICLE : return "<STR_LIT>" + type + "<STR_LIT>" ; case CommentArea . AREA_TYPE_DYNAMIC11 : case CommentArea . AREA_TYPE_DYNAMIC17 : return "<STR_LIT>" + type + "<STR_LIT>" ; default : return String . valueOf ( type ) ; } } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oid + '<STR_LIT>' + "<STR_LIT>" + sourceId + '<STR_LIT>' + "<STR_LIT>" + type + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Log ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; public class StatisticsDBOpenHelper extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public static final String ORDER_BY_DATE_DESC = "<STR_LIT>" ; public static final String ORDER_BY_DATE_ASC = "<STR_LIT>" ; public static final String ORDER_BY_LIKE_DESC = "<STR_LIT>" ; public static final String ORDER_BY_REPLY_COUNT_DESC = "<STR_LIT>" ; public static final String DB_NAME = "<STR_LIT>" ; public static final String TABLE_NAME_MARTIAL_LAW_AREA = "<STR_LIT>" ; public static final String TABLE_NAME_HISTORY_COMMENT = "<STR_LIT>" ; long count = <NUM_LIT> ; public StatisticsDBOpenHelper ( Context context ) { super ( context , DB_NAME , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { switch ( oldVersion ) { case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; } } public long insertMartialLawCommentArea ( MartialLawCommentArea area ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , area . oid ) ; values . put ( "<STR_LIT>" , area . sourceId ) ; values . put ( "<STR_LIT>" , area . type ) ; values . put ( "<STR_LIT>" , area . defaultDisposalMethod ) ; values . put ( "<STR_LIT>" , area . title ) ; values . put ( "<STR_LIT>" , area . up ) ; values . put ( "<STR_LIT>" , area . coverImageData ) ; return db . insert ( TABLE_NAME_MARTIAL_LAW_AREA , null , values ) ; } public long deleteMartialLawCommentArea ( long oid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_MARTIAL_LAW_AREA , "<STR_LIT>" , new String [ ] { String . valueOf ( oid ) } ) ; } public ArrayList < MartialLawCommentArea > queryMartialLawCommentAreas ( ) { ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList = new ArrayList < > ( ) ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA , null ) ; while ( cursor . moveToNext ( ) ) { martialLawCommentAreaArrayList . add ( new MartialLawCommentArea ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getInt ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , null ) ) ; } cursor . close ( ) ; return martialLawCommentAreaArrayList ; } public byte [ ] selectMartialLawCommentAreaCoverImage ( long oid ) { byte [ ] imageData = null ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA + "<STR_LIT>" , new String [ ] { String . valueOf ( oid ) } ) ; if ( cursor . moveToNext ( ) ) { imageData = cursor . getBlob ( <NUM_LIT> ) ; } cursor . close ( ) ; return imageData ; } public int updateCheckedArea ( long rpid , int areaChecked ) { SQLiteDatabase db = getReadableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , areaChecked ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , values , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public List < HistoryComment > getDemoHistoryComments ( ) { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; CommentArea commentArea = new CommentArea ( <NUM_LIT> , "<STR_LIT>" , CommentArea . AREA_TYPE_VIDEO ) ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , "<STR_LIT>" , null ) ) ; count ++ ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SHADOW_BAN ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_DELETED ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SENSITIVE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_INVISIBLE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNDER_REVIEW ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNKNOWN ) ) ; return historyCommentList ; } private HistoryComment newDemoComment ( String state ) { CommentArea commentArea = new CommentArea ( <NUM_LIT> , "<STR_LIT>" , CommentArea . AREA_TYPE_VIDEO ) ; HistoryComment historyComment = new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , state , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , state , null , null ) ; count ++ ; return historyComment ; } public List < HistoryComment > queryAllHistoryComments ( String dateOrderBy ) { return selectHistoryComments ( "<STR_LIT>" + dateOrderBy ) ; } public List < HistoryComment > queryHistoryCommentsByDateGT ( long timestamp ) { return selectHistoryComments ( "<STR_LIT>" + timestamp + "<STR_LIT>" ) ; } public List < HistoryComment > queryHistoryCommentsCountLimit ( int limit ) { return selectHistoryComments ( "<STR_LIT>" + limit ) ; } private List < HistoryComment > selectHistoryComments ( String selectAddition ) { SQLiteDatabase db = getReadableDatabase ( ) ; List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( "<STR_LIT>" + TABLE_NAME_HISTORY_COMMENT + "<STR_LIT>" + selectAddition , null ) ) ; while ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , JSON . parseObject ( cursor . getString ( "<STR_LIT>" ) , SensitiveScanResult . class ) ) ; historyCommentList . add ( historyComment ) ; } cursor . close ( ) ; return historyCommentList ; } public long insertHistoryComment ( HistoryComment historyComment ) { deletePendingCheckComment ( historyComment . rpid ) ; SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , historyComment . rpid ) ; cv . put ( "<STR_LIT>" , historyComment . parent ) ; cv . put ( "<STR_LIT>" , historyComment . root ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . oid ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . type ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . sourceId ) ; cv . put ( "<STR_LIT>" , historyComment . comment ) ; cv . put ( "<STR_LIT>" , historyComment . like ) ; cv . put ( "<STR_LIT>" , historyComment . replyCount ) ; cv . put ( "<STR_LIT>" , historyComment . lastState ) ; cv . put ( "<STR_LIT>" , historyComment . lastCheckDate . getTime ( ) ) ; cv . put ( "<STR_LIT>" , historyComment . date . getTime ( ) ) ; cv . put ( "<STR_LIT>" , historyComment . checkedArea ) ; cv . put ( "<STR_LIT>" , historyComment . firstState ) ; cv . put ( "<STR_LIT>" , historyComment . pictures ) ; if ( historyComment . sensitiveScanResult != null ) { cv . put ( "<STR_LIT>" , JSON . toJSONString ( historyComment . sensitiveScanResult ) ) ; } return db . insert ( TABLE_NAME_HISTORY_COMMENT , null , cv ) ; } public int updateHistoryCommentLastState ( long rpid , String state ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , state ) ; cv . put ( "<STR_LIT>" , System . currentTimeMillis ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int updateHistoryCommentStates ( long rpid , String state , int like , int replyCount , Date last_check_date ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , state ) ; cv . put ( "<STR_LIT>" , like ) ; cv . put ( "<STR_LIT>" , replyCount ) ; cv . put ( "<STR_LIT>" , last_check_date . getTime ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int deleteHistoryComment ( long rpid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_HISTORY_COMMENT , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public HistoryComment getHistoryComment ( long rpid ) { SQLiteDatabase db = getReadableDatabase ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( "<STR_LIT>" + TABLE_NAME_HISTORY_COMMENT + "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ) ; if ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , JSON . parseObject ( cursor . getString ( "<STR_LIT>" ) , SensitiveScanResult . class ) ) ; cursor . close ( ) ; return historyComment ; } else { cursor . close ( ) ; return null ; } } public void insertPendingCheckComment ( Comment comment ) { ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , comment . rpid ) ; values . put ( "<STR_LIT>" , comment . parent ) ; values . put ( "<STR_LIT>" , comment . root ) ; values . put ( "<STR_LIT>" , comment . comment ) ; values . put ( "<STR_LIT>" , comment . pictures ) ; values . put ( "<STR_LIT>" , comment . date . getTime ( ) ) ; values . put ( "<STR_LIT>" , comment . commentArea . oid ) ; values . put ( "<STR_LIT>" , comment . commentArea . sourceId ) ; values . put ( "<STR_LIT>" , comment . commentArea . type ) ; long newRowId = getWritableDatabase ( ) . insert ( "<STR_LIT>" , null , values ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + newRowId ) ; } public List < Comment > getAllPendingCheckComments ( ) { String [ ] projection = { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; Cursor cursor = getReadableDatabase ( ) . query ( "<STR_LIT>" , projection , null , null , null , null , "<STR_LIT>" ) ; List < Comment > commentList = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { long rpid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; Comment comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; commentList . add ( comment ) ; } cursor . close ( ) ; return commentList ; } public Comment getPendingCheckCommentByRpid ( long rpid ) { String [ ] projection = { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = { String . valueOf ( rpid ) } ; Cursor cursor = getReadableDatabase ( ) . query ( "<STR_LIT>" , projection , selection , selectionArgs , null , null , null ) ; Comment comment = null ; if ( cursor . moveToFirst ( ) ) { long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; } cursor . close ( ) ; return comment ; } public void deletePendingCheckComment ( long rpid ) { getWritableDatabase ( ) . delete ( "<STR_LIT>" , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public void addSensitiveScanResultToHistoryComment ( long rpid , SensitiveScanResult result ) { ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , JSON . toJSONString ( result ) ) ; getWritableDatabase ( ) . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public Map < String , String > countingStatus ( ) { Map < String , String > map = new HashMap < > ( ) ; Cursor cursor = getReadableDatabase ( ) . rawQuery ( "<STR_LIT>" , null ) ; while ( cursor . moveToNext ( ) ) { map . put ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) ) ; } cursor . close ( ) ; return map ; } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . content . SharedPreferences ; import android . content . res . XResources ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . os . Build ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . WppXposed ; import com . wmods . wppenhacer . xposed . core . WppCore ; import de . robv . android . xposed . XposedBridge ; public class DesignUtils { private static SharedPreferences mPrefs ; @ SuppressLint ( "<STR_LIT>" ) public static Drawable getDrawable ( int id ) { return Utils . getApplication ( ) . getDrawable ( id ) ; } @ Nullable public static Drawable getDrawableByName ( String name ) { var id = Utils . getID ( name , "<STR_LIT>" ) ; if ( id == <NUM_LIT> ) return null ; return DesignUtils . getDrawable ( id ) ; } @ Nullable public static Drawable getIconByName ( String name , boolean isTheme ) { var id = Utils . getID ( name , "<STR_LIT>" ) ; if ( id == <NUM_LIT> ) return null ; var icon = DesignUtils . getDrawable ( id ) ; if ( isTheme && icon != null ) { return DesignUtils . coloredDrawable ( icon , isNightMode ( ) ? Color . WHITE : Color . BLACK ) ; } return icon ; } @ NonNull public static Drawable coloredDrawable ( Drawable drawable , int color ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { drawable . setColorFilter ( new BlendModeColorFilter ( color , BlendMode . SRC_ATOP ) ) ; } else { drawable . setColorFilter ( color , PorterDuff . Mode . SRC_ATOP ) ; } return drawable ; } @ SuppressLint ( "<STR_LIT>" ) public static Drawable alphaDrawable ( Drawable drawable , int primaryTextColor , int i ) { Drawable coloredDrawable = DesignUtils . coloredDrawable ( drawable , primaryTextColor ) ; coloredDrawable . setAlpha ( i ) ; return coloredDrawable ; } @ NonNull public static Drawable createDrawable ( String type , int color ) { switch ( type ) { case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; var shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable selectorBg = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; selectorBg . getPaint ( ) . setColor ( color ) ; return selectorBg ; } case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case "<STR_LIT>" -> { float radius = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] outerRadii = new float [ ] { radius , radius , radius , radius , radius , radius , radius , radius } ; RoundRectShape roundRectShape = new RoundRectShape ( outerRadii , null , null ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( roundRectShape ) ; Paint paint = shapeDrawable . getPaint ( ) ; paint . setColor ( Color . TRANSPARENT ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( Utils . dipToPixels ( <NUM_LIT> ) ) ; paint . setColor ( color ) ; int inset = Utils . dipToPixels ( <NUM_LIT> ) ; return new InsetDrawable ( shapeDrawable , inset , inset , inset , inset ) ; } } return new ColorDrawable ( Color . BLACK ) ; } public static int getPrimaryTextColor ( ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } public static int getUnSeenColor ( ) { var primaryColor = mPrefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; if ( primaryColor == <NUM_LIT> || ! mPrefs . getBoolean ( "<STR_LIT>" , false ) ) { return <NUM_LIT> ; } return primaryColor ; } public static int getPrimarySurfaceColor ( ) { var backgroundColor = mPrefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; if ( backgroundColor == <NUM_LIT> || ! mPrefs . getBoolean ( "<STR_LIT>" , false ) ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } return backgroundColor ; } public static void setReplacementDrawable ( String name , Drawable replacement ) { if ( WppXposed . ResParam == null ) return ; WppXposed . ResParam . res . setReplacement ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" , name , new XResources . DrawableLoader ( ) { @ Override public Drawable newDrawable ( XResources res , int id ) throws Throwable { return replacement ; } } ) ; } public static boolean isNightMode ( ) { return WppCore . getDefaultTheme ( ) == - <NUM_LIT> ? isNightModeBySystem ( ) : WppCore . getDefaultTheme ( ) == <NUM_LIT> ; } public static boolean isNightModeBySystem ( ) { return ( Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . uiMode & <NUM_LIT> ) == <NUM_LIT> ; } public static void setPrefs ( SharedPreferences mPrefs ) { DesignUtils . mPrefs = mPrefs ; } public static boolean isValidColor ( String primaryColor ) { try { Color . parseColor ( primaryColor ) ; return true ; } catch ( Exception e ) { return false ; } } public static String checkSystemColor ( String color ) { if ( DesignUtils . isValidColor ( color ) ) { return color ; } try { if ( color . startsWith ( "<STR_LIT>" ) ) { var idColor = color . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; var colorRes = android . R . color . class . getField ( idColor ) . getInt ( null ) ; if ( colorRes != - <NUM_LIT> ) { return "<STR_LIT>" + Integer . toHexString ( ContextCompat . getColor ( Utils . getApplication ( ) , colorRes ) ) ; } } } catch ( Exception e ) { XposedBridge . log ( "<STR_LIT>" + e ) ; } return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . utils . ColorReplacement . replaceColors ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static de . robv . android . xposed . XposedHelpers . findAndHookConstructor ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . Manifest ; import android . app . Activity ; import android . app . Notification ; import android . content . pm . PackageManager ; import android . content . res . ColorStateList ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . utils . IColors ; import com . wmods . wppenhacer . views . WallpaperView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . xmlpull . v1 . XmlPullParser ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CustomTheme extends Feature { public static ClassLoader loader1 ; private HashMap < String , String > wallAlpha ; private HashMap < String , String > navAlpha ; private HashMap < String , String > toolbarAlpha ; private Properties properties ; public CustomTheme ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; loader1 = loader ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; hookColors ( ) ; hookWallpaper ( ) ; } private void hookWallpaper ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) && ! Objects . equals ( properties . getProperty ( "<STR_LIT>" ) , "<STR_LIT>" ) ) return ; var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedHelpers . findAndHookMethod ( clazz . getSuperclass ( ) , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_MEDIA_IMAGES ) == PackageManager . PERMISSION_GRANTED || ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { injectWallpaper ( activity . findViewById ( android . R . id . content ) ) ; } } } ) ; var hookFragmentView = Unobfuscator . loadFragmentViewMethod ( classLoader ) ; XposedBridge . hookMethod ( hookFragmentView , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( ViewGroup ) param . getResult ( ) ; replaceColors ( viewGroup , wallAlpha ) ; } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; XposedHelpers . findAndHookMethod ( FrameLayout . class , "<STR_LIT>" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; var viewGroup = ( ViewGroup ) param . thisObject ; var background = viewGroup . getBackground ( ) ; try { var colorfilters = XposedHelpers . getObjectField ( background , "<STR_LIT>" ) ; var fields = ReflectionUtils . getFieldsByType ( colorfilters . getClass ( ) , ColorStateList . class ) ; var colorStateList = ( ColorStateList ) fields . get ( <NUM_LIT> ) . get ( colorfilters ) ; if ( colorStateList == null ) return ; var color = IColors . toString ( colorStateList . getDefaultColor ( ) ) ; var newColor = navAlpha . get ( color ) ; if ( newColor != null ) { background . setTint ( IColors . parseColor ( newColor ) ) ; } } catch ( Throwable ignored ) { } } } ) ; var customWallpaper = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( customWallpaper || properties . containsKey ( "<STR_LIT>" ) ) { wallAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlpha = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( wallAlpha , ( <NUM_LIT> - wallpaperAlpha ) / <NUM_LIT> ) ; navAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlphaNav = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( navAlpha , ( <NUM_LIT> - wallpaperAlphaNav ) / <NUM_LIT> ) ; toolbarAlpha = new HashMap < > ( IColors . colors ) ; var colorOrig = "<STR_LIT>" ; var color = toolbarAlpha . get ( colorOrig ) ; if ( Objects . equals ( colorOrig , color ) ) toolbarAlpha . put ( colorOrig , "<STR_LIT>" ) ; var wallpaperToolbarAlpha = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( toolbarAlpha , ( <NUM_LIT> - wallpaperToolbarAlpha ) / <NUM_LIT> ) ; } } private void hookColors ( ) throws Exception { var customDrawable1 = Unobfuscator . loadExpandableWidgetClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable1 . getName ( ) ) ; var customDrawable2 = Unobfuscator . loadMaterialShapeDrawableClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable2 . getName ( ) ) ; var customDrawable3 = Unobfuscator . loadCustomDrawableClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable3 . getName ( ) ) ; var primaryColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var secondaryColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var backgroundColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var primaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var secondaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var backgroundColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { primaryColor = primaryColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( primaryColorInt ) ; secondaryColor = secondaryColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( secondaryColorInt ) ; backgroundColor = backgroundColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( backgroundColorInt ) ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) || Objects . equals ( properties . getProperty ( "<STR_LIT>" ) , "<STR_LIT>" ) ) { for ( var c : IColors . colors . keySet ( ) ) { if ( ! primaryColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( primaryColor ) ) { primaryColor = primaryColor . length ( ) == <NUM_LIT> ? primaryColor : "<STR_LIT>" + primaryColor . substring ( <NUM_LIT> ) ; switch ( c ) { case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , primaryColor . substring ( <NUM_LIT> ) ) ; case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , primaryColor ) ; case "<STR_LIT>" -> IColors . colors . put ( c , "<STR_LIT>" + primaryColor . substring ( <NUM_LIT> ) ) ; } } if ( ! backgroundColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( backgroundColor ) ) { backgroundColor = backgroundColor . length ( ) == <NUM_LIT> ? backgroundColor : "<STR_LIT>" + backgroundColor . substring ( <NUM_LIT> ) ; switch ( c ) { case "<STR_LIT>" -> IColors . colors . put ( c , backgroundColor . substring ( <NUM_LIT> ) ) ; case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , backgroundColor ) ; } } if ( ! secondaryColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( secondaryColor ) ) { secondaryColor = secondaryColor . length ( ) == <NUM_LIT> ? secondaryColor : "<STR_LIT>" + secondaryColor . substring ( <NUM_LIT> ) ; if ( c . equals ( "<STR_LIT>" ) ) { IColors . colors . put ( c , secondaryColor ) ; } } } } findAndHookMethod ( Activity . class . getName ( ) , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; var colors = IColors . colors ; var activity = ( Activity ) param . thisObject ; var view = activity . findViewById ( android . R . id . content ) . getRootView ( ) ; replaceColors ( view , colors ) ; } } ) ; var intBgHook = new IntBgColorHook ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { findAndHookConstructor ( BlendModeColorFilter . class , int . class , BlendMode . class , intBgHook ) ; } findAndHookConstructor ( PorterDuffColorFilter . class , int . class , PorterDuff . Mode . class , intBgHook ) ; findAndHookMethod ( TextView . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Paint . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( GradientDrawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( ColorDrawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Notification . Builder . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; var colorStateListHook = new ColorStateListHook ( ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( customDrawable3 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; var inflaterHook = ( XC_MethodHook ) new LayoutInflaterHook ( ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , XmlPullParser . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , XmlPullParser . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var drawable = ( Drawable ) param . args [ <NUM_LIT> ] ; replaceColor ( drawable , colors ) ; } } ) ; } private void replaceTransparency ( HashMap < String , String > wallpaperColors , float mAlpha ) { var hexAlpha = Integer . toHexString ( ( int ) Math . ceil ( mAlpha * <NUM_LIT> ) ) ; hexAlpha = hexAlpha . length ( ) == <NUM_LIT> ? "<STR_LIT>" + hexAlpha : hexAlpha ; for ( var c : List . of ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) { var oldColor = wallpaperColors . get ( c ) ; if ( oldColor == null ) continue ; var newColor = "<STR_LIT>" + hexAlpha + oldColor . substring ( <NUM_LIT> ) ; wallpaperColors . put ( c , newColor ) ; wallpaperColors . put ( oldColor , newColor ) ; } } private void injectWallpaper ( View view ) { var content = ( ViewGroup ) view ; var rootView = ( ViewGroup ) content . getChildAt ( <NUM_LIT> ) ; var header = ( ViewGroup ) rootView . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; replaceColors ( header , toolbarAlpha ) ; var frameLayout = new WallpaperView ( rootView . getContext ( ) , prefs , properties ) ; rootView . addView ( frameLayout , <NUM_LIT> ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static class LayoutInflaterHook extends XC_MethodHook { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var view = ( View ) param . getResult ( ) ; if ( view == null ) return ; replaceColors ( view , colors ) ; } } public static class ColorStateListHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var colorStateList = param . args [ <NUM_LIT> ] ; if ( colorStateList != null ) { var mColors = ( int [ ] ) XposedHelpers . getObjectField ( colorStateList , "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < mColors . length ; i ++ ) { var sColor = IColors . toString ( mColors [ i ] ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { mColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { mColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } XposedHelpers . setObjectField ( colorStateList , "<STR_LIT>" , mColors ) ; param . args [ <NUM_LIT> ] = colorStateList ; } } } public static class IntBgColorHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var color = ( int ) param . args [ <NUM_LIT> ] ; var sColor = IColors . toString ( color ) ; if ( param . thisObject instanceof TextView textView ) { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( textView . getId ( ) == id ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( "<STR_LIT>" + sColor . substring ( sColor . length ( ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) ) ; return ; } } var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } } } </s>
<s> package com . wmods . wppenhacer . xposed . core . db ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XposedBridge ; public class MessageStore { private static MessageStore mInstance ; private SQLiteDatabase sqLiteDatabase ; private MessageStore ( ) { var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var dbFile = new File ( dataDir , "<STR_LIT>" ) ; if ( ! dbFile . exists ( ) ) return ; sqLiteDatabase = SQLiteDatabase . openDatabase ( dbFile . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READWRITE ) ; } public static MessageStore getInstance ( ) { synchronized ( MessageStore . class ) { if ( mInstance == null || mInstance . sqLiteDatabase == null || ! mInstance . sqLiteDatabase . isOpen ( ) ) { mInstance = new MessageStore ( ) ; } } return mInstance ; } public String getMessageById ( long id ) { if ( sqLiteDatabase == null ) return "<STR_LIT>" ; String message = "<STR_LIT>" ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = new String [ ] { String . valueOf ( id ) } ; cursor = sqLiteDatabase . query ( "<STR_LIT>" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return message ; } public String getOriginalMessageKey ( long id ) { if ( sqLiteDatabase == null ) return "<STR_LIT>" ; String message = "<STR_LIT>" ; try ( Cursor cursor = sqLiteDatabase . rawQuery ( "<STR_LIT>" + id + "<STR_LIT>" , null ) ) { if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( <NUM_LIT> ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } return message ; } public List < String > getAudioListByMessageList ( List < String > messageList ) { if ( sqLiteDatabase == null ) return new ArrayList < > ( ) ; List < String > list = new ArrayList < > ( ) ; Cursor cursor = null ; try { String sql = "<STR_LIT>" ; sql += String . join ( "<STR_LIT>" , messageList . stream ( ) . map ( m -> "<STR_LIT>" + m + "<STR_LIT>" ) . toArray ( String [ ] :: new ) ) ; sql += "<STR_LIT>" ; cursor = sqLiteDatabase . rawQuery ( sql , null ) ; if ( cursor . moveToFirst ( ) ) { do { int type = cursor . getInt ( <NUM_LIT> ) ; if ( type == <NUM_LIT> ) { list . add ( cursor . getString ( <NUM_LIT> ) ) ; } } while ( cursor . moveToNext ( ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return list ; } public synchronized void executeSQL ( String sql ) { try { if ( sqLiteDatabase == null ) return ; sqLiteDatabase . execSQL ( sql ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } public void storeMessageRead ( String messageId ) { if ( sqLiteDatabase == null ) return ; XposedBridge . log ( "<STR_LIT>" + messageId ) ; sqLiteDatabase . execSQL ( "<STR_LIT>" + messageId + "<STR_LIT>" ) ; } public boolean isReadMessageStatus ( String messageId ) { if ( sqLiteDatabase == null ) return false ; boolean result = false ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = new String [ ] { messageId } ; cursor = sqLiteDatabase . query ( "<STR_LIT>" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { result = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) == <NUM_LIT> ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return result ; } public SQLiteDatabase getDatabase ( ) { return sqLiteDatabase ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . app . Activity ; import android . app . Application ; import android . app . Instrumentation ; import android . content . BroadcastReceiver ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . components . SharedPreferencesWrapper ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . features . customization . BubbleColors ; import com . wmods . wppenhacer . xposed . features . customization . CustomTheme ; import com . wmods . wppenhacer . xposed . features . customization . CustomTime ; import com . wmods . wppenhacer . xposed . features . customization . CustomToolbar ; import com . wmods . wppenhacer . xposed . features . customization . CustomView ; import com . wmods . wppenhacer . xposed . features . customization . DotOnline ; import com . wmods . wppenhacer . xposed . features . customization . FilterGroups ; import com . wmods . wppenhacer . xposed . features . customization . HideTabs ; import com . wmods . wppenhacer . xposed . features . customization . IGStatus ; import com . wmods . wppenhacer . xposed . features . customization . SeparateGroup ; import com . wmods . wppenhacer . xposed . features . general . AntiRevoke ; import com . wmods . wppenhacer . xposed . features . general . CallType ; import com . wmods . wppenhacer . xposed . features . general . ChatLimit ; import com . wmods . wppenhacer . xposed . features . general . DeleteStatus ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . features . general . NewChat ; import com . wmods . wppenhacer . xposed . features . general . Others ; import com . wmods . wppenhacer . xposed . features . general . PinnedLimit ; import com . wmods . wppenhacer . xposed . features . general . SeenTick ; import com . wmods . wppenhacer . xposed . features . general . ShareLimit ; import com . wmods . wppenhacer . xposed . features . general . ShowEditMessage ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . features . media . DownloadProfile ; import com . wmods . wppenhacer . xposed . features . media . DownloadViewOnce ; import com . wmods . wppenhacer . xposed . features . media . MediaPreview ; import com . wmods . wppenhacer . xposed . features . media . MediaQuality ; import com . wmods . wppenhacer . xposed . features . media . StatusDownload ; import com . wmods . wppenhacer . xposed . features . others . Channels ; import com . wmods . wppenhacer . xposed . features . others . ChatFilters ; import com . wmods . wppenhacer . xposed . features . others . CopyStatus ; import com . wmods . wppenhacer . xposed . features . others . DebugFeature ; import com . wmods . wppenhacer . xposed . features . others . GroupAdmin ; import com . wmods . wppenhacer . xposed . features . others . Stickers ; import com . wmods . wppenhacer . xposed . features . others . TextStatusComposer ; import com . wmods . wppenhacer . xposed . features . others . ToastViewer ; import com . wmods . wppenhacer . xposed . features . privacy . CallPrivacy ; import com . wmods . wppenhacer . xposed . features . privacy . DndMode ; import com . wmods . wppenhacer . xposed . features . privacy . FreezeLastSeen ; import com . wmods . wppenhacer . xposed . features . privacy . GhostMode ; import com . wmods . wppenhacer . xposed . features . privacy . HideChat ; import com . wmods . wppenhacer . xposed . features . privacy . HideReceipt ; import com . wmods . wppenhacer . xposed . features . privacy . HideSeen ; import com . wmods . wppenhacer . xposed . features . privacy . HideTagForward ; import com . wmods . wppenhacer . xposed . features . privacy . ViewOnce ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FeatureLoader { public static Application mApp ; public final static String PACKAGE_WPP = "<STR_LIT>" ; public final static String PACKAGE_BUSINESS = "<STR_LIT>" ; private static final ArrayList < ErrorItem > list = new ArrayList < > ( ) ; private static List < String > supportedVersions ; private static String currentVersion ; public static void start ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , String sourceDir ) { if ( ! Unobfuscator . initDexKit ( sourceDir ) ) { XposedBridge . log ( "<STR_LIT>" ) ; return ; } Feature . DEBUG = pref . getBoolean ( "<STR_LIT>" , true ) ; XposedHelpers . findAndHookMethod ( Instrumentation . class , "<STR_LIT>" , Application . class , new XC_MethodHook ( ) { @ SuppressWarnings ( "<STR_LIT>" ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mApp = ( Application ) param . args [ <NUM_LIT> ] ; PackageManager packageManager = mApp . getPackageManager ( ) ; pref . registerOnSharedPreferenceChangeListener ( ( sharedPreferences , s ) -> pref . reload ( ) ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) ; XposedBridge . log ( packageInfo . versionName ) ; currentVersion = packageInfo . versionName ; supportedVersions = Arrays . asList ( mApp . getResources ( ) . getStringArray ( Objects . equals ( mApp . getPackageName ( ) , FeatureLoader . PACKAGE_WPP ) ? ResId . array . supported_versions_wpp : ResId . array . supported_versions_business ) ) ; try { SharedPreferencesWrapper . hookInit ( mApp . getClassLoader ( ) ) ; UnobfuscatorCache . init ( mApp , pref ) ; WppCore . Initialize ( loader ) ; if ( supportedVersions . stream ( ) . noneMatch ( s -> packageInfo . versionName . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) && ! pref . getBoolean ( "<STR_LIT>" , false ) ) { throw new Exception ( "<STR_LIT>" + packageInfo . versionName ) ; } DesignUtils . setPrefs ( pref ) ; initComponents ( loader , pref ) ; plugins ( loader , pref , packageInfo . versionName ) ; registerReceivers ( ) ; mApp . registerActivityLifecycleCallbacks ( new WaCallback ( ) ) ; sendEnabledBroadcast ( mApp ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( "<STR_LIT>" ) ; error . setWhatsAppVersion ( packageInfo . versionName ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + "<STR_LIT>" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) && ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , loader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ! list . isEmpty ( ) ) { var activity = ( Activity ) param . thisObject ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . error_detected ) ) . setMessage ( activity . getString ( ResId . string . version_error ) + String . join ( "<STR_LIT>" , list . stream ( ) . map ( ErrorItem :: getPluginName ) . toArray ( String [ ] :: new ) ) + "<STR_LIT>" + currentVersion + "<STR_LIT>" + String . join ( "<STR_LIT>" , supportedVersions ) ) . setPositiveButton ( activity . getString ( ResId . string . copy_to_clipboard ) , ( dialog , which ) -> { var clipboard = ( ClipboardManager ) mApp . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , String . join ( "<STR_LIT>" , list . stream ( ) . map ( ErrorItem :: toString ) . toArray ( String [ ] :: new ) ) ) ; clipboard . setPrimaryClip ( clip ) ; Toast . makeText ( mApp , ResId . string . copied_to_clipboard , Toast . LENGTH_SHORT ) . show ( ) ; dialog . dismiss ( ) ; } ) . show ( ) ; } } } ) ; } private static void initComponents ( ClassLoader loader , XSharedPreferences pref ) throws Exception { AlertDialogWpp . initDialog ( loader ) ; FMessageWpp . init ( loader ) ; } private static void registerReceivers ( ) { BroadcastReceiver restartReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( context . getPackageName ( ) . equals ( intent . getStringExtra ( "<STR_LIT>" ) ) ) { var appName = context . getPackageManager ( ) . getApplicationLabel ( context . getApplicationInfo ( ) ) ; Toast . makeText ( context , context . getString ( ResId . string . rebooting ) + "<STR_LIT>" + appName + "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; if ( ! Utils . doRestart ( context ) ) Toast . makeText ( context , "<STR_LIT>" + appName , Toast . LENGTH_SHORT ) . show ( ) ; } } } ; ContextCompat . registerReceiver ( mApp , restartReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver wppReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { sendEnabledBroadcast ( context ) ; } } ; ContextCompat . registerReceiver ( mApp , wppReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver restartManualReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; } } ; ContextCompat . registerReceiver ( mApp , restartManualReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; } private static void sendEnabledBroadcast ( Context context ) { try { Intent wppIntent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; wppIntent . putExtra ( "<STR_LIT>" , context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) . versionName ) ; wppIntent . putExtra ( "<STR_LIT>" , context . getPackageName ( ) ) ; wppIntent . setPackage ( BuildConfig . APPLICATION_ID ) ; context . sendBroadcast ( wppIntent ) ; } catch ( Exception ignored ) { } } private static void plugins ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , @ NonNull String versionWpp ) { var classes = new Class < ? > [ ] { DebugFeature . class , MenuStatus . class , ShowEditMessage . class , AntiRevoke . class , CustomToolbar . class , CustomView . class , SeenTick . class , BubbleColors . class , CallPrivacy . class , CustomTheme . class , ChatLimit . class , SeparateGroup . class , DotOnline . class , DndMode . class , FreezeLastSeen . class , GhostMode . class , HideChat . class , HideReceipt . class , HideSeen . class , HideTagForward . class , HideTabs . class , IGStatus . class , MediaQuality . class , NewChat . class , Others . class , PinnedLimit . class , CustomTime . class , ShareLimit . class , StatusDownload . class , ViewOnce . class , CallType . class , MediaPreview . class , FilterGroups . class , Tasker . class , DeleteStatus . class , DownloadViewOnce . class , Channels . class , DownloadProfile . class , ChatFilters . class , GroupAdmin . class , Stickers . class , CopyStatus . class , TextStatusComposer . class , ToastViewer . class } ; for ( var classe : classes ) { try { var constructor = classe . getConstructor ( ClassLoader . class , XSharedPreferences . class ) ; var plugin = ( Feature ) constructor . newInstance ( loader , pref ) ; plugin . doHook ( ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( classe . getSimpleName ( ) ) ; error . setWhatsAppVersion ( versionWpp ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + "<STR_LIT>" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) && ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } private static class ErrorItem { private String pluginName ; private String whatsAppVersion ; private String error ; private String moduleVersion ; @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + getPluginName ( ) + '<STR_LIT>' + "<STR_LIT>" + getModuleVersion ( ) + '<STR_LIT>' + "<STR_LIT>" + getWhatsAppVersion ( ) + '<STR_LIT>' + "<STR_LIT>" + getError ( ) + '<STR_LIT>' ; } public String getWhatsAppVersion ( ) { return whatsAppVersion ; } public void setWhatsAppVersion ( String whatsAppVersion ) { this . whatsAppVersion = whatsAppVersion ; } public String getError ( ) { return error ; } public void setError ( String error ) { this . error = error ; } public String getPluginName ( ) { return pluginName ; } public void setPluginName ( String pluginName ) { this . pluginName = pluginName ; } public String getModuleVersion ( ) { return moduleVersion ; } public void setModuleVersion ( String moduleVersion ) { this . moduleVersion = moduleVersion ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . core . devkit ; import android . app . Application ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . content . res . Resources ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import java . util . stream . Collectors ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class UnobfuscatorCache { private final Application mApp ; private static UnobfuscatorCache mInstance ; private final SharedPreferences mShared ; private final Map < String , String > reverseResourceMap = new HashMap < > ( ) ; public UnobfuscatorCache ( Application app , XSharedPreferences shared ) { mApp = app ; try { mShared = mApp . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; long version = mShared . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; long currentVersion = mApp . getPackageManager ( ) . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) . getLongVersionCode ( ) ; long savedUpdateTime = mShared . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; long lastUpdateTime = shared . getLong ( "<STR_LIT>" , - <NUM_LIT> ) ; if ( version != currentVersion || savedUpdateTime != lastUpdateTime ) { mShared . edit ( ) . clear ( ) . commit ( ) ; mShared . edit ( ) . putLong ( "<STR_LIT>" , currentVersion ) . commit ( ) ; mShared . edit ( ) . putLong ( "<STR_LIT>" , lastUpdateTime ) . commit ( ) ; } initCacheStrings ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "<STR_LIT>" + e . getMessage ( ) , e ) ; } } private void initCacheStrings ( ) { getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; } public static UnobfuscatorCache getInstance ( ) { return mInstance ; } public static void init ( Application mApp , XSharedPreferences pref ) { mInstance = new UnobfuscatorCache ( mApp , pref ) ; } private void initializeReverseResourceMap ( ) { int numThreads = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ) ; try { var configuration = new Configuration ( mApp . getResources ( ) . getConfiguration ( ) ) ; configuration . setLocale ( Locale . ENGLISH ) ; var context = Utils . getApplication ( ) . createConfigurationContext ( configuration ) ; Resources resources = context . getResources ( ) ; int startId = <NUM_LIT> ; int endId = <NUM_LIT> ; int chunkSize = ( endId - startId + <NUM_LIT> ) / numThreads ; CountDownLatch latch = new CountDownLatch ( numThreads ) ; for ( int t = <NUM_LIT> ; t < numThreads ; t ++ ) { int threadStartId = startId + t * chunkSize ; int threadEndId = t == numThreads - <NUM_LIT> ? endId : threadStartId + chunkSize - <NUM_LIT> ; executor . submit ( ( ) -> { try { for ( int i = threadStartId ; i <= threadEndId ; i ++ ) { try { String resourceString = resources . getString ( i ) ; reverseResourceMap . put ( resourceString . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) , String . valueOf ( i ) ) ; } catch ( Resources . NotFoundException ignored ) { } } } finally { latch . countDown ( ) ; } } ) ; } latch . await ( ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { executor . shutdown ( ) ; } } private String getMapIdString ( String search ) { if ( reverseResourceMap . isEmpty ( ) ) { initializeReverseResourceMap ( ) ; } search = search . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; return reverseResourceMap . get ( search ) ; } public int getOfuscateIDString ( String search ) { search = search . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; var id = mShared . getString ( search , null ) ; if ( id == null ) { id = getMapIdString ( search ) ; if ( id != null ) { mShared . edit ( ) . putString ( search , id ) . commit ( ) ; } } return id == null ? - <NUM_LIT> : Integer . parseInt ( id ) ; } public String getString ( String search ) { var id = getOfuscateIDString ( search ) ; return id == - <NUM_LIT> ? "<STR_LIT>" : mApp . getResources ( ) . getString ( id ) ; } public Field getField ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Field result = ( Field ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveField ( methodName , result ) ; return result ; } String [ ] ClassAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( ClassAndName [ <NUM_LIT> ] , loader ) ; return XposedHelpers . findField ( cls , ClassAndName [ <NUM_LIT> ] ) ; } public Method getMethod ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Method result = ( Method ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveMethod ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( "<STR_LIT>" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] , paramTypes ) ; } return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] ) ; } public Class < ? > getClass ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Class < ? > result = ( Class < ? > ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveClass ( methodName , result ) ; return result ; } return XposedHelpers . findClass ( value , loader ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveField ( String key , Field field ) { String value = field . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + field . getName ( ) ; mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveMethod ( String key , Method method ) { String value = method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + method . getName ( ) ; if ( method . getParameterTypes ( ) . length > <NUM_LIT> ) { value += "<STR_LIT>" + Arrays . stream ( method . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveClass ( String message , Class < ? > messageClass ) { mShared . edit ( ) . putString ( message , messageClass . getName ( ) ) . commit ( ) ; } private String getKeyName ( ) { AtomicReference < String > keyName = new AtomicReference < > ( "<STR_LIT>" ) ; Arrays . stream ( Thread . currentThread ( ) . getStackTrace ( ) ) . filter ( stackTraceElement -> stackTraceElement . getClassName ( ) . equals ( Unobfuscator . class . getName ( ) ) ) . findFirst ( ) . ifPresent ( stackTraceElement -> keyName . set ( stackTraceElement . getMethodName ( ) ) ) ; return keyName . get ( ) ; } public Constructor getConstructor ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { var result = ( Constructor ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveConstructor ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( "<STR_LIT>" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findConstructorExact ( cls , paramTypes ) ; } return XposedHelpers . findConstructorExact ( cls ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void saveConstructor ( String key , Constructor constructor ) { String value = constructor . getDeclaringClass ( ) . getName ( ) ; if ( constructor . getParameterTypes ( ) . length > <NUM_LIT> ) { value += "<STR_LIT>" + Arrays . stream ( constructor . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } public interface FunctionCall { Object call ( ) throws Exception ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class FreezeLastSeen extends Feature { public FreezeLastSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) && ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! WppCore . getPrivBoolean ( "<STR_LIT>" , false ) && prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var method = Unobfuscator . loadFreezeSeenMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . downgrade ; import static de . robv . android . xposed . XposedBridge . hookAllMethods ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . os . Build ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . lang . reflect . Field ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class Patch { public static void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam , XSharedPreferences prefs ) throws Throwable { if ( ! ( "<STR_LIT>" . equals ( lpparam . packageName ) ) || ! ( lpparam . processName . equals ( "<STR_LIT>" ) ) ) return ; XC_MethodHook hookDowngrade = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( null ) ; } } ; XC_MethodHook hookDowngrade2 = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( true ) ; } } ; switch ( Build . VERSION . SDK_INT ) { case Build . VERSION_CODES . UPSIDE_DOWN_CAKE : findAndHookMethod ( "<STR_LIT>" , lpparam . classLoader , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , hookDowngrade ) ; break ; case Build . VERSION_CODES . TIRAMISU : var checkDowngrade = XposedHelpers . findMethodExactIfExists ( "<STR_LIT>" , lpparam . classLoader , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( checkDowngrade != null ) { XposedBridge . hookMethod ( checkDowngrade , hookDowngrade ) ; } break ; case Build . VERSION_CODES . S_V2 : case Build . VERSION_CODES . S : case Build . VERSION_CODES . R : var pmService = XposedHelpers . findClassIfExists ( "<STR_LIT>" , lpparam . classLoader ) ; if ( pmService != null ) { var checkDowngrade1 = XposedHelpers . findMethodExactIfExists ( pmService , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( checkDowngrade1 != null ) { XposedBridge . hookMethod ( checkDowngrade1 , hookDowngrade ) ; } var flymeCheckDowngrade = XposedHelpers . findMethodExactIfExists ( pmService , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( flymeCheckDowngrade != null ) XposedBridge . hookMethod ( flymeCheckDowngrade , hookDowngrade2 ) ; } break ; case Build . VERSION_CODES . Q : case Build . VERSION_CODES . P : Class < ? > packageClazz = XposedHelpers . findClass ( "<STR_LIT>" , lpparam . classLoader ) ; hookAllMethods ( XposedHelpers . findClass ( "<STR_LIT>" , lpparam . classLoader ) , "<STR_LIT>" , new XC_MethodHook ( ) { public void beforeHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object packageInfoLite = methodHookParam . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( packageInfoLite , "<STR_LIT>" ) ; if ( packageName == FeatureLoader . PACKAGE_WPP || packageName == FeatureLoader . PACKAGE_BUSINESS ) { Field field = packageClazz . getField ( "<STR_LIT>" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; field = packageClazz . getField ( "<STR_LIT>" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; } } } ) ; break ; default : XposedBridge . log ( "<STR_LIT>" + Build . VERSION . SDK_INT ) ; break ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; public class ResId { public static class drawable { public static int eye_disabled ; public static int eye_enabled ; public static int admin ; public static int preview_eye ; public static int ic_reload ; public static int refresh ; } public static class string { public static int edited_history ; public static int dnd_message ; public static int dnd_mode_title ; public static int freezelastseen_message ; public static int freezelastseen_title ; public static int activate ; public static int cancel ; public static int message_original ; public static int new_chat ; public static int number_with_country_code ; public static int message ; public static int download ; public static int error_when_saving_try_again ; public static int msg_text_status_not_downloadable ; public static int saved_to ; public static int restart_whatsapp ; public static int restart_wpp ; public static int send_blue_tick ; public static int sending_read_blue_tick ; public static int send ; public static int send_sticker ; public static int do_you_want_to_send_sticker ; public static int whatsapp_call ; public static int phone_call ; public static int yes ; public static int no ; public static int version_error ; public static int copy_to_clipboard ; public static int copied_to_clipboard ; public static int error_detected ; public static int rebooting ; public static int deleted_status ; public static int deleted_message ; public static int toast_online ; public static int message_removed_on ; public static int loading ; public static int delete_for_me ; public static int share_as_status ; public static int viewed_your_status ; public static int viewed_your_message ; public static int select_status_type ; public static int open_camera ; public static int edit_text ; public static int select_a_color ; public static int read_all_mark_as_read ; public static int grant_permission ; public static int expiration ; public static int deleted_a_message_in_group ; } public static class array { public static int supported_versions_wpp ; public static int supported_versions_business ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CustomTime extends Feature { public CustomTime ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var secondsToTime = prefs . getBoolean ( "<STR_LIT>" , false ) ; var ampm = prefs . getBoolean ( "<STR_LIT>" , false ) ; var secondsToTimeMethod = Unobfuscator . loadTimeToSecondsMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( secondsToTimeMethod ) ) ; XposedBridge . hookMethod ( secondsToTimeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var timestamp = ( long ) param . args [ <NUM_LIT> ] ; var date = new Date ( timestamp ) ; var patternDefault = "<STR_LIT>" ; var patternSeconds = "<STR_LIT>" ; if ( ampm ) { patternDefault = "<STR_LIT>" ; patternSeconds = "<STR_LIT>" ; } var pattern = secondsToTime ? patternSeconds : patternDefault ; var formattedDate = new SimpleDateFormat ( pattern , Locale . US ) . format ( date ) ; param . setResult ( getTextInHour ( formattedDate ) ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private String getTextInHour ( String date ) { var summary = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( summary == null ) return date ; else return date + "<STR_LIT>" + summary ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Stickers extends Feature { public Stickers ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var sendStickerMethod = Unobfuscator . loadSendStickerMethod ( classLoader ) ; XposedBridge . hookMethod ( sendStickerMethod , new XC_MethodHook ( ) { private Unhook unhooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { unhooked = XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , View . OnClickListener . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { View . OnClickListener mCaptureOnClickListener = ( View . OnClickListener ) param . args [ <NUM_LIT> ] ; if ( mCaptureOnClickListener == null ) return ; if ( ! ( param . thisObject instanceof ViewGroup ) ) return ; var view = ( View ) param . thisObject ; if ( view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) == null ) return ; param . args [ <NUM_LIT> ] = ( View . OnClickListener ) v -> { var context = view . getContext ( ) ; var dialog = new AlertDialogWpp ( view . getContext ( ) ) ; dialog . setTitle ( context . getString ( ResId . string . send_sticker ) ) ; var stickerView = ( ImageView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var padding = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( padding , padding , padding , padding ) ; var image = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; var params = new LinearLayout . LayoutParams ( size , size ) ; params . bottomMargin = padding ; image . setLayoutParams ( params ) ; image . setImageDrawable ( stickerView . getDrawable ( ) ) ; linearLayout . addView ( image ) ; TextView text = new TextView ( context ) ; text . setText ( context . getString ( ResId . string . do_you_want_to_send_sticker ) ) ; text . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; linearLayout . addView ( text ) ; dialog . setView ( linearLayout ) ; dialog . setPositiveButton ( context . getString ( ResId . string . send ) , ( dialog1 , which ) -> mCaptureOnClickListener . onClick ( view ) ) ; dialog . setNegativeButton ( context . getString ( ResId . string . cancel ) , null ) ; dialog . show ( ) ; } ; } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { unhooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . text . TextUtils ; import android . util . AttributeSet ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . RequiresApi ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . TextEditorActivity ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . nio . charset . Charset ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; import java . util . ArrayList ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import kotlin . io . FilesKt ; public class ThemePreference extends Preference implements FilePicker . OnUriPickedListener { public static File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; private androidx . appcompat . app . AlertDialog mainDialog ; public ThemePreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; setPersistent ( false ) ; } @ Override protected void onClick ( ) { super . onClick ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { if ( Environment . isExternalStorageManager ( ) ) { showThemeDialog ( ) ; } else { showAlertPermission ( ) ; } } else { showThemeDialog ( ) ; } } @ RequiresApi ( api = Build . VERSION_CODES . R ) private void showAlertPermission ( ) { MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( getContext ( ) ) ; builder . setTitle ( R . string . storage_permission ) ; builder . setMessage ( R . string . permission_storage ) ; builder . setPositiveButton ( R . string . allow , ( dialog , which ) -> { Intent intent = new Intent ( android . provider . Settings . ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setData ( Uri . fromParts ( "<STR_LIT>" , getContext ( ) . getPackageName ( ) , null ) ) ; getContext ( ) . startActivity ( intent ) ; } ) ; builder . setNegativeButton ( R . string . deny , ( dialog , which ) -> dialog . dismiss ( ) ) ; builder . show ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void showThemeDialog ( ) { final Context context = getContext ( ) ; List < String > folders = getFolders ( ) ; folders . add ( <NUM_LIT> , "<STR_LIT>" ) ; var folder_name = getSharedPreferences ( ) . getString ( getKey ( ) , null ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( context ) ; View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . preference_theme , null ) ; builder . setView ( dialogView ) ; LinearLayout folderListContainer = dialogView . findViewById ( R . id . folder_list_container ) ; Button newTheme = dialogView . findViewById ( R . id . create_theme_button ) ; newTheme . setOnClickListener ( v -> showCreateNewThemeDialog ( ) ) ; Button importTheme = dialogView . findViewById ( R . id . import_theme_button ) ; importTheme . setOnClickListener ( v -> { FilePicker . setOnUriPickedListener ( this ) ; FilePicker . fileCapture . launch ( new String [ ] { "<STR_LIT>" } ) ; } ) ; for ( String folder : folders ) { View itemView = LayoutInflater . from ( context ) . inflate ( R . layout . item_folder , null , false ) ; TextView folderNameView = itemView . findViewById ( R . id . folder_name ) ; folderNameView . setText ( folder ) ; if ( folder . equals ( folder_name ) ) { folderNameView . setTextColor ( ContextCompat . getColor ( context , R . color . md_theme_material_green_dark_onPrimaryContainer ) ) ; } itemView . setOnClickListener ( v -> { var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; sharedPreferences . edit ( ) . putString ( getKey ( ) , folder ) . commit ( ) ; var cssFile = new File ( rootDirectory , folder + "<STR_LIT>" ) ; if ( cssFile . exists ( ) ) { var code = FilesKt . readText ( cssFile , Charset . defaultCharset ( ) ) ; sharedPreferences . edit ( ) . putString ( "<STR_LIT>" , code ) . commit ( ) ; } else { sharedPreferences . edit ( ) . putString ( "<STR_LIT>" , "<STR_LIT>" ) . commit ( ) ; } mainDialog . dismiss ( ) ; } ) ; ImageButton editButton = itemView . findViewById ( R . id . edit_button ) ; if ( folder . equals ( "<STR_LIT>" ) ) { editButton . setVisibility ( View . INVISIBLE ) ; } else { editButton . setOnClickListener ( v -> { Intent intent = new Intent ( context , TextEditorActivity . class ) ; intent . putExtra ( "<STR_LIT>" , folder ) ; intent . putExtra ( "<STR_LIT>" , getKey ( ) ) ; ContextCompat . startActivity ( context , intent , null ) ; } ) ; } folderListContainer . addView ( itemView ) ; } mainDialog = builder . show ( ) ; } private List < String > getFolders ( ) { List < String > folderNames = new ArrayList < > ( ) ; File [ ] folders = rootDirectory . listFiles ( File :: isDirectory ) ; if ( folders != null ) { for ( File folder : folders ) { folderNames . add ( folder . getName ( ) ) ; } } return folderNames ; } private void showCreateNewThemeDialog ( ) { final Context context = getContext ( ) ; final EditText input = new EditText ( context ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . new_theme_name ) . setView ( input ) . setPositiveButton ( R . string . create , ( dialog , whichButton ) -> { String folderName = input . getText ( ) . toString ( ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { createNewFolder ( folderName ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . show ( ) ; } private void createNewFolder ( String folderName ) { File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) { if ( newFolder . mkdirs ( ) ) { mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } } } @ Override public void onUriPicked ( Uri uri ) { if ( uri == null ) return ; try ( var inputStream = getContext ( ) . getContentResolver ( ) . openInputStream ( uri ) ) { var zipInputStream = new ZipInputStream ( inputStream ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { Utils . showToast ( getContext ( ) . getString ( R . string . invalid_zip_file ) , <NUM_LIT> ) ; return ; } do { var name = zipEntry . getName ( ) ; if ( ! name . contains ( "<STR_LIT>" ) ) { continue ; } var folderName = name . substring ( <NUM_LIT> , name . lastIndexOf ( '<STR_LIT>' ) ) ; File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) newFolder . mkdirs ( ) ; var file = new File ( rootDirectory , name ) ; Files . copy ( zipInputStream , file . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; zipEntry = zipInputStream . getNextEntry ( ) ; } while ( zipEntry != null ) ; Utils . showToast ( getContext ( ) . getString ( R . string . theme_imported_successfully ) , <NUM_LIT> ) ; mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . view . ViewGroup ; import android . widget . AbsListView ; import android . widget . ListView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . adapter . IGStatusAdapter ; import com . wmods . wppenhacer . views . IGStatusView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatus extends Feature { public static ArrayList < Object > itens = new ArrayList < > ( ) ; private static final ArrayList < IGStatusView > mListStatusContainer = new ArrayList < > ( ) ; public IGStatus ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) || Utils . getApplication ( ) . getPackageName ( ) . equals ( "<STR_LIT>" ) ) return ; var getViewConversationMethod = Unobfuscator . loadGetViewConversationMethod ( classLoader ) ; XposedBridge . hookMethod ( getViewConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) . isInstance ( param . thisObject ) ) return ; if ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) . isInstance ( param . thisObject ) ) return ; var view = ( ViewGroup ) param . getResult ( ) ; if ( view == null ) return ; var mainView = ( ListView ) view . findViewById ( android . R . id . list ) ; mainView . setNestedScrollingEnabled ( true ) ; var mStatusContainer = new IGStatusView ( WppCore . getCurrentActivity ( ) ) ; var layoutParams = new AbsListView . LayoutParams ( AbsListView . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; mStatusContainer . setLayoutParams ( layoutParams ) ; mainView . addHeaderView ( mStatusContainer ) ; mListStatusContainer . add ( mStatusContainer ) ; } } ) ; var clazz2 = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var onUpdateStatusChanged = Unobfuscator . loadOnUpdateStatusChanged ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onUpdateStatusChanged ) ) ; var statusInfoClass = Unobfuscator . loadStatusInfoClass ( classLoader ) ; logDebug ( statusInfoClass ) ; XposedBridge . hookAllConstructors ( clazz2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { itens . add ( <NUM_LIT> , null ) ; for ( var mStatusContainer : mListStatusContainer ) { IGStatusAdapter mStatusAdapter = new IGStatusAdapter ( WppCore . getCurrentActivity ( ) , statusInfoClass ) ; mStatusContainer . setAdapter ( mStatusAdapter ) ; mStatusContainer . updateList ( ) ; } } } ) ; var onStatusListUpdatesClass = Unobfuscator . loadStatusListUpdatesClass ( classLoader ) ; logDebug ( onStatusListUpdatesClass ) ; XposedBridge . hookAllConstructors ( onStatusListUpdatesClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list1 = ( List ) param . args [ <NUM_LIT> ] ; var list2 = ( List ) param . args [ <NUM_LIT> ] ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; var onGetInvokeField = Unobfuscator . loadGetInvokeField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( onGetInvokeField ) ) ; XposedBridge . hookMethod ( onUpdateStatusChanged , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var object = onGetInvokeField . get ( param . args [ <NUM_LIT> ] ) ; var method = ReflectionUtils . findMethodUsingFilter ( object . getClass ( ) , method1 -> method1 . getReturnType ( ) . equals ( Object . class ) ) ; var StatusListUpdates = ReflectionUtils . callMethod ( method , object ) ; if ( StatusListUpdates == null ) return ; var lists = ReflectionUtils . findAllFieldsUsingFilter ( StatusListUpdates . getClass ( ) , field -> field . getType ( ) . equals ( List . class ) ) ; if ( lists . length < <NUM_LIT> ) return ; var list1 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; var list2 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . utils . ColorReplacement . replaceColors ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . content . res . ColorStateList ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Canvas ; import android . graphics . LinearGradient ; import android . graphics . PorterDuff ; import android . graphics . Shader ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RectShape ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . provider . Settings ; import android . text . TextUtils ; import android . util . Log ; import android . util . LruCache ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . RelativeLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . utils . IColors ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . ExecutorService ; import cz . vutbr . web . css . CSSFactory ; import cz . vutbr . web . css . CombinedSelector ; import cz . vutbr . web . css . Declaration ; import cz . vutbr . web . css . RuleSet ; import cz . vutbr . web . css . StyleSheet ; import cz . vutbr . web . css . Term ; import cz . vutbr . web . css . TermColor ; import cz . vutbr . web . css . TermFloatValue ; import cz . vutbr . web . css . TermFunction ; import cz . vutbr . web . css . TermLength ; import cz . vutbr . web . css . TermNumeric ; import cz . vutbr . web . css . TermURI ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class CustomView extends Feature { private DrawableCache cacheImages ; private HashMap < String , Drawable > chacheDrawables ; private ExecutorService mThreadService ; private static File themeDir ; public CustomView ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var filter_itens = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var folder_theme = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var custom_css = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; checkPermissions ( ) ; if ( ( TextUtils . isEmpty ( filter_itens ) && TextUtils . isEmpty ( folder_theme ) && TextUtils . isEmpty ( custom_css ) ) || ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; hookDrawableViews ( ) ; themeDir = new File ( ThemePreference . rootDirectory , folder_theme ) ; filter_itens += "<STR_LIT>" + custom_css ; cacheImages = new DrawableCache ( Utils . getApplication ( ) , <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; chacheDrawables = new HashMap < > ( ) ; var sheet = CSSFactory . parseString ( filter_itens , new URL ( "<STR_LIT>" ) ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; View rootView = activity . getWindow ( ) . getDecorView ( ) . getRootView ( ) ; rootView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( ( ) -> CompletableFuture . runAsync ( ( ) -> registerCssRules ( activity , ( ViewGroup ) rootView , sheet ) ) ) ; } } ) ; } private void hookDrawableViews ( ) { XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . thisObject ; var newDrawable = ( Drawable ) param . args [ <NUM_LIT> ] ; var hookedBackground = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( Unobfuscator . isCalledFromClass ( CustomView . class ) ) { if ( hookedBackground == null || view . getBackground ( ) != newDrawable ) { XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , newDrawable ) ; return ; } } else if ( hookedBackground == null ) return ; param . setResult ( null ) ; } } ) ; XposedHelpers . findAndHookMethod ( ImageView . class , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( ImageView ) param . thisObject ; var newDrawable = ( Drawable ) param . args [ <NUM_LIT> ] ; var mHookedDrawable = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( Unobfuscator . isCalledFromClass ( CustomView . class ) ) { if ( mHookedDrawable == null || view . getDrawable ( ) != newDrawable ) { XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , newDrawable ) ; return ; } } else if ( mHookedDrawable == null ) return ; param . setResult ( null ) ; } } ) ; } private void checkPermissions ( ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_MEDIA_IMAGES ) != PackageManager . PERMISSION_GRANTED ) { activity . requestPermissions ( new String [ ] { Manifest . permission . READ_MEDIA_IMAGES } , <NUM_LIT> ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , int . class , String [ ] . class , int [ ] . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; var activity = ( Activity ) param . thisObject ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var results = ( int [ ] ) param . args [ <NUM_LIT> ] ; if ( Arrays . stream ( results ) . anyMatch ( result -> result != PackageManager . PERMISSION_GRANTED ) ) { activity . startActivity ( new Intent ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS , Uri . fromParts ( "<STR_LIT>" , activity . getPackageName ( ) , null ) ) ) ; Utils . showToast ( activity . getString ( ResId . string . grant_permission ) , Toast . LENGTH_LONG ) ; } } } } ) ; } private void registerCssRules ( Activity activity , ViewGroup currenView , StyleSheet sheet ) { try { for ( var selector : sheet ) { var ruleSet = ( RuleSet ) selector ; for ( var selectorItem : ruleSet . getSelectors ( ) ) { var item = selectorItem . get ( <NUM_LIT> ) ; String className ; String name ; if ( ( className = item . getClassName ( ) ) != null ) { className = className . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . trim ( ) ; var clazz = XposedHelpers . findClass ( className , classLoader ) ; if ( clazz == null || ! clazz . isInstance ( activity ) ) continue ; name = selectorItem . get ( <NUM_LIT> ) . getIDName ( ) . trim ( ) ; } else { name = selectorItem . get ( <NUM_LIT> ) . getIDName ( ) . trim ( ) ; } int id = <NUM_LIT> ; if ( name . contains ( "<STR_LIT>" ) ) { try { id = android . R . id . class . getField ( name . substring ( <NUM_LIT> ) ) . getInt ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException ignored ) { } } else { id = Utils . getID ( name , "<STR_LIT>" ) ; } if ( id <= <NUM_LIT> ) continue ; var view = currenView . findViewById ( id ) ; if ( view == null || ! view . isShown ( ) || view . getVisibility ( ) != View . VISIBLE || ! view . isAttachedToWindow ( ) ) continue ; var ruleItem = new RuleItem ( selectorItem , ruleSet ) ; setCssRule ( view , ruleItem ) ; } } } catch ( Throwable ignored ) { } } private void setCssRule ( View currentView , RuleItem ruleItem ) { var resultViews = new ArrayList < View > ( ) ; captureSelector ( currentView , ruleItem . selector , <NUM_LIT> , resultViews ) ; if ( ruleItem . rule . getSelectors ( ) . length == <NUM_LIT> || ruleItem . rule . isEmpty ( ) || resultViews . isEmpty ( ) ) return ; for ( var view : resultViews ) { if ( view == null || ! view . isAttachedToWindow ( ) ) continue ; CompletableFuture . runAsync ( ( ) -> view . post ( ( ) -> { try { setRuleInView ( ruleItem , view ) ; } catch ( Throwable e ) { log ( e ) ; } } ) , Utils . getExecutor ( ) ) ; } } private void setRuleInView ( RuleItem ruleItem , View view ) { for ( var declaration : ruleItem . rule ) { var property = declaration . getProperty ( ) ; switch ( property ) { case "<STR_LIT>" -> { if ( declaration . size ( ) != <NUM_LIT> ) continue ; var color = ( TermColor ) declaration . get ( <NUM_LIT> ) ; var colorNew = ( TermColor ) declaration . get ( <NUM_LIT> ) ; var colorValue = IColors . toString ( color . getValue ( ) . getRGB ( ) ) ; var colorNewValue = IColors . toString ( colorNew . getValue ( ) . getRGB ( ) ) ; HashMap < String , String > colors = new HashMap < > ( ) ; colors . put ( colorValue , colorNewValue ) ; replaceColors ( view , colors ) ; if ( view instanceof ImageView imageView ) { var drawable = imageView . getDrawable ( ) ; if ( drawable == null ) continue ; drawable . setTint ( colorNew . getValue ( ) . getRGB ( ) ) ; view . postInvalidate ( ) ; } } case "<STR_LIT>" -> { var value = declaration . get ( <NUM_LIT> ) . toString ( ) ; switch ( value ) { case "<STR_LIT>" -> view . setVisibility ( View . GONE ) ; case "<STR_LIT>" -> view . setVisibility ( View . VISIBLE ) ; case "<STR_LIT>" -> view . setVisibility ( View . INVISIBLE ) ; } } case "<STR_LIT>" -> { if ( ! ( view instanceof TextView textView ) ) continue ; var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; textView . setTextSize ( getRealValue ( value , <NUM_LIT> ) ) ; } case "<STR_LIT>" -> { if ( ! ( view instanceof TextView textView ) ) continue ; var value = ( TermColor ) declaration . get ( <NUM_LIT> ) ; textView . setTextColor ( value . getValue ( ) . getRGB ( ) ) ; } case "<STR_LIT>" -> { var value = ( TermFloatValue ) declaration . get ( <NUM_LIT> ) ; view . setAlpha ( value . getValue ( ) ) ; } case "<STR_LIT>" -> { if ( ! ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) ) continue ; var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; if ( XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) != null || XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) != null ) continue ; setHookedDrawable ( view , draw ) ; } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermLength width ) { var height = ( TermLength ) declaration . get ( <NUM_LIT> ) ; if ( view instanceof ImageView imageView ) { if ( width . isPercentage ( ) || height . isPercentage ( ) ) { if ( width . getValue ( ) . intValue ( ) == <NUM_LIT> || height . getValue ( ) . intValue ( ) == <NUM_LIT> ) { imageView . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; continue ; } } var drawable = imageView . getDrawable ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( getRealValue ( width , imageView . getWidth ( ) ) == ( int ) widthObj && getRealValue ( height , imageView . getHeight ( ) ) == ( int ) heightObj ) continue ; } Bitmap resizedBitmap = Bitmap . createScaledBitmap ( bitmap , getRealValue ( width , imageView . getWidth ( ) ) , getRealValue ( height , imageView . getHeight ( ) ) , false ) ; var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , resizedBitmap ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( height , imageView . getHeight ( ) ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( width , imageView . getWidth ( ) ) ) ; setHookedDrawable ( imageView , resizeDrawable ) ; } else { var drawable = view . getBackground ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( getRealValue ( width , view . getWidth ( ) ) == ( int ) widthObj && getRealValue ( height , view . getHeight ( ) ) == ( int ) heightObj ) continue ; } Bitmap resizedBitmap = Bitmap . createScaledBitmap ( bitmap , getRealValue ( width , <NUM_LIT> ) , getRealValue ( height , <NUM_LIT> ) , false ) ; var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , resizedBitmap ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( height , <NUM_LIT> ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( width , <NUM_LIT> ) ) ; view . setBackground ( resizeDrawable ) ; } } else { var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; } else { var drawable = view . getBackground ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( ( int ) widthObj == view . getWidth ( ) && ( int ) heightObj == view . getHeight ( ) ) continue ; } var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , Bitmap . createScaledBitmap ( bitmap , view . getWidth ( ) , view . getHeight ( ) , true ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , view . getHeight ( ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , view . getWidth ( ) ) ; view . setBackground ( resizeDrawable ) ; } } } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { view . setBackgroundColor ( color . getValue ( ) . getRGB ( ) ) ; continue ; } if ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) { var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; view . setBackground ( draw ) ; continue ; } var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { view . setBackground ( null ) ; } else { setBackgroundModel ( view , declaration . get ( <NUM_LIT> ) ) ; } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { view . setBackground ( new ColorDrawable ( color . getValue ( ) . getRGB ( ) ) ) ; continue ; } if ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) { var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; view . setForeground ( draw ) ; continue ; } var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { view . setForeground ( null ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; view . getLayoutParams ( ) . width = getRealValue ( value , <NUM_LIT> ) ; view . requestLayout ( ) ; } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; view . getLayoutParams ( ) . height = getRealValue ( value , <NUM_LIT> ) ; } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_LEFT , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . leftMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_RIGHT , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . rightMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_TOP , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . topMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_BOTTOM , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . bottomMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var mode = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( mode . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . clearColorFilter ( ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . clearColorFilter ( ) ; } } } else { if ( ! ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) ) continue ; try { var pMode = PorterDuff . Mode . valueOf ( mode ) ; if ( view instanceof ImageView imageView ) { imageView . setColorFilter ( color . getValue ( ) . getRGB ( ) , pMode ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . setColorFilter ( color . getValue ( ) . getRGB ( ) , pMode ) ; } } } catch ( IllegalArgumentException ignored ) { } } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { if ( view instanceof ImageView imageView ) { ColorStateList colorStateList = declaration . size ( ) == <NUM_LIT> ? ColorStateList . valueOf ( color . getValue ( ) . getRGB ( ) ) : getColorStateList ( declaration ) ; imageView . setImageTintList ( colorStateList ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { ColorStateList colorStateList = declaration . size ( ) == <NUM_LIT> ? ColorStateList . valueOf ( color . getValue ( ) . getRGB ( ) ) : getColorStateList ( declaration ) ; drawable . setTintList ( colorStateList ) ; } } } else { var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . setImageTintList ( null ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . setTintList ( null ) ; } } } } } } } } private void setHookedDrawable ( View view , Drawable draw ) { if ( view instanceof ImageView imageView ) { imageView . setImageDrawable ( draw ) ; } else { view . setBackground ( draw ) ; } } private void setBackgroundModel ( View view , Term < ? > value ) { if ( value instanceof TermFunction . LinearGradient gradient ) { try { var gradientDrawable = chacheDrawables . get ( value . toString ( ) ) ; if ( gradientDrawable == null ) { gradientDrawable = GradientDrawableParser . parseGradient ( gradient , view . getWidth ( ) , view . getHeight ( ) ) ; chacheDrawables . put ( value . toString ( ) , gradientDrawable ) ; } view . setBackground ( gradientDrawable ) ; } catch ( Exception e ) { log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } } @ NonNull private static ColorStateList getColorStateList ( Declaration declaration ) { var defaultFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; var pressedFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; var disabledFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; return new ColorStateList ( new int [ ] [ ] { new int [ ] { android . R . attr . state_pressed } , new int [ ] { android . R . attr . state_enabled } , new int [ ] { android . R . attr . state_focused , android . R . attr . state_pressed } , new int [ ] { - android . R . attr . state_enabled } , new int [ ] { } } , new int [ ] { pressedFontColor , defaultFontColor , pressedFontColor , disabledFontColor , defaultFontColor } ) ; } private int getRealValue ( TermLength value , int size ) { if ( value . getUnit ( ) == TermNumeric . Unit . px ) { return Utils . dipToPixels ( value . getValue ( ) . intValue ( ) ) ; } else if ( value . isPercentage ( ) ) { return size * value . getValue ( ) . intValue ( ) / <NUM_LIT> ; } return value . getValue ( ) . intValue ( ) ; } private void captureSelector ( View currentView , CombinedSelector selector , int position , ArrayList < View > resultViews ) { if ( selector . size ( ) == position ) return ; var selectorItem = selector . get ( position ) ; if ( selectorItem . getClassName ( ) != null ) { captureSelector ( currentView , selector , position + <NUM_LIT> , resultViews ) ; } else if ( selectorItem . getIDName ( ) != null ) { var name = selectorItem . getIDName ( ) . trim ( ) ; int id = <NUM_LIT> ; if ( name . contains ( "<STR_LIT>" ) ) { try { id = android . R . id . class . getField ( name . substring ( <NUM_LIT> ) ) . getInt ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException ignored ) { } } else { id = Utils . getID ( name , "<STR_LIT>" ) ; } if ( id <= <NUM_LIT> ) return ; View view = currentView . getId ( ) == id ? currentView : currentView . findViewById ( id ) ; if ( view == null ) return ; if ( selector . size ( ) == position + <NUM_LIT> ) { resultViews . add ( view ) ; } else { captureSelector ( view , selector , position + <NUM_LIT> , resultViews ) ; } } else { if ( ! ( currentView instanceof ViewGroup viewGroup ) ) return ; var name = Arrays . stream ( selectorItem . toString ( ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . toArray ( String [ ] :: new ) ; var itemCount = new int [ ] { <NUM_LIT> } ; for ( int i = <NUM_LIT> ; i < viewGroup . getChildCount ( ) ; i ++ ) { var itemView = viewGroup . getChildAt ( i ) ; if ( ReflectionUtils . isClassSimpleNameString ( itemView . getClass ( ) , name [ <NUM_LIT> ] ) ) { if ( name . length > <NUM_LIT> ) if ( checkAttribute ( itemView , itemCount , name [ <NUM_LIT> ] ) ) continue ; if ( selector . size ( ) == position + <NUM_LIT> ) { resultViews . add ( itemView ) ; } else { captureSelector ( itemView , selector , position + <NUM_LIT> , resultViews ) ; } } else if ( isWidgetString ( name [ <NUM_LIT> ] ) && itemView instanceof ViewGroup viewGroup1 ) { for ( int j = <NUM_LIT> ; j < viewGroup1 . getChildCount ( ) ; j ++ ) { var childView = viewGroup1 . getChildAt ( j ) ; captureSelector ( childView , selector , position , resultViews ) ; } } } } } private boolean checkAttribute ( View itemView , int [ ] itemCount , String name ) { if ( name . startsWith ( "<STR_LIT>" ) ) { var startIndex = name . indexOf ( "<STR_LIT>" ) + <NUM_LIT> ; var endIndex = name . indexOf ( "<STR_LIT>" ) ; var index = Integer . parseInt ( name . substring ( startIndex , endIndex ) ) - <NUM_LIT> ; return index != itemCount [ <NUM_LIT> ] ++ ; } else if ( name . startsWith ( "<STR_LIT>" ) ) { var startIndex = name . indexOf ( "<STR_LIT>" ) + <NUM_LIT> ; var endIndex = name . indexOf ( "<STR_LIT>" ) ; var contains = name . substring ( startIndex , endIndex ) ; if ( itemView instanceof TextView textView ) { return ! textView . getText ( ) . toString ( ) . contains ( contains ) ; } else { return ! itemView . toString ( ) . contains ( contains ) ; } } return false ; } private boolean isWidgetString ( String view ) { return XposedHelpers . findClassIfExists ( "<STR_LIT>" + view , null ) != null ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public class DrawableCache { private final LruCache < String , CachedDrawable > drawableCache ; private final Context context ; public DrawableCache ( Context context , int maxSize ) { this . context = context . getApplicationContext ( ) ; drawableCache = new LruCache < > ( maxSize ) ; } private Drawable loadDrawableFromFile ( String filePath , int reqWidth , int reqHeight ) { File file = new File ( filePath ) ; var bitmap = BitmapFactory . decodeFile ( file . getAbsolutePath ( ) ) ; var newHeight = reqHeight < <NUM_LIT> ? bitmap . getHeight ( ) : Math . min ( bitmap . getHeight ( ) , reqHeight ) ; var newWidth = reqWidth < <NUM_LIT> ? bitmap . getWidth ( ) : Math . min ( bitmap . getWidth ( ) , reqWidth ) ; bitmap = Bitmap . createScaledBitmap ( bitmap , newWidth , newHeight , true ) ; return new BitmapDrawable ( context . getResources ( ) , bitmap ) ; } @ Nullable public Drawable getDrawable ( String filePath , int width , int height ) { File file = filePath . startsWith ( "<STR_LIT>" ) ? new File ( filePath ) : new File ( themeDir , filePath ) ; if ( ! file . exists ( ) || ! file . canRead ( ) ) { return null ; } String key = file . getAbsolutePath ( ) ; long lastModified = file . lastModified ( ) ; CachedDrawable cachedDrawable = drawableCache . get ( key ) ; if ( cachedDrawable != null && cachedDrawable . lastModified == lastModified ) { return cachedDrawable . drawable ; } Drawable cachedDrawableFromFile = loadDrawableFromCache ( key , lastModified ) ; if ( cachedDrawableFromFile != null ) { cachedDrawable = new CachedDrawable ( cachedDrawableFromFile , lastModified ) ; drawableCache . put ( key , cachedDrawable ) ; return cachedDrawableFromFile ; } Drawable drawable = loadDrawableFromFile ( key , width , height ) ; saveDrawableToCache ( key , ( BitmapDrawable ) drawable , lastModified ) ; cachedDrawable = new CachedDrawable ( drawable , lastModified ) ; drawableCache . put ( key , cachedDrawable ) ; return drawable ; } private void saveDrawableToCache ( String key , BitmapDrawable drawable , long lastModified ) { File cacheDir = context . getCacheDir ( ) ; File cacheLocation = new File ( cacheDir , "<STR_LIT>" ) ; if ( ! cacheLocation . exists ( ) ) { cacheLocation . mkdirs ( ) ; } File cacheFile = new File ( cacheLocation , getCacheFileName ( key ) ) ; File metadataFile = new File ( cacheLocation , getCacheFileName ( key ) + "<STR_LIT>" ) ; try ( OutputStream out = new FileOutputStream ( cacheFile ) ; ObjectOutputStream metaOut = new ObjectOutputStream ( new FileOutputStream ( metadataFile ) ) ) { drawable . getBitmap ( ) . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , out ) ; metaOut . writeLong ( lastModified ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + cacheFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" , e ) ; } } private Drawable loadDrawableFromCache ( String key , long originalLastModified ) { File cacheDir = context . getCacheDir ( ) ; File cacheLocation = new File ( cacheDir , "<STR_LIT>" ) ; File cacheFile = new File ( cacheLocation , getCacheFileName ( key ) ) ; File metadataFile = new File ( cacheLocation , getCacheFileName ( key ) + "<STR_LIT>" ) ; if ( ! cacheFile . exists ( ) || ! metadataFile . exists ( ) ) { log ( "<STR_LIT>" + cacheFile . getAbsolutePath ( ) ) ; return null ; } try ( ObjectInputStream metaIn = new ObjectInputStream ( new FileInputStream ( metadataFile ) ) ) { long cachedLastModified = metaIn . readLong ( ) ; if ( cachedLastModified != originalLastModified ) { return null ; } Bitmap bitmap = BitmapFactory . decodeFile ( cacheFile . getAbsolutePath ( ) ) ; if ( bitmap != null ) { return new BitmapDrawable ( context . getResources ( ) , bitmap ) ; } } catch ( IOException e ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" , e ) ; } return null ; } private String getCacheFileName ( String input ) { return String . valueOf ( Objects . hash ( input ) ) ; } private static class CachedDrawable { Drawable drawable ; long lastModified ; CachedDrawable ( Drawable drawable , long lastModified ) { this . drawable = drawable ; this . lastModified = lastModified ; } } } public static class RuleItem { public CombinedSelector selector ; public RuleSet rule ; public RuleItem ( CombinedSelector selectorItem , RuleSet ruleSet ) { this . selector = selectorItem ; this . rule = ruleSet ; } } public static class GradientDrawableParser { public static BitmapDrawable parseGradient ( TermFunction . LinearGradient cssGradient , int width , int height ) { int [ ] colors = new int [ cssGradient . getColorStops ( ) . size ( ) ] ; float [ ] positions = new float [ cssGradient . getColorStops ( ) . size ( ) ] ; float angle = cssGradient . getAngle ( ) . getValue ( ) ; for ( int i = cssGradient . getColorStops ( ) . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { colors [ i ] = cssGradient . getColorStops ( ) . get ( i ) . getColor ( ) . getValue ( ) . getRGB ( ) ; positions [ i ] = cssGradient . getColorStops ( ) . get ( i ) . getLength ( ) . getValue ( ) / <NUM_LIT> ; } LinearGradient linearGradient = createLinearGradient ( angle , colors , positions , width , height ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new RectShape ( ) ) ; shapeDrawable . setIntrinsicWidth ( width ) ; shapeDrawable . setIntrinsicHeight ( height ) ; shapeDrawable . getPaint ( ) . setShader ( linearGradient ) ; Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; shapeDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , width , height ) ; shapeDrawable . draw ( new Canvas ( bitmap ) ) ; return new BitmapDrawable ( Utils . getApplication ( ) . getResources ( ) , bitmap ) ; } private static LinearGradient createLinearGradient ( float angle , int [ ] colors , float [ ] positions , int width , int height ) { float x0 , y0 , x1 , y1 ; double radians = Math . toRadians ( angle ) ; x0 = ( float ) ( <NUM_LIT> * width + <NUM_LIT> * width * Math . cos ( radians - Math . PI / <NUM_LIT> ) ) ; y0 = ( float ) ( <NUM_LIT> * height + <NUM_LIT> * height * Math . sin ( radians - Math . PI / <NUM_LIT> ) ) ; x1 = ( float ) ( <NUM_LIT> * width + <NUM_LIT> * width * Math . cos ( radians + Math . PI / <NUM_LIT> ) ) ; y1 = ( float ) ( <NUM_LIT> * height + <NUM_LIT> * height * Math . sin ( radians + Math . PI / <NUM_LIT> ) ) ; return new LinearGradient ( x0 , y0 , x1 , y1 , colors , positions , Shader . TileMode . CLAMP ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . res . Resources ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . text . TextUtils ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . DelMessageStore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . text . DateFormat ; import java . util . Arrays ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiRevoke extends Feature { private static final HashMap < String , HashSet < String > > messageRevokedMap = new HashMap < > ( ) ; public AntiRevoke ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var antiRevokeMessageMethod = Unobfuscator . loadAntiRevokeMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( antiRevokeMessageMethod ) ) ; var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var unknownStatusPlaybackMethod = Unobfuscator . loadUnknownStatusPlaybackMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( unknownStatusPlaybackMethod ) ) ; var statusPlaybackField = Unobfuscator . loadStatusPlaybackViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( statusPlaybackField ) ) ; XposedBridge . hookMethod ( antiRevokeMessageMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Exception { var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; var messageKey = fMessage . getKey ( ) ; var deviceJid = fMessage . getDeviceJid ( ) ; var id = fMessage . getRowId ( ) ; var messageID = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; if ( WppCore . getPrivBoolean ( messageID + "<STR_LIT>" , false ) ) { WppCore . removePrivKey ( messageID + "<STR_LIT>" ) ; var activity = WppCore . getCurrentActivity ( ) ; Class < ? > StatusPlaybackActivityClass = classLoader . loadClass ( "<STR_LIT>" ) ; if ( activity != null && StatusPlaybackActivityClass . isInstance ( activity ) ) { activity . finish ( ) ; } return ; } var rawString = WppCore . getRawString ( messageKey . remoteJid ) ; if ( WppCore . isGroup ( rawString ) ) { if ( deviceJid != null && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } else if ( ! messageKey . isFromMe && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var dateTextView = ( TextView ) param . args [ <NUM_LIT> ] ; isMRevoked ( objMessage , dateTextView , "<STR_LIT>" ) ; } } ) ; XposedBridge . hookMethod ( unknownStatusPlaybackMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var obj = param . args [ <NUM_LIT> ] ; var objMessage = param . args [ <NUM_LIT> ] ; Object objView = statusPlaybackField . get ( obj ) ; Field [ ] textViews = Arrays . stream ( statusPlaybackField . getType ( ) . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) == TextView . class ) . toArray ( Field [ ] :: new ) ; if ( textViews == null ) { log ( "<STR_LIT>" ) ; return ; } int dateId = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; for ( Field textView : textViews ) { TextView textView1 = ( TextView ) XposedHelpers . getObjectField ( objView , textView . getName ( ) ) ; if ( textView1 == null || textView1 . getId ( ) == dateId ) { isMRevoked ( objMessage , textView1 , "<STR_LIT>" ) ; break ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static Drawable scaleImage ( Resources resources , Drawable image , float scaleFactor ) { if ( ! ( image instanceof BitmapDrawable ) ) { return image ; } Bitmap b = ( ( BitmapDrawable ) image ) . getBitmap ( ) ; int sizeX = Math . round ( image . getIntrinsicWidth ( ) * scaleFactor ) ; int sizeY = Math . round ( image . getIntrinsicHeight ( ) * scaleFactor ) ; Bitmap bitmapResized = Bitmap . createScaledBitmap ( b , sizeX , sizeY , false ) ; return new BitmapDrawable ( resources , bitmapResized ) ; } private static void saveRevokedMessage ( FMessageWpp fMessage ) { var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; HashSet < String > messages = getRevokedMessages ( fMessage ) ; messages . add ( messageKey ) ; DelMessageStore . getInstance ( Utils . getApplication ( ) ) . insertMessage ( stripJID , messageKey , System . currentTimeMillis ( ) ) ; } private static HashSet < String > getRevokedMessages ( FMessageWpp fMessage ) { String jid = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; if ( messageRevokedMap . containsKey ( jid ) ) { return messageRevokedMap . get ( jid ) ; } var messages = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getMessagesByJid ( jid ) ; if ( messages == null ) messages = new HashSet < > ( ) ; messageRevokedMap . put ( jid , messages ) ; return messages ; } private void isMRevoked ( Object objMessage , TextView dateTextView , String antirevokeType ) { if ( dateTextView == null ) return ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; var messageRevokedList = getRevokedMessages ( fMessage ) ; var id = fMessage . getRowId ( ) ; String keyOrig = null ; if ( messageRevokedList . contains ( key . messageID ) || ( ( keyOrig = MessageStore . getInstance ( ) . getOriginalMessageKey ( id ) ) != null && messageRevokedList . contains ( keyOrig ) ) ) { var timestamp = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getTimestampByMessageId ( keyOrig == null ? key . messageID : keyOrig ) ; if ( timestamp > <NUM_LIT> ) { Locale locale = Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . getLocales ( ) . get ( <NUM_LIT> ) ; DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , locale ) ; var date = dateFormat . format ( new Date ( timestamp ) ) ; dateTextView . getPaint ( ) . setUnderlineText ( true ) ; dateTextView . setOnClickListener ( v -> Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . message_removed_on ) , date ) , Toast . LENGTH_LONG ) ) ; } var antirevokeValue = Integer . parseInt ( prefs . getString ( antirevokeType , "<STR_LIT>" ) ) ; if ( antirevokeValue == <NUM_LIT> ) { var newTextData = UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) + "<STR_LIT>" + dateTextView . getText ( ) ; dateTextView . setText ( newTextData ) ; } else if ( antirevokeValue == <NUM_LIT> ) { var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; var drawable = scaleImage ( Utils . getApplication ( ) . getResources ( ) , icon , <NUM_LIT> ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( Color . RED , PorterDuff . Mode . SRC_ATOP ) ) ; dateTextView . setCompoundDrawablesWithIntrinsicBounds ( null , null , drawable , null ) ; dateTextView . setCompoundDrawablePadding ( <NUM_LIT> ) ; } } else { dateTextView . setCompoundDrawables ( null , null , null , null ) ; var revokeNotice = UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) + "<STR_LIT>" ; var dateText = dateTextView . getText ( ) . toString ( ) ; if ( dateText . contains ( revokeNotice ) ) { dateTextView . setText ( dateText . replace ( revokeNotice , "<STR_LIT>" ) ) ; } dateTextView . getPaint ( ) . setUnderlineText ( false ) ; dateTextView . setOnClickListener ( null ) ; } } private int antiRevoke ( FMessageWpp fMessage ) { showToast ( fMessage ) ; var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; var revokeboolean = stripJID . equals ( "<STR_LIT>" ) ? Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) : Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( revokeboolean == <NUM_LIT> ) return revokeboolean ; var messageRevokedList = getRevokedMessages ( fMessage ) ; if ( ! messageRevokedList . contains ( messageKey ) ) { try { AsyncTask . THREAD_POOL_EXECUTOR . execute ( ( ) -> { saveRevokedMessage ( fMessage ) ; try { var mConversation = WppCore . getCurrentConversation ( ) ; if ( mConversation != null && WppCore . stripJID ( WppCore . getCurrentRawJID ( ) ) . equals ( stripJID ) ) { mConversation . runOnUiThread ( ( ) -> { if ( mConversation . hasWindowFocus ( ) ) { mConversation . startActivity ( mConversation . getIntent ( ) ) ; mConversation . overridePendingTransition ( <NUM_LIT> , <NUM_LIT> ) ; mConversation . getWindow ( ) . getDecorView ( ) . findViewById ( android . R . id . content ) . postInvalidate ( ) ; } else { mConversation . recreate ( ) ; } } ) ; } } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } ) ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } return revokeboolean ; } private void showToast ( FMessageWpp fMessage ) { var jidAuthor = WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ; var messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_message ) ; var isStatus = Objects . equals ( WppCore . stripJID ( jidAuthor ) , "<STR_LIT>" ) ; if ( isStatus ) { messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_status ) ; jidAuthor = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; } if ( TextUtils . isEmpty ( jidAuthor ) ) return ; String name = WppCore . getContactName ( WppCore . createUserJid ( jidAuthor ) ) ; if ( TextUtils . isEmpty ( name ) ) { name = WppCore . stripJID ( jidAuthor ) ; } String message ; if ( WppCore . isGroup ( jidAuthor ) && fMessage . getUserJid ( ) != null ) { var participantJid = fMessage . getUserJid ( ) ; String participantName = WppCore . getContactName ( participantJid ) ; if ( TextUtils . isEmpty ( participantName ) ) { participantName = WppCore . stripJID ( WppCore . getRawString ( participantJid ) ) ; } message = Utils . getApplication ( ) . getString ( ResId . string . deleted_a_message_in_group , participantName , name ) ; } else { message = name + "<STR_LIT>" + messageSuffix ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { Utils . showToast ( message , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jidAuthor ) , isStatus ? "<STR_LIT>" : "<STR_LIT>" ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . Menu ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Channels extends Feature { public Channels ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void removeItems ( ArrayList < ? > arrList , boolean channels , boolean removechannelRec , Class < ? > headerChannelItem , Class < ? > listChannelItem , Class < ? > removeChannelRecClass ) { arrList . removeIf ( ( e ) -> { if ( channels ) { if ( headerChannelItem . isInstance ( e ) || listChannelItem . isInstance ( e ) ) return true ; } if ( channels || removechannelRec ) { return removeChannelRecClass . isInstance ( e ) ; } return false ; } ) ; } @ Override public void doHook ( ) throws Throwable { var channels = prefs . getBoolean ( "<STR_LIT>" , false ) ; var removechannelRec = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( channels || removechannelRec ) { var removeChannelRecClass = Unobfuscator . loadRemoveChannelRecClass ( classLoader ) ; log ( "<STR_LIT>" + removeChannelRecClass ) ; var headerChannelItem = Unobfuscator . loadHeaderChannelItemClass ( classLoader ) ; log ( "<STR_LIT>" + headerChannelItem ) ; var listChannelItem = Unobfuscator . loadListChannelItemClass ( classLoader ) ; log ( "<STR_LIT>" + listChannelItem ) ; var listUpdateItems = Unobfuscator . loadListUpdateItemsConstructor ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getConstructorDescriptor ( listUpdateItems ) ) ; XposedBridge . hookMethod ( listUpdateItems , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list = ReflectionUtils . findArrayOfType ( param . args , ArrayList . class ) ; if ( list . isEmpty ( ) ) return ; var arrList = ( ArrayList < ? > ) list . get ( <NUM_LIT> ) . second ; removeItems ( arrList , channels , removechannelRec , headerChannelItem , listChannelItem , removeChannelRecClass ) ; } } ) ; XposedBridge . hookAllConstructors ( removeChannelRecClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pairs = ReflectionUtils . findArrayOfType ( param . args , List . class ) ; for ( var pair : pairs ) { param . args [ pair . first ] = new ArrayList < > ( ) ; } } } ) ; if ( channels ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var menuItem = menu . findItem ( id ) ; if ( menuItem != null ) { menuItem . setVisible ( false ) ; } } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . graphics . PorterDuffColorFilter ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewStub ; import android . widget . ImageView ; import android . widget . TextView ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class ColorReplacement { public static void replaceColors ( View view , HashMap < String , String > colors ) { if ( view instanceof ImageView imageView ) { Image . replace ( imageView , colors ) ; } else if ( view instanceof TextView textView ) { Text . replace ( textView , colors ) ; } else if ( view instanceof ViewGroup viewGroup ) { Group . replace ( viewGroup , colors ) ; } else if ( view instanceof ViewStub viewStub ) { replaceColor ( viewStub . getBackground ( ) , colors ) ; } else if ( view . getClass ( ) . equals ( findClass ( "<STR_LIT>" , loader1 ) ) ) { CircularProgressBar . replace ( view , colors ) ; } } public static class Image { static void replace ( ImageView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var colorFilter = view . getColorFilter ( ) ; if ( colorFilter == null ) return ; if ( colorFilter instanceof PorterDuffColorFilter filter ) { var color = ( int ) XposedHelpers . callMethod ( filter , "<STR_LIT>" ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setColorFilter ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setColorFilter ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } } public static class CircularProgressBar { static void replace ( Object view , HashMap < String , String > colors ) { var progressColor = ( int ) callMethod ( view , "<STR_LIT>" ) ; var progressBackgroundColor = ( int ) callMethod ( view , "<STR_LIT>" ) ; var pcSColor = IColors . toString ( progressColor ) ; var pcbSColor = IColors . toString ( progressBackgroundColor ) ; var newPColor = colors . get ( pcSColor ) ; var newPBColor = colors . get ( pcbSColor ) ; if ( newPColor != null ) { callMethod ( view , "<STR_LIT>" , parseColor ( newPColor ) ) ; } if ( newPBColor != null ) { callMethod ( view , "<STR_LIT>" , parseColor ( newPBColor ) ) ; } } } public static class Text { static void replace ( TextView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var color = view . getCurrentTextColor ( ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setTextColor ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setTextColor ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } public static class Group { static void replace ( ViewGroup view , HashMap < String , String > colors ) { var bg = view . getBackground ( ) ; var count = view . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var child = view . getChildAt ( i ) ; replaceColors ( child , colors ) ; } replaceColor ( bg , colors ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class WaCallback implements Application . ActivityLifecycleCallbacks { @ Override public void onActivityCreated ( @ NonNull Activity activity , @ Nullable Bundle bundle ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; } @ Override public void onActivityStarted ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . START ) ; WppCore . activities . add ( activity ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onActivityResumed ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; if ( WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ) { WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; try { new AlertDialogWpp ( activity ) . setMessage ( activity . getString ( ResId . string . restart_wpp ) ) . setPositiveButton ( activity . getString ( ResId . string . yes ) , ( dialog , which ) -> { if ( ! Utils . doRestart ( activity ) ) Toast . makeText ( activity , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } ) . setNegativeButton ( activity . getString ( ResId . string . no ) , null ) . show ( ) ; } catch ( Exception ignored ) { } } triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . RESUME ) ; } @ Override public void onActivityPaused ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . PAUSE ) ; } @ Override public void onActivityStopped ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . END ) ; WppCore . activities . remove ( activity ) ; } private static void triggerActivityState ( @ NonNull Activity activity , WppCore . ActivityChangeState . ChangeType type ) { for ( WppCore . ActivityChangeState listener : WppCore . listenerChat ) { listener . onChange ( activity , type ) ; } } @ Override public void onActivitySaveInstanceState ( @ NonNull Activity activity , @ NonNull Bundle bundle ) { } @ Override public void onActivityDestroyed ( @ NonNull Activity activity ) { WppCore . activities . remove ( activity ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . os . Handler ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class Tasker extends Feature { private static FMessageWpp fMessage ; private static boolean taskerEnabled ; public Tasker ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { taskerEnabled = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! taskerEnabled ) return ; hookReceiveMessage ( ) ; registerSenderMessage ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private void registerSenderMessage ( ) { IntentFilter filter = new IntentFilter ( "<STR_LIT>" ) ; ContextCompat . registerReceiver ( Utils . getApplication ( ) , new SenderMessageBroadcastReceiver ( ) , filter , ContextCompat . RECEIVER_EXPORTED ) ; } public synchronized static void sendTaskerEvent ( String name , String number , String event ) { if ( ! taskerEnabled ) return ; Intent intent = new Intent ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , name ) ; intent . putExtra ( "<STR_LIT>" , number ) ; intent . putExtra ( "<STR_LIT>" , event ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } public void hookReceiveMessage ( ) throws Throwable { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; XposedBridge . hookMethod ( method2 , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; } } ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" || param . args [ <NUM_LIT> ] == null || fMessage == null ) return ; var userJid = fMessage . getKey ( ) . remoteJid ; var rawJid = WppCore . getRawString ( userJid ) ; var name = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( rawJid ) ; var msg = fMessage . getMessageStr ( ) ; if ( TextUtils . isEmpty ( msg ) || TextUtils . isEmpty ( number ) || rawJid . startsWith ( "<STR_LIT>" ) ) return ; new Handler ( Utils . getApplication ( ) . getMainLooper ( ) ) . post ( ( ) -> { Intent intent = new Intent ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , number ) ; intent . putExtra ( "<STR_LIT>" , name ) ; intent . putExtra ( "<STR_LIT>" , msg ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } ) ; } } ) ; } public static class SenderMessageBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { XposedBridge . log ( "<STR_LIT>" ) ; var number = intent . getStringExtra ( "<STR_LIT>" ) ; if ( number == null ) { number = String . valueOf ( intent . getLongExtra ( "<STR_LIT>" , <NUM_LIT> ) ) ; number = Objects . equals ( number , "<STR_LIT>" ) ? null : number ; } var message = intent . getStringExtra ( "<STR_LIT>" ) ; if ( number == null || message == null ) return ; number = number . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; WppCore . sendMessage ( number , message ) ; } } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . GradientDrawable ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . View ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . SeekBar ; import android . widget . TextView ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; public class SimpleColorPickerDialog extends AlertDialogWpp { private final OnColorSelectedListener listener ; private int selectedColor = Color . BLACK ; private boolean isUpdating = false ; public SimpleColorPickerDialog ( Context context , OnColorSelectedListener listener ) { super ( context ) ; this . listener = listener ; } @ Override public Dialog create ( ) { setTitle ( getContext ( ) . getString ( ResId . string . select_a_color ) ) ; LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; final SeekBar redSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar greenSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar blueSeekBar = new SeekBar ( getContext ( ) ) ; redSeekBar . setMax ( <NUM_LIT> ) ; greenSeekBar . setMax ( <NUM_LIT> ) ; blueSeekBar . setMax ( <NUM_LIT> ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , redSeekBar ) ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , greenSeekBar ) ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , blueSeekBar ) ) ; final View colorPreview = new View ( getContext ( ) ) ; colorPreview . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( selectedColor ) ; borderDrawable . setStroke ( <NUM_LIT> , DesignUtils . getPrimaryTextColor ( ) ) ; colorPreview . setBackground ( borderDrawable ) ; layout . addView ( colorPreview ) ; final EditText hexInput = new EditText ( getContext ( ) ) ; hexInput . setHint ( "<STR_LIT>" ) ; layout . addView ( hexInput ) ; redSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; greenSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; blueSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; hexInput . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { if ( ! isUpdating && s . length ( ) == <NUM_LIT> && s . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { try { isUpdating = true ; selectedColor = Color . parseColor ( s . toString ( ) ) ; borderDrawable . setColor ( selectedColor ) ; redSeekBar . setProgress ( Color . red ( selectedColor ) ) ; greenSeekBar . setProgress ( Color . green ( selectedColor ) ) ; blueSeekBar . setProgress ( Color . blue ( selectedColor ) ) ; isUpdating = false ; } catch ( IllegalArgumentException e ) { } } } @ Override public void afterTextChanged ( Editable s ) { } } ) ; setPositiveButton ( "<STR_LIT>" , ( dialogInterface , i ) -> { if ( listener != null ) { listener . onColorSelected ( selectedColor ) ; } dismiss ( ) ; } ) ; setNegativeButton ( getContext ( ) . getString ( ResId . string . cancel ) , ( dialogInterface , i ) -> { dismiss ( ) ; } ) ; setView ( layout ) ; return super . create ( ) ; } private void updateColorPreview ( GradientDrawable borderDrawable , SeekBar redSeekBar , SeekBar greenSeekBar , SeekBar blueSeekBar , EditText hexInput ) { int red = redSeekBar . getProgress ( ) ; int green = greenSeekBar . getProgress ( ) ; int blue = blueSeekBar . getProgress ( ) ; selectedColor = Color . rgb ( red , green , blue ) ; borderDrawable . setColor ( selectedColor ) ; hexInput . setText ( String . format ( "<STR_LIT>" , red , green , blue ) ) ; } private LinearLayout createSeekBarLayout ( String label , SeekBar seekBar ) { LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; TextView labelView = new TextView ( getContext ( ) ) ; labelView . setText ( label ) ; labelView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; layout . addView ( labelView ) ; layout . addView ( seekBar ) ; return layout ; } public interface OnColorSelectedListener { void onColorSelected ( int color ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . components ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FMessageWpp { public static Class < ? > TYPE ; private static boolean initialized ; private static Method userJidMethod ; private static Field keyMessage ; private static Field getFieldIdMessage ; private static Method deviceJidMethod ; private static Method messageMethod ; private static Method messageWithMediaMethod ; private final Object fmessage ; public FMessageWpp ( Object fMessage ) { if ( fMessage == null ) throw new RuntimeException ( "<STR_LIT>" ) ; this . fmessage = fMessage ; try { init ( fMessage . getClass ( ) . getClassLoader ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void init ( ClassLoader classLoader ) throws Exception { if ( initialized ) return ; initialized = true ; TYPE = Unobfuscator . loadFMessageClass ( classLoader ) ; var userJidClass = classLoader . loadClass ( "<STR_LIT>" ) ; userJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == userJidClass ) ; keyMessage = Unobfuscator . loadMessageKeyField ( classLoader ) ; messageMethod = Unobfuscator . loadNewMessageMethod ( classLoader ) ; messageWithMediaMethod = Unobfuscator . loadNewMessageWithMediaMethod ( classLoader ) ; getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; deviceJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getReturnType ( ) . equals ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ) ; } public Object getUserJid ( ) { try { return userJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getDeviceJid ( ) { try { return deviceJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public long getRowId ( ) { try { return getFieldIdMessage . getLong ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return <NUM_LIT> ; } public Key getKey ( ) { try { return new Key ( keyMessage . get ( fmessage ) ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getObject ( ) { return fmessage ; } public String getMessageStr ( ) { try { var message = ( String ) messageMethod . invoke ( fmessage ) ; if ( message != null ) return message ; return ( String ) messageWithMediaMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; return null ; } } public static class Key { public final Object thisObject ; public final String messageID ; public final boolean isFromMe ; public final Object remoteJid ; public Key ( Object key ) { this . thisObject = key ; this . messageID = ( String ) XposedHelpers . getObjectField ( key , "<STR_LIT>" ) ; this . isFromMe = XposedHelpers . getBooleanField ( key , "<STR_LIT>" ) ; this . remoteJid = XposedHelpers . getObjectField ( key , "<STR_LIT>" ) ; } } } </s>
<s> package com . wmods . wppenhacer . listeners ; import android . view . GestureDetector ; import android . view . MotionEvent ; public class DoubleTapListener extends GestureDetector . SimpleOnGestureListener { private final OnDoubleClickListener listener ; public DoubleTapListener ( OnDoubleClickListener listener ) { this . listener = listener ; } @ Override public boolean onDoubleTap ( MotionEvent e ) { listener . onDoubleClick ( ) ; return true ; } public interface OnDoubleClickListener { void onDoubleClick ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . xposed . features . customization . SeparateGroup . tabs ; import android . os . Bundle ; import android . view . MenuItem ; import android . view . View ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . ArrayList ; import java . util . List ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideTabs extends Feature { private Object mTabPagerInstance ; public HideTabs ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var hidetabs = prefs . getStringSet ( "<STR_LIT>" , null ) ; var igstatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( hidetabs == null || hidetabs . isEmpty ( ) ) return ; var home = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var hideTabsList = hidetabs . stream ( ) . map ( Integer :: valueOf ) . collect ( Collectors . toList ( ) ) ; var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var ListField = Unobfuscator . getFieldByType ( home , List . class ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var list = ( List < Integer > ) XposedHelpers . getStaticObjectField ( home , ListField . getName ( ) ) ; for ( var item : hideTabsList ) { if ( item != SeparateGroup . STATUS || ! igstatus ) { list . remove ( item ) ; } } } } ) ; var OnTabItemAddMethod = Unobfuscator . loadOnTabItemAddMethod ( classLoader ) ; XposedBridge . hookMethod ( OnTabItemAddMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menuItem = ( MenuItem ) param . getResult ( ) ; var menuItemId = menuItem . getItemId ( ) ; if ( hideTabsList . contains ( menuItemId ) ) { menuItem . setVisible ( false ) ; } } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; logDebug ( loadTabFrameClass ) ; XposedBridge . hookAllMethods ( FrameLayout . class , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; if ( tabs != null ) { var arr = new ArrayList < > ( tabs ) ; arr . removeAll ( hideTabsList ) ; if ( arr . size ( ) == <NUM_LIT> ) { ( ( View ) param . thisObject ) . setVisibility ( View . GONE ) ; } } for ( var item : hideTabsList ) { View view ; if ( ( view = ( ( View ) param . thisObject ) . findViewById ( item ) ) != null ) { view . setVisibility ( View . GONE ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Class < ? > TabsPagerClass = classLoader . loadClass ( "<STR_LIT>" ) ; var tabsField = Unobfuscator . getFieldByType ( param . thisObject . getClass ( ) , TabsPagerClass ) ; mTabPagerInstance = tabsField . get ( param . thisObject ) ; } } ) ; var onMenuItemSelected = Unobfuscator . loadOnMenuItemSelected ( classLoader ) ; XposedBridge . hookMethod ( onMenuItemSelected , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject == mTabPagerInstance ) { var index = ( int ) param . args [ <NUM_LIT> ] ; var idxAtual = ( int ) XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; param . args [ <NUM_LIT> ] = getNewTabIndex ( hideTabsList , idxAtual , index ) ; } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , int . class , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject != mTabPagerInstance ) return ; for ( var item : hideTabsList ) { var index = tabs . indexOf ( item ) ; if ( index == - <NUM_LIT> ) continue ; if ( ( int ) param . args [ <NUM_LIT> ] == index ) { ( ( View ) param . args [ <NUM_LIT> ] ) . setVisibility ( View . GONE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public int getNewTabIndex ( List hidetabs , int indexAtual , int index ) { if ( tabs == null ) return index ; var tabIsHidden = hidetabs . contains ( tabs . get ( index ) ) ; if ( ! tabIsHidden ) return index ; var newIndex = index > indexAtual ? index + <NUM_LIT> : index - <NUM_LIT> ; if ( newIndex < <NUM_LIT> ) return <NUM_LIT> ; if ( newIndex >= tabs . size ( ) ) return indexAtual ; return getNewTabIndex ( hidetabs , indexAtual , newIndex ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . media . MediaScannerConnection ; import android . os . Environment ; import android . os . Handler ; import android . os . Looper ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . Properties ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import de . robv . android . xposed . XposedBridge ; public class Utils { private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; private static final ExecutorService executorCachedService = Executors . newCachedThreadPool ( ) ; @ NonNull public static Application getApplication ( ) { return FeatureLoader . mApp == null ? App . getInstance ( ) : FeatureLoader . mApp ; } public static ExecutorService getExecutor ( ) { return executorService ; } public static ExecutorService getExecutorCachedService ( ) { return executorCachedService ; } public static boolean doRestart ( Context context ) { PackageManager packageManager = context . getPackageManager ( ) ; Intent intent = packageManager . getLaunchIntentForPackage ( context . getPackageName ( ) ) ; if ( intent == null ) return false ; ComponentName componentName = intent . getComponent ( ) ; Intent mainIntent = Intent . makeRestartActivityTask ( componentName ) ; mainIntent . setPackage ( context . getPackageName ( ) ) ; context . startActivity ( mainIntent ) ; Runtime . getRuntime ( ) . exit ( <NUM_LIT> ) ; return true ; } @ SuppressLint ( "<STR_LIT>" ) public static int getID ( String name , String type ) { try { return getApplication ( ) . getApplicationContext ( ) . getResources ( ) . getIdentifier ( name , type , getApplication ( ) . getPackageName ( ) ) ; } catch ( Exception e ) { XposedBridge . log ( "<STR_LIT>" + name + "<STR_LIT>" + type + "<STR_LIT>" + e ) ; return - <NUM_LIT> ; } } public static int dipToPixels ( float dipValue ) { DisplayMetrics metrics = FeatureLoader . mApp . getResources ( ) . getDisplayMetrics ( ) ; return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dipValue , metrics ) ; } public static String getMyNumber ( ) { return FeatureLoader . mApp . getSharedPreferences ( FeatureLoader . mApp . getPackageName ( ) + "<STR_LIT>" , Context . MODE_PRIVATE ) . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static String getDateTimeFromMillis ( long timestamp ) { return new SimpleDateFormat ( "<STR_LIT>" , Locale . ENGLISH ) . format ( new Date ( timestamp ) ) ; } public static String getDestination ( SharedPreferences prefs , String name ) { var folderPath = prefs . getString ( "<STR_LIT>" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "<STR_LIT>" ) + "<STR_LIT>" + name + "<STR_LIT>" ; var filePath = new File ( folderPath ) ; if ( ! filePath . exists ( ) ) filePath . mkdirs ( ) ; return filePath . getAbsolutePath ( ) + "<STR_LIT>" ; } public static String copyFile ( File srcFile , File destFile ) { if ( srcFile == null || ! srcFile . exists ( ) ) return "<STR_LIT>" ; try ( FileInputStream in = new FileInputStream ( srcFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; Utils . scanFile ( destFile ) ; return "<STR_LIT>" ; } out . write ( bArr , <NUM_LIT> , read ) ; } } catch ( IOException e ) { XposedBridge . log ( e . getMessage ( ) ) ; return e . getMessage ( ) ; } } public static void showToast ( String message , int length ) { if ( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) { Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ) ; } } public static void setToClipboard ( String string ) { ClipboardManager clipboard = ( ClipboardManager ) Utils . getApplication ( ) . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , string ) ; clipboard . setPrimaryClip ( clip ) ; } public static String generateName ( Object userJid , String fileFormat ) { var contactName = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; return toValidFileName ( contactName ) + "<STR_LIT>" + number + "<STR_LIT>" + new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + "<STR_LIT>" + fileFormat ; } public static Object getDefaultValue ( Class < ? > paramType ) { if ( paramType == int . class || paramType == Integer . class ) { return <NUM_LIT> ; } else if ( paramType == long . class || paramType == Long . class ) { return <NUM_LIT> ; } else if ( paramType == double . class || paramType == Double . class ) { return <NUM_LIT> ; } else if ( paramType == boolean . class || paramType == Boolean . class ) { return false ; } return null ; } @ NonNull public static String toValidFileName ( @ NonNull String input ) { return input . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static void scanFile ( File file ) { MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { file . getAbsolutePath ( ) } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( s , uri ) -> { } ) ; } public static Properties extractProperties ( String text ) { Properties properties = new Properties ( ) ; Pattern pattern = Pattern . compile ( "<STR_LIT>" , Pattern . DOTALL ) ; Matcher matcher = pattern . matcher ( text ) ; if ( matcher . find ( ) ) { String propertiesText = matcher . group ( <NUM_LIT> ) ; String [ ] lines = propertiesText . split ( "<STR_LIT>" ) ; for ( String line : lines ) { String [ ] keyValue = line . split ( "<STR_LIT>" ) ; String key = keyValue [ <NUM_LIT> ] . strip ( ) ; String value = keyValue [ <NUM_LIT> ] . strip ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; properties . put ( key , value ) ; } } return properties ; } public static int tryParseInt ( String wallpaperAlpha , int i ) { try { return Integer . parseInt ( wallpaperAlpha . trim ( ) ) ; } catch ( Exception e ) { return i ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class DndMode extends Feature { public DndMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { if ( ! WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ) return ; var dndMethod = Unobfuscator . loadDndModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( dndMethod ) ) ; XposedBridge . hookMethod ( dndMethod , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . NonNull ; import java . util . HashSet ; public class DelMessageStore extends SQLiteOpenHelper { private static DelMessageStore mInstance ; private DelMessageStore ( @ NonNull Context context ) { super ( context , "<STR_LIT>" , null , <NUM_LIT> ) ; } public static DelMessageStore getInstance ( Context ctx ) { synchronized ( DelMessageStore . class ) { if ( mInstance == null || ! mInstance . getWritableDatabase ( ) . isOpen ( ) ) { mInstance = new DelMessageStore ( ctx ) ; } } return mInstance ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { if ( oldVersion < <NUM_LIT> ) { if ( ! checkColumnExists ( sqLiteDatabase , "<STR_LIT>" , "<STR_LIT>" ) ) { sqLiteDatabase . execSQL ( "<STR_LIT>" ) ; } } } public void insertMessage ( String jid , String msgid , long timestamp ) { try ( SQLiteDatabase dbWrite = this . getWritableDatabase ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , jid ) ; values . put ( "<STR_LIT>" , msgid ) ; values . put ( "<STR_LIT>" , timestamp ) ; dbWrite . insert ( "<STR_LIT>" , null , values ) ; } } public HashSet < String > getMessagesByJid ( String jid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; Cursor query = dbReader . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { jid } , null , null , null ) ; HashSet < String > messages = new HashSet < > ( ) ; try { if ( query . moveToFirst ( ) ) { do { messages . add ( query . getString ( query . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ) ; } while ( query . moveToNext ( ) ) ; } } finally { query . close ( ) ; dbReader . close ( ) ; } return messages ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { sqLiteDatabase . execSQL ( "<STR_LIT>" ) ; } public long getTimestampByMessageId ( String msgid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; try ( dbReader ; Cursor query = dbReader . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { msgid } , null , null , null ) ) { if ( query . moveToFirst ( ) ) { return query . getLong ( query . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; } return <NUM_LIT> ; } } private boolean checkColumnExists ( SQLiteDatabase db , String tableName , String columnName ) { try ( Cursor cursor = db . rawQuery ( "<STR_LIT>" + tableName + "<STR_LIT>" , null ) ) { if ( cursor != null ) { int nameIndex = cursor . getColumnIndex ( "<STR_LIT>" ) ; while ( cursor . moveToNext ( ) ) { String currentColumnName = cursor . getString ( nameIndex ) ; if ( columnName . equals ( currentColumnName ) ) { return true ; } } } } catch ( Exception ignored ) { } return false ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . devkit ; import android . app . Activity ; import android . content . ContentValues ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . NinePatchDrawable ; import android . net . Uri ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . TextView ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . luckypray . dexkit . DexKitBridge ; import org . luckypray . dexkit . query . FindClass ; import org . luckypray . dexkit . query . FindMethod ; import org . luckypray . dexkit . query . enums . StringMatchType ; import org . luckypray . dexkit . query . matchers . ClassMatcher ; import org . luckypray . dexkit . query . matchers . MethodMatcher ; import org . luckypray . dexkit . query . matchers . base . OpCodesMatcher ; import org . luckypray . dexkit . result . ClassData ; import org . luckypray . dexkit . result . ClassDataList ; import org . luckypray . dexkit . result . MethodData ; import org . luckypray . dexkit . result . MethodDataList ; import org . luckypray . dexkit . result . UsingFieldData ; import org . luckypray . dexkit . util . DexSignUtil ; import java . io . File ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . Timer ; import java . util . TimerTask ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Unobfuscator { private static DexKitBridge dexkit ; public static final String BUBBLE_COLORS_BALLOON_INCOMING_NORMAL = "<STR_LIT>" ; public static final String BUBBLE_COLORS_BALLOON_INCOMING_NORMAL_EXT = "<STR_LIT>" ; public static final HashMap < String , Object > cache = new HashMap < > ( ) ; static { System . loadLibrary ( "<STR_LIT>" ) ; } public static boolean initDexKit ( String path ) { try { dexkit = DexKitBridge . create ( path ) ; } catch ( Exception e ) { return false ; } return true ; } public static Method findFirstMethodUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) throws Exception { MethodMatcher matcher = new MethodMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } MethodDataList result = dexkit . findMethod ( new FindMethod ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return null ; for ( MethodData methodData : result ) { if ( methodData . isMethod ( ) ) return methodData . getMethodInstance ( classLoader ) ; } throw new NoSuchMethodException ( ) ; } public static Method [ ] findAllMethodUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) { MethodMatcher matcher = new MethodMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } MethodDataList result = dexkit . findMethod ( new FindMethod ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return new Method [ <NUM_LIT> ] ; return result . stream ( ) . filter ( MethodData :: isMethod ) . map ( methodData -> { try { return methodData . getMethodInstance ( classLoader ) ; } catch ( NoSuchMethodException e ) { return null ; } } ) . filter ( Objects :: nonNull ) . toArray ( Method [ ] :: new ) ; } public static Class < ? > findFirstClassUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) throws Exception { var matcher = new ClassMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } var result = dexkit . findClass ( new FindClass ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return null ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( type ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static String getMethodDescriptor ( Method method ) { if ( method == null ) return null ; return method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + method . getName ( ) + "<STR_LIT>" + Arrays . stream ( method . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) + "<STR_LIT>" ; } public static String getConstructorDescriptor ( Constructor constructor ) { if ( constructor == null ) return null ; return constructor . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + constructor . getName ( ) + "<STR_LIT>" + Arrays . stream ( constructor . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) + "<STR_LIT>" ; } public static String getFieldDescriptor ( Field field ) { return field . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + field . getName ( ) + "<STR_LIT>" + field . getType ( ) . getName ( ) ; } public static boolean isCalledFromClass ( Class < ? > cls ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; for ( StackTraceElement stackTraceElement : trace ) { if ( stackTraceElement . getClassName ( ) . equals ( cls . getName ( ) ) ) return true ; } return false ; } public static boolean isCalledFromMethod ( Method method ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; for ( StackTraceElement stackTraceElement : trace ) { if ( stackTraceElement . getClassName ( ) . equals ( method . getDeclaringClass ( ) . getName ( ) ) && stackTraceElement . getMethodName ( ) . equals ( method . getName ( ) ) ) return true ; } return false ; } public static Method loadFreezeSeenMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ) ) ; } public static Method loadGhostModeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; if ( method . getParameterTypes ( ) . length > <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == int . class ) return method ; throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadReceiptMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method [ ] methods = findAllMethodUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; var deviceJidClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; Method bestMethod = Arrays . stream ( methods ) . filter ( method -> method . getParameterTypes ( ) . length > <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == deviceJidClass ) . findFirst ( ) . orElse ( null ) ; if ( bestMethod == null ) throw new Exception ( "<STR_LIT>" ) ; return bestMethod ; } ) ; } public static Method loadReceiptOutsideChat ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = loadReceiptMethod ( classLoader ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; var classData = dexkit . getClassData ( method . getDeclaringClass ( ) ) ; if ( classData == null ) throw new Exception ( "<STR_LIT>" ) ; var methodResult = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( methodResult . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodResult . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadReceiptInChat ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = loadReceiptMethod ( classLoader ) ; var methodDataList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . addUsingNumber ( <NUM_LIT> ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method ) ) ) ) ; if ( methodDataList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodDataList . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadForwardTagMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > messageInfoClass = loadFMessageClass ( classLoader ) ; var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( methodList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; var invokes = methodList . get ( <NUM_LIT> ) . getInvokes ( ) ; for ( var invoke : invokes ) { var method = invoke . getMethodInstance ( classLoader ) ; if ( method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == int . class && method . getDeclaringClass ( ) == messageInfoClass && method . getReturnType ( ) == void . class ) { return method ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Class < ? > loadForwardClassMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ) ; } public static Method loadHideViewSendReadJob ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var classData = dexkit . getClassData ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ; var methodResult = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Equals ) ) ) ; if ( methodResult . isEmpty ( ) ) { methodResult = classData . getSuperClass ( ) . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Equals ) ) ) ; } if ( methodResult . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodResult . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadHideViewInChatMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadHideViewMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadHideViewAudioMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Class < ? > loadFMessageClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var messageClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( messageClass == null ) throw new Exception ( "<STR_LIT>" ) ; return messageClass ; } ) ; } public static Method loadTabListMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > classMain = findFirstClassUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" ) ; if ( classMain == null ) throw new Exception ( "<STR_LIT>" ) ; Method method = Arrays . stream ( classMain . getMethods ( ) ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadTabFragmentMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > clsFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; Method result = Arrays . stream ( clsFrag . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getReturnType ( ) . equals ( List . class ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadTabNameMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method tabListMethod = loadGetTabMethod ( classLoader ) ; Class < ? > cls = tabListMethod . getDeclaringClass ( ) ; if ( Modifier . isAbstract ( cls . getModifiers ( ) ) ) { var findClass = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( cls . getName ( ) ) . addUsingString ( "<STR_LIT>" ) ) ) ; cls = findClass . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } Method result = Arrays . stream ( cls . getMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getReturnType ( ) . equals ( String . class ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadFabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > cls = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; List < ClassData > classes = List . of ( dexkit . getClassData ( cls ) ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( classes ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . usingNumbers ( <NUM_LIT> ) . returnType ( int . class ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadIconTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconTabField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > cls = loadIconTabMethod ( classLoader ) . getDeclaringClass ( ) ; Class < ? > clsType = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var result = Arrays . stream ( cls . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( clsType ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconTabLayoutField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > clsType = loadIconTabField ( classLoader ) . getType ( ) ; Class < ? > framelayout = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var result = Arrays . stream ( clsType . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( framelayout ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconMenuField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > clsType = loadIconTabLayoutField ( classLoader ) . getType ( ) ; Class < ? > menuClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; return Arrays . stream ( clsType . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( menuClass ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadTabCountMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadEnableCountTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Constructor loadEnableCountTabConstructor1 ( ClassLoader classLoader ) throws Exception { var countMethod = loadEnableCountTabMethod ( classLoader ) ; var indiceClass = countMethod . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Constructor loadEnableCountTabConstructor2 ( ClassLoader classLoader ) throws Exception { var countTabConstructor1 = loadEnableCountTabConstructor1 ( classLoader ) ; var indiceClass = countTabConstructor1 . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Constructor loadEnableCountTabConstructor3 ( ClassLoader classLoader ) throws Exception { var countTabConstructor1 = loadEnableCountTabConstructor1 ( classLoader ) ; var indiceClass = countTabConstructor1 . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Method loadTimeToSecondsMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > cls = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( cls == null ) throw new Exception ( "<STR_LIT>" ) ; var clsData = dexkit . getClassData ( cls ) ; var method = XposedHelpers . findMethodBestMatch ( Calendar . class , "<STR_LIT>" , long . class ) ; var result = clsData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method ) ) . returnType ( String . class ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadDndModeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } private static Class < ? > loadMediaQualityClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazzMediaClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazzMediaClass == null ) throw new Exception ( "<STR_LIT>" ) ; return clazzMediaClass ; } ) ; } public static Method loadMediaQualityResolutionMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadMediaQualityClass ( classLoader ) ; return Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadMediaQualityBitrateMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadMediaQualityClass ( classLoader ) ; return Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getReturnType ( ) . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadMediaQualityVideoMethod2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class loadMediaQualityVideoLimitClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadShareLimitMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadShareMapItemField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var shareLimitMethod = loadShareLimitMethod ( classLoader ) ; var methodData = dexkit . getMethodData ( shareLimitMethod ) ; var usingFields = Objects . requireNonNull ( methodData ) . getUsingFields ( ) ; for ( var ufield : usingFields ) { var field = ufield . getField ( ) . getFieldInstance ( classLoader ) ; if ( field . getType ( ) == Map . class ) return field ; } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadStatusActivePage ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class < ? > loadStatusDownloadMediaClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadMenuStatusClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( id ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadMenuStatusMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) ) ) ; if ( methods . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methods . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadStatusDownloadFileField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var clazz = loadStatusDownloadMediaClass ( classLoader ) ; var clazz2 = clazz . getField ( "<STR_LIT>" ) . getType ( ) ; var field = getFieldByType ( clazz2 , File . class ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Class < ? > loadStatusDownloadSubMenuClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var classes = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Contains ) . returnType ( void . class ) ) ) ) ; if ( classes . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classes . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } ) ; } public static Class < ? > loadStatusDownloadMenuClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method [ ] loadViewOnceMethod ( ClassLoader classLoader ) throws Exception { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Contains ) ) ) ; if ( method . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; var methodData = method . get ( <NUM_LIT> ) ; var listMethods = methodData . getInvokes ( ) ; var list = new ArrayList < Method > ( ) ; for ( MethodData m : listMethods ) { var mInstance = m . getMethodInstance ( classLoader ) ; if ( mInstance . getDeclaringClass ( ) . isInterface ( ) && mInstance . getDeclaringClass ( ) . getMethods ( ) . length == <NUM_LIT> ) { ClassDataList listClasses = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addInterface ( mInstance . getDeclaringClass ( ) . getName ( ) ) ) ) ; for ( ClassData c : listClasses ) { Class < ? > clazz = c . getInstance ( classLoader ) ; var resultMethod = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m1 -> m1 . getParameterCount ( ) == <NUM_LIT> && m1 . getReturnType ( ) . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; if ( resultMethod == null ) continue ; list . add ( resultMethod ) ; } return list . toArray ( new Method [ <NUM_LIT> ] ) ; } } throw new Exception ( "<STR_LIT>" ) ; } public static Class loadViewOnceClass ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } public static Method loadViewOnceStoreMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } public static Method loadViewOnceDownloadMenuMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , Menu . class ) && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , MenuInflater . class ) && m . getDeclaringClass ( ) == clazz ) . findFirst ( ) ; if ( ! method . isPresent ( ) ) throw new Exception ( "<STR_LIT>" ) ; return method . get ( ) ; } ) ; } public static Field loadViewOnceDownloadMenuField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var method = loadViewOnceDownloadMenuMethod ( classLoader ) ; var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var methodData = dexkit . getMethodData ( method ) ; var fields = methodData . getUsingFields ( ) ; for ( UsingFieldData field : fields ) { Field field1 = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( field1 . getType ( ) == int . class && field1 . getDeclaringClass ( ) == clazz ) { return field1 ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Field loadViewOnceDownloadMenuField2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var methodData = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) . get ( <NUM_LIT> ) ; var clazz = methodData . getMethodInstance ( classLoader ) . getDeclaringClass ( ) ; var fields = methodData . getUsingFields ( ) ; for ( UsingFieldData field : fields ) { Field field1 = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( field1 . getType ( ) == int . class && field1 . getDeclaringClass ( ) == clazz ) { return field1 ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadViewOnceDownloadMenuCallMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> ( ( m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , int . class ) && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , clazz ) ) || ( m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , int . class ) ) ) && Modifier . isPublic ( m . getModifiers ( ) ) && Object . class . isAssignableFrom ( m . getReturnType ( ) ) ) . findFirst ( ) ; if ( ! method . isPresent ( ) ) throw new Exception ( "<STR_LIT>" ) ; return method . get ( ) ; } ) ; } public static Class < ? > loadExpandableWidgetClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class < ? > loadMaterialShapeDrawableClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class < ? > loadCustomDrawableClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadPropsBooleanMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPropsIntegerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPropsJsonMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } private static ClassData loadAntiRevokeImplClass ( ) throws Exception { var classes = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( classes . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classes . get ( <NUM_LIT> ) ; } public static Method loadAntiRevokeOnStartMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var classData = loadAntiRevokeImplClass ( ) ; MethodDataList mdOnStart = dexkit . findMethod ( FindMethod . create ( ) . searchInClass ( List . of ( dexkit . getClassData ( conversation ) ) ) . matcher ( MethodMatcher . create ( ) . addInvoke ( Objects . requireNonNull ( classData ) . getDescriptor ( ) + "<STR_LIT>" ) ) ) ; if ( mdOnStart . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return mdOnStart . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadAntiRevokeConvChatField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > chatClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; Field field = getFieldByType ( conversation , chatClass ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Field loadAntiRevokeChatJidField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > chatClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; Class < ? > jidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; Field field = getFieldByExtendType ( chatClass , jidClass ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Method loadAntiRevokeMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Method method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadMessageKeyField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . fieldCount ( <NUM_LIT> ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . name ( "<STR_LIT>" ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; for ( ClassData classData : classList ) { Class < ? > keyMessageClass = classData . getInstance ( loader ) ; var classMessage = loadFMessageClass ( loader ) ; var fields = ReflectionUtils . getFieldsByExtendType ( classMessage , keyMessageClass ) ; if ( fields . isEmpty ( ) ) continue ; return fields . get ( fields . size ( ) - <NUM_LIT> ) ; } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadAntiRevokeBubbleMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > bubbleClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( bubbleClass == null ) throw new Exception ( "<STR_LIT>" ) ; var result = Arrays . stream ( bubbleClass . getMethods ( ) ) . filter ( m -> m . getParameterCount ( ) > <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] == ViewGroup . class && m . getParameterTypes ( ) [ <NUM_LIT> ] == TextView . class ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadUnknownStatusPlaybackMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var statusPlaybackClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var classData = List . of ( dexkit . getClassData ( statusPlaybackClass ) ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( classData ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadStatusPlaybackViewField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > class1 = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; ClassDataList classView = dexkit . findClass ( FindClass . create ( ) . matcher ( ClassMatcher . create ( ) . methodCount ( <NUM_LIT> ) . addFieldForType ( class1 ) ) ) ; if ( classView . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; Class < ? > clsViewStatus = classView . get ( <NUM_LIT> ) . getInstance ( loader ) ; Class < ? > class2 = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; return Arrays . stream ( class2 . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) == clsViewStatus ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Class < ? > loadMessageStoreClass2 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var result = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadBlueOnReplayMessageJobMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadBlueOnReplayWaJobManagerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var job = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; var method = Arrays . stream ( result . getMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] == job ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method [ ] loadArchiveHideViewMethod ( ClassLoader loader ) throws Exception { if ( cache . containsKey ( "<STR_LIT>" ) ) return ( Method [ ] ) cache . get ( "<STR_LIT>" ) ; var methods = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( methods . length == <NUM_LIT> ) throw new Exception ( "<STR_LIT>" ) ; ArrayList < Method > result = new ArrayList < > ( ) ; for ( var m : methods ) { result . add ( m . getDeclaringClass ( ) . getMethod ( "<STR_LIT>" , boolean . class ) ) ; } var resultArray = result . toArray ( new Method [ <NUM_LIT> ] ) ; cache . put ( "<STR_LIT>" , resultArray ) ; return resultArray ; } public static Method loadAntiRevokeOnCallReceivedMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetContactInfoMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > class1 = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( class1 == null ) throw new Exception ( "<STR_LIT>" ) ; var jidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var result = ReflectionUtils . findMethodUsingFilter ( class1 , m -> m . getParameterCount ( ) == <NUM_LIT> && jidClass . isAssignableFrom ( m . getParameterTypes ( ) [ <NUM_LIT> ] ) && m . getReturnType ( ) != void . class ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadOnChangeStatus ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Method [ ] methods = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var method = Arrays . stream ( methods ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadViewHolderField1 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > class1 = loadOnChangeStatus ( loader ) . getDeclaringClass ( ) . getSuperclass ( ) ; Class < ? > classViewHolder = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; return getFieldByType ( class1 , classViewHolder ) ; } ) ; } public static Method loadStatusUserMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var id = UnobfuscatorCache . getInstance ( ) . getOfuscateIDString ( "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadSendPresenceMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPinnedLimitMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPinnedHashSetMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getReturnType ( ) . equals ( Set . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetFiltersMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazzFilters = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazzFilters == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return Arrays . stream ( clazzFilters . getDeclaredMethods ( ) ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadPinnedInChatMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . returnType ( int . class ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadBlueOnReplayCreateMenuConversationMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var conversationClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; if ( conversationClass == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( conversationClass . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( Menu . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadBlueOnReplayViewButtonMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadBlueOnReplayStatusViewMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadChatLimitDeleteMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getReturnType ( ) . equals ( long . class ) && Modifier . isStatic ( m . getModifiers ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) { var methodList = Objects . requireNonNull ( dexkit . getClassData ( clazz ) ) . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . opCodes ( new OpCodesMatcher ( ) . opNames ( List . of ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; method = methodList . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } return method ; } ) ; } public static Method loadChatLimitDelete2Method ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadNewMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazzMessage = loadFMessageClass ( loader ) ; var clazzData = Objects . requireNonNull ( dexkit . getClassData ( clazzMessage ) ) ; var methodData = clazzData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) { var field = clazzMessage . getDeclaredField ( "<STR_LIT>" ) ; methodData = clazzData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field ) ) . returnType ( String . class ) ) ) ; } if ( methodData . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodData . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadNewMessageWithMediaMethod ( ClassLoader loader ) throws Exception { var clazzMessage = Objects . requireNonNull ( dexkit . getClassData ( loadFMessageClass ( loader ) ) ) ; var methodData = clazzMessage . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) { methodData = clazzMessage . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) return null ; } return methodData . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } public static Method loadMessageEditMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetEditMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; if ( methodData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( invoke . getParamTypes ( ) . isEmpty ( ) && Objects . equals ( invoke . getDeclaredClass ( ) , methodData . getParamTypes ( ) . get ( <NUM_LIT> ) ) ) { return invoke . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadSetEditMessageField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var classData = dexkit . getClassData ( loadFMessageClass ( loader ) ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var usingFields = methodData . getUsingFields ( ) ; for ( var f : usingFields ) { var field = f . getField ( ) ; if ( field . getDeclaredClass ( ) . equals ( classData ) && field . getType ( ) . getName ( ) . equals ( long . class . getName ( ) ) ) { return field . getFieldInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadEditMessageShowMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var fields = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( TextView . class ) ) . toArray ( Field [ ] :: new ) ; var classData = dexkit . getClassData ( clazz ) ; if ( fields . length == <NUM_LIT> ) throw new RuntimeException ( "<STR_LIT>" ) ; for ( var field : fields ) { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field ) ) . paramCount ( <NUM_LIT> ) ) . searchInClass ( List . of ( classData ) ) ) ; if ( ! result . isEmpty ( ) ) return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadEditMessageViewField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = loadEditMessageShowMethod ( loader ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var fields = methodData . getUsingFields ( ) ; for ( var ufield : fields ) { var field = ufield . getField ( ) ; if ( field . getType ( ) . getName ( ) . equals ( TextView . class . getName ( ) ) ) { return field . getFieldInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Class loadDialogViewClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) . returnType ( FrameLayout . class ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getDeclaredClass ( ) . getInstance ( loader ) ; } ) ; } public static Constructor loadRecreateFragmentConstructor ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( loader , ( ) -> { var data = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( data . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; if ( ! data . single ( ) . isConstructor ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return data . single ( ) . getConstructorInstance ( loader ) ; } ) ; } public static Method loadOnTabItemAddMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadScrollPagerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( result ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetViewConversationMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getReturnType ( ) . equals ( View . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( LayoutInflater . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadOnMenuItemSelected ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var aClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var result = Arrays . stream ( aClass . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( boolean . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( boolean . class ) ) . collect ( Collectors . toList ( ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) ; } ) ; } public static Method loadOnUpdateStatusChanged ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var clazzData = dexkit . getClassData ( clazz ) ; var methodSeduleche = XposedHelpers . findMethodBestMatch ( Timer . class , "<STR_LIT>" , TimerTask . class , long . class , long . class ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( List . of ( clazzData ) ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( methodSeduleche ) ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadGetInvokeField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = loadOnUpdateStatusChanged ( loader ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var fields = methodData . getUsingFields ( ) ; var field = fields . stream ( ) . map ( UsingFieldData :: getField ) . filter ( f -> f . getDeclaredClass ( ) . equals ( methodData . getDeclaredClass ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( field == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return field . getFieldInstance ( loader ) ; } ) ; } public static Class < ? > loadStatusInfoClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadStatusListUpdatesClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadTabFrameClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static List < Method > loadNineDrawableMethods ( ClassLoader loader ) throws Exception { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . returnType ( NinePatchDrawable . class ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) return Collections . emptyList ( ) ; var arr = new ArrayList < Method > ( ) ; for ( var m : result ) { if ( m . isMethod ( ) ) arr . add ( m . getMethodInstance ( loader ) ) ; } return arr ; } public static Class loadOnMenuItemClickClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadOnMenuItemClickClass2 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadRemoveChannelRecClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadFilterAdaperClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazzList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) ) ) ) ; if ( clazzList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazzList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadSeeMoreMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) . addParamType ( boolean . class ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var clazzData = classList . get ( <NUM_LIT> ) ; XposedBridge . log ( clazzData . toString ( ) ) ; for ( var method : clazzData . getMethods ( ) ) { if ( method . getParamCount ( ) == <NUM_LIT> && method . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( int . class . getName ( ) ) && method . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( boolean . class . getName ( ) ) ) { return method . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadSendStickerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadMaterialAlertDialog ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var callConfirmationFragment = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = ReflectionUtils . findMethodUsingFilter ( callConfirmationFragment , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( android . os . Bundle . class ) ) ; var methodData = dexkit . getMethodData ( method ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( invoke . isMethod ( ) && Modifier . isStatic ( invoke . getModifiers ( ) ) && invoke . getParamCount ( ) == <NUM_LIT> && invoke . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( Context . class . getName ( ) ) ) { return invoke . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadGetIntPreferences ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( SharedPreferences . class ) . addParamType ( String . class ) . modifiers ( Modifier . STATIC | Modifier . PUBLIC ) . returnType ( int . class ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodList . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadProfileInfoField ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var fieldList = ReflectionUtils . getFieldsByExtendType ( clazz , XposedHelpers . findClass ( "<STR_LIT>" , loader ) ) ; if ( fieldList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return fieldList . get ( <NUM_LIT> ) ; } public static Method loadProximitySensorMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGroupAdminMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadJidFactory ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadGroupCheckAdminMethod ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var userJidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var methods = ReflectionUtils . findAllMethodsUsingFilter ( clazz , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( userJidClass ) && m . getReturnType ( ) . equals ( boolean . class ) ) ; if ( methods == null || methods . length == <NUM_LIT> ) throw new RuntimeException ( "<STR_LIT>" ) ; return methods [ methods . length - <NUM_LIT> ] ; } public static Constructor loadStartPrefsConfig ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( loader , ( ) -> { var results = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getConstructorInstance ( loader ) ; } ) ; } public static Method loadCheckOnlineMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadEphemeralInsertdb ( ClassLoader loader ) throws Exception { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . returnType ( ContentValues . class ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var methodData = method . get ( <NUM_LIT> ) ; return methodData . getMethodInstance ( loader ) ; } public static Method loadDefEmojiClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class loadVideoViewContainerClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadImageVewContainerClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazzList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) . addUsingNumber ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) ) ; if ( clazzList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazzList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Class loadMediaQualityProcessor ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method getFilterInitMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( loader ) ; var constructor = filterAdaperClass . getConstructors ( ) [ <NUM_LIT> ] ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( constructor ) ) ) ) ; if ( methods . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = methods . stream ( ) . filter ( m -> m . getParamCount ( ) == <NUM_LIT> && m . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( cFrag . getName ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . getMethodInstance ( loader ) ; } ) ; } public static Class getFilterView ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var results = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . name ( "<STR_LIT>" ) ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Class loadActionUser ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var results = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadOnPlaybackFinished ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadNextStatusRunMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . name ( "<STR_LIT>" ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodList . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadOnInsertReceipt ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadSendAudioTypeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = classLoader . loadClass ( "<STR_LIT>" ) . getMethod ( "<STR_LIT>" , int . class , int . class , android . content . Intent . class ) ; var methodData = dexkit . getMethodData ( method ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( ! invoke . isMethod ( ) ) continue ; var m1 = invoke . getMethodInstance ( classLoader ) ; var params = Arrays . asList ( m1 . getParameterTypes ( ) ) ; if ( params . contains ( List . class ) && params . contains ( int . class ) && params . contains ( boolean . class ) && params . contains ( Uri . class ) ) { return m1 ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadOriginFMessageField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . paramCount ( <NUM_LIT> ) . returnType ( boolean . class ) ) ) ; var clazz = loadFMessageClass ( classLoader ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var fields = result . get ( <NUM_LIT> ) . getUsingFields ( ) ; for ( var field : fields ) { var f = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( f . getDeclaringClass ( ) . equals ( clazz ) ) { return f ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadForwardAudioTypeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return result ; } ) ; } public static Class loadFragmentLoader ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadShowDialogStatusMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadFragmentLoader ( classLoader ) ; var frag = classLoader . loadClass ( "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( frag ) . addParamType ( clazz ) . returnType ( void . class ) . modifiers ( Modifier . PUBLIC | Modifier . STATIC ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadPlaybackSpeed ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Constructor loadListUpdateItemsConstructor ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( classLoader , ( ) -> { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . returnType ( void . class ) . addParamType ( Object . class ) . addUsingNumber ( <NUM_LIT> ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . get ( <NUM_LIT> ) . getClassInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } ) ; } public static Class loadHeaderChannelItemClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadListChannelItemClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadTextStatusComposer ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method1 = Activity . class . getDeclaredMethod ( "<STR_LIT>" ) ; var method2 = View . class . getDeclaredMethod ( "<STR_LIT>" , Drawable . class ) ; var clazz = classLoader . loadClass ( "<STR_LIT>" ) ; var fieldInt = ReflectionUtils . findFieldUsingFilter ( clazz , field -> field . getType ( ) == int . class ) ; var classData = dexkit . getClassData ( clazz ) ; if ( classData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methods = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method1 ) ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method2 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( fieldInt ) ) . modifiers ( Modifier . PUBLIC | Modifier . STATIC ) ) ) ; if ( methods . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methods . get ( methods . size ( ) - <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadTextStatusComposer2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > TextDataClass = classLoader . loadClass ( "<STR_LIT>" ) ; var clazz = classLoader . loadClass ( "<STR_LIT>" ) ; var field1 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var field2 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var field3 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var classData = dexkit . getClassData ( clazz ) ; if ( classData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field1 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field2 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field3 ) ) . modifiers ( Modifier . PUBLIC ) ) ) ; for ( var method : methods ) { var callers = method . getCallers ( ) ; if ( callers . stream ( ) . anyMatch ( methodData -> methodData . getDeclaredClassName ( ) . contains ( "<STR_LIT>" ) ) ) { return method . getMethodInstance ( classLoader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Class < ? > loadExpirationClass ( ClassLoader classLoader ) { var methods = findAllMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var expirationMethod = Arrays . stream ( methods ) . filter ( methodData -> methodData . getReturnType ( ) . equals ( Date . class ) ) . findFirst ( ) . orElse ( null ) ; if ( expirationMethod == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return expirationMethod . getDeclaringClass ( ) ; } public static Class < ? > loadMsgDatabaseClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var aClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( aClass == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return aClass ; } ) ; } public static Class < ? > loadAbsViewHolder ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadFragmentViewMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadCopiedMessageMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . components ; import android . content . ContextWrapper ; import android . content . SharedPreferences ; import androidx . annotation . Nullable ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; public class SharedPreferencesWrapper implements SharedPreferences { private final static HashSet < SPrefHook > prefHook = new HashSet < > ( ) ; private final SharedPreferences mPreferences ; public SharedPreferencesWrapper ( SharedPreferences sharedPreferences ) { mPreferences = sharedPreferences ; } @ Override public Map < String , ? > getAll ( ) { return mPreferences . getAll ( ) ; } @ Nullable @ Override public String getString ( String s , @ Nullable String s1 ) { var value = mPreferences . getString ( s , s1 ) ; return ( String ) hookValue ( s , value ) ; } @ Nullable @ Override public Set < String > getStringSet ( String s , @ Nullable Set < String > set ) { var value = mPreferences . getStringSet ( s , set ) ; return ( Set < String > ) hookValue ( s , value ) ; } @ Override public int getInt ( String s , int i ) { var value = mPreferences . getInt ( s , i ) ; return ( int ) hookValue ( s , value ) ; } @ Override public long getLong ( String s , long l ) { var value = mPreferences . getLong ( s , l ) ; return ( long ) hookValue ( s , value ) ; } @ Override public float getFloat ( String s , float v ) { var value = mPreferences . getFloat ( s , v ) ; return ( float ) hookValue ( s , value ) ; } @ Override public boolean getBoolean ( String s , boolean b ) { var value = mPreferences . getBoolean ( s , b ) ; return ( boolean ) hookValue ( s , value ) ; } @ Override public boolean contains ( String s ) { return mPreferences . contains ( s ) ; } @ Override public Editor edit ( ) { return mPreferences . edit ( ) ; } @ Override public void registerOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . registerOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; } @ Override public void unregisterOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . unregisterOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; } public static void hookInit ( ClassLoader classLoader ) { XposedHelpers . findAndHookMethod ( ContextWrapper . class . getName ( ) , classLoader , "<STR_LIT>" , String . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pref = ( SharedPreferences ) param . getResult ( ) ; if ( pref instanceof SharedPreferencesWrapper ) return ; param . setResult ( new SharedPreferencesWrapper ( pref ) ) ; } } ) ; } public static void addHook ( SPrefHook hook ) { prefHook . add ( hook ) ; } private Object hookValue ( String key , Object value ) { for ( SPrefHook hook : prefHook ) { value = hook . hookValue ( key , value ) ; } return value ; } public interface SPrefHook { @ Nullable Object hookValue ( String key , Object value ) ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . ViewGroup ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CompletableFuture ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import kotlin . io . FilesKt ; import rikka . core . util . IOUtils ; public class TextEditorActivity extends AppCompatActivity { private String folderName ; private ActivityResultLauncher < String > mGetContent ; private ActivityResultLauncher < String > mExportFile ; private WebView webView ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; super . onCreate ( savedInstanceState ) ; webView = new WebView ( this ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . getSettings ( ) . setAllowContentAccess ( true ) ; webView . getSettings ( ) . setDomStorageEnabled ( true ) ; webView . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( true ) ; webView . getSettings ( ) . setJavaScriptCanOpenWindowsAutomatically ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) ) ; webView . setWebChromeClient ( new WebChromeClient ( ) ) ; updateWebViewContent ( "<STR_LIT>" ) ; setContentView ( webView , new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; mGetContent = registerForActivityResult ( new ActivityResultContracts . GetContent ( ) , this :: onUriSelected ) ; mExportFile = registerForActivityResult ( new ActivityResultContracts . CreateDocument ( "<STR_LIT>" ) , this :: exportAsZip ) ; folderName = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { readFile ( folderName ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void updateWebViewContent ( String newContent ) { if ( webView != null ) { try { var inputStream = getAssets ( ) . open ( "<STR_LIT>" ) ; var code = IOUtils . toString ( inputStream ) ; code = code . replace ( "<STR_LIT>" , newContent ) ; webView . loadDataWithBaseURL ( "<STR_LIT>" , code , "<STR_LIT>" , "<STR_LIT>" , null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } private CompletableFuture < String > getTextareaContentAsync ( ) { CompletableFuture < String > future = new CompletableFuture < > ( ) ; if ( webView != null ) { webView . evaluateJavascript ( "<STR_LIT>" , content -> { if ( content != null ) { content = content . substring ( <NUM_LIT> , content . length ( ) - <NUM_LIT> ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } future . complete ( content ) ; } ) ; } else { future . completeExceptionally ( new Exception ( "<STR_LIT>" ) ) ; } return future ; } private void readFile ( String folderName ) { try { File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , "<STR_LIT>" ) ; if ( cssCode . exists ( ) ) { var code = FilesKt . readText ( cssCode , Charset . defaultCharset ( ) ) ; updateWebViewContent ( code ) ; } else { cssCode . createNewFile ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . css_editor_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . menuitem_save -> { try { getTextareaContentAsync ( ) . thenAccept ( content -> { String code = content ; File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , "<STR_LIT>" ) ; FilesKt . writeText ( cssCode , code , Charset . defaultCharset ( ) ) ; Toast . makeText ( this , R . string . saved , Toast . LENGTH_SHORT ) . show ( ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; var key = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; if ( key != null && prefs . getString ( key , "<STR_LIT>" ) . equals ( folderName ) ) { prefs . edit ( ) . putString ( "<STR_LIT>" , code ) . commit ( ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } case R . id . menuitem_exit -> finish ( ) ; case R . id . menuitem_clear -> { updateWebViewContent ( "<STR_LIT>" ) ; } case R . id . menuitem_import_image -> { mGetContent . launch ( "<STR_LIT>" ) ; } case R . id . menuitem_export -> { mExportFile . launch ( folderName + "<STR_LIT>" ) ; } } return super . onOptionsItemSelected ( item ) ; } private void exportAsZip ( Uri uri ) { try ( var outputStream = getContentResolver ( ) . openOutputStream ( uri ) ) { var zipOutputStream = new ZipOutputStream ( outputStream ) ; var dir = ThemePreference . rootDirectory . getAbsolutePath ( ) + "<STR_LIT>" ; var folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; var files = getAllFilesPath ( folderFolder ) ; for ( File file : files ) { var name = file . getAbsolutePath ( ) . replace ( dir , "<STR_LIT>" ) ; zipOutputStream . putNextEntry ( new ZipEntry ( name ) ) ; var bytes = FilesKt . readBytes ( file ) ; zipOutputStream . write ( bytes ) ; zipOutputStream . closeEntry ( ) ; } zipOutputStream . close ( ) ; Toast . makeText ( this , R . string . exported , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , <NUM_LIT> ) ; } } private List < File > getAllFilesPath ( File folderFolder ) { File [ ] files = folderFolder . listFiles ( ) ; if ( files == null ) { return Collections . emptyList ( ) ; } ArrayList < File > list = new ArrayList < > ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { list . addAll ( getAllFilesPath ( file ) ) ; } else { list . add ( file ) ; } } return list ; } public void onUriSelected ( Uri uri ) { if ( uri == null ) { return ; } var linearLayout = new LinearLayout ( this ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; var input = new EditText ( this ) ; input . setHint ( "<STR_LIT>" ) ; input . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; linearLayout . addView ( input ) ; new AlertDialog . Builder ( this ) . setTitle ( R . string . enter_image_file_name ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { var fileName = input . getText ( ) . toString ( ) ; if ( fileName . endsWith ( "<STR_LIT>" ) ) { copyFromUri ( fileName , uri ) ; } else { Toast . makeText ( this , R . string . error_image_name , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . setView ( linearLayout ) . show ( ) ; } public void copyFromUri ( String fileName , Uri uri ) { var outFolder = new File ( ThemePreference . rootDirectory , folderName ) ; try ( InputStream inputStream = getContentResolver ( ) . openInputStream ( uri ) ) { Bitmap bitmap = BitmapFactory . decodeStream ( inputStream ) ; var outFile = new File ( outFolder , fileName ) ; FileOutputStream out = new FileOutputStream ( outFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , out ) ; out . close ( ) ; Toast . makeText ( this , getString ( R . string . imported_as ) + fileName , Toast . LENGTH_LONG ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( this , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import java . io . ByteArrayOutputStream ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; public abstract class HKDF { public static HKDF createFor ( int version ) { if ( version == <NUM_LIT> ) { return new HKDFv3 ( ) ; } throw new AssertionError ( "<STR_LIT>" + version ) ; } public byte [ ] deriveSecrets ( byte [ ] arr_b , byte [ ] arr_b1 , int v ) { return this . deriveSecrets ( arr_b , new byte [ <NUM_LIT> ] , arr_b1 , v ) ; } public byte [ ] deriveSecrets ( byte [ ] inputKeyMaterial , byte [ ] salt , byte [ ] info , int outputLength ) { byte [ ] derivedKey ; try { Mac mac = Mac . getInstance ( "<STR_LIT>" ) ; mac . init ( new SecretKeySpec ( salt , "<STR_LIT>" ) ) ; derivedKey = mac . doFinal ( inputKeyMaterial ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException e ) { throw new AssertionError ( e ) ; } try { int iterations = ( int ) Math . ceil ( ( ( double ) outputLength ) / <NUM_LIT> ) ; byte [ ] outputKey = new byte [ <NUM_LIT> ] ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; for ( int i = getIterationStartOffset ( ) ; i < getIterationStartOffset ( ) + iterations ; ++ i ) { Mac macIteration = Mac . getInstance ( "<STR_LIT>" ) ; macIteration . init ( new SecretKeySpec ( derivedKey , "<STR_LIT>" ) ) ; macIteration . update ( outputKey ) ; if ( info != null ) { macIteration . update ( info ) ; } macIteration . update ( ( byte ) i ) ; outputKey = macIteration . doFinal ( ) ; int remainingLength = Math . min ( outputLength , outputKey . length ) ; outputStream . write ( outputKey , <NUM_LIT> , remainingLength ) ; outputLength -= remainingLength ; } return outputStream . toByteArray ( ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException ex ) { throw new AssertionError ( ex ) ; } } protected abstract int getIterationStartOffset ( ) ; } </s>
<s> package com . wmods . wppenhacer . adapter ; import android . content . Context ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; public class MessageAdapter extends ArrayAdapter < MessageHistory . MessageItem > { private final Context context ; private final List < MessageHistory . MessageItem > items ; public MessageAdapter ( Context context , List < MessageHistory . MessageItem > items ) { super ( context , android . R . layout . simple_list_item_2 , android . R . id . text1 , items ) ; this . context = context ; this . items = items ; } @ Override public int getCount ( ) { return items . size ( ) ; } @ Override public MessageHistory . MessageItem getItem ( int position ) { return items . get ( position ) ; } @ Override public long getItemId ( int position ) { return position ; } @ NonNull @ Override public View getView ( int position , View convertView , @ NonNull ViewGroup parent ) { View view1 = super . getView ( position , convertView , parent ) ; TextView textView0 = view1 . findViewById ( android . R . id . text1 ) ; textView0 . setTextSize ( <NUM_LIT> ) ; textView0 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView0 . setText ( this . items . get ( position ) . message ) ; TextView textView1 = view1 . findViewById ( android . R . id . text2 ) ; textView1 . setTextSize ( <NUM_LIT> ) ; textView1 . setAlpha ( <NUM_LIT> ) ; textView1 . setTypeface ( null , Typeface . ITALIC ) ; textView1 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; var timestamp = this . items . get ( position ) . timestamp ; textView1 . setText ( ( timestamp == <NUM_LIT> ? context . getString ( ResId . string . message_original ) : "<STR_LIT>" + Utils . getDateTimeFromMillis ( timestamp ) ) ) ; return view1 ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments . base ; import android . view . View ; import android . widget . Toast ; import androidx . annotation . IdRes ; import androidx . annotation . StringRes ; import androidx . appcompat . widget . Toolbar ; import androidx . core . view . MenuProvider ; import androidx . fragment . app . Fragment ; import androidx . navigation . NavController ; import androidx . navigation . NavDirections ; import androidx . navigation . fragment . NavHostFragment ; import com . google . android . material . snackbar . Snackbar ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . R ; import java . util . concurrent . Callable ; import java . util . concurrent . Future ; import java . util . concurrent . FutureTask ; public class BaseFragment extends Fragment { public void navigateUp ( ) { getNavController ( ) . navigateUp ( ) ; } public NavController getNavController ( ) { return NavHostFragment . findNavController ( this ) ; } public boolean safeNavigate ( @ IdRes int resId ) { try { getNavController ( ) . navigate ( resId ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public boolean safeNavigate ( NavDirections direction ) { try { getNavController ( ) . navigate ( direction ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public void setupToolbar ( Toolbar toolbar , View tipsView , int title ) { setupToolbar ( toolbar , tipsView , getString ( title ) , - <NUM_LIT> ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , int title , int menu ) { setupToolbar ( toolbar , tipsView , getString ( title ) , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu ) { setupToolbar ( toolbar , tipsView , title , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu , View . OnClickListener navigationOnClickListener ) { toolbar . setNavigationOnClickListener ( navigationOnClickListener == null ? ( v -> navigateUp ( ) ) : navigationOnClickListener ) ; toolbar . setNavigationIcon ( R . drawable . ic_baseline_arrow_back_24 ) ; toolbar . setTitle ( title ) ; toolbar . setTooltipText ( title ) ; if ( tipsView != null ) tipsView . setTooltipText ( title ) ; if ( menu != - <NUM_LIT> ) { toolbar . inflateMenu ( menu ) ; if ( this instanceof MenuProvider self ) { toolbar . setOnMenuItemClickListener ( self :: onMenuItemSelected ) ; self . onPrepareMenu ( toolbar . getMenu ( ) ) ; } } } public void runAsync ( Runnable runnable ) { App . getExecutorService ( ) . submit ( runnable ) ; } public < T > Future < T > runAsync ( Callable < T > callable ) { return App . getExecutorService ( ) . submit ( callable ) ; } public void runOnUiThread ( Runnable runnable ) { App . getMainHandler ( ) . post ( runnable ) ; } public < T > Future < T > runOnUiThread ( Callable < T > callable ) { var task = new FutureTask < > ( callable ) ; runOnUiThread ( task ) ; return task ; } public void showHint ( @ StringRes int res , boolean lengthShort , @ StringRes int actionRes , View . OnClickListener action ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , App . getInstance ( ) . getString ( actionRes ) , action ) ; } public void showHint ( @ StringRes int res , boolean lengthShort ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort ) { showHint ( str , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort , CharSequence actionStr , View . OnClickListener action ) { var container = getView ( ) ; if ( isResumed ( ) && container != null ) { var snackbar = Snackbar . make ( container , str , lengthShort ? Snackbar . LENGTH_SHORT : Snackbar . LENGTH_LONG ) ; if ( actionStr != null && action != null ) snackbar . setAction ( actionStr , action ) ; snackbar . show ( ) ; return ; } runOnUiThread ( ( ) -> { try { Toast . makeText ( App . getInstance ( ) , str , lengthShort ? Toast . LENGTH_SHORT : Toast . LENGTH_LONG ) . show ( ) ; } catch ( Throwable ignored ) { } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import android . os . Message ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallPrivacy extends Feature { public CallPrivacy ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var onCallReceivedMethod = Unobfuscator . loadAntiRevokeOnCallReceivedMethod ( classLoader ) ; XposedBridge . hookMethod ( onCallReceivedMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { Object callinfo = ( ( Message ) param . args [ <NUM_LIT> ] ) . obj ; Class < ? > callInfoClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; if ( callinfo == null || ! callInfoClass . isInstance ( callinfo ) ) return ; if ( ( boolean ) XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ) return ; var userJid = XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ; var callId = XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ; var type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Tasker . sendTaskerEvent ( WppCore . getContactName ( userJid ) , WppCore . stripJID ( WppCore . getRawString ( userJid ) ) , "<STR_LIT>" ) ; var blockCall = checkCallBlock ( userJid , type ) ; if ( ! blockCall ) return ; var clazzVoip = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var rejectType = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; switch ( rejectType ) { case "<STR_LIT>" : case "<STR_LIT>" : var rejectCallMethod = ReflectionUtils . findMethodUsingFilter ( clazzVoip , m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) ; var obj = new Object [ rejectCallMethod . getParameterCount ( ) ] ; obj [ <NUM_LIT> ] = callId ; obj [ <NUM_LIT> ] = "<STR_LIT>" . equals ( rejectType ) ? null : rejectType ; if ( obj . length > <NUM_LIT> ) { obj [ <NUM_LIT> ] = <NUM_LIT> ; } ReflectionUtils . callMethod ( rejectCallMethod , null , obj ) ; param . setResult ( true ) ; break ; case "<STR_LIT>" : try { XposedHelpers . callStaticMethod ( clazzVoip , "<STR_LIT>" , true ) ; } catch ( NoSuchMethodError e ) { XposedHelpers . callStaticMethod ( clazzVoip , "<STR_LIT>" , true , <NUM_LIT> ) ; } param . setResult ( true ) ; break ; default : } } } ) ; XposedBridge . hookAllMethods ( classLoader . loadClass ( "<STR_LIT>" ) , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) return ; var userJid = param . args [ <NUM_LIT> ] ; var type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var block = checkCallBlock ( userJid , type ) ; if ( block ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; } public boolean checkCallBlock ( Object userJid , int type ) throws IllegalAccessException , InvocationTargetException { if ( type == <NUM_LIT> ) return false ; if ( type == <NUM_LIT> ) return true ; var jid = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; if ( jid == null ) return false ; switch ( type ) { case <NUM_LIT> : if ( WppCore . stripJID ( jid ) . equals ( jid ) ) { jid = jid . split ( "<STR_LIT>" ) [ <NUM_LIT> ] + "<STR_LIT>" ; } var contactName = WppCore . getSContactName ( WppCore . createUserJid ( jid ) , true ) ; return TextUtils . isEmpty ( contactName ) || contactName . equals ( jid ) ; case <NUM_LIT> : var callBlockList = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var blockList = Arrays . stream ( callBlockList . substring ( <NUM_LIT> , callBlockList . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var blockNumber : blockList ) { if ( ! TextUtils . isEmpty ( blockNumber ) && jid . contains ( blockNumber ) ) { return true ; } } return false ; case <NUM_LIT> : var callWhiteList = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var whiteList = Arrays . stream ( callWhiteList . substring ( <NUM_LIT> , callWhiteList . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var whiteNumber : whiteList ) { if ( ! TextUtils . isEmpty ( whiteNumber ) && jid . contains ( whiteNumber ) ) { return false ; } } return true ; } return false ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Dialog ; import android . content . Intent ; import android . net . Uri ; import android . os . BaseBundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallType extends Feature { private XC_MethodHook . Unhook hookBundleBoolean ; public CallType ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var intPreferences = Unobfuscator . loadGetIntPreferences ( classLoader ) ; XposedBridge . hookMethod ( intPreferences , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var callConfirmationFragment = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var method = ReflectionUtils . findMethodUsingFilter ( callConfirmationFragment , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( android . os . Bundle . class ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { private boolean isVideoCall ; private String jid ; private Dialog newDialog ; private Unhook hookBundleString ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString = XposedHelpers . findAndHookMethod ( BaseBundle . class , "<STR_LIT>" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { jid = ( String ) param . getResult ( ) ; } } } ) ; hookBundleBoolean = XposedHelpers . findAndHookMethod ( BaseBundle . class , "<STR_LIT>" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { isVideoCall = ( boolean ) param . getResult ( ) ; } } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString . unhook ( ) ; hookBundleBoolean . unhook ( ) ; if ( jid == null || isVideoCall ) return ; var origDialog = ( Dialog ) param . getResult ( ) ; var context = origDialog . getContext ( ) ; var mAlertDialog = new AlertDialogWpp ( origDialog . getContext ( ) ) ; mAlertDialog . setTitle ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; mAlertDialog . setItems ( new String [ ] { context . getString ( ResId . string . phone_call ) , context . getString ( ResId . string . whatsapp_call ) } , ( dialog , which ) -> { newDialog . dismiss ( ) ; switch ( which ) { case <NUM_LIT> : var intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_DIAL ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + WppCore . stripJID ( jid ) ) ) ; context . startActivity ( intent ) ; break ; case <NUM_LIT> : origDialog . show ( ) ; break ; } } ) ; newDialog = mAlertDialog . create ( ) ; param . setResult ( newDialog ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . text . InputType ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . EditText ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class NewChat extends Feature { public NewChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) { var homeActivity = findClass ( "<STR_LIT>" , classLoader ) ; var newSettings = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; XposedHelpers . findAndHookMethod ( homeActivity , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . new_chat ) ; var drawable = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( item1 -> { var view = new LinearLayout ( activity ) ; view . setGravity ( Gravity . CENTER ) ; view . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; var edt = new EditText ( view . getContext ( ) ) ; edt . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; edt . setMaxLines ( <NUM_LIT> ) ; edt . setInputType ( InputType . TYPE_CLASS_PHONE ) ; edt . setTransformationMethod ( null ) ; edt . setHint ( ResId . string . number_with_country_code ) ; view . addView ( edt ) ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . new_chat ) ) . setView ( view ) . setPositiveButton ( activity . getString ( ResId . string . message ) , ( dialog , which ) -> { var number = edt . getText ( ) . toString ( ) ; var numberFomatted = number . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; var intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + numberFomatted ) ) ; intent . setPackage ( Utils . getApplication ( ) . getPackageName ( ) ) ; activity . startActivity ( intent ) ; } ) . setNegativeButton ( activity . getString ( ResId . string . cancel ) , null ) . show ( ) ; return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . graphics . drawable . Drawable ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class TabDialogContent extends LinearLayout { private TextView mTitle ; private LinearLayout contentLinear ; public TabDialogContent ( Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { var params = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; setLayoutParams ( params ) ; setOrientation ( VERTICAL ) ; setBackground ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimarySurfaceColor ( ) ) ) ; setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; LinearLayout layoutLine = new LinearLayout ( context ) ; layoutLine . setOrientation ( LinearLayout . HORIZONTAL ) ; var layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL ; layoutParams . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutLine . setLayoutParams ( layoutParams ) ; ImageView imageView = new ImageView ( context ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , LinearLayout . LayoutParams . MATCH_PARENT ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimaryTextColor ( ) ) ) ; layoutLine . addView ( imageView ) ; addView ( layoutLine ) ; mTitle = new TextView ( context ) ; var paramsTitle = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTitle . gravity = Gravity . CENTER ; paramsTitle . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mTitle . setLayoutParams ( paramsTitle ) ; mTitle . setGravity ( Gravity . CENTER ) ; mTitle . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; mTitle . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; mTitle . setTypeface ( null , Typeface . BOLD ) ; addView ( mTitle ) ; var view = new View ( context ) ; var paramsView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; paramsView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; view . setLayoutParams ( paramsView ) ; view . setBackgroundColor ( Color . GRAY ) ; addView ( view ) ; contentLinear = new LinearLayout ( context ) ; contentLinear . setOrientation ( LinearLayout . HORIZONTAL ) ; contentLinear . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var paramsContent = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsContent . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; contentLinear . setLayoutParams ( paramsContent ) ; addView ( contentLinear ) ; } public void setTitle ( String title ) { mTitle . setText ( title ) ; } public void addTab ( String title , @ Nullable Drawable image , @ Nullable View . OnClickListener listener ) { var linearLayout = new LinearLayout ( getContext ( ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER ) ; var params = new LinearLayout . LayoutParams ( <NUM_LIT> , LinearLayout . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> ) ; linearLayout . setLayoutParams ( params ) ; linearLayout . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; linearLayout . setBackground ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimaryTextColor ( ) ) ) ; linearLayout . setOnClickListener ( listener ) ; var imageView = new ImageView ( getContext ( ) ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( image ) ; linearLayout . addView ( imageView ) ; var textView = new TextView ( getContext ( ) ) ; var paramsTextView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTextView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; textView . setLayoutParams ( paramsTextView ) ; textView . setText ( title ) ; textView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; textView . setTypeface ( null , Typeface . BOLD ) ; linearLayout . addView ( textView ) ; contentLinear . addView ( linearLayout ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Bitmap ; import android . graphics . RecordingCanvas ; import android . os . Build ; import android . util . Pair ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Others ; import org . json . JSONObject ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MediaQuality extends Feature { public MediaQuality ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var videoQuality = prefs . getBoolean ( "<STR_LIT>" , false ) ; var imageQuality = prefs . getBoolean ( "<STR_LIT>" , false ) ; Others . propsBoolean . put ( <NUM_LIT> , false ) ; if ( videoQuality ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; var jsonProperty = Unobfuscator . loadPropsJsonMethod ( classLoader ) ; XposedBridge . hookMethod ( jsonProperty , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var json = ( JSONObject ) param . getResult ( ) ; for ( int i = <NUM_LIT> ; i < json . length ( ) ; i ++ ) { var key = ( String ) json . names ( ) . opt ( i ) ; var jSONObject = json . getJSONObject ( key ) ; jSONObject . put ( "<STR_LIT>" , <NUM_LIT> ) ; jSONObject . put ( "<STR_LIT>" , <NUM_LIT> ) ; } } } } ) ; var resolutionMethod = Unobfuscator . loadMediaQualityResolutionMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( resolutionMethod ) ) ; XposedBridge . hookMethod ( resolutionMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var pair = new Pair < > ( param . args [ <NUM_LIT> ] , param . args [ <NUM_LIT> ] ) ; param . setResult ( pair ) ; } } ) ; var bitrateMethod = Unobfuscator . loadMediaQualityBitrateMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bitrateMethod ) ) ; XposedBridge . hookMethod ( bitrateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { param . setResult ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; } } ) ; var videoMethod = Unobfuscator . loadMediaQualityVideoMethod2 ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( videoMethod ) ) ; XposedBridge . hookMethod ( videoMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var resizeVideo = param . getResult ( ) ; var originalVieo = param . args [ <NUM_LIT> ] ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { var widthDest = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var heightDest = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var landscapeDest = widthDest > heightDest ; var widthDest2 = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var heightDest2 = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var landscapeDest2 = widthDest2 > heightDest2 ; var widthSrc = XposedHelpers . getIntField ( originalVieo , "<STR_LIT>" ) ; var heightSrc = XposedHelpers . getIntField ( originalVieo , "<STR_LIT>" ) ; var rotation = ( landscapeDest2 != landscapeDest ) ; XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , rotation ? heightSrc : widthSrc ) ; XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , rotation ? widthSrc : heightSrc ) ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , <NUM_LIT> ) ; } } } } ) ; var videoLimitClass = Unobfuscator . loadMediaQualityVideoLimitClass ( classLoader ) ; logDebug ( videoLimitClass ) ; XposedHelpers . findAndHookConstructor ( videoLimitClass , int . class , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } } ) ; } if ( imageQuality ) { int [ ] props = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; int max = <NUM_LIT> ; int min = <NUM_LIT> ; for ( int index = <NUM_LIT> ; index < props . length ; index ++ ) { if ( index <= <NUM_LIT> ) { Others . propsInteger . put ( props [ index ] , min ) ; } else { Others . propsInteger . put ( props [ index ] , max ) ; } } Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; var mediaQualityProcessor = Unobfuscator . loadMediaQualityProcessor ( classLoader ) ; XposedBridge . hookAllConstructors ( mediaQualityProcessor , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { XposedHelpers . findAndHookMethod ( RecordingCanvas . class , "<STR_LIT>" , Bitmap . class , XC_MethodReplacement . DO_NOTHING ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import android . content . res . ColorStateList ; import android . graphics . Bitmap ; import android . graphics . NinePatch ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . DrawableContainer ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . NinePatchDrawable ; import android . graphics . drawable . RippleDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . StateListDrawable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class DrawableColors { private static final HashMap < Bitmap , Integer > ninePatchs = new HashMap < > ( ) ; public static void replaceColor ( Drawable drawable , HashMap < String , String > colors ) { if ( DesignUtils . isNightMode ( ) ) { colors . remove ( "<STR_LIT>" ) ; } if ( drawable instanceof StateListDrawable stateListDrawable ) { var count = StateListDrawableCompact . getStateCount ( stateListDrawable ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var stateDrawable = StateListDrawableCompact . getStateDrawable ( stateListDrawable , i ) ; if ( stateDrawable != null ) replaceColor ( stateDrawable , colors ) ; } } else if ( drawable instanceof DrawableContainer drawableContainer ) { var containerState = drawableContainer . getConstantState ( ) ; var drawables = ( Drawable [ ] ) XposedHelpers . getObjectField ( containerState , "<STR_LIT>" ) ; for ( var drawable1 : drawables ) { replaceColor ( drawable1 , colors ) ; } } else if ( drawable instanceof LayerDrawable layerDrawable ) { var layerState = layerDrawable . getConstantState ( ) ; var mChildren = ( Object [ ] ) XposedHelpers . getObjectField ( layerState , "<STR_LIT>" ) ; for ( var childDrawable : mChildren ) { if ( childDrawable != null ) { var drawable1 = ( Drawable ) XposedHelpers . getObjectField ( childDrawable , "<STR_LIT>" ) ; replaceColor ( drawable1 , colors ) ; } } } else if ( drawable instanceof GradientDrawable gradientDrawable ) { var gradientColors = gradientDrawable . getColors ( ) ; if ( gradientColors != null ) { for ( var i = <NUM_LIT> ; i < gradientColors . length ; i ++ ) { var gradientColor = IColors . toString ( gradientColors [ i ] ) ; var newColor = colors . get ( gradientColor ) ; if ( newColor != null ) { gradientColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! gradientColor . startsWith ( "<STR_LIT>" ) && ! gradientColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = gradientColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( gradientColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) gradientColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } gradientDrawable . setColors ( gradientColors ) ; } } else if ( drawable instanceof InsetDrawable insetDrawable ) { replaceColor ( insetDrawable . getDrawable ( ) , colors ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { var color = getNinePatchDrawableColor ( ninePatchDrawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { ninePatchDrawable . setTintList ( ColorStateList . valueOf ( parseColor ( newColor ) ) ) ; } } else { if ( drawable == null ) return ; var color = getColor ( drawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( sColorSub + newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } } } } } public static int getColor ( Drawable drawable ) { if ( drawable == null ) return <NUM_LIT> ; int color = <NUM_LIT> ; if ( drawable instanceof ColorDrawable colorDrawable ) { color = getColorDrawableColor ( colorDrawable ) ; } else if ( drawable instanceof ShapeDrawable shapeDrawable ) { color = getShapeDrawableColor ( shapeDrawable ) ; } else if ( drawable instanceof RippleDrawable rippleDrawable ) { color = getRippleDrawableColor ( rippleDrawable ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { color = getNinePatchDrawableColor ( ninePatchDrawable ) ; } else if ( drawable instanceof InsetDrawable insetDrawable ) { color = getInsetDrawableColor ( insetDrawable ) ; } return color ; } private static int getInsetDrawableColor ( InsetDrawable insetDrawable ) { var mDrawable = ( Drawable ) XposedHelpers . getObjectField ( insetDrawable , "<STR_LIT>" ) ; return getColor ( mDrawable ) ; } public static int getNinePatchDrawableColor ( NinePatchDrawable ninePatchDrawable ) { var state = ninePatchDrawable . getConstantState ( ) ; var ninePatch = ( NinePatch ) XposedHelpers . getObjectField ( state , "<STR_LIT>" ) ; var bitmap = ninePatch . getBitmap ( ) ; var corSalva = ninePatchs . get ( bitmap ) ; if ( corSalva != null ) return corSalva ; HashMap < Integer , Integer > contagemCores = new HashMap < > ( ) ; int corMaisFrequente = <NUM_LIT> ; int contagemMaxima = <NUM_LIT> ; for ( int x = <NUM_LIT> ; x < bitmap . getWidth ( ) ; x ++ ) { for ( int y = <NUM_LIT> ; y < bitmap . getHeight ( ) ; y ++ ) { int cor = bitmap . getPixel ( x , y ) ; int contagemAtual = contagemCores . getOrDefault ( cor , <NUM_LIT> ) + <NUM_LIT> ; contagemCores . put ( cor , contagemAtual ) ; if ( contagemAtual > contagemMaxima ) { corMaisFrequente = cor ; contagemMaxima = contagemAtual ; } } } ninePatchs . put ( bitmap , corMaisFrequente ) ; return corMaisFrequente ; } private static int getRippleDrawableColor ( RippleDrawable rippleDrawable ) { var state = rippleDrawable . getConstantState ( ) ; var rippleStateClass = XposedHelpers . findClass ( "<STR_LIT>" , loader1 ) ; try { return XposedHelpers . getIntField ( state , "<STR_LIT>" ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; return <NUM_LIT> ; } } public static int getColorDrawableColor ( ColorDrawable colorDrawable ) { return colorDrawable . getColor ( ) ; } public static int getShapeDrawableColor ( ShapeDrawable shapeDrawable ) { return shapeDrawable . getPaint ( ) . getColor ( ) ; } } </s>
<s> package com . wmods . wppenhacer ; import android . Manifest ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Environment ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . Fragment ; import androidx . viewpager2 . widget . ViewPager2 ; import com . google . android . material . navigation . NavigationBarView ; import com . wmods . wppenhacer . activities . AboutActivity ; import com . wmods . wppenhacer . adapter . MainPagerAdapter ; import com . wmods . wppenhacer . databinding . ActivityMainBinding ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; public class MainActivity extends AppCompatActivity { private ActivityMainBinding binding ; public static File mainDir ; @ Override protected void onCreate ( Bundle savedInstanceState ) { setTheme ( R . style . AppTheme ) ; getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; App . changeLanguage ( this ) ; super . onCreate ( savedInstanceState ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayShowHomeEnabled ( true ) ; getSupportActionBar ( ) . setIcon ( R . mipmap . launcher ) ; } binding = ActivityMainBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; MainPagerAdapter pagerAdapter = new MainPagerAdapter ( this ) ; binding . viewPager . setAdapter ( pagerAdapter ) ; binding . navView . setOnItemSelectedListener ( new NavigationBarView . OnItemSelectedListener ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onNavigationItemSelected ( @ NonNull MenuItem item ) { return switch ( item . getItemId ( ) ) { case R . id . navigation_home -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_chat -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_privacy -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_media -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_colors -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } default -> false ; } ; } } ) ; binding . viewPager . registerOnPageChangeCallback ( new ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; binding . navView . getMenu ( ) . getItem ( position ) . setChecked ( true ) ; } } ) ; setupPermissions ( ) ; createMainDir ( ) ; FilePicker . registerFilePicker ( this ) ; } private void setupPermissions ( ) { ArrayList < String > permissions = new ArrayList < > ( ) ; if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_MEDIA_IMAGES ) != PackageManager . PERMISSION_GRANTED && Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { permissions . add ( Manifest . permission . READ_MEDIA_IMAGES ) ; } if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { permissions . add ( Manifest . permission . READ_EXTERNAL_STORAGE ) ; } if ( ! permissions . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , permissions . toArray ( new String [ <NUM_LIT> ] ) , <NUM_LIT> ) ; } } private void createMainDir ( ) { mainDir = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) , "<STR_LIT>" ) ; if ( ! mainDir . exists ( ) ) { mainDir . mkdir ( ) ; } var nomedia = new File ( mainDir , "<STR_LIT>" ) ; if ( ! nomedia . exists ( ) ) { try { nomedia . createNewFile ( ) ; } catch ( IOException ignored ) { } } } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; for ( Fragment fragment : getSupportFragmentManager ( ) . getFragments ( ) ) { fragment . onActivityResult ( requestCode , resultCode , data ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . header_menu , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { if ( item . getItemId ( ) == R . id . menu_about ) { startActivity ( new Intent ( this , AboutActivity . class ) ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } public static boolean isXposedEnabled ( ) { return false ; } } </s>
<s> package com . wmods . wppenhacer . views ; import static de . robv . android . xposed . XposedBridge . log ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . view . WindowManager ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileOutputStream ; import java . util . Properties ; import de . robv . android . xposed . XSharedPreferences ; @ SuppressLint ( "<STR_LIT>" ) public class WallpaperView extends FrameLayout { private final XSharedPreferences prefs ; private final Properties properties ; public WallpaperView ( @ NonNull Context context , XSharedPreferences preferences , Properties properties ) { super ( context ) ; this . prefs = preferences ; this . properties = properties ; init ( context ) ; } private void init ( Context context ) { ImageView bgView = new ImageView ( context ) ; bgView . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . MATCH_PARENT , FrameLayout . LayoutParams . MATCH_PARENT ) ) ; bgView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; bgView . setAdjustViewBounds ( false ) ; try { String image = ThemePreference . rootDirectory . getAbsolutePath ( ) + "<STR_LIT>" + prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) + "<STR_LIT>" + properties . getProperty ( "<STR_LIT>" ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { image = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } Drawable drawable = getDrawableImage ( image ) ; bgView . setImageDrawable ( drawable ) ; addView ( bgView ) ; } catch ( Exception e ) { log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private Drawable getDrawableImage ( String imagePath ) throws Exception { var fileOut = getContext ( ) . getFilesDir ( ) . getAbsolutePath ( ) + "<STR_LIT>" + "<STR_LIT>" ; var file = new File ( imagePath ) ; if ( ! file . exists ( ) ) return null ; String filePath = file . getAbsolutePath ( ) ; long lastModified = file . lastModified ( ) ; String cacheKey = filePath + "<STR_LIT>" + lastModified ; String cachedData = WppCore . getPrivString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( cacheKey . equals ( cachedData ) && new File ( fileOut ) . exists ( ) ) { Bitmap bitmap = BitmapFactory . decodeFile ( fileOut ) ; return new BitmapDrawable ( getResources ( ) , bitmap ) ; } Bitmap bitmap = BitmapFactory . decodeFile ( imagePath ) ; DisplayMetrics displayMetrics = new DisplayMetrics ( ) ; var windowManager = ( WindowManager ) getContext ( ) . getSystemService ( Context . WINDOW_SERVICE ) ; windowManager . getDefaultDisplay ( ) . getMetrics ( displayMetrics ) ; int width = displayMetrics . widthPixels ; int height = displayMetrics . heightPixels ; var scaledBitmap = Bitmap . createScaledBitmap ( bitmap , width , height , true ) ; try ( var outputStream = new FileOutputStream ( fileOut ) ) { scaledBitmap . compress ( Bitmap . CompressFormat . JPEG , <NUM_LIT> , outputStream ) ; outputStream . flush ( ) ; } WppCore . setPrivString ( "<STR_LIT>" , cacheKey ) ; bitmap . recycle ( ) ; return new BitmapDrawable ( getResources ( ) , scaledBitmap ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . os . BaseBundle ; import android . os . Message ; import android . text . TextUtils ; import android . view . GestureDetector ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . listeners . DoubleTapListener ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . AnimationUtil ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Others extends Feature { public static HashMap < Integer , Boolean > propsBoolean = new HashMap < > ( ) ; public static HashMap < Integer , Integer > propsInteger = new HashMap < > ( ) ; private Properties properties ; public Others ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var novoTema = prefs . getBoolean ( "<STR_LIT>" , false ) ; var menuWIcons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var newSettings = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filterChats = prefs . getString ( "<STR_LIT>" , null ) ; var strokeButtons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var outlinedIcons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showDnd = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showFreezeLastSeen = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filterSeen = prefs . getBoolean ( "<STR_LIT>" , false ) ; var fbstyle = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var metaai = prefs . getBoolean ( "<STR_LIT>" , false ) ; var topnav = prefs . getBoolean ( "<STR_LIT>" , false ) ; var proximity = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showOnline = prefs . getBoolean ( "<STR_LIT>" , false ) ; var floatingMenu = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filter_items = prefs . getString ( "<STR_LIT>" , null ) ; var disable_defemojis = prefs . getBoolean ( "<STR_LIT>" , false ) ; var autonext_status = prefs . getBoolean ( "<STR_LIT>" , false ) ; var audio_type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var audio_transcription = prefs . getBoolean ( "<STR_LIT>" , false ) ; var oldStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var igstatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var verticalStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var animationEmojis = prefs . getBoolean ( "<STR_LIT>" , false ) ; propsInteger . put ( <NUM_LIT> , oldStatus ? igstatus ? <NUM_LIT> : <NUM_LIT> : <NUM_LIT> ) ; propsBoolean . put ( <NUM_LIT> , filterSeen ) ; propsBoolean . put ( <NUM_LIT> , novoTema ) ; propsBoolean . put ( <NUM_LIT> , menuWIcons ) ; propsBoolean . put ( <NUM_LIT> , newSettings ) ; propsBoolean . put ( <NUM_LIT> , Objects . equals ( filterChats , "<STR_LIT>" ) ) ; propsBoolean . put ( <NUM_LIT> , strokeButtons ) ; propsBoolean . put ( <NUM_LIT> , outlinedIcons ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , floatingMenu ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , animationEmojis ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; if ( metaai ) { propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; } if ( audio_transcription ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; } if ( verticalStatus ) { propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; } else { propsInteger . put ( <NUM_LIT> , fbstyle ) ; propsInteger . put ( <NUM_LIT> , fbstyle ) ; } hookProps ( ) ; hookMenuOptions ( newSettings , showFreezeLastSeen , showDnd , filterChats ) ; if ( proximity ) { var proximitySensorMethod = Unobfuscator . loadProximitySensorMethod ( classLoader ) ; XposedBridge . hookMethod ( proximitySensorMethod , XC_MethodReplacement . DO_NOTHING ) ; } if ( filter_items != null && prefs . getBoolean ( "<STR_LIT>" , true ) ) { filterItems ( filter_items ) ; } if ( disable_defemojis ) { disable_defEmojis ( ) ; } if ( autonext_status ) { autoNextStatus ( ) ; } if ( audio_type > <NUM_LIT> ) { sendAudioType ( audio_type ) ; } customPlayBackSpeed ( ) ; showOnline ( showOnline ) ; animationList ( ) ; stampCopiedMessage ( ) ; doubleTapReaction ( ) ; } private void doubleTapReaction ( ) throws Exception { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( View ) param . thisObject ; if ( viewGroup == null ) return ; var gestureDetector = new GestureDetector ( viewGroup . getContext ( ) , new DoubleTapListener ( ( ) -> { var reactionView = ( ViewGroup ) viewGroup . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( reactionView != null && reactionView . getVisibility ( ) == View . VISIBLE ) { for ( int i = <NUM_LIT> ; i < reactionView . getChildCount ( ) ; i ++ ) { if ( reactionView . getChildAt ( i ) instanceof TextView textView ) { if ( textView . getText ( ) . toString ( ) . contains ( "<STR_LIT>" ) ) { WppCore . sendReaction ( "<STR_LIT>" , param . args [ <NUM_LIT> ] ) ; return ; } } } } WppCore . sendReaction ( "<STR_LIT>" , param . args [ <NUM_LIT> ] ) ; } ) ) ; viewGroup . setOnTouchListener ( ( v , event ) -> gestureDetector . onTouchEvent ( event ) ) ; } } ) ; } private void stampCopiedMessage ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var copiedMessage = Unobfuscator . loadCopiedMessageMethod ( classLoader ) ; XposedBridge . hookMethod ( copiedMessage , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var Collection = ( java . util . Collection ) param . args [ param . args . length - <NUM_LIT> ] ; param . args [ param . args . length - <NUM_LIT> ] = new ArrayList < Object > ( Collection ) { @ Override public int size ( ) { return <NUM_LIT> ; } } ; } } ) ; } private void animationList ( ) throws Exception { var animation = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; if ( ! Objects . equals ( animation , "<STR_LIT>" ) ) { view . startAnimation ( AnimationUtil . getAnimation ( animation ) ) ; } else { if ( properties . containsKey ( "<STR_LIT>" ) ) { var animation = AnimationUtil . getAnimation ( properties . getProperty ( "<STR_LIT>" ) ) ; if ( animation != null ) { view . startAnimation ( animation ) ; } } } } } ) ; } private void customPlayBackSpeed ( ) throws Exception { var voicenote_speed = prefs . getFloat ( "<STR_LIT>" , <NUM_LIT> ) ; var playBackSpeed = Unobfuscator . loadPlaybackSpeed ( classLoader ) ; XposedBridge . hookMethod ( playBackSpeed , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( ( float ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = voicenote_speed ; } } } ) ; var voicenoteClass = classLoader . loadClass ( "<STR_LIT>" ) ; var method = ReflectionUtils . findAllMethodsUsingFilter ( voicenoteClass , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == int . class && method1 . getReturnType ( ) . equals ( void . class ) ) ; XposedBridge . hookMethod ( method [ method . length - <NUM_LIT> ] , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var view = ( View ) param . thisObject ; var playback = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( playback != null ) { playback . setText ( String . valueOf ( voicenote_speed ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) + "<STR_LIT>" ) ; } } } } ) ; } private void sendAudioType ( int audio_type ) throws Exception { var sendAudioTypeMethod = Unobfuscator . loadSendAudioTypeMethod ( classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( sendAudioTypeMethod ) ) ; XposedBridge . hookMethod ( sendAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var results = ReflectionUtils . findArrayOfType ( param . args , Integer . class ) ; if ( results . size ( ) < <NUM_LIT> ) { log ( "<STR_LIT>" ) ; return ; } var mediaType = results . get ( <NUM_LIT> ) ; if ( ( int ) mediaType . second != <NUM_LIT> ) return ; var audioType = results . get ( <NUM_LIT> ) ; param . args [ audioType . first ] = audio_type - <NUM_LIT> ; } } ) ; var originFMessageField = Unobfuscator . loadOriginFMessageField ( classLoader ) ; var forwardAudioTypeMethod = Unobfuscator . loadForwardAudioTypeMethod ( classLoader ) ; XposedBridge . hookMethod ( forwardAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = param . getResult ( ) ; originFMessageField . setAccessible ( true ) ; originFMessageField . setInt ( fMessage , audio_type - <NUM_LIT> ) ; } } ) ; } private void autoNextStatus ( ) throws Exception { Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( "<STR_LIT>" ) ; var runNextStatusMethod = Unobfuscator . loadNextStatusRunMethod ( classLoader ) ; XposedBridge . hookMethod ( runNextStatusMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var obj = XposedHelpers . getObjectField ( param . thisObject , "<STR_LIT>" ) ; if ( StatusPlaybackContactFragmentClass . isInstance ( obj ) ) { param . setResult ( null ) ; } } } ) ; var onPlayBackFinished = Unobfuscator . loadOnPlaybackFinished ( classLoader ) ; XposedBridge . hookMethod ( onPlayBackFinished , XC_MethodReplacement . DO_NOTHING ) ; } private void disable_defEmojis ( ) throws Exception { var defEmojiClass = Unobfuscator . loadDefEmojiClass ( classLoader ) ; XposedBridge . hookMethod ( defEmojiClass , XC_MethodReplacement . returnConstant ( null ) ) ; } private void filterItems ( String filterItems ) { var itens = filterItems . split ( "<STR_LIT>" ) ; var idsFilter = new ArrayList < Integer > ( ) ; for ( String item : itens ) { var id = Utils . getID ( item , "<STR_LIT>" ) ; if ( id > <NUM_LIT> ) { idsFilter . add ( id ) ; } } XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , boolean . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . thisObject ; var id = view . getId ( ) ; if ( id > <NUM_LIT> && idsFilter . contains ( id ) && view . getVisibility ( ) == View . VISIBLE ) { view . setVisibility ( View . GONE ) ; } } } ) ; } private void showOnline ( boolean showOnline ) throws Exception { var checkOnlineMethod = Unobfuscator . loadCheckOnlineMethod ( classLoader ) ; XposedBridge . hookMethod ( checkOnlineMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var message = ( Message ) param . args [ <NUM_LIT> ] ; if ( message . arg1 != <NUM_LIT> ) return ; BaseBundle baseBundle = ( BaseBundle ) message . obj ; var jid = baseBundle . getString ( "<STR_LIT>" ) ; if ( WppCore . isGroup ( jid ) ) return ; var name = WppCore . getContactName ( WppCore . createUserJid ( jid ) ) ; name = TextUtils . isEmpty ( name ) ? WppCore . stripJID ( jid ) : name ; if ( showOnline ) Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . toast_online ) , name ) , Toast . LENGTH_SHORT ) ; Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jid ) , "<STR_LIT>" ) ; } } ) ; } @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ) private static void InsertDNDOption ( Menu menu , Activity home , boolean newSettings ) { var dndmode = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . dnd_mode_title ) ) ; var drawable = DesignUtils . getDrawableByName ( dndmode ? "<STR_LIT>" : "<STR_LIT>" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! dndmode ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . dnd_mode_title ) ) . setMessage ( home . getString ( ResId . string . dnd_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ) private static void InsertFreezeLastSeenOption ( Menu menu , Activity home , boolean newSettings ) { final boolean freezelastseen = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . freezelastseen_title ) ) ; var drawable = Utils . getApplication ( ) . getDrawable ( freezelastseen ? ResId . drawable . eye_disabled : ResId . drawable . eye_enabled ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! freezelastseen ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . freezelastseen_title ) ) . setMessage ( home . getString ( ResId . string . freezelastseen_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } private void hookProps ( ) throws Exception { var methodPropsBoolean = Unobfuscator . loadPropsBooleanMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPropsBoolean ) ) ; var dataUsageActivityClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookMethod ( methodPropsBoolean , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsBoolean . get ( i ) ; if ( propValue != null ) { switch ( i ) { case <NUM_LIT> : if ( Unobfuscator . isCalledFromClass ( dataUsageActivityClass ) ) return ; break ; } param . setResult ( propValue ) ; } } } ) ; var methodPropsInteger = Unobfuscator . loadPropsIntegerMethod ( classLoader ) ; XposedBridge . hookMethod ( methodPropsInteger , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsInteger . get ( i ) ; if ( propValue == null ) return ; param . setResult ( propValue ) ; } } ) ; } private void hookMenuOptions ( boolean newSettings , boolean showFreezeLastSeen , boolean showDnd , String filterChats ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var activity = ( Activity ) param . thisObject ; if ( prefs . getBoolean ( "<STR_LIT>" , true ) ) { var iconDraw = activity . getDrawable ( ResId . drawable . refresh ) ; iconDraw . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; var itemMenu = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . restart_whatsapp ) . setIcon ( iconDraw ) . setOnMenuItemClickListener ( item -> { Utils . doRestart ( activity ) ; return true ; } ) ; if ( newSettings ) { itemMenu . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } } if ( showFreezeLastSeen ) { InsertFreezeLastSeenOption ( menu , activity , newSettings ) ; } if ( showDnd ) { InsertDNDOption ( menu , activity , newSettings ) ; } else { var dndmode = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; if ( dndmode ) { WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( activity ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . findItem ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( item != null ) { item . setVisible ( Objects . equals ( filterChats , "<STR_LIT>" ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashSet ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class PinnedLimit extends Feature { public PinnedLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void doHook ( ) throws Throwable { var pinnedLimitMethod = Unobfuscator . loadPinnedLimitMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( pinnedLimitMethod ) ) ; var pinnedSetMethod = Unobfuscator . loadPinnedHashSetMethod ( classLoader ) ; var pinnedInChatMethod = Unobfuscator . loadPinnedInChatMethod ( classLoader ) ; XposedBridge . hookMethod ( pinnedInChatMethod , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; XposedBridge . hookMethod ( pinnedSetMethod , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pinnedset = ( Set ) param . getResult ( ) ; PinnedLinkedHashSet < Object > pinnedMod ; if ( ! ( pinnedset instanceof PinnedLinkedHashSet ) ) { pinnedMod = new PinnedLinkedHashSet < > ( ) ; pinnedMod . addAll ( pinnedset ) ; var setField = Unobfuscator . getFieldByType ( pinnedSetMethod . getDeclaringClass ( ) , Set . class ) ; XposedHelpers . setObjectField ( param . thisObject , setField . getName ( ) , pinnedMod ) ; param . setResult ( pinnedMod ) ; } else { pinnedMod = ( PinnedLinkedHashSet < Object > ) pinnedset ; } pinnedMod . setLimit ( prefs . getBoolean ( "<STR_LIT>" , false ) ? <NUM_LIT> : <NUM_LIT> ) ; } } ) ; var idPin = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; XposedBridge . hookMethod ( pinnedLimitMethod , new XC_MethodHook ( ) { private Unhook hooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( param . args . length > <NUM_LIT> && param . args [ <NUM_LIT> ] instanceof MenuItem menuItem ) { if ( menuItem . getItemId ( ) != idPin ) return ; hooked = XposedHelpers . findAndHookMethod ( HashSet . class , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( hooked != null ) hooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private static class PinnedLinkedHashSet < T > extends java . util . LinkedHashSet < T > { private int limit ; @ Override public int size ( ) { if ( super . size ( ) >= limit ) { return <NUM_LIT> ; } return <NUM_LIT> ; } public void setLimit ( int i ) { this . limit = i ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideTagForward extends Feature { public HideTagForward ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method method = Unobfuscator . loadForwardTagMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; Class < ? > forwardClass = Unobfuscator . loadForwardClassMethod ( classLoader ) ; logDebug ( "<STR_LIT>" + forwardClass . getName ( ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var arg = ( int ) param . args [ <NUM_LIT> ] ; if ( arg == <NUM_LIT> ) { if ( Unobfuscator . isCalledFromClass ( forwardClass ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . OvalShape ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DotOnline extends Feature { private Object mStatusUser ; private Object mInstancePresence ; public DotOnline ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var showOnlineText = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showOnlineIcon = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! showOnlineText && ! showOnlineIcon ) return ; var classViewHolder = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookAllConstructors ( classViewHolder , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var context = ( Context ) param . args [ <NUM_LIT> ] ; var content = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( showOnlineText ) { var linearLayout = new LinearLayout ( context ) ; linearLayout . setGravity ( Gravity . END | Gravity . TOP ) ; content . addView ( linearLayout ) ; TextView lastSeenText = new TextView ( context ) ; lastSeenText . setId ( <NUM_LIT> ) ; lastSeenText . setTextSize ( <NUM_LIT> ) ; lastSeenText . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; lastSeenText . setGravity ( Gravity . CENTER_VERTICAL ) ; lastSeenText . setVisibility ( View . INVISIBLE ) ; linearLayout . addView ( lastSeenText ) ; } if ( showOnlineIcon ) { var contactView = ( FrameLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var photoView = ( ImageView ) contactView . getChildAt ( <NUM_LIT> ) ; contactView . removeView ( photoView ) ; var relativeLayout = new RelativeLayout ( context ) ; relativeLayout . setId ( <NUM_LIT> ) ; var params = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params . addRule ( RelativeLayout . CENTER_IN_PARENT ) ; photoView . setLayoutParams ( params ) ; relativeLayout . addView ( photoView ) ; contactView . addView ( relativeLayout ) ; var imageView = new ImageView ( context ) ; imageView . setId ( <NUM_LIT> ) ; var params2 = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params2 . addRule ( RelativeLayout . ALIGN_TOP , photoView . getId ( ) ) ; params2 . addRule ( RelativeLayout . ALIGN_RIGHT , photoView . getId ( ) ) ; params2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; imageView . setLayoutParams ( params2 ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new OvalShape ( ) ) ; shapeDrawable . getPaint ( ) . setColor ( Color . GREEN ) ; shapeDrawable . setIntrinsicHeight ( <NUM_LIT> ) ; shapeDrawable . setIntrinsicWidth ( <NUM_LIT> ) ; imageView . setImageDrawable ( shapeDrawable ) ; imageView . setVisibility ( View . INVISIBLE ) ; relativeLayout . addView ( imageView ) ; } } } ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var getStatusUser = Unobfuscator . loadStatusUserMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getStatusUser ) ) ; var sendPresenceMethod = Unobfuscator . loadSendPresenceMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( sendPresenceMethod ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookAllConstructors ( getStatusUser . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mStatusUser = param . thisObject ; } } ) ; XposedBridge . hookAllConstructors ( sendPresenceMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mInstancePresence = param . thisObject ; } } ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var object = param . args [ <NUM_LIT> ] ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; var getAdapterPositionMethod = ReflectionUtils . findMethodUsingFilter ( absViewHolderClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; var position = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; ImageView csDot = showOnlineIcon ? view . findViewById ( <NUM_LIT> ) . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineIcon ) { csDot . setVisibility ( View . INVISIBLE ) ; } TextView lastSeenText = showOnlineText ? view . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineText ) { lastSeenText . setVisibility ( View . INVISIBLE ) ; } var jidFiled = Unobfuscator . getFieldByExtendType ( object . getClass ( ) , XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ; var jidObject = jidFiled . get ( object ) ; var jid = WppCore . getRawString ( jidObject ) ; if ( WppCore . isGroup ( jid ) ) return ; Class < ? > JidClass = classLoader . loadClass ( "<STR_LIT>" ) ; var method = ReflectionUtils . findMethodUsingFilter ( sendPresenceMethod . getDeclaringClass ( ) , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && JidClass . isAssignableFrom ( method1 . getParameterTypes ( ) [ <NUM_LIT> ] ) && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == sendPresenceMethod . getDeclaringClass ( ) ) ; var instance = ReflectionUtils . callMethod ( method , null , jidObject , mInstancePresence ) ; sendPresenceMethod . invoke ( null , jidObject , instance , mInstancePresence ) ; var status = ( String ) getStatusUser . invoke ( mStatusUser , object ) ; var currentPosition = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; if ( currentPosition != position ) return ; if ( ! TextUtils . isEmpty ( status ) && status . trim ( ) . equals ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ) { if ( csDot != null ) { csDot . setVisibility ( View . VISIBLE ) ; } } if ( ! TextUtils . isEmpty ( status ) ) { if ( lastSeenText != null ) { lastSeenText . setText ( status ) ; lastSeenText . setVisibility ( View . VISIBLE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import android . graphics . Color ; import java . util . HashMap ; public class IColors { public static HashMap < String , String > colors = new HashMap < > ( ) ; static { colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static int parseColor ( String str ) { return Color . parseColor ( str ) ; } public static String toString ( int i ) { return "<STR_LIT>" + Integer . toHexString ( i ) ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments . base ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . preference . PreferenceFragmentCompat ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import rikka . material . preference . MaterialSwitchPreference ; public abstract class BasePreferenceFragment extends PreferenceFragmentCompat implements SharedPreferences . OnSharedPreferenceChangeListener { protected SharedPreferences mPrefs ; @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { mPrefs = PreferenceManager . getDefaultSharedPreferences ( requireContext ( ) ) ; mPrefs . registerOnSharedPreferenceChangeListener ( this ) ; } @ NonNull @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { chanceStates ( null ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , @ Nullable String s ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; App . getInstance ( ) . sendBroadcast ( intent ) ; chanceStates ( s ) ; } private void setPreferenceState ( String key , boolean enabled ) { var pref = findPreference ( key ) ; if ( pref != null ) { pref . setEnabled ( enabled ) ; if ( pref instanceof MaterialSwitchPreference && ! enabled ) { ( ( MaterialSwitchPreference ) pref ) . setChecked ( false ) ; } } } @ SuppressLint ( "<STR_LIT>" ) private void chanceStates ( String key ) { if ( Objects . equals ( key , "<STR_LIT>" ) ) { var mode = Integer . parseInt ( mPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; App . setThemeMode ( mode ) ; } if ( Objects . equals ( key , "<STR_LIT>" ) ) { mPrefs . edit ( ) . commit ( ) ; Utils . doRestart ( requireContext ( ) ) ; } var igstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; var verticalstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! igstatus ) ; var oldstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! ( oldstatus || verticalstatus ) ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; var channels = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! channels && ! oldstatus ) ; var freezelastseen = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! freezelastseen ) ; var separategroups = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! separategroups ) ; var filtergroups = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! filtergroups ) ; var callBlockContacts = findPreference ( "<STR_LIT>" ) ; var callWhiteContacts = findPreference ( "<STR_LIT>" ) ; if ( callBlockContacts != null && callWhiteContacts != null ) { var callType = Integer . parseInt ( mPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; switch ( callType ) { case <NUM_LIT> : callBlockContacts . setEnabled ( true ) ; callWhiteContacts . setEnabled ( false ) ; break ; case <NUM_LIT> : callWhiteContacts . setEnabled ( true ) ; callBlockContacts . setEnabled ( false ) ; break ; default : callWhiteContacts . setEnabled ( false ) ; callBlockContacts . setEnabled ( false ) ; break ; } } } } </s>
<s> package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . Context ; import android . content . Intent ; import android . os . Handler ; import android . os . Looper ; import androidx . appcompat . app . AppCompatDelegate ; import androidx . preference . PreferenceManager ; import java . util . Locale ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import rikka . material . app . LocaleDelegate ; public class App extends Application { private static App instance ; private static final ExecutorService executorService = Executors . newCachedThreadPool ( ) ; private static final Handler MainHandler = new Handler ( Looper . getMainLooper ( ) ) ; @ SuppressLint ( "<STR_LIT>" ) @ Override public void onCreate ( ) { super . onCreate ( ) ; instance = this ; var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; sharedPreferences . edit ( ) . putLong ( "<STR_LIT>" , System . currentTimeMillis ( ) ) . commit ( ) ; var mode = Integer . parseInt ( sharedPreferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; setThemeMode ( mode ) ; changeLanguage ( this ) ; } public static void setThemeMode ( int mode ) { switch ( mode ) { case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_YES ) ; break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; break ; } } public static App getInstance ( ) { return instance ; } public static ExecutorService getExecutorService ( ) { return executorService ; } public static Handler getMainHandler ( ) { return MainHandler ; } public void restartApp ( String packageWpp ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , packageWpp ) ; sendBroadcast ( intent ) ; } public static void changeLanguage ( Context context ) { var force = PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( "<STR_LIT>" , false ) ; LocaleDelegate . setDefaultLocale ( force ? Locale . ENGLISH : Locale . getDefault ( ) ) ; var res = context . getResources ( ) ; var config = res . getConfiguration ( ) ; config . setLocale ( LocaleDelegate . getDefaultLocale ( ) ) ; res . updateConfiguration ( config , res . getDisplayMetrics ( ) ) ; } } </s>
<s> package com . wmods . wppenhacer ; import android . net . Uri ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . utils . RealPathUtil ; import java . io . File ; public class FilePicker { private static OnFilePickedListener mOnFilePickedListener ; private static AppCompatActivity mActivity ; public static ActivityResultLauncher < String > fileSalve ; private static OnUriPickedListener mOnUriPickedListener ; public static ActivityResultLauncher < String [ ] > fileCapture ; public static ActivityResultLauncher < Uri > directoryCapture ; public static void registerFilePicker ( AppCompatActivity activity ) { mActivity = activity ; fileCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocument ( ) , FilePicker :: setFile ) ; directoryCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocumentTree ( ) , FilePicker :: setDirectory ) ; fileSalve = activity . registerForActivityResult ( new ActivityResultContracts . CreateDocument ( "<STR_LIT>" ) , FilePicker :: setFile ) ; } private static void setFile ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFilePath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } private static void setDirectory ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFolderPath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } public static void setOnFilePickedListener ( OnFilePickedListener onFilePickedListener ) { mOnFilePickedListener = onFilePickedListener ; } public static void setOnUriPickedListener ( OnUriPickedListener onFilePickedListener ) { mOnUriPickedListener = onFilePickedListener ; } public interface OnFilePickedListener { void onFilePicked ( File file ) ; } public interface OnUriPickedListener { void onUriPicked ( Uri uri ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DebugUtils { public static void debugFields ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( "<STR_LIT>" + cls . getName ( ) ) ; for ( var field : cls . getDeclaredFields ( ) ) { try { field . setAccessible ( true ) ; var name = field . getName ( ) ; var value = field . get ( thisObject ) ; if ( value != null && value . getClass ( ) . isArray ( ) ) { value = Arrays . toString ( ( Object [ ] ) value ) ; } XposedBridge . log ( "<STR_LIT>" + name + "<STR_LIT>" + value ) ; } catch ( Exception ignored ) { } } } public static void debugAllMethods ( String className , String methodName , boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { XposedBridge . hookAllMethods ( XposedHelpers . findClass ( className , Utils . getApplication ( ) . getClassLoader ( ) ) , methodName , getDebugMethodHook ( printMethods , printFields , printArgs , printTrace ) ) ; } public static XC_MethodHook getDebugMethodHook ( boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { return new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { XposedBridge . log ( "<STR_LIT>" ) ; XposedBridge . log ( "<STR_LIT>" + param . method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + param . method . getName ( ) + "<STR_LIT>" + param . thisObject ) ; if ( printArgs ) { debugArgs ( param . args ) ; XposedBridge . log ( "<STR_LIT>" + ( param . getResult ( ) == null ? null : param . getResult ( ) . getClass ( ) . getName ( ) ) + "<STR_LIT>" + param . getResult ( ) ) ; } if ( printFields ) { debugFields ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printMethods ) { debugMethods ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printTrace ) { for ( var trace : Thread . currentThread ( ) . getStackTrace ( ) ) { XposedBridge . log ( "<STR_LIT>" + trace . toString ( ) ) ; } } XposedBridge . log ( "<STR_LIT>" ) ; } } ; } public static void debugArgs ( Object [ ] args ) { for ( var i = <NUM_LIT> ; i < args . length ; i ++ ) { XposedBridge . log ( "<STR_LIT>" + i + "<STR_LIT>" + ( args [ i ] == null ? null : args [ i ] . getClass ( ) . getName ( ) ) + "<STR_LIT>" + args [ i ] ) ; } } public static void debugMethods ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( "<STR_LIT>" + cls . getName ( ) ) ; for ( var method : cls . getDeclaredMethods ( ) ) { if ( method . getParameterCount ( ) > <NUM_LIT> ) continue ; try { method . setAccessible ( true ) ; XposedBridge . log ( "<STR_LIT>" + method . getName ( ) + "<STR_LIT>" + method . invoke ( thisObject ) ) ; } catch ( Exception ignored ) { } } } } </s>
<s> package com . wmods . wppenhacer . utils ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . os . Build ; import androidx . annotation . Nullable ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class StateListDrawableCompact { private static final Class < ? > mClass = StateListDrawable . class ; private StateListDrawableCompact ( ) { } public static int getStateCount ( StateListDrawable stateListDrawable ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateCount ( ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , "<STR_LIT>" ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable ) ; if ( invoke instanceof Integer ) { return ( Integer ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return <NUM_LIT> ; } @ Nullable public static Drawable getStateDrawable ( StateListDrawable stateListDrawable , int i ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateDrawable ( i ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , "<STR_LIT>" , Integer . TYPE ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable , i ) ; if ( invoke instanceof Drawable ) { return ( Drawable ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return null ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import android . annotation . SuppressLint ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . BaseAdapter ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeparateGroup extends Feature { public static final int CHATS = <NUM_LIT> ; public static final int STATUS = <NUM_LIT> ; public static final int CALLS = <NUM_LIT> ; public static final int COMMUNITY = <NUM_LIT> ; public static final int GROUPS = <NUM_LIT> ; public static ArrayList < Integer > tabs = new ArrayList < > ( ) ; public static HashMap < Integer , Object > tabInstances = new HashMap < > ( ) ; public SeparateGroup ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var home = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; hookTabList ( home ) ; if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; hookTabIcon ( ) ; hookTabInstance ( cFrag ) ; hookTabName ( home ) ; hookTabCount ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private void hookTabCount ( ) throws Exception { var runMethod = Unobfuscator . loadTabCountMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( runMethod ) ) ; var enableCountMethod = Unobfuscator . loadEnableCountTabMethod ( classLoader ) ; var constructor1 = Unobfuscator . loadEnableCountTabConstructor1 ( classLoader ) ; var constructor2 = Unobfuscator . loadEnableCountTabConstructor2 ( classLoader ) ; var constructor3 = Unobfuscator . loadEnableCountTabConstructor3 ( classLoader ) ; constructor3 . setAccessible ( true ) ; logDebug ( Unobfuscator . getMethodDescriptor ( enableCountMethod ) ) ; XposedBridge . hookMethod ( enableCountMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" } ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var indexTab = ( int ) param . args [ <NUM_LIT> ] ; if ( indexTab == tabs . indexOf ( CHATS ) ) { var chatCount = <NUM_LIT> ; var groupCount = <NUM_LIT> ; synchronized ( SeparateGroup . class ) { var db = MessageStore . getInstance ( ) . getDatabase ( ) ; var sql = "<STR_LIT>" ; var cursor = db . rawQuery ( sql , null ) ; while ( cursor . moveToNext ( ) ) { int jid = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int groupType = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int archived = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int chatLocked = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; if ( archived != <NUM_LIT> || ( groupType != <NUM_LIT> && groupType != <NUM_LIT> ) || chatLocked != <NUM_LIT> ) continue ; var sql2 = "<STR_LIT>" ; var cursor1 = db . rawQuery ( sql2 , new String [ ] { String . valueOf ( jid ) } ) ; if ( ! cursor1 . moveToFirst ( ) ) continue ; var server = cursor1 . getString ( cursor1 . getColumnIndex ( "<STR_LIT>" ) ) ; if ( server . equals ( "<STR_LIT>" ) ) { groupCount ++ ; } else { chatCount ++ ; } cursor1 . close ( ) ; } cursor . close ( ) ; } if ( tabs . contains ( CHATS ) && tabInstances . containsKey ( CHATS ) ) { var instance12 = chatCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( chatCount ) ; var instance22 = constructor1 . newInstance ( instance12 ) ; param . args [ <NUM_LIT> ] = instance22 ; } if ( tabs . contains ( GROUPS ) && tabInstances . containsKey ( GROUPS ) ) { var instance2 = groupCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( groupCount ) ; var instance1 = constructor1 . newInstance ( instance2 ) ; enableCountMethod . invoke ( param . thisObject , param . args [ <NUM_LIT> ] , instance1 , tabs . indexOf ( GROUPS ) ) ; } } } } ) ; } private void hookTabIcon ( ) throws Exception { var iconTabMethod = Unobfuscator . loadIconTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( iconTabMethod ) ) ; var iconField = Unobfuscator . loadIconTabField ( classLoader ) ; var iconFrameField = Unobfuscator . loadIconTabLayoutField ( classLoader ) ; var iconMenuField = Unobfuscator . loadIconMenuField ( classLoader ) ; XposedBridge . hookMethod ( iconTabMethod , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var superClass = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( superClass != null && superClass == iconTabMethod . getDeclaringClass ( ) ) { var field1 = superClass . getDeclaredField ( iconField . getName ( ) ) . get ( param . thisObject ) ; var field2 = getObjectField ( field1 , iconFrameField . getName ( ) ) ; if ( field2 == null ) return ; var menu = ( Menu ) getObjectField ( field2 , iconMenuField . getName ( ) ) ; if ( menu == null ) return ; var menuItem = ( MenuItem ) menu . findItem ( GROUPS ) ; if ( menuItem != null ) { menuItem . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; } } } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void hookTabName ( Class < ? > home ) throws Exception { var tabNameMethod = Unobfuscator . loadTabNameMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( tabNameMethod ) ) ; XposedBridge . hookMethod ( tabNameMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; var tab = ( int ) param . args [ <NUM_LIT> ] ; if ( tab == GROUPS ) { param . setResult ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; } } } ) ; } private void hookTabInstance ( Class < ? > cFrag ) throws Exception { var getTabMethod = Unobfuscator . loadGetTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getTabMethod ) ) ; var methodTabInstance = Unobfuscator . loadTabFragmentMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodTabInstance ) ) ; var recreateFragmentMethod = Unobfuscator . loadRecreateFragmentConstructor ( classLoader ) ; XposedBridge . hookMethod ( recreateFragmentMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var object = param . args [ <NUM_LIT> ] ; var desc = XposedHelpers . getObjectField ( object , "<STR_LIT>" ) ; if ( desc == null ) return ; var split = desc . toString ( ) . split ( "<STR_LIT>" ) ; var id = <NUM_LIT> ; try { id = Integer . parseInt ( split [ split . length - <NUM_LIT> ] ) ; } catch ( Exception ignored ) { return ; } if ( id == GROUPS || id == CHATS ) { var convFragment = XposedHelpers . getObjectField ( param . thisObject , "<STR_LIT>" ) ; tabInstances . remove ( id ) ; tabInstances . put ( id , convFragment ) ; } } } ) ; XposedBridge . hookMethod ( getTabMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; if ( tabId == GROUPS || tabId == CHATS ) { var convFragment = cFrag . newInstance ( ) ; param . setResult ( convFragment ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; tabInstances . remove ( tabId ) ; tabInstances . put ( tabId , param . getResult ( ) ) ; } } ) ; XposedBridge . hookMethod ( methodTabInstance , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var chatsList = ( List ) param . getResult ( ) ; var resultList = filterChat ( param . thisObject , chatsList ) ; param . setResult ( resultList ) ; } } ) ; var fabintMethod = Unobfuscator . loadFabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( fabintMethod ) ) ; XposedBridge . hookMethod ( fabintMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Objects . equals ( tabInstances . get ( GROUPS ) , param . thisObject ) ) { param . setResult ( GROUPS ) ; } } } ) ; var publishResultsMethod = Unobfuscator . loadGetFiltersMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( publishResultsMethod ) ) ; XposedBridge . hookMethod ( publishResultsMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var filters = param . args [ <NUM_LIT> ] ; var chatsList = ( List ) XposedHelpers . getObjectField ( filters , "<STR_LIT>" ) ; var baseField = Unobfuscator . getFieldByExtendType ( publishResultsMethod . getDeclaringClass ( ) , BaseAdapter . class ) ; if ( baseField == null ) return ; var convField = Unobfuscator . getFieldByType ( baseField . getType ( ) , cFrag ) ; Object thiz = convField . get ( baseField . get ( param . thisObject ) ) ; if ( thiz == null ) return ; var resultList = filterChat ( thiz , chatsList ) ; XposedHelpers . setObjectField ( filters , "<STR_LIT>" , resultList ) ; XposedHelpers . setIntField ( filters , "<STR_LIT>" , resultList . size ( ) ) ; } } ) ; } private List filterChat ( Object thiz , List chatsList ) { var tabChat = tabInstances . get ( CHATS ) ; var tabGroup = tabInstances . get ( GROUPS ) ; if ( ! Objects . equals ( tabChat , thiz ) && ! Objects . equals ( tabGroup , thiz ) ) { return chatsList ; } var editableChatList = new ArrayListFilter ( Objects . equals ( tabGroup , thiz ) ) ; editableChatList . addAll ( chatsList ) ; return editableChatList ; } private void hookTabList ( @ NonNull Class < ? > home ) throws Exception { var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var fieldTabsList = Arrays . stream ( home . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( List . class ) ) . findFirst ( ) . orElse ( null ) ; if ( fieldTabsList == null ) { throw new NullPointerException ( "<STR_LIT>" ) ; } fieldTabsList . setAccessible ( true ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { tabs = ( ArrayList < Integer > ) fieldTabsList . get ( null ) ; if ( tabs == null ) return ; if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! tabs . contains ( GROUPS ) ) { tabs . add ( tabs . isEmpty ( ) ? <NUM_LIT> : <NUM_LIT> , GROUPS ) ; } } } ) ; } public static class ArrayListFilter extends ArrayList < Object > { private final boolean isGroup ; public ArrayListFilter ( boolean isGroup ) { this . isGroup = isGroup ; } @ Override public void add ( int index , Object element ) { if ( checkGroup ( element ) ) { super . add ( index , element ) ; } } @ Override public boolean add ( Object object ) { if ( checkGroup ( object ) ) { return super . add ( object ) ; } return true ; } @ Override public boolean addAll ( @ NonNull Collection c ) { for ( var chat : c ) { if ( checkGroup ( chat ) ) { super . add ( chat ) ; } } return true ; } private boolean checkGroup ( Object chat ) { var requiredServer = isGroup ? "<STR_LIT>" : "<STR_LIT>" ; var jid = getObjectField ( chat , "<STR_LIT>" ) ; if ( XposedHelpers . findMethodExactIfExists ( jid . getClass ( ) , "<STR_LIT>" ) != null ) { var server = ( String ) callMethod ( jid , "<STR_LIT>" ) ; return server . equals ( requiredServer ) ; } return true ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DownloadViewOnce extends Feature { public DownloadViewOnce ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var initIntField = Unobfuscator . loadViewOnceDownloadMenuField2 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( initIntField ) ) ; var callMethod = Unobfuscator . loadViewOnceDownloadMenuCallMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( callMethod ) ) ; var fileField = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( fileField ) ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { try { var i = XposedHelpers . getIntField ( param . thisObject , initIntField . getName ( ) ) ; var message = callMethod . getParameterCount ( ) == <NUM_LIT> ? XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , param . thisObject , i ) : XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , i ) ; if ( message != null ) { var fileData = XposedHelpers . getObjectField ( message , "<STR_LIT>" ) ; var file = ( File ) ReflectionUtils . getField ( fileField , fileData ) ; var dest = Utils . getDestination ( prefs , "<STR_LIT>" ) ; var userJid = new FMessageWpp ( message ) . getKey ( ) . remoteJid ; var fileExtension = file . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; var name = Utils . generateName ( userJid , fileExtension ) ; var error = Utils . copyFile ( file , new File ( dest , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + dest , Toast . LENGTH_LONG ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_LONG ) ; } } } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; } return true ; } ) ; } } } ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . graphics . Color ; import android . view . View ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class BottomDialogWpp { private final Dialog dialog ; public BottomDialogWpp ( @ NonNull Dialog dialog ) { this . dialog = dialog ; } public void dismissDialog ( ) { dialog . dismiss ( ) ; } public void showDialog ( ) { dialog . show ( ) ; if ( dialog . getWindow ( ) != null ) { dialog . getWindow ( ) . setBackgroundDrawable ( null ) ; dialog . getWindow ( ) . setDimAmount ( <NUM_LIT> ) ; var view = dialog . getWindow ( ) . getDecorView ( ) ; view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) . setBackgroundColor ( Color . TRANSPARENT ) ; dialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_PAN ) ; } } public void setContentView ( View view ) { dialog . setContentView ( view ) ; } public void setCanceledOnTouchOutside ( boolean b ) { dialog . setCanceledOnTouchOutside ( b ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . os . Bundle ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import java . lang . reflect . Field ; import de . robv . android . xposed . XSharedPreferences ; public class DeleteStatus extends Feature { public DeleteStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var fragmentloader = Unobfuscator . loadFragmentLoader ( classLoader ) ; var showDialogStatus = Unobfuscator . loadShowDialogStatusMethod ( classLoader ) ; Class < ? > StatusDeleteDialogFragmentClass = classLoader . loadClass ( "<STR_LIT>" ) ; Field fieldBundle = ReflectionUtils . getFieldByType ( fragmentloader , Bundle . class ) ; var item = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . delete_for_me ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . delete_for_me , <NUM_LIT> , ResId . string . delete_for_me ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessage ) { try { var status = StatusDeleteDialogFragmentClass . newInstance ( ) ; var key = fMessage . getKey ( ) ; var bundle = getBundle ( key ) ; WppCore . setPrivBoolean ( key . messageID + "<STR_LIT>" , true ) ; log ( key . messageID ) ; fieldBundle . set ( status , bundle ) ; showDialogStatus . invoke ( status , status , fragmentInstance ) ; } catch ( Exception e ) { log ( e ) ; } } } ; menuStatuses . add ( item ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } @ NonNull private static Bundle getBundle ( FMessageWpp . Key key ) { var bundle = new Bundle ( ) ; bundle . putString ( "<STR_LIT>" , WppCore . getRawString ( key . remoteJid ) ) ; bundle . putBoolean ( "<STR_LIT>" , key . isFromMe ) ; bundle . putString ( "<STR_LIT>" , key . messageID ) ; return bundle ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import android . view . View ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideChat extends Feature { public static View . OnClickListener mClickListenerLocked ; public HideChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! Objects . equals ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) , "<STR_LIT>" ) ) { var archiveHideViewMethod = Unobfuscator . loadArchiveHideViewMethod ( classLoader ) ; for ( var method : archiveHideViewMethod ) { logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = false ; } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . SharedPreferences ; import android . database . sqlite . SQLiteDatabase ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . BottomDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class WppCore { static final HashSet < ActivityChangeState > listenerChat = new HashSet < > ( ) ; @ SuppressLint ( "<STR_LIT>" ) static Activity mCurrentActivity ; static LinkedHashSet < Activity > activities = new LinkedHashSet < > ( ) ; private static Class < ? > mGenJidClass ; private static Method mGenJidMethod ; private static Class bottomDialog ; private static Field convChatField ; private static Field chatJidField ; private static SharedPreferences privPrefs ; private static Object mStartUpConfig ; private static Object mActionUser ; private static SQLiteDatabase mWaDatabase ; public static void Initialize ( ClassLoader loader ) throws Exception { privPrefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; var mSendReadClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var subClass = ReflectionUtils . findConstructorUsingFilter ( mSendReadClass , ( constructor ) -> constructor . getParameterCount ( ) == <NUM_LIT> ) . getParameterTypes ( ) [ <NUM_LIT> ] ; mGenJidClass = ReflectionUtils . findFieldUsingFilter ( subClass , ( field ) -> Modifier . isStatic ( field . getModifiers ( ) ) ) . getType ( ) ; mGenJidMethod = ReflectionUtils . findMethodUsingFilter ( mGenJidClass , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && ! Modifier . isStatic ( method . getModifiers ( ) ) ) ; bottomDialog = Unobfuscator . loadDialogViewClass ( loader ) ; convChatField = Unobfuscator . loadAntiRevokeConvChatField ( loader ) ; chatJidField = Unobfuscator . loadAntiRevokeChatJidField ( loader ) ; var startPrefsConfig = Unobfuscator . loadStartPrefsConfig ( loader ) ; XposedBridge . hookMethod ( startPrefsConfig , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mStartUpConfig = param . thisObject ; } } ) ; var actionUser = Unobfuscator . loadActionUser ( loader ) ; XposedBridge . hookAllConstructors ( actionUser , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mActionUser = param . thisObject ; } } ) ; loadWADatabase ( ) ; } public static void sendMessage ( String number , String message ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilterIfExists ( mActionUser . getClass ( ) , ( method ) -> List . class . isAssignableFrom ( method . getReturnType ( ) ) && ReflectionUtils . findIndexOfType ( method . getParameterTypes ( ) , String . class ) != - <NUM_LIT> ) ; if ( senderMethod != null ) { var userJid = createUserJid ( number + "<STR_LIT>" ) ; if ( userJid == null ) { Utils . showToast ( "<STR_LIT>" , Toast . LENGTH_SHORT ) ; return ; } var newObject = new Object [ senderMethod . getParameterCount ( ) ] ; for ( int i = <NUM_LIT> ; i < newObject . length ; i ++ ) { var param = senderMethod . getParameterTypes ( ) [ i ] ; newObject [ i ] = Utils . getDefaultValue ( param ) ; } var index = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , String . class ) ; newObject [ index ] = message ; var index2 = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , List . class ) ; newObject [ index2 ] = Collections . singletonList ( userJid ) ; senderMethod . invoke ( mActionUser , newObject ) ; Utils . showToast ( "<STR_LIT>" + number , Toast . LENGTH_SHORT ) ; } } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void sendReaction ( String s , Object objMessage ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilter ( mActionUser . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && Arrays . equals ( method . getParameterTypes ( ) , new Class [ ] { FMessageWpp . TYPE , String . class , boolean . class } ) ) ; senderMethod . invoke ( mActionUser , objMessage , s , ! TextUtils . isEmpty ( s ) ) ; } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void loadWADatabase ( ) { if ( mWaDatabase != null ) return ; var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var database = new File ( dataDir , "<STR_LIT>" ) ; if ( database . exists ( ) ) { mWaDatabase = SQLiteDatabase . openDatabase ( database . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READONLY ) ; } } public static Activity getCurrentActivity ( ) { return mCurrentActivity ; } public static int getDefaultTheme ( ) { if ( mStartUpConfig != null ) { var result = ReflectionUtils . findMethodUsingFilterIfExists ( mStartUpConfig . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; if ( result != null ) { var value = ReflectionUtils . callMethod ( result , mStartUpConfig ) ; if ( value != null ) return ( int ) value ; } } var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; return startup_prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; } @ NonNull public static String getContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String name = getSContactName ( userJid , false ) ; if ( ! TextUtils . isEmpty ( name ) ) return name ; return getWppContactName ( userJid ) ; } @ NonNull public static String getSContactName ( Object userJid , boolean saveOnly ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String selection ; if ( saveOnly ) { selection = "<STR_LIT>" ; } else { selection = "<STR_LIT>" ; } String name = null ; var rawJid = getRawString ( userJid ) ; var cursor = mWaDatabase . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , selection , new String [ ] { rawJid } , null , null , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { name = cursor . getString ( <NUM_LIT> ) ; cursor . close ( ) ; } return name == null ? "<STR_LIT>" : name ; } @ NonNull public static String getWppContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String name = null ; var rawJid = getRawString ( userJid ) ; var cursor2 = mWaDatabase . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { rawJid } , null , null , null ) ; if ( cursor2 != null && cursor2 . moveToFirst ( ) ) { name = cursor2 . getString ( <NUM_LIT> ) ; cursor2 . close ( ) ; } return name == null ? "<STR_LIT>" : name ; } public static Object createUserJid ( String rawjid ) { var genInstance = XposedHelpers . newInstance ( mGenJidClass ) ; try { return mGenJidMethod . invoke ( genInstance , rawjid ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public static String getRawString ( Object userjid ) { if ( userjid == null ) return null ; return ( String ) XposedHelpers . callMethod ( userjid , "<STR_LIT>" ) ; } public static boolean isGroup ( String str ) { if ( str == null ) return false ; return str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) || ( ! str . contains ( "<STR_LIT>" ) && str . length ( ) > <NUM_LIT> ) ; } public static String getCurrentRawJID ( ) { var conversation = getCurrentConversation ( ) ; if ( conversation == null ) return null ; var chatField = XposedHelpers . getObjectField ( conversation , convChatField . getName ( ) ) ; var chatJidObj = XposedHelpers . getObjectField ( chatField , chatJidField . getName ( ) ) ; return getRawString ( chatJidObj ) ; } public static String stripJID ( String str ) { try { return ( str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) ) ? str . substring ( <NUM_LIT> , str . indexOf ( "<STR_LIT>" ) ) : str ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; return str ; } } public static Drawable getContactPhotoDrawable ( String jid ) { var file = getContactPhotoFile ( jid ) ; if ( file == null ) return null ; return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; } public static File getContactPhotoFile ( String jid ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + "<STR_LIT>" ; File file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + stripJID ( jid ) + "<STR_LIT>" ) ; if ( ! file . exists ( ) ) file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + jid + "<STR_LIT>" ) ; if ( file . exists ( ) ) return file ; return null ; } public static String getMyName ( ) { var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; return startup_prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static SharedPreferences getMainPrefs ( ) { return Utils . getApplication ( ) . getSharedPreferences ( Utils . getApplication ( ) . getPackageName ( ) + "<STR_LIT>" , Context . MODE_PRIVATE ) ; } public static String getMyBio ( ) { var mainPrefs = getMainPrefs ( ) ; return mainPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static Drawable getMyPhoto ( ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + "<STR_LIT>" ; File file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; if ( file . exists ( ) ) return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; return null ; } public static BottomDialogWpp createBottomDialog ( Context context ) { return new BottomDialogWpp ( ( Dialog ) XposedHelpers . newInstance ( bottomDialog , context , <NUM_LIT> ) ) ; } @ Nullable public static Activity getCurrentConversation ( ) { if ( mCurrentActivity == null ) return null ; Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , mCurrentActivity . getClassLoader ( ) ) ; if ( conversation . isInstance ( mCurrentActivity ) ) return mCurrentActivity ; return null ; } @ SuppressLint ( "<STR_LIT>" ) public static void setPrivString ( String key , String value ) { privPrefs . edit ( ) . putString ( key , value ) . commit ( ) ; } public static String getPrivString ( String key , String defaultValue ) { return privPrefs . getString ( key , defaultValue ) ; } @ SuppressLint ( "<STR_LIT>" ) public static void removePrivKey ( String s ) { if ( s != null && privPrefs . contains ( s ) ) privPrefs . edit ( ) . remove ( s ) . commit ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public static void setPrivBoolean ( String key , boolean value ) { privPrefs . edit ( ) . putBoolean ( key , value ) . commit ( ) ; } public static boolean getPrivBoolean ( String key , boolean defaultValue ) { return privPrefs . getBoolean ( key , defaultValue ) ; } public static void addListenerChat ( ActivityChangeState listener ) { listenerChat . add ( listener ) ; } public interface ActivityChangeState { void onChange ( Object object , ChangeType type ) ; enum ChangeType { START , END , RESUME , PAUSE } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . content . Context ; import android . database . Cursor ; import android . graphics . Color ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . HKDF ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Objects ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import javax . crypto . Cipher ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okio . BufferedSink ; import okio . Okio ; public class MediaPreview extends Feature { private static final String HTML_LOADING = "<STR_LIT>" ; private static final String HTML_VIDEO = "<STR_LIT>" ; private static final String HTML_IMAGE = "<STR_LIT>" ; private File filePath ; private AlertDialog dialog ; static HashMap < String , byte [ ] > MEDIA_KEYS = new HashMap < > ( ) ; static { MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; } public MediaPreview ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; var getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; var videoViewContainerClass = Unobfuscator . loadVideoViewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( videoViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; var surface = ( ViewGroup ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var controlFrame = surface . getChildAt ( <NUM_LIT> ) ; surface . removeViewAt ( <NUM_LIT> ) ; var linearLayout = new LinearLayout ( context ) ; surface . addView ( linearLayout ) ; linearLayout . addView ( controlFrame ) ; var prevBtn = new ImageView ( context ) ; var layoutParams = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams . gravity = Gravity . CENTER ; prevBtn . setLayoutParams ( layoutParams ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( "<STR_LIT>" ) ) ; } ) ; } } ) ; var imageViewContainerClass = Unobfuscator . loadImageVewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( imageViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ViewGroup mediaContainer = view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; ViewGroup controlFrame = view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . WRAP_CONTENT , FrameLayout . LayoutParams . WRAP_CONTENT , Gravity . CENTER ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; mediaContainer . removeView ( controlFrame ) ; linearLayout . addView ( controlFrame ) ; mediaContainer . addView ( linearLayout ) ; var prevBtn = new ImageView ( context ) ; var layoutParams2 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams2 . gravity = Gravity . CENTER ; layoutParams2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; prevBtn . setLayoutParams ( layoutParams2 ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; controlFrame . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( ( ) -> { if ( prevBtn . getVisibility ( ) != controlFrame . getVisibility ( ) ) prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; } ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( "<STR_LIT>" ) ) ; } ) ; } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void startPlayer ( long id , Context context , boolean isNewsletter ) { var executor = Executors . newSingleThreadExecutor ( ) ; try { Cursor cursor0 = MessageStore . getInstance ( ) . getDatabase ( ) . rawQuery ( String . format ( Locale . ENGLISH , "<STR_LIT>" , id ) , null ) ; if ( cursor0 != null && cursor0 . getCount ( ) > <NUM_LIT> ) { cursor0 . moveToFirst ( ) ; AtomicReference < String > url = new AtomicReference < > ( cursor0 . getString ( <NUM_LIT> ) ) ; String mine_type = cursor0 . getString ( <NUM_LIT> ) ; String media_key = cursor0 . getString ( <NUM_LIT> ) ; String direct_path = cursor0 . getString ( <NUM_LIT> ) ; cursor0 . close ( ) ; if ( isNewsletter ) { url . set ( "<STR_LIT>" + direct_path ) ; } var alertDialog = new AlertDialog . Builder ( context ) ; FrameLayout frameLayout = new FrameLayout ( context ) ; var webView = new WebView ( context ) ; webView . getSettings ( ) . setAllowFileAccess ( true ) ; webView . getSettings ( ) . setSupportZoom ( true ) ; webView . getSettings ( ) . setBuiltInZoomControls ( true ) ; webView . getSettings ( ) . setDisplayZoomControls ( false ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; webView . loadDataWithBaseURL ( null , HTML_LOADING . replace ( "<STR_LIT>" , context . getString ( ResId . string . loading ) ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; frameLayout . addView ( webView ) ; alertDialog . setView ( frameLayout ) ; alertDialog . setOnDismissListener ( dialog1 -> { if ( filePath != null && filePath . exists ( ) ) { filePath . delete ( ) ; } if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } ) ; dialog = alertDialog . create ( ) ; dialog . show ( ) ; executor . execute ( ( ) -> decodeMedia ( url . get ( ) , media_key , mine_type , executor , webView , isNewsletter ) ) ; } } catch ( Exception e ) { logDebug ( e ) ; Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) dialog . dismiss ( ) ; if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } } private void decodeMedia ( String url , String mediaKey , String mimeType , ExecutorService executor , WebView webView , boolean isNewsletter ) { try { String fileExtension = mimeType . startsWith ( "<STR_LIT>" ) ? "<STR_LIT>" : "<STR_LIT>" ; filePath = new File ( Utils . getApplication ( ) . getCacheDir ( ) , "<STR_LIT>" + fileExtension ) ; byte [ ] encryptedData = Objects . requireNonNull ( new OkHttpClient . Builder ( ) . addInterceptor ( chain -> chain . proceed ( chain . request ( ) . newBuilder ( ) . addHeader ( "<STR_LIT>" , "<STR_LIT>" ) . build ( ) ) ) . build ( ) . newCall ( new Request . Builder ( ) . url ( url ) . build ( ) ) . execute ( ) . body ( ) ) . source ( ) . readByteArray ( ) ; if ( filePath . exists ( ) ) { filePath . delete ( ) ; } byte [ ] decryptedData = isNewsletter ? encryptedData : decryptMedia ( encryptedData , mediaKey , mimeType ) ; assert decryptedData != null ; try ( BufferedSink bufferedSink = Okio . buffer ( Okio . sink ( filePath ) ) ) { bufferedSink . write ( decryptedData ) ; } webView . post ( ( ) -> { String fileUrl = "<STR_LIT>" + filePath . getAbsolutePath ( ) ; if ( mimeType . contains ( "<STR_LIT>" ) ) { webView . loadDataWithBaseURL ( null , HTML_IMAGE . replace ( "<STR_LIT>" , fileUrl ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; } else { webView . loadDataWithBaseURL ( null , HTML_VIDEO . replace ( "<STR_LIT>" , fileUrl ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; } } ) ; } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) { dialog . dismiss ( ) ; } } finally { if ( ! executor . isShutdown ( ) ) { executor . shutdownNow ( ) ; } } } private byte [ ] decryptMedia ( byte [ ] encryptedData , String mediaKey , String mimeType ) throws Exception { if ( mediaKey . length ( ) % <NUM_LIT> != <NUM_LIT> || mediaKey . length ( ) != <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } byte [ ] keyBytes = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i += <NUM_LIT> ) { keyBytes [ i / <NUM_LIT> ] = ( byte ) ( ( Character . digit ( mediaKey . charAt ( i ) , <NUM_LIT> ) << <NUM_LIT> ) + Character . digit ( mediaKey . charAt ( i + <NUM_LIT> ) , <NUM_LIT> ) ) ; } byte [ ] typeKey = MEDIA_KEYS . getOrDefault ( mimeType , MEDIA_KEYS . get ( "<STR_LIT>" ) ) ; byte [ ] derivedKey = HKDF . createFor ( <NUM_LIT> ) . deriveSecrets ( keyBytes , typeKey , <NUM_LIT> ) ; byte [ ] iv = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; byte [ ] aesKey = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( aesKey , "<STR_LIT>" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( Arrays . copyOfRange ( encryptedData , <NUM_LIT> , encryptedData . length - <NUM_LIT> ) ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideSeen extends Feature { public HideSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method SendReadReceiptJobMethod = Unobfuscator . loadHideViewSendReadJob ( classLoader ) ; var sendJob = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( SendReadReceiptJobMethod ) ) ; var hideread = prefs . getBoolean ( "<STR_LIT>" , false ) ; var hideread_group = prefs . getBoolean ( "<STR_LIT>" , false ) ; var hidestatusview = prefs . getBoolean ( "<STR_LIT>" , false ) ; XposedBridge . hookMethod ( SendReadReceiptJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! sendJob . isInstance ( param . thisObject ) ) return ; var srj = sendJob . cast ( param . thisObject ) ; var messageIds = XposedHelpers . getObjectField ( srj , "<STR_LIT>" ) ; var firstmessage = ( String ) Array . get ( messageIds , <NUM_LIT> ) ; if ( firstmessage != null && WppCore . getPrivBoolean ( firstmessage + "<STR_LIT>" , false ) ) { WppCore . removePrivKey ( firstmessage + "<STR_LIT>" ) ; return ; } var jid = ( String ) XposedHelpers . getObjectField ( srj , "<STR_LIT>" ) ; if ( jid == null ) return ; if ( WppCore . isGroup ( jid ) ) { if ( hideread_group ) param . setResult ( null ) ; } else if ( jid . startsWith ( "<STR_LIT>" ) ) { if ( hidestatusview ) param . setResult ( null ) ; } else if ( hideread ) { param . setResult ( null ) ; } } } ) ; Method hideViewInChatMethod = Unobfuscator . loadHideViewInChatMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewInChatMethod ) ) ; Method hideViewMethod = Unobfuscator . loadHideViewMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewMethod ) ) ; XposedBridge . hookMethod ( hideViewMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! Unobfuscator . isCalledFromMethod ( hideViewInChatMethod ) ) return ; if ( param . args [ <NUM_LIT> ] == null || ! param . args [ <NUM_LIT> ] . equals ( "<STR_LIT>" ) ) return ; var jid = WppCore . getCurrentRawJID ( ) ; if ( WppCore . isGroup ( jid ) ) { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) param . args [ <NUM_LIT> ] = null ; } else if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . args [ <NUM_LIT> ] = null ; } } } ) ; var methodPlayerViewJid = Unobfuscator . loadHideViewAudioMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPlayerViewJid ) ) ; XposedBridge . hookMethod ( methodPlayerViewJid , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) param . setResult ( true ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . ActivityAboutBinding ; public class AboutActivity extends AppCompatActivity { private ActivityAboutBinding binding ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; binding = ActivityAboutBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; binding . btnTelegram . setOnClickListener ( v -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; binding . btnGithub . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; binding . btnDonate . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . View ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CopyStatus extends Feature { public CopyStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . getResult ( ) ; var caption = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( caption != null ) { caption . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( caption . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; var viewStatusMethod = Unobfuscator . loadBlueOnReplayStatusViewMethod ( classLoader ) ; XposedBridge . hookMethod ( viewStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var text = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( text != null ) { text . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( text . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . adapter ; import androidx . annotation . NonNull ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . viewpager2 . adapter . FragmentStateAdapter ; import com . wmods . wppenhacer . ui . fragments . CustomizationFragment ; import com . wmods . wppenhacer . ui . fragments . GeneralFragment ; import com . wmods . wppenhacer . ui . fragments . HomeFragment ; import com . wmods . wppenhacer . ui . fragments . MediaFragment ; import com . wmods . wppenhacer . ui . fragments . PrivacyFragment ; public class MainPagerAdapter extends FragmentStateAdapter { public MainPagerAdapter ( @ NonNull FragmentActivity fragmentActivity ) { super ( fragmentActivity ) ; } @ NonNull @ Override public Fragment createFragment ( int position ) { return switch ( position ) { case <NUM_LIT> -> new GeneralFragment ( ) ; case <NUM_LIT> -> new PrivacyFragment ( ) ; case <NUM_LIT> -> new MediaFragment ( ) ; case <NUM_LIT> -> new CustomizationFragment ( ) ; default -> new HomeFragment ( ) ; } ; } @ Override public int getItemCount ( ) { return <NUM_LIT> ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . annotation . SuppressLint ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . FragmentActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . MainActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . FragmentHomeBinding ; import com . wmods . wppenhacer . ui . fragments . base . BaseFragment ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Date ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import rikka . core . util . IOUtils ; public class HomeFragment extends BaseFragment { private FragmentHomeBinding binding ; @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; var intentFilter = new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; ContextCompat . registerReceiver ( requireContext ( ) , new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { try { if ( FeatureLoader . PACKAGE_WPP . equals ( intent . getStringExtra ( "<STR_LIT>" ) ) ) receiverBroadcastWpp ( context , intent ) ; else receiverBroadcastBusiness ( context , intent ) ; } catch ( Exception ignored ) { } } } , intentFilter , ContextCompat . RECEIVER_EXPORTED ) ; } public View onCreateView ( @ NonNull LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { binding = FragmentHomeBinding . inflate ( inflater , container , false ) ; checkStateWpp ( requireActivity ( ) ) ; binding . rebootBtn . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; disableWpp ( requireActivity ( ) ) ; } ) ; binding . rebootBtn2 . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; disableBusiness ( requireActivity ( ) ) ; } ) ; binding . exportBtn . setOnClickListener ( view -> saveConfigs ( this . getContext ( ) ) ) ; binding . importBtn . setOnClickListener ( view -> importConfigs ( this . getContext ( ) ) ) ; binding . resetBtn . setOnClickListener ( view -> resetConfigs ( this . getContext ( ) ) ) ; return binding . getRoot ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void receiverBroadcastBusiness ( Context context , Intent intent ) { binding . statusTitle3 . setText ( R . string . business_in_background ) ; var version = intent . getStringExtra ( "<STR_LIT>" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) { binding . statusSummary3 . setText ( getString ( R . string . version_s , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary3 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn2 . setVisibility ( View . VISIBLE ) ; binding . statusSummary3 . setVisibility ( View . VISIBLE ) ; binding . statusIcon3 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } @ SuppressLint ( "<STR_LIT>" ) private void receiverBroadcastWpp ( Context context , Intent intent ) { binding . statusTitle2 . setText ( R . string . whatsapp_in_background ) ; var version = intent . getStringExtra ( "<STR_LIT>" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) { binding . statusSummary1 . setText ( getString ( R . string . version_s , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary1 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn . setVisibility ( View . VISIBLE ) ; binding . statusSummary1 . setVisibility ( View . VISIBLE ) ; binding . statusIcon2 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } private void resetConfigs ( Context context ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; Utils . showToast ( context . getString ( R . string . configs_reset ) , Toast . LENGTH_SHORT ) ; } private static @ NonNull JSONObject getJsonObject ( SharedPreferences prefs ) throws JSONException { var entries = prefs . getAll ( ) ; var JSOjsonObject = new JSONObject ( ) ; for ( var entry : entries . entrySet ( ) ) { var type = new JSONObject ( ) ; var keyValue = entry . getValue ( ) ; if ( keyValue instanceof HashSet < ? > hashSet ) { keyValue = new JSONArray ( new ArrayList < > ( hashSet ) ) ; } type . put ( "<STR_LIT>" , entry . getValue ( ) . getClass ( ) . getSimpleName ( ) ) ; type . put ( "<STR_LIT>" , keyValue ) ; JSOjsonObject . put ( entry . getKey ( ) , type ) ; } return JSOjsonObject ; } private void saveConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var output = context . getContentResolver ( ) . openOutputStream ( uri ) ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var JSOjsonObject = getJsonObject ( prefs ) ; Objects . requireNonNull ( output ) . write ( JSOjsonObject . toString ( <NUM_LIT> ) . getBytes ( ) ) ; } Toast . makeText ( context , context . getString ( R . string . configs_saved ) , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "<STR_LIT>" , Locale . US ) ; String formattedDate = dateFormat . format ( new Date ( ) ) ; FilePicker . fileSalve . launch ( "<STR_LIT>" + formattedDate + "<STR_LIT>" ) ; } private void importConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var input = context . getContentResolver ( ) . openInputStream ( uri ) ) { var data = IOUtils . toString ( input ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var jsonObject = new JSONObject ( data ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; var key = jsonObject . keys ( ) ; while ( key . hasNext ( ) ) { var keyName = key . next ( ) ; var value = jsonObject . get ( keyName ) ; var type = value . getClass ( ) . getSimpleName ( ) ; if ( value instanceof JSONObject valueJson ) { value = valueJson . get ( "<STR_LIT>" ) ; type = valueJson . getString ( "<STR_LIT>" ) ; } if ( type . equals ( JSONArray . class . getSimpleName ( ) ) ) { var jsonArray = ( JSONArray ) value ; HashSet < String > hashSet = new HashSet < > ( ) ; for ( var i = <NUM_LIT> ; i < jsonArray . length ( ) ; i ++ ) { hashSet . add ( jsonArray . getString ( i ) ) ; } prefs . edit ( ) . putStringSet ( keyName , hashSet ) . apply ( ) ; } else if ( type . equals ( String . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putString ( keyName , ( String ) value ) . apply ( ) ; } else if ( type . equals ( Boolean . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putBoolean ( keyName , ( boolean ) value ) . apply ( ) ; } else if ( type . equals ( Integer . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putInt ( keyName , ( int ) value ) . apply ( ) ; } else if ( type . equals ( Long . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putLong ( keyName , ( long ) value ) . apply ( ) ; } else if ( type . equals ( Double . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } else if ( type . equals ( Float . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } } } Toast . makeText ( context , context . getString ( R . string . configs_imported ) , Toast . LENGTH_SHORT ) . show ( ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; } catch ( Exception e ) { Log . e ( "<STR_LIT>" , e . getMessage ( ) , e ) ; Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; FilePicker . fileCapture . launch ( new String [ ] { "<STR_LIT>" } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void checkStateWpp ( FragmentActivity activity ) { if ( MainActivity . isXposedEnabled ( ) ) { binding . statusIcon . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; binding . statusTitle . setText ( R . string . module_enabled ) ; binding . statusSummary . setText ( String . format ( getString ( R . string . version_s ) , BuildConfig . VERSION_NAME ) ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_green ) ) ; } else { binding . statusIcon . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle . setText ( R . string . module_disabled ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary . setVisibility ( View . GONE ) ; } if ( isInstalled ( FeatureLoader . PACKAGE_WPP ) ) { disableWpp ( activity ) ; } else { binding . status2 . setVisibility ( View . GONE ) ; } if ( isInstalled ( FeatureLoader . PACKAGE_BUSINESS ) ) { disableBusiness ( activity ) ; } else { binding . status3 . setVisibility ( View . GONE ) ; } checkWpp ( activity ) ; binding . deviceName . setText ( Build . MANUFACTURER ) ; binding . sdk . setText ( String . valueOf ( Build . VERSION . SDK_INT ) ) ; binding . modelName . setText ( Build . DEVICE ) ; binding . listWpp . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ) ; binding . listBusiness . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ) ; } private boolean isInstalled ( String packageWpp ) { try { App . getInstance ( ) . getPackageManager ( ) . getPackageInfo ( packageWpp , <NUM_LIT> ) ; return true ; } catch ( Exception ignored ) { } return false ; } private void disableBusiness ( FragmentActivity activity ) { binding . statusIcon3 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle3 . setText ( R . string . business_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status3 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary3 . setVisibility ( View . GONE ) ; binding . rebootBtn2 . setVisibility ( View . GONE ) ; } private void disableWpp ( FragmentActivity activity ) { binding . statusIcon2 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle2 . setText ( R . string . whatsapp_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status2 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary1 . setVisibility ( View . GONE ) ; binding . rebootBtn . setVisibility ( View . GONE ) ; } private static void checkWpp ( FragmentActivity activity ) { Intent checkWpp = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; activity . sendBroadcast ( checkWpp ) ; } @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; binding = null ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Color ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class DownloadProfile extends Feature { public DownloadProfile ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var loadProfileInfoField = Unobfuscator . loadProfileInfoField ( classLoader ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; if ( icon != null ) { icon . setTint ( Color . WHITE ) ; item . setIcon ( icon ) ; } item . setOnMenuItemClickListener ( menuItem -> { var subCls = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( subCls == null ) { log ( new Exception ( "<STR_LIT>" ) ) ; return true ; } var field = Unobfuscator . getFieldByType ( subCls , loadProfileInfoField . getDeclaringClass ( ) ) ; var jidObj = ReflectionUtils . getField ( loadProfileInfoField , ReflectionUtils . getField ( field , param . thisObject ) ) ; var jid = WppCore . stripJID ( WppCore . getRawString ( jidObj ) ) ; var file = WppCore . getContactPhotoFile ( jid ) ; var destPath = Utils . getDestination ( prefs , "<STR_LIT>" ) ; var name = Utils . generateName ( jidObj , "<STR_LIT>" ) ; var error = Utils . copyFile ( file , new File ( destPath , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destPath , Toast . LENGTH_LONG ) . show ( ) ; } else { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_LONG ) . show ( ) ; } return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . content . Intent ; import android . content . SharedPreferences ; import android . media . MediaScannerConnection ; import android . net . Uri ; import android . os . Environment ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . utils . MimeTypeUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Collections ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class StatusDownload extends Feature { private Field fieldFile ; public StatusDownload ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; var downloadStatus = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . download ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . download , <NUM_LIT> , ResId . string . download ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { downloadFile ( fMessageWpp ) ; } } ; menuStatuses . add ( downloadStatus ) ; var sharedMenu = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( fMessage . getKey ( ) . isFromMe ) return null ; if ( menu . findItem ( ResId . string . share_as_status ) != null ) return null ; return menu . add ( <NUM_LIT> , ResId . string . share_as_status , <NUM_LIT> , ResId . string . share_as_status ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sharedStatus ( fMessageWpp ) ; } } ; menuStatuses . add ( sharedMenu ) ; } private void sharedStatus ( FMessageWpp fMessageWpp ) { try { var fileData = XposedHelpers . getObjectField ( fMessageWpp . getObject ( ) , "<STR_LIT>" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , new ArrayList < > ( Collections . singleton ( "<STR_LIT>" ) ) ) ; intent . putExtra ( "<STR_LIT>" , new ArrayList < > ( Collections . singleton ( Uri . fromFile ( file ) ) ) ) ; intent . putExtra ( "<STR_LIT>" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } private void downloadFile ( FMessageWpp fMessage ) { try { var fileData = XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . msg_text_status_not_downloadable ) , Toast . LENGTH_SHORT ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; var userJid = fMessage . getUserJid ( ) ; var fileType = file . getName ( ) . substring ( file . getName ( ) . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; var destination = getPathDestination ( prefs , file ) ; var name = Utils . generateName ( userJid , fileType ) ; var destinationFile = new File ( destination , name ) ; var error = Utils . copyFile ( file , destinationFile ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destinationFile . getAbsolutePath ( ) , Toast . LENGTH_SHORT ) ; log ( "<STR_LIT>" + destinationFile . getAbsolutePath ( ) ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_SHORT ) ; } } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private boolean copyFile ( SharedPreferences prefs , File file ) throws IOException { if ( file == null || ! file . exists ( ) ) throw new IOException ( "<STR_LIT>" ) ; var destination = getPathDestination ( prefs , file ) ; try ( FileInputStream in = new FileInputStream ( file ) ; FileOutputStream out = new FileOutputStream ( destination ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { destination } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( path , uri ) -> { } ) ; return true ; } out . write ( bArr , <NUM_LIT> , read ) ; } } } @ NonNull private String getPathDestination ( SharedPreferences sharedPreferences , @ NonNull File f ) { var fileName = f . getName ( ) . toLowerCase ( ) ; var mediaPath = getStatusFolderPath ( sharedPreferences , MimeTypeUtils . getMimeTypeFromExtension ( fileName ) ) ; if ( ! mediaPath . exists ( ) ) mediaPath . mkdirs ( ) ; return mediaPath + "<STR_LIT>" ; } @ NonNull private File getStatusFolderPath ( SharedPreferences sharedPreferences , @ NonNull String mimeType ) { String folderPath = sharedPreferences . getString ( "<STR_LIT>" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "<STR_LIT>" ) ; if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else { folderPath += "<STR_LIT>" ; } return new File ( folderPath ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FilterGroups extends Feature { private Method methodSetFilter ; private Object mFilterInstance ; private Object mConversationFragment ; private Method methodInitFilter ; private TextView tabConversas ; private TextView tabGrupos ; public FilterGroups ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) || prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( Utils . getApplication ( ) . getPackageName ( ) . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( classLoader ) ; methodSetFilter = ReflectionUtils . findMethodUsingFilter ( filterAdaperClass , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; XposedBridge . hookAllConstructors ( filterAdaperClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mFilterInstance = param . thisObject ; } } ) ; var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookAllConstructors ( cFrag , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mConversationFragment = param . thisObject ; } } ) ; methodInitFilter = Unobfuscator . getFilterInitMethod ( classLoader ) ; var filterView = Unobfuscator . getFilterView ( classLoader ) ; XposedHelpers . findAndHookConstructor ( filterView , android . content . Context . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { setSetupSeparate ( ( ViewGroup ) param . thisObject ) ; } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void setSetupSeparate ( ViewGroup view ) { var context = view . getContext ( ) ; if ( view . findViewById ( <NUM_LIT> ) != null ) return ; var container = new LinearLayout ( context ) ; container . setOrientation ( LinearLayout . VERTICAL ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; container . setId ( <NUM_LIT> ) ; var filter = view . getChildAt ( <NUM_LIT> ) ; view . removeView ( filter ) ; LinearLayout mainLayout = new LinearLayout ( context ) ; mainLayout . setOrientation ( LinearLayout . VERTICAL ) ; var params = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . leftMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . rightMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . bottomMargin = Utils . dipToPixels ( <NUM_LIT> ) ; mainLayout . setLayoutParams ( params ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , DesignUtils . getUnSeenColor ( ) ) ; borderDrawable . setCornerRadius ( Utils . dipToPixels ( <NUM_LIT> ) ) ; mainLayout . setBackground ( borderDrawable ) ; LinearLayout tabLayout = new LinearLayout ( context ) ; tabLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; mainLayout . addView ( tabLayout , new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; tabConversas = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , <NUM_LIT> ) ; tabConversas . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabConversas . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabGrupos = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , <NUM_LIT> ) ; tabGrupos . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabGrupos . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabLayout . addView ( tabConversas ) ; tabLayout . addView ( tabGrupos ) ; updateContent ( <NUM_LIT> ) ; container . addView ( mainLayout ) ; container . addView ( filter ) ; view . addView ( container , <NUM_LIT> ) ; } private TextView createTab ( Context context , String text , int left ) { TextView tab = new TextView ( context ) ; tab . setText ( text ) ; tab . setGravity ( Gravity . CENTER ) ; tab . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; tab . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; setDrawableSelected ( tab , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , left ) ; return tab ; } private void setDrawableSelected ( View view , int colorBackground , int colorStroke , int left ) { float border = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] rects = left == <NUM_LIT> ? new float [ ] { border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , border , border } : new float [ ] { <NUM_LIT> , <NUM_LIT> , border , border , border , border , <NUM_LIT> , <NUM_LIT> } ; ShapeDrawable shape = new ShapeDrawable ( new RoundRectShape ( rects , null , null ) ) ; shape . getPaint ( ) . setColor ( colorBackground ) ; shape . setAlpha ( <NUM_LIT> ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , colorStroke ) ; borderDrawable . setCornerRadii ( rects ) ; LayerDrawable layerDrawable = new LayerDrawable ( new Drawable [ ] { borderDrawable , shape } ) ; layerDrawable . setLayerInset ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; view . setBackground ( layerDrawable ) ; } private void updateContent ( int position ) { if ( position == <NUM_LIT> ) { setDrawableSelected ( tabConversas , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setDrawableSelected ( tabGrupos , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } else { setDrawableSelected ( tabConversas , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setDrawableSelected ( tabGrupos , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } } private void setFilter ( int position ) { try { ReflectionUtils . callMethod ( methodInitFilter , null , mConversationFragment ) ; ReflectionUtils . callMethod ( methodSetFilter , mFilterInstance , position + <NUM_LIT> ) ; } catch ( Exception e ) { logDebug ( e ) ; } } @ NonNull @ Override public String getPluginName ( ) { return null ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . database . Cursor ; import android . os . Bundle ; import android . provider . ContactsContract ; import android . text . Editable ; import android . text . TextWatcher ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ListView ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; public class ContactPickerActivity extends AppCompatActivity { private String mKey ; private ListView contactListView ; private ArrayAdapter < String > adapter ; private HashSet < String > selectedNumbers = new HashSet < > ( ) ; private final List < Contact > allContacts = new ArrayList < > ( ) ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; setContentView ( R . layout . activity_contact_picker ) ; mKey = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; contactListView = findViewById ( R . id . contactListView ) ; Button selectButton = findViewById ( R . id . selectButton ) ; EditText searchBar = findViewById ( R . id . searchBar ) ; ArrayList < String > selectedNumbersInIntent = getIntent ( ) . getStringArrayListExtra ( "<STR_LIT>" ) ; if ( selectedNumbersInIntent != null ) { selectedNumbers = new HashSet < > ( selectedNumbersInIntent ) ; } loadAllContacts ( ) ; insertContactsInList ( allContacts ) ; selectButton . setOnClickListener ( view -> { Intent resultIntent = new Intent ( ) ; resultIntent . putExtra ( "<STR_LIT>" , new ArrayList < > ( selectedNumbers ) ) ; resultIntent . putExtra ( "<STR_LIT>" , mKey ) ; setResult ( Activity . RESULT_OK , resultIntent ) ; finish ( ) ; } ) ; searchBar . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { String searchText = charSequence . toString ( ) . toLowerCase ( ) ; List < Contact > filteredContacts = allContacts . stream ( ) . filter ( contact -> contact . name . toLowerCase ( ) . contains ( searchText ) || contact . number . contains ( searchText ) ) . collect ( Collectors . toList ( ) ) ; insertContactsInList ( filteredContacts ) ; } @ Override public void afterTextChanged ( Editable editable ) { } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void loadAllContacts ( ) { allContacts . clear ( ) ; Set < String > uniqueNumbers = new HashSet < > ( ) ; Cursor cursor = getContentResolver ( ) . query ( ContactsContract . CommonDataKinds . Phone . CONTENT_URI , null , null , null , ContactsContract . CommonDataKinds . Phone . STARRED + "<STR_LIT>" + ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME + "<STR_LIT>" ) ; if ( cursor != null ) { while ( cursor . moveToNext ( ) ) { String nome = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME ) ) ; String numero = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . NUMBER ) ) ; int starred = cursor . getInt ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . STARRED ) ) ; String numeroLimpo = numero . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( ! uniqueNumbers . contains ( numeroLimpo ) ) { uniqueNumbers . add ( numeroLimpo ) ; allContacts . add ( new Contact ( nome , numeroLimpo , starred == <NUM_LIT> ) ) ; } } cursor . close ( ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void insertContactsInList ( List < Contact > contacts ) { List < String > contactList = contacts . stream ( ) . map ( contact -> contact . name + "<STR_LIT>" + contact . number ) . collect ( Collectors . toList ( ) ) ; contactList . sort ( ( contact1 , contact2 ) -> { String number1 = contact1 . substring ( contact1 . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; String number2 = contact2 . substring ( contact2 . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; boolean isSelected1 = selectedNumbers . contains ( number1 ) ; boolean isSelected2 = selectedNumbers . contains ( number2 ) ; if ( isSelected1 && ! isSelected2 ) { return - <NUM_LIT> ; } else if ( ! isSelected1 && isSelected2 ) { return <NUM_LIT> ; } else { return contact1 . compareToIgnoreCase ( contact2 ) ; } } ) ; adapter = new ArrayAdapter < > ( this , android . R . layout . simple_list_item_multiple_choice , contactList ) ; contactListView . setAdapter ( adapter ) ; contactListView . setChoiceMode ( ListView . CHOICE_MODE_MULTIPLE ) ; for ( int i = <NUM_LIT> ; i < contactList . size ( ) ; i ++ ) { String contactInfo = contactList . get ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; if ( selectedNumbers . contains ( number ) ) { contactListView . setItemChecked ( i , true ) ; } } contactListView . setOnItemClickListener ( ( adapterView , view , i , l ) -> { String contactInfo = adapter . getItem ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; if ( selectedNumbers . contains ( number ) ) { selectedNumbers . remove ( number ) ; } else { selectedNumbers . add ( number ) ; } } ) ; } public static class Contact { public String name ; public String number ; public boolean isStarred ; public Contact ( String name , String number , boolean isStarred ) { this . name = name ; this . number = number ; this . isStarred = isStarred ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . ContentValues ; import android . os . Bundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ChatLimit extends Feature { public ChatLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var antiDisappearing = prefs . getBoolean ( "<STR_LIT>" , false ) ; var revokeallmessages = prefs . getBoolean ( "<STR_LIT>" , false ) ; var chatLimitDeleteMethod = Unobfuscator . loadChatLimitDeleteMethod ( classLoader ) ; var chatLimitDelete2Method = Unobfuscator . loadChatLimitDelete2Method ( classLoader ) ; var epUpdateMethod = Unobfuscator . loadEphemeralInsertdb ( classLoader ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { MessageStore . getInstance ( ) . executeSQL ( "<STR_LIT>" ) ; } } } ) ; XposedBridge . hookMethod ( epUpdateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { var contentValues = ( ContentValues ) param . getResult ( ) ; contentValues . put ( "<STR_LIT>" , <NUM_LIT> ) ; } } } ) ; XposedBridge . hookMethod ( chatLimitDeleteMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Unobfuscator . isCalledFromMethod ( chatLimitDelete2Method ) && revokeallmessages ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var seeMoreMethod = Unobfuscator . loadSeeMoreMethod ( classLoader ) ; XposedBridge . hookMethod ( seeMoreMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . adapter ; import static com . wmods . wppenhacer . xposed . features . customization . IGStatus . itens ; import android . content . Context ; import android . content . Intent ; import android . graphics . Color ; import android . graphics . Typeface ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . TabDialogContent ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . Objects ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatusAdapter extends ArrayAdapter { private final Class < ? > clazzImageStatus ; private final Class < ? > statusInfoClazz ; private final Method setCountStatus ; @ NonNull @ Override public View getView ( int position , @ Nullable View convertView , @ NonNull ViewGroup parent ) { var item = itens . get ( position ) ; IGStatusViewHolder holder ; if ( convertView == null ) { holder = new IGStatusViewHolder ( ) ; convertView = createLayoutStatus ( holder ) ; convertView . setTag ( holder ) ; } else { holder = ( IGStatusViewHolder ) convertView . getTag ( ) ; } if ( item == null ) { holder . setInfo ( "<STR_LIT>" ) ; } else if ( statusInfoClazz . isInstance ( item ) ) { holder . setInfo ( item ) ; } convertView . setOnClickListener ( v -> { if ( holder . myStatus ) { var activity = WppCore . getCurrentActivity ( ) ; var dialog = WppCore . createBottomDialog ( activity ) ; var tabdialog = new TabDialogContent ( activity ) ; tabdialog . setTitle ( activity . getString ( ResId . string . select_status_type ) ) ; tabdialog . addTab ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( "<STR_LIT>" , getContext ( ) . getClassLoader ( ) ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . open_camera ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , "<STR_LIT>" ) ; A09 . putExtra ( "<STR_LIT>" , "<STR_LIT>" ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , false ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; activity . startActivity ( A09 ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . edit_text ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , "<STR_LIT>" ) ; activity . startActivity ( A09 ) ; dialog . dismissDialog ( ) ; } ) ; dialog . setContentView ( tabdialog ) ; dialog . showDialog ( ) ; return ; } var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( "<STR_LIT>" , getContext ( ) . getClassLoader ( ) ) ) ; intent . putExtra ( "<STR_LIT>" , holder . jid ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } ) ; return convertView ; } public IGStatusAdapter ( @ NonNull Context context , @ NonNull Class < ? > statusInfoClazz ) { super ( context , <NUM_LIT> ) ; this . clazzImageStatus = XposedHelpers . findClass ( "<STR_LIT>" , this . getContext ( ) . getClassLoader ( ) ) ; this . statusInfoClazz = statusInfoClazz ; this . setCountStatus = ReflectionUtils . findMethodUsingFilter ( this . clazzImageStatus , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; } @ Override public int getCount ( ) { return itens . size ( ) ; } class IGStatusViewHolder { public ImageView igStatusContactPhoto ; public RelativeLayout addButton ; public TextView igStatusContactName ; public boolean myStatus ; private String jid ; public void setInfo ( Object item ) { if ( Objects . equals ( item , "<STR_LIT>" ) ) { myStatus = true ; igStatusContactName . setText ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; igStatusContactPhoto . setImageDrawable ( WppCore . getMyPhoto ( ) ) ; setCountStatus ( <NUM_LIT> , <NUM_LIT> ) ; return ; } var statusInfo = XposedHelpers . getObjectField ( item , "<STR_LIT>" ) ; var field = ReflectionUtils . getFieldByType ( statusInfo . getClass ( ) , XposedHelpers . findClass ( "<STR_LIT>" , statusInfoClazz . getClassLoader ( ) ) ) ; var userJid = ReflectionUtils . getField ( field , statusInfo ) ; var contactName = WppCore . getContactName ( userJid ) ; jid = WppCore . getRawString ( userJid ) ; igStatusContactName . setText ( contactName ) ; var profile = WppCore . getContactPhotoDrawable ( jid ) ; if ( profile == null ) profile = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; igStatusContactPhoto . setImageDrawable ( profile ) ; var countUnseen = XposedHelpers . getIntField ( statusInfo , "<STR_LIT>" ) ; var total = XposedHelpers . getIntField ( statusInfo , "<STR_LIT>" ) ; setCountStatus ( countUnseen , total ) ; } public void setCountStatus ( int countUnseen , int total ) { if ( setCountStatus != null ) { try { setCountStatus . invoke ( igStatusContactPhoto , countUnseen , total ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } } } @ NonNull private RelativeLayout createLayoutStatus ( IGStatusViewHolder holder ) { RelativeLayout relativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams relativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , ViewGroup . LayoutParams . WRAP_CONTENT ) ; relativeLayout . setLayoutParams ( relativeParams ) ; FrameLayout frameLayout = new FrameLayout ( this . getContext ( ) ) ; frameLayout . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; LinearLayout linearLayout = new LinearLayout ( this . getContext ( ) ) ; LinearLayout . LayoutParams linearParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( linearParams ) ; RelativeLayout internalRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams internalRelativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; internalRelativeLayout . setLayoutParams ( internalRelativeParams ) ; var contactPhoto = ( ImageView ) XposedHelpers . newInstance ( this . clazzImageStatus , this . getContext ( ) ) ; RelativeLayout . LayoutParams photoParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; contactPhoto . setLayoutParams ( photoParams ) ; contactPhoto . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; contactPhoto . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; contactPhoto . setImageDrawable ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; holder . igStatusContactPhoto = contactPhoto ; contactPhoto . setClickable ( true ) ; XposedHelpers . callMethod ( contactPhoto , "<STR_LIT>" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . callMethod ( contactPhoto , "<STR_LIT>" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . setObjectField ( contactPhoto , "<STR_LIT>" , Color . GRAY ) ; XposedHelpers . setObjectField ( contactPhoto , "<STR_LIT>" , DesignUtils . getUnSeenColor ( ) ) ; RelativeLayout addBtnRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; addBtnRelativeLayout . setBackgroundColor ( Color . TRANSPARENT ) ; RelativeLayout . LayoutParams addBtnParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_BOTTOM ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_END ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; addBtnRelativeLayout . setLayoutParams ( addBtnParams ) ; addBtnRelativeLayout . setVisibility ( View . GONE ) ; holder . addButton = addBtnRelativeLayout ; ImageView iconImageView = new ImageView ( this . getContext ( ) ) ; RelativeLayout . LayoutParams iconParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; iconImageView . setLayoutParams ( iconParams ) ; var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; iconImageView . setImageDrawable ( icon ) ; iconImageView . setBackgroundColor ( Color . TRANSPARENT ) ; addBtnRelativeLayout . addView ( iconImageView ) ; internalRelativeLayout . addView ( contactPhoto ) ; internalRelativeLayout . addView ( addBtnRelativeLayout ) ; TextView contactName = new TextView ( this . getContext ( ) ) ; contactName . setEllipsize ( TextUtils . TruncateAt . END ) ; contactName . setGravity ( Gravity . CENTER ) ; LinearLayout . LayoutParams nameParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; contactName . setLayoutParams ( nameParams ) ; contactName . setText ( "<STR_LIT>" ) ; contactName . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; contactName . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; contactName . setTypeface ( Typeface . DEFAULT_BOLD ) ; contactName . setMaxLines ( <NUM_LIT> ) ; holder . igStatusContactName = contactName ; linearLayout . addView ( internalRelativeLayout ) ; linearLayout . addView ( contactName ) ; frameLayout . addView ( linearLayout ) ; relativeLayout . addView ( frameLayout ) ; return relativeLayout ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideReceipt extends Feature { public HideReceipt ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method ) ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method2 ) ) ; var method3 = Unobfuscator . loadReceiptInChat ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method3 ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! Unobfuscator . isCalledFromMethod ( method2 ) && ! Unobfuscator . isCalledFromMethod ( method3 ) ) return ; var jid = WppCore . getRawString ( param . args [ <NUM_LIT> ] ) ; if ( ( jid == null || jid . contains ( "<STR_LIT>" ) ) && param . args [ <NUM_LIT> ] != "<STR_LIT>" ) { param . args [ <NUM_LIT> ] = "<STR_LIT>" ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . content . ContextWrapper ; import android . content . res . XModuleResources ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . xposed . AntiUpdater ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . downgrade . Patch ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . IXposedHookZygoteInit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class WppXposed implements IXposedHookLoadPackage , IXposedHookInitPackageResources , IXposedHookZygoteInit { private static XSharedPreferences pref ; private String MODULE_PATH ; public static XC_InitPackageResources . InitPackageResourcesParam ResParam ; @ NonNull public static XSharedPreferences getPref ( ) { if ( pref == null ) { pref = new XSharedPreferences ( BuildConfig . APPLICATION_ID , BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; pref . makeWorldReadable ( ) ; pref . reload ( ) ; } return pref ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam ) throws Throwable { var packageName = lpparam . packageName ; var classLoader = lpparam . classLoader ; if ( packageName . equals ( BuildConfig . APPLICATION_ID ) ) { XposedHelpers . findAndHookMethod ( MainActivity . class . getName ( ) , lpparam . classLoader , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( true ) ) ; XposedHelpers . findAndHookMethod ( PreferenceManager . class . getName ( ) , lpparam . classLoader , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( ContextWrapper . MODE_WORLD_READABLE ) ) ; return ; } XposedBridge . log ( "<STR_LIT>" + lpparam . packageName ) ; AntiUpdater . hookSession ( pref ) ; Patch . handleLoadPackage ( lpparam , pref ) ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var sourceDir = lpparam . appInfo . sourceDir ; FeatureLoader . start ( classLoader , getPref ( ) , sourceDir ) ; disableSecureFlag ( ) ; } @ Override public void handleInitPackageResources ( XC_InitPackageResources . InitPackageResourcesParam resparam ) throws Throwable { var packageName = resparam . packageName ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; XModuleResources modRes = XModuleResources . createInstance ( MODULE_PATH , resparam . res ) ; for ( var field : ResId . string . class . getFields ( ) ) { var field1 = R . string . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . array . class . getFields ( ) ) { var field1 = R . array . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . drawable . class . getFields ( ) ) { var field1 = R . drawable . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } ResParam = resparam ; } @ Override public void initZygote ( StartupParam startupParam ) throws Throwable { MODULE_PATH = startupParam . modulePath ; } public void disableSecureFlag ( ) { XposedHelpers . findAndHookMethod ( Window . class , "<STR_LIT>" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; } } ) ; XposedHelpers . findAndHookMethod ( Window . class , "<STR_LIT>" , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . setResult ( null ) ; } } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed ; import android . content . pm . PackageInstaller ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . io . IOException ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiUpdater { public static void hookSession ( XSharedPreferences prefs ) { XposedBridge . hookAllMethods ( PackageInstaller . class , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var session = ( PackageInstaller . SessionParams ) param . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( session , "<STR_LIT>" ) ; if ( packageName . equals ( FeatureLoader . PACKAGE_WPP ) || packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . setThrowable ( new IOException ( "<STR_LIT>" ) ) ; } } } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . ListView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . widget . NestedScrollView ; import com . wmods . wppenhacer . adapter . MessageAdapter ; import com . wmods . wppenhacer . views . NoScrollListView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ShowEditMessage extends Feature { public ShowEditMessage ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var onStartMethod = Unobfuscator . loadAntiRevokeOnStartMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onStartMethod ) ) ; var onMessageEdit = Unobfuscator . loadMessageEditMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onMessageEdit ) ) ; var getEditMessage = Unobfuscator . loadGetEditMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getEditMessage ) ) ; var editMessageShowMethod = Unobfuscator . loadEditMessageShowMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( editMessageShowMethod ) ) ; var editMessageViewField = Unobfuscator . loadEditMessageViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( editMessageViewField ) ) ; XposedBridge . hookMethod ( onMessageEdit , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var editMessage = getEditMessage . invoke ( param . args [ <NUM_LIT> ] ) ; if ( editMessage == null ) return ; long timestamp = XposedHelpers . getLongField ( editMessage , "<STR_LIT>" ) ; if ( timestamp == <NUM_LIT> ) return ; var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; long id = fMessage . getRowId ( ) ; String newMessage = fMessage . getMessageStr ( ) ; if ( newMessage == null ) { var methods = ReflectionUtils . findAllMethodsUsingFilter ( param . args [ <NUM_LIT> ] . getClass ( ) , method -> method . getReturnType ( ) == String . class && ReflectionUtils . isOverridden ( method ) ) ; for ( var method : methods ) { newMessage = ( String ) method . invoke ( param . args [ <NUM_LIT> ] ) ; if ( newMessage != null ) break ; } if ( newMessage == null ) return ; } try { MessageHistory . getInstance ( ) . insertMessage ( id , newMessage , timestamp ) ; } catch ( Exception e ) { logDebug ( e ) ; } } } ) ; XposedBridge . hookMethod ( editMessageShowMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var textView = ( TextView ) editMessageViewField . get ( param . thisObject ) ; if ( textView != null && ! textView . getText ( ) . toString ( ) . contains ( "<STR_LIT>" ) ) { textView . getPaint ( ) . setUnderlineText ( true ) ; textView . append ( "<STR_LIT>" ) ; textView . setOnClickListener ( ( v ) -> { try { var messageObj = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var fMesage = new FMessageWpp ( messageObj ) ; long id = fMesage . getRowId ( ) ; var msg = new MessageHistory . MessageItem ( id , MessageStore . getInstance ( ) . getMessageById ( id ) , <NUM_LIT> ) ; var messages = MessageHistory . getInstance ( ) . getMessages ( id ) ; if ( messages == null ) { messages = new ArrayList < > ( ) ; } else { messages . add ( <NUM_LIT> , msg ) ; } showBottomDialog ( messages ) ; } catch ( Exception exception0 ) { logDebug ( exception0 ) ; } } ) ; } } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void showBottomDialog ( ArrayList < MessageHistory . MessageItem > messages ) { Objects . requireNonNull ( WppCore . getCurrentConversation ( ) ) . runOnUiThread ( ( ) -> { var ctx = ( Context ) WppCore . getCurrentConversation ( ) ; var dialog = WppCore . createBottomDialog ( ctx ) ; NestedScrollView nestedScrollView0 = new NestedScrollView ( ctx , null ) ; nestedScrollView0 . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; nestedScrollView0 . setFillViewport ( true ) ; nestedScrollView0 . setFitsSystemWindows ( true ) ; LinearLayout linearLayout = new LinearLayout ( ctx ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; LinearLayout . LayoutParams layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; linearLayout . setFitsSystemWindows ( true ) ; linearLayout . setMinimumHeight ( layoutParams . height = Utils . getApplication ( ) . getResources ( ) . getDisplayMetrics ( ) . heightPixels / <NUM_LIT> ) ; linearLayout . setLayoutParams ( layoutParams ) ; int dip = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( dip , dip , dip , <NUM_LIT> ) ; var bg = DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimarySurfaceColor ( ) ) ; linearLayout . setBackground ( bg ) ; TextView titleView = new TextView ( ctx ) ; LinearLayout . LayoutParams layoutParams1 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams1 . weight = <NUM_LIT> ; layoutParams1 . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; titleView . setLayoutParams ( layoutParams1 ) ; titleView . setTextSize ( <NUM_LIT> ) ; titleView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; titleView . setTypeface ( null , Typeface . BOLD ) ; titleView . setText ( ResId . string . edited_history ) ; var adapter = new MessageAdapter ( ctx , messages ) ; ListView listView = new NoScrollListView ( ctx ) ; LinearLayout . LayoutParams layoutParams2 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; layoutParams2 . weight = <NUM_LIT> ; listView . setLayoutParams ( layoutParams2 ) ; listView . setAdapter ( adapter ) ; ImageView imageView0 = new ImageView ( ctx ) ; LinearLayout . LayoutParams layoutParams4 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams4 . gravity = <NUM_LIT> ; layoutParams4 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; var bg2 = DesignUtils . createDrawable ( "<STR_LIT>" , Color . BLACK ) ; imageView0 . setBackground ( DesignUtils . alphaDrawable ( bg2 , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; imageView0 . setLayoutParams ( layoutParams4 ) ; Button okButton = new Button ( ctx ) ; LinearLayout . LayoutParams layoutParams3 = new LinearLayout . LayoutParams ( - <NUM_LIT> , - <NUM_LIT> ) ; layoutParams3 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams3 . gravity = <NUM_LIT> ; okButton . setLayoutParams ( layoutParams3 ) ; okButton . setGravity ( <NUM_LIT> ) ; var drawable = DesignUtils . createDrawable ( "<STR_LIT>" , Color . BLACK ) ; okButton . setBackground ( DesignUtils . alphaDrawable ( drawable , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; okButton . setText ( "<STR_LIT>" ) ; okButton . setOnClickListener ( ( View view ) -> dialog . dismissDialog ( ) ) ; linearLayout . addView ( imageView0 ) ; linearLayout . addView ( titleView ) ; linearLayout . addView ( listView ) ; linearLayout . addView ( okButton ) ; nestedScrollView0 . addView ( linearLayout ) ; dialog . setContentView ( nestedScrollView0 ) ; dialog . setCanceledOnTouchOutside ( true ) ; dialog . showDialog ( ) ; } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class GhostMode extends Feature { public GhostMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var ghostmode_t = prefs . getBoolean ( "<STR_LIT>" , false ) ; var ghostmode_r = prefs . getBoolean ( "<STR_LIT>" , false ) ; Method method = Unobfuscator . loadGhostModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) { var p1 = ( int ) param . args [ <NUM_LIT> ] ; if ( ( p1 == <NUM_LIT> && ghostmode_r ) || ( p1 == <NUM_LIT> && ghostmode_t ) ) { param . setResult ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views ; import android . content . Context ; import android . view . ViewGroup ; import android . widget . ListView ; public class NoScrollListView extends ListView { public NoScrollListView ( Context context ) { super ( context ) ; } public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( <NUM_LIT> , MeasureSpec . AT_MOST ) ) ; ViewGroup . LayoutParams layoutParams = this . getLayoutParams ( ) ; layoutParams . height = this . getMeasuredHeight ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . annotation . SuppressLint ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class GroupAdmin extends Feature { public GroupAdmin ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var jidFactory = Unobfuscator . loadJidFactory ( classLoader ) ; var grpAdmin1 = Unobfuscator . loadGroupAdminMethod ( classLoader ) ; var grpcheckAdmin = Unobfuscator . loadGroupCheckAdminMethod ( classLoader ) ; var hooked = new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var userJidClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var methodResult = ReflectionUtils . findMethodUsingFilter ( fMessage . getClass ( ) , method -> method . getReturnType ( ) == userJidClass && method . getParameterCount ( ) == <NUM_LIT> ) ; var userJid = ReflectionUtils . callMethod ( methodResult , fMessage ) ; var chatCurrentJid = WppCore . getCurrentRawJID ( ) ; if ( ! WppCore . isGroup ( chatCurrentJid ) ) return ; var field = ReflectionUtils . getFieldByType ( param . thisObject . getClass ( ) , grpcheckAdmin . getDeclaringClass ( ) ) ; var grpParticipants = field . get ( param . thisObject ) ; var jidGrp = jidFactory . invoke ( null , chatCurrentJid ) ; var result = ReflectionUtils . callMethod ( grpcheckAdmin , grpParticipants , jidGrp , userJid ) ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ImageView iconAdmin ; if ( ( iconAdmin = view . findViewById ( <NUM_LIT> ) ) == null ) { var nameGroup = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var view1 = new LinearLayout ( context ) ; view1 . setOrientation ( LinearLayout . HORIZONTAL ) ; view1 . setGravity ( Gravity . CENTER_VERTICAL ) ; var nametv = nameGroup . getChildAt ( <NUM_LIT> ) ; iconAdmin = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; iconAdmin . setLayoutParams ( new LinearLayout . LayoutParams ( size , size ) ) ; iconAdmin . setImageResource ( ResId . drawable . admin ) ; iconAdmin . setId ( <NUM_LIT> ) ; nameGroup . removeView ( nametv ) ; view1 . addView ( nametv ) ; view1 . addView ( iconAdmin ) ; nameGroup . addView ( view1 , <NUM_LIT> ) ; } iconAdmin . setVisibility ( result != null && ( boolean ) result ? View . VISIBLE : View . GONE ) ; } } ; XposedBridge . hookMethod ( grpAdmin1 , hooked ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class CustomizationFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_customization , rootKey ) ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class GeneralFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_general , rootKey ) ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . util . AttributeSet ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . ContactPickerActivity ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; public class ContactPickerPreference extends Preference implements Preference . OnPreferenceClickListener { public static final int REQUEST_CONTACT_PICKER = <NUM_LIT> ; public static final int PERMISSIONS_REQUEST_READ_CONTACTS = <NUM_LIT> ; private CharSequence summaryOff ; private CharSequence summaryOn ; private ArrayList < String > mContacts ; public ContactPickerPreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs ) ; } @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { if ( ContextCompat . checkSelfPermission ( getContext ( ) , Manifest . permission . READ_CONTACTS ) != PackageManager . PERMISSION_GRANTED ) { ( ( Activity ) getContext ( ) ) . requestPermissions ( new String [ ] { Manifest . permission . READ_CONTACTS } , PERMISSIONS_REQUEST_READ_CONTACTS ) ; } else { startContactPickerActivity ( ) ; } return true ; } private void init ( Context context , AttributeSet attrs ) { setOnPreferenceClickListener ( this ) ; var typedArray = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . ContactPickerPreference , <NUM_LIT> , <NUM_LIT> ) ; summaryOff = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOff ) ; summaryOn = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOn ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; String namesString = prefs . getString ( getKey ( ) , "<STR_LIT>" ) ; if ( namesString . length ( ) > <NUM_LIT> ) { mContacts = Arrays . stream ( namesString . substring ( <NUM_LIT> , namesString . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( item -> item . trim ( ) ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; } if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } public void startContactPickerActivity ( ) { Context context = getContext ( ) ; Intent intent = new Intent ( context , ContactPickerActivity . class ) ; if ( mContacts != null ) { intent . putStringArrayListExtra ( "<STR_LIT>" , mContacts ) ; } intent . putExtra ( "<STR_LIT>" , getKey ( ) ) ; ( ( Activity ) getContext ( ) ) . startActivityForResult ( intent , REQUEST_CONTACT_PICKER ) ; } public void handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode == REQUEST_CONTACT_PICKER && resultCode == Activity . RESULT_OK ) { mContacts = data . getStringArrayListExtra ( "<STR_LIT>" ) ; getSharedPreferences ( ) . edit ( ) . putString ( getKey ( ) , mContacts . toString ( ) ) . apply ( ) ; if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . app . Activity ; import android . widget . EditText ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . views . dialog . SimpleColorPickerDialog ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class TextStatusComposer extends Feature { private static final AtomicReference < ColorData > colorData = new AtomicReference < > ( ) ; public TextStatusComposer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var setColorTextComposer = Unobfuscator . loadTextStatusComposer ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( setColorTextComposer ) ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var viewRoot = activity . getWindow ( ) . getDecorView ( ) ; var pickerColor = viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var entry = ( EditText ) viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; pickerColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { try { Field fieldInt = ReflectionUtils . findFieldUsingFilter ( param . thisObject . getClass ( ) , field -> field . getType ( ) == int . class ) ; fieldInt . setInt ( param . thisObject , color ) ; ReflectionUtils . callMethod ( setColorTextComposer , null , param . thisObject ) ; } catch ( Exception e ) { log ( e ) ; } } ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; var textColor = viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; textColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { var colorData = new ColorData ( ) ; colorData . instance = param . thisObject ; colorData . color = color ; TextStatusComposer . colorData . set ( colorData ) ; entry . setTextColor ( color ) ; } ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; } } ) ; var setColorTextComposer2 = Unobfuscator . loadTextStatusComposer2 ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( setColorTextComposer2 ) ) ; XposedBridge . hookMethod ( setColorTextComposer2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( colorData . get ( ) != null ) { var message = param . getResult ( ) ; var textData = XposedHelpers . getObjectField ( message , "<STR_LIT>" ) ; XposedHelpers . setObjectField ( textData , "<STR_LIT>" , colorData . get ( ) . color ) ; colorData . set ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static class ColorData { public Object instance ; public int color ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . database . sqlite . SQLiteDatabase ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class ToastViewer extends Feature { private static final long MIN_INTERVAL = <NUM_LIT> ; private static final Map < String , Long > lastEventTimeMap = new HashMap < > ( ) ; private static final ScheduledExecutorService scheduler = Executors . newScheduledThreadPool ( <NUM_LIT> ) ; public ToastViewer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; startCleanupTask ( ) ; } @ Override public void doHook ( ) throws Throwable { var toastViewedStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var toastViewedMessage = prefs . getBoolean ( "<STR_LIT>" , false ) ; var onInsertReceipt = Unobfuscator . loadOnInsertReceipt ( classLoader ) ; XposedBridge . hookMethod ( onInsertReceipt , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var type = ( int ) param . args [ <NUM_LIT> ] ; var id = ( long ) param . args [ <NUM_LIT> ] ; if ( type != <NUM_LIT> ) return ; var PhoneUserJid = param . args [ <NUM_LIT> ] ; CompletableFuture . runAsync ( ( ) -> { var raw = WppCore . getRawString ( PhoneUserJid ) ; var UserJid = WppCore . createUserJid ( raw ) ; var contactName = WppCore . getContactName ( UserJid ) ; if ( TextUtils . isEmpty ( contactName ) ) contactName = WppCore . stripJID ( raw ) ; var sql = MessageStore . getInstance ( ) . getDatabase ( ) ; checkDataBase ( sql , id , contactName , raw , toastViewedMessage , toastViewedStatus ) ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private synchronized void checkDataBase ( SQLiteDatabase sql , long id , String contactName , String raw , boolean toastViewedMessage , boolean toast_viewed_status ) { try ( var result2 = sql . query ( "<STR_LIT>" , null , "<STR_LIT>" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ) { if ( ! result2 . moveToNext ( ) ) return ; var participantHash = result2 . getString ( result2 . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; if ( participantHash != null ) { if ( toast_viewed_status ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_status , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , "<STR_LIT>" ) ; return ; } if ( Objects . equals ( WppCore . getCurrentRawJID ( ) , raw ) ) return ; var chat_id = result2 . getLong ( result2 . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; try ( var result3 = sql . query ( "<STR_LIT>" , null , "<STR_LIT>" , new String [ ] { String . valueOf ( chat_id ) } , null , null , null ) ) { if ( ! result3 . moveToNext ( ) ) return ; var key = raw + "<STR_LIT>" + "<STR_LIT>" ; long currentTime = System . currentTimeMillis ( ) ; Long lastEventTime = lastEventTimeMap . get ( key ) ; if ( lastEventTime == null || ( currentTime - lastEventTime ) >= MIN_INTERVAL ) { lastEventTimeMap . put ( key , currentTime ) ; if ( toastViewedMessage ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_message , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , "<STR_LIT>" ) ; } } } } private void startCleanupTask ( ) { scheduler . scheduleWithFixedDelay ( ( ) -> { long currentTime = System . currentTimeMillis ( ) ; synchronized ( lastEventTimeMap ) { lastEventTimeMap . entrySet ( ) . removeIf ( entry -> ( currentTime - entry . getValue ( ) ) >= MIN_INTERVAL ) ; } } , MIN_INTERVAL , MIN_INTERVAL , TimeUnit . MILLISECONDS ) ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . content . Context ; import android . content . res . TypedArray ; import android . util . AttributeSet ; import android . widget . SeekBar ; import android . widget . TextView ; import androidx . preference . Preference ; import androidx . preference . PreferenceViewHolder ; import com . wmods . wppenhacer . R ; public class FloatSeekBarPreference extends Preference implements SeekBar . OnSeekBarChangeListener { private float minValue ; private float maxValue ; private float valueSpacing ; private String format ; private SeekBar seekbar ; private TextView textView ; private float defaultValue = <NUM_LIT> ; private float newValue = <NUM_LIT> ; public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs , defStyleAttr , defStyleRes ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { this ( context , attrs , defStyleAttr , <NUM_LIT> ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs ) { this ( context , attrs , androidx . preference . R . attr . seekBarPreferenceStyle ) ; } public FloatSeekBarPreference ( Context context ) { this ( context , null ) ; } @ Override protected Object onGetDefaultValue ( TypedArray ta , int index ) { defaultValue = ta . getFloat ( index , <NUM_LIT> ) ; return defaultValue ; } @ Override protected void onSetInitialValue ( Object defaultValue ) { newValue = getPersistedFloat ( ( defaultValue instanceof Float ) ? ( Float ) defaultValue : this . defaultValue ) ; } @ Override public void onBindViewHolder ( PreferenceViewHolder holder ) { super . onBindViewHolder ( holder ) ; holder . itemView . setClickable ( false ) ; seekbar = ( SeekBar ) holder . findViewById ( R . id . seekbar ) ; textView = ( TextView ) holder . findViewById ( R . id . seekbar_value ) ; seekbar . setOnSeekBarChangeListener ( this ) ; seekbar . setMax ( ( int ) ( ( maxValue - minValue ) / valueSpacing ) ) ; seekbar . setProgress ( ( int ) ( ( newValue - minValue ) / valueSpacing ) ) ; seekbar . setEnabled ( isEnabled ( ) ) ; textView . setText ( String . format ( format , newValue ) ) ; } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! fromUser ) { return ; } float v = minValue + progress * valueSpacing ; textView . setText ( String . format ( format , v ) ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { float v = minValue + seekBar . getProgress ( ) * valueSpacing ; persistFloat ( v ) ; } private void init ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { setWidgetLayoutResource ( R . layout . pref_float_seekbar ) ; TypedArray ta = context . obtainStyledAttributes ( attrs , R . styleable . FloatSeekBarPreference , defStyleAttr , defStyleRes ) ; minValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_minValue , <NUM_LIT> ) ; maxValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_maxValue , <NUM_LIT> ) ; valueSpacing = ta . getFloat ( R . styleable . FloatSeekBarPreference_valueSpacing , <NUM_LIT> ) ; format = ta . getString ( R . styleable . FloatSeekBarPreference_format ) ; if ( format == null ) { format = "<STR_LIT>" ; } ta . recycle ( ) ; } public float getValue ( ) { return ( seekbar != null ) ? ( seekbar . getProgress ( ) * valueSpacing ) + minValue : <NUM_LIT> ; } public void setValue ( float value ) { newValue = value ; persistFloat ( value ) ; notifyChanged ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Handler ; import android . os . Looper ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . collection . ArraySet ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeenTick extends Feature { private static final ArraySet < MessageInfo > messages = new ArraySet < > ( ) ; private static Object mWaJobManager ; private static Class < ? > mSendReadClass ; private static Method WaJobManagerMethod ; private static String currentJid ; private static String currentScreen = "<STR_LIT>" ; private static final HashMap < String , ImageView > messageMap = new HashMap < > ( ) ; public SeenTick ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var messageSendClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; WaJobManagerMethod = Unobfuscator . loadBlueOnReplayWaJobManagerMethod ( classLoader ) ; var messageJobMethod = Unobfuscator . loadBlueOnReplayMessageJobMethod ( classLoader ) ; mSendReadClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; WppCore . addListenerChat ( ( activity , type ) -> { if ( activity . getClass ( ) . getSimpleName ( ) . equals ( "<STR_LIT>" ) && ( type == WppCore . ActivityChangeState . ChangeType . START || type == WppCore . ActivityChangeState . ChangeType . RESUME ) ) { var jid = WppCore . getCurrentRawJID ( ) ; if ( ! Objects . equals ( jid , currentJid ) ) { currentJid = jid ; messages . clear ( ) ; } currentScreen = "<STR_LIT>" ; } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; messages . add ( new MessageInfo ( fMessage , key . messageID , fMessage . getUserJid ( ) ) ) ; } } ) ; XposedBridge . hookMethod ( messageJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var obj = messageSendClass . cast ( param . thisObject ) ; var rawJid = ( String ) XposedHelpers . getObjectField ( obj , "<STR_LIT>" ) ; var handler = new Handler ( Looper . getMainLooper ( ) ) ; if ( Objects . equals ( currentScreen , "<STR_LIT>" ) ) { if ( messages . isEmpty ( ) ) return ; MessageStore . getInstance ( ) . storeMessageRead ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; var view = messageMap . get ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; if ( view != null ) view . post ( ( ) -> setSeenButton ( view , true ) ) ; handler . post ( ( ) -> sendBlueTickStatus ( currentJid ) ) ; } else handler . post ( ( ) -> sendBlueTick ( rawJid ) ) ; } } ) ; XposedBridge . hookAllConstructors ( WaJobManagerMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mWaJobManager = param . thisObject ; } } ) ; var ticktype = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( ticktype == <NUM_LIT> ) return ; var onCreateMenuConversationMethod = Unobfuscator . loadBlueOnReplayCreateMenuConversationMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateMenuConversationMethod ) ) ; XposedBridge . hookMethod ( onCreateMenuConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var menuItem = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) ; if ( ticktype == <NUM_LIT> ) menuItem . setShowAsAction ( <NUM_LIT> ) ; menuItem . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; menuItem . setOnMenuItemClickListener ( item -> { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTick ( currentJid ) ; return true ; } ) ; } } ) ; var setPageActiveMethod = Unobfuscator . loadStatusActivePage ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( setPageActiveMethod ) ) ; var fieldList = Unobfuscator . getFieldByType ( setPageActiveMethod . getDeclaringClass ( ) , List . class ) ; XposedBridge . hookMethod ( setPageActiveMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var position = ( int ) param . args [ <NUM_LIT> ] ; var list = ( List < ? > ) XposedHelpers . getObjectField ( param . args [ <NUM_LIT> ] , fieldList . getName ( ) ) ; var fMessage = new FMessageWpp ( list . get ( position ) ) ; var messageKey = ( String ) fMessage . getKey ( ) . messageID ; var jid = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; messages . clear ( ) ; messages . add ( new MessageInfo ( fMessage , messageKey , null ) ) ; currentJid = jid ; currentScreen = "<STR_LIT>" ; } } ) ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; if ( ticktype == <NUM_LIT> ) { XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var fMessageField = ReflectionUtils . getFieldByExtendType ( param . thisObject . getClass ( ) , FMessageWpp . TYPE ) ; var fMessage = new FMessageWpp ( ReflectionUtils . getField ( fMessageField , param . thisObject ) ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; var view = ( View ) param . getResult ( ) ; var contentView = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var buttonImage = new ImageView ( view . getContext ( ) ) ; LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . gravity = Gravity . CENTER_VERTICAL ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; buttonImage . setLayoutParams ( params ) ; buttonImage . setImageResource ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; GradientDrawable border = new GradientDrawable ( ) ; border . setShape ( GradientDrawable . RECTANGLE ) ; border . setStroke ( <NUM_LIT> , Color . WHITE ) ; border . setCornerRadius ( <NUM_LIT> ) ; border . setColor ( Color . parseColor ( "<STR_LIT>" ) ) ; buttonImage . setBackground ( border ) ; contentView . setOrientation ( LinearLayout . HORIZONTAL ) ; contentView . addView ( buttonImage , <NUM_LIT> ) ; messageMap . put ( key . messageID , buttonImage ) ; buttonImage . setOnClickListener ( v -> CompletableFuture . runAsync ( ( ) -> { Utils . showToast ( view . getContext ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTickStatus ( currentJid ) ; setSeenButton ( buttonImage , true ) ; } ) ) ; CompletableFuture . runAsync ( ( ) -> { var seen = MessageStore . getInstance ( ) . isReadMessageStatus ( key . messageID ) ; setSeenButton ( buttonImage , seen ) ; } ) ; } } ) ; } else { MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . send_blue_tick ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . send_blue_tick , <NUM_LIT> , ResId . string . send_blue_tick ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; } MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . read_all_mark_as_read ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . read_all_mark_as_read , <NUM_LIT> , ResId . string . read_all_mark_as_read ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { try { messages . clear ( ) ; var listStatusField = ReflectionUtils . getFieldByExtendType ( fragmentInstance . getClass ( ) , List . class ) ; var listStatus = ( List ) listStatusField . get ( fragmentInstance ) ; for ( int i = <NUM_LIT> ; i < listStatus . size ( ) ; i ++ ) { var fMessage = new FMessageWpp ( listStatus . get ( i ) ) ; var messageId = fMessage . getKey ( ) . messageID ; if ( ! fMessage . getKey ( ) . isFromMe ) { messages . add ( new MessageInfo ( fMessage , messageId , null ) ) ; } var view = messageMap . get ( messageId ) ; if ( view != null ) { view . post ( ( ) -> setSeenButton ( view , true ) ) ; } } } catch ( Exception e ) { log ( e ) ; } sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var classThreadMessage = Unobfuscator . loadFMessageClass ( classLoader ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( ticktype == <NUM_LIT> ) item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { var messageField = Unobfuscator . getFieldByExtendType ( menuMethod . getDeclaringClass ( ) , classThreadMessage ) ; var messageObject = XposedHelpers . getObjectField ( param . thisObject , messageField . getName ( ) ) ; sendBlueTickMedia ( messageObject , true ) ; Toast . makeText ( Utils . getApplication ( ) , ResId . string . sending_read_blue_tick , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } ) ; } } } ) ; } public static void setSeenButton ( ImageView buttonImage , boolean b ) { Drawable originalDrawable = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; Drawable clonedDrawable ; if ( originalDrawable instanceof BitmapDrawable ) { Bitmap bitmap = ( ( BitmapDrawable ) originalDrawable ) . getBitmap ( ) ; Bitmap clonedBitmap = bitmap . copy ( bitmap . getConfig ( ) , true ) ; clonedDrawable = new BitmapDrawable ( buttonImage . getResources ( ) , clonedBitmap ) ; } else { clonedDrawable = Objects . requireNonNull ( originalDrawable . getConstantState ( ) ) . newDrawable ( ) . mutate ( ) ; } if ( b ) { clonedDrawable . setColorFilter ( Color . CYAN , PorterDuff . Mode . SRC_ATOP ) ; } buttonImage . setImageDrawable ( clonedDrawable ) ; buttonImage . postInvalidate ( ) ; } private void sendBlueTick ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; var messagekeys = messages . stream ( ) . map ( item -> item . messageId ) . collect ( Collectors . toList ( ) ) ; var listAudios = MessageStore . getInstance ( ) . getAudioListByMessageList ( messagekeys ) ; logDebug ( "<STR_LIT>" + listAudios ) ; for ( var messageKey : listAudios ) { var mInfo = messages . stream ( ) . filter ( messageInfo -> messageInfo . messageId . equals ( messageKey ) ) . findAny ( ) ; if ( mInfo . isPresent ( ) ) { messages . remove ( mInfo . get ( ) ) ; sendBlueTickMedia ( mInfo . get ( ) . fMessage . getObject ( ) , false ) ; } } sendBlueTickMsg ( currentJid ) ; } private void sendBlueTickMsg ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; try { logDebug ( "<STR_LIT>" + currentJid ) ; HashMap < Object , List < String > > map = new HashMap < > ( ) ; for ( var messageInfo : messages ) { map . computeIfAbsent ( messageInfo . userJid , k -> new ArrayList < > ( ) ) ; Objects . requireNonNull ( map . get ( messageInfo . userJid ) ) . add ( messageInfo . messageId ) ; } var userJidTarget = WppCore . createUserJid ( currentJid ) ; for ( var userjid : map . keySet ( ) ) { var messages = Objects . requireNonNull ( map . get ( userjid ) ) . toArray ( new String [ <NUM_LIT> ] ) ; WppCore . setPrivBoolean ( messages [ <NUM_LIT> ] + "<STR_LIT>" , true ) ; var participant = WppCore . isGroup ( currentJid ) ? userjid : null ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidTarget , participant , null , null , messages , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; } messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private void sendBlueTickStatus ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . equals ( "<STR_LIT>" ) ) return ; try { logDebug ( "<STR_LIT>" + currentJid ) ; var arr_s = messages . stream ( ) . map ( item -> item . messageId ) . toArray ( String [ ] :: new ) ; Arrays . stream ( arr_s ) . forEach ( s -> MessageStore . getInstance ( ) . storeMessageRead ( s ) ) ; var userJidSender = WppCore . createUserJid ( "<STR_LIT>" ) ; var userJid = WppCore . createUserJid ( currentJid ) ; WppCore . setPrivBoolean ( arr_s [ <NUM_LIT> ] + "<STR_LIT>" , true ) ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidSender , userJid , null , null , arr_s , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private void sendBlueTickMedia ( Object messageObject , boolean clear ) { try { logDebug ( "<STR_LIT>" + WppCore . getCurrentRawJID ( ) ) ; var sendPlayerClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var sendJob = XposedHelpers . newInstance ( sendPlayerClass , messageObject ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; if ( clear ) messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } static class MessageInfo { public Object userJid ; public String messageId ; public FMessageWpp fMessage ; public MessageInfo ( FMessageWpp fMessage , String messageId , Object userJid ) { this . messageId = messageId ; this . fMessage = fMessage ; this . userJid = userJid ; } @ Override public boolean equals ( @ Nullable Object obj ) { if ( obj instanceof MessageInfo messageInfo ) { return Objects . equals ( messageId , messageInfo . messageId ) && Objects . equals ( fMessage , messageInfo . fMessage ) && Objects . equals ( userJid , messageInfo . userJid ) ; } return false ; } @ NonNull @ Override public String toString ( ) { return messageId ; } } } </s>
