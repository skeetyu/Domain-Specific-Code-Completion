<s> package icu . freedomIntrovert . async ; public abstract class BackstageTask < T extends EventHandler > implements Runnable { private final T handle ; public BackstageTask ( T handle ) { this . handle = handle ; } @ Override public void run ( ) { try { onStart ( handle ) ; } catch ( Throwable e ) { handle . sendError ( e ) ; } } public void execute ( ) { TaskManger . execute ( this ) ; } protected abstract void onStart ( T eventHandler ) throws Throwable ; protected void sleep ( long time ) { try { Thread . sleep ( time ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostDanmakuHook extends BaseHook { public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { AtomicLong currentOid = new AtomicLong ( ) ; AtomicLong currentAvid = new AtomicLong ( ) ; AtomicReference < String > currentContent = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , Context . class , String . class , classLoader . loadClass ( "<STR_LIT>" ) , int . class , String . class , String . class , String . class , String . class , Long . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . toString ( ) ) . append ( "<STR_LIT>" ) ; } else { sb . append ( i ) . append ( "<STR_LIT>" ) ; } currentContent . set ( ( String ) param . args [ <NUM_LIT> ] ) ; currentOid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; currentAvid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( "<STR_LIT>" ) . append ( param . args [ i ] . toString ( ) ) . append ( "<STR_LIT>" ) ; } else { sb . append ( i ) . append ( "<STR_LIT>" ) ; } Class < ? > biliAccountsClass = classLoader . loadClass ( "<STR_LIT>" ) ; Field contextField = param . thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; contextField . setAccessible ( true ) ; Context context = ( Context ) contextField . get ( param . thisObject ) ; XposedBridge . log ( "<STR_LIT>" + context . toString ( ) ) ; Object biliAccounts = biliAccountsClass . getMethod ( "<STR_LIT>" , Context . class ) . invoke ( null , context ) ; String accessKey = ( String ) biliAccounts . getClass ( ) . getMethod ( "<STR_LIT>" ) . invoke ( biliAccounts ) ; XposedBridge . log ( "<STR_LIT>" + accessKey ) ; Object danmakuSendResponse = param . args [ <NUM_LIT> ] ; Method dmidMethod = danmakuSendResponse . getClass ( ) . getMethod ( "<STR_LIT>" ) ; long dmid = ( long ) dmidMethod . invoke ( danmakuSendResponse ) ; Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_DANMAKU ) ; intent . putExtra ( "<STR_LIT>" , currentOid . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , dmid ) ; intent . putExtra ( "<STR_LIT>" , currentContent . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , accessKey ) ; intent . putExtra ( "<STR_LIT>" , currentAvid . get ( ) ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) ) ; context . startActivity ( intent ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . net . Uri ; import android . os . Handler ; import android . text . Spannable ; import android . text . SpannableStringBuilder ; import android . text . style . ForegroundColorSpan ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import android . widget . TextView ; import android . widget . Toast ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . AreaMartialLawCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . BannedOnlyInThisAreaCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . CommentCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . SensitiveScannerTask ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class DialogCommCheckWorker implements BiliBiliApiRequestHandler . DialogErrorHandle . OnDialogMessageListener { public static final int BANNED_TYPE_SHADOW_BAN = <NUM_LIT> ; public static final int BANNED_TYPE_QUICK_DELETE = <NUM_LIT> ; public static final int BANNED_TYPE_UNDER_REVIEW = <NUM_LIT> ; public static final int BANNED_TYPE_INVISIBLE = <NUM_LIT> ; private Context context ; private Config config ; private StatisticsDBOpenHelper statDB ; private Handler handler ; private CommentManipulator commentManipulator ; private CommentUtil commentUtil ; private OnExitListener exitListener ; public DialogCommCheckWorker ( Context context , Config config , StatisticsDBOpenHelper statDB , CommentManipulator commentManipulator , CommentUtil commentUtil ) { this . context = context ; this . config = config ; this . statDB = statDB ; this . commentManipulator = commentManipulator ; this . commentUtil = commentUtil ; this . handler = new Handler ( ) ; } public void setExitListener ( OnExitListener exitListener ) { this . exitListener = exitListener ; } public void checkComment ( Comment comment , ProgressBarDialog dialog ) { if ( commentManipulator . cookieAreSet ( ) ) { DialogCommentCheckEventHandler handle = new DialogCommentCheckEventHandler ( dialog , comment , this ) ; new CommentCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil . getRandomComment ( comment . commentArea ) ) . execute ( ) ; } else { dialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; } } private static class DialogCommentCheckEventHandler extends CommentCheckTask . EventHandler { private final ProgressBarDialog dialog ; private final Comment comment ; private final DialogCommCheckWorker worker ; public DialogCommentCheckEventHandler ( ProgressBarDialog dialog , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( dialog , worker ) ) ; this . dialog = dialog ; this . comment = comment ; this . worker = worker ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_START_COMMENT_CHECK : dialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_ON_COMMENT_NOT_FOUND : dialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY : dialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_THEN_COMMENT_OK : dialog . dismiss ( ) ; worker . showCommentIsOkResult ( comment . comment , comment . rpid ) ; break ; case WHAT_THEN_SHADOW_BAN : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_SHADOW_BAN , comment ) ; break ; case WHAT_THEN_DELETED : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_QUICK_DELETE , comment ) ; break ; case WHAT_THEN_UNDER_REVIEW : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_UNDER_REVIEW , comment ) ; break ; case WHAT_THEN_INVISIBLE : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_INVISIBLE , comment ) ; break ; } } } private void showCommentIsOkResult ( String comment , long rpid ) { onNewCommentRpid ( rpid ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + comment + "<STR_LIT>" ) . setCancelable ( false ) . setOnDismissListener ( dialog13 -> exit ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; } private void showCommentBannedResult ( int bannedType , Comment comment ) { onNewCommentRpid ( comment . rpid ) ; CommentArea commentArea = comment . commentArea ; long rpid = comment . rpid ; String commentText = comment . comment ; AlertDialog . Builder resultDialogBuilder = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) ; switch ( bannedType ) { case BANNED_TYPE_SHADOW_BAN : resultDialogBuilder . setIcon ( R . drawable . hide_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } else { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } break ; case BANNED_TYPE_UNDER_REVIEW : resultDialogBuilder . setIcon ( R . drawable . i_black ) ; resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; break ; case BANNED_TYPE_QUICK_DELETE : resultDialogBuilder . setIcon ( R . drawable . deleted_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } else { resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; } break ; case BANNED_TYPE_INVISIBLE : resultDialogBuilder . setIcon ( R . drawable . ghost_black ) ; resultDialogBuilder . setMessage ( "<STR_LIT>" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + "<STR_LIT>" ) ; break ; } resultDialogBuilder . setOnDismissListener ( dialog -> exit ( ) ) ; resultDialogBuilder . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; resultDialogBuilder . setNeutralButton ( "<STR_LIT>" , null ) ; resultDialogBuilder . setNegativeButton ( "<STR_LIT>" , null ) ; AlertDialog resultDialog = resultDialogBuilder . show ( ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEUTRAL ) . setOnClickListener ( v -> new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" } , ( dialog , which ) -> { boolean isDeputyAccount = which == <NUM_LIT> ; checkAreaMartialLaw ( comment , null , isDeputyAccount ) ; } ) . show ( ) ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEGATIVE ) . setOnClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case <NUM_LIT> : scanSensitiveWord ( comment ) ; break ; case <NUM_LIT> : AlertDialog dialog1 = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog23 , which1 ) -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog24 , which1 ) -> { AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , handler , commentManipulator ) ; appealDialogPresenter . appeal ( CommentUtil . sourceIdToUrl ( commentArea ) , commentText , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { if ( code == <NUM_LIT> ) { statDB . updateHistoryCommentLastState ( rpid , HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ; toastLong ( toastText + "<STR_LIT>" ) ; } else { toastLong ( toastText ) ; } } @ Override public void onNetErrInUI ( String msg ) { toastNetError ( msg ) ; } } ) ; } ) . show ( ) ; break ; case <NUM_LIT> : commentManipulator . createDeleteCommentCall ( commentArea , rpid ) . enqueue ( new BiliApiCallback < GeneralResponse < Object > > ( ) { @ Override public void onError ( Throwable th ) { toastNetError ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < Object > unused ) { resultDialog . dismiss ( ) ; if ( unused . isSuccess ( ) ) { toastLong ( "<STR_LIT>" ) ; } else { toastLong ( "<STR_LIT>" ) ; } } } ) ; break ; case <NUM_LIT> : ClipboardManager cm = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData mClipData = ClipData . newPlainText ( "<STR_LIT>" , "<STR_LIT>" + rpid + "<STR_LIT>" + commentArea . oid + "<STR_LIT>" + commentArea . type ) ; cm . setPrimaryClip ( mClipData ) ; toastShort ( "<STR_LIT>" ) ; } } } ) . show ( ) ; } ) ; } public void checkAreaMartialLaw ( Comment comment , DialogInterface . OnDismissListener onDismissListener , boolean isDeputyAccount ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; if ( ! isDeputyAccount ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } else { if ( commentManipulator . deputyCookieAreSet ( ) ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } else { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; } } AreaCheckHandler handle = new AreaCheckHandler ( progressDialog , onDismissListener , comment , this ) ; new AreaMartialLawCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil , isDeputyAccount ) . execute ( ) ; } private static class AreaCheckHandler extends AreaMartialLawCheckTask . EventHandler { ProgressDialog progressDialog ; Comment comment ; DialogCommCheckWorker worker ; DialogInterface . OnDismissListener onDismissListener ; public AreaCheckHandler ( ProgressDialog progressDialog , DialogInterface . OnDismissListener onDismissListener , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . progressDialog = progressDialog ; this . comment = comment ; this . worker = worker ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_TEST_COMMENT_SENT : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , String . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_THEN_AREA_OK : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , ( dialog1 , which ) -> { CommentArea yourCommentArea = worker . commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { worker . commentUtil . setYourCommentArea ( worker . context , worker . commentManipulator ) ; } else { worker . checkIfBannedOnlyInThisArea ( comment , onDismissListener , yourCommentArea ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; case WHAT_THEN_MARTIAL_LAW : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; } } } private void checkIfBannedOnlyInThisArea ( Comment comment , DialogInterface . OnDismissListener onDismissListener , CommentArea yourCommentArea ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; BannedOnlyInThisAreaCheckHandler handler = new BannedOnlyInThisAreaCheckHandler ( this , onDismissListener , progressDialog ) ; new BannedOnlyInThisAreaCheckTask ( handler , commentManipulator , config , statDB , comment , yourCommentArea ) . execute ( ) ; } private static class BannedOnlyInThisAreaCheckHandler extends BannedOnlyInThisAreaCheckTask . EventHandler { DialogCommCheckWorker worker ; ProgressDialog progressDialog ; DialogInterface . OnDismissListener onDismissListener ; public BannedOnlyInThisAreaCheckHandler ( DialogCommCheckWorker worker , DialogInterface . OnDismissListener onDismissListener , ProgressDialog progressDialog ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . worker = worker ; this . progressDialog = progressDialog ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_COMMENT_SENT_TO_YOUR_AREA : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , String . class ) ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( "<STR_LIT>" ) ; break ; case WHAT_THEN_ONLY_BANNED_IN_THIS_AREA : progressDialog . dismiss ( ) ; showResult ( "<STR_LIT>" ) ; break ; case WHAT_THEN_BANNED_IN_YOUR_AREA : showResult ( "<STR_LIT>" ) ; break ; } } private void showResult ( String message ) { progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( "<STR_LIT>" ) . setMessage ( message ) . setOnDismissListener ( onDismissListener ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } } public void scanSensitiveWord ( Comment mainComment ) { if ( mainComment . comment . length ( ) < <NUM_LIT> ) { toastShort ( "<STR_LIT>" ) ; return ; } final int [ ] commentAreaSelect = new int [ ] { <NUM_LIT> } ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setSingleChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , } , commentAreaSelect [ <NUM_LIT> ] , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { commentAreaSelect [ <NUM_LIT> ] = which ; } } ) . setNegativeButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { switch ( commentAreaSelect [ <NUM_LIT> ] ) { case <NUM_LIT> : CommentArea yourCommentArea = commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setYourCommentArea ( context , commentManipulator ) ; } else { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , yourCommentArea , commentManipulator , config , statDB ) . execute ( ) ; } break ; case <NUM_LIT> : if ( ! commentManipulator . deputyCookieAreSet ( ) ) { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" ) ; return ; } String dynamicId = commentUtil . getForwardDynamicId ( ) ; if ( dynamicId != null ) { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , dynamicId , commentManipulator , config , statDB ) . execute ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setDynamicIdToBeForward ( context , commentManipulator ) ; } break ; case <NUM_LIT> : SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , mainComment . commentArea , commentManipulator , config , statDB ) . execute ( ) ; break ; } } ) . show ( ) ; } private static class SensitiveScannerHandler extends SensitiveScannerTask . EventHandler { private final DialogCommCheckWorker worker ; private final AlertDialog dialog ; private final Comment mainComment ; private final String commentText ; private final TextView txv_comment_content ; private final ProgressBar pb_scanning_ssw ; private final ProgressBar pb_wait ; private final TextView txv_scanning_status ; private final TextView txv_scanning_progress ; Button buttonClose ; private final ForegroundColorSpan greenSpan ; private final ForegroundColorSpan redSpan ; private final ForegroundColorSpan yellowSpan ; private final ForegroundColorSpan blueSpan ; public SensitiveScannerHandler ( DialogCommCheckWorker worker , Comment mainComment ) { super ( null ) ; this . worker = worker ; this . mainComment = mainComment ; Context context = worker . context ; View dialogView = View . inflate ( context , R . layout . dialog_scanning_sensitive_word , null ) ; txv_comment_content = dialogView . findViewById ( R . id . txv_scanning_result_of_sensitive_world ) ; pb_scanning_ssw = dialogView . findViewById ( R . id . prog_scanning_ssw ) ; pb_wait = dialogView . findViewById ( R . id . prog_wait ) ; txv_scanning_status = dialogView . findViewById ( R . id . txv_scanning_status ) ; txv_scanning_progress = dialogView . findViewById ( R . id . txv_scanning_progress ) ; this . dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setCancelable ( false ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; buttonClose = dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) ; buttonClose . setEnabled ( false ) ; commentText = mainComment . comment ; txv_comment_content . setText ( commentText ) ; greenSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . green ) ) ; redSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . red ) ) ; yellowSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . yellow ) ) ; blueSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . blue ) ) ; setErrorHandle ( new DialogErrorHandle ( dialog , worker ) ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override protected void handleEvent ( EventMessage message ) { SpannableStringBuilder builder ; switch ( message . getWhat ( ) ) { case WHAT_COMMENT_FULL_TEXT_SENT : txv_scanning_status . setText ( String . format ( "<STR_LIT>" , message . getObject ( <NUM_LIT> , Long . class ) ) ) ; SpannableStringBuilder stringBuilder = new SpannableStringBuilder ( commentText ) ; stringBuilder . setSpan ( blueSpan , <NUM_LIT> , commentText . length ( ) , SpannableStringBuilder . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( stringBuilder ) ; break ; case WHAT_COMMENT_FULL_TEXT_IS_NORMAL : builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , commentText . length ( ) , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; CommentArea commentArea = message . getObject ( <NUM_LIT> , CommentArea . class ) ; if ( commentArea == mainComment . commentArea ) { txv_scanning_status . setText ( "<STR_LIT>" + commentArea . sourceId + "<STR_LIT>" ) ; } else { txv_scanning_status . setText ( "<STR_LIT>" ) ; } dialog . setTitle ( "<STR_LIT>" ) ; pb_scanning_ssw . setMax ( <NUM_LIT> ) ; pb_scanning_ssw . setProgress ( <NUM_LIT> ) ; pb_wait . setIndeterminate ( false ) ; buttonClose . setEnabled ( true ) ; break ; case WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT : int normalPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitLeftPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitRightPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; long waitTime = message . getObject ( <NUM_LIT> , Long . class ) ; builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( yellowSpan , normalPosition , splitLeftPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( blueSpan , splitLeftPosition , splitRightPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; txv_scanning_status . setText ( String . format ( "<STR_LIT>" , waitTime ) ) ; break ; case WHAT_ON_CHECKING_COMMENT : int currProgress = message . getObject ( <NUM_LIT> , Integer . class ) ; int max = message . getObject ( <NUM_LIT> , Integer . class ) ; pb_scanning_ssw . setMax ( max ) ; pb_scanning_ssw . setProgress ( currProgress ) ; txv_scanning_progress . setText ( String . format ( "<STR_LIT>" , currProgress , max ) ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_ON_CHECK_RESULT : SensitiveScanResult result = message . getObject ( <NUM_LIT> , SensitiveScanResult . class ) ; SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder ( commentText ) ; spannableStringBuilder . setSpan ( greenSpan , <NUM_LIT> , result . normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; System . out . println ( result . unusualPosition ) ; spannableStringBuilder . setSpan ( redSpan , result . normalPosition , result . unusualPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( spannableStringBuilder ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_ON_SCAN_COMPLETE : dialog . setTitle ( "<STR_LIT>" ) ; txv_scanning_status . setText ( "<STR_LIT>" ) ; buttonClose . setEnabled ( true ) ; buttonClose . setOnClickListener ( v -> { dialog . dismiss ( ) ; } ) ; pb_wait . setIndeterminate ( false ) ; worker . onCommentStatusUpdated ( mainComment . rpid ) ; break ; case WHAT_NEW_SLEEP_PROGRESS_MAX : int progressMax = message . getObject ( <NUM_LIT> , Integer . class ) ; if ( progressMax >= <NUM_LIT> ) { pb_wait . setIndeterminate ( false ) ; pb_wait . setMax ( progressMax ) ; } else { pb_wait . setIndeterminate ( true ) ; } break ; case WHAT_NEW_SLEEP_PROGRESS : pb_wait . setProgress ( message . getObject ( <NUM_LIT> , Integer . class ) ) ; break ; case WHAT_FORWARD_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" ) ; break ; case WHAT_FORWARDED_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; break ; case WHAT_DELETE_FORWARDED_DYNAMIC : txv_scanning_status . setText ( "<STR_LIT>" ) ; } } } public void toAppeal ( String comment , CommentArea commentArea , String parent , String root , String areaIdentifier ) { } private void toastShort ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastLong ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } private void toastNetError ( String msg ) { toastShort ( "<STR_LIT>" + msg ) ; } public void dialogMessage ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setPositiveButton ( android . R . string . ok , null ) . setOnDismissListener ( dialog -> exit ( ) ) . show ( ) ; } private void exit ( ) { if ( exitListener != null ) { exitListener . exit ( ) ; } } private void onNewCommentRpid ( long rpid ) { if ( exitListener != null ) { exitListener . onNewCommentRpid ( rpid ) ; } } private void onCommentStatusUpdated ( long rpid ) { if ( exitListener != null ) { exitListener . onCommentStatusUpdated ( rpid ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . async . EventHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public abstract class CommentOperateTask < T extends EventHandler > extends BackstageTask < T > { protected final CommentManipulator commentManipulator ; protected final Comment comment ; protected final Config config ; protected final StatisticsDBOpenHelper statisticsDB ; public CommentOperateTask ( T handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . comment = comment ; this . config = config ; this . statisticsDB = statisticsDB ; } public void insertHistoryComment ( HistoryComment historyComment ) { if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . insertHistoryComment ( historyComment ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . view ; public class ProgressTimer { private final long TimeMs ; private final int max ; private final ProgressLister progressLister ; private boolean isStopped = false ; public ProgressTimer ( long timeMs , int max , ProgressLister progressLister ) { TimeMs = timeMs ; this . max = max ; this . progressLister = progressLister ; } public void start ( ) { long sleepSeg = TimeMs / max ; for ( int i = <NUM_LIT> ; i <= max && ! isStopped ; i ++ ) { try { Thread . sleep ( sleepSeg ) ; progressLister . onNewProgress ( i , sleepSeg ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } public void stop ( ) { isStopped = true ; } public interface ProgressLister { void onNewProgress ( int progress , long sleepSeg ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . os . Build ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Date ; import java . util . Locale ; public class Logger { private static final int MAX_LOG_FILES = <NUM_LIT> ; private static final String LOG_FILE_EXTENSION = "<STR_LIT>" ; private final File logDirectory ; private PrintWriter logWriter ; public Logger ( File logDirectory ) { this . logDirectory = logDirectory ; if ( ! logDirectory . exists ( ) ) { logDirectory . mkdirs ( ) ; } createNewLogFile ( ) ; } private void createNewLogFile ( ) { String fileName = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + LOG_FILE_EXTENSION ; File logFile = new File ( logDirectory , fileName ) ; try { logFile . createNewFile ( ) ; logWriter = new PrintWriter ( new FileWriter ( logFile , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } deleteOldLogFiles ( ) ; } private void deleteOldLogFiles ( ) { File [ ] logFiles = logDirectory . listFiles ( ( dir , name ) -> name . endsWith ( LOG_FILE_EXTENSION ) ) ; if ( logFiles == null ) return ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Arrays . sort ( logFiles , Comparator . comparingLong ( File :: lastModified ) ) ; int numFilesToDelete = logFiles . length - MAX_LOG_FILES ; if ( numFilesToDelete > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < numFilesToDelete ; i ++ ) { logFiles [ i ] . delete ( ) ; } } } } public synchronized void log ( String message ) { if ( logWriter == null ) return ; logWriter . println ( message ) ; logWriter . flush ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostPictureHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . content . Intent . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; int requestCode = ( Integer ) param . args [ <NUM_LIT> ] ; if ( requestCode == <NUM_LIT> ) { Intent newIntent = new Intent ( ) ; newIntent . setAction ( Intent . ACTION_PICK ) ; newIntent . setType ( "<STR_LIT>" ) ; param . args [ <NUM_LIT> ] = newIntent ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , int . class , android . content . Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; if ( ( Integer ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { if ( intent != null && intent . getData ( ) != null ) { String fileName = "<STR_LIT>" + System . currentTimeMillis ( ) + "<STR_LIT>" ; try ( InputStream inputStream = activity . getContentResolver ( ) . openInputStream ( intent . getData ( ) ) ; FileOutputStream fos = new FileOutputStream ( fileName ) ) { if ( inputStream == null ) { XposedBridge . log ( "<STR_LIT>" ) ; return ; } byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } XposedBridge . log ( "<STR_LIT>" ) ; } catch ( IOException e ) { XposedBridge . log ( "<STR_LIT>" + e ) ; } for ( Method declaredMethod : activity . getClass ( ) . getDeclaredMethods ( ) ) { Class < ? > [ ] parameterTypes = declaredMethod . getParameterTypes ( ) ; if ( Arrays . equals ( new Class [ ] { String . class } , parameterTypes ) ) { XposedHelpers . callMethod ( activity , declaredMethod . getName ( ) , fileName ) ; } } } else { activity . finish ( ) ; } } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; public class CommentAddResult { public static final int CODE_SUCCESS = <NUM_LIT> ; public static final int CODE_DELETED = <NUM_LIT> ; public static final int CODE_CONTAIN_SENSITIVE = <NUM_LIT> ; public static final int CODE_NOT_THE_COMMENT = <NUM_LIT> ; @ JSONField ( name = "<STR_LIT>" ) public long rpid ; @ JSONField ( name = "<STR_LIT>" ) public String success_toast ; @ JSONField ( name = "<STR_LIT>" ) public int success_action ; public long root ; public long parent ; public BiliComment reply ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public interface NetworkCallBack { public void onNetworkError ( Throwable th ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class CommentCheckTask extends CommentOperateTask < CommentCheckTask . EventHandler > { private final String testCommentText ; public CommentCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , String testCommentText ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . testCommentText = testCommentText ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; HistoryComment historyComment = new HistoryComment ( comment ) ; historyComment . lastCheckDate = new Date ( ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_COMMENT_CHECK ) ; if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } BiliComment biliComment = commentManipulator . findComment ( comment . commentArea , comment . rpid , comment . root ) ; if ( biliComment != null ) { if ( biliComment . invisible ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_INVISIBLE ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_INVISIBLE ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_NORMAL ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_COMMENT_OK ) ; } } else { if ( comment . root == <NUM_LIT> ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_COMMENT_NOT_FOUND ) ; GeneralResponse < CommentReplyPage > response = commentManipulator . getCommentReplyHasAccount ( commentArea , comment . rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( response ) ; if ( response . code == CommentAddResult . CODE_SUCCESS ) { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } GeneralResponse < CommentReplyPage > noACResp = commentManipulator . getCommentReplyNoAccount ( commentArea , comment . rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( noACResp ) ; if ( noACResp . isSuccess ( ) ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNDER_REVIEW ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_UNDER_REVIEW ) ; } else if ( noACResp . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( noACResp , null ) ) ; } } else if ( response . code == CommentAddResult . CODE_DELETED ) { GeneralResponse < CommentAddResult > response1 = commentManipulator . getSendCommentCall ( testCommentText , comment . rpid , comment . root , commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( response1 ) ; if ( response1 . isSuccess ( ) ) { sleep ( config . getWaitTime ( ) ) ; commentManipulator . deleteComment ( comment . commentArea , comment . rpid , false ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else if ( response1 . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( response1 . code , response1 . message , null ) ) ; } } else { eventHandler . sendError ( new BiliBiliApiException ( response . code , response . message , null ) ) ; } } else { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , comment . rpid , comment . root , true ) ; if ( foundReply != null ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } } } } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_START_COMMENT_CHECK = <NUM_LIT> ; public static final int WHAT_ON_COMMENT_NOT_FOUND = <NUM_LIT> ; public static final int WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY = <NUM_LIT> ; public static final int WHAT_THEN_COMMENT_OK = <NUM_LIT> ; public static final int WHAT_THEN_SHADOW_BAN = <NUM_LIT> ; public static final int WHAT_THEN_DELETED = <NUM_LIT> ; public static final int WHAT_THEN_UNDER_REVIEW = <NUM_LIT> ; public static final int WHAT_THEN_INVISIBLE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; public class TaskManger { private static volatile Handler mainThreadHandler ; private static Handler getUiThreadHandler ( ) { if ( mainThreadHandler == null ) { synchronized ( TaskManger . class ) { if ( mainThreadHandler == null ) { mainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; } } } return mainThreadHandler ; } public static void postOnUiThread ( Runnable runnable ) { getUiThreadHandler ( ) . post ( runnable ) ; } private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; public static void start ( Runnable runnable ) { executorService . execute ( runnable ) ; } public static void execute ( BackstageTask < ? > backstageTask ) { start ( backstageTask ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . Dialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; public class DialogUtil { public static Dialog dialogMessage ( Context context , String title , String message ) { return dialogMessage ( context , title , message , null ) ; } public static Dialog dialogMessage ( Context context , String title , String message , DialogInterface . OnClickListener onClose ) { AlertDialog . Builder dialogBuilder = new AlertDialog . Builder ( context ) . setMessage ( message ) ; if ( onClose == null ) { dialogBuilder . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; } else { dialogBuilder . setPositiveButton ( "<STR_LIT>" , onClose ) ; } if ( title != null ) { dialogBuilder . setTitle ( title ) ; } return dialogBuilder . show ( ) ; } public static ProgressDialog newProgressDialog ( Context context , String title , String message ) { ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( message ) ; if ( title != null ) { progressDialog . setTitle ( title ) ; } return progressDialog ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . SearchView ; import android . widget . Spinner ; import android . widget . Toast ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContract ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . alibaba . fastjson . JSON ; import com . opencsv . CSVReader ; import com . opencsv . CSVWriter ; import com . opencsv . exceptions . CsvValidationException ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import java . util . zip . ZipOutputStream ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . BatchReviewCommentStatusTask ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResult ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResultCallbackForSaveDoc ; import icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper . ActivityResultForFile ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; public class HistoryCommentActivity extends AppCompatActivity { private static final String [ ] csv_header_after_v500 = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; private static final int REQUEST_CODE_EXPORT = <NUM_LIT> ; private static final int REQUEST_CODE_IMPORT = <NUM_LIT> ; StatisticsDBOpenHelper statisticsDBOpenHelper ; HistoryCommentAdapter adapter ; RecyclerView recyclerView ; Context context ; Config config ; private LoadingHistoryCommentFragment loadingHistoryCommentFragment ; private HistoryCommentFragment historyCommentFragment ; public ActivityResultLauncher < File > savePicFileLauncher ; public ActivityResultLauncher < Intent > exportLauncher ; public CommentManipulator commentManipulator ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_history_comment ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } ByXposedLaunchedActivity . lastActivity = this ; context = this ; config = new Config ( context ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; adapter = new HistoryCommentAdapter ( this , commentManipulator , statisticsDBOpenHelper ) ; loadingHistoryCommentFragment = new LoadingHistoryCommentFragment ( ) ; historyCommentFragment = new HistoryCommentFragment ( adapter ) ; reloadData ( null ) ; savePicFileLauncher = registerForActivityResult ( new ActivityResultContract < File , ActivityResultForFile > ( ) { File inputFile ; @ NonNull @ Override public Intent createIntent ( @ NonNull Context context , File file ) { inputFile = file ; Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . setType ( "<STR_LIT>" ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . putExtra ( Intent . EXTRA_TITLE , file . getName ( ) ) ; return intent ; } @ Override public ActivityResultForFile parseResult ( int i , @ Nullable Intent intent ) { return new ActivityResultForFile ( intent , inputFile ) ; } } , new ActivityResultCallbackForSaveDoc < ActivityResultForFile > ( context ) { @ Override protected void onOpenOutputStream ( OutputStream outputStream , ActivityResultForFile result ) throws IOException { FileInputStream inputStream = new FileInputStream ( result . file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { outputStream . write ( buffer , <NUM_LIT> , read ) ; } HistoryCommentActivity . this . toastInUi ( "<STR_LIT>" ) ; inputStream . close ( ) ; outputStream . close ( ) ; } @ Override protected void onNullOutputStream ( ) { toastInUi ( "<STR_LIT>" ) ; } @ Override protected void onIOException ( Exception e ) { toastInUi ( "<STR_LIT>" + e . getMessage ( ) ) ; } } ) ; exportLauncher = registerForActivityResult ( new ActivityResultContract < Intent , ActivityResult > ( ) { @ NonNull @ Override public Intent createIntent ( @ NonNull Context context , Intent intent ) { return intent ; } @ Override public ActivityResult parseResult ( int i , @ Nullable Intent intent ) { return new ActivityResult ( intent ) ; } } , new ActivityResultCallbackForSaveDoc < ActivityResult > ( context ) { ProgressDialog progressDialog ; @ Override protected void onHasResult ( ) { progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; } @ Override protected void onOpenOutputStream ( OutputStream outputStream , ActivityResult result ) throws IOException { ZipOutputStream zos = new ZipOutputStream ( outputStream ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; List < HistoryComment > historyCommentList = statisticsDBOpenHelper . queryAllHistoryComments ( StatisticsDBOpenHelper . ORDER_BY_DATE_ASC ) ; ZipEntry csvEntry = new ZipEntry ( "<STR_LIT>" ) ; zos . putNextEntry ( csvEntry ) ; CSVWriter csvWriter = new CSVWriter ( new OutputStreamWriter ( zos ) ) ; csvWriter . writeNext ( csv_header_after_v500 ) ; for ( HistoryComment comment : historyCommentList ) { csvWriter . writeNext ( new String [ ] { String . valueOf ( comment . rpid ) , String . valueOf ( comment . parent ) , String . valueOf ( comment . root ) , String . valueOf ( comment . commentArea . oid ) , String . valueOf ( comment . commentArea . type ) , comment . commentArea . sourceId , comment . comment , String . valueOf ( comment . like ) , String . valueOf ( comment . replyCount ) , comment . lastState , String . valueOf ( comment . lastCheckDate . getTime ( ) ) , String . valueOf ( comment . date . getTime ( ) ) , String . valueOf ( comment . checkedArea ) , comment . firstState , comment . pictures , comment . sensitiveScanResult != null ? JSON . toJSONString ( comment . sensitiveScanResult ) : null } ) ; } csvWriter . flush ( ) ; zos . closeEntry ( ) ; File file = PictureStorage . getPicturesDir ( context ) ; File [ ] fileList = file . listFiles ( ) ; if ( fileList != null ) { for ( File fileToZip : fileList ) { try ( FileInputStream fis = new FileInputStream ( fileToZip ) ) { ZipEntry zipEntry = new ZipEntry ( "<STR_LIT>" + fileToZip . getName ( ) ) ; zos . putNextEntry ( zipEntry ) ; int length ; while ( ( length = fis . read ( buffer ) ) >= <NUM_LIT> ) { zos . write ( buffer , <NUM_LIT> , length ) ; } zos . closeEntry ( ) ; } } } zos . close ( ) ; outputStream . close ( ) ; toastInUi ( "<STR_LIT>" ) ; HistoryCommentActivity . this . runOnUiThread ( ( progressDialog :: dismiss ) ) ; } @ Override protected void onNullOutputStream ( ) { progressDialog . dismiss ( ) ; toastInUi ( "<STR_LIT>" ) ; } @ Override protected void onIOException ( Exception e ) { progressDialog . dismiss ( ) ; toastInUi ( "<STR_LIT>" + e . getMessage ( ) ) ; } } ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_more_options , menu ) ; MenuItem menuItem = menu . findItem ( R . id . search ) ; SearchView searchView = ( SearchView ) menuItem . getActionView ( ) ; assert searchView != null ; searchView . setSubmitButtonEnabled ( true ) ; menu . findItem ( R . id .  ) . setChecked ( config . getEnable ( ) ) ; searchView . setOnQueryTextListener ( new SearchView . OnQueryTextListener ( ) { @ Override public boolean onQueryTextSubmit ( String query ) { reloadData ( query ) ; return false ; } @ Override public boolean onQueryTextChange ( String newText ) { if ( TextUtils . isEmpty ( newText ) ) { reloadData ( newText ) ; } return false ; } } ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == android . R . id . home ) { finish ( ) ; } else if ( itemId == R . id . item_sort ) { AtomicInteger sortRuler = new AtomicInteger ( config . getSortRuler ( ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setIcon ( R . drawable . baseline_sort_24 ) . setSingleChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , sortRuler . get ( ) , ( dialog , which ) -> { sortRuler . set ( which ) ; } ) . setPositiveButton ( android . R . string . ok , ( dialog , which ) -> { if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_DATE_DESC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_DATE_ASC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_LIKE_DESC ) ; } else if ( sortRuler . get ( ) == <NUM_LIT> ) { onSortTypeSet ( Config . SORT_RULER_REPLY_COUNT_DESC ) ; } } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } else if ( itemId == R . id . item_filter ) { AtomicBoolean enableNormal = new AtomicBoolean ( config . getFilterRulerEnableNormal ( ) ) ; AtomicBoolean enableShadowBan = new AtomicBoolean ( config . getFilterRulerEnableShadowBan ( ) ) ; AtomicBoolean enableDeleted = new AtomicBoolean ( config . getFilterRulerEnableDelete ( ) ) ; AtomicBoolean enableOther = new AtomicBoolean ( config . getFilterRulerEnableOther ( ) ) ; AtomicBoolean enableType1 = new AtomicBoolean ( config . getFilterRulerEnableType1 ( ) ) ; AtomicBoolean enableType12 = new AtomicBoolean ( config . getFilterRulerEnableType12 ( ) ) ; AtomicBoolean enableType11 = new AtomicBoolean ( config . getFilterRulerEnableType11 ( ) ) ; AtomicBoolean enableType17 = new AtomicBoolean ( config . getFilterRulerEnableType17 ( ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setIcon ( R . drawable . baseline_filter_alt_24 ) . setMultiChoiceItems ( new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , new boolean [ ] { enableNormal . get ( ) , enableShadowBan . get ( ) , enableDeleted . get ( ) , enableOther . get ( ) , enableType1 . get ( ) , enableType12 . get ( ) , enableType11 . get ( ) , enableType17 . get ( ) } , ( dialog , which , isChecked ) -> { if ( which == <NUM_LIT> ) { enableNormal . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableShadowBan . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableDeleted . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableOther . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType1 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType12 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType11 . set ( isChecked ) ; } else if ( which == <NUM_LIT> ) { enableType17 . set ( isChecked ) ; } } ) . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { onFilterRulerSet ( enableNormal . get ( ) , enableShadowBan . get ( ) , enableDeleted . get ( ) , enableOther . get ( ) , enableType1 . get ( ) , enableType12 . get ( ) , enableType11 . get ( ) , enableType17 . get ( ) ) ; } } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } else if ( itemId == R . id . item_export ) { Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; exportLauncher . launch ( intent ) ; } else if ( itemId == R . id . item_import ) { Intent intent = new Intent ( Intent . ACTION_GET_CONTENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { "<STR_LIT>" , "<STR_LIT>" } ) ; startActivityForResult ( intent , REQUEST_CODE_IMPORT ) ; } else if ( itemId == R . id .  ) { boolean enable = ! item . isChecked ( ) ; config . setEnable ( enable ) ; item . setChecked ( enable ) ; adapter . setEnable ( enable ) ; } else if ( itemId == R . id . batch_recheck ) { View dialogView = View . inflate ( context , R . layout . dialog_batch_recheck_start , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; Spinner spinner = dialogView . findViewById ( R . id . spinner_before_by ) ; spinner . setSelection ( <NUM_LIT> ) ; AlertDialog dialog = new AlertDialog . Builder ( this ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( android . R . string . ok , null ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setOnClickListener ( v -> { if ( TextUtils . isEmpty ( editText . getText ( ) . toString ( ) ) ) { editText . setError ( "<STR_LIT>" ) ; return ; } int inputNumber = Integer . parseInt ( editText . getText ( ) . toString ( ) ) ; switch ( spinner . getSelectedItemPosition ( ) ) { case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsByDateGT ( getPreviousNDaysTimestamp ( inputNumber ) ) ) ; break ; case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsByDateGT ( System . currentTimeMillis ( ) - ( long ) inputNumber * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; break ; case <NUM_LIT> : batchCheck ( statisticsDBOpenHelper . queryHistoryCommentsCountLimit ( inputNumber ) ) ; break ; } dialog . dismiss ( ) ; } ) ; } return true ; } private long getPreviousNDaysTimestamp ( int day ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . add ( Calendar . DAY_OF_MONTH , - day ) ; calendar . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MILLISECOND , <NUM_LIT> ) ; Date previousDate = calendar . getTime ( ) ; return previousDate . getTime ( ) ; } private void batchCheck ( List < HistoryComment > pendingCheckComments ) { System . out . println ( pendingCheckComments ) ; if ( pendingCheckComments . isEmpty ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } View dialogView = View . inflate ( context , R . layout . dialog_batch_check , null ) ; RecyclerView recyclerView = dialogView . findViewById ( R . id . rv_batch_checking_comments ) ; RecyclerView . LayoutManager layoutManager = new LinearLayoutManager ( context ) ; recyclerView . setLayoutManager ( layoutManager ) ; BatchCheckAdapter adapter = new BatchCheckAdapter ( context ) ; recyclerView . setAdapter ( adapter ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( String . format ( "<STR_LIT>" , <NUM_LIT> , pendingCheckComments . size ( ) ) ) . setView ( dialogView ) . setCancelable ( false ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; BatchReviewCommentStatusTask task = new BatchReviewCommentStatusTask ( commentManipulator , statisticsDBOpenHelper , pendingCheckComments , new BatchReviewCommentStatusTask . EventHandler ( ) { @ Override public void onStartCheck ( HistoryComment checkingComment ) { adapter . setCheckingComment ( checkingComment ) ; dialog . setTitle ( String . format ( "<STR_LIT>" , adapter . getItemCount ( ) , pendingCheckComments . size ( ) ) ) ; } @ Override public void onCheckOver ( String newStatus ) { adapter . overCheckComment ( newStatus ) ; recyclerView . scrollToPosition ( adapter . getItemCount ( ) ) ; } @ Override public void onComplete ( ) { dialog . setTitle ( pendingCheckComments . size ( ) + "<STR_LIT>" ) ; reloadData ( null ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setText ( "<STR_LIT>" ) ; } @ Override public void onError ( Throwable th ) { dialog . dismiss ( ) ; reloadData ( null ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , th . toString ( ) ) ; } } ) ; task . execute ( ) ; Button button = dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) ; button . setOnClickListener ( v -> { task . breakRun ( ) ; dialog . dismiss ( ) ; } ) ; } private void reloadData ( String searchText ) { replaceFragment ( loadingHistoryCommentFragment ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { String sortRuler = null ; switch ( config . getSortRuler ( ) ) { case Config . SORT_RULER_DATE_ASC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_DATE_ASC ; break ; case Config . SORT_RULER_DATE_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_DATE_DESC ; break ; case Config . SORT_RULER_LIKE_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_LIKE_DESC ; break ; case Config . SORT_RULER_REPLY_COUNT_DESC : sortRuler = StatisticsDBOpenHelper . ORDER_BY_REPLY_COUNT_DESC ; break ; default : throw new RuntimeException ( "<STR_LIT>" + config . getSortRuler ( ) ) ; } List < HistoryComment > historyCommentList = statisticsDBOpenHelper . queryAllHistoryComments ( sortRuler ) ; List < HistoryComment > sortedCommentList = new ArrayList < > ( historyCommentList . size ( ) ) ; boolean enableNormal = config . getFilterRulerEnableNormal ( ) ; boolean enableShadowBan = config . getFilterRulerEnableShadowBan ( ) ; boolean enableDelete = config . getFilterRulerEnableDelete ( ) ; boolean enableOther = config . getFilterRulerEnableOther ( ) ; boolean enableType1 = config . getFilterRulerEnableType1 ( ) ; boolean enableType12 = config . getFilterRulerEnableType12 ( ) ; boolean enableType11 = config . getFilterRulerEnableType11 ( ) ; boolean enableType17 = config . getFilterRulerEnableType17 ( ) ; if ( ! TextUtils . isEmpty ( searchText ) && searchText . startsWith ( "<STR_LIT>" ) ) { Pattern pattern = Pattern . compile ( "<STR_LIT>" ) ; Matcher matcher = pattern . matcher ( searchText ) ; if ( matcher . find ( ) ) { String startDateStr = matcher . group ( <NUM_LIT> ) ; String endDateStr = matcher . group ( <NUM_LIT> ) ; try { @ SuppressLint ( "<STR_LIT>" ) SimpleDateFormat dateFormat = new SimpleDateFormat ( "<STR_LIT>" ) ; if ( startDateStr != null && endDateStr != null ) { Date startDate = dateFormat . parse ( startDateStr ) ; Date endDate = dateFormat . parse ( endDateStr ) ; historyCommentList = filterCommentsWithinRange ( historyCommentList , startDate , endDate ) ; } else { toastInUi ( "<STR_LIT>" ) ; } } catch ( ParseException e ) { toastInUi ( "<STR_LIT>" ) ; } } else { toastInUi ( "<STR_LIT>" ) ; } } boolean continueToSearching = ! TextUtils . isEmpty ( searchText ) && ! searchText . startsWith ( "<STR_LIT>" ) ; for ( HistoryComment historyComment : historyCommentList ) { if ( continueToSearching && ! ( historyComment . comment . contains ( searchText ) || historyComment . commentArea . sourceId . contains ( searchText ) ) ) { continue ; } int type = historyComment . commentArea . type ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { if ( ! enableType1 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { if ( ! enableType12 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_DYNAMIC11 ) { if ( ! enableType11 ) { continue ; } } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { if ( ! enableType17 ) { continue ; } } if ( historyComment . lastState . equals ( HistoryComment . STATE_NORMAL ) ) { if ( enableNormal ) { sortedCommentList . add ( historyComment ) ; } } else if ( historyComment . lastState . equals ( HistoryComment . STATE_SHADOW_BAN ) ) { if ( enableShadowBan ) { sortedCommentList . add ( historyComment ) ; } } else if ( historyComment . lastState . equals ( HistoryComment . STATE_DELETED ) ) { if ( enableDelete ) { sortedCommentList . add ( historyComment ) ; } } else if ( enableOther ) { sortedCommentList . add ( historyComment ) ; } } runOnUiThread ( ( ) -> { if ( ! TextUtils . isEmpty ( searchText ) ) { Toast . makeText ( context , "<STR_LIT>" + sortedCommentList . size ( ) + "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } adapter . reloadData ( sortedCommentList ) ; replaceFragment ( historyCommentFragment ) ; } ) ; } } ) . start ( ) ; } protected void onFilterRulerSet ( boolean enableNormal , boolean enableShadowBan , boolean enableDeleted , boolean enableOther , boolean e1 , boolean e12 , boolean e11 , boolean e17 ) { config . setFilterRulerEnableNormal ( enableNormal ) ; config . setFilterRulerEnableShadowBan ( enableShadowBan ) ; config . setFilterRulerEnableDeleted ( enableDeleted ) ; config . setFilterRulerEnableOther ( enableOther ) ; config . setFilterRulerEnableType1 ( e1 ) ; config . setFilterRulerEnableType12 ( e12 ) ; config . setFilterRulerEnableType11 ( e11 ) ; config . setFilterRulerEnableType17 ( e17 ) ; reloadData ( null ) ; } protected void onSortTypeSet ( int sortRuler ) { config . setSortRuler ( sortRuler ) ; reloadData ( null ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent intent ) { super . onActivityResult ( requestCode , resultCode , intent ) ; switch ( requestCode ) { case REQUEST_CODE_IMPORT : ProgressDialog progressDialog1 = new ProgressDialog ( context ) ; progressDialog1 . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog1 . setMessage ( "<STR_LIT>" ) ; progressDialog1 . setCancelable ( false ) ; progressDialog1 . show ( ) ; Executor executor = Executors . newSingleThreadExecutor ( ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( intent == null || intent . getData ( ) == null ) { error ( "<STR_LIT>" ) ; return ; } String type = getContentResolver ( ) . getType ( intent . getData ( ) ) ; try { List < HistoryComment > readComments = null ; InputStream inputStream = getContentResolver ( ) . openInputStream ( intent . getData ( ) ) ; if ( inputStream == null ) { error ( "<STR_LIT>" ) ; return ; } if ( "<STR_LIT>" . equals ( type ) ) { ZipInputStream zis = new ZipInputStream ( inputStream ) ; ZipEntry nextEntry ; while ( ( nextEntry = zis . getNextEntry ( ) ) != null ) { String name = nextEntry . getName ( ) ; System . out . println ( name ) ; if ( name . equals ( "<STR_LIT>" ) ) { readComments = readCSVToHistoryComments ( new CSVReader ( new InputStreamReader ( zis ) ) ) ; } else if ( name . startsWith ( "<STR_LIT>" ) ) { String [ ] split = name . split ( "<STR_LIT>" ) ; PictureStorage . save ( context , zis , split [ split . length - <NUM_LIT> ] ) ; } zis . closeEntry ( ) ; } zis . close ( ) ; } else if ( "<STR_LIT>" . equals ( type ) ) { readComments = readCSVToHistoryComments ( new CSVReader ( new InputStreamReader ( inputStream ) ) ) ; inputStream . close ( ) ; } else { error ( "<STR_LIT>" ) ; return ; } int successCount = <NUM_LIT> ; int failCount = <NUM_LIT> ; if ( readComments == null ) { error ( "<STR_LIT>" ) ; return ; } List < HistoryComment > newHistoryCommentList = new ArrayList < > ( ) ; for ( HistoryComment comment : readComments ) { if ( statisticsDBOpenHelper . insertHistoryComment ( comment ) > <NUM_LIT> ) { System . out . println ( "<STR_LIT>" + comment ) ; newHistoryCommentList . add ( comment ) ; successCount ++ ; } else { System . out . println ( "<STR_LIT>" + comment ) ; failCount ++ ; } } int finalSuccessCount = successCount ; int finalFailCount = failCount ; runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; adapter . addSomeData ( newHistoryCommentList ) ; Toast . makeText ( context , "<STR_LIT>" + finalSuccessCount + "<STR_LIT>" + finalFailCount + "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } catch ( IOException e ) { error ( "<STR_LIT>" + e . getMessage ( ) ) ; } catch ( CsvValidationException e ) { error ( "<STR_LIT>" + e . getMessage ( ) ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) ; } } private List < HistoryComment > readCSVToHistoryComments ( CSVReader csvReader ) throws CsvValidationException , IOException { String [ ] header_before_v500 = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] header_banned = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] data ; if ( ( data = csvReader . readNext ( ) ) == null ) { return null ; } if ( Arrays . equals ( header_before_v500 , data ) ) { return readCSVToHistoryComments_before_v500 ( csvReader ) ; } else if ( Arrays . equals ( csv_header_after_v500 , data ) ) { return readCSVToHistoryComments_after_v500 ( csvReader ) ; } else if ( Arrays . equals ( header_banned , data ) ) { return readCSVToHistoryComments_banned_to_history ( csvReader ) ; } else { return null ; } } private List < HistoryComment > readCSVToHistoryComments_before_v500 ( CSVReader csvReader ) throws CsvValidationException , IOException { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; String [ ] data ; while ( ( data = csvReader . readNext ( ) ) != null ) { HistoryComment historyComment = new HistoryComment ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) ) ; historyCommentList . add ( historyComment ) ; } return historyCommentList ; } private List < HistoryComment > readCSVToHistoryComments_after_v500 ( CSVReader csvReader ) throws CsvValidationException , IOException { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; String [ ] data ; while ( ( data = csvReader . readNext ( ) ) != null ) { CommentArea commentArea = new CommentArea ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) ) ; HistoryComment comment = new HistoryComment ( commentArea , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , data [ <NUM_LIT> ] , JSON . parseObject ( data [ <NUM_LIT> ] , SensitiveScanResult . class ) ) ; historyCommentList . add ( comment ) ; } return historyCommentList ; } private List < HistoryComment > readCSVToHistoryComments_banned_to_history ( CSVReader csvReader ) throws CsvValidationException , IOException { String [ ] data ; List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; while ( ( data = csvReader . readNext ( ) ) != null ) { CommentArea commentArea = new CommentArea ( Long . parseLong ( data [ <NUM_LIT> ] ) , data [ <NUM_LIT> ] , Integer . parseInt ( data [ <NUM_LIT> ] ) ) ; String state = data [ <NUM_LIT> ] ; HistoryComment comment = new HistoryComment ( commentArea , Long . parseLong ( data [ <NUM_LIT> ] ) , <NUM_LIT> , <NUM_LIT> , data [ <NUM_LIT> ] , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , <NUM_LIT> , <NUM_LIT> , state , new Date ( Long . parseLong ( data [ <NUM_LIT> ] ) ) , Integer . parseInt ( data [ <NUM_LIT> ] ) , state , null , null ) ; if ( comment . firstState . equals ( "<STR_LIT>" ) ) { comment . firstState = HistoryComment . STATE_NORMAL ; } if ( comment . firstState . equals ( "<STR_LIT>" ) ) { comment . firstState = HistoryComment . STATE_DELETED ; } if ( comment . lastState . equals ( "<STR_LIT>" ) ) { comment . lastState = HistoryComment . STATE_SHADOW_BAN ; } if ( comment . lastState . equals ( "<STR_LIT>" ) ) { comment . lastState = HistoryComment . STATE_DELETED ; } historyCommentList . add ( comment ) ; } return historyCommentList ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } private void replaceFragment ( Fragment fragment ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction fragmentTransaction = fragmentManager . beginTransaction ( ) ; fragmentTransaction . replace ( R . id . frame , fragment ) ; fragmentTransaction . commit ( ) ; } public static List < HistoryComment > filterCommentsWithinRange ( List < HistoryComment > historyCommentList , Date startDate , Date endDate ) { List < HistoryComment > filteredComments = new ArrayList < > ( ) ; for ( HistoryComment comment : historyCommentList ) { if ( comment . date . after ( startDate ) && comment . date . before ( endDate ) ) { filteredComments . add ( comment ) ; } } return filteredComments ; } public void toastInUi ( String message ) { runOnUiThread ( ( ) -> { Toast . makeText ( context , message , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . Nullable ; import java . util . List ; public class CommentPage { public Page page ; public List < BiliComment > replies ; @ Nullable public List < BiliComment > top_replies ; public static class Page { public int num ; public int size ; public int count ; public int acount ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; public class LoadingHistoryCommentFragment extends Fragment { private View rootView ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_loading_history_comment , container , false ) ; return rootView ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . database . Cursor ; public class GreatCursor { Cursor cursor ; public GreatCursor ( Cursor cursor ) { this . cursor = cursor ; } public int getInt ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getInt ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public long getLong ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getLong ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public String getString ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getString ( columnIndex ) ; } else { throw new RuntimeException ( "<STR_LIT>" + columnName + "<STR_LIT>" ) ; } } public boolean moveToNext ( ) { return cursor . moveToNext ( ) ; } public void close ( ) { cursor . close ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . SharedPreferences ; public class XConfig { public static final String PREF_NAME = "<STR_LIT>" ; private final SharedPreferences sp ; protected XConfig ( SharedPreferences sharedPreferences ) { this . sp = sharedPreferences ; } public void setHookPictureSelectEnable ( boolean enable ) { sp . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getHookPictureSelectIsEnable ( ) { return sp . getBoolean ( "<STR_LIT>" , true ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class VideoInfo { public String bvid ; public long aid ; public String title ; public String desc ; public String pic ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import androidx . annotation . NonNull ; import java . io . File ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; import okhttp3 . Interceptor ; import okhttp3 . MediaType ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class LoggerInterceptor implements Interceptor { private final Logger logger ; public LoggerInterceptor ( ) { File logDir = new File ( "<STR_LIT>" + BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; if ( ! logDir . exists ( ) ) { logDir . mkdirs ( ) ; } logger = new Logger ( logDir ) ; } @ NonNull @ Override public Response intercept ( @ NonNull Chain chain ) throws IOException { Request request = chain . request ( ) ; Response response = null ; response = chain . proceed ( request ) ; String time = new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) ; logger . log ( "<STR_LIT>" + time + "<STR_LIT>" ) ; logger . log ( "<STR_LIT>" + request . url ( ) ) ; logger . log ( "<STR_LIT>" + request . method ( ) ) ; logger . log ( "<STR_LIT>" + request . headers ( ) ) ; logger . log ( "<STR_LIT>" + response . code ( ) ) ; logger . log ( "<STR_LIT>" + response . message ( ) ) ; logger . log ( "<STR_LIT>" + response . headers ( ) ) ; ResponseBody body = response . body ( ) ; if ( body != null ) { MediaType contentType = body . contentType ( ) ; if ( contentType != null && contentType . toString ( ) . contains ( "<STR_LIT>" ) ) { String responseBody = body . string ( ) ; logger . log ( "<STR_LIT>" + responseBody ) ; logger . log ( "<STR_LIT>" ) ; return response . newBuilder ( ) . body ( ResponseBody . create ( contentType , responseBody ) ) . build ( ) ; } } logger . log ( "<STR_LIT>" ) ; return response ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XposedBridge ; public class HookStater { public int appVersionCode ; public ClassLoader classLoader ; public HookStater ( int appVersionCode , ClassLoader classLoader ) { this . appVersionCode = appVersionCode ; this . classLoader = classLoader ; } public void startHook ( BaseHook baseHook ) { try { baseHook . startHook ( appVersionCode , classLoader ) ; } catch ( Throwable throwable ) { XposedBridge . log ( baseHook . getClass ( ) . getSimpleName ( ) + "<STR_LIT>" + throwable ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; @ SuppressLint ( "<STR_LIT>" ) public class BatchCheckAdapter extends RecyclerView . Adapter < BatchCheckAdapter . ViewHolder > { private final Context context ; private final List < String > oldStatusList = new ArrayList < > ( ) ; private final List < HistoryComment > checkedComments = new ArrayList < > ( ) ; private HistoryComment checkingComment ; public BatchCheckAdapter ( Context context ) { this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_one_batch_checking_comment , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { if ( position == checkedComments . size ( ) ) { holder . txv_comment_content . setText ( checkingComment . comment ) ; setStatus ( checkingComment . lastState , holder . txv_old_status , holder . img_old_status ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( new ProgressBar ( context ) ) ; return ; } HistoryComment comment = checkedComments . get ( position ) ; holder . txv_comment_content . setText ( comment . comment ) ; setStatus ( oldStatusList . get ( position ) , holder . txv_old_status , holder . img_old_status ) ; ImageView imageView = new ImageView ( context ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( imageView ) ; setStatus ( comment . lastState , holder . txv_new_status , imageView ) ; } @ Override public int getItemCount ( ) { int size = checkedComments . size ( ) ; if ( checkingComment != null ) { size ++ ; } return size ; } private void setStatus ( String status , TextView textView , ImageView imageView ) { switch ( status ) { case HistoryComment . STATE_NORMAL : imageView . setImageDrawable ( context . getDrawable ( R . drawable . normal ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SHADOW_BAN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNDER_REVIEW : imageView . setImageDrawable ( context . getDrawable ( R . drawable . i ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_DELETED : imageView . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SENSITIVE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . sensitive ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_INVISIBLE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ghost ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNKNOWN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . unknown ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_access_time_24 ) ) ; textView . setText ( "<STR_LIT>" ) ; break ; default : textView . setText ( status ) ; } } public void setCheckingComment ( HistoryComment historyComment ) { checkingComment = historyComment ; oldStatusList . add ( historyComment . lastState ) ; notifyItemInserted ( getItemCount ( ) - <NUM_LIT> ) ; } public void overCheckComment ( String newStatus ) { if ( checkingComment == null ) { throw new IllegalStateException ( "<STR_LIT>" ) ; } checkingComment . lastState = newStatus ; checkedComments . add ( checkingComment ) ; checkingComment = null ; notifyItemChanged ( getItemCount ( ) - <NUM_LIT> ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { ImageView img_old_status = itemView . findViewById ( R . id . img_old_status ) ; TextView txv_old_status = itemView . findViewById ( R . id . txv_old_status ) ; FrameLayout new_status_icon_frame = itemView . findViewById ( R . id . new_status_icon_frame ) ; TextView txv_new_status = itemView . findViewById ( R . id . txv_new_status ) ; TextView txv_comment_content = itemView . findViewById ( R . id . txv_comment_content ) ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import icu . freedomIntrovert . async . BackstageTaskByMVP ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class BatchReviewCommentStatusTask extends BackstageTaskByMVP < BatchReviewCommentStatusTask . EventHandler > { private final AtomicBoolean isBreak = new AtomicBoolean ( false ) ; private final CommentManipulator commentManipulator ; private final StatisticsDBOpenHelper statisticsDB ; private final List < HistoryComment > comments ; public BatchReviewCommentStatusTask ( CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , List < HistoryComment > comments , EventHandler uiHandler ) { super ( uiHandler ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . comments = comments ; } @ Override protected void onStart ( EventHandler eventHandlerProxy ) throws Throwable { for ( HistoryComment comment : comments ) { if ( isBreak . get ( ) ) { System . out . println ( "<STR_LIT>" ) ; break ; } eventHandlerProxy . onStartCheck ( comment ) ; eventHandlerProxy . onCheckOver ( checkComment ( comment ) ) ; } } public void breakRun ( ) { isBreak . set ( true ) ; } public String checkComment ( HistoryComment historyComment ) throws IOException , CookieFailedException , BiliBiliApiException { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { throw new CookieFailedException ( ) ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_UNDER_REVIEW ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } } } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_SHADOW_BAN , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } } else if ( resp . code == CommentAddResult . CODE_DELETED ) { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } else if ( resp . code == <NUM_LIT> ) { return "<STR_LIT>" ; } else { throw new BiliBiliApiException ( resp , "<STR_LIT>" ) ; } } public interface EventHandler extends BaseEventHandler { void onStartCheck ( HistoryComment checkingComment ) ; void onCheckOver ( String newStatus ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class AreaMartialLawCheckTask extends CommentOperateTask < AreaMartialLawCheckTask . EventHandler > { private final CommentUtil commentUtil ; private final boolean isDeputyAccount ; public AreaMartialLawCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentUtil commentUtil , boolean isDeputyAccount ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . commentUtil = commentUtil ; this . isDeputyAccount = isDeputyAccount ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; String randomComment = commentUtil . getRandomComment ( commentArea ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( randomComment , <NUM_LIT> , <NUM_LIT> , commentArea , isDeputyAccount ) ; eventHandler . sendEventMessage ( new EventMessage ( EventHandler . WHAT_ON_TEST_COMMENT_SENT , randomComment ) ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( commentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_MARTIAL_LAW ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_AREA_OK ) ; } else { if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_MARTIAL_LAW ) ; statisticsDB . insertMartialLawCommentArea ( commentManipulator . getMartialLawCommentArea ( commentArea , testCommentRpid , isDeputyAccount ) ) ; } commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_MARTIAL_LAW ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_TEST_COMMENT_SENT = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_AREA_OK = <NUM_LIT> ; public static final int WHAT_THEN_MARTIAL_LAW = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; public class ActivityResult { public ActivityResult ( Intent intent ) { this . intent = intent ; } public Intent intent ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ResendCommentTask extends BackstageTask < ResendCommentTask . EventHandler > { private final CommentManipulator commentManipulator ; private final Config config ; private final String newCommentText ; private final HistoryComment historyComment ; public ResendCommentTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , String newCommentText , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . config = config ; this . newCommentText = newCommentText ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { GeneralResponse < CommentAddResult > body = commentManipulator . getSendCommentCall ( newCommentText , historyComment . parent , historyComment . root , historyComment . commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; long waitTime = config . getWaitTime ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_SUCCESS_AND_SLEEP , waitTime ) ; if ( body . isSuccess ( ) ) { new ProgressTimer ( waitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , ( progress , sleepSeg ) -> eventHandler . sendEventMessage ( EventHandler . WHAT_ON_NEW_PROGRESS , progress , sleepSeg , waitTime ) ) . start ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_RESENT_COMMENT , body . data ) ; } else { if ( body . code == <NUM_LIT> ) { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CONTAIN_SENSITIVE , body . message , newCommentText ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( body , "<STR_LIT>" ) ) ; } } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_SEND_SUCCESS_AND_SLEEP = <NUM_LIT> ; public static final int WHAT_ON_NEW_PROGRESS = <NUM_LIT> ; public static final int WHAT_ON_RESENT_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CONTAIN_SENSITIVE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import android . util . Log ; import java . io . IOException ; import java . util . Arrays ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . ForwardDynamicResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class SensitiveScannerTask extends BackstageTask < SensitiveScannerTask . EventHandler > { private final Comment mainComment ; private CommentArea commentAreaForTest ; private String dynamicIdToBeForward ; private final CommentManipulator commentManipulator ; private final Config config ; private final StatisticsDBOpenHelper helper ; public SensitiveScannerTask ( EventHandler handle , Comment mainComment , CommentArea yourCommentArea , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . commentAreaForTest = yourCommentArea ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } public SensitiveScannerTask ( EventHandler handle , Comment mainComment , String dynamicIdToBeForward , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . dynamicIdToBeForward = dynamicIdToBeForward ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { String commentText = mainComment . comment ; long waitTime = config . getWaitTime ( ) ; if ( dynamicIdToBeForward != null ) { commentAreaForTest = forwardDynamicToCreateNewCommentArea ( eventHandler ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_SENT , waitTime ) ; sleepAndSendProgress ( waitTime , eventHandler ) ; long fulltextRpid = commentManipulator . sendComment ( commentText , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) . rpid ; BiliComment foundComment = commentManipulator . findComment ( commentAreaForTest , fulltextRpid , <NUM_LIT> ) ; commentManipulator . deleteComment ( commentAreaForTest , fulltextRpid , false ) ; if ( foundComment != null ) { deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_IS_NORMAL , commentAreaForTest ) ; return ; } int max = ( int ) ( Math . log ( ( double ) commentText . length ( ) / <NUM_LIT> ) / Math . log ( <NUM_LIT> ) ) ; int currProg = <NUM_LIT> ; Log . i ( "<STR_LIT>" , String . valueOf ( commentText . length ( ) ) ) ; Log . i ( "<STR_LIT>" , String . valueOf ( max ) ) ; String passText = "<STR_LIT>" ; String [ ] split = splitFromTheMiddle ( commentText ) ; SensitiveScanResult result = new SensitiveScanResult ( ) ; while ( split != null ) { System . out . println ( Arrays . toString ( split ) ) ; String [ ] finalSplit = split ; int normalPosition = passText . length ( ) ; int splitLeftPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; int splitRightPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT , normalPosition , splitLeftPosition , splitRightPosition , waitTime ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( passText + split [ <NUM_LIT> ] , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) ; long rpid = commentAddResult . rpid ; sleepAndSendProgress ( waitTime , eventHandler ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECKING_COMMENT , currProg , max ) ; if ( commentManipulator . findComment ( commentAreaForTest , rpid , <NUM_LIT> ) != null ) { result . normalPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; passText += split [ <NUM_LIT> ] ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ; } else { result . normalPosition = passText . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECK_RESULT , result ) ; commentManipulator . deleteComment ( commentAreaForTest , rpid , false ) ; System . out . println ( passText ) ; sleep ( <NUM_LIT> ) ; currProg ++ ; } helper . addSensitiveScanResultToHistoryComment ( mainComment . rpid , result ) ; deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_SCAN_COMPLETE ) ; } private CommentArea forwardDynamicToCreateNewCommentArea ( EventHandler eventHandler ) throws IOException , BiliBiliApiException { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_FORWARD_DYNAMIC ) ; ForwardDynamicResult forwardDynamicResult = commentManipulator . forwardDynamicUsingSubAccount ( dynamicIdToBeForward ) ; long dynRid = forwardDynamicResult . dyn_rid ; eventHandler . sendEventMessage ( EventHandler . WHAT_FORWARDED_DYNAMIC , dynRid ) ; sleepAndSendProgress ( <NUM_LIT> , eventHandler ) ; return new CommentArea ( dynRid , String . valueOf ( dynRid ) , CommentArea . AREA_TYPE_DYNAMIC17 ) ; } private void deleteForwardedDynamic ( EventHandler eventHandler , String dynamicId ) throws BiliBiliApiException , IOException { if ( dynamicIdToBeForward != null ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_DELETE_FORWARDED_DYNAMIC ) ; commentManipulator . deleteDynamicUsingSubAccount ( dynamicId ) ; } } public static String [ ] splitFromTheMiddle ( String input ) { if ( input . length ( ) >= <NUM_LIT> ) { return new String [ ] { input . substring ( <NUM_LIT> , input . length ( ) / <NUM_LIT> ) , input . substring ( input . length ( ) / <NUM_LIT> ) } ; } else { return null ; } } public void sleepAndSendProgress ( long time1 , EventHandler eventHandler ) { int time = ( int ) time1 ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , time ) ; int sleepSeg = <NUM_LIT> ; int sleepCount = time / sleepSeg ; for ( int i = <NUM_LIT> ; i <= sleepCount ; i ++ ) { sleep ( sleepSeg ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS , sleepSeg * i ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , - <NUM_LIT> ) ; } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_COMMENT_FULL_TEXT_SENT = <NUM_LIT> ; public static final int WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT = <NUM_LIT> ; public static final int WHAT_ON_CHECKING_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CHECK_RESULT = <NUM_LIT> ; public static final int WHAT_COMMENT_FULL_TEXT_IS_NORMAL = <NUM_LIT> ; public static final int WHAT_ON_SCAN_COMPLETE = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS_MAX = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS = <NUM_LIT> ; public static final int WHAT_FORWARD_DYNAMIC = <NUM_LIT> ; public static final int WHAT_FORWARDED_DYNAMIC = <NUM_LIT> ; public static final int WHAT_DELETE_FORWARDED_DYNAMIC = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import java . util . ArrayList ; public class CommentReplyPage { public BiliComment root ; public ArrayList < BiliComment > replies ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class HistoryCommentFragment extends Fragment { private View rootView ; private RecyclerView recyclerView ; private HistoryCommentAdapter adapter ; public HistoryCommentFragment ( ) { } public HistoryCommentFragment ( HistoryCommentAdapter adapter ) { this . adapter = adapter ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_history_comment , container , false ) ; recyclerView = rootView . findViewById ( R . id . rv_history_comments ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( getContext ( ) ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; return rootView ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . NotificationManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . provider . Settings ; import android . view . Window ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ByXposedLaunchedActivity extends AppCompatActivity { public static final int TODO_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_CHECK_DANMAKU = <NUM_LIT> ; public static final int TODO_CONTINUE_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_SAVE_CONTAIN_SENSITIVE_CONTENT = <NUM_LIT> ; public static Activity lastActivity ; Context context ; Handler handler ; CommentManipulator commentManipulator ; CommentUtil commentUtil ; StatisticsDBOpenHelper statisticsDBOpenHelper ; DanmakuManipulator danmakuManipulator ; boolean toContinueTo = true ; Config config ; @ Override protected void onCreate ( Bundle savedInstanceState ) { if ( lastActivity != null ) { System . out . println ( "<STR_LIT>" + lastActivity . getClass ( ) . getCanonicalName ( ) + "<STR_LIT>" ) ; lastActivity . finish ( ) ; } super . onCreate ( savedInstanceState ) ; supportRequestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . activity_by_xposed_launched ) ; this . context = this ; config = new Config ( context ) ; handler = new Handler ( ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; commentUtil = new CommentUtil ( context ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; danmakuManipulator = new DanmakuManipulator ( ) ; Intent intent = getIntent ( ) ; int todo = intent . getIntExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; long waitTime = config . getWaitTime ( ) ; long waitTimeByHasPictures = config . getWaitTimeByHasPictures ( ) ; Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { showExtrasError ( null ) ; } else if ( todo == TODO_CHECK_COMMENT ) { String message = extras . getString ( "<STR_LIT>" ) ; String s_oid = extras . getString ( "<STR_LIT>" ) ; String s_type = extras . getString ( "<STR_LIT>" ) ; String s_resultRpid = extras . getString ( "<STR_LIT>" ) ; String s_root = extras . getString ( "<STR_LIT>" ) ; String s_parent = extras . getString ( "<STR_LIT>" ) ; String commentText = extras . getString ( "<STR_LIT>" ) ; String dynamicId = extras . getString ( "<STR_LIT>" ) ; String bvid = extras . getString ( "<STR_LIT>" ) ; String pictures = extras . getString ( "<STR_LIT>" ) ; long ctime = extras . getLong ( "<STR_LIT>" , <NUM_LIT> ) * <NUM_LIT> ; if ( message == null || s_oid == null || s_type == null || s_resultRpid == null || s_root == null || s_parent == null || commentText == null ) { showExtrasError ( extras ) ; return ; } long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; long resultRpid = Long . parseLong ( s_resultRpid ) ; long root = Long . parseLong ( s_root ) ; long parent = Long . parseLong ( s_parent ) ; CommentArea commentArea = null ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentArea = new CommentArea ( oid , bvid , type ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { commentArea = new CommentArea ( oid , s_oid , type ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { commentArea = new CommentArea ( oid , "<STR_LIT>" + oid , type ) ; } else { commentArea = new CommentArea ( oid , dynamicId != null ? dynamicId : "<STR_LIT>" , type ) ; } Comment comment = new Comment ( commentArea , resultRpid , parent , root , commentText , pictures , new Date ( ctime ) ) ; statisticsDBOpenHelper . insertPendingCheckComment ( comment ) ; boolean hasPictures = comment . hasPictures ( ) ; long totalWaitTime ; String proMsg ; if ( hasPictures ) { totalWaitTime = waitTime + waitTimeByHasPictures ; proMsg = "<STR_LIT>" + waitTime + "<STR_LIT>" + waitTimeByHasPictures + "<STR_LIT>" + totalWaitTime + "<STR_LIT>" ; } else { totalWaitTime = waitTime ; proMsg = "<STR_LIT>" + waitTime + "<STR_LIT>" ; } ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( String . format ( proMsg , <NUM_LIT> ) ) . setPositiveButton ( "<STR_LIT>" , null ) . setCancelable ( false ) . show ( ) ; ProgressTimer progressTimer = new ProgressTimer ( totalWaitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , new ProgressTimer . ProgressLister ( ) { @ Override public void onNewProgress ( int progress , long sleepSeg ) { runOnUiThread ( ( ) -> { progressBarDialog . setProgress ( progress ) ; progressBarDialog . setMessage ( String . format ( proMsg , progress * sleepSeg ) ) ; } ) ; } } ) ; long lastTime = System . currentTimeMillis ( ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( v -> { if ( checkNotificationPermission ( context ) ) { Intent intent1 = new Intent ( context , WaitService . class ) ; if ( hasPictures ) { intent1 . putExtra ( "<STR_LIT>" , totalWaitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } else { intent1 . putExtra ( "<STR_LIT>" , waitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } intent1 . putExtra ( "<STR_LIT>" , resultRpid ) ; intent1 . putExtra ( "<STR_LIT>" , commentText ) ; startService ( intent1 ) ; toContinueTo = false ; finish ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; requestNotificationPermission ( context ) ; } } ) ; new Thread ( ( ) -> { progressTimer . start ( ) ; if ( toContinueTo ) { runOnUiThread ( ( ) -> { progressBarDialog . setIndeterminate ( true ) ; progressBarDialog . setTitle ( "<STR_LIT>" ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( false ) ; toCheckComment ( comment , progressBarDialog ) ; } ) ; } } ) . start ( ) ; } else if ( todo == TODO_CONTINUE_CHECK_COMMENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; long rpid = intent . getLongExtra ( "<STR_LIT>" , - <NUM_LIT> ) ; Comment comment = statisticsDBOpenHelper . getPendingCheckCommentByRpid ( rpid ) ; System . out . println ( comment ) ; if ( comment == null ) { dialogMessageAndExit ( "<STR_LIT>" , "<STR_LIT>" + rpid + "<STR_LIT>" ) ; } else { toCheckComment ( comment , progressBarDialog ) ; } } else if ( todo == TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; String comment = intent . getStringExtra ( "<STR_LIT>" ) ; String message = intent . getStringExtra ( "<STR_LIT>" ) ; String s_oid = intent . getStringExtra ( "<STR_LIT>" ) ; String s_type = intent . getStringExtra ( "<STR_LIT>" ) ; String dynamicId = intent . getStringExtra ( "<STR_LIT>" ) ; DialogInterface . OnClickListener onClose = ( dialog , which ) -> finish ( ) ; if ( comment != null && s_oid != null && s_type != null ) { long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentManipulator . getVideoInfoByAid ( oid ) . enqueue ( new BiliApiCallback < GeneralResponse < VideoInfo > > ( ) { @ Override public void onError ( Throwable th ) { progressBarDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , th . getMessage ( ) , onClose ) ; } @ Override public void onSuccess ( GeneralResponse < VideoInfo > videoInfoGeneralResponse ) { progressBarDialog . dismiss ( ) ; if ( videoInfoGeneralResponse . isSuccess ( ) ) { addSensitiveComment ( new CommentArea ( oid , videoInfoGeneralResponse . data . bvid , type ) , comment , message , onClose ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , videoInfoGeneralResponse . message , onClose ) ; } } } ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { addSensitiveComment ( new CommentArea ( oid , "<STR_LIT>" + oid , type ) , comment , message , onClose ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { addSensitiveComment ( new CommentArea ( oid , String . valueOf ( oid ) , type ) , comment , message , onClose ) ; } else { addSensitiveComment ( new CommentArea ( oid , dynamicId != null ? dynamicId : "<STR_LIT>" , type ) , comment , message , onClose ) ; } } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + intent . getExtras ( ) , onClose ) ; } } } private void addSensitiveComment ( CommentArea commentArea , String commentText , String message , DialogInterface . OnClickListener onClose ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , - System . currentTimeMillis ( ) , <NUM_LIT> , <NUM_LIT> , commentText , null , new Date ( ) ) ) ; historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SENSITIVE ) ; if ( statisticsDBOpenHelper . insertHistoryComment ( historyComment ) > <NUM_LIT> ) { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + message + "<STR_LIT>" + commentText , onClose ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" , onClose ) ; } } private void showExtrasError ( @ Nullable Bundle extras ) { dialogMessageAndExit ( "<STR_LIT>" , "<STR_LIT>" + extras ) ; } private void dialogMessageAndExit ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> finish ( ) ) . show ( ) ; } private void toCheckComment ( Comment comment , ProgressBarDialog progressDialog ) { DialogCommCheckWorker worker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , commentUtil ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void exit ( ) { finish ( ) ; } } ) ; List < Comment . PictureInfo > pictureInfoList = comment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { TaskManger . start ( ( ) -> { try { for ( int i = <NUM_LIT> ; i < pictureInfoList . size ( ) ; i ++ ) { int finalI = i ; runOnUiThread ( ( ) -> { progressDialog . setMessage ( "<STR_LIT>" + ( finalI + <NUM_LIT> ) + "<STR_LIT>" + pictureInfoList . size ( ) + "<STR_LIT>" ) ; } ) ; PictureStorage . save ( context , pictureInfoList . get ( i ) . img_src ) ; } runOnUiThread ( ( ) -> { progressDialog . setMessage ( "<STR_LIT>" ) ; worker . checkComment ( comment , progressDialog ) ; } ) ; } catch ( IOException e ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , "<STR_LIT>" + e . getMessage ( ) ) ; } ) ; e . printStackTrace ( ) ; } } ) ; } else { worker . checkComment ( comment , progressDialog ) ; } } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; System . out . println ( "<STR_LIT>" ) ; System . out . println ( this ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } public static boolean checkNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; if ( notificationManager != null ) { return notificationManager . areNotificationsEnabled ( ) ; } } else { return true ; } return false ; } public static void requestNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { Intent intent = new Intent ( Settings . ACTION_APP_NOTIFICATION_SETTINGS ) ; intent . putExtra ( Settings . EXTRA_APP_PACKAGE , context . getPackageName ( ) ) ; context . startActivity ( intent ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } } </s>
<s> package icu . freedomIntrovert . async ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class BackstageTaskByMVP < T extends BackstageTaskByMVP . BaseEventHandler > implements Runnable { private final T uiHandler ; public BackstageTaskByMVP ( T uiHandler ) { this . uiHandler = uiHandler ; } protected abstract void onStart ( T eventHandlerProxy ) throws Throwable ; @ SuppressWarnings ( "<STR_LIT>" ) @ Override public void run ( ) { T proxyInstance = ( T ) Proxy . newProxyInstance ( uiHandler . getClass ( ) . getClassLoader ( ) , uiHandler . getClass ( ) . getInterfaces ( ) , new EvProxyHandler ( uiHandler ) ) ; try { onStart ( proxyInstance ) ; TaskManger . postOnUiThread ( uiHandler :: onComplete ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; TaskManger . postOnUiThread ( ( ) -> uiHandler . onError ( e ) ) ; } } public void execute ( ) { TaskManger . start ( this ) ; } public static class EvProxyHandler implements InvocationHandler { Object evHandler ; public EvProxyHandler ( Object evHandler ) { this . evHandler = evHandler ; } @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) == Object . class ) { return method . invoke ( proxy , args ) ; } TaskManger . postOnUiThread ( ( ) -> { try { method . invoke ( evHandler , args ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } ) ; return null ; } } public interface BaseEventHandler { default void onError ( Throwable th ) { throw new RuntimeException ( th ) ; } default void onComplete ( ) { } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHookByGlobal extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { Handler handler = new Handler ( ) ; AtomicReference < Context > currentContext = new AtomicReference < > ( ) ; AtomicReference < String > currentDynId = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( "<STR_LIT>" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( "<STR_LIT>" ) ; String dynamicId = fragment_args . getString ( "<STR_LIT>" ) ; if ( dynamicId == null ) { dynamicId = fragment_args . getString ( "<STR_LIT>" ) ; } XposedBridge . log ( "<STR_LIT>" + dynamicId ) ; currentDynId . set ( dynamicId ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( "<STR_LIT>" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; if ( arg == null ) { return ; } Object body = XposedHelpers . callMethod ( arg , "<STR_LIT>" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( "<STR_LIT>" ) ) { Object data = XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ; if ( data != null && "<STR_LIT>" . equals ( data . getClass ( ) . getCanonicalName ( ) ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , "<STR_LIT>" ) ; Object content = XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( "<STR_LIT>" , ( String ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( oid ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( type ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( content , "<STR_LIT>" ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( "<STR_LIT>" , Utils . getBvidFormAvid ( oid ) ) ; } long ctime = XposedHelpers . getLongField ( reply , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , ctime ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; try { Field picturesField = content . getClass ( ) . getField ( "<STR_LIT>" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( "<STR_LIT>" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( "<STR_LIT>" ) ; } XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . FutureTask ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . ServiceGenerator ; public class Utils { public static String picturesObjToString ( List < ? > obj ) { List < BiliComment . Picture > pictures = new ArrayList < > ( ) ; if ( obj == null || obj . size ( ) == <NUM_LIT> ) { return null ; } for ( Object o : obj ) { BiliComment . Picture picture = new BiliComment . Picture ( ) ; picture . img_src = ( String ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_width = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_height = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; picture . img_size = ( Double ) XposedHelpers . getObjectField ( o , "<STR_LIT>" ) ; pictures . add ( picture ) ; } return JSON . toJSONString ( pictures ) ; } public static String getBvidFormAvid ( long avid ) throws ExecutionException , InterruptedException { Callable < String > callable = ( ) -> { BiliApiService biliApiService = ServiceGenerator . getBiliApiService ( ) ; GeneralResponse < VideoInfo > body = biliApiService . getVideoInfoByAid ( avid ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; return body . data . bvid ; } ; FutureTask < String > task = new FutureTask < > ( callable ) ; task . run ( ) ; return task . get ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import java . lang . reflect . Field ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class ShowInvisibleCommentHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodReplacement ( ) { @ Override protected Object replaceHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object thisObject = methodHookParam . thisObject ; Field invisibleField = thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; invisibleField . setAccessible ( true ) ; boolean invisible = invisibleField . getBoolean ( thisObject ) ; Field locationField = thisObject . getClass ( ) . getDeclaredField ( "<STR_LIT>" ) ; locationField . setAccessible ( true ) ; String location = ( String ) locationField . get ( thisObject ) ; if ( invisible ) { return location + "<STR_LIT>" ; } else { return location ; } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import retrofit2 . Retrofit ; import retrofit2 . converter . fastjson . FastJsonConverterFactory ; public class ServiceGenerator { private static Retrofit retrofit ; private static BiliApiService biliApiService ; public static < T > T createService ( Class < T > cls ) { return ( T ) getRetrofit ( ) . create ( cls ) ; } public synchronized static Retrofit getRetrofit ( ) { if ( retrofit == null ) { retrofit = new Retrofit . Builder ( ) . baseUrl ( "<STR_LIT>" ) . addConverterFactory ( FastJsonConverterFactory . create ( ) ) . client ( OkHttpUtil . getHttpClient ( ) ) . build ( ) ; } return retrofit ; } public synchronized static BiliApiService getBiliApiService ( ) { if ( biliApiService == null ) { biliApiService = getRetrofit ( ) . create ( BiliApiService . class ) ; } return biliApiService ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . JSON ; public class SensitiveScanResult { public SensitiveScanResult ( int normalPosition , int unusualPosition ) { this . normalPosition = normalPosition ; this . unusualPosition = unusualPosition ; } public SensitiveScanResult ( ) { } public int normalPosition ; public int unusualPosition ; @ NonNull @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public abstract class OnExitListener { public void onNewCommentRpid ( long rpid ) { } public void onCommentStatusUpdated ( long rpid ) { } public void exit ( ) { } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . view ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class ProgressBarDialog implements DialogInterface { public static final int DEFAULT_MAX_PROGRESS = <NUM_LIT> ; public final AlertDialog alertDialog ; final ProgressBar progressBar ; ProgressBarDialog ( AlertDialog alertDialog , ProgressBar progressBar ) { this . alertDialog = alertDialog ; this . progressBar = progressBar ; } public void setProgress ( int progress ) { progressBar . setProgress ( progress ) ; } public void setMax ( int max ) { progressBar . setMax ( max ) ; } public void setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; } public void setMessage ( String message ) { alertDialog . setMessage ( message ) ; } public void setTitle ( String title ) { alertDialog . setTitle ( title ) ; } public Button getButton ( int whichButton ) { return alertDialog . getButton ( whichButton ) ; } @ Override public void cancel ( ) { alertDialog . cancel ( ) ; } @ Override public void dismiss ( ) { alertDialog . dismiss ( ) ; } public static class Builder { private final AlertDialog . Builder dialogBuilder ; private final ProgressBar progressBar ; public Builder ( Context context ) { dialogBuilder = new AlertDialog . Builder ( context ) ; View view = View . inflate ( context , R . layout . dialog_wait_progress , null ) ; progressBar = view . findViewById ( R . id . wait_progress_bar ) ; dialogBuilder . setView ( view ) ; progressBar . setMax ( DEFAULT_MAX_PROGRESS ) ; } public Builder setTitle ( String title ) { dialogBuilder . setTitle ( title ) ; return this ; } public Builder setMessage ( String message ) { dialogBuilder . setMessage ( message ) ; return this ; } public Builder setPositiveButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setPositiveButton ( text , listener ) ; return this ; } public Builder setNegativeButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNegativeButton ( text , listener ) ; return this ; } public Builder setNeutralButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNeutralButton ( text , listener ) ; return this ; } public Builder setCancelable ( boolean cancelable ) { dialogBuilder . setCancelable ( cancelable ) ; return this ; } public Builder setOnCancelListener ( DialogInterface . OnCancelListener listener ) { dialogBuilder . setOnCancelListener ( listener ) ; return this ; } public Builder setOnDismissListener ( DialogInterface . OnDismissListener listener ) { dialogBuilder . setOnDismissListener ( listener ) ; return this ; } public Builder setProgress ( int progress ) { progressBar . setProgress ( progress ) ; return this ; } public Builder setMax ( int max ) { progressBar . setMax ( max ) ; return this ; } public Builder setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; return this ; } public ProgressBarDialog show ( ) { return new ProgressBarDialog ( dialogBuilder . show ( ) , progressBar ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; public class InHookXConfig extends XConfig { public static final InHookXConfig config = new InHookXConfig ( new XSharedPreferences ( BuildConfig . APPLICATION_ID , PREF_NAME ) ) ; protected InHookXConfig ( XSharedPreferences sharedPreferences ) { super ( sharedPreferences ) ; XposedBridge . log ( sharedPreferences . getFile ( ) . toString ( ) ) ; } public static InHookXConfig getInstance ( ) { return config ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; public abstract class BaseHook { public abstract void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuPresenter ; public class DialogDanmakuCheckWorker { private Context context ; private Handler handler ; private DanmakuPresenter danmakuPresenter ; private OnExitListener exitListener ; public DialogDanmakuCheckWorker ( Context context , Handler handler , DanmakuPresenter danmakuPresenter , OnExitListener exitListener ) { this . context = context ; this . handler = handler ; this . danmakuPresenter = danmakuPresenter ; this . exitListener = exitListener ; } public void startCheckDanmaku ( long oid , long dmid , String content , String accessKey , long avid ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , "<STR_LIT>" , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; danmakuPresenter . checkDanmaku ( oid , dmid , content , accessKey , avid , new DanmakuPresenter . CheckDanmakuCallBack ( ) { @ Override public void onSleeping ( long waitTime ) { progressDialog . setMessage ( "<STR_LIT>" + waitTime + "<STR_LIT>" ) ; } @ Override public void onGettingHasAccountDMList ( ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } @ Override public void onGettingNoAccountDMList ( ) { progressDialog . setMessage ( "<STR_LIT>" ) ; } @ Override public void thenOk ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void thenDeleted ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void thenShadowBan ( ) { progressDialog . dismiss ( ) ; showCheckResult ( "<STR_LIT>" + CommentUtil . subComment ( content , <NUM_LIT> ) + "<STR_LIT>" ) ; } @ Override public void onNetworkError ( Throwable th ) { progressDialog . dismiss ( ) ; } } ) ; } private void showCheckResult ( String message ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( message ) . setCancelable ( false ) . setNegativeButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { exitListener . exit ( ) ; } } ) . show ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . SharedPreferences ; import android . util . Log ; import android . view . View ; import android . widget . EditText ; import android . widget . Toast ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Random ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentUtil { private CommentArea yourCommentArea ; private String sourceRandomComments ; private String [ ] randomComments ; private HashMap < CommentArea , LinkedList < String > > usedTestCommentMap ; SharedPreferences sp_config ; public CommentUtil ( Context context ) { sp_config = context . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; this . sourceRandomComments = sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; this . randomComments = sourceRandomComments . split ( "<STR_LIT>" ) ; usedTestCommentMap = new HashMap < > ( ) ; if ( sp_config . contains ( "<STR_LIT>" ) ) { this . yourCommentArea = new CommentArea ( Long . parseLong ( sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) , sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) , sp_config . getInt ( "<STR_LIT>" , <NUM_LIT> ) ) ; } } public String getSourceRandomComments ( ) { return sourceRandomComments ; } public String getAreaSourceText ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public CommentArea getYourCommentArea ( ) { return yourCommentArea ; } public boolean setYourCommentArea ( String sourceAreaText , CommentManipulator commentManipulator ) throws IOException { CommentArea commentArea = commentManipulator . matchCommentArea ( sourceAreaText ) ; if ( commentArea != null ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , String . valueOf ( commentArea . oid ) ) . putInt ( "<STR_LIT>" , commentArea . type ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . putString ( "<STR_LIT>" , sourceAreaText ) . apply ( ) ; yourCommentArea = commentArea ; return true ; } else { return false ; } } public void setYourCommentArea ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( getAreaSourceText ( ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , String . valueOf ( commentArea . oid ) ) . putInt ( "<STR_LIT>" , commentArea . type ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . putString ( "<STR_LIT>" , editText . getText ( ) . toString ( ) ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } } ) ; } } ) ; } public String getForwardDynamicId ( ) { return sp_config . getString ( "<STR_LIT>" , null ) ; } public void setDynamicIdToBeForward ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { if ( commentArea . type == CommentArea . AREA_TYPE_DYNAMIC17 || commentArea . type == CommentArea . AREA_TYPE_DYNAMIC11 ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , editText . getText ( ) . toString ( ) ) . putString ( "<STR_LIT>" , commentArea . sourceId ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } else { editText . setError ( "<STR_LIT>" ) ; } } } ) ; } } ) ; } public String getRandomComment ( CommentArea area ) { if ( usedTestCommentMap . get ( area ) == null ) { LinkedList < String > noUsedCommentList = new LinkedList < > ( Arrays . asList ( randomComments ) ) ; usedTestCommentMap . put ( area , noUsedCommentList ) ; } Random random = new Random ( ) ; LinkedList < String > noUsedCommentList = usedTestCommentMap . get ( area ) ; int randomNum = random . nextInt ( noUsedCommentList . size ( ) ) ; String randomComment = noUsedCommentList . get ( randomNum ) ; noUsedCommentList . remove ( randomNum ) ; Log . i ( "<STR_LIT>" , randomComment ) ; return randomComment ; } public void updateRandomComments ( String sourceRandomComments ) { this . sourceRandomComments = sourceRandomComments ; sp_config . edit ( ) . putString ( "<STR_LIT>" , sourceRandomComments ) . apply ( ) ; } public static String sourceIdToUrl ( CommentArea area ) { String url = null ; if ( area . type == CommentArea . AREA_TYPE_VIDEO ) { url = "<STR_LIT>" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_ARTICLE ) { url = "<STR_LIT>" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_DYNAMIC11 || area . type == CommentArea . AREA_TYPE_DYNAMIC17 ) { url = "<STR_LIT>" + area . sourceId ; } return url ; } public static String subComment ( String comment , int length ) { if ( comment . length ( ) > length ) { return comment . substring ( <NUM_LIT> , length - <NUM_LIT> ) + "<STR_LIT>" ; } else { return comment ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class PendingCheckCommentsActivity extends AppCompatActivity { RecyclerView recyclerView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_pending_check_comments ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } LinearLayoutManager layoutManager = new LinearLayoutManager ( this ) ; layoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView = findViewById ( R . id . recycler_view ) ; recyclerView . setLayoutManager ( layoutManager ) ; recyclerView . setAdapter ( new PendingCommentListAdapter ( this ) ) ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; break ; } return true ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import android . view . View ; import android . widget . EditText ; import com . alibaba . fastjson . JSONObject ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; public class AppealDialogPresenter { Context context ; Handler handler ; CommentManipulator commentManipulator ; public AppealDialogPresenter ( Context context , Handler handler , CommentManipulator commentManipulator ) { this . context = context ; this . handler = handler ; this . commentManipulator = commentManipulator ; } public void appeal ( String areaIdentifier , String comment , CallBack callBack ) { View dialogView = View . inflate ( context , R . layout . dialog_appeal_comment , null ) ; EditText edt_appeal_area_location = dialogView . findViewById ( R . id . edt_appeal_area_location ) ; EditText edt_reason = dialogView . findViewById ( R . id . edt_reason ) ; edt_appeal_area_location . setText ( areaIdentifier ) ; edt_reason . setText ( "<STR_LIT>" + CommentUtil . subComment ( comment , <NUM_LIT> ) ) ; AlertDialog editAppealInfoDialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; editAppealInfoDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( edt_appeal_area_location . getText ( ) . toString ( ) . equals ( "<STR_LIT>" ) ) { edt_appeal_area_location . setError ( "<STR_LIT>" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) < <NUM_LIT> ) { edt_reason . setError ( "<STR_LIT>" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) > <NUM_LIT> ) { edt_reason . setError ( "<STR_LIT>" ) ; } else { new Thread ( ( ) -> { try { JSONObject appealRespJson = commentManipulator . appealComment ( edt_appeal_area_location . getText ( ) . toString ( ) , edt_reason . getText ( ) . toString ( ) ) ; int code = appealRespJson . getInteger ( "<STR_LIT>" ) ; String respMsg ; if ( code == <NUM_LIT> ) { respMsg = appealRespJson . getJSONObject ( "<STR_LIT>" ) . getString ( "<STR_LIT>" ) ; } else { respMsg = appealRespJson . getString ( "<STR_LIT>" ) ; } handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ; callBack . onRespInUI ( code , respMsg ) ; } ) ; } catch ( IOException e ) { handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ; callBack . onNetErrInUI ( e . getMessage ( ) ) ; } ) ; } } ) . start ( ) ; } } } ) ; } public interface CallBack { public void onRespInUI ( int code , String toastText ) ; public void onNetErrInUI ( String msg ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; import java . util . List ; public class BiliComment { public long rpid ; public long oid ; public int type ; public long mid ; public long root ; public long parent ; public Content content ; public Member member ; public int rcount ; public List < BiliComment > replies ; public int like ; public boolean invisible ; public long ctime ; public static class Member { public long mid ; public String uname ; public String avatar ; public LevelInFo level_info ; } public static class LevelInFo { @ JSONField ( name = "<STR_LIT>" ) public int currentLevel ; } public static class Content { public String message ; public List < Picture > pictures ; public int max_line ; } public static class Picture { public String img_src ; public Double img_width ; public Double img_height ; public Double img_size ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class RemoveDynamicReqObject { public RemoveDynamicReqObject ( String dyn_id_str ) { this . dyn_id_str = dyn_id_str ; } public String dyn_id_str ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . Context ; import java . util . Arrays ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . IntentTransferStationHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHookByGlobal ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostPictureHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . ShowInvisibleCommentHook ; public class XposedInit implements IXposedHookLoadPackage { @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam loadPackageParam ) throws Throwable { if ( loadPackageParam . packageName . equals ( "<STR_LIT>" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( "<STR_LIT>" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHook ( ) ) ; hookStater . startHook ( new ShowInvisibleCommentHook ( ) ) ; hookStater . startHook ( new IntentTransferStationHook ( ) ) ; hookStater . startHook ( new PostPictureHook ( ) ) ; } else if ( loadPackageParam . packageName . equals ( "<STR_LIT>" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( "<STR_LIT>" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHookByGlobal ( ) ) ; } } public static Context systemContext ( ) { Object obj = null ; Class < ? > findClassIfExists = XposedHelpers . findClass ( "<STR_LIT>" , null ) ; if ( findClassIfExists != null ) { obj = XposedHelpers . callStaticMethod ( findClassIfExists , "<STR_LIT>" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } return ( Context ) XposedHelpers . callMethod ( obj , "<STR_LIT>" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async ; import androidx . annotation . NonNull ; import org . jetbrains . annotations . Nullable ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; public class BiliBiliApiException extends Exception { public final int code ; public final String message ; public final String tipsMessage ; public BiliBiliApiException ( int code , String message , @ Nullable String tipsMessage ) { this . code = code ; this . message = message ; this . tipsMessage = tipsMessage ; } public BiliBiliApiException ( GeneralResponse < ? > response , @ Nullable String tipsMessage ) { super ( String . format ( "<STR_LIT>" , tipsMessage , response . code , response . message ) ) ; this . code = response . code ; this . message = response . message ; this . tipsMessage = tipsMessage ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + code + "<STR_LIT>" + message + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class PendingCommentListAdapter extends RecyclerView . Adapter < PendingCommentListAdapter . ViewHolder > { private final Context context ; private final StatisticsDBOpenHelper helper ; private final List < Comment > comments ; private final DialogCommCheckWorker worker ; public PendingCommentListAdapter ( Context context ) { this . context = context ; helper = new StatisticsDBOpenHelper ( context ) ; comments = helper . getAllPendingCheckComments ( ) ; Config config = new Config ( context ) ; worker = new DialogCommCheckWorker ( context , config , helper , new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) , new CommentUtil ( context ) ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . item_pending_check_comment , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { Comment comment = comments . get ( position ) ; holder . txv_comment . setText ( comment . comment ) ; holder . txv_info . setText ( comment . commentArea . sourceId ) ; holder . txv_date . setText ( comment . getFormatDateFor_yMdHms ( ) ) ; holder . itemView . setOnClickListener ( view -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( comment . comment ) . setPositiveButton ( android . R . string . ok , ( dialogInterface , i ) -> { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void onNewCommentRpid ( long rpid ) { comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } } ) ; worker . checkComment ( comment , progressBarDialog ) ; } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialogInterface , i ) -> { helper . deletePendingCheckComment ( comment . rpid ) ; comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } ) . show ( ) ; } ) ; } @ Override public int getItemCount ( ) { return comments . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { TextView txv_comment , txv_info , txv_date ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; txv_comment = itemView . findViewById ( R . id . txv_comment_content ) ; txv_info = itemView . findViewById ( R . id . txv_info ) ; txv_date = itemView . findViewById ( R . id . txv_date ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async ; public class CookieFailedException extends Exception { } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class IntentTransferStationHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; positioningActivity ( activity , activity . getIntent ( ) , classLoader ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; positioningActivity ( ( Activity ) param . thisObject , ( Intent ) param . args [ <NUM_LIT> ] , classLoader ) ; } } ) ; } private void positioningActivity ( Activity activity , Intent intent , ClassLoader classLoader ) throws ClassNotFoundException { Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { return ; } String transferActivity = extras . getString ( "<STR_LIT>" ) ; if ( transferActivity == null ) { return ; } Bundle transferExtras = extras . getBundle ( "<STR_LIT>" ) ; Intent newIntent = new Intent ( activity , classLoader . loadClass ( transferActivity ) ) ; String transferUri = extras . getString ( "<STR_LIT>" , null ) ; if ( transferUri != null ) { newIntent . setData ( Uri . parse ( transferUri ) ) ; } if ( transferExtras != null ) { newIntent . putExtras ( transferExtras ) ; } activity . startActivity ( newIntent ) ; } } </s>
<s> package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; public abstract class EventHandler extends Handler { public EventHandler ( ) { super ( ) ; } public EventHandler ( @ NonNull Looper looper ) { super ( looper ) ; } public void sendEventMessage ( EventMessage message ) { post ( ( ) -> handleEvent ( message ) ) ; } public void sendEventMessage ( int what , Object ... objects ) { post ( ( ) -> handleEvent ( new EventMessage ( what , objects ) ) ) ; } public void sendEmptyEventMessage ( int what ) { post ( ( ) -> handleEvent ( new EventMessage ( what ) ) ) ; } public void sendError ( Throwable th ) { post ( ( ) -> handleError ( th ) ) ; } protected abstract void handleEvent ( EventMessage message ) ; protected abstract void handleError ( Throwable th ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Context ; import android . net . Uri ; import androidx . activity . result . ActivityResultCallback ; import java . io . IOException ; import java . io . OutputStream ; import icu . freedomIntrovert . async . TaskManger ; public abstract class ActivityResultCallbackForSaveDoc < T extends ActivityResult > implements ActivityResultCallback < T > { public ActivityResultCallbackForSaveDoc ( Context context ) { this . context = context ; } Context context ; @ Override public void onActivityResult ( T result ) { if ( result . intent == null ) { onVoidResult ( ) ; return ; } Uri data = result . intent . getData ( ) ; if ( data == null ) { onVoidResult ( ) ; return ; } onHasResult ( ) ; TaskManger . start ( ( ) -> { try { OutputStream outputStream = context . getContentResolver ( ) . openOutputStream ( data ) ; if ( outputStream != null ) { onOpenOutputStream ( outputStream , result ) ; } else { onNullOutputStream ( ) ; } } catch ( IOException e ) { onIOException ( e ) ; } } ) ; } protected void onHasResult ( ) { } ; protected abstract void onOpenOutputStream ( OutputStream outputStream , T result ) throws IOException ; protected abstract void onNullOutputStream ( ) ; protected void onVoidResult ( ) { } ; protected abstract void onIOException ( Exception e ) ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import static android . view . KeyEvent . KEYCODE_BACK ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Bundle ; import android . util . Log ; import android . view . KeyEvent ; import android . view . MenuItem ; import android . webkit . CookieManager ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . ProgressBar ; import androidx . appcompat . app . AppCompatActivity ; public class WebViewLoginActivity extends AppCompatActivity { WebView webView ; public Context context ; Config config ; ProgressBar progressBar ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_web_view_login ) ; progressBar = findViewById ( R . id . progressBar ) ; context = this ; config = new Config ( context ) ; webView = findViewById ( R . id . web_view ) ; webView . loadUrl ( "<STR_LIT>" ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } @ Override public void onPageFinished ( WebView view , String url ) { CookieManager cookieManager = CookieManager . getInstance ( ) ; String cookieStr = cookieManager . getCookie ( url ) ; if ( cookieStr != null ) { Log . i ( "<STR_LIT>" , "<STR_LIT>" + cookieStr ) ; if ( cookieStr . contains ( "<STR_LIT>" ) ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( cookieStr ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { onCookieSet ( cookieStr ) ; finish ( ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { cookieManager . removeAllCookies ( value -> { } ) ; finish ( ) ; } ) . show ( ) ; } } super . onPageFinished ( view , url ) ; } } ) ; webView . setWebChromeClient ( new WebChromeClient ( ) { @ Override public void onProgressChanged ( WebView view , int newProgress ) { super . onProgressChanged ( view , newProgress ) ; progressBar . setProgress ( newProgress ) ; if ( newProgress == <NUM_LIT> ) { progressBar . setProgress ( <NUM_LIT> ) ; } } } ) ; } protected void onCookieSet ( String cookie ) { config . setCookie ( cookie ) ; } public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( ( keyCode == KEYCODE_BACK ) && webView . canGoBack ( ) ) { if ( webView . canGoBack ( ) ) { webView . goBack ( ) ; return true ; } else { finish ( ) ; return true ; } } return super . onKeyDown ( keyCode , event ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } return true ; } @ Override protected void onDestroy ( ) { if ( webView != null ) { webView . clearHistory ( ) ; webView . destroy ( ) ; webView = null ; } super . onDestroy ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class BannedOnlyInThisAreaCheckTask extends CommentOperateTask < BannedOnlyInThisAreaCheckTask . EventHandler > { CommentArea yourCommentArea ; public BannedOnlyInThisAreaCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentArea yourCommentArea ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . yourCommentArea = yourCommentArea ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_COMMENT_SENT_TO_YOUR_AREA , yourCommentArea . sourceId ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( comment . comment , <NUM_LIT> , <NUM_LIT> , yourCommentArea , false ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( yourCommentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( comment . commentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_ONLY_BANNED_IN_THIS_AREA ) ; } else { commentManipulator . deleteComment ( yourCommentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_BANNED_IN_YOUR_AREA ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_COMMENT_SENT_TO_YOUR_AREA = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_ONLY_BANNED_IN_THIS_AREA = <NUM_LIT> ; public static final int WHAT_THEN_BANNED_IN_YOUR_AREA = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import okhttp3 . OkHttpClient ; import okhttp3 . ResponseBody ; import retrofit2 . Response ; public class OkHttpUtil { private static OkHttpClient okHttpClient ; public static synchronized OkHttpClient getHttpClient ( ) { if ( okHttpClient == null ) { okHttpClient = new OkHttpClient . Builder ( ) . addInterceptor ( new LoggerInterceptor ( ) ) . build ( ) ; } return okHttpClient ; } public static void respNotNull ( GeneralResponse < ? > generalResponse ) throws IOException { if ( generalResponse == null ) { throw new IOException ( "<STR_LIT>" ) ; } } public static void respNotNull ( ResponseBody resp ) throws IOException { if ( resp == null ) { throw new IOException ( "<STR_LIT>" ) ; } } public static < T > GeneralResponse < T > getBody ( Response < GeneralResponse < T > > response ) throws IOException { if ( response . isSuccessful ( ) ) { return response . body ( ) ; } else { throw new IOException ( "<STR_LIT>" + response . code ( ) ) ; } } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . util . Base64 ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . opencsv . CSVReader ; import com . opencsv . CSVWriter ; import com . opencsv . exceptions . CsvValidationException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; public class MartialLawCommentAreaListActivity extends AppCompatActivity { private static final int REQUEST_CODE_EXPORT = <NUM_LIT> ; private static final int REQUEST_CODE_IMPORT = <NUM_LIT> ; RecyclerView recyclerView ; StatisticsDBOpenHelper dbOpenHelper ; Context context ; ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList ; MartialLawCommentAreaListAdapter adapter ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_martial_law_comment_area_list ) ; ByXposedLaunchedActivity . lastActivity = this ; context = this ; dbOpenHelper = new StatisticsDBOpenHelper ( context ) ; martialLawCommentAreaArrayList = dbOpenHelper . queryMartialLawCommentAreas ( ) ; recyclerView = findViewById ( R . id . rv_martial_law_comment_area ) ; adapter = new MartialLawCommentAreaListAdapter ( martialLawCommentAreaArrayList , context ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( RecyclerView . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { case REQUEST_CODE_EXPORT : ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( data != null ) { try ( OutputStream outputStream = getContentResolver ( ) . openOutputStream ( data . getData ( ) ) ; CSVWriter csvWriter = new CSVWriter ( new OutputStreamWriter ( outputStream ) ) ) { List < String [ ] > csvData = new ArrayList < > ( ) ; String [ ] csvHeader = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; csvData . add ( csvHeader ) ; Collections . reverse ( martialLawCommentAreaArrayList ) ; for ( MartialLawCommentArea area : martialLawCommentAreaArrayList ) { byte [ ] imageData = dbOpenHelper . selectMartialLawCommentAreaCoverImage ( area . oid ) ; String [ ] csvRow = area . toStringArrays ( ) ; if ( imageData != null ) { csvRow [ <NUM_LIT> ] = Base64 . encodeToString ( imageData , Base64 . DEFAULT ) ; } csvData . add ( csvRow ) ; } Collections . reverse ( martialLawCommentAreaArrayList ) ; csvWriter . writeAll ( csvData ) ; runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; error ( "<STR_LIT>" + e . getMessage ( ) ) ; } } else { error ( "<STR_LIT>" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) . start ( ) ; break ; case REQUEST_CODE_IMPORT : ProgressDialog progressDialog1 = new ProgressDialog ( context ) ; progressDialog1 . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog1 . setMessage ( "<STR_LIT>" ) ; progressDialog1 . setCancelable ( false ) ; progressDialog1 . show ( ) ; Executor executor = Executors . newSingleThreadExecutor ( ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { List < MartialLawCommentArea > martialLawCommentAreas = new ArrayList < > ( ) ; if ( data != null ) { try ( InputStreamReader inputStreamReader = new InputStreamReader ( context . getContentResolver ( ) . openInputStream ( data . getData ( ) ) ) ; CSVReader csvReader = new CSVReader ( inputStreamReader ) ; ) { String [ ] fileds = new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String [ ] csvLine ; int successCount = <NUM_LIT> ; int failCount = <NUM_LIT> ; if ( ( csvLine = csvReader . readNext ( ) ) != null ) { if ( Arrays . equals ( fileds , csvLine ) ) { while ( ( csvLine = csvReader . readNext ( ) ) != null ) { byte [ ] coverImageData = Base64 . decode ( csvLine [ <NUM_LIT> ] , Base64 . DEFAULT ) ; MartialLawCommentArea martialLawCommentArea = new MartialLawCommentArea ( csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , Integer . parseInt ( csvLine [ <NUM_LIT> ] ) , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , coverImageData ) ; System . out . println ( martialLawCommentArea ) ; if ( dbOpenHelper . insertMartialLawCommentArea ( martialLawCommentArea ) > <NUM_LIT> ) { martialLawCommentAreas . add ( martialLawCommentArea ) ; successCount ++ ; } else { failCount ++ ; } } int finalSuccessCount = successCount ; int finalFailCount = failCount ; runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; adapter . addData ( martialLawCommentAreas ) ; Toast . makeText ( context , "<STR_LIT>" + finalSuccessCount + "<STR_LIT>" + finalFailCount + "<STR_LIT>" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } else { error ( "<STR_LIT>" ) ; } } else { error ( "<STR_LIT>" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } catch ( CsvValidationException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } } else { error ( "<STR_LIT>" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_export_and_input , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } else if ( item . getItemId ( ) == R . id . item_export ) { Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . CHINA ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; startActivityForResult ( intent , REQUEST_CODE_EXPORT ) ; } else if ( item . getItemId ( ) == R . id . item_import ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; startActivityForResult ( intent , REQUEST_CODE_IMPORT ) ; } return true ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . inputmethod . EditorInfo ; import android . widget . Button ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . Spinner ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . ActionBarDrawerToggle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . SwitchCompat ; import androidx . appcompat . widget . Toolbar ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . drawerlayout . widget . DrawerLayout ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class MainActivity extends AppCompatActivity { private static final int RESULT_CODE_SAVE_LOG_ZIP = <NUM_LIT> ; EditText edt_bvid , edt_comment ; Button btn_send , btn_clean , btn_send_and_appeal , btn_test ; CommentManipulator commentManipulator ; DrawerLayout drawerLayout ; SwitchCompat sw_recorde_history ; SwitchCompat sw_hook_picture_select ; ConstraintLayout cl_recorde_history_comment_sw ; LinearLayout ll_pending_check_comments , ll_martial_law_comment_area_list , ll_history_comment , ll_wait_time , ll_github_project ; Toolbar toolbar ; private Context context ; StatisticsDBOpenHelper statisticsDBOpenHelper ; boolean enableRecordeHistoryComment ; LinearLayout ll_test_comment_pool ; LinearLayout ll_you_comment_area ; LinearLayout ll_export_logs ; LinearLayout ll_targeting ; CommentUtil commentUtil ; Handler handler ; DialogCommCheckWorker dialogCommSendWorker ; Config config ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; ByXposedLaunchedActivity . lastActivity = this ; context = this ; config = new Config ( context ) ; commentUtil = new CommentUtil ( context ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; handler = new Handler ( ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; dialogCommSendWorker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , commentUtil ) ; initView ( ) ; initRecordeHistoryCommentSW ( ) ; initTestCommentPoolItem ( ) ; initWaitTimeItem ( ) ; initHomePageCommentCheck ( ) ; initToNewActivityItem ( ) ; initExportLogs ( ) ; initTargetingComment ( ) ; ll_you_comment_area . setOnClickListener ( v -> { commentUtil . setYourCommentArea ( context , commentManipulator ) ; } ) ; findViewById ( R . id . ll_forward_dynamic ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentUtil . setDynamicIdToBeForward ( context , commentManipulator ) ; } } ) ; } private void initTargetingComment ( ) { ll_targeting . setOnClickListener ( v -> { View dialogView = View . inflate ( context , R . layout . dialog_targeting_comment , null ) ; Spinner spinner = dialogView . findViewById ( R . id . spinner_area_type ) ; EditText oid = dialogView . findViewById ( R . id . edit_oid ) ; EditText rpid = dialogView . findViewById ( R . id . edit_rpid ) ; EditText root = dialogView . findViewById ( R . id . edit_root ) ; EditText sourceId = dialogView . findViewById ( R . id . edit_source_id ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { int type = CommentArea . AREA_TYPE_VIDEO ; switch ( spinner . getSelectedItemPosition ( ) ) { case <NUM_LIT> : type = CommentArea . AREA_TYPE_ARTICLE ; break ; case <NUM_LIT> : type = CommentArea . AREA_TYPE_DYNAMIC11 ; break ; case <NUM_LIT> : type = CommentArea . AREA_TYPE_DYNAMIC17 ; break ; default : break ; } CommentLocator . lunch ( context , type , Long . parseLong ( oid . getText ( ) . toString ( ) ) , Long . parseLong ( rpid . getText ( ) . toString ( ) ) , TextUtils . isEmpty ( root . getText ( ) . toString ( ) ) ? <NUM_LIT> : Long . parseLong ( root . getText ( ) . toString ( ) ) , TextUtils . isEmpty ( sourceId . getText ( ) . toString ( ) ) ? oid . getText ( ) . toString ( ) : sourceId . getText ( ) . toString ( ) ) ; } ) . setNegativeButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( data != null && data . getData ( ) != null ) { switch ( requestCode ) { case RESULT_CODE_SAVE_LOG_ZIP : ProgressBarDialog dialog = new ProgressBarDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . show ( ) ; new Thread ( ( ) -> { try { File sourceFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; OutputStream outputStream = getContentResolver ( ) . openOutputStream ( data . getData ( ) ) ; ZipOutputStream zos = new ZipOutputStream ( outputStream ) ; zipDirectory ( sourceFolder , sourceFolder , zos ) ; zos . close ( ) ; outputStream . close ( ) ; runOnUiThread ( ( ) -> { dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } ) ; } catch ( IOException e ) { runOnUiThread ( ( ) -> { dialog . dismiss ( ) ; Toast . makeText ( context , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } ) ; } } ) . start ( ) ; break ; default : throw new RuntimeException ( ) ; } } } private static void zipDirectory ( File rootPath , File sourceFolder , ZipOutputStream zos ) throws IOException { for ( File file : sourceFolder . listFiles ( ) ) { if ( file . isDirectory ( ) ) { zipDirectory ( rootPath , file , zos ) ; } else { addToZip ( rootPath , file , zos ) ; } } } private static void addToZip ( File rootPath , File file , ZipOutputStream zos ) throws IOException { FileInputStream fis = new FileInputStream ( file ) ; String zipFilePath = file . getAbsolutePath ( ) . substring ( rootPath . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; ZipEntry zipEntry = new ZipEntry ( zipFilePath ) ; zos . putNextEntry ( zipEntry ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; int length ; while ( ( length = fis . read ( bytes ) ) >= <NUM_LIT> ) { zos . write ( bytes , <NUM_LIT> , length ) ; } zos . closeEntry ( ) ; fis . close ( ) ; } private static long calculateFolderSize ( File folder ) { long size = <NUM_LIT> ; if ( folder . isDirectory ( ) ) { File [ ] files = folder . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { if ( file . isFile ( ) ) { size += file . length ( ) ; } else { size += calculateFolderSize ( file ) ; } } } } else if ( folder . isFile ( ) ) { size += folder . length ( ) ; } return size ; } private static boolean deleteFolder ( File folder ) { if ( folder . isDirectory ( ) ) { File [ ] files = folder . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { deleteFolder ( file ) ; } } } return folder . delete ( ) ; } private void initExportLogs ( ) { ll_export_logs . setOnClickListener ( v -> { File sourceFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; if ( ! sourceFolder . exists ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( "<STR_LIT>" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" , Locale . CHINA ) ; intent . putExtra ( Intent . EXTRA_TITLE , "<STR_LIT>" + sdf . format ( new Date ( ) ) + "<STR_LIT>" ) ; startActivityForResult ( intent , RESULT_CODE_SAVE_LOG_ZIP ) ; } ) ; ll_export_logs . setOnLongClickListener ( v -> { File logsFolder = new File ( getFilesDir ( ) , "<STR_LIT>" ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setMessage ( String . format ( Locale . getDefault ( ) , "<STR_LIT>" , ( double ) calculateFolderSize ( logsFolder ) / ( <NUM_LIT> * <NUM_LIT> ) ) ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { deleteFolder ( logsFolder ) ; Toast . makeText ( MainActivity . this , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return false ; } ) ; } private void initView ( ) { drawerLayout = findViewById ( R . id . drawerLayout ) ; toolbar = findViewById ( R . id . toolbar ) ; edt_bvid = findViewById ( R . id . edt_bvid ) ; edt_comment = findViewById ( R . id . edt_comment ) ; btn_send = findViewById ( R . id . btn_send ) ; btn_clean = findViewById ( R . id . btn_clean ) ; ll_pending_check_comments = findViewById ( R . id . ll_pending_check_comment_list ) ; ll_martial_law_comment_area_list = findViewById ( R . id . ll_martial_law_comment_area_list ) ; ll_history_comment = findViewById ( R . id . ll_history_comment ) ; ll_test_comment_pool = findViewById ( R . id . ll_test_comment_pool ) ; ll_you_comment_area = findViewById ( R . id . ll_your_comment_area ) ; ll_wait_time = findViewById ( R . id . ll_wait_time ) ; ll_export_logs = findViewById ( R . id . ll_export_logs ) ; cl_recorde_history_comment_sw = findViewById ( R . id . cl_recorde_history_comment_sw ) ; ll_targeting = findViewById ( R . id . ll_targeting ) ; ll_github_project = findViewById ( R . id . ll_github_project ) ; sw_recorde_history = findViewById ( R . id . sw_recorde_history ) ; btn_send_and_appeal = findViewById ( R . id . btn_send_and_appeal ) ; setSupportActionBar ( toolbar ) ; ActionBarDrawerToggle toggle = new ActionBarDrawerToggle ( this , drawerLayout , toolbar , R . string . drawer_open , R . string . drawer_close ) ; drawerLayout . addDrawerListener ( toggle ) ; toggle . syncState ( ) ; } private void initRecordeHistoryCommentSW ( ) { enableRecordeHistoryComment = config . getRecordeHistory ( ) ; sw_recorde_history . setChecked ( enableRecordeHistoryComment ) ; cl_recorde_history_comment_sw . setOnClickListener ( v -> { sw_recorde_history . setChecked ( ! enableRecordeHistoryComment ) ; } ) ; sw_recorde_history . setOnCheckedChangeListener ( ( buttonView , isChecked ) -> { if ( isChecked ) { enableRecordeHistoryComment = true ; config . setRecordeHistory ( true ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { enableRecordeHistoryComment = false ; config . setRecordeHistory ( false ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } private void initToNewActivityItem ( ) { ll_pending_check_comments . setOnClickListener ( v -> { startActivity ( new Intent ( MainActivity . this , PendingCheckCommentsActivity . class ) ) ; } ) ; ll_martial_law_comment_area_list . setOnClickListener ( v -> { startActivity ( new Intent ( context , MartialLawCommentAreaListActivity . class ) ) ; } ) ; ll_history_comment . setOnClickListener ( v -> { startActivity ( new Intent ( context , HistoryCommentActivity . class ) ) ; } ) ; ll_github_project . setOnClickListener ( v -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) ; } private void initTestCommentPoolItem ( ) { ll_test_comment_pool . setOnClickListener ( v -> { View edtView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( commentUtil . getSourceRandomComments ( ) ) ; AlertDialog setRandomDialog = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , null ) . setNeutralButton ( "<STR_LIT>" , null ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; setRandomDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( v1 -> { if ( editText . getText ( ) . toString ( ) . split ( "<STR_LIT>" ) . length > <NUM_LIT> ) { commentUtil . updateRandomComments ( editText . getText ( ) . toString ( ) ) ; setRandomDialog . dismiss ( ) ; } else { editText . setError ( "<STR_LIT>" ) ; } } ) ; setRandomDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) . setOnClickListener ( v12 -> { new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } ) ; } private void initWaitTimeItem ( ) { ll_wait_time . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { View dialogView = View . inflate ( context , R . layout . dialog_set_wait_time , null ) ; EditText editTextWTByCommentSent = dialogView . findViewById ( R . id . edit_text_wt_by_after_comment_sent ) ; EditText editTextWTByHasPictures = dialogView . findViewById ( R . id . edit_text_wt_by_has_pictures ) ; EditText editTextWTByDanmakuSent = dialogView . findViewById ( R . id . edit_text_wt_danmaku_sent ) ; editTextWTByCommentSent . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByCommentSent . setText ( String . valueOf ( config . getWaitTime ( ) ) ) ; editTextWTByHasPictures . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByHasPictures . setText ( String . valueOf ( config . getWaitTimeByHasPictures ( ) ) ) ; editTextWTByDanmakuSent . setInputType ( EditorInfo . TYPE_CLASS_NUMBER ) ; editTextWTByDanmakuSent . setText ( String . valueOf ( config . getWaitTimeByDanmakuSend ( ) ) ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( dialogView ) . setPositiveButton ( "<STR_LIT>" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { long waitTime = Long . parseLong ( editTextWTByCommentSent . getText ( ) . toString ( ) ) ; long waitTimeByHasPictures = Long . parseLong ( editTextWTByHasPictures . getText ( ) . toString ( ) ) ; long waitTimeByDanmakuSent = Long . parseLong ( editTextWTByDanmakuSent . getText ( ) . toString ( ) ) ; config . setWaitTime ( waitTime ) ; config . setWaitTimeByHasPictures ( waitTimeByHasPictures ) ; config . setWaitTimeByDanmakuSend ( waitTimeByDanmakuSent ) ; toastLong ( "<STR_LIT>" ) ; } } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } } ) ; } private void initHomePageCommentCheck ( ) { btn_send . setOnClickListener ( v -> { ProgressBarDialog dialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; commentManipulator . matchCommentAreaInUi ( edt_bvid . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { dialog . dismiss ( ) ; toastNetErr ( e . getMessage ( ) ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { dialog . setMessage ( "<STR_LIT>" ) ; String comment = edt_comment . getText ( ) . toString ( ) ; commentManipulator . getSendCommentCall ( comment , <NUM_LIT> , <NUM_LIT> , commentArea , false ) . enqueue ( new BiliApiCallback < GeneralResponse < CommentAddResult > > ( ) { @ Override public void onError ( Throwable th ) { dialog . dismiss ( ) ; toastNetErr ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < CommentAddResult > response ) { if ( commentSendSuccess ( response , commentArea , comment , dialog ) ) { dialog . setIndeterminate ( false ) ; new Thread ( ( ) -> { long waitTime = config . getWaitTime ( ) ; new ProgressTimer ( waitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , new ProgressTimer . ProgressLister ( ) { @ Override public void onNewProgress ( int progress , long sleepSeg ) { runOnUiThread ( ( ) -> { dialog . setMessage ( "<STR_LIT>" + progress * sleepSeg + "<STR_LIT>" + waitTime + "<STR_LIT>" ) ; dialog . setProgress ( progress ) ; } ) ; } } ) . start ( ) ; runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { dialogCommSendWorker . checkComment ( new Comment ( commentArea , response . data . rpid , <NUM_LIT> , <NUM_LIT> , comment , null , new Date ( response . data . reply . ctime * <NUM_LIT> ) ) , dialog ) ; } } ) ; } ) . start ( ) ; } } } ) ; } else { Toast . makeText ( context , R . string . bv_cv_url_typo , Toast . LENGTH_SHORT ) . show ( ) ; dialog . dismiss ( ) ; } } } ) ; } ) ; btn_send_and_appeal . setOnClickListener ( v -> { if ( commentManipulator . cookieAreSet ( ) ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , null , "<STR_LIT>" ) ; progressDialog . show ( ) ; String comment = edt_comment . getText ( ) . toString ( ) ; commentManipulator . matchCommentAreaInUi ( edt_bvid . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { progressDialog . dismiss ( ) ; toastShort ( e . getMessage ( ) ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { progressDialog . setMessage ( "<STR_LIT>" ) ; AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , handler , commentManipulator ) ; commentManipulator . getSendCommentCall ( comment , <NUM_LIT> , <NUM_LIT> , commentArea , false ) . enqueue ( new BiliApiCallback < GeneralResponse < CommentAddResult > > ( ) { @ Override public void onError ( Throwable th ) { progressDialog . dismiss ( ) ; toastLong ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < CommentAddResult > response ) { progressDialog . dismiss ( ) ; toastLong ( "<STR_LIT>" ) ; if ( commentSendSuccess ( response , commentArea , comment , progressDialog ) ) { appealDialogPresenter . appeal ( edt_bvid . getText ( ) . toString ( ) , comment , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , response . data . rpid , <NUM_LIT> , <NUM_LIT> , comment , HistoryComment . STATE_UNKNOWN , new Date ( response . data . reply . ctime ) ) ) ; if ( code == <NUM_LIT> ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNKNOWN ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } else if ( code == <NUM_LIT> ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_NORMAL ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNKNOWN ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; return ; } if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDBOpenHelper . insertHistoryComment ( historyComment ) ; } } @ Override public void onNetErrInUI ( String msg ) { toastNetErr ( msg ) ; } } ) ; } } } ) ; } else { progressDialog . dismiss ( ) ; toastShort ( R . string . bv_cv_url_typo ) ; } } } ) ; } else { toastShort ( "<STR_LIT>" ) ; } } ) ; btn_clean . setOnClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { edt_bvid . setText ( "<STR_LIT>" ) ; edt_comment . setText ( "<STR_LIT>" ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } ) ; } private boolean commentSendSuccess ( GeneralResponse < CommentAddResult > response , CommentArea commentArea , String comment , DialogInterface dialog ) { if ( response . isSuccess ( ) ) { if ( response . data . success_action == <NUM_LIT> ) { return true ; } else { dialog . dismiss ( ) ; new AlertDialog . Builder ( context ) . setMessage ( response . data . success_toast ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNegativeButton ( "<STR_LIT>" , ( dialog1 , which ) -> { commentManipulator . createDeleteCommentCall ( commentArea , response . data . rpid ) . enqueue ( new BiliApiCallback < GeneralResponse < Object > > ( ) { @ Override public void onError ( Throwable th ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onSuccess ( GeneralResponse < Object > unused ) { if ( unused . isSuccess ( ) ) { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; } ) . show ( ) ; } } else if ( response . code == CommentAddResult . CODE_CONTAIN_SENSITIVE ) { if ( config . getRecordeHistoryIsEnable ( ) ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , - System . currentTimeMillis ( ) , <NUM_LIT> , <NUM_LIT> , comment , null , new Date ( ) ) ) ; historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SENSITIVE ) ; statisticsDBOpenHelper . insertHistoryComment ( historyComment ) ; } dialog . dismiss ( ) ; toastLong ( response . message ) ; } else { dialog . dismiss ( ) ; toastLong ( response . message ) ; } return false ; } private void toastShort ( String text ) { Toast . makeText ( context , text , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastShort ( int text ) { Toast . makeText ( context , text , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastLong ( String text ) { Toast . makeText ( context , text , Toast . LENGTH_LONG ) . show ( ) ; } private void toastNetErr ( String e ) { toastShort ( "<STR_LIT>" + e ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_cookie , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == R . id . main_account_cookie ) { View edtView = View . inflate ( MainActivity . this , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( config . getCookie ( ) ) ; new AlertDialog . Builder ( MainActivity . this ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { String cookie = editText . getText ( ) . toString ( ) ; config . setCookie ( cookie ) ; commentManipulator . setCookie ( cookie ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { startActivity ( new Intent ( context , WebViewLoginActivity . class ) ) ; } ) . show ( ) ; } else if ( item . getItemId ( ) == R . id . deputy_account_cookie ) { View edtView = View . inflate ( MainActivity . this , R . layout . edit_text , null ) ; EditText editText = edtView . findViewById ( R . id . edit_text ) ; editText . setText ( config . getDeputyCookie ( ) ) ; new AlertDialog . Builder ( MainActivity . this ) . setTitle ( "<STR_LIT>" ) . setView ( edtView ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { String cookie = editText . getText ( ) . toString ( ) ; config . setDeputyCookie ( cookie ) ; } ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog , which ) -> { startActivity ( new Intent ( context , WebViewLoginByDeputyActivity . class ) ) ; } ) . show ( ) ; } return true ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; import java . io . File ; public class ActivityResultForFile extends ActivityResult { public ActivityResultForFile ( Intent intent , File file ) { super ( intent ) ; this . file = file ; } public File file ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; public class WebViewLoginByDeputyActivity extends WebViewLoginActivity { @ Override protected void onCookieSet ( String cookie ) { config . setDeputyCookie ( cookie ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . graphics . Paint ; import android . net . Uri ; import android . os . Handler ; import android . text . Spannable ; import android . text . SpannableStringBuilder ; import android . text . style . ForegroundColorSpan ; import android . util . TypedValue ; import android . view . LayoutInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageView ; import android . widget . PopupMenu ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . ResendCommentTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . ReviewCommentStatusTask ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class HistoryCommentAdapter extends RecyclerView . Adapter < HistoryCommentAdapter . ViewHolder > implements BiliBiliApiRequestHandler . DialogErrorHandle . OnDialogMessageListener { HistoryCommentActivity context ; StatisticsDBOpenHelper statisticsDBOpenHelper ; List < HistoryComment > historyCommentList ; CommentManipulator commentManipulator ; DialogCommCheckWorker dialogCommCheckWorker ; Config config ; boolean  ; public HistoryCommentAdapter ( HistoryCommentActivity context , CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDBOpenHelper ) { this . context = context ; config = new Config ( context ) ; this . statisticsDBOpenHelper = statisticsDBOpenHelper ; Config config = new Config ( context ) ; this . commentManipulator = commentManipulator ; this . dialogCommCheckWorker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , new CommentUtil ( context ) ) ;  = config . getEnable ( ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View itemView = LayoutInflater . from ( context ) . inflate ( R . layout . item_history_comment , parent , false ) ; return new ViewHolder ( itemView ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { HistoryComment historyComment = historyCommentList . get ( position ) ; holder . txv_comment . setText ( historyComment . comment ) ; if ( historyComment . hasPictures ( ) ) { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long_pic ) ) ; } else if ( historyComment . root != <NUM_LIT> ) { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long_reply ) ) ; } else { holder . imgv_cover_image . setImageDrawable ( context . getDrawable ( R . drawable . comment_long ) ) ; } switch ( historyComment . checkedArea ) { case HistoryComment . CHECKED_NO_CHECK : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . GRAY ) ) ; break ; case HistoryComment . CHECKED_NOT_MARTIAL_LAW : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . blue ) ) ; break ; case HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . yellow ) ) ; break ; case HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . green ) ) ; break ; case HistoryComment . CHECKED_MARTIAL_LAW : holder . txv_info . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; break ; } switch ( historyComment . lastState ) { case HistoryComment . STATE_NORMAL : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . normal ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SHADOW_BAN : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; if ( historyComment . firstState != null && historyComment . firstState . equals ( HistoryComment . STATE_NORMAL ) ) { holder . txv_banned_type . setText ( "<STR_LIT>" ) ; } else { holder . txv_banned_type . setText ( "<STR_LIT>" ) ; } break ; case HistoryComment . STATE_UNDER_REVIEW : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . i ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_DELETED : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SENSITIVE : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . sensitive ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_INVISIBLE : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . ghost ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_UNKNOWN : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . unknown ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : holder . imgv_banned_type . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_access_time_24 ) ) ; holder . txv_banned_type . setText ( "<STR_LIT>" ) ; break ; } if (  ) { switch ( historyComment . lastState ) { case HistoryComment . STATE_DELETED : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . STRIKE_THRU_TEXT_FLAG | Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SHADOW_BAN : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . red ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_INVISIBLE : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . gray ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_UNDER_REVIEW : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . orange ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . blue ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; case HistoryComment . STATE_SENSITIVE : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_violet ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; default : holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_font ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; break ; } } else { holder . txv_comment . setTextColor ( context . getResources ( ) . getColor ( R . color . dark_font ) ) ; holder . txv_comment . getPaint ( ) . setFlags ( Paint . ANTI_ALIAS_FLAG ) ; } holder . txv_date . setText ( historyComment . getFormatDateFor_yMd ( ) ) ; holder . txv_info . setText ( historyComment . commentArea . sourceId ) ; holder . txv_like . setText ( formatCount ( historyComment . like ) ) ; if ( historyComment . like > <NUM_LIT> || historyComment . replyCount > <NUM_LIT> ) { holder . txv_like . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; holder . txv_reply_count . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; } holder . txv_reply_count . setText ( formatCount ( historyComment . replyCount ) ) ; holder . itemView . setOnClickListener ( v -> { showCommentInfoDialog ( historyComment , holder ) ; } ) ; holder . itemView . setOnLongClickListener ( v -> { View view = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = view . findViewById ( R . id . edit_text ) ; editText . setText ( historyComment . comment ) ; new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setView ( view ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; ResendCommentHandler handler = new ResendCommentHandler ( this , progressBarDialog , historyComment , holder ) ; new ResendCommentTask ( handler , commentManipulator , config , editText . getText ( ) . toString ( ) , historyComment ) . execute ( ) ; } ) . show ( ) ; return false ; } ) ; } private void showCommentInfoDialog ( HistoryComment historyComment , ViewHolder holder ) { View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . dialog_history_comment_info , null , true ) ; TextView txv_comment = dialogView . findViewById ( R . id . txv_comment_content ) ; TextView txv_last_state = dialogView . findViewById ( R . id . txv_last_state ) ; TextView txv_source_id = dialogView . findViewById ( R . id . txv_source_id ) ; TextView txv_oid = dialogView . findViewById ( R . id . txv_oid ) ; TextView txv_area_type = dialogView . findViewById ( R . id . txv_area_type ) ; TextView txv_rpid = dialogView . findViewById ( R . id . txv_rpid ) ; TextView txv_parent = dialogView . findViewById ( R . id . txv_parent ) ; TextView txv_root = dialogView . findViewById ( R . id . txv_root ) ; TextView txv_check_date = dialogView . findViewById ( R . id . txv_check_date ) ; TextView txv_send_date = dialogView . findViewById ( R . id . txv_send_date ) ; TextView txv_first_state = dialogView . findViewById ( R . id . txv_first_state ) ; TextView txv_checked_area = dialogView . findViewById ( R . id . txv_checked_area ) ; SensitiveScanResult scr = historyComment . sensitiveScanResult ; if ( scr != null ) { ForegroundColorSpan greenSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . green ) ) ; ForegroundColorSpan redSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . red ) ) ; SpannableStringBuilder builder0 = new SpannableStringBuilder ( historyComment . comment ) ; builder0 . setSpan ( greenSpan , <NUM_LIT> , scr . normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder0 . setSpan ( redSpan , scr . normalPosition , scr . unusualPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment . setText ( builder0 ) ; System . out . println ( scr . normalPosition ) ; } else { txv_comment . setText ( historyComment . comment ) ; } txv_last_state . setText ( HistoryComment . getStateDesc ( historyComment . lastState ) ) ; txv_first_state . setText ( HistoryComment . getStateDesc ( historyComment . firstState ) ) ; txv_source_id . setText ( historyComment . commentArea . sourceId ) ; txv_oid . setText ( String . valueOf ( historyComment . commentArea . oid ) ) ; txv_area_type . setText ( historyComment . commentArea . getAreaTypeDesc ( ) ) ; txv_rpid . setText ( String . valueOf ( historyComment . rpid ) ) ; txv_parent . setText ( String . valueOf ( historyComment . parent ) ) ; txv_root . setText ( String . valueOf ( historyComment . root ) ) ; txv_check_date . setText ( historyComment . getFormatLastCheckDateFor_yMdHms ( ) ) ; txv_send_date . setText ( historyComment . getFormatDateFor_yMdHms ( ) ) ; switch ( historyComment . checkedArea ) { case HistoryComment . CHECKED_NO_CHECK : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_NOT_MARTIAL_LAW : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA : txv_checked_area . setText ( "<STR_LIT>" ) ; break ; case HistoryComment . CHECKED_MARTIAL_LAW : txv_checked_area . setText ( "<STR_LIT>" ) ; } List < Comment . PictureInfo > pictureInfoList = historyComment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { RecyclerView rv_images = dialogView . findViewById ( R . id . rv_pictures ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . HORIZONTAL ) ; rv_images . setLayoutManager ( linearLayoutManager ) ; PicturesAdapter picturesAdapter = new PicturesAdapter ( context , pictureInfoList , linearLayoutManager ) ; rv_images . setAdapter ( picturesAdapter ) ; } AlertDialog . Builder builder = new AlertDialog . Builder ( context ) . setView ( dialogView ) . setPositiveButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) ; if ( ! HistoryComment . STATE_SENSITIVE . equals ( historyComment . firstState ) ) { builder . setNegativeButton ( "<STR_LIT>" , ( dialog , which ) -> { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , null , "<STR_LIT>" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; ReviewCommentStatusHandler handle = new ReviewCommentStatusHandler ( this , historyComment , progressDialog , holder ) ; new ReviewCommentStatusTask ( handle , commentManipulator , statisticsDBOpenHelper , historyComment ) . execute ( ) ; } ) ; } AlertDialog infoDialog = builder . setNeutralButton ( "<STR_LIT>" , null ) . show ( ) ; Button buttonMore = infoDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) ; buttonMore . setOnClickListener ( v1 -> showSubMenu ( buttonMore , infoDialog , holder , historyComment ) ) ; } private static class ReviewCommentStatusHandler extends ReviewCommentStatusTask . EventHandler { private final HistoryCommentAdapter adapter ; private final HistoryComment historyComment ; private final ProgressDialog progressDialog ; private final ViewHolder holder ; public ReviewCommentStatusHandler ( HistoryCommentAdapter adapter , HistoryComment historyComment , ProgressDialog progressDialog , ViewHolder holder ) { super ( new DialogErrorHandle ( progressDialog , adapter ) ) ; this . adapter = adapter ; this . historyComment = historyComment ; this . progressDialog = progressDialog ; this . holder = holder ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_PAGE_TURN_FOR_NO_ACC_REPLY : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY : progressDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Integer . class ) + "<STR_LIT>" ) ; break ; case WHAT_OK : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_NORMAL ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_SHADOW_BANNED : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_SHADOW_BAN ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_DELETED : progressDialog . dismiss ( ) ; historyComment . lastCheckDate = new Date ( ) ; historyComment . lastState = HistoryComment . STATE_DELETED ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_INVISIBLE : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_INVISIBLE ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_UNDER_REVIEW : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_UNDER_REVIEW ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_REPLY_OK : progressDialog . dismiss ( ) ; updateCommentInfo ( message . getObject ( <NUM_LIT> , BiliComment . class ) , HistoryComment . STATE_NORMAL ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; case WHAT_ROOT_COMMENT_IS_SHADOW_BAN : progressDialog . dismiss ( ) ; historyComment . lastState = HistoryComment . STATE_SHADOW_BAN ; historyComment . lastCheckDate = new Date ( ) ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; dialogCheckResult ( "<STR_LIT>" ) ; break ; } } private void updateCommentInfo ( BiliComment resultComment , String newState ) { historyComment . lastState = newState ; historyComment . like = resultComment . like ; historyComment . replyCount = resultComment . rcount ; historyComment . lastCheckDate = new Date ( ) ; adapter . notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; } private void dialogCheckResult ( String result ) { DialogUtil . dialogMessage ( adapter . context , "<STR_LIT>" , result ) ; } } private static class ResendCommentHandler extends ResendCommentTask . EventHandler { ProgressBarDialog progressBarDialog ; HistoryComment historyComment ; HistoryCommentAdapter adapter ; DialogCommCheckWorker worker ; ViewHolder holder ; StatisticsDBOpenHelper helper ; public ResendCommentHandler ( HistoryCommentAdapter adapter , ProgressBarDialog progressBarDialog , HistoryComment historyComment , ViewHolder viewHolder ) { super ( new DialogErrorHandle ( progressBarDialog , adapter ) ) ; this . progressBarDialog = progressBarDialog ; this . historyComment = historyComment ; this . adapter = adapter ; this . worker = adapter . dialogCommCheckWorker ; this . holder = viewHolder ; this . helper = adapter . statisticsDBOpenHelper ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_SEND_SUCCESS_AND_SLEEP : progressBarDialog . setIndeterminate ( false ) ; progressBarDialog . setMessage ( "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; break ; case WHAT_ON_NEW_PROGRESS : int progress = message . getObject ( <NUM_LIT> , Integer . class ) ; progressBarDialog . setMessage ( "<STR_LIT>" + progress * message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" + message . getObject ( <NUM_LIT> , Long . class ) + "<STR_LIT>" ) ; progressBarDialog . setProgress ( progress ) ; break ; case WHAT_ON_RESENT_COMMENT : progressBarDialog . setIndeterminate ( true ) ; BiliComment c = message . getObject ( <NUM_LIT> , CommentAddResult . class ) . reply ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void onNewCommentRpid ( long rpid ) { HistoryComment comment = helper . getHistoryComment ( c . rpid ) ; adapter . historyCommentList . add ( <NUM_LIT> , comment ) ; adapter . notifyItemInserted ( <NUM_LIT> ) ; } } ) ; worker . checkComment ( new Comment ( historyComment . commentArea , c . rpid , c . parent , c . root , c . content . message , null , new Date ( c . ctime * <NUM_LIT> ) ) , progressBarDialog ) ; break ; case WHAT_ON_CONTAIN_SENSITIVE : progressBarDialog . dismiss ( ) ; String title = message . getObject ( <NUM_LIT> , String . class ) ; String newComment = message . getObject ( <NUM_LIT> , String . class ) ; new AlertDialog . Builder ( adapter . context ) . setTitle ( title ) . setMessage ( "<STR_LIT>" + newComment ) . setOnDismissListener ( dialog -> { HistoryComment sensitiveComment = new HistoryComment ( historyComment . commentArea , - System . currentTimeMillis ( ) , historyComment . parent , historyComment . root , newComment , new Date ( ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_SENSITIVE , new Date ( ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_SENSITIVE , null , null ) ; adapter . statisticsDBOpenHelper . insertHistoryComment ( sensitiveComment ) ; adapter . historyCommentList . add ( <NUM_LIT> , sensitiveComment ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) . setPositiveButton ( "<STR_LIT>" , null ) . show ( ) ; break ; } } } private void showSubMenu ( Button button , DialogInterface dialog , ViewHolder holder , HistoryComment historyComment ) { PopupMenu popupMenu = new PopupMenu ( context , button ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { dialog . dismiss ( ) ; new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( "<STR_LIT>" , ( dialog14 , which2 ) -> { if ( statisticsDBOpenHelper . deleteHistoryComment ( historyComment . rpid ) != <NUM_LIT> ) { List < Comment . PictureInfo > pictureInfoList = historyComment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { for ( Comment . PictureInfo pictureInfo : pictureInfoList ) { PictureStorage . delete ( context , pictureInfo . img_src ) ; } } historyCommentList . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( context , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return false ; } ) ; if ( ! historyComment . lastState . equals ( HistoryComment . STATE_NORMAL ) && ! historyComment . lastState . equals ( HistoryComment . STATE_SENSITIVE ) ) { popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { AlertDialog dialog1 = new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" + "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( "<STR_LIT>" , ( dialog23 , which1 ) -> { Uri uri = Uri . parse ( "<STR_LIT>" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog24 , which1 ) -> { AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , new Handler ( ) , commentManipulator ) ; appealDialogPresenter . appeal ( CommentUtil . sourceIdToUrl ( historyComment . commentArea ) , historyComment . comment , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { if ( code == <NUM_LIT> ) { statisticsDBOpenHelper . updateHistoryCommentLastState ( historyComment . rpid , HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ; DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText + "<STR_LIT>" ) ; } else { DialogUtil . dialogMessage ( context , "<STR_LIT>" , toastText ) ; } } @ Override public void onNetErrInUI ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } ) . show ( ) ; return false ; } } ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { new AlertDialog . Builder ( context ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( android . R . string . ok , ( dialog12 , which ) -> { dialogCommCheckWorker . setExitListener ( new OnExitListener ( ) { @ Override public void onCommentStatusUpdated ( long rpid ) { historyCommentList . set ( holder . getBindingAdapterPosition ( ) , statisticsDBOpenHelper . getHistoryComment ( rpid ) ) ; notifyItemChanged ( holder . getBindingAdapterPosition ( ) ) ; } } ) ; dialog . dismiss ( ) ; dialogCommCheckWorker . scanSensitiveWord ( historyComment ) ; } ) . show ( ) ; return false ; } ) ; popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( @ NonNull MenuItem item ) { new AlertDialog . Builder ( context ) . setTitle ( "<STR_LIT>" ) . setMessage ( "<STR_LIT>" ) . setNegativeButton ( "<STR_LIT>" , ( dialog15 , which ) -> { checkArea ( true ) ; } ) . setPositiveButton ( "<STR_LIT>" , ( dialog13 , which ) -> { checkArea ( false ) ; } ) . setNeutralButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; return false ; } public void checkArea ( boolean isDeputyAccount ) { dialog . dismiss ( ) ; int position = holder . getBindingAdapterPosition ( ) ; DialogInterface . OnDismissListener listener = dialog16 -> { System . out . println ( position ) ; historyCommentList . set ( position , statisticsDBOpenHelper . getHistoryComment ( historyComment . rpid ) ) ; notifyItemChanged ( position ) ; } ; dialogCommCheckWorker . checkAreaMartialLaw ( historyComment , listener , isDeputyAccount ) ; } } ) ; } if ( ! historyComment . lastState . equals ( HistoryComment . STATE_SENSITIVE ) ) { popupMenu . getMenu ( ) . add ( "<STR_LIT>" ) . setOnMenuItemClickListener ( item -> { CommentLocator . lunch ( context , historyComment . commentArea . type , historyComment . commentArea . oid , historyComment . rpid , historyComment . root , historyComment . commentArea . sourceId ) ; return false ; } ) ; } popupMenu . show ( ) ; } @ Override public int getItemCount ( ) { return historyCommentList . size ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void addSomeData ( List < HistoryComment > historyCommentList ) { Collections . reverse ( historyCommentList ) ; this . historyCommentList . addAll ( <NUM_LIT> , historyCommentList ) ; notifyDataSetChanged ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void reloadData ( List < HistoryComment > historyCommentList ) { this . historyCommentList = historyCommentList ; notifyDataSetChanged ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public void setEnable ( boolean enable ) { this .  = enable ; notifyDataSetChanged ( ) ; } public static String formatCount ( int count ) { if ( count < <NUM_LIT> ) { return String . valueOf ( count ) ; } else { return String . format ( Locale . getDefault ( ) , "<STR_LIT>" , count / <NUM_LIT> ) ; } } public static class ViewHolder extends RecyclerView . ViewHolder { View itemView ; TextView txv_comment , txv_like , txv_reply_count , txv_info , txv_date , txv_banned_type ; ImageView imgv_banned_type , imgv_cover_image ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; this . itemView = itemView ; txv_comment = itemView . findViewById ( R . id . txv_comment_content ) ; txv_like = itemView . findViewById ( R . id . txv_like ) ; txv_info = itemView . findViewById ( R . id . txv_info ) ; txv_date = itemView . findViewById ( R . id . txv_date ) ; txv_reply_count = itemView . findViewById ( R . id . txv_reply_count ) ; txv_banned_type = itemView . findViewById ( R . id . txv_old_status ) ; imgv_banned_type = itemView . findViewById ( R . id . img_old_status ) ; imgv_cover_image = itemView . findViewById ( R . id . cover_image ) ; } } @ Override public void dialogMessage ( String title , String message ) { DialogUtil . dialogMessage ( context , title , message ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . SharedPreferences ; public class Config { public static final int SORT_RULER_DATE_DESC = <NUM_LIT> ; public static final int SORT_RULER_DATE_ASC = <NUM_LIT> ; public static final int SORT_RULER_LIKE_DESC = <NUM_LIT> ; public static final int SORT_RULER_REPLY_COUNT_DESC = <NUM_LIT> ; Context context ; public SharedPreferences sp_config ; public Config ( Context context ) { this . context = context ; sp_config = context . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; } public boolean getRecordeHistory ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setRecordeHistory ( boolean recordeHistory ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , recordeHistory ) . apply ( ) ; } public String getCookie ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public void setCookie ( String cookie ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , cookie ) . apply ( ) ; } public String getDeputyCookie ( ) { return sp_config . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public void setDeputyCookie ( String cookie ) { sp_config . edit ( ) . putString ( "<STR_LIT>" , cookie ) . apply ( ) ; } public long getWaitTime ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTime ( long waitTime ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTime ) . apply ( ) ; } public long getWaitTimeByDanmakuSend ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTimeByDanmakuSend ( long waitTimeByDanmakuSend ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTimeByDanmakuSend ) . apply ( ) ; } public long getWaitTimeByHasPictures ( ) { return sp_config . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; } public void setWaitTimeByHasPictures ( long waitTimeByHasPictures ) { sp_config . edit ( ) . putLong ( "<STR_LIT>" , waitTimeByHasPictures ) . apply ( ) ; } public boolean getEnableRecordeBannedComments ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setEnableRecordeBannedComments ( boolean autoRecorde ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , autoRecorde ) . apply ( ) ; } public boolean getRecordeHistoryIsEnable ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setSortRuler ( int sortRuler ) { sp_config . edit ( ) . putInt ( "<STR_LIT>" , sortRuler ) . apply ( ) ; } public int getSortRuler ( ) { return sp_config . getInt ( "<STR_LIT>" , SORT_RULER_DATE_DESC ) ; } public void setFilterRulerEnableNormal ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableNormal ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableShadowBan ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableShadowBan ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableDeleted ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableDelete ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableOther ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableOther ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public boolean getFilterRulerEnableType1 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType1 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType12 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType12 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public void setFilterRulerEnableType11 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType11 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setFilterRulerEnableType17 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType17 ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public boolean getEnable ( ) { return sp_config . getBoolean ( "<STR_LIT>" , true ) ; } public void setEnable ( boolean enable ) { sp_config . edit ( ) . putBoolean ( "<STR_LIT>" , enable ) . apply ( ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class PictureStorage { private static final Map < String , Bitmap > bitmapMap = new HashMap < > ( ) ; private static final LinkedList < String > bitmapLink = new LinkedList < > ( ) ; public synchronized static boolean save ( Context context , String url ) throws IOException { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( ! pictureFile . exists ( ) ) { OkHttpClient httpClient = OkHttpUtil . getHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( ! response . isSuccessful ( ) ) { return false ; } ResponseBody body = response . body ( ) ; OkHttpUtil . respNotNull ( body ) ; InputStream inputStream = body . byteStream ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( pictureFile ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) != - <NUM_LIT> ) { fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; } fileOutputStream . close ( ) ; } return true ; } public synchronized static void save ( Context context , InputStream inputStream , String name ) throws IOException { byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileOutputStream fos = new FileOutputStream ( new File ( getPicturesDir ( context ) , name ) ) ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } fos . close ( ) ; } public synchronized static Bitmap getBitMap ( String url ) { Bitmap bitmap = bitmapMap . get ( url ) ; if ( bitmap != null ) { bitmapLink . remove ( url ) ; bitmapLink . addFirst ( url ) ; } return bitmap ; } public synchronized static boolean loadImage ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { FileInputStream fileInputStream = null ; try { fileInputStream = new FileInputStream ( pictureFile ) ; } catch ( FileNotFoundException e ) { return false ; } bitmapMap . put ( url , BitmapFactory . decodeStream ( fileInputStream ) ) ; bitmapLink . addFirst ( url ) ; if ( bitmapLink . size ( ) > <NUM_LIT> ) { bitmapMap . remove ( bitmapLink . getLast ( ) ) ; bitmapLink . removeLast ( ) ; } return true ; } else { return false ; } } public synchronized static void delete ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { pictureFile . delete ( ) ; } } public static File getPictureFile ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { return pictureFile ; } return null ; } public static File getPicturesDir ( Context context ) { return context . getExternalFilesDir ( "<STR_LIT>" ) ; } private static String getPicFileNameFromUrl ( String url ) { String [ ] split = url . split ( "<STR_LIT>" ) ; return split [ split . length - <NUM_LIT> ] ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . annotation . JSONField ; import org . jetbrains . annotations . Nullable ; import kotlin . jvm . JvmField ; public abstract class BaseResponse { @ JvmField public int code ; @ JvmField @ Nullable public String message ; @ JvmField public int ttl ; @ JSONField ( deserialize = false , serialize = false ) public boolean isSuccess ( ) { return this . code == <NUM_LIT> ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + code + "<STR_LIT>" + message + '<STR_LIT>' + "<STR_LIT>" + ttl + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class ForwardDynamicResult { public long dyn_id ; public String dyn_id_str ; public int dyn_type ; public long dyn_rid ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . DialogInterface ; public class VoidDialogInterfaceOnClickListener implements DialogInterface . OnClickListener { @ Override public void onClick ( DialogInterface dialog , int which ) { } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHook extends BaseHook { AtomicReference < Context > currentContext ; AtomicReference < String > currentOid ; AtomicReference < String > currentDynId ; AtomicReference < String > currentAreaType ; AtomicReference < String > currentComment ; AtomicReference < String > currentPictures ; public PostCommentHook ( ) { currentContext = new AtomicReference < > ( ) ; currentOid = new AtomicReference < > ( ) ; currentDynId = new AtomicReference < > ( ) ; currentAreaType = new AtomicReference < > ( ) ; currentComment = new AtomicReference < > ( ) ; currentPictures = new AtomicReference < > ( ) ; } @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { try { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( "<STR_LIT>" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( "<STR_LIT>" ) ; XposedBridge . log ( "<STR_LIT>" + fragment_args . getString ( "<STR_LIT>" ) ) ; currentDynId . set ( fragment_args . getString ( "<STR_LIT>" ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } catch ( XposedHelpers . ClassNotFoundError e ) { XposedBridge . log ( "<STR_LIT>" ) ; } XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( "<STR_LIT>" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , java . lang . Class . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object result = param . getResult ( ) ; if ( result != null ) { Class < ? > resultClass = result . getClass ( ) ; for ( Class < ? > classInterface : resultClass . getInterfaces ( ) ) { if ( classInterface . getCanonicalName ( ) . equals ( "<STR_LIT>" ) ) { XposedHelpers . findAndHookMethod ( resultClass , "<STR_LIT>" , java . util . Map . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Map < String , String > arrayMap = ( Map < String , String > ) param . args [ <NUM_LIT> ] ; currentComment . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentOid . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentAreaType . set ( arrayMap . get ( "<STR_LIT>" ) ) ; currentPictures . set ( arrayMap . get ( "<STR_LIT>" ) ) ; } } ) ; } } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; Object body = XposedHelpers . callMethod ( arg , "<STR_LIT>" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( "<STR_LIT>" ) ) { Object data = XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ; if ( data != null && data . getClass ( ) . getCanonicalName ( ) . equals ( "<STR_LIT>" ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , "<STR_LIT>" ) ; Object content = XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , "<STR_LIT>" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( "<STR_LIT>" , ( String ) biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( oid ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( type ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , String . valueOf ( biliCommentAddResultClass . getField ( "<STR_LIT>" ) . get ( data ) ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( content , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( "<STR_LIT>" , Utils . getBvidFormAvid ( oid ) ) ; } try { Field picturesField = content . getClass ( ) . getField ( "<STR_LIT>" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( "<STR_LIT>" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( "<STR_LIT>" ) ; } long ctime = XposedHelpers . getLongField ( reply , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , ctime ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } else if ( XposedHelpers . getIntField ( body , "<STR_LIT>" ) == CommentAddResult . CODE_CONTAIN_SENSITIVE ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( "<STR_LIT>" , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , ByXposedLaunchedActivity . TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) ; intent . putExtra ( "<STR_LIT>" , currentOid . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , currentComment . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , ( String ) XposedHelpers . getObjectField ( body , "<STR_LIT>" ) ) ; intent . putExtra ( "<STR_LIT>" , currentAreaType . get ( ) ) ; intent . putExtra ( "<STR_LIT>" , currentDynId . get ( ) ) ; XposedBridge . log ( "<STR_LIT>" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } ) ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . drawable . Drawable ; import android . widget . ImageView ; import androidx . appcompat . content . res . AppCompatResources ; import java . io . IOException ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class PictureLoader { private final Context context ; private String url ; private PictureLoader ( Context context ) { this . context = context ; } public static PictureLoader with ( Context context ) { return new PictureLoader ( context ) ; } public PictureLoader load ( String url ) { this . url = url ; return this ; } public PictureLoader into ( ImageView imageView ) { Bitmap bitmap = PictureStorage . getBitMap ( url ) ; if ( bitmap != null ) { imageView . setImageBitmap ( bitmap ) ; return this ; } TaskManger . start ( ( ) -> { boolean loaded = PictureStorage . loadImage ( context , url ) ; if ( loaded ) { setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; return ; } try { if ( PictureStorage . save ( context , url ) ) { PictureStorage . loadImage ( context , url ) ; setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; } else { setFailed ( imageView ) ; } } catch ( IOException e ) { setFailed ( imageView ) ; } } ) ; return this ; } private static void setBitMap ( ImageView imageView , Bitmap bitmap ) { TaskManger . postOnUiThread ( ( ) -> imageView . setImageBitmap ( bitmap ) ) ; } private void setFailed ( ImageView imageView ) { TaskManger . postOnUiThread ( ( ) -> { Drawable drawable = AppCompatResources . getDrawable ( context , R . drawable . picture_failed ) ; imageView . setImageDrawable ( drawable ) ; } ) ; } } </s>
<s> package icu . freedomIntrovert . async ; public class EventMessage { private final int what ; private final Object [ ] objects ; public EventMessage ( Object [ ] objects , int what ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what , Object ... objects ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what ) { this . what = what ; this . objects = new Object [ <NUM_LIT> ] ; } public < T > T getObject ( int index , Class < T > clazz ) { return clazz . cast ( objects [ index ] ) ; } public int getWhat ( ) { return what ; } public Object [ ] getObjects ( ) { return objects ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class MartialLawCommentArea extends CommentArea { public static final String DISPOSAL_METHOD_SHADOW_BAN = "<STR_LIT>" ; public static final String DISPOSAL_METHOD_QUICK_DELETE = "<STR_LIT>" ; public String title , defaultDisposalMethod , up ; public byte [ ] coverImageData ; public MartialLawCommentArea ( CommentArea commentArea , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { this ( String . valueOf ( commentArea . oid ) , commentArea . sourceId , commentArea . type , defaultDisposalMethod , title , up , coverImageData ) ; } public MartialLawCommentArea ( String oid , String sourceId , int areaType , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { super ( Long . parseLong ( oid ) , sourceId , areaType ) ; this . up = up ; this . title = title ; this . defaultDisposalMethod = defaultDisposalMethod ; this . coverImageData = coverImageData ; } public String [ ] toStringArrays ( ) { return new String [ ] { String . valueOf ( oid ) , sourceId , String . valueOf ( type ) , defaultDisposalMethod , title , up , null } ; } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oid + '<STR_LIT>' + "<STR_LIT>" + sourceId + '<STR_LIT>' + "<STR_LIT>" + type + "<STR_LIT>" + title + '<STR_LIT>' + "<STR_LIT>" + defaultDisposalMethod + '<STR_LIT>' + "<STR_LIT>" + up + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class GeneralResponse < T > extends BaseResponse { public T data ; } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class CommentArea { public static final String AREA_VIDEO = "<STR_LIT>" ; public static final String AREA_ARTICLE = "<STR_LIT>" ; public static final String AREA_DYNAMIC = "<STR_LIT>" ; public static final int AREA_TYPE_VIDEO = <NUM_LIT> ; public static final int AREA_TYPE_ARTICLE = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC11 = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC17 = <NUM_LIT> ; public long oid ; public String sourceId ; public int type ; public CommentArea ( long oid , String sourceId , int type ) { this . oid = oid ; this . sourceId = sourceId ; this . type = type ; } public String getAreaTypeDesc ( ) { switch ( type ) { case CommentArea . AREA_TYPE_VIDEO : return "<STR_LIT>" + type + "<STR_LIT>" ; case CommentArea . AREA_TYPE_ARTICLE : return "<STR_LIT>" + type + "<STR_LIT>" ; case CommentArea . AREA_TYPE_DYNAMIC11 : case CommentArea . AREA_TYPE_DYNAMIC17 : return "<STR_LIT>" + type + "<STR_LIT>" ; default : return String . valueOf ( type ) ; } } @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + "<STR_LIT>" + oid + '<STR_LIT>' + "<STR_LIT>" + sourceId + '<STR_LIT>' + "<STR_LIT>" + type + '<STR_LIT>' + '<STR_LIT>' ; } } </s>
<s> package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Log ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; public class StatisticsDBOpenHelper extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public static final String ORDER_BY_DATE_DESC = "<STR_LIT>" ; public static final String ORDER_BY_DATE_ASC = "<STR_LIT>" ; public static final String ORDER_BY_LIKE_DESC = "<STR_LIT>" ; public static final String ORDER_BY_REPLY_COUNT_DESC = "<STR_LIT>" ; public static final String DB_NAME = "<STR_LIT>" ; public static final String TABLE_NAME_MARTIAL_LAW_AREA = "<STR_LIT>" ; public static final String TABLE_NAME_HISTORY_COMMENT = "<STR_LIT>" ; long count = <NUM_LIT> ; public StatisticsDBOpenHelper ( Context context ) { super ( context , DB_NAME , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { switch ( oldVersion ) { case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; db . execSQL ( "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; case <NUM_LIT> : db . execSQL ( "<STR_LIT>" ) ; } } public long insertMartialLawCommentArea ( MartialLawCommentArea area ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , area . oid ) ; values . put ( "<STR_LIT>" , area . sourceId ) ; values . put ( "<STR_LIT>" , area . type ) ; values . put ( "<STR_LIT>" , area . defaultDisposalMethod ) ; values . put ( "<STR_LIT>" , area . title ) ; values . put ( "<STR_LIT>" , area . up ) ; values . put ( "<STR_LIT>" , area . coverImageData ) ; return db . insert ( TABLE_NAME_MARTIAL_LAW_AREA , null , values ) ; } public long deleteMartialLawCommentArea ( long oid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_MARTIAL_LAW_AREA , "<STR_LIT>" , new String [ ] { String . valueOf ( oid ) } ) ; } public ArrayList < MartialLawCommentArea > queryMartialLawCommentAreas ( ) { ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList = new ArrayList < > ( ) ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA , null ) ; while ( cursor . moveToNext ( ) ) { martialLawCommentAreaArrayList . add ( new MartialLawCommentArea ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getInt ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , null ) ) ; } cursor . close ( ) ; return martialLawCommentAreaArrayList ; } public byte [ ] selectMartialLawCommentAreaCoverImage ( long oid ) { byte [ ] imageData = null ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( "<STR_LIT>" + TABLE_NAME_MARTIAL_LAW_AREA + "<STR_LIT>" , new String [ ] { String . valueOf ( oid ) } ) ; if ( cursor . moveToNext ( ) ) { imageData = cursor . getBlob ( <NUM_LIT> ) ; } cursor . close ( ) ; return imageData ; } public int updateCheckedArea ( long rpid , int areaChecked ) { SQLiteDatabase db = getReadableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , areaChecked ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , values , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public List < HistoryComment > getDemoHistoryComments ( ) { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; CommentArea commentArea = new CommentArea ( <NUM_LIT> , "<STR_LIT>" , CommentArea . AREA_TYPE_VIDEO ) ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , "<STR_LIT>" , null ) ) ; count ++ ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SHADOW_BAN ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_DELETED ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SENSITIVE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_INVISIBLE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNDER_REVIEW ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNKNOWN ) ) ; return historyCommentList ; } private HistoryComment newDemoComment ( String state ) { CommentArea commentArea = new CommentArea ( <NUM_LIT> , "<STR_LIT>" , CommentArea . AREA_TYPE_VIDEO ) ; HistoryComment historyComment = new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , "<STR_LIT>" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , state , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , state , null , null ) ; count ++ ; return historyComment ; } public List < HistoryComment > queryAllHistoryComments ( String dateOrderBy ) { return selectHistoryComments ( "<STR_LIT>" + dateOrderBy ) ; } public List < HistoryComment > queryHistoryCommentsByDateGT ( long timestamp ) { return selectHistoryComments ( "<STR_LIT>" + timestamp + "<STR_LIT>" ) ; } public List < HistoryComment > queryHistoryCommentsCountLimit ( int limit ) { return selectHistoryComments ( "<STR_LIT>" + limit ) ; } private List < HistoryComment > selectHistoryComments ( String selectAddition ) { SQLiteDatabase db = getReadableDatabase ( ) ; List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( "<STR_LIT>" + TABLE_NAME_HISTORY_COMMENT + "<STR_LIT>" + selectAddition , null ) ) ; while ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , JSON . parseObject ( cursor . getString ( "<STR_LIT>" ) , SensitiveScanResult . class ) ) ; historyCommentList . add ( historyComment ) ; } cursor . close ( ) ; return historyCommentList ; } public long insertHistoryComment ( HistoryComment historyComment ) { deletePendingCheckComment ( historyComment . rpid ) ; SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , historyComment . rpid ) ; cv . put ( "<STR_LIT>" , historyComment . parent ) ; cv . put ( "<STR_LIT>" , historyComment . root ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . oid ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . type ) ; cv . put ( "<STR_LIT>" , historyComment . commentArea . sourceId ) ; cv . put ( "<STR_LIT>" , historyComment . comment ) ; cv . put ( "<STR_LIT>" , historyComment . like ) ; cv . put ( "<STR_LIT>" , historyComment . replyCount ) ; cv . put ( "<STR_LIT>" , historyComment . lastState ) ; cv . put ( "<STR_LIT>" , historyComment . lastCheckDate . getTime ( ) ) ; cv . put ( "<STR_LIT>" , historyComment . date . getTime ( ) ) ; cv . put ( "<STR_LIT>" , historyComment . checkedArea ) ; cv . put ( "<STR_LIT>" , historyComment . firstState ) ; cv . put ( "<STR_LIT>" , historyComment . pictures ) ; if ( historyComment . sensitiveScanResult != null ) { cv . put ( "<STR_LIT>" , JSON . toJSONString ( historyComment . sensitiveScanResult ) ) ; } return db . insert ( TABLE_NAME_HISTORY_COMMENT , null , cv ) ; } public int updateHistoryCommentLastState ( long rpid , String state ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , state ) ; cv . put ( "<STR_LIT>" , System . currentTimeMillis ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int updateHistoryCommentStates ( long rpid , String state , int like , int replyCount , Date last_check_date ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , state ) ; cv . put ( "<STR_LIT>" , like ) ; cv . put ( "<STR_LIT>" , replyCount ) ; cv . put ( "<STR_LIT>" , last_check_date . getTime ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int deleteHistoryComment ( long rpid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_HISTORY_COMMENT , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public HistoryComment getHistoryComment ( long rpid ) { SQLiteDatabase db = getReadableDatabase ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( "<STR_LIT>" + TABLE_NAME_HISTORY_COMMENT + "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ) ; if ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getLong ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , new Date ( cursor . getLong ( "<STR_LIT>" ) ) , cursor . getInt ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , cursor . getString ( "<STR_LIT>" ) , JSON . parseObject ( cursor . getString ( "<STR_LIT>" ) , SensitiveScanResult . class ) ) ; cursor . close ( ) ; return historyComment ; } else { cursor . close ( ) ; return null ; } } public void insertPendingCheckComment ( Comment comment ) { ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , comment . rpid ) ; values . put ( "<STR_LIT>" , comment . parent ) ; values . put ( "<STR_LIT>" , comment . root ) ; values . put ( "<STR_LIT>" , comment . comment ) ; values . put ( "<STR_LIT>" , comment . pictures ) ; values . put ( "<STR_LIT>" , comment . date . getTime ( ) ) ; values . put ( "<STR_LIT>" , comment . commentArea . oid ) ; values . put ( "<STR_LIT>" , comment . commentArea . sourceId ) ; values . put ( "<STR_LIT>" , comment . commentArea . type ) ; long newRowId = getWritableDatabase ( ) . insert ( "<STR_LIT>" , null , values ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + newRowId ) ; } public List < Comment > getAllPendingCheckComments ( ) { String [ ] projection = { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; Cursor cursor = getReadableDatabase ( ) . query ( "<STR_LIT>" , projection , null , null , null , null , "<STR_LIT>" ) ; List < Comment > commentList = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { long rpid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; Comment comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; commentList . add ( comment ) ; } cursor . close ( ) ; return commentList ; } public Comment getPendingCheckCommentByRpid ( long rpid ) { String [ ] projection = { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = { String . valueOf ( rpid ) } ; Cursor cursor = getReadableDatabase ( ) . query ( "<STR_LIT>" , projection , selection , selectionArgs , null , null , null ) ; Comment comment = null ; if ( cursor . moveToFirst ( ) ) { long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; } cursor . close ( ) ; return comment ; } public void deletePendingCheckComment ( long rpid ) { getWritableDatabase ( ) . delete ( "<STR_LIT>" , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public void addSensitiveScanResultToHistoryComment ( long rpid , SensitiveScanResult result ) { ContentValues cv = new ContentValues ( ) ; cv . put ( "<STR_LIT>" , JSON . toJSONString ( result ) ) ; getWritableDatabase ( ) . update ( TABLE_NAME_HISTORY_COMMENT , cv , "<STR_LIT>" , new String [ ] { String . valueOf ( rpid ) } ) ; } public Map < String , String > countingStatus ( ) { Map < String , String > map = new HashMap < > ( ) ; Cursor cursor = getReadableDatabase ( ) . rawQuery ( "<STR_LIT>" , null ) ; while ( cursor . moveToNext ( ) ) { map . put ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) ) ; } cursor . close ( ) ; return map ; } } </s>
