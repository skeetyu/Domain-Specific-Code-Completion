<s> TEXT = '<STR_LIT>' <EOL> MAP = '<STR_LIT>' <EOL> CARD = '<STR_LIT>' <EOL> NOTE = '<STR_LIT>' <EOL> SHARING = '<STR_LIT>' <EOL> PICTURE = '<STR_LIT>' <EOL> RECORDING = VOICE = '<STR_LIT>' <EOL> ATTACHMENT = '<STR_LIT>' <EOL> VIDEO = '<STR_LIT>' <EOL> FRIENDS = '<STR_LIT>' <EOL> SYSTEM = '<STR_LIT>' <EOL> INCOME_MSG = [ TEXT , MAP , CARD , NOTE , SHARING , PICTURE , <EOL> RECORDING , VOICE , ATTACHMENT , VIDEO , FRIENDS , SYSTEM ] <EOL> </s>
<s> import requests <EOL> from . import storage <EOL> class Core ( object ) : <EOL> def __init__ ( self ) : <EOL> self . alive , self . isLogging = False , False <EOL> self . storageClass = storage . Storage ( self ) <EOL> self . memberList = self . storageClass . memberList <EOL> self . mpList = self . storageClass . mpList <EOL> self . chatroomList = self . storageClass . chatroomList <EOL> self . msgList = self . storageClass . msgList <EOL> self . loginInfo = { } <EOL> self . s = requests . Session ( ) <EOL> self . uuid = None <EOL> self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } <EOL> self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' <EOL> self . receivingRetryCount = <NUM_LIT> <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QRuuid ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def check_login ( self , uuid = None ) : <EOL> raise NotImplementedError ( ) <EOL> def web_init ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def show_mobile_login ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_msg ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def logout ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def update_chatroom ( self , userName , detailedMember = False ) : <EOL> raise NotImplementedError ( ) <EOL> def update_friend ( self , userName ) : <EOL> raise NotImplementedError ( ) <EOL> def get_contact ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_friends ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_chatrooms ( self , update = False , contactOnly = False ) : <EOL> raise NotImplementedError ( ) <EOL> def get_mps ( self , update = False ) : <EOL> raise NotImplementedError ( ) <EOL> def set_alias ( self , userName , alias ) : <EOL> raise NotImplementedError ( ) <EOL> def set_pinned ( self , userName , isPinned = True ) : <EOL> raise NotImplementedError ( ) <EOL> def accept_friend ( self , userName , v4 , autoUpdate = True ) : <EOL> raise NotImplementedError ( ) <EOL> def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : <EOL> raise NotImplementedError ( ) <EOL> def set_chatroom_name ( self , chatroomUserName , name ) : <EOL> raise NotImplementedError ( ) <EOL> def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : <EOL> raise NotImplementedError ( ) <EOL> def add_member_into_chatroom ( self , chatroomUserName , memberList , <EOL> useInvitation = False ) : <EOL> raise NotImplementedError ( ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> raise NotImplementedError ( ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> raise NotImplementedError ( ) <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> raise NotImplementedError ( ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> raise NotImplementedError ( ) <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> raise NotImplementedError ( ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> raise NotImplementedError ( ) <EOL> def configured_reply ( self ) : <EOL> raise NotImplementedError ( ) <EOL> def msg_register ( self , msgType , <EOL> isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> raise NotImplementedError ( ) <EOL> def run ( self , debug = True , blockThread = True ) : <EOL> raise NotImplementedError ( ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return self . storageClass . search_friends ( name , userName , remarkName , <EOL> nickName , wechatAccount ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> return self . storageClass . search_chatrooms ( name , userName ) <EOL> def search_mps ( self , name = None , userName = None ) : <EOL> return self . storageClass . search_mps ( name , userName ) <EOL> </s>
<s> from io import BytesIO <EOL> from curl_cffi import Curl , CurlInfo , CurlOpt , requests <EOL> def main_curl ( ) : <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . CUSTOMREQUEST , b"<STR_LIT>" ) <EOL> c . setopt ( CurlOpt . URL , b"<STR_LIT>" ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( "<STR_LIT>" ) <EOL> print ( body . decode ( ) ) <EOL> print ( "<STR_LIT>" ) <EOL> buffer = BytesIO ( ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . setopt ( CurlOpt . URL , b"<STR_LIT>" ) <EOL> c . impersonate ( "<STR_LIT>" ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , [ b"<STR_LIT>" ] ) <EOL> c . perform ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( "<STR_LIT>" ) <EOL> print ( body . decode ( ) ) <EOL> c . close ( ) <EOL> def main_requests ( ) : <EOL> r = requests . get ( "<STR_LIT>" ) <EOL> print ( r . json ( ) ) <EOL> r = requests . get ( "<STR_LIT>" , impersonate = "<STR_LIT>" ) <EOL> print ( r . json ( ) ) <EOL> async def async_main ( ) : <EOL> async with requests . AsyncSession ( ) as s : <EOL> r = await s . get ( "<STR_LIT>" ) <EOL> print ( r . text ) <EOL> r = await s . get ( "<STR_LIT>" , stream = True ) <EOL> async for content in r . iter_content ( ) : <EOL> print ( content ) <EOL> if __name__ == "<STR_LIT>" : <EOL> async_main ( ) <EOL> </s>
<s> from bridge . bridge import Bridge <EOL> class Channel ( object ) : <EOL> def startup ( self ) : <EOL> raise NotImplementedError <EOL> def handle ( self , msg ) : <EOL> raise NotImplementedError <EOL> def send ( self , msg , receiver ) : <EOL> raise NotImplementedError <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> </s>
<s> import os <EOL> from claude_api import Client <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> return cookie <EOL> def main ( ) : <EOL> cookie = get_cookie ( ) <EOL> claude = Client ( cookie ) <EOL> conversation_id = None <EOL> print ( "<STR_LIT>" ) <EOL> while True : <EOL> user_input = input ( "<STR_LIT>" ) <EOL> if user_input . lower ( ) == '<STR_LIT>' : <EOL> print ( "<STR_LIT>" ) <EOL> break <EOL> if not conversation_id : <EOL> conversation = claude . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> response = claude . send_message ( user_input , conversation_id ) <EOL> print ( "<STR_LIT>" , response ) <EOL> if __name__ == "<STR_LIT>" : <EOL> main ( ) <EOL> </s>
<s> import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( "<STR_LIT>" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> rval = self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> if rval : <EOL> return <EOL> logger . error ( '<STR_LIT>' . format ( rval ) ) <EOL> self . logout ( ) <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> def configured_reply ( self ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = replyFn ( msg ) <EOL> if r is not None : <EOL> self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> if blockThread : <EOL> reply_fn ( ) <EOL> else : <EOL> replyThread = threading . Thread ( target = reply_fn ) <EOL> replyThread . setDaemon ( True ) <EOL> replyThread . start ( ) <EOL> </s>
<s> from fastapi import FastAPI , BackgroundTasks , File , UploadFile <EOL> from claude_api import Client <EOL> import os <EOL> app = FastAPI ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> if not cookie : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> return cookie <EOL> @ app . post ( "<STR_LIT>" ) <EOL> async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversation = client . create_new_chat ( ) <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> background_tasks . add_task ( client . send_message , prompt , conversation_id ) <EOL> return { "<STR_LIT>" : conversation_id } <EOL> @ app . get ( "<STR_LIT>" ) <EOL> async def get_chat_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return history <EOL> @ app . post ( "<STR_LIT>" ) <EOL> async def send_message ( conversation_id : str , prompt : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> response = client . send_message ( prompt , conversation_id ) <EOL> return { "<STR_LIT>" : response } <EOL> @ app . post ( "<STR_LIT>" ) <EOL> async def reset_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . reset_all ( ) <EOL> return { "<STR_LIT>" : result } <EOL> @ app . post ( "<STR_LIT>" ) <EOL> async def rename_conversation ( conversation_id : str , title : str ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> result = client . rename_chat ( title , conversation_id ) <EOL> return { "<STR_LIT>" : result } <EOL> @ app . post ( "<STR_LIT>" ) <EOL> async def upload_attachment ( file : UploadFile ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> file_path = save_upload_file ( file ) <EOL> response = client . upload_attachment ( file_path ) <EOL> return { "<STR_LIT>" : response } <EOL> def save_upload_file ( uploaded_file ) : <EOL> file_path = f"<STR_LIT>" <EOL> with open ( file_path , "<STR_LIT>" ) as buffer : <EOL> buffer . write ( uploaded_file . file . read ( ) ) <EOL> return file_path <EOL> @ app . get ( "<STR_LIT>" ) <EOL> async def list_all_conversations ( ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> conversations = client . list_all_conversations ( ) <EOL> return { "<STR_LIT>" : conversations } <EOL> @ app . get ( "<STR_LIT>" ) <EOL> async def chat_conversation_history ( conversation_id ) : <EOL> cookie = get_cookie ( ) <EOL> client = Client ( cookie ) <EOL> history = client . chat_conversation_history ( conversation_id ) <EOL> return { "<STR_LIT>" : history } <EOL> </s>
<s> import logging , copy , pickle <EOL> from weakref import ref <EOL> from . . returnvalues import ReturnValue <EOL> from . . utils import update_info_dict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class AttributeDict ( dict ) : <EOL> def __getattr__ ( self , value ) : <EOL> keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> try : <EOL> return self [ keyName ] <EOL> except KeyError : <EOL> raise AttributeError ( "<STR_LIT>" % ( <EOL> self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) <EOL> def get ( self , v , d = None ) : <EOL> try : <EOL> return self [ v ] <EOL> except KeyError : <EOL> return d <EOL> class UnInitializedItchat ( object ) : <EOL> def _raise_error ( self , * args , ** kwargs ) : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> def __getattr__ ( self , value ) : <EOL> return self . _raise_error <EOL> class ContactList ( list ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( ContactList , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def set_default_value ( self , initFunction = None , contactClass = None ) : <EOL> if hasattr ( initFunction , '<STR_LIT>' ) : <EOL> self . contactInitFn = initFunction <EOL> if hasattr ( contactClass , '<STR_LIT>' ) : <EOL> self . contactClass = contactClass <EOL> def append ( self , value ) : <EOL> contact = self . contactClass ( value ) <EOL> contact . core = self . core <EOL> if self . contactInitFn is not None : <EOL> contact = self . contactInitFn ( self , contact ) or contact <EOL> super ( ContactList , self ) . append ( contact ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) <EOL> r . contactInitFn = self . contactInitFn <EOL> r . contactClass = self . contactClass <EOL> r . core = self . core <EOL> return r <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> self . contactInitFn = None <EOL> self . contactClass = User <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> class AbstractUserDict ( AttributeDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> def update ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_alias ( self , alias ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def verify ( self ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def add_member ( self , userName ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return self . core . send_raw_msg ( msgType , content , self . userName ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return self . core . send_msg ( msg , self . userName ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_file ( fileDir , self . userName , mediaId ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return self . core . send_image ( fileDir , self . userName , mediaId ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return self . core . send_video ( fileDir , self . userName , mediaId ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return self . core . send ( msg , self . userName , mediaId ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = self . __class__ ( ) <EOL> for k , v in self . items ( ) : <EOL> r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) <EOL> r . core = self . core <EOL> return r <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> def __getstate__ ( self ) : <EOL> return <NUM_LIT> <EOL> def __setstate__ ( self , state ) : <EOL> pass <EOL> class User ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( User , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def update ( self ) : <EOL> r = self . core . update_friend ( self . userName ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_alias ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def verify ( self ) : <EOL> return self . core . add_friend ( ** self . verifyDict ) <EOL> def __deepcopy__ ( self , memo ) : <EOL> r = super ( User , self ) . __deepcopy__ ( memo ) <EOL> r . verifyDict = copy . deepcopy ( self . verifyDict ) <EOL> return r <EOL> def __setstate__ ( self , state ) : <EOL> super ( User , self ) . __setstate__ ( state ) <EOL> self . verifyDict = { } <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class MassivePlatform ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( MassivePlatform , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class Chatroom ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) <EOL> memberList = ContactList ( ) <EOL> userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> refSelf = ref ( self ) <EOL> def init_fn ( parentList , d ) : <EOL> d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) <EOL> memberList . set_default_value ( init_fn , ChatroomMember ) <EOL> if '<STR_LIT>' in self : <EOL> for member in self . memberList : <EOL> memberList . append ( member ) <EOL> self [ '<STR_LIT>' ] = memberList <EOL> @ property <EOL> def core ( self ) : <EOL> return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat <EOL> @ core . setter <EOL> def core ( self , value ) : <EOL> self . _core = ref ( value ) <EOL> self . memberList . core = value <EOL> for member in self . memberList : <EOL> member . core = value <EOL> def update ( self , detailedMember = False ) : <EOL> r = self . core . update_chatroom ( self . userName , detailedMember ) <EOL> if r : <EOL> update_info_dict ( self , r ) <EOL> self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] <EOL> return r <EOL> def set_alias ( self , alias ) : <EOL> return self . core . set_chatroom_name ( self . userName , alias ) <EOL> def set_pinned ( self , isPinned = True ) : <EOL> return self . core . set_pinned ( self . userName , isPinned ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . userName , userName ) <EOL> def add_member ( self , userName ) : <EOL> return self . core . add_member_into_chatroom ( self . userName , userName ) <EOL> def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . core . storageClass . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return None <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m . userName == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( Chatroom , self ) . __setstate__ ( state ) <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> class ChatroomMember ( AbstractUserDict ) : <EOL> def __init__ ( self , * args , ** kwargs ) : <EOL> super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) <EOL> self . __setstate__ ( None ) <EOL> @ property <EOL> def chatroom ( self ) : <EOL> r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) <EOL> if r is None : <EOL> userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> r = self . core . search_chatrooms ( userName = userName ) <EOL> if isinstance ( r , dict ) : <EOL> self . chatroom = r <EOL> return r or fakeChatroom <EOL> @ chatroom . setter <EOL> def chatroom ( self , value ) : <EOL> if isinstance ( value , dict ) and '<STR_LIT>' in value : <EOL> self . _chatroom = ref ( value ) <EOL> self . _chatroomUserName = value [ '<STR_LIT>' ] <EOL> def get_head_image ( self , imageDir = None ) : <EOL> return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) <EOL> def delete_member ( self , userName ) : <EOL> return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) <EOL> def send_raw_msg ( self , msgType , content ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_msg ( self , msg = '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_file ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_image ( self , fileDir , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send_video ( self , fileDir = None , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def send ( self , msg , mediaId = None ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) <EOL> def __setstate__ ( self , state ) : <EOL> super ( ChatroomMember , self ) . __setstate__ ( state ) <EOL> self [ '<STR_LIT>' ] = fakeContactList <EOL> def wrap_user_dict ( d ) : <EOL> userName = d . get ( '<STR_LIT>' ) <EOL> if '<STR_LIT>' in userName : <EOL> r = Chatroom ( d ) <EOL> elif d . get ( '<STR_LIT>' , <NUM_LIT> ) & <NUM_LIT> == <NUM_LIT> : <EOL> r = User ( d ) <EOL> else : <EOL> r = MassivePlatform ( d ) <EOL> return r <EOL> fakeItchat = UnInitializedItchat ( ) <EOL> fakeContactList = ContactList ( ) <EOL> fakeChatroom = Chatroom ( ) <EOL> </s>
<s> import os , platform <EOL> VERSION = '<STR_LIT>' <EOL> ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) <EOL> BASE_URL = '<STR_LIT>' <EOL> OS = platform . system ( ) <EOL> DIR = os . getcwd ( ) <EOL> DEFAULT_QR = '<STR_LIT>' <EOL> TIMEOUT = ( <NUM_LIT> , <NUM_LIT> ) <EOL> USER_AGENT = '<STR_LIT>' <EOL> UOS_PATCH_CLIENT_VERSION = '<STR_LIT>' <EOL> UOS_PATCH_EXTSPAM = '<STR_LIT>' <EOL> </s>
<s> import os <EOL> import time <EOL> import re <EOL> import io <EOL> import threading <EOL> import json <EOL> import xml . dom . minidom <EOL> import random <EOL> import traceback <EOL> import logging <EOL> try : <EOL> from httplib import BadStatusLine <EOL> except ImportError : <EOL> from http . client import BadStatusLine <EOL> import requests <EOL> from pyqrcode import QRCode <EOL> from . . import config , utils <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage . templates import wrap_user_dict <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_login ( core ) : <EOL> core . login = login <EOL> core . get_QRuuid = get_QRuuid <EOL> core . get_QR = get_QR <EOL> core . check_login = check_login <EOL> core . web_init = web_init <EOL> core . show_mobile_login = show_mobile_login <EOL> core . start_receiving = start_receiving <EOL> core . get_msg = get_msg <EOL> core . logout = logout <EOL> def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if self . alive or self . isLogging : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> return <EOL> self . isLogging = True <EOL> logger . info ( '<STR_LIT>' ) <EOL> while self . isLogging : <EOL> uuid = push_login ( self ) <EOL> if uuid : <EOL> qrStorage = io . BytesIO ( ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' ) <EOL> while not self . get_QRuuid ( ) : <EOL> time . sleep ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> qrStorage = self . get_QR ( enableCmdQR = enableCmdQR , <EOL> picDir = picDir , qrCallback = qrCallback ) <EOL> isLoggedIn = False <EOL> while not isLoggedIn : <EOL> status = self . check_login ( ) <EOL> if hasattr ( qrCallback , '<STR_LIT>' ) : <EOL> qrCallback ( uuid = self . uuid , status = status , <EOL> qrcode = qrStorage . getvalue ( ) ) <EOL> if status == '<STR_LIT>' : <EOL> isLoggedIn = True <EOL> elif status == '<STR_LIT>' : <EOL> if isLoggedIn is not None : <EOL> logger . info ( '<STR_LIT>' ) <EOL> isLoggedIn = None <EOL> time . sleep ( <NUM_LIT> ) <EOL> time . sleep ( <NUM_LIT> ) <EOL> elif status != '<STR_LIT>' : <EOL> break <EOL> if isLoggedIn : <EOL> break <EOL> elif self . isLogging : <EOL> logger . info ( '<STR_LIT>' ) <EOL> else : <EOL> return <EOL> logger . info ( '<STR_LIT>' ) <EOL> self . web_init ( ) <EOL> self . show_mobile_login ( ) <EOL> self . get_contact ( True ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> r = loginCallback ( ) <EOL> else : <EOL> if os . path . exists ( picDir or config . DEFAULT_QR ) : <EOL> os . remove ( picDir or config . DEFAULT_QR ) <EOL> logger . info ( '<STR_LIT>' % self . storageClass . nickName ) <EOL> self . start_receiving ( exitCallback ) <EOL> self . isLogging = False <EOL> def push_login ( core ) : <EOL> cookiesDict = core . s . cookies . get_dict ( ) <EOL> if '<STR_LIT>' in cookiesDict : <EOL> url = '<STR_LIT>' % ( <EOL> config . BASE_URL , cookiesDict [ '<STR_LIT>' ] ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , headers = headers ) . json ( ) <EOL> if '<STR_LIT>' in r and r . get ( '<STR_LIT>' ) in ( <NUM_LIT> , '<STR_LIT>' ) : <EOL> core . uuid = r [ '<STR_LIT>' ] <EOL> return r [ '<STR_LIT>' ] <EOL> return False <EOL> def get_QRuuid ( self ) : <EOL> url = '<STR_LIT>' % config . BASE_URL <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . get ( url , params = params , headers = headers ) <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , r . text ) <EOL> if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : <EOL> self . uuid = data . group ( <NUM_LIT> ) <EOL> return self . uuid <EOL> def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> uuid = uuid or self . uuid <EOL> picDir = picDir or config . DEFAULT_QR <EOL> qrStorage = io . BytesIO ( ) <EOL> qrCode = QRCode ( '<STR_LIT>' + uuid ) <EOL> qrCode . png ( qrStorage , scale = <NUM_LIT> ) <EOL> if hasattr ( qrCallback , '<STR_LIT>' ) : <EOL> qrCallback ( uuid = uuid , status = '<STR_LIT>' , qrcode = qrStorage . getvalue ( ) ) <EOL> else : <EOL> with open ( picDir , '<STR_LIT>' ) as f : <EOL> f . write ( qrStorage . getvalue ( ) ) <EOL> if enableCmdQR : <EOL> utils . print_cmd_qr ( qrCode . text ( <NUM_LIT> ) , enableCmdQR = enableCmdQR ) <EOL> else : <EOL> utils . print_qr ( picDir ) <EOL> return qrStorage <EOL> def check_login ( self , uuid = None ) : <EOL> uuid = uuid or self . uuid <EOL> url = '<STR_LIT>' % config . BASE_URL <EOL> localTime = int ( time . time ( ) ) <EOL> params = '<STR_LIT>' % ( <EOL> uuid , int ( - localTime / <NUM_LIT> ) , localTime ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . get ( url , params = params , headers = headers ) <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , r . text ) <EOL> if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : <EOL> if process_login_info ( self , r . text ) : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return '<STR_LIT>' <EOL> elif data : <EOL> return data . group ( <NUM_LIT> ) <EOL> else : <EOL> return '<STR_LIT>' <EOL> def process_login_info ( core , loginContent ) : <EOL> regx = r'<STR_LIT>' <EOL> core . loginInfo [ '<STR_LIT>' ] = re . search ( regx , loginContent ) . group ( <NUM_LIT> ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : config . UOS_PATCH_CLIENT_VERSION , <EOL> '<STR_LIT>' : config . UOS_PATCH_EXTSPAM , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> r = core . s . get ( core . loginInfo [ '<STR_LIT>' ] , <EOL> headers = headers , allow_redirects = False ) <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ : core . loginInfo [ '<STR_LIT>' ] . rfind ( <EOL> '<STR_LIT>' ) ] <EOL> for indexUrl , detailedUrl in ( <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) ) : <EOL> fileUrl , syncUrl = [ '<STR_LIT>' % <EOL> url for url in detailedUrl ] <EOL> if indexUrl in core . loginInfo [ '<STR_LIT>' ] : <EOL> core . loginInfo [ '<STR_LIT>' ] , core . loginInfo [ '<STR_LIT>' ] = fileUrl , syncUrl <EOL> break <EOL> else : <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] <EOL> core . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] <EOL> core . loginInfo [ '<STR_LIT>' ] = int ( time . time ( ) * <NUM_LIT> ) <EOL> core . loginInfo [ '<STR_LIT>' ] = { } <EOL> cookies = core . s . cookies . get_dict ( ) <EOL> res = re . findall ( '<STR_LIT>' , r . text , re . S ) <EOL> skey = res [ <NUM_LIT> ] if res else None <EOL> res = re . findall ( <EOL> '<STR_LIT>' , r . text , re . S ) <EOL> pass_ticket = res [ <NUM_LIT> ] if res else None <EOL> if skey is not None : <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = skey <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ "<STR_LIT>" ] <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ "<STR_LIT>" ] <EOL> if pass_ticket is not None : <EOL> core . loginInfo [ '<STR_LIT>' ] = pass_ticket <EOL> if not all ( [ key in core . loginInfo for key in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> logger . error ( <EOL> '<STR_LIT>' % r . text ) <EOL> core . isLogging = False <EOL> return False <EOL> return True <EOL> def web_init ( self ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : int ( - time . time ( ) / <NUM_LIT> ) , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> data = { '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT , } <EOL> r = self . s . post ( url , params = params , data = json . dumps ( data ) , headers = headers ) <EOL> dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> utils . emoji_formatter ( dic [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . loginInfo [ '<STR_LIT>' ] = int ( dic [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] = wrap_user_dict ( <EOL> utils . struct_friend_info ( dic [ '<STR_LIT>' ] ) ) <EOL> self . memberList . append ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) <EOL> for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) <EOL> self . storageClass . userName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> self . storageClass . nickName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> contactList = dic . get ( '<STR_LIT>' , [ ] ) <EOL> chatroomList , otherList = [ ] , [ ] <EOL> for m in contactList : <EOL> if m [ '<STR_LIT>' ] != <NUM_LIT> : <EOL> otherList . append ( m ) <EOL> elif '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> m [ '<STR_LIT>' ] = [ ] <EOL> chatroomList . append ( m ) <EOL> elif '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> otherList . append ( m ) <EOL> if chatroomList : <EOL> update_local_chatrooms ( self , chatroomList ) <EOL> if otherList : <EOL> update_local_friends ( self , otherList ) <EOL> return dic <EOL> def show_mobile_login ( self ) : <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : int ( time . time ( ) ) , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT , } <EOL> r = self . s . post ( url , data = json . dumps ( data ) , headers = headers ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> self . alive = True <EOL> def maintain_loop ( ) : <EOL> retryCount = <NUM_LIT> <EOL> while self . alive : <EOL> try : <EOL> i = sync_check ( self ) <EOL> if i is None : <EOL> self . alive = False <EOL> elif i == '<STR_LIT>' : <EOL> pass <EOL> else : <EOL> msgList , contactList = self . get_msg ( ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : <EOL> self . msgList . put ( msg ) <EOL> if contactList : <EOL> chatroomList , otherList = [ ] , [ ] <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> chatroomList . append ( contact ) <EOL> else : <EOL> otherList . append ( contact ) <EOL> chatroomMsg = update_local_chatrooms ( <EOL> self , chatroomList ) <EOL> chatroomMsg [ '<STR_LIT>' ] = self . loginInfo [ '<STR_LIT>' ] <EOL> self . msgList . put ( chatroomMsg ) <EOL> update_local_friends ( self , otherList ) <EOL> retryCount = <NUM_LIT> <EOL> except requests . exceptions . ReadTimeout : <EOL> pass <EOL> except : <EOL> retryCount += <NUM_LIT> <EOL> logger . error ( traceback . format_exc ( ) ) <EOL> if self . receivingRetryCount < retryCount : <EOL> logger . error ( "<STR_LIT>" % ( <EOL> retryCount ) + "<STR_LIT>" ) <EOL> self . alive = False <EOL> else : <EOL> time . sleep ( <NUM_LIT> ) <EOL> self . logout ( ) <EOL> if hasattr ( exitCallback , '<STR_LIT>' ) : <EOL> exitCallback ( ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if getReceivingFnOnly : <EOL> return maintain_loop <EOL> else : <EOL> maintainThread = threading . Thread ( target = maintain_loop ) <EOL> maintainThread . setDaemon ( True ) <EOL> maintainThread . start ( ) <EOL> def sync_check ( self ) : <EOL> url = '<STR_LIT>' % self . loginInfo . get ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) <EOL> params = { <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> self . loginInfo [ '<STR_LIT>' ] += <NUM_LIT> <EOL> try : <EOL> r = self . s . get ( url , params = params , headers = headers , <EOL> timeout = config . TIMEOUT ) <EOL> except requests . exceptions . ConnectionError as e : <EOL> try : <EOL> if not isinstance ( e . args [ <NUM_LIT> ] . args [ <NUM_LIT> ] , BadStatusLine ) : <EOL> raise <EOL> return '<STR_LIT>' <EOL> except : <EOL> raise <EOL> r . raise_for_status ( ) <EOL> regx = r'<STR_LIT>' <EOL> pm = re . search ( regx , r . text ) <EOL> if pm is None or pm . group ( <NUM_LIT> ) != '<STR_LIT>' : <EOL> logger . error ( '<STR_LIT>' % r . text ) <EOL> return None <EOL> return pm . group ( <NUM_LIT> ) <EOL> def get_msg ( self ) : <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] , <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ~ int ( time . time ( ) ) , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , data = json . dumps ( data ) , <EOL> headers = headers , timeout = config . TIMEOUT ) <EOL> dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> if dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] != <NUM_LIT> : <EOL> return None , None <EOL> self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) <EOL> for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) <EOL> return dic [ '<STR_LIT>' ] , dic [ '<STR_LIT>' ] <EOL> def logout ( self ) : <EOL> if self . alive : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> self . s . get ( url , params = params , headers = headers ) <EOL> self . alive = False <EOL> self . isLogging = False <EOL> self . s . cookies . clear ( ) <EOL> del self . chatroomList [ : ] <EOL> del self . memberList [ : ] <EOL> del self . mpList [ : ] <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> </s>
<s> from . core import Core <EOL> from . config import VERSION , ASYNC_COMPONENTS <EOL> from . log import set_logging <EOL> if ASYNC_COMPONENTS : <EOL> from . async_components import load_components <EOL> else : <EOL> from . components import load_components <EOL> __version__ = VERSION <EOL> instanceList = [ ] <EOL> def load_async_itchat ( ) -> Core : <EOL> from . async_components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> def load_sync_itchat ( ) -> Core : <EOL> from . components import load_components <EOL> load_components ( Core ) <EOL> return Core ( ) <EOL> if ASYNC_COMPONENTS : <EOL> instance = load_async_itchat ( ) <EOL> else : <EOL> instance = load_sync_itchat ( ) <EOL> instanceList = [ instance ] <EOL> login = instance . login <EOL> get_QRuuid = instance . get_QRuuid <EOL> get_QR = instance . get_QR <EOL> check_login = instance . check_login <EOL> web_init = instance . web_init <EOL> show_mobile_login = instance . show_mobile_login <EOL> start_receiving = instance . start_receiving <EOL> get_msg = instance . get_msg <EOL> logout = instance . logout <EOL> update_chatroom = instance . update_chatroom <EOL> update_friend = instance . update_friend <EOL> get_contact = instance . get_contact <EOL> get_friends = instance . get_friends <EOL> get_chatrooms = instance . get_chatrooms <EOL> get_mps = instance . get_mps <EOL> set_alias = instance . set_alias <EOL> set_pinned = instance . set_pinned <EOL> accept_friend = instance . accept_friend <EOL> get_head_img = instance . get_head_img <EOL> create_chatroom = instance . create_chatroom <EOL> set_chatroom_name = instance . set_chatroom_name <EOL> delete_member_from_chatroom = instance . delete_member_from_chatroom <EOL> add_member_into_chatroom = instance . add_member_into_chatroom <EOL> send_raw_msg = instance . send_raw_msg <EOL> send_msg = instance . send_msg <EOL> upload_file = instance . upload_file <EOL> send_file = instance . send_file <EOL> send_image = instance . send_image <EOL> send_video = instance . send_video <EOL> send = instance . send <EOL> revoke = instance . revoke <EOL> dump_login_status = instance . dump_login_status <EOL> load_login_status = instance . load_login_status <EOL> auto_login = instance . auto_login <EOL> configured_reply = instance . configured_reply <EOL> msg_register = instance . msg_register <EOL> run = instance . run <EOL> search_friends = instance . search_friends <EOL> search_chatrooms = instance . search_chatrooms <EOL> search_mps = instance . search_mps <EOL> set_logging = set_logging <EOL> </s>
<s> import hashlib <EOL> import web <EOL> class Handle ( object ) : <EOL> def GET ( self ) : <EOL> try : <EOL> data = web . input ( ) <EOL> if len ( data ) == <NUM_LIT> : <EOL> return "<STR_LIT>" <EOL> signature = data . signature <EOL> timestamp = data . timestamp <EOL> nonce = data . nonce <EOL> echostr = data . echostr <EOL> token = "<STR_LIT>" <EOL> list = [ token , timestamp , nonce ] <EOL> list . sort ( ) <EOL> sha1 = hashlib . sha1 ( ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( "<STR_LIT>" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( "<STR_LIT>" ) ) <EOL> sha1 . update ( list [ <NUM_LIT> ] . encode ( "<STR_LIT>" ) ) <EOL> hashcode = sha1 . hexdigest ( ) <EOL> print ( "<STR_LIT>" , hashcode , signature ) <EOL> if hashcode == signature : <EOL> return echostr <EOL> else : <EOL> return "<STR_LIT>" <EOL> except Exception as Argument : <EOL> return Argument <EOL> </s>
<s> from bot import bot_factory <EOL> class Bridge ( object ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def fetch_reply_content ( self , query , context ) : <EOL> return bot_factory . create_bot ( "<STR_LIT>" ) . reply ( query , context ) <EOL> </s>
<s> import requests <EOL> proxies = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } <EOL> response = requests . get ( '<STR_LIT>' , proxies = proxies ) <EOL> print ( response . text ) <EOL> </s>
<s> import os , time , re , io <EOL> import json <EOL> import mimetypes , hashlib <EOL> import logging <EOL> from collections import OrderedDict <EOL> import requests <EOL> from . . import config , utils <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_uin <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_messages ( core ) : <EOL> core . send_raw_msg = send_raw_msg <EOL> core . send_msg = send_msg <EOL> core . upload_file = upload_file <EOL> core . send_file = send_file <EOL> core . send_image = send_image <EOL> core . send_video = send_video <EOL> core . send = send <EOL> core . revoke = revoke <EOL> def get_download_fn ( core , url , msgId ) : <EOL> def download_fn ( downloadDir = None ) : <EOL> params = { <EOL> '<STR_LIT>' : msgId , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , stream = True , headers = headers ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if downloadDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( downloadDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> tempStorage . seek ( <NUM_LIT> ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } , <EOL> '<STR_LIT>' : utils . get_image_postfix ( tempStorage . read ( <NUM_LIT> ) ) , } ) <EOL> return download_fn <EOL> def produce_msg ( core , msgList ) : <EOL> rl = [ ] <EOL> srl = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> for m in msgList : <EOL> if m [ '<STR_LIT>' ] == core . storageClass . userName : <EOL> actualOpposite = m [ '<STR_LIT>' ] <EOL> else : <EOL> actualOpposite = m [ '<STR_LIT>' ] <EOL> if '<STR_LIT>' in m [ '<STR_LIT>' ] or '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> produce_group_chat ( core , m ) <EOL> else : <EOL> utils . msg_formatter ( m , '<STR_LIT>' ) <EOL> if '<STR_LIT>' in actualOpposite : <EOL> m [ '<STR_LIT>' ] = core . search_chatrooms ( userName = actualOpposite ) or templates . Chatroom ( { '<STR_LIT>' : actualOpposite } ) <EOL> elif actualOpposite in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> m [ '<STR_LIT>' ] = templates . User ( { '<STR_LIT>' : actualOpposite } ) <EOL> else : <EOL> m [ '<STR_LIT>' ] = core . search_mps ( userName = actualOpposite ) or core . search_friends ( userName = actualOpposite ) or templates . User ( userName = actualOpposite ) <EOL> m [ '<STR_LIT>' ] . core = core <EOL> if m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> if m [ '<STR_LIT>' ] : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> data = '<STR_LIT>' if data is None else data . group ( <NUM_LIT> ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> else : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> or m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % ( time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' if m [ '<STR_LIT>' ] == <NUM_LIT> else '<STR_LIT>' ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> m [ '<STR_LIT>' ] [ '<STR_LIT>' ] = m [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } , } <EOL> m [ '<STR_LIT>' ] . verifyDict = msg [ '<STR_LIT>' ] <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] in ( <NUM_LIT> , <NUM_LIT> ) : <EOL> msgId = m [ '<STR_LIT>' ] <EOL> def download_video ( videoDir = None ) : <EOL> url = '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : msgId , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , headers = headers , stream = True ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if videoDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( videoDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' : download_video , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> if m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> rawMsg = m <EOL> cookiesList = { name : data for name , data in core . s . cookies . items ( ) } <EOL> def download_atta ( attaDir = None ) : <EOL> url = core . loginInfo [ '<STR_LIT>' ] + '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesList [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , stream = True , headers = headers ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if attaDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( attaDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : download_atta , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % ( <EOL> time . strftime ( '<STR_LIT>' , time . localtime ( ) ) ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> if data : <EOL> data = data . group ( <NUM_LIT> ) . split ( u'<STR_LIT>' ) [ <NUM_LIT> ] <EOL> else : <EOL> data = '<STR_LIT>' <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> else : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = update_local_uin ( core , m ) <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> data = '<STR_LIT>' if data is None else data . group ( <NUM_LIT> ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> elif m [ '<STR_LIT>' ] in srl : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> else : <EOL> logger . debug ( '<STR_LIT>' % ( m [ '<STR_LIT>' ] , str ( m ) ) ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> m = dict ( m , ** msg ) <EOL> rl . append ( m ) <EOL> return rl <EOL> def produce_group_chat ( core , msg ) : <EOL> r = re . match ( '<STR_LIT>' , msg [ '<STR_LIT>' ] ) <EOL> if r : <EOL> actualUserName , content = r . groups ( ) <EOL> chatroomUserName = msg [ '<STR_LIT>' ] <EOL> elif msg [ '<STR_LIT>' ] == core . storageClass . userName : <EOL> actualUserName = core . storageClass . userName <EOL> content = msg [ '<STR_LIT>' ] <EOL> chatroomUserName = msg [ '<STR_LIT>' ] <EOL> else : <EOL> msg [ '<STR_LIT>' ] = core . storageClass . userName <EOL> msg [ '<STR_LIT>' ] = core . storageClass . nickName <EOL> msg [ '<STR_LIT>' ] = False <EOL> utils . msg_formatter ( msg , '<STR_LIT>' ) <EOL> return <EOL> chatroom = core . storageClass . search_chatrooms ( userName = chatroomUserName ) <EOL> member = utils . search_dict_list ( ( chatroom or { } ) . get ( <EOL> '<STR_LIT>' ) or [ ] , '<STR_LIT>' , actualUserName ) <EOL> if member is None : <EOL> chatroom = core . update_chatroom ( chatroomUserName ) <EOL> member = utils . search_dict_list ( ( chatroom or { } ) . get ( <EOL> '<STR_LIT>' ) or [ ] , '<STR_LIT>' , actualUserName ) <EOL> if member is None : <EOL> logger . debug ( '<STR_LIT>' % actualUserName ) <EOL> msg [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> msg [ '<STR_LIT>' ] = False <EOL> else : <EOL> msg [ '<STR_LIT>' ] = member . get ( '<STR_LIT>' , '<STR_LIT>' ) or member [ '<STR_LIT>' ] <EOL> atFlag = '<STR_LIT>' + ( chatroom [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) or core . storageClass . nickName ) <EOL> msg [ '<STR_LIT>' ] = ( <EOL> ( atFlag + ( u'<STR_LIT>' if u'<STR_LIT>' in msg [ '<STR_LIT>' ] else '<STR_LIT>' ) ) <EOL> in msg [ '<STR_LIT>' ] or msg [ '<STR_LIT>' ] . endswith ( atFlag ) ) <EOL> msg [ '<STR_LIT>' ] = actualUserName <EOL> msg [ '<STR_LIT>' ] = content <EOL> utils . msg_formatter ( msg , '<STR_LIT>' ) <EOL> def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : msgType , <EOL> '<STR_LIT>' : content , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : ( toUserName if toUserName else self . storageClass . userName ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( toUserName , msg ) ) <EOL> r = self . send_raw_msg ( <NUM_LIT> , msg , toUserName ) <EOL> return r <EOL> def _prepare_file ( fileDir , file_ = None ) : <EOL> fileDict = { } <EOL> if file_ : <EOL> if hasattr ( file_ , '<STR_LIT>' ) : <EOL> file_ = file_ . read ( ) <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if not utils . check_file ( fileDir ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> file_ = f . read ( ) <EOL> fileDict [ '<STR_LIT>' ] = len ( file_ ) <EOL> fileDict [ '<STR_LIT>' ] = hashlib . md5 ( file_ ) . hexdigest ( ) <EOL> fileDict [ '<STR_LIT>' ] = io . BytesIO ( file_ ) <EOL> return fileDict <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> '<STR_LIT>' if isPicture else '<STR_LIT>' if isVideo else '<STR_LIT>' , fileDir ) ) <EOL> if not preparedFile : <EOL> preparedFile = _prepare_file ( fileDir , file_ ) <EOL> if not preparedFile : <EOL> return preparedFile <EOL> fileSize , fileMd5 , file_ = preparedFile [ '<STR_LIT>' ] , preparedFile [ '<STR_LIT>' ] , preparedFile [ '<STR_LIT>' ] <EOL> fileSymbol = '<STR_LIT>' if isPicture else '<STR_LIT>' if isVideo else '<STR_LIT>' <EOL> chunks = int ( ( fileSize - <NUM_LIT> ) / <NUM_LIT> ) + <NUM_LIT> <EOL> clientMediaId = int ( time . time ( ) * <NUM_LIT> ) <EOL> uploadMediaRequest = json . dumps ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , clientMediaId ) , <EOL> ( '<STR_LIT>' , fileSize ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , fileSize ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , self . storageClass . userName ) , <EOL> ( '<STR_LIT>' , toUserName ) , <EOL> ( '<STR_LIT>' , fileMd5 ) ] <EOL> ) , separators = ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> r = { '<STR_LIT>' : { '<STR_LIT>' : - <NUM_LIT> , '<STR_LIT>' : '<STR_LIT>' } } <EOL> for chunk in range ( chunks ) : <EOL> r = upload_chunk_file ( self , fileDir , fileSymbol , fileSize , <EOL> file_ , chunk , chunks , uploadMediaRequest ) <EOL> file_ . close ( ) <EOL> if isinstance ( r , dict ) : <EOL> return ReturnValue ( r ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def upload_chunk_file ( core , fileDir , fileSymbol , fileSize , <EOL> file_ , chunk , chunks , uploadMediaRequest ) : <EOL> url = core . loginInfo . get ( '<STR_LIT>' , core . loginInfo [ '<STR_LIT>' ] ) + '<STR_LIT>' <EOL> cookiesList = { name : data for name , data in core . s . cookies . items ( ) } <EOL> fileType = mimetypes . guess_type ( fileDir ) [ <NUM_LIT> ] or '<STR_LIT>' <EOL> fileName = utils . quote ( os . path . basename ( fileDir ) ) <EOL> files = OrderedDict ( [ <EOL> ( '<STR_LIT>' , ( None , '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , ( None , fileName ) ) , <EOL> ( '<STR_LIT>' , ( None , fileType ) ) , <EOL> ( '<STR_LIT>' , ( None , time . strftime ( '<STR_LIT>' ) ) ) , <EOL> ( '<STR_LIT>' , ( None , str ( fileSize ) ) ) , <EOL> ( '<STR_LIT>' , ( None , None ) ) , <EOL> ( '<STR_LIT>' , ( None , None ) ) , <EOL> ( '<STR_LIT>' , ( None , fileSymbol ) ) , <EOL> ( '<STR_LIT>' , ( None , uploadMediaRequest ) ) , <EOL> ( '<STR_LIT>' , ( None , cookiesList [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , ( None , core . loginInfo [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , ( fileName , file_ . read ( <NUM_LIT> ) , '<STR_LIT>' ) ) ] ) <EOL> if chunks == <NUM_LIT> : <EOL> del files [ '<STR_LIT>' ] ; del files [ '<STR_LIT>' ] <EOL> else : <EOL> files [ '<STR_LIT>' ] , files [ '<STR_LIT>' ] = ( None , str ( chunk ) ) , ( None , str ( chunks ) ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> return core . s . post ( url , files = files , headers = headers , timeout = config . TIMEOUT ) <EOL> def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> preparedFile = _prepare_file ( fileDir , file_ ) <EOL> if not preparedFile : <EOL> return preparedFile <EOL> fileSize = preparedFile [ '<STR_LIT>' ] <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , preparedFile = preparedFile ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : ( "<STR_LIT>" % os . path . basename ( fileDir ) + <EOL> "<STR_LIT>" + <EOL> "<STR_LIT>" % ( str ( fileSize ) , mediaId ) + <EOL> "<STR_LIT>" % os . path . splitext ( fileDir ) [ <NUM_LIT> ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if fileDir or file_ : <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> file_ , fileDir = fileDir , None <EOL> if fileDir is None : <EOL> fileDir = '<STR_LIT>' <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , isPicture = not fileDir [ - <NUM_LIT> : ] == '<STR_LIT>' , file_ = file_ ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : mediaId , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> if fileDir [ - <NUM_LIT> : ] == '<STR_LIT>' : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT> <EOL> data [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT> <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if fileDir or file_ : <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> file_ , fileDir = fileDir , None <EOL> if fileDir is None : <EOL> fileDir = '<STR_LIT>' <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , isVideo = True , file_ = file_ ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : mediaId , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> if not msg : <EOL> r = ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = self . send_file ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = self . send_file ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = self . send_image ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = self . send_image ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> r = self . send_msg ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = self . send_video ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = self . send_video ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> else : <EOL> r = self . send_msg ( msg , toUserName ) <EOL> return r <EOL> def revoke ( self , msgId , toUserName , localId = None ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> "<STR_LIT>" : localId or str ( time . time ( ) * <NUM_LIT> ) , <EOL> "<STR_LIT>" : msgId , <EOL> "<STR_LIT>" : toUserName } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> </s>
<s> def create_bot ( bot_type ) : <EOL> if bot_type == '<STR_LIT>' : <EOL> from bot . baidu . baidu_unit_bot import BaiduUnitBot <EOL> return BaiduUnitBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . chatgpt . chat_gpt_bot import ChatGPTBot <EOL> return ChatGPTBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . openai . open_ai_bot import OpenAIBot <EOL> return OpenAIBot ( ) <EOL> elif bot_type == '<STR_LIT>' : <EOL> from bot . claude . claude_ai_bot import ClaudeAiBot <EOL> return ClaudeAiBot ( ) <EOL> raise RuntimeError <EOL> </s>
<s> from lib import itchat <EOL> from lib . itchat . content import * <EOL> import json <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import requests <EOL> import io <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ itchat . msg_register ( TEXT ) <EOL> def handler_single_msg ( msg ) : <EOL> WechatChannel ( ) . handle ( msg ) <EOL> return None <EOL> @ itchat . msg_register ( TEXT , isGroupChat = True ) <EOL> def handler_group_msg ( msg ) : <EOL> WechatChannel ( ) . handle_group ( msg ) <EOL> return None <EOL> class WechatChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> itchat . auto_login ( enableCmdQR = <NUM_LIT> ) <EOL> itchat . run ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( "<STR_LIT>" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> from_user_id = msg [ '<STR_LIT>' ] <EOL> to_user_id = msg [ '<STR_LIT>' ] <EOL> other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if from_user_id == other_user_id and match_prefix is not None : <EOL> if match_prefix != '<STR_LIT>' : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , from_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , from_user_id ) <EOL> elif to_user_id == other_user_id and match_prefix : <EOL> str_list = content . split ( match_prefix , <NUM_LIT> ) <EOL> if len ( str_list ) == <NUM_LIT> : <EOL> content = str_list [ <NUM_LIT> ] . strip ( ) <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , to_user_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send , content , to_user_id ) <EOL> def handle_group ( self , msg ) : <EOL> logger . debug ( "<STR_LIT>" + json . dumps ( msg , ensure_ascii = False ) ) <EOL> group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) <EOL> if not group_name : <EOL> return "<STR_LIT>" <EOL> origin_content = msg [ '<STR_LIT>' ] <EOL> content = msg [ '<STR_LIT>' ] <EOL> content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) <EOL> if len ( context_special_list ) == <NUM_LIT> : <EOL> content = context_special_list [ <NUM_LIT> ] <EOL> elif len ( content_list ) == <NUM_LIT> : <EOL> content = content_list [ <NUM_LIT> ] <EOL> config = conf ( ) <EOL> match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( "<STR_LIT>" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) <EOL> if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : <EOL> img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) <EOL> if img_match_prefix : <EOL> content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) <EOL> thread_pool . submit ( self . _do_send_img , content , group_id ) <EOL> else : <EOL> thread_pool . submit ( self . _do_send_group , content , msg ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> itchat . send ( msg , toUserName = receiver ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( conf ( ) . get ( "<STR_LIT>" ) + reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_img ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> img_url = super ( ) . build_reply_content ( query , context ) <EOL> if not img_url : <EOL> return <EOL> pic_res = requests . get ( img_url , stream = True ) <EOL> image_storage = io . BytesIO ( ) <EOL> for block in pic_res . iter_content ( <NUM_LIT> ) : <EOL> image_storage . write ( block ) <EOL> image_storage . seek ( <NUM_LIT> ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) <EOL> itchat . send_image ( image_storage , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def _do_send_group ( self , query , msg ) : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> reply_text = '<STR_LIT>' + msg [ '<STR_LIT>' ] + '<STR_LIT>' + reply_text . strip ( ) <EOL> self . send ( conf ( ) . get ( "<STR_LIT>" , "<STR_LIT>" ) + reply_text , msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) <EOL> def check_prefix ( self , content , prefix_list ) : <EOL> for prefix in prefix_list : <EOL> if content . startswith ( prefix ) : <EOL> return prefix <EOL> return None <EOL> def check_contain ( self , content , keyword_list ) : <EOL> if not keyword_list : <EOL> return None <EOL> for ky in keyword_list : <EOL> if content . find ( ky ) != - <NUM_LIT> : <EOL> return True <EOL> return None <EOL> </s>
<s> import config <EOL> from common . log import logger <EOL> from channel import channel_factory <EOL> def run ( ) : <EOL> try : <EOL> config . load_config ( ) <EOL> channel = channel_factory . create_channel ( "<STR_LIT>" ) <EOL> channel . startup ( ) <EOL> except Exception as e : <EOL> logger . error ( "<STR_LIT>" ) <EOL> logger . exception ( e ) <EOL> if __name__ == "<STR_LIT>" : <EOL> run ( ) <EOL> </s>
<s> import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> async def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> async def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> await self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> await loginCallback ( self . storageClass . userName ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> async def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } ) <EOL> except : <EOL> logger . info ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> </s>
<s> import pickle <EOL> class idStore ( ) : <EOL> def __init__ ( self ) : <EOL> self . id = None <EOL> def get_id ( self ) : <EOL> if self . id is None : <EOL> try : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> self . id = pickle . load ( f ) <EOL> except FileNotFoundError : <EOL> print ( "<STR_LIT>" ) <EOL> return self . id <EOL> def set_id ( self , id ) : <EOL> self . id = id <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : <EOL> pickle . dump ( self . id , f ) <EOL> </s>
<s> import werobot <EOL> import time <EOL> from config import conf <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> import config <EOL> import os <EOL> config . load_config ( ) <EOL> robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> cache = { } <EOL> @ robot . text <EOL> def hello_world ( msg ) : <EOL> with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] <EOL> found = False <EOL> for word in sensitive_words : <EOL> if word != '<STR_LIT>' and word in msg . content : <EOL> found = True <EOL> break <EOL> if found : <EOL> return "<STR_LIT>" <EOL> else : <EOL> logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> if cache . get ( key ) : <EOL> cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> <EOL> return WechatSubsribeAccount ( ) . handle ( msg ) <EOL> class WechatSubsribeAccount ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> logger . info ( "<STR_LIT>" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> robot . config [ '<STR_LIT>' ] = self . host <EOL> robot . config [ '<STR_LIT>' ] = self . port <EOL> robot . run ( ) <EOL> def handle ( self , msg , count = <NUM_LIT> ) : <EOL> if msg . content == "<STR_LIT>" : <EOL> return self . get_un_send_content ( msg . source ) <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = msg . source <EOL> key = msg . content + '<STR_LIT>' + msg . source <EOL> res = cache . get ( key ) <EOL> if not res : <EOL> cache [ key ] = { "<STR_LIT>" : "<STR_LIT>" , "<STR_LIT>" : <NUM_LIT> } <EOL> thread_pool . submit ( self . _do_send , msg . content , context ) <EOL> res = cache . get ( key ) <EOL> logger . info ( "<STR_LIT>" . format ( count , res ) ) <EOL> if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : <EOL> res [ '<STR_LIT>' ] = "<STR_LIT>" <EOL> cache . pop ( key ) <EOL> return res . get ( "<STR_LIT>" ) <EOL> if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : <EOL> logger . info ( "<STR_LIT>" ) <EOL> return "<STR_LIT>" <EOL> if count <= <NUM_LIT> : <EOL> time . sleep ( <NUM_LIT> ) <EOL> if count == <NUM_LIT> : <EOL> return None <EOL> return self . handle ( msg , count + <NUM_LIT> ) <EOL> def _do_send ( self , query , context ) : <EOL> key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] <EOL> reply_text = self . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> cache [ key ] [ '<STR_LIT>' ] = "<STR_LIT>" <EOL> cache [ key ] [ '<STR_LIT>' ] = reply_text <EOL> def get_un_send_content ( self , from_user_id ) : <EOL> for key in cache : <EOL> if from_user_id in key : <EOL> value = cache [ key ] <EOL> if value . get ( '<STR_LIT>' ) == "<STR_LIT>" : <EOL> cache . pop ( key ) <EOL> return value . get ( "<STR_LIT>" ) <EOL> return "<STR_LIT>" <EOL> return "<STR_LIT>" <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> </s>
<s> import logging , traceback , sys , threading <EOL> try : <EOL> import Queue <EOL> except ImportError : <EOL> import queue as Queue <EOL> from . . log import set_logging <EOL> from . . utils import test_connect <EOL> from . . storage import templates <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_register ( core ) : <EOL> core . auto_login = auto_login <EOL> core . configured_reply = configured_reply <EOL> core . msg_register = msg_register <EOL> core . run = run <EOL> async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> hotReload = True , statusStorageDir = '<STR_LIT>' , <EOL> enableCmdQR = False , picDir = None , qrCallback = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if not test_connect ( ) : <EOL> logger . info ( "<STR_LIT>" ) <EOL> sys . exit ( ) <EOL> self . useHotReload = hotReload <EOL> self . hotReloadDir = statusStorageDir <EOL> if hotReload : <EOL> if await self . load_login_status ( statusStorageDir , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) : <EOL> return <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> await self . dump_login_status ( statusStorageDir ) <EOL> else : <EOL> await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , <EOL> loginCallback = loginCallback , exitCallback = exitCallback ) <EOL> async def configured_reply ( self , event_stream , payload , message_container ) : <EOL> try : <EOL> msg = self . msgList . get ( timeout = <NUM_LIT> ) <EOL> if '<STR_LIT>' in msg . keys ( ) : <EOL> message_container [ msg [ '<STR_LIT>' ] ] = msg <EOL> except Queue . Empty : <EOL> pass <EOL> else : <EOL> if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : <EOL> replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) <EOL> if replyFn is None : <EOL> r = None <EOL> else : <EOL> try : <EOL> r = await replyFn ( msg ) <EOL> if r is not None : <EOL> await self . send ( r , msg . get ( '<STR_LIT>' ) ) <EOL> except : <EOL> logger . warning ( traceback . format_exc ( ) ) <EOL> def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : <EOL> if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : <EOL> msgType = [ msgType ] <EOL> def _msg_register ( fn ) : <EOL> for _msgType in msgType : <EOL> if isFriendChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isGroupChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if isMpChat : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : <EOL> self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn <EOL> return fn <EOL> return _msg_register <EOL> async def run ( self , debug = False , blockThread = True ) : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if debug : <EOL> set_logging ( loggingLevel = logging . DEBUG ) <EOL> async def reply_fn ( ) : <EOL> try : <EOL> while self . alive : <EOL> await self . configured_reply ( ) <EOL> except KeyboardInterrupt : <EOL> if self . useHotReload : <EOL> await self . dump_login_status ( ) <EOL> self . alive = False <EOL> logger . debug ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> if blockThread : <EOL> await reply_fn ( ) <EOL> else : <EOL> replyThread = threading . Thread ( target = reply_fn ) <EOL> replyThread . setDaemon ( True ) <EOL> replyThread . start ( ) <EOL> </s>
<s> from aiocqhttp import CQHttp , Event , MessageSegment <EOL> from channel . channel import Channel <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> bot = CQHttp ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . on_message ( '<STR_LIT>' ) <EOL> async def _ ( event : Event ) : <EOL> logger . info ( "<STR_LIT>" , event ) <EOL> QqchaChannel ( ) . handle ( event ) <EOL> @ bot . on_startup <EOL> async def startup ( ) : <EOL> logger . info ( "<STR_LIT>" ) <EOL> class QqchaChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( "<STR_LIT>" . format ( <EOL> self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> bot . run ( host = self . host , port = self . port ) <EOL> def handle ( self , msg ) : <EOL> thread_pool . submit ( self . _do_handle , msg ) <EOL> def _do_handle ( self , msg ) : <EOL> context = dict ( ) <EOL> reply_text = self . build_reply_content ( msg . message , context ) <EOL> bot . sync . send_private_msg ( user_id = msg . user_id , message = reply_text ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> bot . send ( receiver , msg ) <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> </s>
<s> import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from flask import Flask , request , render_template , make_response <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from channel . channel import Channel <EOL> from urllib import request as url_request <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class FeiShuChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . app_id = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . app_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . verification_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( "<STR_LIT>" . format ( <EOL> self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def get_tenant_access_token ( self ) : <EOL> url = "<STR_LIT>" <EOL> headers = { <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> req_body = { <EOL> "<STR_LIT>" : self . app_id , <EOL> "<STR_LIT>" : self . app_secret <EOL> } <EOL> data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) <EOL> req = url_request . Request ( url = url , data = data , <EOL> headers = headers , method = '<STR_LIT>' ) <EOL> try : <EOL> response = url_request . urlopen ( req ) <EOL> except Exception as e : <EOL> print ( e . read ( ) . decode ( ) ) <EOL> return "<STR_LIT>" <EOL> rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) <EOL> rsp_dict = json . loads ( rsp_body ) <EOL> code = rsp_dict . get ( "<STR_LIT>" , - <NUM_LIT> ) <EOL> if code != <NUM_LIT> : <EOL> print ( "<STR_LIT>" , code ) <EOL> return "<STR_LIT>" <EOL> return rsp_dict . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : <EOL> url = "<STR_LIT>" <EOL> params = { "<STR_LIT>" : receive_type } <EOL> text = answer . lstrip ( ) <EOL> msgContent = { <EOL> "<STR_LIT>" : text , <EOL> } <EOL> req = { <EOL> "<STR_LIT>" : receive_id , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : json . dumps ( msgContent ) , <EOL> } <EOL> payload = json . dumps ( req ) <EOL> headers = { <EOL> "<STR_LIT>" : "<STR_LIT>" + token , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } <EOL> response = requests . request ( <EOL> "<STR_LIT>" , url , params = params , headers = headers , data = payload <EOL> ) <EOL> def handle ( self , message ) : <EOL> event = message [ "<STR_LIT>" ] <EOL> msg = event [ "<STR_LIT>" ] <EOL> messageId = msg [ "<STR_LIT>" ] <EOL> chat_type = msg [ "<STR_LIT>" ] <EOL> sender_id = event [ "<STR_LIT>" ] [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> prompt = json . loads ( msg [ "<STR_LIT>" ] ) [ "<STR_LIT>" ] <EOL> prompt = prompt . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> message_type = msg [ "<STR_LIT>" ] <EOL> if message_type != "<STR_LIT>" : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> if chat_type == "<STR_LIT>" : <EOL> mentions = msg [ "<STR_LIT>" ] <EOL> if not mentions : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> receive_type = "<STR_LIT>" <EOL> receive_id = msg . get ( "<STR_LIT>" ) <EOL> at_id = sender_id <EOL> elif chat_type == "<STR_LIT>" : <EOL> receive_type = "<STR_LIT>" <EOL> receive_id = sender_id <EOL> at_id = None <EOL> access_token = self . get_tenant_access_token ( ) <EOL> if access_token == "<STR_LIT>" : <EOL> logger . error ( "<STR_LIT>" ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( sender_id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> self . notify_feishu ( access_token , receive_type , <EOL> receive_id , at_id , reply ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> def handle_request_url_verify ( self , post_obj ) : <EOL> challenge = post_obj . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> logger . info ( "<STR_LIT>" . format ( challenge ) ) <EOL> return { '<STR_LIT>' : challenge } <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ ) <EOL> @ http_app . route ( "<STR_LIT>" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> feishu = FeiShuChannel ( ) <EOL> logger . info ( "<STR_LIT>" . format ( str ( request . data ) ) ) <EOL> obj = json . loads ( request . data ) <EOL> if not obj : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> headers = obj . get ( "<STR_LIT>" ) <EOL> if not headers : <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> t = obj . get ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> if "<STR_LIT>" == t : <EOL> return feishu . handle_request_url_verify ( obj ) <EOL> elif headers . get ( "<STR_LIT>" , None ) == "<STR_LIT>" : <EOL> return feishu . handle ( obj ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> </s>
<s> from config import conf <EOL> import config <EOL> config . load_config ( ) <EOL> bot_token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) <EOL> print ( bot_token ) <EOL> </s>
<s> import os , time , copy <EOL> from threading import Lock <EOL> from . messagequeue import Queue <EOL> from . templates import ( <EOL> ContactList , AbstractUserDict , User , <EOL> MassivePlatform , Chatroom , ChatroomMember ) <EOL> def contact_change ( fn ) : <EOL> def _contact_change ( core , * args , ** kwargs ) : <EOL> with core . storageClass . updateLock : <EOL> return fn ( core , * args , ** kwargs ) <EOL> return _contact_change <EOL> class Storage ( object ) : <EOL> def __init__ ( self , core ) : <EOL> self . userName = None <EOL> self . nickName = None <EOL> self . updateLock = Lock ( ) <EOL> self . memberList = ContactList ( ) <EOL> self . mpList = ContactList ( ) <EOL> self . chatroomList = ContactList ( ) <EOL> self . msgList = Queue ( - <NUM_LIT> ) <EOL> self . lastInputUserName = None <EOL> self . memberList . set_default_value ( contactClass = User ) <EOL> self . memberList . core = core <EOL> self . mpList . set_default_value ( contactClass = MassivePlatform ) <EOL> self . mpList . core = core <EOL> self . chatroomList . set_default_value ( contactClass = Chatroom ) <EOL> self . chatroomList . core = core <EOL> def dumps ( self ) : <EOL> return { <EOL> '<STR_LIT>' : self . userName , <EOL> '<STR_LIT>' : self . nickName , <EOL> '<STR_LIT>' : self . memberList , <EOL> '<STR_LIT>' : self . mpList , <EOL> '<STR_LIT>' : self . chatroomList , <EOL> '<STR_LIT>' : self . lastInputUserName , } <EOL> def loads ( self , j ) : <EOL> self . userName = j . get ( '<STR_LIT>' , None ) <EOL> self . nickName = j . get ( '<STR_LIT>' , None ) <EOL> del self . memberList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . memberList . append ( i ) <EOL> del self . mpList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . mpList . append ( i ) <EOL> del self . chatroomList [ : ] <EOL> for i in j . get ( '<STR_LIT>' , [ ] ) : <EOL> self . chatroomList . append ( i ) <EOL> for chatroom in self . chatroomList : <EOL> if '<STR_LIT>' in chatroom : <EOL> for member in chatroom [ '<STR_LIT>' ] : <EOL> member . core = chatroom . core <EOL> member . chatroom = chatroom <EOL> if '<STR_LIT>' in chatroom : <EOL> chatroom [ '<STR_LIT>' ] . core = chatroom . core <EOL> chatroom [ '<STR_LIT>' ] . chatroom = chatroom <EOL> self . lastInputUserName = j . get ( '<STR_LIT>' , None ) <EOL> def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , <EOL> wechatAccount = None ) : <EOL> with self . updateLock : <EOL> if ( name or userName or remarkName or nickName or wechatAccount ) is None : <EOL> return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) <EOL> elif userName : <EOL> for m in self . memberList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> else : <EOL> matchDict = { <EOL> '<STR_LIT>' : remarkName , <EOL> '<STR_LIT>' : nickName , <EOL> '<STR_LIT>' : wechatAccount , } <EOL> for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : <EOL> if matchDict [ k ] is None : <EOL> del matchDict [ k ] <EOL> if name : <EOL> contact = [ ] <EOL> for m in self . memberList : <EOL> if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> contact . append ( m ) <EOL> else : <EOL> contact = self . memberList [ : ] <EOL> if matchDict : <EOL> friendList = [ ] <EOL> for m in contact : <EOL> if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : <EOL> friendList . append ( m ) <EOL> return copy . deepcopy ( friendList ) <EOL> else : <EOL> return copy . deepcopy ( contact ) <EOL> def search_chatrooms ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . chatroomList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> matchList = [ ] <EOL> for m in self . chatroomList : <EOL> if name in m [ '<STR_LIT>' ] : <EOL> matchList . append ( copy . deepcopy ( m ) ) <EOL> return matchList <EOL> def search_mps ( self , name = None , userName = None ) : <EOL> with self . updateLock : <EOL> if userName is not None : <EOL> for m in self . mpList : <EOL> if m [ '<STR_LIT>' ] == userName : <EOL> return copy . deepcopy ( m ) <EOL> elif name is not None : <EOL> matchList = [ ] <EOL> for m in self . mpList : <EOL> if name in m [ '<STR_LIT>' ] : <EOL> matchList . append ( copy . deepcopy ( m ) ) <EOL> return matchList <EOL> </s>
<s> import json <EOL> import os <EOL> import uuid <EOL> import requests <EOL> from curl_cffi import requests , Curl , CurlOpt <EOL> from dotenv import load_dotenv <EOL> from common . log import logger <EOL> import PyPDF2 <EOL> import docx <EOL> import re <EOL> from io import BytesIO <EOL> load_dotenv ( ) <EOL> class Client : <EOL> def __init__ ( self , cookie , use_proxy = False ) : <EOL> self . cookie = cookie <EOL> self . use_proxy = use_proxy <EOL> self . proxies = self . load_proxies_from_env ( ) <EOL> self . organization_id = self . get_organization_id ( ) <EOL> def load_proxies_from_env ( self ) : <EOL> proxies = { } <EOL> if self . use_proxy : <EOL> http_proxy = os . getenv ( '<STR_LIT>' ) <EOL> https_proxy = os . getenv ( '<STR_LIT>' ) <EOL> socks5_proxy = os . getenv ( '<STR_LIT>' ) <EOL> if http_proxy : <EOL> proxies [ '<STR_LIT>' ] = http_proxy <EOL> if https_proxy : <EOL> proxies [ '<STR_LIT>' ] = https_proxy <EOL> if socks5_proxy : <EOL> proxies [ '<STR_LIT>' ] = socks5_proxy <EOL> return proxies <EOL> def get_organization_id ( self ) : <EOL> url = "<STR_LIT>" <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> return uuid <EOL> else : <EOL> print ( f"<STR_LIT>" ) <EOL> def get_content_type ( self , file_path ) : <EOL> extension = os . path . splitext ( file_path ) [ - <NUM_LIT> ] . lower ( ) <EOL> if extension == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> elif extension == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> elif extension == '<STR_LIT>' : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return '<STR_LIT>' <EOL> def list_all_conversations ( self ) : <EOL> url = f"<STR_LIT>" <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers ) <EOL> conversations = response . json ( ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return conversations <EOL> else : <EOL> print ( f"<STR_LIT>" ) <EOL> def send_message ( self , prompt , conversation_id , attachment = None ) : <EOL> url = "<STR_LIT>" <EOL> attachments = [ ] <EOL> if attachment : <EOL> attachment_response = self . upload_attachment ( attachment ) <EOL> if attachment_response : <EOL> attachments = [ attachment_response ] <EOL> else : <EOL> return { "<STR_LIT>" } <EOL> if not attachment : <EOL> attachments = [ ] <EOL> payload = json . dumps ( { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : attachments <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = "<STR_LIT>" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . impersonate ( "<STR_LIT>" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( body . decode ( ) ) <EOL> return body <EOL> def delete_conversation ( self , conversation_id ) : <EOL> url = f"<STR_LIT>" <EOL> payload = json . dumps ( f"<STR_LIT>" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers , data = payload ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return True <EOL> else : <EOL> return False <EOL> def chat_conversation_history ( self , conversation_id ) : <EOL> url = f"<STR_LIT>" <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers , params = { '<STR_LIT>' : '<STR_LIT>' } ) <EOL> print ( type ( response ) ) <EOL> return response . json ( ) <EOL> def generate_uuid ( self ) : <EOL> random_uuid = uuid . uuid4 ( ) <EOL> random_uuid_str = str ( random_uuid ) <EOL> formatted_uuid = f"<STR_LIT>" <EOL> return formatted_uuid <EOL> def create_new_chat ( self ) : <EOL> url = f"<STR_LIT>" <EOL> uuid = self . generate_uuid ( ) <EOL> payload = json . dumps ( { "<STR_LIT>" : uuid , "<STR_LIT>" : "<STR_LIT>" } ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . cookie , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers , data = payload ) <EOL> return response . json ( ) <EOL> def reset_all ( self ) : <EOL> conversations = self . list_all_conversations ( ) <EOL> for conversation in conversations : <EOL> conversation_id = conversation [ '<STR_LIT>' ] <EOL> delete_id = self . delete_conversation ( conversation_id ) <EOL> return True <EOL> def upload_attachment ( self , file_path ) : <EOL> if file_path . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) : <EOL> file_name = os . path . basename ( file_path ) <EOL> file_size = os . path . getsize ( file_path ) <EOL> file_type = "<STR_LIT>" <EOL> file_content = "<STR_LIT>" <EOL> if file_path . endswith ( '<STR_LIT>' ) : <EOL> with open ( file_path , '<STR_LIT>' , encoding = '<STR_LIT>' ) as file : <EOL> file_content = file . read ( ) <EOL> elif file_path . endswith ( '<STR_LIT>' ) : <EOL> with open ( file_path , '<STR_LIT>' ) as file : <EOL> pdf_reader = PyPDF2 . PdfFileReader ( file ) <EOL> for page_num in range ( pdf_reader . numPages ) : <EOL> page = pdf_reader . getPage ( page_num ) <EOL> file_content += page . extractText ( ) <EOL> elif file_path . endswith ( ( '<STR_LIT>' , '<STR_LIT>' ) ) : <EOL> doc = docx . Document ( file_path ) <EOL> paragraphs = doc . paragraphs <EOL> for paragraph in paragraphs : <EOL> file_content += paragraph . text <EOL> return { <EOL> "<STR_LIT>" : file_name , <EOL> "<STR_LIT>" : file_type , <EOL> "<STR_LIT>" : file_size , <EOL> "<STR_LIT>" : file_content <EOL> } <EOL> url = '<STR_LIT>' <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> file_name = os . path . basename ( file_path ) <EOL> content_type = self . get_content_type ( file_path ) <EOL> files = { <EOL> '<STR_LIT>' : ( file_name , open ( file_path , '<STR_LIT>' ) , content_type ) , <EOL> '<STR_LIT>' : ( None , self . organization_id ) <EOL> } <EOL> response = self . send_request ( url , "<STR_LIT>" , headers = headers , files = files ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return response . json ( ) <EOL> else : <EOL> return False <EOL> def rename_chat ( self , title , conversation_id ) : <EOL> url = "<STR_LIT>" <EOL> payload = json . dumps ( { <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" <EOL> } ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> response = self . send_request ( "<STR_LIT>" , url , headers = headers , data = payload ) <EOL> if response . status_code == <NUM_LIT> : <EOL> return True <EOL> else : <EOL> return False <EOL> def send_request ( self , method , url , headers , data = None , files = None , params = None , stream = False ) : <EOL> if self . use_proxy : <EOL> return requests . request ( method , url , headers = headers , data = data , files = files , params = params , impersonate = "<STR_LIT>" , proxies = self . proxies , timeout = <NUM_LIT> ) <EOL> else : <EOL> return requests . request ( method , url , headers = headers , data = data , files = files , params = params , impersonate = "<STR_LIT>" , timeout = <NUM_LIT> ) <EOL> </s>
<s> import uuid <EOL> import json <EOL> from curl_cffi import requests <EOL> url = requests . get ( "<STR_LIT>" , impersonate = "<STR_LIT>" ) <EOL> headers = { <EOL> '<STR_LIT>' : <EOL> '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : f'<STR_LIT>' <EOL> } <EOL> proxies = { "<STR_LIT>" : "<STR_LIT>" } <EOL> response = requests . get ( "<STR_LIT>" , impersonate = "<STR_LIT>" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) <EOL> if response . status_code == <NUM_LIT> : <EOL> res = json . loads ( response . text ) <EOL> uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] <EOL> print ( f"<STR_LIT>" ) <EOL> else : <EOL> print ( f"<STR_LIT>" ) <EOL> </s>
<s> import logging <EOL> class LogSystem ( object ) : <EOL> handlerList = [ ] <EOL> showOnCmd = True <EOL> loggingLevel = logging . INFO <EOL> loggingFile = None <EOL> def __init__ ( self ) : <EOL> self . logger = logging . getLogger ( '<STR_LIT>' ) <EOL> self . logger . addHandler ( logging . NullHandler ( ) ) <EOL> self . logger . setLevel ( self . loggingLevel ) <EOL> self . cmdHandler = logging . StreamHandler ( ) <EOL> self . fileHandler = None <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> def set_logging ( self , showOnCmd = True , loggingFile = None , <EOL> loggingLevel = logging . INFO ) : <EOL> if showOnCmd != self . showOnCmd : <EOL> if showOnCmd : <EOL> self . logger . addHandler ( self . cmdHandler ) <EOL> else : <EOL> self . logger . removeHandler ( self . cmdHandler ) <EOL> self . showOnCmd = showOnCmd <EOL> if loggingFile != self . loggingFile : <EOL> if self . loggingFile is not None : <EOL> self . logger . removeHandler ( self . fileHandler ) <EOL> self . fileHandler . close ( ) <EOL> if loggingFile is not None : <EOL> self . fileHandler = logging . FileHandler ( loggingFile ) <EOL> self . logger . addHandler ( self . fileHandler ) <EOL> self . loggingFile = loggingFile <EOL> if loggingLevel != self . loggingLevel : <EOL> self . logger . setLevel ( loggingLevel ) <EOL> self . loggingLevel = loggingLevel <EOL> ls = LogSystem ( ) <EOL> set_logging = ls . set_logging <EOL> </s>
<s> import json <EOL> import hmac <EOL> import hashlib <EOL> import base64 <EOL> import time <EOL> import requests <EOL> from urllib . parse import quote_plus <EOL> from common . log import logger <EOL> from config import conf <EOL> from bridge . bridge import Bridge <EOL> from flask import Flask , request , render_template , make_response <EOL> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> class DingTalkHandler ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . access_token = None <EOL> logger . info ( "<STR_LIT>" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) <EOL> def notify_dingtalk_webhook ( self , data ) : <EOL> timestamp = round ( time . time ( ) * <NUM_LIT> ) <EOL> secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) <EOL> string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) <EOL> string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) <EOL> hmac_code = hmac . new ( secret_enc , string_to_sign_enc , <EOL> digestmod = hashlib . sha256 ) . digest ( ) <EOL> sign = quote_plus ( base64 . b64encode ( hmac_code ) ) <EOL> notify_url = f"<STR_LIT>" <EOL> try : <EOL> logger . info ( "<STR_LIT>" . format ( str ( notify_url ) ) ) <EOL> r = requests . post ( notify_url , json = data ) <EOL> reply = r . json ( ) <EOL> logger . info ( "<STR_LIT>" . format ( str ( reply ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> def get_token_internal ( self ) : <EOL> access_token_url = '<STR_LIT>' <EOL> try : <EOL> r = requests . post ( access_token_url , json = { "<STR_LIT>" : self . dingtalk_key , "<STR_LIT>" : self . dingtalk_secret } ) <EOL> except : <EOL> raise Exception ( "<STR_LIT>" ) <EOL> data = json . loads ( r . content ) <EOL> access_token = data [ '<STR_LIT>' ] <EOL> expire_in = data [ '<STR_LIT>' ] <EOL> self . access_token = access_token <EOL> self . expire_at = int ( expire_in ) + time . time ( ) <EOL> return self . access_token <EOL> def get_token ( self ) : <EOL> if self . access_token is None or self . expire_at <= time . time ( ) : <EOL> self . get_token_internal ( ) <EOL> return self . access_token <EOL> def get_post_url ( self , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == "<STR_LIT>" : <EOL> return f"<STR_LIT>" <EOL> else : <EOL> return f"<STR_LIT>" <EOL> def build_response ( self , reply , data ) : <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == "<STR_LIT>" : <EOL> return self . build_oto_response ( reply , data ) <EOL> else : <EOL> return self . build_group_response ( reply , data ) <EOL> def build_oto_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : json . dumps ( { <EOL> "<STR_LIT>" : reply <EOL> } ) , <EOL> "<STR_LIT>" : robotCode , <EOL> "<STR_LIT>" : [ staffid ] <EOL> } <EOL> return resp <EOL> def build_group_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robot_code = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : json . dumps ( { <EOL> "<STR_LIT>" : reply + "<STR_LIT>" + "<STR_LIT>" + nick <EOL> } ) , <EOL> "<STR_LIT>" : robot_code , <EOL> "<STR_LIT>" : conversation_id , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ <EOL> staffid <EOL> ] , <EOL> "<STR_LIT>" : False <EOL> } <EOL> } <EOL> return resp <EOL> def build_webhook_response ( self , reply , data ) : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> nick = data [ '<STR_LIT>' ] <EOL> staffid = data [ '<STR_LIT>' ] <EOL> robotCode = data [ '<STR_LIT>' ] <EOL> resp = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : reply <EOL> } , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ <EOL> staffid <EOL> ] , <EOL> "<STR_LIT>" : False <EOL> } <EOL> } <EOL> return resp <EOL> def chat ( self , channel , data ) : <EOL> reply = channel . handle ( data ) <EOL> type = data [ '<STR_LIT>' ] <EOL> if type == "<STR_LIT>" : <EOL> reply_json = self . build_response ( reply , data ) <EOL> self . notify_dingtalk ( data , reply_json ) <EOL> else : <EOL> reply_json = self . build_webhook_response ( reply , data ) <EOL> self . notify_dingtalk_webhook ( reply_json ) <EOL> def notify_dingtalk ( self , data , reply_json ) : <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : self . get_token ( ) <EOL> } <EOL> notify_url = self . get_post_url ( data ) <EOL> try : <EOL> r = requests . post ( notify_url , json = reply_json , headers = headers ) <EOL> resp = r . json ( ) <EOL> logger . info ( "<STR_LIT>" . format ( str ( resp ) ) ) <EOL> except Exception as e : <EOL> logger . error ( e ) <EOL> class DingTalkChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . host = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . port = conf ( ) . get ( '<STR_LIT>' ) <EOL> logger . info ( "<STR_LIT>" ) <EOL> def startup ( self ) : <EOL> http_app . run ( host = self . host , port = self . port ) <EOL> def handle ( self , data ) : <EOL> reply = "<STR_LIT>" <EOL> prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> prompt = prompt . strip ( ) <EOL> if str ( prompt ) != <NUM_LIT> : <EOL> conversation_id = data [ '<STR_LIT>' ] <EOL> sender_id = data [ '<STR_LIT>' ] <EOL> context = dict ( ) <EOL> id = sender_id <EOL> context [ '<STR_LIT>' ] = str ( id ) <EOL> reply = self . build_reply_content ( prompt , context ) <EOL> return reply <EOL> def build_reply_content ( self , query , context = None ) : <EOL> return Bridge ( ) . fetch_reply_content ( query , context ) <EOL> dd = DingTalkChannel ( ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> http_app = Flask ( __name__ , ) <EOL> @ http_app . route ( "<STR_LIT>" , methods = [ '<STR_LIT>' ] ) <EOL> def chat ( ) : <EOL> handlers = DingTalkHandler ( ) <EOL> logger . info ( "<STR_LIT>" . format ( str ( request . headers ) ) ) <EOL> logger . info ( "<STR_LIT>" . format ( str ( request . data ) ) ) <EOL> token = request . headers . get ( '<STR_LIT>' ) <EOL> data = json . loads ( request . data ) <EOL> if data : <EOL> content = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> if not content : <EOL> return <EOL> code = data [ '<STR_LIT>' ] <EOL> group_name = None <EOL> if '<STR_LIT>' in data : <EOL> group_name = data [ '<STR_LIT>' ] <EOL> handlers . chat ( dd , data ) <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> return { '<STR_LIT>' : <NUM_LIT> } <EOL> </s>
<s> import asyncio <EOL> import os , time , re , io <EOL> import threading <EOL> import json <EOL> import random <EOL> import traceback <EOL> import logging <EOL> try : <EOL> from httplib import BadStatusLine <EOL> except ImportError : <EOL> from http . client import BadStatusLine <EOL> import requests <EOL> from pyqrcode import QRCode <EOL> from . . import config , utils <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage . templates import wrap_user_dict <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_login ( core ) : <EOL> core . login = login <EOL> core . get_QRuuid = get_QRuuid <EOL> core . get_QR = get_QR <EOL> core . check_login = check_login <EOL> core . web_init = web_init <EOL> core . show_mobile_login = show_mobile_login <EOL> core . start_receiving = start_receiving <EOL> core . get_msg = get_msg <EOL> core . logout = logout <EOL> async def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , EventScanPayload = None , ScanStatus = None , event_stream = None , <EOL> loginCallback = None , exitCallback = None ) : <EOL> if self . alive or self . isLogging : <EOL> logger . warning ( '<STR_LIT>' ) <EOL> return <EOL> self . isLogging = True <EOL> while self . isLogging : <EOL> uuid = await push_login ( self ) <EOL> if uuid : <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Waiting , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' ) <EOL> self . get_QRuuid ( ) <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Waiting , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> print ( f"<STR_LIT>" ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> isLoggedIn = False <EOL> while not isLoggedIn : <EOL> status = await self . check_login ( ) <EOL> if status == '<STR_LIT>' : <EOL> isLoggedIn = True <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Scanned , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> elif status == '<STR_LIT>' : <EOL> if isLoggedIn is not None : <EOL> logger . info ( '<STR_LIT>' ) <EOL> isLoggedIn = None <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Waiting , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> elif status != '<STR_LIT>' : <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Cancel , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> break <EOL> if isLoggedIn : <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Confirmed , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> break <EOL> elif self . isLogging : <EOL> logger . info ( '<STR_LIT>' ) <EOL> payload = EventScanPayload ( <EOL> status = ScanStatus . Timeout , <EOL> qrcode = f"<STR_LIT>" <EOL> ) <EOL> event_stream . emit ( '<STR_LIT>' , payload ) <EOL> await asyncio . sleep ( <NUM_LIT> ) <EOL> else : <EOL> return <EOL> logger . info ( '<STR_LIT>' ) <EOL> await self . web_init ( ) <EOL> await self . show_mobile_login ( ) <EOL> self . get_contact ( True ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> r = await loginCallback ( self . storageClass . userName ) <EOL> else : <EOL> utils . clear_screen ( ) <EOL> if os . path . exists ( picDir or config . DEFAULT_QR ) : <EOL> os . remove ( picDir or config . DEFAULT_QR ) <EOL> logger . info ( '<STR_LIT>' % self . storageClass . nickName ) <EOL> await self . start_receiving ( exitCallback ) <EOL> self . isLogging = False <EOL> async def push_login ( core ) : <EOL> cookiesDict = core . s . cookies . get_dict ( ) <EOL> if '<STR_LIT>' in cookiesDict : <EOL> url = '<STR_LIT>' % ( <EOL> config . BASE_URL , cookiesDict [ '<STR_LIT>' ] ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , headers = headers ) . json ( ) <EOL> if '<STR_LIT>' in r and r . get ( '<STR_LIT>' ) in ( <NUM_LIT> , '<STR_LIT>' ) : <EOL> core . uuid = r [ '<STR_LIT>' ] <EOL> return r [ '<STR_LIT>' ] <EOL> return False <EOL> def get_QRuuid ( self ) : <EOL> url = '<STR_LIT>' % config . BASE_URL <EOL> params = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . get ( url , params = params , headers = headers ) <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , r . text ) <EOL> if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : <EOL> self . uuid = data . group ( <NUM_LIT> ) <EOL> return self . uuid <EOL> async def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : <EOL> uuid = uuid or self . uuid <EOL> picDir = picDir or config . DEFAULT_QR <EOL> qrStorage = io . BytesIO ( ) <EOL> qrCode = QRCode ( '<STR_LIT>' + uuid ) <EOL> qrCode . png ( qrStorage , scale = <NUM_LIT> ) <EOL> if hasattr ( qrCallback , '<STR_LIT>' ) : <EOL> await qrCallback ( uuid = uuid , status = '<STR_LIT>' , qrcode = qrStorage . getvalue ( ) ) <EOL> else : <EOL> with open ( picDir , '<STR_LIT>' ) as f : <EOL> f . write ( qrStorage . getvalue ( ) ) <EOL> if enableCmdQR : <EOL> utils . print_cmd_qr ( qrCode . text ( <NUM_LIT> ) , enableCmdQR = enableCmdQR ) <EOL> else : <EOL> utils . print_qr ( picDir ) <EOL> return qrStorage <EOL> async def check_login ( self , uuid = None ) : <EOL> uuid = uuid or self . uuid <EOL> url = '<STR_LIT>' % config . BASE_URL <EOL> localTime = int ( time . time ( ) ) <EOL> params = '<STR_LIT>' % ( <EOL> uuid , int ( - localTime / <NUM_LIT> ) , localTime ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . get ( url , params = params , headers = headers ) <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , r . text ) <EOL> if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : <EOL> if await process_login_info ( self , r . text ) : <EOL> return '<STR_LIT>' <EOL> else : <EOL> return '<STR_LIT>' <EOL> elif data : <EOL> return data . group ( <NUM_LIT> ) <EOL> else : <EOL> return '<STR_LIT>' <EOL> async def process_login_info ( core , loginContent ) : <EOL> regx = r'<STR_LIT>' <EOL> core . loginInfo [ '<STR_LIT>' ] = re . search ( regx , loginContent ) . group ( <NUM_LIT> ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : config . UOS_PATCH_CLIENT_VERSION , <EOL> '<STR_LIT>' : config . UOS_PATCH_EXTSPAM , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> r = core . s . get ( core . loginInfo [ '<STR_LIT>' ] , headers = headers , allow_redirects = False ) <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ : core . loginInfo [ '<STR_LIT>' ] . rfind ( '<STR_LIT>' ) ] <EOL> for indexUrl , detailedUrl in ( <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) , <EOL> ( "<STR_LIT>" , ( "<STR_LIT>" , "<STR_LIT>" ) ) ) : <EOL> fileUrl , syncUrl = [ '<STR_LIT>' % url for url in detailedUrl ] <EOL> if indexUrl in core . loginInfo [ '<STR_LIT>' ] : <EOL> core . loginInfo [ '<STR_LIT>' ] , core . loginInfo [ '<STR_LIT>' ] = fileUrl , syncUrl <EOL> break <EOL> else : <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] <EOL> core . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] <EOL> core . loginInfo [ '<STR_LIT>' ] = int ( time . time ( ) * <NUM_LIT> ) <EOL> core . loginInfo [ '<STR_LIT>' ] = { } <EOL> cookies = core . s . cookies . get_dict ( ) <EOL> skey = re . findall ( '<STR_LIT>' , r . text , re . S ) [ <NUM_LIT> ] <EOL> pass_ticket = re . findall ( '<STR_LIT>' , r . text , re . S ) [ <NUM_LIT> ] <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = skey <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ "<STR_LIT>" ] <EOL> core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ "<STR_LIT>" ] <EOL> core . loginInfo [ '<STR_LIT>' ] = pass_ticket <EOL> if not all ( [ key in core . loginInfo for key in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : <EOL> logger . error ( '<STR_LIT>' % r . text ) <EOL> core . isLogging = False <EOL> return False <EOL> return True <EOL> async def web_init ( self ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : int ( - time . time ( ) / <NUM_LIT> ) , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> data = { '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT , } <EOL> r = self . s . post ( url , params = params , data = json . dumps ( data ) , headers = headers ) <EOL> dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> utils . emoji_formatter ( dic [ '<STR_LIT>' ] , '<STR_LIT>' ) <EOL> self . loginInfo [ '<STR_LIT>' ] = int ( dic [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] = wrap_user_dict ( utils . struct_friend_info ( dic [ '<STR_LIT>' ] ) ) <EOL> self . memberList . append ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) <EOL> for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) <EOL> self . storageClass . userName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> self . storageClass . nickName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> contactList = dic . get ( '<STR_LIT>' , [ ] ) <EOL> chatroomList , otherList = [ ] , [ ] <EOL> for m in contactList : <EOL> if m [ '<STR_LIT>' ] != <NUM_LIT> : <EOL> otherList . append ( m ) <EOL> elif '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> m [ '<STR_LIT>' ] = [ ] <EOL> chatroomList . append ( m ) <EOL> elif '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> otherList . append ( m ) <EOL> if chatroomList : <EOL> update_local_chatrooms ( self , chatroomList ) <EOL> if otherList : <EOL> update_local_friends ( self , otherList ) <EOL> return dic <EOL> async def show_mobile_login ( self ) : <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : int ( time . time ( ) ) , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT , } <EOL> r = self . s . post ( url , data = json . dumps ( data ) , headers = headers ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> async def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : <EOL> self . alive = True <EOL> def maintain_loop ( ) : <EOL> retryCount = <NUM_LIT> <EOL> while self . alive : <EOL> try : <EOL> i = sync_check ( self ) <EOL> if i is None : <EOL> self . alive = False <EOL> elif i == '<STR_LIT>' : <EOL> pass <EOL> else : <EOL> msgList , contactList = self . get_msg ( ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : <EOL> self . msgList . put ( msg ) <EOL> if contactList : <EOL> chatroomList , otherList = [ ] , [ ] <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> chatroomList . append ( contact ) <EOL> else : <EOL> otherList . append ( contact ) <EOL> chatroomMsg = update_local_chatrooms ( self , chatroomList ) <EOL> chatroomMsg [ '<STR_LIT>' ] = self . loginInfo [ '<STR_LIT>' ] <EOL> self . msgList . put ( chatroomMsg ) <EOL> update_local_friends ( self , otherList ) <EOL> retryCount = <NUM_LIT> <EOL> except requests . exceptions . ReadTimeout : <EOL> pass <EOL> except : <EOL> retryCount += <NUM_LIT> <EOL> logger . error ( traceback . format_exc ( ) ) <EOL> if self . receivingRetryCount < retryCount : <EOL> self . alive = False <EOL> else : <EOL> time . sleep ( <NUM_LIT> ) <EOL> self . logout ( ) <EOL> if hasattr ( exitCallback , '<STR_LIT>' ) : <EOL> exitCallback ( self . storageClass . userName ) <EOL> else : <EOL> logger . info ( '<STR_LIT>' ) <EOL> if getReceivingFnOnly : <EOL> return maintain_loop <EOL> else : <EOL> maintainThread = threading . Thread ( target = maintain_loop ) <EOL> maintainThread . setDaemon ( True ) <EOL> maintainThread . start ( ) <EOL> def sync_check ( self ) : <EOL> url = '<STR_LIT>' % self . loginInfo . get ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) <EOL> params = { <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> self . loginInfo [ '<STR_LIT>' ] += <NUM_LIT> <EOL> try : <EOL> r = self . s . get ( url , params = params , headers = headers , timeout = config . TIMEOUT ) <EOL> except requests . exceptions . ConnectionError as e : <EOL> try : <EOL> if not isinstance ( e . args [ <NUM_LIT> ] . args [ <NUM_LIT> ] , BadStatusLine ) : <EOL> raise <EOL> return '<STR_LIT>' <EOL> except : <EOL> raise <EOL> r . raise_for_status ( ) <EOL> regx = r'<STR_LIT>' <EOL> pm = re . search ( regx , r . text ) <EOL> if pm is None or pm . group ( <NUM_LIT> ) != '<STR_LIT>' : <EOL> logger . debug ( '<STR_LIT>' % r . text ) <EOL> return None <EOL> return pm . group ( <NUM_LIT> ) <EOL> def get_msg ( self ) : <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] , <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : ~ int ( time . time ( ) ) , } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , data = json . dumps ( data ) , headers = headers , timeout = config . TIMEOUT ) <EOL> dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> if dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] != <NUM_LIT> : return None , None <EOL> self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) <EOL> for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) <EOL> return dic [ '<STR_LIT>' ] , dic [ '<STR_LIT>' ] <EOL> def logout ( self ) : <EOL> if self . alive : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> self . s . get ( url , params = params , headers = headers ) <EOL> self . alive = False <EOL> self . isLogging = False <EOL> self . s . cookies . clear ( ) <EOL> del self . chatroomList [ : ] <EOL> del self . memberList [ : ] <EOL> del self . mpList [ : ] <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> </s>
<s> import pickle , os <EOL> import logging <EOL> import requests <EOL> from . . config import VERSION <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_chatrooms , update_local_friends <EOL> from . messages import produce_msg <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_hotreload ( core ) : <EOL> core . dump_login_status = dump_login_status <EOL> core . load_login_status = load_login_status <EOL> def dump_login_status ( self , fileDir = None ) : <EOL> fileDir = fileDir or self . hotReloadDir <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> f . write ( '<STR_LIT>' ) <EOL> os . remove ( fileDir ) <EOL> except : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> status = { <EOL> '<STR_LIT>' : VERSION , <EOL> '<STR_LIT>' : self . loginInfo , <EOL> '<STR_LIT>' : self . s . cookies . get_dict ( ) , <EOL> '<STR_LIT>' : self . storageClass . dumps ( ) } <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> pickle . dump ( status , f ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> def load_login_status ( self , fileDir , <EOL> loginCallback = None , exitCallback = None ) : <EOL> try : <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> j = pickle . load ( f ) <EOL> except Exception as e : <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : <EOL> logger . debug ( ( '<STR_LIT>' + <EOL> '<STR_LIT>' ) % ( <EOL> j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> self . loginInfo = j [ '<STR_LIT>' ] <EOL> self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) <EOL> self . loginInfo [ '<STR_LIT>' ] . core = self <EOL> self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) <EOL> self . storageClass . loads ( j [ '<STR_LIT>' ] ) <EOL> try : <EOL> msgList , contactList = self . get_msg ( ) <EOL> except : <EOL> msgList = contactList = None <EOL> if ( msgList or contactList ) is None : <EOL> self . logout ( ) <EOL> load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if contactList : <EOL> for contact in contactList : <EOL> if '<STR_LIT>' in contact [ '<STR_LIT>' ] : <EOL> update_local_chatrooms ( self , [ contact ] ) <EOL> else : <EOL> update_local_friends ( self , [ contact ] ) <EOL> if msgList : <EOL> msgList = produce_msg ( self , msgList ) <EOL> for msg in msgList : self . msgList . put ( msg ) <EOL> self . start_receiving ( exitCallback ) <EOL> logger . debug ( '<STR_LIT>' ) <EOL> if hasattr ( loginCallback , '<STR_LIT>' ) : <EOL> loginCallback ( ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> def load_last_login_status ( session , cookiesDict ) : <EOL> try : <EOL> session . cookies = requests . utils . cookiejar_from_dict ( { <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } ) <EOL> except : <EOL> logger . info ( '<STR_LIT>' ) <EOL> logger . info ( '<STR_LIT>' ) <EOL> </s>
<s> from . contact import load_contact <EOL> from . hotreload import load_hotreload <EOL> from . login import load_login <EOL> from . messages import load_messages <EOL> from . register import load_register <EOL> def load_components ( core ) : <EOL> load_contact ( core ) <EOL> load_hotreload ( core ) <EOL> load_login ( core ) <EOL> load_messages ( core ) <EOL> load_register ( core ) <EOL> </s>
<s> import json <EOL> import os <EOL> from common . log import logger <EOL> config = { } <EOL> def load_config ( ) : <EOL> global config <EOL> config_path = "<STR_LIT>" <EOL> if not os . path . exists ( config_path ) : <EOL> raise Exception ( '<STR_LIT>' ) <EOL> config_str = read_file ( config_path ) <EOL> config = json . loads ( config_str ) <EOL> logger . info ( "<STR_LIT>" . format ( config ) ) <EOL> def get_root ( ) : <EOL> return os . path . dirname ( os . path . abspath ( __file__ ) ) <EOL> def read_file ( path ) : <EOL> with open ( path , mode = '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : <EOL> return f . read ( ) <EOL> def conf ( ) : <EOL> return config <EOL> </s>
<s> import io <EOL> import os <EOL> from dotenv import load_dotenv <EOL> from PIL import Image <EOL> def fsize ( file ) : <EOL> if isinstance ( file , io . BytesIO ) : <EOL> return file . getbuffer ( ) . nbytes <EOL> elif isinstance ( file , str ) : <EOL> return os . path . getsize ( file ) <EOL> elif hasattr ( file , "<STR_LIT>" ) and hasattr ( file , "<STR_LIT>" ) : <EOL> pos = file . tell ( ) <EOL> file . seek ( <NUM_LIT> , os . SEEK_END ) <EOL> size = file . tell ( ) <EOL> file . seek ( pos ) <EOL> return size <EOL> else : <EOL> raise TypeError ( "<STR_LIT>" ) <EOL> def compress_imgfile ( file , max_size ) : <EOL> if fsize ( file ) <= max_size : <EOL> return file <EOL> file . seek ( <NUM_LIT> ) <EOL> img = Image . open ( file ) <EOL> rgb_image = img . convert ( "<STR_LIT>" ) <EOL> quality = <NUM_LIT> <EOL> while True : <EOL> out_buf = io . BytesIO ( ) <EOL> rgb_image . save ( out_buf , "<STR_LIT>" , quality = quality ) <EOL> if fsize ( out_buf ) <= max_size : <EOL> return out_buf <EOL> quality -= <NUM_LIT> <EOL> def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) : <EOL> encoded = string . encode ( "<STR_LIT>" ) <EOL> start , end = <NUM_LIT> , <NUM_LIT> <EOL> result = [ ] <EOL> while end < len ( encoded ) : <EOL> if max_split > <NUM_LIT> and len ( result ) >= max_split : <EOL> result . append ( encoded [ start : ] . decode ( "<STR_LIT>" ) ) <EOL> break <EOL> end = min ( start + max_length , len ( encoded ) ) <EOL> while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : <EOL> end -= <NUM_LIT> <EOL> result . append ( encoded [ start : end ] . decode ( "<STR_LIT>" ) ) <EOL> start = end <EOL> return result <EOL> load_dotenv ( ) <EOL> def get_cookie ( ) : <EOL> cookie = os . getenv ( '<STR_LIT>' ) <EOL> print ( cookie ) <EOL> if not cookie : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> return cookie <EOL> def get_proxy ( ) -> bool : <EOL> isproxy = os . getenv ( '<STR_LIT>' ) <EOL> print ( isproxy ) <EOL> if not isproxy : <EOL> return False <EOL> else : <EOL> return True if isproxy . lower ( ) == '<STR_LIT>' else False <EOL> </s>
<s> from curl_cffi import requests , Curl , CurlOpt <EOL> from io import BytesIO <EOL> import json <EOL> import re <EOL> def send_message ( ) : <EOL> url = "<STR_LIT>" <EOL> attachments = [ ] <EOL> prompt = "<STR_LIT>" <EOL> organization_id = "<STR_LIT>" <EOL> conversation_id = "<STR_LIT>" <EOL> cookie = "<STR_LIT>" <EOL> proxies = "<STR_LIT>" <EOL> payload = json . dumps ( { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : attachments <EOL> } ) <EOL> headers = [ b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' , <EOL> b'<STR_LIT>' ] <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> def stream_callback ( data ) : <EOL> json_str = data . decode ( '<STR_LIT>' ) <EOL> decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) <EOL> data_strings = decoded_data . split ( '<STR_LIT>' ) <EOL> for data_string in data_strings : <EOL> json_str = data_string [ <NUM_LIT> : ] . strip ( ) <EOL> _data = json . loads ( json_str ) <EOL> if '<STR_LIT>' in _data : <EOL> buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) <EOL> print ( _data [ '<STR_LIT>' ] , end = "<STR_LIT>" ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) <EOL> c . setopt ( CurlOpt . HTTPHEADER , headers ) <EOL> c . setopt ( CurlOpt . POSTFIELDS , payload ) <EOL> c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) <EOL> c . impersonate ( "<STR_LIT>" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( body . decode ( ) ) <EOL> send_message ( ) <EOL> </s>
<s> import os , time , re , io <EOL> import json <EOL> import mimetypes , hashlib <EOL> import logging <EOL> from collections import OrderedDict <EOL> from . . import config , utils <EOL> from . . returnvalues import ReturnValue <EOL> from . . storage import templates <EOL> from . contact import update_local_uin <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> def load_messages ( core ) : <EOL> core . send_raw_msg = send_raw_msg <EOL> core . send_msg = send_msg <EOL> core . upload_file = upload_file <EOL> core . send_file = send_file <EOL> core . send_image = send_image <EOL> core . send_video = send_video <EOL> core . send = send <EOL> core . revoke = revoke <EOL> async def get_download_fn ( core , url , msgId ) : <EOL> async def download_fn ( downloadDir = None ) : <EOL> params = { <EOL> '<STR_LIT>' : msgId , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , stream = True , headers = headers ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if downloadDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( downloadDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> tempStorage . seek ( <NUM_LIT> ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } , <EOL> '<STR_LIT>' : utils . get_image_postfix ( tempStorage . read ( <NUM_LIT> ) ) , } ) <EOL> return download_fn <EOL> def produce_msg ( core , msgList ) : <EOL> rl = [ ] <EOL> srl = [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] <EOL> for m in msgList : <EOL> if m [ '<STR_LIT>' ] == core . storageClass . userName : <EOL> actualOpposite = m [ '<STR_LIT>' ] <EOL> else : <EOL> actualOpposite = m [ '<STR_LIT>' ] <EOL> if '<STR_LIT>' in m [ '<STR_LIT>' ] or '<STR_LIT>' in m [ '<STR_LIT>' ] : <EOL> produce_group_chat ( core , m ) <EOL> else : <EOL> utils . msg_formatter ( m , '<STR_LIT>' ) <EOL> if '<STR_LIT>' in actualOpposite : <EOL> m [ '<STR_LIT>' ] = core . search_chatrooms ( userName = actualOpposite ) or templates . Chatroom ( { '<STR_LIT>' : actualOpposite } ) <EOL> elif actualOpposite in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> m [ '<STR_LIT>' ] = templates . User ( { '<STR_LIT>' : actualOpposite } ) <EOL> else : <EOL> m [ '<STR_LIT>' ] = core . search_mps ( userName = actualOpposite ) or core . search_friends ( userName = actualOpposite ) or templates . User ( userName = actualOpposite ) <EOL> m [ '<STR_LIT>' ] . core = core <EOL> if m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> if m [ '<STR_LIT>' ] : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> data = '<STR_LIT>' if data is None else data . group ( <NUM_LIT> ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> else : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> or m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % ( time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' if m [ '<STR_LIT>' ] == <NUM_LIT> else '<STR_LIT>' ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> m [ '<STR_LIT>' ] [ '<STR_LIT>' ] = m [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } , } <EOL> m [ '<STR_LIT>' ] . verifyDict = msg [ '<STR_LIT>' ] <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] in ( <NUM_LIT> , <NUM_LIT> ) : <EOL> msgId = m [ '<STR_LIT>' ] <EOL> async def download_video ( videoDir = None ) : <EOL> url = '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] <EOL> params = { <EOL> '<STR_LIT>' : msgId , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , headers = headers , stream = True ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if videoDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( videoDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % time . strftime ( '<STR_LIT>' , time . localtime ( ) ) , <EOL> '<STR_LIT>' : download_video , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> if m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> rawMsg = m <EOL> cookiesList = { name : data for name , data in core . s . cookies . items ( ) } <EOL> async def download_atta ( attaDir = None ) : <EOL> url = core . loginInfo [ '<STR_LIT>' ] + '<STR_LIT>' <EOL> params = { <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : rawMsg [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : core . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : cookiesList [ '<STR_LIT>' ] , } <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> r = core . s . get ( url , params = params , stream = True , headers = headers ) <EOL> tempStorage = io . BytesIO ( ) <EOL> for block in r . iter_content ( <NUM_LIT> ) : <EOL> tempStorage . write ( block ) <EOL> if attaDir is None : <EOL> return tempStorage . getvalue ( ) <EOL> with open ( attaDir , '<STR_LIT>' ) as f : <EOL> f . write ( tempStorage . getvalue ( ) ) <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : <NUM_LIT> , } } ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : download_atta , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> download_fn = get_download_fn ( core , <EOL> '<STR_LIT>' % core . loginInfo [ '<STR_LIT>' ] , m [ '<STR_LIT>' ] ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' % ( <EOL> time . strftime ( '<STR_LIT>' , time . localtime ( ) ) ) , <EOL> '<STR_LIT>' : download_fn , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> if data : <EOL> data = data . group ( <NUM_LIT> ) . split ( u'<STR_LIT>' ) [ <NUM_LIT> ] <EOL> else : <EOL> data = '<STR_LIT>' <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> else : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = update_local_uin ( core , m ) <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : m [ '<STR_LIT>' ] , } <EOL> elif m [ '<STR_LIT>' ] == <NUM_LIT> : <EOL> regx = r'<STR_LIT>' <EOL> data = re . search ( regx , m [ '<STR_LIT>' ] ) <EOL> data = '<STR_LIT>' if data is None else data . group ( <NUM_LIT> ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : data , } <EOL> elif m [ '<STR_LIT>' ] in srl : <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> else : <EOL> logger . debug ( '<STR_LIT>' % ( m [ '<STR_LIT>' ] , str ( m ) ) ) <EOL> msg = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> m = dict ( m , ** msg ) <EOL> rl . append ( m ) <EOL> return rl <EOL> def produce_group_chat ( core , msg ) : <EOL> r = re . match ( '<STR_LIT>' , msg [ '<STR_LIT>' ] ) <EOL> if r : <EOL> actualUserName , content = r . groups ( ) <EOL> chatroomUserName = msg [ '<STR_LIT>' ] <EOL> elif msg [ '<STR_LIT>' ] == core . storageClass . userName : <EOL> actualUserName = core . storageClass . userName <EOL> content = msg [ '<STR_LIT>' ] <EOL> chatroomUserName = msg [ '<STR_LIT>' ] <EOL> else : <EOL> msg [ '<STR_LIT>' ] = core . storageClass . userName <EOL> msg [ '<STR_LIT>' ] = core . storageClass . nickName <EOL> msg [ '<STR_LIT>' ] = False <EOL> utils . msg_formatter ( msg , '<STR_LIT>' ) <EOL> return <EOL> chatroom = core . storageClass . search_chatrooms ( userName = chatroomUserName ) <EOL> member = utils . search_dict_list ( ( chatroom or { } ) . get ( <EOL> '<STR_LIT>' ) or [ ] , '<STR_LIT>' , actualUserName ) <EOL> if member is None : <EOL> chatroom = core . update_chatroom ( chatroomUserName ) <EOL> member = utils . search_dict_list ( ( chatroom or { } ) . get ( <EOL> '<STR_LIT>' ) or [ ] , '<STR_LIT>' , actualUserName ) <EOL> if member is None : <EOL> logger . debug ( '<STR_LIT>' % actualUserName ) <EOL> msg [ '<STR_LIT>' ] = '<STR_LIT>' <EOL> msg [ '<STR_LIT>' ] = False <EOL> else : <EOL> msg [ '<STR_LIT>' ] = member . get ( '<STR_LIT>' , '<STR_LIT>' ) or member [ '<STR_LIT>' ] <EOL> atFlag = '<STR_LIT>' + ( chatroom [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) or core . storageClass . nickName ) <EOL> msg [ '<STR_LIT>' ] = ( <EOL> ( atFlag + ( u'<STR_LIT>' if u'<STR_LIT>' in msg [ '<STR_LIT>' ] else '<STR_LIT>' ) ) <EOL> in msg [ '<STR_LIT>' ] or msg [ '<STR_LIT>' ] . endswith ( atFlag ) ) <EOL> msg [ '<STR_LIT>' ] = actualUserName <EOL> msg [ '<STR_LIT>' ] = content <EOL> utils . msg_formatter ( msg , '<STR_LIT>' ) <EOL> async def send_raw_msg ( self , msgType , content , toUserName ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : msgType , <EOL> '<STR_LIT>' : content , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : ( toUserName if toUserName else self . storageClass . userName ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> async def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( toUserName , msg ) ) <EOL> r = await self . send_raw_msg ( <NUM_LIT> , msg , toUserName ) <EOL> return r <EOL> def _prepare_file ( fileDir , file_ = None ) : <EOL> fileDict = { } <EOL> if file_ : <EOL> if hasattr ( file_ , '<STR_LIT>' ) : <EOL> file_ = file_ . read ( ) <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> else : <EOL> if not utils . check_file ( fileDir ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> with open ( fileDir , '<STR_LIT>' ) as f : <EOL> file_ = f . read ( ) <EOL> fileDict [ '<STR_LIT>' ] = len ( file_ ) <EOL> fileDict [ '<STR_LIT>' ] = hashlib . md5 ( file_ ) . hexdigest ( ) <EOL> fileDict [ '<STR_LIT>' ] = io . BytesIO ( file_ ) <EOL> return fileDict <EOL> def upload_file ( self , fileDir , isPicture = False , isVideo = False , <EOL> toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> '<STR_LIT>' if isPicture else '<STR_LIT>' if isVideo else '<STR_LIT>' , fileDir ) ) <EOL> if not preparedFile : <EOL> preparedFile = _prepare_file ( fileDir , file_ ) <EOL> if not preparedFile : <EOL> return preparedFile <EOL> fileSize , fileMd5 , file_ = preparedFile [ '<STR_LIT>' ] , preparedFile [ '<STR_LIT>' ] , preparedFile [ '<STR_LIT>' ] <EOL> fileSymbol = '<STR_LIT>' if isPicture else '<STR_LIT>' if isVideo else '<STR_LIT>' <EOL> chunks = int ( ( fileSize - <NUM_LIT> ) / <NUM_LIT> ) + <NUM_LIT> <EOL> clientMediaId = int ( time . time ( ) * <NUM_LIT> ) <EOL> uploadMediaRequest = json . dumps ( OrderedDict ( [ <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) , <EOL> ( '<STR_LIT>' , clientMediaId ) , <EOL> ( '<STR_LIT>' , fileSize ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , fileSize ) , <EOL> ( '<STR_LIT>' , <NUM_LIT> ) , <EOL> ( '<STR_LIT>' , self . storageClass . userName ) , <EOL> ( '<STR_LIT>' , toUserName ) , <EOL> ( '<STR_LIT>' , fileMd5 ) ] <EOL> ) , separators = ( '<STR_LIT>' , '<STR_LIT>' ) ) <EOL> r = { '<STR_LIT>' : { '<STR_LIT>' : - <NUM_LIT> , '<STR_LIT>' : '<STR_LIT>' } } <EOL> for chunk in range ( chunks ) : <EOL> r = upload_chunk_file ( self , fileDir , fileSymbol , fileSize , <EOL> file_ , chunk , chunks , uploadMediaRequest ) <EOL> file_ . close ( ) <EOL> if isinstance ( r , dict ) : <EOL> return ReturnValue ( r ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> def upload_chunk_file ( core , fileDir , fileSymbol , fileSize , <EOL> file_ , chunk , chunks , uploadMediaRequest ) : <EOL> url = core . loginInfo . get ( '<STR_LIT>' , core . loginInfo [ '<STR_LIT>' ] ) + '<STR_LIT>' <EOL> cookiesList = { name : data for name , data in core . s . cookies . items ( ) } <EOL> fileType = mimetypes . guess_type ( fileDir ) [ <NUM_LIT> ] or '<STR_LIT>' <EOL> fileName = utils . quote ( os . path . basename ( fileDir ) ) <EOL> files = OrderedDict ( [ <EOL> ( '<STR_LIT>' , ( None , '<STR_LIT>' ) ) , <EOL> ( '<STR_LIT>' , ( None , fileName ) ) , <EOL> ( '<STR_LIT>' , ( None , fileType ) ) , <EOL> ( '<STR_LIT>' , ( None , time . strftime ( '<STR_LIT>' ) ) ) , <EOL> ( '<STR_LIT>' , ( None , str ( fileSize ) ) ) , <EOL> ( '<STR_LIT>' , ( None , None ) ) , <EOL> ( '<STR_LIT>' , ( None , None ) ) , <EOL> ( '<STR_LIT>' , ( None , fileSymbol ) ) , <EOL> ( '<STR_LIT>' , ( None , uploadMediaRequest ) ) , <EOL> ( '<STR_LIT>' , ( None , cookiesList [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , ( None , core . loginInfo [ '<STR_LIT>' ] ) ) , <EOL> ( '<STR_LIT>' , ( fileName , file_ . read ( <NUM_LIT> ) , '<STR_LIT>' ) ) ] ) <EOL> if chunks == <NUM_LIT> : <EOL> del files [ '<STR_LIT>' ] ; del files [ '<STR_LIT>' ] <EOL> else : <EOL> files [ '<STR_LIT>' ] , files [ '<STR_LIT>' ] = ( None , str ( chunk ) ) , ( None , str ( chunks ) ) <EOL> headers = { '<STR_LIT>' : config . USER_AGENT } <EOL> return core . s . post ( url , files = files , headers = headers , timeout = config . TIMEOUT ) <EOL> async def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> preparedFile = _prepare_file ( fileDir , file_ ) <EOL> if not preparedFile : <EOL> return preparedFile <EOL> fileSize = preparedFile [ '<STR_LIT>' ] <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , preparedFile = preparedFile ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : ( "<STR_LIT>" % os . path . basename ( fileDir ) + <EOL> "<STR_LIT>" + <EOL> "<STR_LIT>" % ( str ( fileSize ) , mediaId ) + <EOL> "<STR_LIT>" % os . path . splitext ( fileDir ) [ <NUM_LIT> ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> async def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if fileDir or file_ : <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> file_ , fileDir = fileDir , None <EOL> if fileDir is None : <EOL> fileDir = '<STR_LIT>' <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , isPicture = not fileDir [ - <NUM_LIT> : ] == '<STR_LIT>' , file_ = file_ ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : mediaId , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> if fileDir [ - <NUM_LIT> : ] == '<STR_LIT>' : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT> <EOL> data [ '<STR_LIT>' ] [ '<STR_LIT>' ] = <NUM_LIT> <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> async def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : <EOL> logger . debug ( '<STR_LIT>' % ( <EOL> mediaId , toUserName , fileDir ) ) <EOL> if fileDir or file_ : <EOL> if hasattr ( fileDir , '<STR_LIT>' ) : <EOL> file_ , fileDir = fileDir , None <EOL> if fileDir is None : <EOL> fileDir = '<STR_LIT>' <EOL> else : <EOL> return ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> if toUserName is None : <EOL> toUserName = self . storageClass . userName <EOL> if mediaId is None : <EOL> r = self . upload_file ( fileDir , isVideo = True , file_ = file_ ) <EOL> if r : <EOL> mediaId = r [ '<STR_LIT>' ] <EOL> else : <EOL> return r <EOL> url = '<STR_LIT>' % ( <EOL> self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : <NUM_LIT> , <EOL> '<STR_LIT>' : mediaId , <EOL> '<STR_LIT>' : self . storageClass . userName , <EOL> '<STR_LIT>' : toUserName , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , <EOL> '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , } , <EOL> '<STR_LIT>' : <NUM_LIT> , } <EOL> headers = { <EOL> '<STR_LIT>' : config . USER_AGENT , <EOL> '<STR_LIT>' : '<STR_LIT>' , } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> async def send ( self , msg , toUserName = None , mediaId = None ) : <EOL> if not msg : <EOL> r = ReturnValue ( { '<STR_LIT>' : { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } } ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = await self . send_file ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = await self . send_file ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = await self . send_image ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = await self . send_image ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> r = await self . send_msg ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> elif msg [ : <NUM_LIT> ] == '<STR_LIT>' : <EOL> if mediaId is None : <EOL> r = await self . send_video ( msg [ <NUM_LIT> : ] , toUserName ) <EOL> else : <EOL> r = await self . send_video ( msg [ <NUM_LIT> : ] , toUserName , mediaId ) <EOL> else : <EOL> r = await self . send_msg ( msg , toUserName ) <EOL> return r <EOL> async def revoke ( self , msgId , toUserName , localId = None ) : <EOL> url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] <EOL> data = { <EOL> '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , <EOL> "<STR_LIT>" : localId or str ( time . time ( ) * <NUM_LIT> ) , <EOL> "<STR_LIT>" : msgId , <EOL> "<STR_LIT>" : toUserName } <EOL> headers = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : config . USER_AGENT } <EOL> r = self . s . post ( url , headers = headers , <EOL> data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) ) <EOL> return ReturnValue ( rawResponse = r ) <EOL> </s>
<s> import logging <EOL> import sys <EOL> def _reset_logger ( log ) : <EOL> for handler in log . handlers : <EOL> handler . close ( ) <EOL> log . removeHandler ( handler ) <EOL> del handler <EOL> log . handlers . clear ( ) <EOL> log . propagate = False <EOL> console_handle = logging . StreamHandler ( sys . stdout ) <EOL> console_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> "<STR_LIT>" , <EOL> datefmt = "<STR_LIT>" , <EOL> ) <EOL> ) <EOL> file_handle = logging . FileHandler ( "<STR_LIT>" , encoding = "<STR_LIT>" ) <EOL> file_handle . setFormatter ( <EOL> logging . Formatter ( <EOL> "<STR_LIT>" , <EOL> datefmt = "<STR_LIT>" , <EOL> ) <EOL> ) <EOL> log . addHandler ( file_handle ) <EOL> log . addHandler ( console_handle ) <EOL> def _get_logger ( ) : <EOL> log = logging . getLogger ( "<STR_LIT>" ) <EOL> _reset_logger ( log ) <EOL> log . setLevel ( logging . INFO ) <EOL> return log <EOL> logger = _get_logger ( ) <EOL> </s>
<s> from channel . wechat . wechat_channel import WechatChannel <EOL> from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel <EOL> from channel . qqchat . qqchat_channel import QqchaChannel <EOL> from channel . dingtalk . dingtalk_channel import DingTalkChannel <EOL> from channel . feishu . feishu_channel import FeiShuChannel <EOL> from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount <EOL> def create_channel ( channel_type ) : <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatEnterpriseChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return QqchaChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return DingTalkChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return FeiShuChannel ( ) <EOL> if channel_type == '<STR_LIT>' : <EOL> return WechatSubsribeAccount ( ) <EOL> raise RuntimeError <EOL> </s>
<s> from concurrent . futures import ThreadPoolExecutor <EOL> import io <EOL> import requests <EOL> import telebot <EOL> from common . log import logger <EOL> from channel . channel import Channel <EOL> from config import conf <EOL> bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( message ) : <EOL> bot . send_message ( message . chat . id , "<STR_LIT>" , parse_mode = "<STR_LIT>" ) <EOL> @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) <EOL> def send_welcome ( msg ) : <EOL> TelegramChannel ( ) . handle ( msg ) <EOL> class TelegramChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> pass <EOL> def startup ( self ) : <EOL> logger . info ( "<STR_LIT>" ) <EOL> bot . infinity_polling ( ) <EOL> def handle ( self , msg ) : <EOL> logger . debug ( "<STR_LIT>" + msg . text ) <EOL> thread_pool . submit ( self . _dosend , msg . text , msg ) <EOL> def _dosend ( self , query , msg ) : <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = str ( msg . chat . id ) <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> logger . info ( '<STR_LIT>' . format ( reply_text ) ) <EOL> bot . reply_to ( msg , reply_text ) <EOL> </s>
<s> import hashlib <EOL> import web <EOL> from handle import Handle <EOL> urls = ( <EOL> '<STR_LIT>' , '<STR_LIT>' , <EOL> ) <EOL> if __name__ == '<STR_LIT>' : <EOL> app = web . application ( urls , globals ( ) ) <EOL> app . run ( ) <EOL> </s>
<s> import logging <EOL> try : <EOL> import Queue as queue <EOL> except ImportError : <EOL> import queue <EOL> from . templates import AttributeDict <EOL> logger = logging . getLogger ( '<STR_LIT>' ) <EOL> class Queue ( queue . Queue ) : <EOL> def put ( self , message ) : <EOL> queue . Queue . put ( self , Message ( message ) ) <EOL> class Message ( AttributeDict ) : <EOL> def download ( self , fileName ) : <EOL> if hasattr ( self . text , '<STR_LIT>' ) : <EOL> return self . text ( fileName ) <EOL> else : <EOL> return b'<STR_LIT>' <EOL> def __getitem__ ( self , value ) : <EOL> if value in ( '<STR_LIT>' , '<STR_LIT>' ) : <EOL> v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] <EOL> logger . debug ( '<STR_LIT>' % ( value , v ) ) <EOL> value = v <EOL> return super ( Message , self ) . __getitem__ ( value ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , <EOL> self . __str__ ( ) ) <EOL> </s>
<s> import requests <EOL> from bot . bot import Bot <EOL> class BaiduUnitBot ( Bot ) : <EOL> def reply ( self , query , context = None ) : <EOL> token = self . get_token ( ) <EOL> url = '<STR_LIT>' + token <EOL> post_data = "<STR_LIT>" + query + "<STR_LIT>" <EOL> print ( post_data ) <EOL> headers = { '<STR_LIT>' : '<STR_LIT>' } <EOL> response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) <EOL> if response : <EOL> return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] <EOL> def get_token ( self ) : <EOL> access_key = '<STR_LIT>' <EOL> secret_key = '<STR_LIT>' <EOL> host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key <EOL> response = requests . get ( host ) <EOL> if response : <EOL> print ( response . json ( ) ) <EOL> return response . json ( ) [ '<STR_LIT>' ] <EOL> </s>
<s> TRANSLATE = '<STR_LIT>' <EOL> class ReturnValue ( dict ) : <EOL> def __init__ ( self , returnValueDict = { } , rawResponse = None ) : <EOL> if rawResponse : <EOL> try : <EOL> returnValueDict = rawResponse . json ( ) <EOL> except ValueError : <EOL> returnValueDict = { <EOL> '<STR_LIT>' : { <EOL> '<STR_LIT>' : - <NUM_LIT> , <EOL> '<STR_LIT>' : '<STR_LIT>' , } , <EOL> '<STR_LIT>' : rawResponse . content , } <EOL> for k , v in returnValueDict . items ( ) : <EOL> self [ k ] = v <EOL> if not '<STR_LIT>' in self : <EOL> self [ '<STR_LIT>' ] = { <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : - <NUM_LIT> , } <EOL> if TRANSLATE : <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( <EOL> self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) <EOL> self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] <EOL> def __nonzero__ ( self ) : <EOL> return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> <EOL> def __bool__ ( self ) : <EOL> return self . __nonzero__ ( ) <EOL> def __str__ ( self ) : <EOL> return '<STR_LIT>' % '<STR_LIT>' . join ( <EOL> [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) <EOL> def __repr__ ( self ) : <EOL> return '<STR_LIT>' % self . __str__ ( ) <EOL> TRANSLATION = { <EOL> '<STR_LIT>' : { <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> - <NUM_LIT> : u'<STR_LIT>' , <EOL> <NUM_LIT> : u'<STR_LIT>' , <EOL> } , <EOL> } <EOL> </s>
<s> from channel . channel import Channel <EOL> from concurrent . futures import ThreadPoolExecutor <EOL> from common . log import logger <EOL> from config import conf <EOL> import json <EOL> import requests <EOL> import io <EOL> from wechatpy . enterprise . crypto import WeChatCrypto <EOL> from wechatpy . enterprise import WeChatClient <EOL> from wechatpy . exceptions import InvalidSignatureException <EOL> from wechatpy . enterprise . exceptions import InvalidCorpIdException <EOL> from wechatpy . enterprise import parse_message <EOL> from flask import Flask , request , abort <EOL> thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) <EOL> app = Flask ( __name__ ) <EOL> @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) <EOL> def handler_msg ( ) : <EOL> return WechatEnterpriseChannel ( ) . handle ( ) <EOL> class WechatEnterpriseChannel ( Channel ) : <EOL> def __init__ ( self ) : <EOL> self . CorpId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . Secret = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . AppId = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) <EOL> self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) <EOL> self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) <EOL> logger . info ( "<STR_LIT>" . format ( <EOL> self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) <EOL> def startup ( self ) : <EOL> app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) <EOL> def send ( self , msg , receiver ) : <EOL> logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) <EOL> self . client . message . send_text ( self . AppId , receiver , msg ) <EOL> def _do_send ( self , query , reply_user_id ) : <EOL> try : <EOL> if not query : <EOL> return <EOL> context = dict ( ) <EOL> context [ '<STR_LIT>' ] = reply_user_id <EOL> reply_text = super ( ) . build_reply_content ( query , context ) <EOL> if reply_text : <EOL> self . send ( reply_text , reply_user_id ) <EOL> except Exception as e : <EOL> logger . exception ( e ) <EOL> def handle ( self ) : <EOL> query_params = request . args <EOL> signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> if request . method == '<STR_LIT>' : <EOL> echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) <EOL> try : <EOL> echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) <EOL> except InvalidSignatureException : <EOL> abort ( <NUM_LIT> ) <EOL> print ( echostr ) <EOL> return echostr <EOL> elif request . method == '<STR_LIT>' : <EOL> try : <EOL> message = self . crypto . decrypt_message ( <EOL> request . data , <EOL> signature , <EOL> timestamp , <EOL> nonce <EOL> ) <EOL> except ( InvalidSignatureException , InvalidCorpIdException ) : <EOL> abort ( <NUM_LIT> ) <EOL> msg = parse_message ( message ) <EOL> if msg . type == '<STR_LIT>' : <EOL> reply = '<STR_LIT>' <EOL> thread_pool . submit ( self . _do_send , msg . content , msg . source ) <EOL> else : <EOL> reply = '<STR_LIT>' <EOL> self . client . message . send_text ( self . AppId , msg . source , reply ) <EOL> return '<STR_LIT>' <EOL> </s>
<s> from curl_cffi import Curl , CurlOpt <EOL> from io import BytesIO <EOL> buffer = BytesIO ( ) <EOL> c = Curl ( ) <EOL> c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) <EOL> c . setopt ( CurlOpt . WRITEDATA , buffer ) <EOL> c . impersonate ( "<STR_LIT>" ) <EOL> c . perform ( ) <EOL> c . close ( ) <EOL> body = buffer . getvalue ( ) <EOL> print ( body . decode ( ) ) <EOL> </s>
