<s> package me . zhengjie . modules . security . service . dto ; import com . alibaba . fastjson . annotation . JSONField ; import lombok . AllArgsConstructor ; import lombok . Getter ; import me . zhengjie . modules . system . domain . User ; import org . springframework . security . core . userdetails . UserDetails ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Getter @ AllArgsConstructor public class JwtUserDto implements UserDetails { private final User user ; private final List < Long > dataScopes ; private final List < AuthorityDto > authorities ; public Set < String > getRoles ( ) { return authorities . stream ( ) . map ( AuthorityDto :: getAuthority ) . collect ( Collectors . toSet ( ) ) ; } @ Override @ JSONField ( serialize = false ) public String getPassword ( ) { return user . getPassword ( ) ; } @ Override @ JSONField ( serialize = false ) public String getUsername ( ) { return user . getUsername ( ) ; } @ JSONField ( serialize = false ) @ Override public boolean isAccountNonExpired ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isAccountNonLocked ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isCredentialsNonExpired ( ) { return true ; } @ Override @ JSONField ( serialize = false ) public boolean isEnabled ( ) { return user . getEnabled ( ) ; } } </s>
<s> package me . zhengjie . modules . security . service ; import cn . hutool . core . util . RandomUtil ; import me . zhengjie . modules . security . config . bean . LoginProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . StringUtils ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; @ Component public class UserCacheManager { @ Resource private RedisUtils redisUtils ; @ Value ( "<STR_LIT>" ) private long idleTime ; public JwtUserDto getUserCache ( String userName ) { if ( StringUtils . isNotEmpty ( userName ) ) { Object obj = redisUtils . get ( LoginProperties . cacheKey + userName ) ; if ( obj != null ) { return ( JwtUserDto ) obj ; } } return null ; } @ Async public void addUserCache ( String userName , JwtUserDto user ) { if ( StringUtils . isNotEmpty ( userName ) ) { long time = idleTime + RandomUtil . randomInt ( <NUM_LIT> , <NUM_LIT> ) ; redisUtils . set ( LoginProperties . cacheKey + userName , user , time ) ; } } @ Async public void cleanUserCache ( String userName ) { if ( StringUtils . isNotEmpty ( userName ) ) { redisUtils . del ( LoginProperties . cacheKey + userName ) ; } } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . Email ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Date ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class User extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" ) private Set < Role > roles ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" ) private Set < Job > jobs ; @ TableField ( value = "<STR_LIT>" ) @ ApiModelProperty ( hidden = true ) private Long deptId ; @ ApiModelProperty ( value = "<STR_LIT>" ) @ TableField ( exist = false ) private Dept dept ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String username ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String nickName ; @ Email @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String email ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String phone ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String gender ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String avatarName ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String avatarPath ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String password ; @ NotNull @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean enabled ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Boolean isAdmin = false ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Date pwdResetTime ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } User user = ( User ) o ; return Objects . equals ( id , user . id ) && Objects . equals ( username , user . username ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , username ) ; } } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . AlipayConfig ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface AliPayConfigMapper extends BaseMapper < AlipayConfig > { } </s>
<s> package me . zhengjie . modules . mnt . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . mapper . ServerMapper ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . modules . mnt . util . ExecuteShellUtil ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class ServerServiceImpl extends ServiceImpl < ServerMapper , Server > implements ServerService { private final ServerMapper serverMapper ; private final DeployServerMapper deployServerMapper ; @ Override public PageResult < Server > queryAll ( ServerQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( serverMapper . findAll ( criteria , page ) ) ; } @ Override public List < Server > queryAll ( ServerQueryCriteria criteria ) { return serverMapper . findAll ( criteria ) ; } @ Override public Server findByIp ( String ip ) { return serverMapper . findByIp ( ip ) ; } @ Override public Boolean testConnect ( Server resources ) { ExecuteShellUtil executeShellUtil = null ; try { executeShellUtil = new ExecuteShellUtil ( resources . getIp ( ) , resources . getAccount ( ) , resources . getPassword ( ) , resources . getPort ( ) ) ; return executeShellUtil . execute ( "<STR_LIT>" ) == <NUM_LIT> ; } catch ( Exception e ) { return false ; } finally { if ( executeShellUtil != null ) { executeShellUtil . close ( ) ; } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Server resources ) { save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Server resources ) { Server server = getById ( resources . getId ( ) ) ; server . copy ( resources ) ; saveOrUpdate ( server ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; deployServerMapper . deleteByServerIds ( ids ) ; } @ Override public void download ( List < Server > servers , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Server deploy : servers ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , deploy . getName ( ) ) ; map . put ( "<STR_LIT>" , deploy . getIp ( ) ) ; map . put ( "<STR_LIT>" , deploy . getPort ( ) ) ; map . put ( "<STR_LIT>" , deploy . getAccount ( ) ) ; map . put ( "<STR_LIT>" , deploy . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . config . RsaProperties ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . vo . UserPassVo ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . service . UserService ; import me . zhengjie . utils . enums . CodeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Api ( tags = "<STR_LIT>" ) @ RestController @ RequestMapping ( "<STR_LIT>" ) @ RequiredArgsConstructor public class UserController { private final PasswordEncoder passwordEncoder ; private final UserService userService ; private final DataService dataService ; private final DeptService deptService ; private final RoleService roleService ; private final VerifyService verificationCodeService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportUser ( HttpServletResponse response , UserQueryCriteria criteria ) throws IOException { userService . download ( userService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < User > > queryUser ( UserQueryCriteria criteria , Page < Object > page ) { if ( ! ObjectUtils . isEmpty ( criteria . getDeptId ( ) ) ) { criteria . getDeptIds ( ) . add ( criteria . getDeptId ( ) ) ; List < Dept > data = deptService . findByPid ( criteria . getDeptId ( ) ) ; criteria . getDeptIds ( ) . addAll ( deptService . getDeptChildren ( data ) ) ; } List < Long > dataScopes = dataService . getDeptIds ( userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ) ; if ( ! CollectionUtils . isEmpty ( criteria . getDeptIds ( ) ) && ! CollectionUtils . isEmpty ( dataScopes ) ) { criteria . getDeptIds ( ) . retainAll ( dataScopes ) ; if ( ! CollectionUtil . isEmpty ( criteria . getDeptIds ( ) ) ) { return new ResponseEntity < > ( userService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } } else { criteria . getDeptIds ( ) . addAll ( dataScopes ) ; return new ResponseEntity < > ( userService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } return new ResponseEntity < > ( PageUtil . noData ( ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createUser ( @ Validated @ RequestBody User resources ) { checkLevel ( resources ) ; resources . setPassword ( passwordEncoder . encode ( "<STR_LIT>" ) ) ; userService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateUser ( @ Validated ( User . Update . class ) @ RequestBody User resources ) throws Exception { checkLevel ( resources ) ; userService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > centerUser ( @ Validated ( User . Update . class ) @ RequestBody User resources ) { if ( ! resources . getId ( ) . equals ( SecurityUtils . getCurrentUserId ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } userService . updateCenter ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteUser ( @ RequestBody Set < Long > ids ) { for ( Long id : ids ) { Integer currentLevel = Collections . min ( roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; Integer optLevel = Collections . min ( roleService . findByUsersId ( id ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; if ( currentLevel > optLevel ) { throw new BadRequestException ( "<STR_LIT>" + userService . findById ( id ) . getUsername ( ) ) ; } } userService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > updateUserPass ( @ RequestBody UserPassVo passVo ) throws Exception { String oldPass = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , passVo . getOldPass ( ) ) ; String newPass = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , passVo . getNewPass ( ) ) ; User user = userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ; if ( ! passwordEncoder . matches ( oldPass , user . getPassword ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( passwordEncoder . matches ( newPass , user . getPassword ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } userService . updatePass ( user . getUsername ( ) , passwordEncoder . encode ( newPass ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PutMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > resetPwd ( @ RequestBody Set < Long > ids ) { String pwd = passwordEncoder . encode ( "<STR_LIT>" ) ; userService . resetPwd ( ids , pwd ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > updateUserAvatar ( @ RequestParam MultipartFile avatar ) { return new ResponseEntity < > ( userService . updateAvatar ( avatar ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > updateUserEmail ( @ PathVariable String code , @ RequestBody User resources ) throws Exception { String password = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , resources . getPassword ( ) ) ; User user = userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ; if ( ! passwordEncoder . matches ( password , user . getPassword ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } verificationCodeService . validated ( CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) + user . getEmail ( ) , code ) ; userService . updateEmail ( user . getUsername ( ) , user . getEmail ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private void checkLevel ( User resources ) { Integer currentLevel = Collections . min ( roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; Integer optLevel = roleService . findByRoles ( resources . getRoles ( ) ) ; if ( currentLevel > optLevel ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DictMapper extends BaseMapper < Dict > { List < Dict > findAll ( @ Param ( "<STR_LIT>" ) DictQueryCriteria criteria ) ; Long countAll ( @ Param ( "<STR_LIT>" ) DictQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Role ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface UserRoleMapper { void insertData ( @ Param ( "<STR_LIT>" ) Long userId , @ Param ( "<STR_LIT>" ) Set < Role > roles ) ; void deleteByUserId ( @ Param ( "<STR_LIT>" ) Long userId ) ; void deleteByUserIds ( @ Param ( "<STR_LIT>" ) Set < Long > userIds ) ; } </s>
<s> package me . zhengjie . modules . security . config . bean ; import lombok . Data ; @ Data public class SecurityProperties { private String header ; private String tokenStartWith ; private String base64Secret ; private Long tokenValidityInSeconds ; private String onlineKey ; private String codeKey ; private Long detect ; private Long renew ; public String getTokenStartWith ( ) { return tokenStartWith + "<STR_LIT>" ; } } </s>
<s> package me . zhengjie . base ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import org . apache . commons . lang3 . builder . ToStringBuilder ; import org . springframework . data . annotation . CreatedBy ; import org . springframework . data . annotation . LastModifiedBy ; import java . io . Serializable ; import java . lang . reflect . Field ; import java . sql . Timestamp ; @ Getter @ Setter public class BaseEntity implements Serializable { @ CreatedBy @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String createBy ; @ LastModifiedBy @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String updateBy ; @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Timestamp createTime ; @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Timestamp updateTime ; public @ interface Create { } public @ interface Update { } @ Override public String toString ( ) { ToStringBuilder builder = new ToStringBuilder ( this ) ; Field [ ] fields = this . getClass ( ) . getDeclaredFields ( ) ; try { for ( Field f : fields ) { f . setAccessible ( true ) ; builder . append ( f . getName ( ) , f . get ( this ) ) . append ( "<STR_LIT>" ) ; } } catch ( Exception e ) { builder . append ( "<STR_LIT>" ) ; } return builder . toString ( ) ; } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . alibaba . fastjson . annotation . JSONField ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Menu extends BaseEntity implements Serializable { @ NotNull ( groups = { Update . class } ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ JSONField ( serialize = false ) @ ApiModelProperty ( value = "<STR_LIT>" ) private Set < Role > roles ; @ TableField ( exist = false ) private List < Menu > children ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String title ; @ TableField ( value = "<STR_LIT>" ) @ ApiModelProperty ( value = "<STR_LIT>" ) private String componentName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer menuSort = <NUM_LIT> ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String component ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String path ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer type ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String permission ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String icon ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean cache ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean hidden ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Long pid ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Integer subCount = <NUM_LIT> ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean iFrame ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Menu menu = ( Menu ) o ; return Objects . equals ( id , menu . id ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id ) ; } public Boolean getHasChildren ( ) { return subCount > <NUM_LIT> ; } public Boolean getLeaf ( ) { return subCount <= <NUM_LIT> ; } public String getLabel ( ) { return title ; } } </s>
<s> package me . zhengjie . config ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Component ; @ Data @ Component public class RsaProperties { public static String privateKey ; @ Value ( "<STR_LIT>" ) public void setPrivateKey ( String privateKey ) { RsaProperties . privateKey = privateKey ; } } </s>
<s> package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Set ; @ Mapper public interface DeployMapper extends BaseMapper < Deploy > { Long countAll ( @ Param ( "<STR_LIT>" ) DeployQueryCriteria criteria ) ; List < Deploy > findAll ( @ Param ( "<STR_LIT>" ) DeployQueryCriteria criteria ) ; Set < Long > getIdByAppIds ( @ Param ( "<STR_LIT>" ) Set < Long > appIds ) ; Deploy getDeployById ( @ Param ( "<STR_LIT>" ) Long deployId ) ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . config . FileProperties ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . modules . system . mapper . UserJobMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . mapper . UserRoleMapper ; import me . zhengjie . modules . system . service . UserService ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import javax . validation . constraints . NotBlank ; import java . io . File ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class UserServiceImpl extends ServiceImpl < UserMapper , User > implements UserService { private final UserMapper userMapper ; private final UserJobMapper userJobMapper ; private final UserRoleMapper userRoleMapper ; private final FileProperties properties ; private final RedisUtils redisUtils ; private final UserCacheManager userCacheManager ; private final OnlineUserService onlineUserService ; @ Override public PageResult < User > queryAll ( UserQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < User > users = userMapper . findAll ( criteria ) ; Long total = userMapper . countAll ( criteria ) ; return PageUtil . toPage ( users , total ) ; } @ Override public List < User > queryAll ( UserQueryCriteria criteria ) { return userMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public User findById ( long id ) { return getById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( User resources ) { resources . setDeptId ( resources . getDept ( ) . getId ( ) ) ; if ( userMapper . findByUsername ( resources . getUsername ( ) ) != null ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getUsername ( ) ) ; } if ( userMapper . findByEmail ( resources . getEmail ( ) ) != null ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getEmail ( ) ) ; } if ( userMapper . findByPhone ( resources . getPhone ( ) ) != null ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getPhone ( ) ) ; } save ( resources ) ; userJobMapper . insertData ( resources . getId ( ) , resources . getJobs ( ) ) ; userRoleMapper . insertData ( resources . getId ( ) , resources . getRoles ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( User resources ) throws Exception { User user = getById ( resources . getId ( ) ) ; User user1 = userMapper . findByUsername ( resources . getUsername ( ) ) ; User user2 = userMapper . findByEmail ( resources . getEmail ( ) ) ; User user3 = userMapper . findByPhone ( resources . getPhone ( ) ) ; if ( user1 != null && ! user . getId ( ) . equals ( user1 . getId ( ) ) ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getUsername ( ) ) ; } if ( user2 != null && ! user . getId ( ) . equals ( user2 . getId ( ) ) ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getEmail ( ) ) ; } if ( user3 != null && ! user . getId ( ) . equals ( user3 . getId ( ) ) ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getPhone ( ) ) ; } if ( ! resources . getRoles ( ) . equals ( user . getRoles ( ) ) ) { redisUtils . del ( CacheKey . DATA_USER + resources . getId ( ) ) ; redisUtils . del ( CacheKey . MENU_USER + resources . getId ( ) ) ; redisUtils . del ( CacheKey . ROLE_AUTH + resources . getId ( ) ) ; } if ( ! Objects . equals ( resources . getDept ( ) , user . getDept ( ) ) ) { redisUtils . del ( CacheKey . DATA_USER + resources . getId ( ) ) ; } if ( ! resources . getEnabled ( ) ) { onlineUserService . kickOutForUsername ( resources . getUsername ( ) ) ; } user . setDeptId ( resources . getDept ( ) . getId ( ) ) ; user . setUsername ( resources . getUsername ( ) ) ; user . setEmail ( resources . getEmail ( ) ) ; user . setEnabled ( resources . getEnabled ( ) ) ; user . setRoles ( resources . getRoles ( ) ) ; user . setDept ( resources . getDept ( ) ) ; user . setJobs ( resources . getJobs ( ) ) ; user . setPhone ( resources . getPhone ( ) ) ; user . setNickName ( resources . getNickName ( ) ) ; user . setGender ( resources . getGender ( ) ) ; saveOrUpdate ( user ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; userJobMapper . deleteByUserId ( resources . getId ( ) ) ; userJobMapper . insertData ( resources . getId ( ) , resources . getJobs ( ) ) ; userRoleMapper . deleteByUserId ( resources . getId ( ) ) ; userRoleMapper . insertData ( resources . getId ( ) , resources . getRoles ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateCenter ( User resources ) { User user = getById ( resources . getId ( ) ) ; User user1 = userMapper . findByPhone ( resources . getPhone ( ) ) ; if ( user1 != null && ! user . getId ( ) . equals ( user1 . getId ( ) ) ) { throw new EntityExistException ( User . class , "<STR_LIT>" , resources . getPhone ( ) ) ; } user . setNickName ( resources . getNickName ( ) ) ; user . setPhone ( resources . getPhone ( ) ) ; user . setGender ( resources . getGender ( ) ) ; saveOrUpdate ( user ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { User user = getById ( id ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; } userMapper . deleteBatchIds ( ids ) ; userJobMapper . deleteByUserIds ( ids ) ; userRoleMapper . deleteByUserIds ( ids ) ; } @ Override public User findByName ( String userName ) { return userMapper . findByUsername ( userName ) ; } @ Override public User getLoginData ( String userName ) { User user = userMapper . findByUsername ( userName ) ; if ( user == null ) { throw new EntityNotFoundException ( User . class , "<STR_LIT>" , userName ) ; } else { return user ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updatePass ( String username , String pass ) { userMapper . updatePass ( username , pass , new Date ( ) ) ; flushCache ( username ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void resetPwd ( Set < Long > ids , String pwd ) { userMapper . resetPwd ( ids , pwd ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public Map < String , String > updateAvatar ( MultipartFile multipartFile ) { FileUtil . checkSize ( properties . getAvatarMaxSize ( ) , multipartFile . getSize ( ) ) ; String image = "<STR_LIT>" ; String fileType = FileUtil . getExtensionName ( multipartFile . getOriginalFilename ( ) ) ; if ( fileType != null && ! image . contains ( fileType ) ) { throw new BadRequestException ( "<STR_LIT>" + image + "<STR_LIT>" ) ; } User user = userMapper . findByUsername ( SecurityUtils . getCurrentUsername ( ) ) ; String oldPath = user . getAvatarPath ( ) ; File file = FileUtil . upload ( multipartFile , properties . getPath ( ) . getAvatar ( ) ) ; user . setAvatarPath ( Objects . requireNonNull ( file ) . getPath ( ) ) ; user . setAvatarName ( file . getName ( ) ) ; saveOrUpdate ( user ) ; if ( StringUtils . isNotBlank ( oldPath ) ) { FileUtil . del ( oldPath ) ; } @ NotBlank String username = user . getUsername ( ) ; flushCache ( username ) ; return new HashMap < String , String > ( <NUM_LIT> ) { { put ( "<STR_LIT>" , file . getName ( ) ) ; } } ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateEmail ( String username , String email ) { userMapper . updateEmail ( username , email ) ; flushCache ( username ) ; } @ Override public void download ( List < User > users , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( User user : users ) { List < String > roles = user . getRoles ( ) . stream ( ) . map ( Role :: getName ) . collect ( Collectors . toList ( ) ) ; Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , user . getUsername ( ) ) ; map . put ( "<STR_LIT>" , roles ) ; map . put ( "<STR_LIT>" , user . getDept ( ) . getName ( ) ) ; map . put ( "<STR_LIT>" , user . getJobs ( ) . stream ( ) . map ( Job :: getName ) . collect ( Collectors . toList ( ) ) ) ; map . put ( "<STR_LIT>" , user . getEmail ( ) ) ; map . put ( "<STR_LIT>" , user . getEnabled ( ) ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , user . getPhone ( ) ) ; map . put ( "<STR_LIT>" , user . getPwdResetTime ( ) ) ; map . put ( "<STR_LIT>" , user . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } public void delCaches ( Long id , String username ) { redisUtils . del ( CacheKey . USER_ID + id ) ; flushCache ( username ) ; } private void flushCache ( String username ) { userCacheManager . cleanUserCache ( username ) ; } } </s>
<s> package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface AppMapper extends BaseMapper < App > { IPage < App > queryAll ( @ Param ( "<STR_LIT>" ) AppQueryCriteria criteria , Page < Object > page ) ; List < App > queryAll ( @ Param ( "<STR_LIT>" ) AppQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum DataScopeEnum { ALL ( "<STR_LIT>" , "<STR_LIT>" ) , THIS_LEVEL ( "<STR_LIT>" , "<STR_LIT>" ) , CUSTOMIZE ( "<STR_LIT>" , "<STR_LIT>" ) ; private final String value ; private final String description ; public static DataScopeEnum find ( String val ) { for ( DataScopeEnum dataScopeEnum : DataScopeEnum . values ( ) ) { if ( dataScopeEnum . getValue ( ) . equals ( val ) ) { return dataScopeEnum ; } } return null ; } } </s>
<s> package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface ServerService extends IService < Server > { PageResult < Server > queryAll ( ServerQueryCriteria criteria , Page < Object > page ) ; List < Server > queryAll ( ServerQueryCriteria criteria ) ; void create ( Server resources ) ; void update ( Server resources ) ; void delete ( Set < Long > ids ) ; Server findByIp ( String ip ) ; Boolean testConnect ( Server resources ) ; void download ( List < Server > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . NoArgsConstructor ; import lombok . Setter ; import java . io . Serializable ; @ Getter @ Setter @ NoArgsConstructor @ TableName ( "<STR_LIT>" ) public class ColumnInfo implements Serializable { @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) private Long id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String tableName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String columnName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String columnType ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String keyType ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String extra ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String remark ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean notNull ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean listShow = true ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean formShow = true ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String formType ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String queryType ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String dictName ; } </s>
<s> package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . date . DatePattern ; import cn . hutool . core . date . DateUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . mapper . DeployMapper ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . service . DeployService ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . modules . mnt . util . ExecuteShellUtil ; import me . zhengjie . modules . mnt . util . ScpClientUtil ; import me . zhengjie . modules . mnt . websocket . MsgType ; import me . zhengjie . modules . mnt . websocket . SocketMsg ; import me . zhengjie . modules . mnt . websocket . WebSocketServer ; import me . zhengjie . utils . * ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Slf4j @ Service @ RequiredArgsConstructor public class DeployServiceImpl extends ServiceImpl < DeployMapper , Deploy > implements DeployService { private final String FILE_SEPARATOR = "<STR_LIT>" ; private final DeployMapper deployMapper ; private final DeployServerMapper deployServerMapper ; private final ServerService serverService ; private final DeployHistoryService deployHistoryService ; private final Integer count = <NUM_LIT> ; @ Override public PageResult < Deploy > queryAll ( DeployQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Deploy > deploys = deployMapper . findAll ( criteria ) ; Long total = deployMapper . countAll ( criteria ) ; return PageUtil . toPage ( deploys , total ) ; } @ Override public List < Deploy > queryAll ( DeployQueryCriteria criteria ) { return deployMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Deploy resources ) { resources . setAppId ( resources . getApp ( ) . getId ( ) ) ; save ( resources ) ; deployServerMapper . insertData ( resources . getId ( ) , resources . getDeploys ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Deploy resources ) { Deploy deploy = getById ( resources . getId ( ) ) ; deploy . copy ( resources ) ; saveOrUpdate ( deploy ) ; deployServerMapper . deleteByDeployId ( resources . getId ( ) ) ; deployServerMapper . insertData ( resources . getId ( ) , resources . getDeploys ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; deployServerMapper . deleteByDeployIds ( ids ) ; } @ Override public void deploy ( String fileSavePath , Long id ) { deployApp ( fileSavePath , id ) ; } private void deployApp ( String fileSavePath , Long id ) { Deploy deploy = deployMapper . getDeployById ( id ) ; if ( deploy == null ) { sendMsg ( "<STR_LIT>" , MsgType . ERROR ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } App app = deploy . getApp ( ) ; if ( app == null ) { sendMsg ( "<STR_LIT>" , MsgType . ERROR ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } int port = app . getPort ( ) ; String uploadPath = app . getUploadPath ( ) ; StringBuilder sb = new StringBuilder ( ) ; String msg ; Set < Server > deploys = deploy . getDeploys ( ) ; for ( Server server : deploys ) { String ip = server . getIp ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( ip ) ; boolean flag = checkFile ( executeShellUtil , app ) ; executeShellUtil . execute ( "<STR_LIT>" + app . getUploadPath ( ) ) ; executeShellUtil . execute ( "<STR_LIT>" + app . getBackupPath ( ) ) ; executeShellUtil . execute ( "<STR_LIT>" + app . getDeployPath ( ) ) ; msg = String . format ( "<STR_LIT>" , ip ) ; ScpClientUtil scpClientUtil = getScpClientUtil ( ip ) ; log . info ( msg ) ; sendMsg ( msg , MsgType . INFO ) ; msg = String . format ( "<STR_LIT>" , ip , uploadPath ) ; sendMsg ( msg , MsgType . INFO ) ; scpClientUtil . putFile ( fileSavePath , uploadPath ) ; if ( flag ) { sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; stopApp ( port , executeShellUtil ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; backupApp ( executeShellUtil , ip , app . getDeployPath ( ) + FILE_SEPARATOR , app . getName ( ) , app . getBackupPath ( ) + FILE_SEPARATOR , id ) ; } sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; String deployScript = app . getDeployScript ( ) ; executeShellUtil . execute ( deployScript ) ; sleep ( <NUM_LIT> ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( port , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } sb . append ( "<STR_LIT>" ) . append ( server . getName ( ) ) . append ( "<STR_LIT>" ) . append ( app . getName ( ) ) ; sendResultMsg ( result , sb ) ; executeShellUtil . close ( ) ; } } private void sleep ( int second ) { try { Thread . sleep ( second * <NUM_LIT> ) ; } catch ( InterruptedException e ) { log . error ( e . getMessage ( ) , e ) ; } } private void backupApp ( ExecuteShellUtil executeShellUtil , String ip , String fileSavePath , String appName , String backupPath , Long id ) { String deployDate = DateUtil . format ( new Date ( ) , DatePattern . PURE_DATETIME_PATTERN ) ; StringBuilder sb = new StringBuilder ( ) ; backupPath += appName + FILE_SEPARATOR + deployDate + "<STR_LIT>" ; sb . append ( "<STR_LIT>" ) . append ( backupPath ) ; sb . append ( "<STR_LIT>" ) . append ( fileSavePath ) ; sb . append ( appName ) . append ( "<STR_LIT>" ) . append ( backupPath ) ; log . info ( "<STR_LIT>" + sb . toString ( ) ) ; executeShellUtil . execute ( sb . toString ( ) ) ; DeployHistory deployHistory = new DeployHistory ( ) ; deployHistory . setAppName ( appName ) ; deployHistory . setDeployUser ( SecurityUtils . getCurrentUsername ( ) ) ; deployHistory . setIp ( ip ) ; deployHistory . setDeployId ( id ) ; deployHistoryService . create ( deployHistory ) ; } private void stopApp ( int port , ExecuteShellUtil executeShellUtil ) { executeShellUtil . execute ( String . format ( "<STR_LIT>" , port ) ) ; } private boolean checkIsRunningStatus ( int port , ExecuteShellUtil executeShellUtil ) { String result = executeShellUtil . executeForResult ( String . format ( "<STR_LIT>" , port ) ) ; return result . indexOf ( "<STR_LIT>" ) > <NUM_LIT> ; } private void sendMsg ( String msg , MsgType msgType ) { try { WebSocketServer . sendInfo ( new SocketMsg ( msg , msgType ) , "<STR_LIT>" ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } @ Override public String serverStatus ( Deploy resources ) { Set < Server > servers = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server server : servers ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( server . getIp ( ) ) ; sb . append ( "<STR_LIT>" ) . append ( server . getName ( ) ) . append ( "<STR_LIT>" ) . append ( app . getName ( ) ) ; boolean result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } else { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return "<STR_LIT>" ; } private boolean checkFile ( ExecuteShellUtil executeShellUtil , App app ) { String result = executeShellUtil . executeForResult ( "<STR_LIT>" + app . getDeployPath ( ) + "<STR_LIT>" + app . getName ( ) ) ; return result . indexOf ( app . getName ( ) ) > <NUM_LIT> ; } @ Override public String startServer ( Deploy resources ) { Set < Server > deploys = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server deploy : deploys ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( deploy . getIp ( ) ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sb . append ( "<STR_LIT>" ) . append ( deploy . getName ( ) ) . append ( "<STR_LIT>" ) . append ( app . getName ( ) ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; executeShellUtil . execute ( app . getStartScript ( ) ) ; sleep ( <NUM_LIT> ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } sendResultMsg ( result , sb ) ; log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return "<STR_LIT>" ; } @ Override public String stopServer ( Deploy resources ) { Set < Server > deploys = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server deploy : deploys ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( deploy . getIp ( ) ) ; sb . append ( "<STR_LIT>" ) . append ( deploy . getName ( ) ) . append ( "<STR_LIT>" ) . append ( app . getName ( ) ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sleep ( <NUM_LIT> ) ; boolean result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } else { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return "<STR_LIT>" ; } @ Override public String serverReduction ( DeployHistory resources ) { Long deployId = resources . getDeployId ( ) ; Deploy deployInfo = getById ( deployId ) ; String deployDate = DateUtil . format ( resources . getDeployDate ( ) , DatePattern . PURE_DATETIME_PATTERN ) ; App app = deployInfo . getApp ( ) ; if ( app == null ) { sendMsg ( "<STR_LIT>" + resources . getAppName ( ) , MsgType . ERROR ) ; throw new BadRequestException ( "<STR_LIT>" + resources . getAppName ( ) ) ; } String backupPath = app . getBackupPath ( ) + FILE_SEPARATOR ; backupPath += resources . getAppName ( ) + FILE_SEPARATOR + deployDate ; String deployPath = app . getDeployPath ( ) ; String ip = resources . getIp ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( ip ) ; String msg ; msg = String . format ( "<STR_LIT>" , ip ) ; log . info ( msg ) ; sendMsg ( msg , MsgType . INFO ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; executeShellUtil . execute ( "<STR_LIT>" + deployPath + FILE_SEPARATOR + resources . getAppName ( ) ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; executeShellUtil . execute ( "<STR_LIT>" + backupPath + "<STR_LIT>" + deployPath ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; executeShellUtil . execute ( app . getStartScript ( ) ) ; sendMsg ( "<STR_LIT>" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( "<STR_LIT>" ) . append ( ip ) . append ( "<STR_LIT>" ) . append ( resources . getAppName ( ) ) ; sendResultMsg ( result , sb ) ; executeShellUtil . close ( ) ; return "<STR_LIT>" ; } private ExecuteShellUtil getExecuteShellUtil ( String ip ) { Server server = serverService . findByIp ( ip ) ; if ( server == null ) { sendMsg ( "<STR_LIT>" + ip , MsgType . ERROR ) ; throw new BadRequestException ( "<STR_LIT>" + ip ) ; } return new ExecuteShellUtil ( ip , server . getAccount ( ) , server . getPassword ( ) , server . getPort ( ) ) ; } private ScpClientUtil getScpClientUtil ( String ip ) { Server server = serverService . findByIp ( ip ) ; if ( server == null ) { sendMsg ( "<STR_LIT>" + ip , MsgType . ERROR ) ; throw new BadRequestException ( "<STR_LIT>" + ip ) ; } return ScpClientUtil . getInstance ( ip , server . getPort ( ) , server . getAccount ( ) , server . getPassword ( ) ) ; } private void sendResultMsg ( boolean result , StringBuilder sb ) { if ( result ) { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } else { sb . append ( "<STR_LIT>" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } } @ Override public void download ( List < Deploy > deploys , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Deploy deploy : deploys ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , deploy . getApp ( ) . getName ( ) ) ; map . put ( "<STR_LIT>" , deploy . getServers ( ) ) ; map . put ( "<STR_LIT>" , deploy . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . QiniuConfig ; public interface QiNiuConfigService extends IService < QiniuConfig > { QiniuConfig getConfig ( ) ; void saveConfig ( QiniuConfig type ) ; void updateType ( String type ) ; } </s>
<s> package me . zhengjie . utils ; import org . apache . commons . codec . binary . Base64 ; import javax . crypto . Cipher ; import java . io . ByteArrayOutputStream ; import java . security . * ; import java . security . interfaces . RSAPrivateKey ; import java . security . interfaces . RSAPublicKey ; import java . security . spec . PKCS8EncodedKeySpec ; import java . security . spec . X509EncodedKeySpec ; public class RsaUtils { private static final String SRC = "<STR_LIT>" ; public static void main ( String [ ] args ) throws Exception { System . out . println ( "<STR_LIT>" ) ; RsaKeyPair keyPair = generateKeyPair ( ) ; System . out . println ( "<STR_LIT>" + keyPair . getPublicKey ( ) ) ; System . out . println ( "<STR_LIT>" + keyPair . getPrivateKey ( ) ) ; System . out . println ( "<STR_LIT>" ) ; test1 ( keyPair ) ; System . out . println ( "<STR_LIT>" ) ; test2 ( keyPair ) ; System . out . println ( "<STR_LIT>" ) ; } private static void test1 ( RsaKeyPair keyPair ) throws Exception { System . out . println ( "<STR_LIT>" ) ; String text1 = encryptByPublicKey ( keyPair . getPublicKey ( ) , RsaUtils . SRC ) ; String text2 = decryptByPrivateKey ( keyPair . getPrivateKey ( ) , text1 ) ; System . out . println ( "<STR_LIT>" + RsaUtils . SRC ) ; System . out . println ( "<STR_LIT>" + text1 ) ; System . out . println ( "<STR_LIT>" + text2 ) ; if ( RsaUtils . SRC . equals ( text2 ) ) { System . out . println ( "<STR_LIT>" ) ; } else { System . out . println ( "<STR_LIT>" ) ; } System . out . println ( "<STR_LIT>" ) ; } private static void test2 ( RsaKeyPair keyPair ) throws Exception { System . out . println ( "<STR_LIT>" ) ; String text1 = encryptByPrivateKey ( keyPair . getPrivateKey ( ) , RsaUtils . SRC ) ; String text2 = decryptByPublicKey ( keyPair . getPublicKey ( ) , text1 ) ; System . out . println ( "<STR_LIT>" + RsaUtils . SRC ) ; System . out . println ( "<STR_LIT>" + text1 ) ; System . out . println ( "<STR_LIT>" + text2 ) ; if ( RsaUtils . SRC . equals ( text2 ) ) { System . out . println ( "<STR_LIT>" ) ; } else { System . out . println ( "<STR_LIT>" ) ; } System . out . println ( "<STR_LIT>" ) ; } public static String decryptByPublicKey ( String publicKeyText , String text ) throws Exception { X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec ( Base64 . decodeBase64 ( publicKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; PublicKey publicKey = keyFactory . generatePublic ( x509EncodedKeySpec ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . DECRYPT_MODE , publicKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . DECRYPT_MODE , cipher , Base64 . decodeBase64 ( text ) ) ; return new String ( result ) ; } public static String encryptByPrivateKey ( String privateKeyText , String text ) throws Exception { PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec ( Base64 . decodeBase64 ( privateKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; PrivateKey privateKey = keyFactory . generatePrivate ( pkcs8EncodedKeySpec ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . ENCRYPT_MODE , privateKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . ENCRYPT_MODE , cipher , text . getBytes ( ) ) ; return Base64 . encodeBase64String ( result ) ; } public static String decryptByPrivateKey ( String privateKeyText , String text ) throws Exception { PKCS8EncodedKeySpec pkcs8EncodedKeySpec5 = new PKCS8EncodedKeySpec ( Base64 . decodeBase64 ( privateKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; PrivateKey privateKey = keyFactory . generatePrivate ( pkcs8EncodedKeySpec5 ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . DECRYPT_MODE , privateKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . DECRYPT_MODE , cipher , Base64 . decodeBase64 ( text ) ) ; return new String ( result ) ; } public static String encryptByPublicKey ( String publicKeyText , String text ) throws Exception { X509EncodedKeySpec x509EncodedKeySpec2 = new X509EncodedKeySpec ( Base64 . decodeBase64 ( publicKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "<STR_LIT>" ) ; PublicKey publicKey = keyFactory . generatePublic ( x509EncodedKeySpec2 ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . ENCRYPT_MODE , cipher , text . getBytes ( ) ) ; return Base64 . encodeBase64String ( result ) ; } private static byte [ ] doLongerCipherFinal ( int opMode , Cipher cipher , byte [ ] source ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; if ( opMode == Cipher . DECRYPT_MODE ) { out . write ( cipher . doFinal ( source ) ) ; } else { int offset = <NUM_LIT> ; int totalSize = source . length ; while ( totalSize - offset > <NUM_LIT> ) { int size = Math . min ( cipher . getOutputSize ( <NUM_LIT> ) - <NUM_LIT> , totalSize - offset ) ; out . write ( cipher . doFinal ( source , offset , size ) ) ; offset += size ; } } out . close ( ) ; return out . toByteArray ( ) ; } public static RsaKeyPair generateKeyPair ( ) throws NoSuchAlgorithmException { KeyPairGenerator keyPairGenerator = KeyPairGenerator . getInstance ( "<STR_LIT>" ) ; keyPairGenerator . initialize ( <NUM_LIT> ) ; KeyPair keyPair = keyPairGenerator . generateKeyPair ( ) ; RSAPublicKey rsaPublicKey = ( RSAPublicKey ) keyPair . getPublic ( ) ; RSAPrivateKey rsaPrivateKey = ( RSAPrivateKey ) keyPair . getPrivate ( ) ; String publicKeyString = Base64 . encodeBase64String ( rsaPublicKey . getEncoded ( ) ) ; String privateKeyString = Base64 . encodeBase64String ( rsaPrivateKey . getEncoded ( ) ) ; return new RsaKeyPair ( publicKeyString , privateKeyString ) ; } public static class RsaKeyPair { private final String publicKey ; private final String privateKey ; public RsaKeyPair ( String publicKey , String privateKey ) { this . publicKey = publicKey ; this . privateKey = privateKey ; } public String getPublicKey ( ) { return publicKey ; } public String getPrivateKey ( ) { return privateKey ; } } } </s>
<s> package me . zhengjie . utils ; import java . sql . Timestamp ; import java . time . * ; import java . time . format . DateTimeFormatter ; import java . util . Date ; public class DateUtil { public static final DateTimeFormatter DFY_MD_HMS = DateTimeFormatter . ofPattern ( "<STR_LIT>" ) ; public static final DateTimeFormatter DFY_MD = DateTimeFormatter . ofPattern ( "<STR_LIT>" ) ; public static Long getTimeStamp ( LocalDateTime localDateTime ) { return localDateTime . atZone ( ZoneId . systemDefault ( ) ) . toEpochSecond ( ) ; } public static LocalDateTime fromTimeStamp ( Long timeStamp ) { return LocalDateTime . ofEpochSecond ( timeStamp , <NUM_LIT> , OffsetDateTime . now ( ) . getOffset ( ) ) ; } public static Date toDate ( LocalDateTime localDateTime ) { return Date . from ( localDateTime . atZone ( ZoneId . systemDefault ( ) ) . toInstant ( ) ) ; } public static Date toDate ( LocalDate localDate ) { return toDate ( localDate . atTime ( LocalTime . now ( ZoneId . systemDefault ( ) ) ) ) ; } public static LocalDateTime toLocalDateTime ( Date date ) { return LocalDateTime . ofInstant ( date . toInstant ( ) , ZoneId . systemDefault ( ) ) ; } public static String localDateTimeFormat ( LocalDateTime localDateTime , String patten ) { DateTimeFormatter df = DateTimeFormatter . ofPattern ( patten ) ; return df . format ( localDateTime ) ; } public static String localDateTimeFormat ( LocalDateTime localDateTime , DateTimeFormatter df ) { return df . format ( localDateTime ) ; } public static String localDateTimeFormatyMdHms ( LocalDateTime localDateTime ) { return DFY_MD_HMS . format ( localDateTime ) ; } public static Timestamp getTimeStamp ( ) { return Timestamp . valueOf ( LocalDateTime . now ( ) ) ; } public String localDateTimeFormatyMd ( LocalDateTime localDateTime ) { return DFY_MD . format ( localDateTime ) ; } public static LocalDateTime parseLocalDateTimeFormat ( String localDateTime , String pattern ) { DateTimeFormatter dateTimeFormatter = DateTimeFormatter . ofPattern ( pattern ) ; return LocalDateTime . from ( dateTimeFormatter . parse ( localDateTime ) ) ; } public static LocalDateTime parseLocalDateTimeFormat ( String localDateTime , DateTimeFormatter dateTimeFormatter ) { return LocalDateTime . from ( dateTimeFormatter . parse ( localDateTime ) ) ; } public static LocalDateTime parseLocalDateTimeFormatyMdHms ( String localDateTime ) { return LocalDateTime . from ( DFY_MD_HMS . parse ( localDateTime ) ) ; } } </s>
<s> package me . zhengjie . modules . mnt . util ; import cn . hutool . core . io . IoUtil ; import com . jcraft . jsch . ChannelShell ; import com . jcraft . jsch . JSch ; import com . jcraft . jsch . Session ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . Vector ; @ Slf4j public class ExecuteShellUtil { private Vector < String > stdout ; Session session ; public ExecuteShellUtil ( final String ipAddress , final String username , final String password , int port ) { try { JSch jsch = new JSch ( ) ; session = jsch . getSession ( username , ipAddress , port ) ; session . setPassword ( password ) ; session . setConfig ( "<STR_LIT>" , "<STR_LIT>" ) ; session . connect ( <NUM_LIT> ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } public int execute ( final String command ) { int returnCode = <NUM_LIT> ; ChannelShell channel = null ; PrintWriter printWriter = null ; BufferedReader input = null ; stdout = new Vector < String > ( ) ; try { channel = ( ChannelShell ) session . openChannel ( "<STR_LIT>" ) ; channel . connect ( ) ; input = new BufferedReader ( new InputStreamReader ( channel . getInputStream ( ) ) ) ; printWriter = new PrintWriter ( channel . getOutputStream ( ) ) ; printWriter . println ( command ) ; printWriter . println ( "<STR_LIT>" ) ; printWriter . flush ( ) ; log . info ( "<STR_LIT>" ) ; String line ; while ( ( line = input . readLine ( ) ) != null ) { stdout . add ( line ) ; System . out . println ( line ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return - <NUM_LIT> ; } finally { IoUtil . close ( printWriter ) ; IoUtil . close ( input ) ; if ( channel != null ) { channel . disconnect ( ) ; } } return returnCode ; } public void close ( ) { if ( session != null ) { session . disconnect ( ) ; } } public String executeForResult ( String command ) { execute ( command ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String str : stdout ) { sb . append ( str ) ; } return sb . toString ( ) ; } } </s>
<s> package me . zhengjie . aspect ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . SysLog ; import me . zhengjie . service . SysLogService ; import me . zhengjie . utils . RequestHolder ; import me . zhengjie . utils . SecurityUtils ; import me . zhengjie . utils . StringUtils ; import me . zhengjie . utils . ThrowableUtil ; import org . aspectj . lang . JoinPoint ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . AfterThrowing ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; @ Component @ Aspect @ Slf4j public class LogAspect { private final SysLogService sysLogService ; ThreadLocal < Long > currentTime = new ThreadLocal < > ( ) ; public LogAspect ( SysLogService sysLogService ) { this . sysLogService = sysLogService ; } @ Pointcut ( "<STR_LIT>" ) public void logPointcut ( ) { } @ Around ( "<STR_LIT>" ) public Object logAround ( ProceedingJoinPoint joinPoint ) throws Throwable { Object result ; currentTime . set ( System . currentTimeMillis ( ) ) ; result = joinPoint . proceed ( ) ; SysLog sysLog = new SysLog ( "<STR_LIT>" , System . currentTimeMillis ( ) - currentTime . get ( ) ) ; currentTime . remove ( ) ; HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ; sysLogService . save ( getUsername ( ) , StringUtils . getBrowser ( request ) , StringUtils . getIp ( request ) , joinPoint , sysLog ) ; return result ; } @ AfterThrowing ( pointcut = "<STR_LIT>" , throwing = "<STR_LIT>" ) public void logAfterThrowing ( JoinPoint joinPoint , Throwable e ) { SysLog sysLog = new SysLog ( "<STR_LIT>" , System . currentTimeMillis ( ) - currentTime . get ( ) ) ; currentTime . remove ( ) ; sysLog . setExceptionDetail ( new String ( ThrowableUtil . getStackTrace ( e ) . getBytes ( ) ) ) ; HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ; sysLogService . save ( getUsername ( ) , StringUtils . getBrowser ( request ) , StringUtils . getIp ( request ) , ( ProceedingJoinPoint ) joinPoint , sysLog ) ; } public String getUsername ( ) { try { return SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception e ) { return "<STR_LIT>" ; } } } </s>
<s> package me . zhengjie . utils ; import java . io . Closeable ; public class CloseUtil { public static void close ( Closeable closeable ) { if ( null != closeable ) { try { closeable . close ( ) ; } catch ( Exception e ) { } } } public static void close ( AutoCloseable closeable ) { if ( null != closeable ) { try { closeable . close ( ) ; } catch ( Exception e ) { } } } } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface ColumnInfoMapper extends BaseMapper < ColumnInfo > { IPage < TableInfo > getTables ( @ Param ( "<STR_LIT>" ) String tableName , Page < Object > page ) ; List < ColumnInfo > findByTableNameOrderByIdAsc ( @ Param ( "<STR_LIT>" ) String tableName ) ; List < ColumnInfo > getColumns ( @ Param ( "<STR_LIT>" ) String tableName ) ; } </s>
<s> package me . zhengjie . modules . quartz . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface QuartzJobService extends IService < QuartzJob > { PageResult < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria ) ; PageResult < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria ) ; void create ( QuartzJob resources ) ; void update ( QuartzJob resources ) ; void delete ( Set < Long > ids ) ; void updateIsPause ( QuartzJob quartzJob ) ; void execution ( QuartzJob quartzJob ) ; void download ( List < QuartzJob > queryAll , HttpServletResponse response ) throws IOException ; void downloadLog ( List < QuartzLog > queryAllLog , HttpServletResponse response ) throws IOException ; void executionSubJob ( String [ ] tasks ) throws InterruptedException ; } </s>
<s> package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import org . springframework . mock . web . MockHttpServletRequest ; import java . text . SimpleDateFormat ; import java . util . Date ; import static me . zhengjie . utils . StringUtils . getIp ; import static me . zhengjie . utils . StringUtils . getWeekDay ; import static me . zhengjie . utils . StringUtils . toCamelCase ; import static me . zhengjie . utils . StringUtils . toCapitalizeCamelCase ; import static me . zhengjie . utils . StringUtils . toUnderScoreCase ; import static org . junit . jupiter . api . Assertions . assertEquals ; import static org . junit . jupiter . api . Assertions . assertNull ; public class StringUtilsTest { @ Test public void testToCamelCase ( ) { assertNull ( toCamelCase ( null ) ) ; } @ Test public void testToCapitalizeCamelCase ( ) { assertNull ( StringUtils . toCapitalizeCamelCase ( null ) ) ; assertEquals ( "<STR_LIT>" , toCapitalizeCamelCase ( "<STR_LIT>" ) ) ; } @ Test public void testToUnderScoreCase ( ) { assertNull ( StringUtils . toUnderScoreCase ( null ) ) ; assertEquals ( "<STR_LIT>" , toUnderScoreCase ( "<STR_LIT>" ) ) ; assertEquals ( "<STR_LIT>" , toUnderScoreCase ( "<STR_LIT>" ) ) ; assertEquals ( "<STR_LIT>" , toUnderScoreCase ( "<STR_LIT>" ) ) ; } @ Test public void testGetWeekDay ( ) { SimpleDateFormat simpleDateformat = new SimpleDateFormat ( "<STR_LIT>" ) ; assertEquals ( simpleDateformat . format ( new Date ( ) ) , getWeekDay ( ) ) ; } @ Test public void testGetIP ( ) { assertEquals ( "<STR_LIT>" , getIp ( new MockHttpServletRequest ( ) ) ) ; } } </s>
<s> package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . service . DeployService ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; @ RestController @ Api ( tags = "<STR_LIT>" ) @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) public class DeployController { private final String fileSavePath = FileUtil . getTmpDirPath ( ) + "<STR_LIT>" ; private final DeployService deployService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportDeployData ( HttpServletResponse response , DeployQueryCriteria criteria ) throws IOException { deployService . download ( deployService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Deploy > > queryDeployData ( DeployQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( deployService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createDeploy ( @ Validated @ RequestBody Deploy resources ) { deployService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateDeploy ( @ Validated @ RequestBody Deploy resources ) { deployService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDeploy ( @ RequestBody Set < Long > ids ) { deployService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > uploadDeploy ( @ RequestBody MultipartFile file , HttpServletRequest request ) throws Exception { Long id = Long . valueOf ( request . getParameter ( "<STR_LIT>" ) ) ; String fileName = "<STR_LIT>" ; if ( file != null ) { fileName = file . getOriginalFilename ( ) ; File deployFile = new File ( fileSavePath + fileName ) ; FileUtil . del ( deployFile ) ; file . transferTo ( deployFile ) ; deployService . deploy ( fileSavePath + fileName , id ) ; } else { System . out . println ( "<STR_LIT>" ) ; } System . out . println ( "<STR_LIT>" + Objects . requireNonNull ( file ) . getOriginalFilename ( ) ) ; Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( "<STR_LIT>" , <NUM_LIT> ) ; map . put ( "<STR_LIT>" , fileName ) ; return new ResponseEntity < > ( map , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < String > serverReduction ( @ Validated @ RequestBody DeployHistory resources ) { String result = deployService . serverReduction ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < String > serverStatus ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . serverStatus ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < String > startServer ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . startServer ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < String > stopServer ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . stopServer ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; @ Data public class DictQueryCriteria { private String blurry ; private Long offset ; private Long size ; } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . GenConfig ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; @ Mapper public interface GenConfigMapper extends BaseMapper < GenConfig > { GenConfig findByTableName ( @ Param ( "<STR_LIT>" ) String tableName ) ; } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( "<STR_LIT>" ) public class QiniuConfig implements Serializable { @ TableId ( "<STR_LIT>" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String accessKey ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String secretKey ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String bucket ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String zone ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String host ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String type = "<STR_LIT>" ; } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . EmailConfig ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface EmailConfigMapper extends BaseMapper < EmailConfig > { } </s>
<s> package me . zhengjie . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class TableInfo { private Object tableName ; private Object createTime ; private Object engine ; private Object coding ; private Object remark ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . date . BetweenFormatter . Level ; import cn . hutool . core . date . DateUtil ; import me . zhengjie . modules . system . service . MonitorService ; import me . zhengjie . utils . ElConstant ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . StringUtils ; import org . springframework . stereotype . Service ; import oshi . SystemInfo ; import oshi . hardware . * ; import oshi . software . os . FileSystem ; import oshi . software . os . OSFileStore ; import oshi . software . os . OperatingSystem ; import oshi . util . FormatUtil ; import oshi . util . Util ; import java . lang . management . ManagementFactory ; import java . text . DecimalFormat ; import java . util . * ; @ Service public class MonitorServiceImpl implements MonitorService { private final DecimalFormat df = new DecimalFormat ( "<STR_LIT>" ) ; @ Override public Map < String , Object > getServers ( ) { Map < String , Object > resultMap = new LinkedHashMap < > ( <NUM_LIT> ) ; try { SystemInfo si = new SystemInfo ( ) ; OperatingSystem os = si . getOperatingSystem ( ) ; HardwareAbstractionLayer hal = si . getHardware ( ) ; resultMap . put ( "<STR_LIT>" , getSystemInfo ( os ) ) ; resultMap . put ( "<STR_LIT>" , getCpuInfo ( hal . getProcessor ( ) ) ) ; resultMap . put ( "<STR_LIT>" , getMemoryInfo ( hal . getMemory ( ) ) ) ; resultMap . put ( "<STR_LIT>" , getSwapInfo ( hal . getMemory ( ) ) ) ; resultMap . put ( "<STR_LIT>" , getDiskInfo ( os ) ) ; resultMap . put ( "<STR_LIT>" , DateUtil . format ( new Date ( ) , "<STR_LIT>" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return resultMap ; } private Map < String , Object > getDiskInfo ( OperatingSystem os ) { Map < String , Object > diskInfo = new LinkedHashMap < > ( ) ; FileSystem fileSystem = os . getFileSystem ( ) ; List < OSFileStore > fsArray = fileSystem . getFileStores ( ) ; String osName = System . getProperty ( "<STR_LIT>" ) ; long available = <NUM_LIT> , total = <NUM_LIT> ; for ( OSFileStore fs : fsArray ) { if ( osName . toLowerCase ( ) . startsWith ( ElConstant . WIN ) ) { available += fs . getUsableSpace ( ) ; total += fs . getTotalSpace ( ) ; } else { available = fs . getUsableSpace ( ) ; total = fs . getTotalSpace ( ) ; break ; } } long used = total - available ; diskInfo . put ( "<STR_LIT>" , total > <NUM_LIT> ? FileUtil . getSize ( total ) : "<STR_LIT>" ) ; diskInfo . put ( "<STR_LIT>" , FileUtil . getSize ( available ) ) ; diskInfo . put ( "<STR_LIT>" , FileUtil . getSize ( used ) ) ; if ( total != <NUM_LIT> ) { diskInfo . put ( "<STR_LIT>" , df . format ( used / ( double ) total * <NUM_LIT> ) ) ; } else { diskInfo . put ( "<STR_LIT>" , <NUM_LIT> ) ; } return diskInfo ; } private Map < String , Object > getSwapInfo ( GlobalMemory memory ) { Map < String , Object > swapInfo = new LinkedHashMap < > ( ) ; VirtualMemory virtualMemory = memory . getVirtualMemory ( ) ; long total = virtualMemory . getSwapTotal ( ) ; long used = virtualMemory . getSwapUsed ( ) ; swapInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( total ) ) ; swapInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( used ) ) ; swapInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( total - used ) ) ; if ( used == <NUM_LIT> ) { swapInfo . put ( "<STR_LIT>" , <NUM_LIT> ) ; } else { swapInfo . put ( "<STR_LIT>" , df . format ( used / ( double ) total * <NUM_LIT> ) ) ; } return swapInfo ; } private Map < String , Object > getMemoryInfo ( GlobalMemory memory ) { Map < String , Object > memoryInfo = new LinkedHashMap < > ( ) ; memoryInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( memory . getTotal ( ) ) ) ; memoryInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( memory . getAvailable ( ) ) ) ; memoryInfo . put ( "<STR_LIT>" , FormatUtil . formatBytes ( memory . getTotal ( ) - memory . getAvailable ( ) ) ) ; memoryInfo . put ( "<STR_LIT>" , df . format ( ( memory . getTotal ( ) - memory . getAvailable ( ) ) / ( double ) memory . getTotal ( ) * <NUM_LIT> ) ) ; return memoryInfo ; } private Map < String , Object > getCpuInfo ( CentralProcessor processor ) { Map < String , Object > cpuInfo = new LinkedHashMap < > ( ) ; cpuInfo . put ( "<STR_LIT>" , processor . getProcessorIdentifier ( ) . getName ( ) ) ; cpuInfo . put ( "<STR_LIT>" , processor . getPhysicalPackageCount ( ) + "<STR_LIT>" ) ; cpuInfo . put ( "<STR_LIT>" , processor . getPhysicalProcessorCount ( ) + "<STR_LIT>" ) ; cpuInfo . put ( "<STR_LIT>" , processor . getPhysicalProcessorCount ( ) ) ; cpuInfo . put ( "<STR_LIT>" , processor . getLogicalProcessorCount ( ) + "<STR_LIT>" ) ; long [ ] prevTicks = processor . getSystemCpuLoadTicks ( ) ; long time = <NUM_LIT> ; Util . sleep ( time ) ; long [ ] ticks = processor . getSystemCpuLoadTicks ( ) ; while ( Arrays . toString ( prevTicks ) . equals ( Arrays . toString ( ticks ) ) && time < <NUM_LIT> ) { time += <NUM_LIT> ; Util . sleep ( <NUM_LIT> ) ; ticks = processor . getSystemCpuLoadTicks ( ) ; } long user = ticks [ CentralProcessor . TickType . USER . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . USER . getIndex ( ) ] ; long nice = ticks [ CentralProcessor . TickType . NICE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . NICE . getIndex ( ) ] ; long sys = ticks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] ; long idle = ticks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] ; long iowait = ticks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] ; long irq = ticks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] ; long softirq = ticks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] ; long steal = ticks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] ; long totalCpu = user + nice + sys + idle + iowait + irq + softirq + steal ; cpuInfo . put ( "<STR_LIT>" , df . format ( <NUM_LIT> * user / totalCpu + <NUM_LIT> * sys / totalCpu ) ) ; cpuInfo . put ( "<STR_LIT>" , df . format ( <NUM_LIT> * idle / totalCpu ) ) ; return cpuInfo ; } private Map < String , Object > getSystemInfo ( OperatingSystem os ) { Map < String , Object > systemInfo = new LinkedHashMap < > ( ) ; long time = ManagementFactory . getRuntimeMXBean ( ) . getStartTime ( ) ; Date date = new Date ( time ) ; String formatBetween = DateUtil . formatBetween ( date , new Date ( ) , Level . HOUR ) ; systemInfo . put ( "<STR_LIT>" , os . toString ( ) ) ; systemInfo . put ( "<STR_LIT>" , formatBetween ) ; systemInfo . put ( "<STR_LIT>" , StringUtils . getLocalIp ( ) ) ; return systemInfo ; } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Dict extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) private Long id ; @ TableField ( exist = false ) private List < DictDetail > dictDetails ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String description ; } </s>
<s> package me . zhengjie . aspect ; public enum LimitType { CUSTOMER , IP } </s>
<s> package me . zhengjie . utils ; import javax . crypto . Cipher ; import javax . crypto . SecretKey ; import javax . crypto . SecretKeyFactory ; import javax . crypto . spec . DESKeySpec ; import javax . crypto . spec . IvParameterSpec ; import java . nio . charset . StandardCharsets ; public class EncryptUtils { private static final String STR_PARAM = "<STR_LIT>" ; private static Cipher cipher ; private static final IvParameterSpec IV = new IvParameterSpec ( STR_PARAM . getBytes ( StandardCharsets . UTF_8 ) ) ; private static DESKeySpec getDesKeySpec ( String source ) throws Exception { if ( source == null || source . length ( ) == <NUM_LIT> ) { return null ; } cipher = Cipher . getInstance ( "<STR_LIT>" ) ; String strKey = "<STR_LIT>" ; return new DESKeySpec ( strKey . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static String desEncrypt ( String source ) throws Exception { DESKeySpec desKeySpec = getDesKeySpec ( source ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "<STR_LIT>" ) ; SecretKey secretKey = keyFactory . generateSecret ( desKeySpec ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey , IV ) ; return byte2hex ( cipher . doFinal ( source . getBytes ( StandardCharsets . UTF_8 ) ) ) . toUpperCase ( ) ; } public static String desDecrypt ( String source ) throws Exception { byte [ ] src = hex2byte ( source . getBytes ( StandardCharsets . UTF_8 ) ) ; DESKeySpec desKeySpec = getDesKeySpec ( source ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "<STR_LIT>" ) ; SecretKey secretKey = keyFactory . generateSecret ( desKeySpec ) ; cipher . init ( Cipher . DECRYPT_MODE , secretKey , IV ) ; byte [ ] retByte = cipher . doFinal ( src ) ; return new String ( retByte ) ; } private static String byte2hex ( byte [ ] inStr ) { String stmp ; StringBuilder out = new StringBuilder ( inStr . length * <NUM_LIT> ) ; for ( byte b : inStr ) { stmp = Integer . toHexString ( b & <NUM_LIT> ) ; if ( stmp . length ( ) == <NUM_LIT> ) { out . append ( "<STR_LIT>" ) . append ( stmp ) ; } else { out . append ( stmp ) ; } } return out . toString ( ) ; } private static byte [ ] hex2byte ( byte [ ] b ) { int size = <NUM_LIT> ; if ( ( b . length % size ) != <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } byte [ ] b2 = new byte [ b . length / <NUM_LIT> ] ; for ( int n = <NUM_LIT> ; n < b . length ; n += size ) { String item = new String ( b , n , <NUM_LIT> ) ; b2 [ n / <NUM_LIT> ] = ( byte ) Integer . parseInt ( item , <NUM_LIT> ) ; } return b2 ; } } </s>
<s> package me . zhengjie . modules . system . service . impl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class DataServiceImpl implements DataService { private final RoleService roleService ; private final DeptService deptService ; @ Override @ Cacheable ( key = "<STR_LIT>" ) public List < Long > getDeptIds ( User user ) { Set < Long > deptIds = new HashSet < > ( ) ; List < Role > roleList = roleService . findByUsersId ( user . getId ( ) ) ; for ( Role role : roleList ) { DataScopeEnum dataScopeEnum = DataScopeEnum . find ( role . getDataScope ( ) ) ; switch ( Objects . requireNonNull ( dataScopeEnum ) ) { case THIS_LEVEL : deptIds . add ( user . getDept ( ) . getId ( ) ) ; break ; case CUSTOMIZE : deptIds . addAll ( getCustomize ( deptIds , role ) ) ; break ; default : return new ArrayList < > ( ) ; } } return new ArrayList < > ( deptIds ) ; } public Set < Long > getCustomize ( Set < Long > deptIds , Role role ) { Set < Dept > depts = deptService . findByRoleId ( role . getId ( ) ) ; for ( Dept dept : depts ) { deptIds . add ( dept . getId ( ) ) ; List < Dept > deptChildren = deptService . findByPid ( dept . getId ( ) ) ; if ( deptChildren != null && deptChildren . size ( ) != <NUM_LIT> ) { deptIds . addAll ( deptService . getDeptChildren ( deptChildren ) ) ; } } return deptIds ; } } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class MenuQueryCriteria { private String blurry ; private List < Timestamp > createTime ; private Boolean pidIsNull ; private Long pid ; } </s>
<s> package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import me . zhengjie . modules . system . service . MenuService ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . util . * ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class MenuController { private final MenuService menuService ; private static final String ENTITY_NAME = "<STR_LIT>" ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportMenu ( HttpServletResponse response , MenuQueryCriteria criteria ) throws Exception { menuService . download ( menuService . queryAll ( criteria , false ) , response ) ; } @ GetMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < List < MenuVo > > buildMenus ( ) { List < Menu > menuList = menuService . findByUser ( SecurityUtils . getCurrentUserId ( ) ) ; List < Menu > menus = menuService . buildTree ( menuList ) ; return new ResponseEntity < > ( menuService . buildMenus ( menus ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < List < Menu > > queryAllMenu ( @ RequestParam Long pid ) { return new ResponseEntity < > ( menuService . getMenus ( pid ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > childMenu ( @ RequestParam Long id ) { Set < Menu > menuSet = new HashSet < > ( ) ; List < Menu > menuList = menuService . getMenus ( id ) ; menuSet . add ( menuService . getById ( id ) ) ; menuSet = menuService . getChildMenus ( menuList , menuSet ) ; Set < Long > ids = menuSet . stream ( ) . map ( Menu :: getId ) . collect ( Collectors . toSet ( ) ) ; return new ResponseEntity < > ( ids , HttpStatus . OK ) ; } @ GetMapping @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Menu > > queryMenu ( MenuQueryCriteria criteria ) throws Exception { List < Menu > menuList = menuService . queryAll ( criteria , true ) ; return new ResponseEntity < > ( PageUtil . toPage ( menuList ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < List < Menu > > getMenuSuperior ( @ RequestBody List < Long > ids ) { Set < Menu > menus = new LinkedHashSet < > ( ) ; if ( CollectionUtil . isNotEmpty ( ids ) ) { for ( Long id : ids ) { Menu menu = menuService . findById ( id ) ; List < Menu > menuList = menuService . getSuperior ( menu , new ArrayList < > ( ) ) ; for ( Menu data : menuList ) { if ( data . getId ( ) . equals ( menu . getPid ( ) ) ) { data . setSubCount ( data . getSubCount ( ) - <NUM_LIT> ) ; } } menus . addAll ( menuList ) ; } menus = menus . stream ( ) . filter ( i -> ! ids . contains ( i . getId ( ) ) ) . collect ( Collectors . toSet ( ) ) ; return new ResponseEntity < > ( menuService . buildTree ( new ArrayList < > ( menus ) ) , HttpStatus . OK ) ; } return new ResponseEntity < > ( menuService . getMenus ( null ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createMenu ( @ Validated @ RequestBody Menu resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } menuService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateMenu ( @ Validated ( Menu . Update . class ) @ RequestBody Menu resources ) { menuService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteMenu ( @ RequestBody Set < Long > ids ) { Set < Menu > menuSet = new HashSet < > ( ) ; for ( Long id : ids ) { List < Menu > menuList = menuService . getMenus ( id ) ; menuSet . add ( menuService . getById ( id ) ) ; menuSet = menuService . getChildMenus ( menuList , menuSet ) ; } menuService . delete ( menuSet ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . mapper . GenConfigMapper ; import me . zhengjie . service . GenConfigService ; import org . springframework . stereotype . Service ; import java . io . File ; @ Service @ RequiredArgsConstructor @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public class GenConfigServiceImpl extends ServiceImpl < GenConfigMapper , GenConfig > implements GenConfigService { private final GenConfigMapper genConfigMapper ; @ Override public GenConfig find ( String tableName ) { GenConfig genConfig = genConfigMapper . findByTableName ( tableName ) ; if ( genConfig == null ) { return new GenConfig ( tableName ) ; } return genConfig ; } @ Override public GenConfig update ( String tableName , GenConfig genConfig ) { String separator = File . separator ; String [ ] paths ; String symbol = "<STR_LIT>" ; if ( symbol . equals ( separator ) ) { paths = genConfig . getPath ( ) . split ( "<STR_LIT>" ) ; } else { paths = genConfig . getPath ( ) . split ( File . separator ) ; } StringBuilder api = new StringBuilder ( ) ; for ( String path : paths ) { api . append ( path ) ; api . append ( separator ) ; if ( "<STR_LIT>" . equals ( path ) ) { api . append ( "<STR_LIT>" ) ; break ; } } genConfig . setApiPath ( api . toString ( ) ) ; saveOrUpdate ( genConfig ) ; return genConfig ; } } </s>
<s> package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeployService extends IService < Deploy > { PageResult < Deploy > queryAll ( DeployQueryCriteria criteria , Page < Object > page ) ; List < Deploy > queryAll ( DeployQueryCriteria criteria ) ; void create ( Deploy resources ) ; void update ( Deploy resources ) ; void delete ( Set < Long > ids ) ; void deploy ( String fileSavePath , Long appId ) ; String serverStatus ( Deploy resources ) ; String startServer ( Deploy resources ) ; String stopServer ( Deploy resources ) ; String serverReduction ( DeployHistory resources ) ; void download ( List < Deploy > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . security . security ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . web . AuthenticationEntryPoint ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Component public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint { @ Override public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) throws IOException { response . sendError ( HttpServletResponse . SC_UNAUTHORIZED , authException == null ? "<STR_LIT>" : authException . getMessage ( ) ) ; } } </s>
<s> package me . zhengjie . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface Log { String value ( ) default "<STR_LIT>" ; } </s>
<s> package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class LocalStorageQueryCriteria { private String blurry ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . service . impl ; import cn . hutool . extra . mail . Mail ; import cn . hutool . extra . mail . MailAccount ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . EmailConfig ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . EmailConfigMapper ; import me . zhengjie . service . EmailService ; import me . zhengjie . utils . EncryptUtils ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CachePut ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class EmailServiceImpl extends ServiceImpl < EmailConfigMapper , EmailConfig > implements EmailService { @ Override @ CachePut ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public EmailConfig config ( EmailConfig emailConfig , EmailConfig old ) throws Exception { emailConfig . setId ( <NUM_LIT> ) ; if ( ! emailConfig . getPass ( ) . equals ( old . getPass ( ) ) ) { emailConfig . setPass ( EncryptUtils . desEncrypt ( emailConfig . getPass ( ) ) ) ; } saveOrUpdate ( emailConfig ) ; return emailConfig ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public EmailConfig find ( ) { EmailConfig emailConfig = getById ( <NUM_LIT> ) ; return emailConfig == null ? new EmailConfig ( ) : emailConfig ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void send ( EmailVo emailVo , EmailConfig emailConfig ) { if ( emailConfig . getId ( ) == null ) { throw new BadRequestException ( "<STR_LIT>" ) ; } MailAccount account = new MailAccount ( ) ; String user = emailConfig . getFromUser ( ) . split ( "<STR_LIT>" ) [ <NUM_LIT> ] ; account . setUser ( user ) ; account . setHost ( emailConfig . getHost ( ) ) ; account . setPort ( Integer . parseInt ( emailConfig . getPort ( ) ) ) ; account . setAuth ( true ) ; try { account . setPass ( EncryptUtils . desDecrypt ( emailConfig . getPass ( ) ) ) ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } account . setFrom ( emailConfig . getUser ( ) + "<STR_LIT>" + emailConfig . getFromUser ( ) + "<STR_LIT>" ) ; account . setSslEnable ( true ) ; account . setStarttlsEnable ( true ) ; account . setSslProtocols ( "<STR_LIT>" ) ; String content = emailVo . getContent ( ) ; try { int size = emailVo . getTos ( ) . size ( ) ; Mail . create ( account ) . setTos ( emailVo . getTos ( ) . toArray ( new String [ size ] ) ) . setTitle ( emailVo . getSubject ( ) ) . setContent ( content ) . setHtml ( true ) . setUseGlobalSession ( false ) . send ( ) ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } } } </s>
<s> package me . zhengjie . modules . security . security ; import cn . hutool . core . date . DateField ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . crypto . digest . DigestUtil ; import io . jsonwebtoken . * ; import io . jsonwebtoken . io . Decoders ; import io . jsonwebtoken . security . Keys ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . utils . RedisUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . userdetails . User ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . security . Key ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Slf4j @ Component public class TokenProvider implements InitializingBean { private final SecurityProperties properties ; private final RedisUtils redisUtils ; public static final String AUTHORITIES_KEY = "<STR_LIT>" ; private JwtParser jwtParser ; private JwtBuilder jwtBuilder ; public TokenProvider ( SecurityProperties properties , RedisUtils redisUtils ) { this . properties = properties ; this . redisUtils = redisUtils ; } @ Override public void afterPropertiesSet ( ) { byte [ ] keyBytes = Decoders . BASE64 . decode ( properties . getBase64Secret ( ) ) ; Key key = Keys . hmacShaKeyFor ( keyBytes ) ; jwtParser = Jwts . parserBuilder ( ) . setSigningKey ( key ) . build ( ) ; jwtBuilder = Jwts . builder ( ) . signWith ( key , SignatureAlgorithm . HS512 ) ; } public String createToken ( Authentication authentication ) { return jwtBuilder . setId ( IdUtil . simpleUUID ( ) ) . claim ( AUTHORITIES_KEY , authentication . getName ( ) ) . setSubject ( authentication . getName ( ) ) . compact ( ) ; } Authentication getAuthentication ( String token ) { Claims claims = getClaims ( token ) ; User principal = new User ( claims . getSubject ( ) , "<STR_LIT>" , new ArrayList < > ( ) ) ; return new UsernamePasswordAuthenticationToken ( principal , token , new ArrayList < > ( ) ) ; } public Claims getClaims ( String token ) { return jwtParser . parseClaimsJws ( token ) . getBody ( ) ; } public void checkRenewal ( String token ) { String loginKey = loginKey ( token ) ; long time = redisUtils . getExpire ( loginKey ) * <NUM_LIT> ; Date expireDate = DateUtil . offset ( new Date ( ) , DateField . MILLISECOND , ( int ) time ) ; long differ = expireDate . getTime ( ) - System . currentTimeMillis ( ) ; if ( differ <= properties . getDetect ( ) ) { long renew = time + properties . getRenew ( ) ; redisUtils . expire ( loginKey , renew , TimeUnit . MILLISECONDS ) ; } } public String getToken ( HttpServletRequest request ) { final String requestHeader = request . getHeader ( properties . getHeader ( ) ) ; if ( requestHeader != null && requestHeader . startsWith ( properties . getTokenStartWith ( ) ) ) { return requestHeader . substring ( <NUM_LIT> ) ; } return null ; } public String loginKey ( String token ) { Claims claims = getClaims ( token ) ; String md5Token = DigestUtil . md5Hex ( token ) ; return properties . getOnlineKey ( ) + claims . getSubject ( ) + "<STR_LIT>" + md5Token ; } } </s>
<s> package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . service . GenConfigService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class GenConfigController { private final GenConfigService genConfigService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < GenConfig > queryGenConfig ( @ PathVariable String tableName ) { return new ResponseEntity < > ( genConfigService . find ( tableName ) , HttpStatus . OK ) ; } @ PutMapping @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < GenConfig > updateGenConfig ( @ Validated @ RequestBody GenConfig genConfig ) { return new ResponseEntity < > ( genConfigService . update ( genConfig . getTableName ( ) , genConfig ) , HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . LocalStorageService ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import io . swagger . annotations . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class LocalStorageController { private final LocalStorageService localStorageService ; @ GetMapping @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < LocalStorage > > queryFile ( LocalStorageQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( localStorageService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportFile ( HttpServletResponse response , LocalStorageQueryCriteria criteria ) throws IOException { localStorageService . download ( localStorageService . queryAll ( criteria ) , response ) ; } @ PostMapping @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createFile ( @ RequestParam String name , @ RequestParam ( "<STR_LIT>" ) MultipartFile file ) { localStorageService . create ( name , file ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( "<STR_LIT>" ) public ResponseEntity < LocalStorage > uploadPicture ( @ RequestParam MultipartFile file ) { String suffix = FileUtil . getExtensionName ( file . getOriginalFilename ( ) ) ; if ( ! FileUtil . IMAGE . equals ( FileUtil . getFileType ( suffix ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } LocalStorage localStorage = localStorageService . create ( null , file ) ; return new ResponseEntity < > ( localStorage , HttpStatus . OK ) ; } @ PutMapping @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateFile ( @ Validated @ RequestBody LocalStorage resources ) { localStorageService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ DeleteMapping @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < Object > deleteFile ( @ RequestBody Long [ ] ids ) { localStorageService . deleteAll ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . mnt . websocket ; import com . alibaba . fastjson . JSON ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; import javax . websocket . * ; import javax . websocket . server . PathParam ; import javax . websocket . server . ServerEndpoint ; import java . io . IOException ; import java . util . Objects ; import java . util . concurrent . CopyOnWriteArraySet ; @ ServerEndpoint ( "<STR_LIT>" ) @ Slf4j @ Component public class WebSocketServer { private static final CopyOnWriteArraySet < WebSocketServer > webSocketSet = new CopyOnWriteArraySet < WebSocketServer > ( ) ; private Session session ; private String sid = "<STR_LIT>" ; @ OnOpen public void onOpen ( Session session , @ PathParam ( "<STR_LIT>" ) String sid ) { this . session = session ; webSocketSet . removeIf ( webSocket -> webSocket . sid . equals ( sid ) ) ; webSocketSet . add ( this ) ; this . sid = sid ; } @ OnClose public void onClose ( ) { webSocketSet . remove ( this ) ; } @ OnMessage public void onMessage ( String message , Session session ) { log . info ( "<STR_LIT>" + sid + "<STR_LIT>" + message ) ; for ( WebSocketServer item : webSocketSet ) { try { item . sendMessage ( message ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } @ OnError public void onError ( Session session , Throwable error ) { log . error ( "<STR_LIT>" ) ; error . printStackTrace ( ) ; } private void sendMessage ( String message ) throws IOException { this . session . getBasicRemote ( ) . sendText ( message ) ; } public static void sendInfo ( SocketMsg socketMsg , @ PathParam ( "<STR_LIT>" ) String sid ) throws IOException { String message = JSON . toJSONString ( socketMsg ) ; log . info ( "<STR_LIT>" + sid + "<STR_LIT>" + message ) ; for ( WebSocketServer item : webSocketSet ) { try { if ( sid == null ) { item . sendMessage ( message ) ; } else if ( item . sid . equals ( sid ) ) { item . sendMessage ( message ) ; } } catch ( IOException ignored ) { } } } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } WebSocketServer that = ( WebSocketServer ) o ; return Objects . equals ( session , that . session ) && Objects . equals ( sid , that . sid ) ; } @ Override public int hashCode ( ) { return Objects . hash ( session , sid ) ; } } </s>
<s> package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . service . AppService ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class AppController { private final AppService appService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportApp ( HttpServletResponse response , AppQueryCriteria criteria ) throws IOException { appService . download ( appService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < App > > queryApp ( AppQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( appService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createApp ( @ Validated @ RequestBody App resources ) { appService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateApp ( @ Validated @ RequestBody App resources ) { appService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteApp ( @ RequestBody Set < Long > ids ) { appService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . service . impl ; import cn . hutool . core . lang . Dict ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . SysLog ; import me . zhengjie . mapper . SysLogMapper ; import me . zhengjie . service . SysLogService ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . * ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . reflect . MethodSignature ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Method ; import java . lang . reflect . Parameter ; import java . util . * ; @ Service @ RequiredArgsConstructor public class SysLogServiceImpl extends ServiceImpl < SysLogMapper , SysLog > implements SysLogService { private final SysLogMapper sysLogMapper ; @ Override public PageResult < SysLog > queryAll ( SysLogQueryCriteria criteria , Page < SysLog > page ) { return PageUtil . toPage ( sysLogMapper . queryAll ( criteria , page ) ) ; } @ Override public List < SysLog > queryAll ( SysLogQueryCriteria criteria ) { return sysLogMapper . queryAll ( criteria ) ; } @ Override public PageResult < SysLog > queryAllByUser ( SysLogQueryCriteria criteria , Page < SysLog > page ) { return PageUtil . toPage ( sysLogMapper . queryAllByUser ( criteria , page ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void save ( String username , String browser , String ip , ProceedingJoinPoint joinPoint , SysLog sysLog ) { if ( sysLog == null ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } MethodSignature signature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method method = signature . getMethod ( ) ; me . zhengjie . annotation . Log aopLog = method . getAnnotation ( me . zhengjie . annotation . Log . class ) ; String methodName = joinPoint . getTarget ( ) . getClass ( ) . getName ( ) + "<STR_LIT>" + signature . getName ( ) + "<STR_LIT>" ; sysLog . setDescription ( aopLog . value ( ) ) ; sysLog . setRequestIp ( ip ) ; sysLog . setAddress ( StringUtils . getCityInfo ( sysLog . getRequestIp ( ) ) ) ; sysLog . setMethod ( methodName ) ; sysLog . setUsername ( username ) ; sysLog . setParams ( getParameter ( method , joinPoint . getArgs ( ) ) ) ; if ( signature . getName ( ) . equals ( "<STR_LIT>" ) && StringUtils . isNotEmpty ( sysLog . getParams ( ) ) ) { JSONObject obj = JSON . parseObject ( sysLog . getParams ( ) ) ; sysLog . setUsername ( obj . getString ( "<STR_LIT>" ) ) ; sysLog . setParams ( JSON . toJSONString ( Dict . create ( ) . set ( "<STR_LIT>" , sysLog . getUsername ( ) ) ) ) ; } sysLog . setBrowser ( browser ) ; save ( sysLog ) ; } private String getParameter ( Method method , Object [ ] args ) { List < Object > argList = new ArrayList < > ( ) ; Parameter [ ] parameters = method . getParameters ( ) ; for ( int i = <NUM_LIT> ; i < parameters . length ; i ++ ) { if ( args [ i ] instanceof MultipartFile ) { continue ; } RequestBody requestBody = parameters [ i ] . getAnnotation ( RequestBody . class ) ; if ( requestBody != null ) { argList . add ( args [ i ] ) ; } RequestParam requestParam = parameters [ i ] . getAnnotation ( RequestParam . class ) ; if ( requestParam != null ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; String key = parameters [ i ] . getName ( ) ; if ( ! StringUtils . isEmpty ( requestParam . value ( ) ) ) { key = requestParam . value ( ) ; } map . put ( key , args [ i ] ) ; argList . add ( map ) ; } } if ( argList . isEmpty ( ) ) { return "<STR_LIT>" ; } return argList . size ( ) == <NUM_LIT> ? JSON . toJSONString ( argList . get ( <NUM_LIT> ) ) : JSON . toJSONString ( argList ) ; } @ Override public Object findByErrDetail ( Long id ) { String details = sysLogMapper . getExceptionDetails ( id ) ; return Dict . create ( ) . set ( "<STR_LIT>" , details ) ; } @ Override public void download ( List < SysLog > sysLogs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( SysLog sysLog : sysLogs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , sysLog . getUsername ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getRequestIp ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getAddress ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getDescription ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getBrowser ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getTime ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getExceptionDetail ( ) ) ; map . put ( "<STR_LIT>" , sysLog . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delAllByError ( ) { sysLogMapper . deleteByLevel ( "<STR_LIT>" ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delAllByInfo ( ) { sysLogMapper . deleteByLevel ( "<STR_LIT>" ) ; } } </s>
<s> package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Menu ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface RoleMenuMapper { void insertData ( @ Param ( "<STR_LIT>" ) Long roleId , @ Param ( "<STR_LIT>" ) Set < Menu > menus ) ; void deleteByRoleId ( @ Param ( "<STR_LIT>" ) Long roleId ) ; void deleteByRoleIds ( @ Param ( "<STR_LIT>" ) Set < Long > roleIds ) ; void deleteByMenuId ( @ Param ( "<STR_LIT>" ) Long menuId ) ; } </s>
<s> package me . zhengjie . modules . system . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . service . DictDetailService ; import me . zhengjie . modules . system . domain . vo . DictDetailQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class DictDetailController { private final DictDetailService dictDetailService ; private static final String ENTITY_NAME = "<STR_LIT>" ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping public ResponseEntity < PageResult < DictDetail > > queryDictDetail ( DictDetailQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( dictDetailService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > getDictDetailMaps ( @ RequestParam String dictName ) { String [ ] names = dictName . split ( "<STR_LIT>" ) ; Map < String , List < DictDetail > > dictMap = new HashMap < > ( <NUM_LIT> ) ; for ( String name : names ) { dictMap . put ( name , dictDetailService . getDictByName ( name ) ) ; } return new ResponseEntity < > ( dictMap , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createDictDetail ( @ Validated @ RequestBody DictDetail resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } dictDetailService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateDictDetail ( @ Validated ( DictDetail . Update . class ) @ RequestBody DictDetail resources ) { dictDetailService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDictDetail ( @ PathVariable Long id ) { dictDetailService . delete ( id ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . config ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . stereotype . Service ; import java . util . Arrays ; import java . util . List ; import java . util . stream . Collectors ; @ Service ( value = "<STR_LIT>" ) public class AuthorityConfig { public Boolean check ( String ... permissions ) { List < String > elPermissions = SecurityUtils . getCurrentUser ( ) . getAuthorities ( ) . stream ( ) . map ( GrantedAuthority :: getAuthority ) . collect ( Collectors . toList ( ) ) ; return elPermissions . contains ( "<STR_LIT>" ) || Arrays . stream ( permissions ) . anyMatch ( elPermissions :: contains ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Database extends BaseEntity implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String jdbcUrl ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String pwd ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String userName ; public void copy ( Database source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } } </s>
<s> package me . zhengjie . modules . quartz . domain ; import com . baomidou . mybatisplus . annotation . * ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . sql . Timestamp ; @ Data @ TableName ( "<STR_LIT>" ) public class QuartzLog implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String jobName ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String beanName ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String methodName ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String params ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String cronExpression ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Boolean isSuccess ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String exceptionDetail ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long time ; @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Timestamp createTime ; } </s>
<s> package me . zhengjie . config . mybatis ; import cn . hutool . core . date . DateTime ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import me . zhengjie . utils . SecurityUtils ; import org . apache . ibatis . reflection . MetaObject ; import org . springframework . stereotype . Component ; import java . sql . Timestamp ; @ Component public class MyMetaObjectHandler implements MetaObjectHandler { @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , "<STR_LIT>" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; this . strictInsertFill ( metaObject , "<STR_LIT>" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; String username = "<STR_LIT>" ; try { username = SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception ignored ) { } this . strictInsertFill ( metaObject , "<STR_LIT>" , String . class , username ) ; this . strictInsertFill ( metaObject , "<STR_LIT>" , String . class , username ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , "<STR_LIT>" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; String username = "<STR_LIT>" ; try { username = SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception ignored ) { } this . strictUpdateFill ( metaObject , "<STR_LIT>" , String . class , username ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class ServerQueryCriteria { private String blurry ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . utils ; public enum AliPayStatusEnum { FINISHED ( "<STR_LIT>" ) , SUCCESS ( "<STR_LIT>" ) , BUYER_PAY ( "<STR_LIT>" ) , CLOSED ( "<STR_LIT>" ) ; private final String value ; AliPayStatusEnum ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . Date ; import java . util . List ; import java . util . Set ; @ Mapper public interface UserMapper extends BaseMapper < User > { List < User > findAll ( @ Param ( "<STR_LIT>" ) UserQueryCriteria criteria ) ; Long countAll ( @ Param ( "<STR_LIT>" ) UserQueryCriteria criteria ) ; User findByUsername ( @ Param ( "<STR_LIT>" ) String username ) ; User findByEmail ( @ Param ( "<STR_LIT>" ) String email ) ; User findByPhone ( @ Param ( "<STR_LIT>" ) String phone ) ; @ Select ( "<STR_LIT>" ) void updatePass ( @ Param ( "<STR_LIT>" ) String username , @ Param ( "<STR_LIT>" ) String password , @ Param ( "<STR_LIT>" ) Date lastPasswordResetTime ) ; @ Select ( "<STR_LIT>" ) void updateEmail ( @ Param ( "<STR_LIT>" ) String username , @ Param ( "<STR_LIT>" ) String email ) ; List < User > findByRoleId ( @ Param ( "<STR_LIT>" ) Long roleId ) ; List < User > findByRoleDeptId ( @ Param ( "<STR_LIT>" ) Long deptId ) ; List < User > findByMenuId ( @ Param ( "<STR_LIT>" ) Long menuId ) ; int countByJobs ( @ Param ( "<STR_LIT>" ) Set < Long > jobIds ) ; int countByDepts ( @ Param ( "<STR_LIT>" ) Set < Long > deptIds ) ; int countByRoles ( @ Param ( "<STR_LIT>" ) Set < Long > roleIds ) ; void resetPwd ( @ Param ( "<STR_LIT>" ) Set < Long > userIds , @ Param ( "<STR_LIT>" ) String pwd ) ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . mapper . RoleMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . DeptMapper ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class DeptServiceImpl extends ServiceImpl < DeptMapper , Dept > implements DeptService { private final DeptMapper deptMapper ; private final UserMapper userMapper ; private final RedisUtils redisUtils ; private final RoleMapper roleMapper ; @ Override public List < Dept > queryAll ( DeptQueryCriteria criteria , Boolean isQuery ) throws Exception { String dataScopeType = SecurityUtils . getDataScopeType ( ) ; if ( isQuery ) { if ( dataScopeType . equals ( DataScopeEnum . ALL . getValue ( ) ) ) { criteria . setPidIsNull ( true ) ; } List < Field > fields = StringUtils . getAllFields ( criteria . getClass ( ) , new ArrayList < > ( ) ) ; List < String > fieldNames = new ArrayList < String > ( ) { { add ( "<STR_LIT>" ) ; add ( "<STR_LIT>" ) ; } } ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object val = field . get ( criteria ) ; if ( fieldNames . contains ( field . getName ( ) ) ) { continue ; } if ( ObjectUtil . isNotNull ( val ) ) { criteria . setPidIsNull ( null ) ; break ; } } } criteria . setIds ( SecurityUtils . getCurrentUserDataScope ( ) ) ; List < Dept > list = deptMapper . findAll ( criteria ) ; if ( StringUtils . isBlank ( dataScopeType ) ) { return deduplication ( list ) ; } return list ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public Dept findById ( Long id ) { return getById ( id ) ; } @ Override public List < Dept > findByPid ( long pid ) { return deptMapper . findByPid ( pid ) ; } @ Override public Set < Dept > findByRoleId ( Long id ) { return deptMapper . findByRoleId ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Dept resources ) { save ( resources ) ; updateSubCnt ( resources . getPid ( ) ) ; delCaches ( resources . getPid ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Dept resources ) { Long oldPid = findById ( resources . getId ( ) ) . getPid ( ) ; Long newPid = resources . getPid ( ) ; if ( resources . getPid ( ) != null && resources . getId ( ) . equals ( resources . getPid ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } Dept dept = getById ( resources . getId ( ) ) ; resources . setId ( dept . getId ( ) ) ; saveOrUpdate ( resources ) ; updateSubCnt ( oldPid ) ; updateSubCnt ( newPid ) ; delCaches ( resources . getId ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Dept > depts ) { for ( Dept dept : depts ) { delCaches ( dept . getId ( ) ) ; deptMapper . deleteById ( dept . getId ( ) ) ; updateSubCnt ( dept . getPid ( ) ) ; } } @ Override public void download ( List < Dept > depts , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Dept dept : depts ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , dept . getName ( ) ) ; map . put ( "<STR_LIT>" , dept . getEnabled ( ) ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , dept . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public Set < Dept > getDeleteDepts ( List < Dept > menuList , Set < Dept > deptSet ) { for ( Dept dept : menuList ) { deptSet . add ( dept ) ; List < Dept > depts = deptMapper . findByPid ( dept . getId ( ) ) ; if ( depts != null && depts . size ( ) != <NUM_LIT> ) { getDeleteDepts ( depts , deptSet ) ; } } return deptSet ; } @ Override public List < Long > getDeptChildren ( List < Dept > deptList ) { List < Long > list = new ArrayList < > ( ) ; deptList . forEach ( dept -> { if ( dept != null && dept . getEnabled ( ) ) { List < Dept > depts = deptMapper . findByPid ( dept . getId ( ) ) ; if ( depts . size ( ) != <NUM_LIT> ) { list . addAll ( getDeptChildren ( depts ) ) ; } list . add ( dept . getId ( ) ) ; } } ) ; return list ; } @ Override public List < Dept > getSuperior ( Dept dept , List < Dept > depts ) { if ( dept . getPid ( ) == null ) { depts . addAll ( deptMapper . findByPidIsNull ( ) ) ; return depts ; } depts . addAll ( deptMapper . findByPid ( dept . getPid ( ) ) ) ; return getSuperior ( findById ( dept . getPid ( ) ) , depts ) ; } @ Override public Object buildTree ( List < Dept > deptList ) { Set < Dept > trees = new LinkedHashSet < > ( ) ; Set < Dept > depts = new LinkedHashSet < > ( ) ; List < String > deptNames = deptList . stream ( ) . map ( Dept :: getName ) . collect ( Collectors . toList ( ) ) ; boolean isChild ; for ( Dept dept : deptList ) { isChild = false ; if ( dept . getPid ( ) == null ) { trees . add ( dept ) ; } for ( Dept it : deptList ) { if ( it . getPid ( ) != null && dept . getId ( ) . equals ( it . getPid ( ) ) ) { isChild = true ; if ( dept . getChildren ( ) == null ) { dept . setChildren ( new ArrayList < > ( ) ) ; } dept . getChildren ( ) . add ( it ) ; } } if ( isChild ) { depts . add ( dept ) ; } else if ( dept . getPid ( ) != null && ! deptNames . contains ( findById ( dept . getPid ( ) ) . getName ( ) ) ) { depts . add ( dept ) ; } } if ( CollectionUtil . isEmpty ( trees ) ) { trees = depts ; } Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( "<STR_LIT>" , depts . size ( ) ) ; map . put ( "<STR_LIT>" , CollectionUtil . isEmpty ( trees ) ? depts : trees ) ; return map ; } @ Override public void verification ( Set < Dept > depts ) { Set < Long > deptIds = depts . stream ( ) . map ( Dept :: getId ) . collect ( Collectors . toSet ( ) ) ; if ( userMapper . countByDepts ( deptIds ) > <NUM_LIT> ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( roleMapper . countByDepts ( deptIds ) > <NUM_LIT> ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } private void updateSubCnt ( Long deptId ) { if ( deptId != null ) { int count = deptMapper . countByPid ( deptId ) ; deptMapper . updateSubCntById ( count , deptId ) ; } } private List < Dept > deduplication ( List < Dept > list ) { List < Dept > depts = new ArrayList < > ( ) ; for ( Dept dept : list ) { boolean flag = true ; for ( Dept dept1 : list ) { if ( dept1 . getId ( ) . equals ( dept . getPid ( ) ) ) { flag = false ; break ; } } if ( flag ) { depts . add ( dept ) ; } } return depts ; } public void delCaches ( Long id ) { List < User > users = userMapper . findByRoleDeptId ( id ) ; redisUtils . delByKeys ( CacheKey . DATA_USER , users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ) ; redisUtils . del ( CacheKey . DEPT_ID + id ) ; } } </s>
<s> package me . zhengjie . utils ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . core . env . Environment ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class SpringContextHolder implements ApplicationContextAware , DisposableBean { private static ApplicationContext applicationContext = null ; private static final List < CallBack > CALL_BACKS = new ArrayList < > ( ) ; private static boolean addCallback = true ; public synchronized static void addCallBacks ( CallBack callBack ) { if ( addCallback ) { SpringContextHolder . CALL_BACKS . add ( callBack ) ; } else { log . warn ( "<STR_LIT>" , callBack . getCallBackName ( ) ) ; callBack . executor ( ) ; } } @ SuppressWarnings ( "<STR_LIT>" ) public static < T > T getBean ( String name ) { assertContextInjected ( ) ; return ( T ) applicationContext . getBean ( name ) ; } public static < T > T getBean ( Class < T > requiredType ) { assertContextInjected ( ) ; return applicationContext . getBean ( requiredType ) ; } public static < T > T getProperties ( String property , T defaultValue , Class < T > requiredType ) { T result = defaultValue ; try { result = getBean ( Environment . class ) . getProperty ( property , requiredType ) ; } catch ( Exception ignored ) { } return result ; } public static String getProperties ( String property ) { return getProperties ( property , null , String . class ) ; } public static < T > T getProperties ( String property , Class < T > requiredType ) { return getProperties ( property , null , requiredType ) ; } private static void assertContextInjected ( ) { if ( applicationContext == null ) { throw new IllegalStateException ( "<STR_LIT>" + "<STR_LIT>" ) ; } } private static void clearHolder ( ) { log . debug ( "<STR_LIT>" + applicationContext ) ; applicationContext = null ; } @ Override public void destroy ( ) { SpringContextHolder . clearHolder ( ) ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( SpringContextHolder . applicationContext != null ) { log . warn ( "<STR_LIT>" + SpringContextHolder . applicationContext ) ; } SpringContextHolder . applicationContext = applicationContext ; if ( addCallback ) { for ( CallBack callBack : SpringContextHolder . CALL_BACKS ) { callBack . executor ( ) ; } CALL_BACKS . clear ( ) ; } SpringContextHolder . addCallback = false ; } public static List < String > getAllServiceBeanName ( ) { return new ArrayList < > ( Arrays . asList ( applicationContext . getBeanNamesForAnnotation ( Service . class ) ) ) ; } } </s>
<s> package me . zhengjie . modules . security . config . bean ; import lombok . Data ; @ Data public class LoginCode { private LoginCodeEnum codeType ; private Long expiration = <NUM_LIT> ; private int length = <NUM_LIT> ; private int width = <NUM_LIT> ; private int height = <NUM_LIT> ; private String fontName ; private int fontSize = <NUM_LIT> ; public LoginCodeEnum getCodeType ( ) { return codeType ; } } </s>
<s> package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Dept ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface RoleDeptMapper { void insertData ( @ Param ( "<STR_LIT>" ) Long roleId , @ Param ( "<STR_LIT>" ) Set < Dept > depts ) ; void deleteByRoleId ( @ Param ( "<STR_LIT>" ) Long roleId ) ; void deleteByRoleIds ( @ Param ( "<STR_LIT>" ) Set < Long > roleIds ) ; } </s>
<s> package me . zhengjie . modules . quartz . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class QuartzJobQueryCriteria { private String jobName ; private Boolean isSuccess ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . utils ; import cn . hutool . core . util . StrUtil ; import cn . hutool . extra . template . * ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import org . springframework . util . ObjectUtils ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . Writer ; import java . time . LocalDate ; import java . util . * ; import static me . zhengjie . utils . FileUtil . SYS_TEM_DIR ; @ Slf4j @ SuppressWarnings ( { "<STR_LIT>" , "<STR_LIT>" } ) public class GenUtil { private static final String TIMESTAMP = "<STR_LIT>" ; private static final String BIGDECIMAL = "<STR_LIT>" ; public static final String PK = "<STR_LIT>" ; public static final String EXTRA = "<STR_LIT>" ; private static List < String > getAdminTemplateNames ( ) { List < String > templateNames = new ArrayList < > ( ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; return templateNames ; } private static List < String > getFrontTemplateNames ( ) { List < String > templateNames = new ArrayList < > ( ) ; templateNames . add ( "<STR_LIT>" ) ; templateNames . add ( "<STR_LIT>" ) ; return templateNames ; } public static List < Map < String , Object > > preview ( List < ColumnInfo > columns , GenConfig genConfig ) { Map < String , Object > genMap = getGenMap ( columns , genConfig ) ; List < Map < String , Object > > genList = new ArrayList < > ( ) ; List < String > templates = getAdminTemplateNames ( ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( "<STR_LIT>" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; for ( String templateName : templates ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , template . render ( genMap ) ) ; map . put ( "<STR_LIT>" , templateName . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ; genList . add ( map ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; map . put ( templateName , template . render ( genMap ) ) ; map . put ( "<STR_LIT>" , template . render ( genMap ) ) ; map . put ( "<STR_LIT>" , templateName ) ; genList . add ( map ) ; } return genList ; } public static String download ( List < ColumnInfo > columns , GenConfig genConfig ) throws IOException { String tempPath = SYS_TEM_DIR + "<STR_LIT>" + File . separator + genConfig . getTableName ( ) + File . separator ; Map < String , Object > genMap = getGenMap ( columns , genConfig ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( "<STR_LIT>" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; List < String > templates = getAdminTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; String filePath = getAdminFilePath ( templateName , genConfig , genMap . get ( "<STR_LIT>" ) . toString ( ) , tempPath + "<STR_LIT>" + File . separator ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; String path = tempPath + "<STR_LIT>" + File . separator ; String apiPath = path + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator ; String srcPath = path + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator + genMap . get ( "<STR_LIT>" ) . toString ( ) + File . separator ; String filePath = getFrontFilePath ( templateName , apiPath , srcPath , genMap . get ( "<STR_LIT>" ) . toString ( ) ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } return tempPath ; } public static void generatorCode ( List < ColumnInfo > columnInfos , GenConfig genConfig ) throws IOException { Map < String , Object > genMap = getGenMap ( columnInfos , genConfig ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( "<STR_LIT>" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; List < String > templates = getAdminTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; String rootPath = System . getProperty ( "<STR_LIT>" ) ; String filePath = getAdminFilePath ( templateName , genConfig , genMap . get ( "<STR_LIT>" ) . toString ( ) , rootPath ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( "<STR_LIT>" + templateName + "<STR_LIT>" ) ; String filePath = getFrontFilePath ( templateName , genConfig . getApiPath ( ) , genConfig . getPath ( ) , genMap . get ( "<STR_LIT>" ) . toString ( ) ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } } private static Map < String , Object > getGenMap ( List < ColumnInfo > columnInfos , GenConfig genConfig ) { Map < String , Object > genMap = new HashMap < > ( <NUM_LIT> ) ; genMap . put ( "<STR_LIT>" , genConfig . getApiAlias ( ) ) ; genMap . put ( "<STR_LIT>" , genConfig . getPack ( ) ) ; genMap . put ( "<STR_LIT>" , genConfig . getModuleName ( ) ) ; genMap . put ( "<STR_LIT>" , genConfig . getAuthor ( ) ) ; genMap . put ( "<STR_LIT>" , LocalDate . now ( ) . toString ( ) ) ; genMap . put ( "<STR_LIT>" , genConfig . getTableName ( ) ) ; String className = StringUtils . toCapitalizeCamelCase ( genConfig . getTableName ( ) ) ; String changeClassName = StringUtils . toCamelCase ( genConfig . getTableName ( ) ) ; if ( StringUtils . isNotEmpty ( genConfig . getPrefix ( ) ) ) { className = StringUtils . toCapitalizeCamelCase ( StrUtil . removePrefix ( genConfig . getTableName ( ) , genConfig . getPrefix ( ) ) ) ; changeClassName = StringUtils . toCamelCase ( StrUtil . removePrefix ( genConfig . getTableName ( ) , genConfig . getPrefix ( ) ) ) ; changeClassName = StringUtils . uncapitalize ( changeClassName ) ; } genMap . put ( "<STR_LIT>" , className ) ; genMap . put ( "<STR_LIT>" , changeClassName ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , false ) ; genMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; genMap . put ( "<STR_LIT>" , "<STR_LIT>" ) ; List < Map < String , Object > > columns = new ArrayList < > ( ) ; List < Map < String , Object > > queryColumns = new ArrayList < > ( ) ; List < String > dicts = new ArrayList < > ( ) ; List < Map < String , Object > > betweens = new ArrayList < > ( ) ; List < Map < String , Object > > isNotNullColumns = new ArrayList < > ( ) ; for ( ColumnInfo column : columnInfos ) { Map < String , Object > listMap = new HashMap < > ( <NUM_LIT> ) ; listMap . put ( "<STR_LIT>" , column . getRemark ( ) ) ; listMap . put ( "<STR_LIT>" , column . getKeyType ( ) ) ; String colType = ColUtil . cloToJava ( column . getColumnType ( ) ) ; String changeColumnName = StringUtils . toCamelCase ( column . getColumnName ( ) ) ; String capitalColumnName = StringUtils . toCapitalizeCamelCase ( column . getColumnName ( ) ) ; if ( PK . equals ( column . getKeyType ( ) ) ) { genMap . put ( "<STR_LIT>" , colType ) ; genMap . put ( "<STR_LIT>" , changeColumnName ) ; genMap . put ( "<STR_LIT>" , capitalColumnName ) ; genMap . put ( "<STR_LIT>" , column . getColumnName ( ) ) ; } if ( TIMESTAMP . equals ( colType ) ) { genMap . put ( "<STR_LIT>" , true ) ; } if ( BIGDECIMAL . equals ( colType ) ) { genMap . put ( "<STR_LIT>" , true ) ; } if ( EXTRA . equals ( column . getExtra ( ) ) ) { genMap . put ( "<STR_LIT>" , true ) ; } if ( StringUtils . isNotBlank ( column . getDictName ( ) ) ) { genMap . put ( "<STR_LIT>" , true ) ; if ( ! dicts . contains ( column . getDictName ( ) ) ) dicts . add ( column . getDictName ( ) ) ; } listMap . put ( "<STR_LIT>" , colType ) ; listMap . put ( "<STR_LIT>" , column . getColumnName ( ) ) ; listMap . put ( "<STR_LIT>" , column . getNotNull ( ) ) ; listMap . put ( "<STR_LIT>" , column . getListShow ( ) ) ; listMap . put ( "<STR_LIT>" , column . getFormShow ( ) ) ; listMap . put ( "<STR_LIT>" , StringUtils . isNotBlank ( column . getFormType ( ) ) ? column . getFormType ( ) : "<STR_LIT>" ) ; listMap . put ( "<STR_LIT>" , changeColumnName ) ; listMap . put ( "<STR_LIT>" , capitalColumnName ) ; listMap . put ( "<STR_LIT>" , column . getDictName ( ) ) ; if ( column . getNotNull ( ) ) { isNotNullColumns . add ( listMap ) ; } if ( ! StringUtils . isBlank ( column . getQueryType ( ) ) ) { listMap . put ( "<STR_LIT>" , column . getQueryType ( ) ) ; genMap . put ( "<STR_LIT>" , true ) ; if ( TIMESTAMP . equals ( colType ) ) { genMap . put ( "<STR_LIT>" , true ) ; } if ( BIGDECIMAL . equals ( colType ) ) { genMap . put ( "<STR_LIT>" , true ) ; } if ( "<STR_LIT>" . equalsIgnoreCase ( column . getQueryType ( ) ) ) { betweens . add ( listMap ) ; } else { queryColumns . add ( listMap ) ; } } columns . add ( listMap ) ; } genMap . put ( "<STR_LIT>" , columns ) ; genMap . put ( "<STR_LIT>" , queryColumns ) ; genMap . put ( "<STR_LIT>" , dicts ) ; genMap . put ( "<STR_LIT>" , betweens ) ; genMap . put ( "<STR_LIT>" , isNotNullColumns ) ; return genMap ; } private static String getAdminFilePath ( String templateName , GenConfig genConfig , String className , String rootPath ) { String projectPath = rootPath + File . separator + genConfig . getModuleName ( ) ; String packagePath = projectPath + File . separator + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator ; String mpXmlPath = projectPath + File . separator + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator ; if ( ! ObjectUtils . isEmpty ( genConfig . getPack ( ) ) ) { packagePath += genConfig . getPack ( ) . replace ( "<STR_LIT>" , File . separator ) + File . separator ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return packagePath + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return mpXmlPath + "<STR_LIT>" + File . separator + className + "<STR_LIT>" ; } return null ; } private static String getFrontFilePath ( String templateName , String apiPath , String path , String apiName ) { if ( "<STR_LIT>" . equals ( templateName ) ) { return apiPath + File . separator + apiName + "<STR_LIT>" ; } if ( "<STR_LIT>" . equals ( templateName ) ) { return path + File . separator + "<STR_LIT>" ; } return null ; } private static void genFile ( File file , Template template , Map < String , Object > map ) throws IOException { Writer writer = null ; try { FileUtil . touch ( file ) ; writer = new FileWriter ( file ) ; template . render ( map , writer ) ; } catch ( TemplateException | IOException e ) { throw new RuntimeException ( e ) ; } finally { assert writer != null ; writer . close ( ) ; } } } </s>
<s> package me . zhengjie . modules . security . config . bean ; public enum LoginCodeEnum { ARITHMETIC , CHINESE , CHINESE_GIF , GIF , SPEC } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; @ Mapper public interface MenuMapper extends BaseMapper < Menu > { List < Menu > findAll ( @ Param ( "<STR_LIT>" ) MenuQueryCriteria criteria ) ; LinkedHashSet < Menu > findByRoleIdsAndTypeNot ( @ Param ( "<STR_LIT>" ) Set < Long > roleIds , @ Param ( "<STR_LIT>" ) Integer type ) ; List < Menu > findByPidIsNullOrderByMenuSort ( ) ; List < Menu > findByPidOrderByMenuSort ( @ Param ( "<STR_LIT>" ) Long pid ) ; @ Select ( "<STR_LIT>" ) Menu findByTitle ( @ Param ( "<STR_LIT>" ) String title ) ; @ Select ( "<STR_LIT>" ) Menu findByComponentName ( @ Param ( "<STR_LIT>" ) String name ) ; @ Select ( "<STR_LIT>" ) int countByPid ( @ Param ( "<STR_LIT>" ) Long pid ) ; @ Select ( "<STR_LIT>" ) void updateSubCntById ( @ Param ( "<STR_LIT>" ) int count , @ Param ( "<STR_LIT>" ) Long menuId ) ; } </s>
<s> package me . zhengjie . utils ; import org . apache . commons . configuration . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ColUtil { private static final Logger log = LoggerFactory . getLogger ( ColUtil . class ) ; static String cloToJava ( String type ) { Configuration config = getConfig ( ) ; assert config != null ; return config . getString ( type , "<STR_LIT>" ) ; } public static PropertiesConfiguration getConfig ( ) { try { return new PropertiesConfiguration ( "<STR_LIT>" ) ; } catch ( ConfigurationException e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } } </s>
<s> package me . zhengjie . exception ; import org . springframework . util . StringUtils ; public class EntityExistException extends RuntimeException { public EntityExistException ( Class clazz , String field , String val ) { super ( EntityExistException . generateMessage ( clazz . getSimpleName ( ) , field , val ) ) ; } private static String generateMessage ( String entity , String field , String val ) { return StringUtils . capitalize ( entity ) + "<STR_LIT>" + field + "<STR_LIT>" + val + "<STR_LIT>" ; } } </s>
<s> package me . zhengjie . utils ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ThrowableUtil { public static String getStackTrace ( Throwable throwable ) { StringWriter sw = new StringWriter ( ) ; try ( PrintWriter pw = new PrintWriter ( sw ) ) { throwable . printStackTrace ( pw ) ; return sw . toString ( ) ; } } } </s>
<s> package me . zhengjie . modules . quartz . utils ; import cn . hutool . extra . template . Template ; import cn . hutool . extra . template . TemplateConfig ; import cn . hutool . extra . template . TemplateEngine ; import cn . hutool . extra . template . TemplateUtil ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . mapper . QuartzLogMapper ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . service . EmailService ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . SpringContextHolder ; import me . zhengjie . utils . StringUtils ; import me . zhengjie . utils . ThrowableUtil ; import org . quartz . JobExecutionContext ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . scheduling . annotation . Async ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import org . springframework . scheduling . quartz . QuartzJobBean ; import java . util . * ; import java . util . concurrent . * ; @ Async public class ExecutionJob extends QuartzJobBean { private final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final ThreadPoolTaskExecutor executor = SpringContextHolder . getBean ( "<STR_LIT>" ) ; @ Override public void executeInternal ( JobExecutionContext context ) { QuartzJob quartzJob = ( QuartzJob ) context . getMergedJobDataMap ( ) . get ( QuartzJob . JOB_KEY ) ; QuartzLogMapper quartzLogMapper = SpringContextHolder . getBean ( QuartzLogMapper . class ) ; QuartzJobService quartzJobService = SpringContextHolder . getBean ( QuartzJobService . class ) ; RedisUtils redisUtils = SpringContextHolder . getBean ( RedisUtils . class ) ; String uuid = quartzJob . getUuid ( ) ; QuartzLog log = new QuartzLog ( ) ; log . setJobName ( quartzJob . getJobName ( ) ) ; log . setBeanName ( quartzJob . getBeanName ( ) ) ; log . setMethodName ( quartzJob . getMethodName ( ) ) ; log . setParams ( quartzJob . getParams ( ) ) ; long startTime = System . currentTimeMillis ( ) ; log . setCronExpression ( quartzJob . getCronExpression ( ) ) ; try { QuartzRunnable task = new QuartzRunnable ( quartzJob . getBeanName ( ) , quartzJob . getMethodName ( ) , quartzJob . getParams ( ) ) ; Future < ? > future = executor . submit ( task ) ; future . get ( ) ; long times = System . currentTimeMillis ( ) - startTime ; log . setTime ( times ) ; if ( StringUtils . isNotBlank ( uuid ) ) { redisUtils . set ( uuid , true ) ; } log . setIsSuccess ( true ) ; logger . info ( "<STR_LIT>" + quartzJob . getJobName ( ) + "<STR_LIT>" + times + "<STR_LIT>" ) ; if ( StringUtils . isNotBlank ( quartzJob . getSubTask ( ) ) ) { String [ ] tasks = quartzJob . getSubTask ( ) . split ( "<STR_LIT>" ) ; quartzJobService . executionSubJob ( tasks ) ; } } catch ( Exception e ) { if ( StringUtils . isNotBlank ( uuid ) ) { redisUtils . set ( uuid , false ) ; } logger . error ( "<STR_LIT>" + quartzJob . getJobName ( ) ) ; long times = System . currentTimeMillis ( ) - startTime ; log . setTime ( times ) ; log . setIsSuccess ( false ) ; log . setExceptionDetail ( ThrowableUtil . getStackTrace ( e ) ) ; if ( quartzJob . getPauseAfterFailure ( ) != null && quartzJob . getPauseAfterFailure ( ) ) { quartzJob . setIsPause ( false ) ; quartzJobService . updateIsPause ( quartzJob ) ; } if ( quartzJob . getEmail ( ) != null ) { EmailService emailService = SpringContextHolder . getBean ( EmailService . class ) ; if ( StringUtils . isNoneBlank ( quartzJob . getEmail ( ) ) ) { EmailVo emailVo = taskAlarm ( quartzJob , ThrowableUtil . getStackTrace ( e ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; } } } finally { quartzLogMapper . insert ( log ) ; } } private EmailVo taskAlarm ( QuartzJob quartzJob , String msg ) { EmailVo emailVo = new EmailVo ( ) ; emailVo . setSubject ( "<STR_LIT>" + quartzJob . getJobName ( ) + "<STR_LIT>" ) ; Map < String , Object > data = new HashMap < > ( <NUM_LIT> ) ; data . put ( "<STR_LIT>" , quartzJob ) ; data . put ( "<STR_LIT>" , msg ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( "<STR_LIT>" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; Template template = engine . getTemplate ( "<STR_LIT>" ) ; emailVo . setContent ( template . render ( data ) ) ; List < String > emails = Arrays . asList ( quartzJob . getEmail ( ) . split ( "<STR_LIT>" ) ) ; emailVo . setTos ( emails ) ; return emailVo ; } } </s>
<s> package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import java . io . Serializable ; import java . sql . Timestamp ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class DeployHistory implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String appName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String ip ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Timestamp deployDate ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String deployUser ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Long deployId ; public void copy ( DeployHistory source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } } </s>
<s> package me . zhengjie . modules . system . rest ; import cn . hutool . core . lang . Dict ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class RoleController { private final RoleService roleService ; private static final String ENTITY_NAME = "<STR_LIT>" ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Role > findRoleById ( @ PathVariable Long id ) { return new ResponseEntity < > ( roleService . findById ( id ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportRole ( HttpServletResponse response , RoleQueryCriteria criteria ) throws IOException { roleService . download ( roleService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < List < Role > > queryAllRole ( ) { return new ResponseEntity < > ( roleService . queryAll ( ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Role > > queryRole ( RoleQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( roleService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > getRoleLevel ( ) { return new ResponseEntity < > ( Dict . create ( ) . set ( "<STR_LIT>" , getLevels ( null ) ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createRole ( @ Validated @ RequestBody Role resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } getLevels ( resources . getLevel ( ) ) ; roleService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateRole ( @ Validated ( Role . Update . class ) @ RequestBody Role resources ) { getLevels ( resources . getLevel ( ) ) ; roleService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateRoleMenu ( @ RequestBody Role resources ) { Role role = roleService . getById ( resources . getId ( ) ) ; getLevels ( role . getLevel ( ) ) ; roleService . updateMenu ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteRole ( @ RequestBody Set < Long > ids ) { for ( Long id : ids ) { Role role = roleService . getById ( id ) ; getLevels ( role . getLevel ( ) ) ; } roleService . verification ( ids ) ; roleService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private int getLevels ( Integer level ) { List < Integer > levels = roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ; int min = Collections . min ( levels ) ; if ( level != null ) { if ( level < min ) { throw new BadRequestException ( "<STR_LIT>" + min + "<STR_LIT>" + level ) ; } } return min ; } } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . SysLog ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . aspectj . lang . ProceedingJoinPoint ; import org . springframework . scheduling . annotation . Async ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public interface SysLogService extends IService < SysLog > { PageResult < SysLog > queryAll ( SysLogQueryCriteria criteria , Page < SysLog > page ) ; List < SysLog > queryAll ( SysLogQueryCriteria criteria ) ; PageResult < SysLog > queryAllByUser ( SysLogQueryCriteria criteria , Page < SysLog > page ) ; @ Async void save ( String username , String browser , String ip , ProceedingJoinPoint joinPoint , SysLog sysLog ) ; Object findByErrDetail ( Long id ) ; void download ( List < SysLog > sysLogs , HttpServletResponse response ) throws IOException ; void delAllByError ( ) ; void delAllByInfo ( ) ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . domain . vo . JobQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . JobMapper ; import me . zhengjie . modules . system . service . JobService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class JobServiceImpl extends ServiceImpl < JobMapper , Job > implements JobService { private final JobMapper jobMapper ; private final RedisUtils redisUtils ; private final UserMapper userMapper ; @ Override public PageResult < Job > queryAll ( JobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( jobMapper . findAll ( criteria , page ) ) ; } @ Override public List < Job > queryAll ( JobQueryCriteria criteria ) { return jobMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public Job findById ( Long id ) { return getById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Job resources ) { Job job = jobMapper . findByName ( resources . getName ( ) ) ; if ( job != null ) { throw new EntityExistException ( Job . class , "<STR_LIT>" , resources . getName ( ) ) ; } save ( resources ) ; } @ Override @ CacheEvict ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public void update ( Job resources ) { Job job = getById ( resources . getId ( ) ) ; Job old = jobMapper . findByName ( resources . getName ( ) ) ; if ( old != null && ! old . getId ( ) . equals ( resources . getId ( ) ) ) { throw new EntityExistException ( Job . class , "<STR_LIT>" , resources . getName ( ) ) ; } resources . setId ( job . getId ( ) ) ; saveOrUpdate ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; redisUtils . delByKeys ( CacheKey . JOB_ID , ids ) ; } @ Override public void download ( List < Job > jobs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Job job : jobs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , job . getName ( ) ) ; map . put ( "<STR_LIT>" , job . getEnabled ( ) ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , job . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void verification ( Set < Long > ids ) { if ( userMapper . countByJobs ( ids ) > <NUM_LIT> ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . modules . system . service ; import java . util . Map ; public interface MonitorService { Map < String , Object > getServers ( ) ; } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . domain . vo . DictDetailQueryCriteria ; import me . zhengjie . utils . PageResult ; import java . util . List ; public interface DictDetailService extends IService < DictDetail > { void create ( DictDetail resources ) ; void update ( DictDetail resources ) ; void delete ( Long id ) ; PageResult < DictDetail > queryAll ( DictDetailQueryCriteria criteria , Page < Object > page ) ; List < DictDetail > getDictByName ( String name ) ; } </s>
<s> package me . zhengjie . modules . system . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . service . EmailService ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . enums . CodeBiEnum ; import me . zhengjie . utils . enums . CodeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . web . bind . annotation . * ; import java . util . Objects ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class VerifyController { private final VerifyService verificationCodeService ; private final EmailService emailService ; @ PostMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < Object > resetEmail ( @ RequestParam String email ) { EmailVo emailVo = verificationCodeService . sendEmail ( email , CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ PostMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < Object > resetPass ( @ RequestParam String email ) { EmailVo emailVo = verificationCodeService . sendEmail ( email , CodeEnum . EMAIL_RESET_PWD_CODE . getKey ( ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ GetMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < Object > validated ( @ RequestParam String email , @ RequestParam String code , @ RequestParam Integer codeBi ) { CodeBiEnum biEnum = CodeBiEnum . find ( codeBi ) ; switch ( Objects . requireNonNull ( biEnum ) ) { case ONE : verificationCodeService . validated ( CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) + email , code ) ; break ; case TWO : verificationCodeService . validated ( CodeEnum . EMAIL_RESET_PWD_CODE . getKey ( ) + email , code ) ; break ; default : break ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Job ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface UserJobMapper { void insertData ( @ Param ( "<STR_LIT>" ) Long userId , @ Param ( "<STR_LIT>" ) Set < Job > jobs ) ; void deleteByUserId ( @ Param ( "<STR_LIT>" ) Long userId ) ; void deleteByUserIds ( @ Param ( "<STR_LIT>" ) Set < Long > userIds ) ; } </s>
<s> package me . zhengjie . modules . security . service . dto ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import org . springframework . security . core . GrantedAuthority ; @ Data @ NoArgsConstructor @ AllArgsConstructor public class AuthorityDto implements GrantedAuthority { private String authority ; } </s>
<s> package me . zhengjie . config ; import org . apache . catalina . connector . Connector ; import org . springframework . boot . web . embedded . tomcat . TomcatConnectorCustomizer ; import org . springframework . context . annotation . Configuration ; @ Configuration ( proxyBeanMethods = false ) public class RelaxedQueryCharsConnectorCustomizer implements TomcatConnectorCustomizer { @ Override public void customize ( Connector connector ) { connector . setProperty ( "<STR_LIT>" , "<STR_LIT>" ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class App extends BaseEntity implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private int port ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String uploadPath ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String deployPath ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String backupPath ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String startScript ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String deployScript ; public void copy ( App source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } } </s>
<s> package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . GET ) public @ interface AnonymousGetMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default "<STR_LIT>" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class MenuVo implements Serializable { private String name ; private String path ; private Boolean hidden ; private String redirect ; private String component ; private Boolean alwaysShow ; private MenuMetaVo meta ; private List < MenuVo > children ; } </s>
<s> package me . zhengjie . config . thread ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadPoolExecutor ; @ Configuration public class CustomExecutorConfig { @ Bean @ Primary public Executor elAsync ( ) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor ( ) ; executor . setCorePoolSize ( AsyncTaskProperties . corePoolSize ) ; executor . setMaxPoolSize ( AsyncTaskProperties . maxPoolSize ) ; executor . setQueueCapacity ( AsyncTaskProperties . queueCapacity ) ; executor . setThreadNamePrefix ( "<STR_LIT>" ) ; executor . setKeepAliveSeconds ( AsyncTaskProperties . keepAliveSeconds ) ; executor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; executor . initialize ( ) ; return executor ; } @ Bean public Executor otherAsync ( ) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor ( ) ; executor . setCorePoolSize ( <NUM_LIT> ) ; executor . setQueueCapacity ( <NUM_LIT> ) ; executor . setKeepAliveSeconds ( AsyncTaskProperties . keepAliveSeconds ) ; executor . setThreadNamePrefix ( "<STR_LIT>" ) ; executor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; executor . initialize ( ) ; return executor ; } } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . utils . PageResult ; import org . springframework . http . ResponseEntity ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . List ; public interface GeneratorService extends IService < ColumnInfo > { PageResult < TableInfo > getTables ( String name , Page < Object > page ) ; List < ColumnInfo > getColumns ( String name ) ; void sync ( List < ColumnInfo > columnInfos , List < ColumnInfo > columnInfoList ) ; void save ( List < ColumnInfo > columnInfos ) ; void generator ( GenConfig genConfig , List < ColumnInfo > columns ) ; ResponseEntity < Object > preview ( GenConfig genConfig , List < ColumnInfo > columns ) ; void download ( GenConfig genConfig , List < ColumnInfo > columns , HttpServletRequest request , HttpServletResponse response ) ; List < ColumnInfo > query ( String table ) ; } </s>
<s> package me . zhengjie ; import io . swagger . annotations . Api ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . utils . SpringContextHolder ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . boot . context . ApplicationPidFileWriter ; import org . springframework . context . annotation . Bean ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . transaction . annotation . EnableTransactionManagement ; import org . springframework . web . bind . annotation . RestController ; @ EnableAsync @ RestController @ Api ( hidden = true ) @ SpringBootApplication @ EnableTransactionManagement public class AppRun { public static void main ( String [ ] args ) { SpringApplication springApplication = new SpringApplication ( AppRun . class ) ; springApplication . addListeners ( new ApplicationPidFileWriter ( ) ) ; springApplication . run ( args ) ; } @ Bean public SpringContextHolder springContextHolder ( ) { return new SpringContextHolder ( ) ; } @ AnonymousGetMapping ( "<STR_LIT>" ) public String index ( ) { return "<STR_LIT>" ; } } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ NoArgsConstructor @ TableName ( "<STR_LIT>" ) public class LocalStorage extends BaseEntity implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String realName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String suffix ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String path ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String type ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String size ; public LocalStorage ( String realName , String name , String suffix , String path , String type , String size ) { this . realName = realName ; this . name = name ; this . suffix = suffix ; this . path = path ; this . type = type ; this . size = size ; } public void copy ( LocalStorage source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . security . service . dto . AuthorityDto ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface RoleService extends IService < Role > { List < Role > queryAll ( ) ; Role findById ( long id ) ; void create ( Role resources ) ; void update ( Role resources ) ; void delete ( Set < Long > ids ) ; List < Role > findByUsersId ( Long userId ) ; Integer findByRoles ( Set < Role > roles ) ; void updateMenu ( Role resources ) ; PageResult < Role > queryAll ( RoleQueryCriteria criteria , Page < Object > page ) ; List < Role > queryAll ( RoleQueryCriteria criteria ) ; void download ( List < Role > roles , HttpServletResponse response ) throws IOException ; List < AuthorityDto > mapToGrantedAuthorities ( User user ) ; void verification ( Set < Long > ids ) ; List < Role > findByMenuId ( Long menuId ) ; } </s>
<s> package me . zhengjie . modules . quartz . service . impl ; import cn . hutool . core . util . IdUtil ; import cn . hutool . core . util . StrUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . mapper . QuartzJobMapper ; import me . zhengjie . modules . quartz . mapper . QuartzLogMapper ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . modules . quartz . utils . QuartzManage ; import me . zhengjie . utils . * ; import org . quartz . CronExpression ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ RequiredArgsConstructor @ Service ( value = "<STR_LIT>" ) public class QuartzJobServiceImpl extends ServiceImpl < QuartzJobMapper , QuartzJob > implements QuartzJobService { private final QuartzJobMapper quartzJobMapper ; private final QuartzLogMapper quartzLogMapper ; private final QuartzManage quartzManage ; private final RedisUtils redisUtils ; @ Override public PageResult < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( quartzJobMapper . findAll ( criteria , page ) ) ; } @ Override public PageResult < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( quartzLogMapper . findAll ( criteria , page ) ) ; } @ Override public List < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria ) { return quartzJobMapper . findAll ( criteria ) ; } @ Override public List < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria ) { return quartzLogMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( QuartzJob resources ) { if ( ! CronExpression . isValidExpression ( resources . getCronExpression ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } save ( resources ) ; quartzManage . addJob ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( QuartzJob resources ) { if ( ! CronExpression . isValidExpression ( resources . getCronExpression ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( StringUtils . isNotBlank ( resources . getSubTask ( ) ) ) { List < String > tasks = Arrays . asList ( resources . getSubTask ( ) . split ( "<STR_LIT>" ) ) ; if ( tasks . contains ( resources . getId ( ) . toString ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } saveOrUpdate ( resources ) ; quartzManage . updateJobCron ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateIsPause ( QuartzJob quartzJob ) { if ( quartzJob . getIsPause ( ) ) { quartzManage . resumeJob ( quartzJob ) ; quartzJob . setIsPause ( false ) ; } else { quartzManage . pauseJob ( quartzJob ) ; quartzJob . setIsPause ( true ) ; } saveOrUpdate ( quartzJob ) ; } @ Override public void execution ( QuartzJob quartzJob ) { quartzManage . runJobNow ( quartzJob ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { QuartzJob quartzJob = getById ( id ) ; quartzManage . deleteJob ( quartzJob ) ; removeById ( quartzJob ) ; } } @ Async @ Override @ Transactional ( rollbackFor = Exception . class ) public void executionSubJob ( String [ ] tasks ) throws InterruptedException { for ( String id : tasks ) { if ( StrUtil . isBlank ( id ) ) { continue ; } QuartzJob quartzJob = getById ( Long . parseLong ( id ) ) ; String uuid = IdUtil . simpleUUID ( ) ; quartzJob . setUuid ( uuid ) ; execution ( quartzJob ) ; Boolean result = ( Boolean ) redisUtils . get ( uuid ) ; while ( result == null ) { Thread . sleep ( <NUM_LIT> ) ; result = ( Boolean ) redisUtils . get ( uuid ) ; } if ( ! result ) { redisUtils . del ( uuid ) ; break ; } } } @ Override public void download ( List < QuartzJob > quartzJobs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QuartzJob quartzJob : quartzJobs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , quartzJob . getJobName ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getBeanName ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getMethodName ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getParams ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getCronExpression ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getIsPause ( ) ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , quartzJob . getDescription ( ) ) ; map . put ( "<STR_LIT>" , quartzJob . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void downloadLog ( List < QuartzLog > queryAllLog , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QuartzLog quartzLog : queryAllLog ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , quartzLog . getJobName ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getBeanName ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getMethodName ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getParams ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getCronExpression ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getExceptionDetail ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getTime ( ) ) ; map . put ( "<STR_LIT>" , quartzLog . getIsSuccess ( ) ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , quartzLog . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . SysLog ; import me . zhengjie . service . SysLogService ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class SysLogController { private final SysLogService sysLogService ; @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportLog ( HttpServletResponse response , SysLogQueryCriteria criteria ) throws IOException { criteria . setLogType ( "<STR_LIT>" ) ; sysLogService . download ( sysLogService . queryAll ( criteria ) , response ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportErrorLog ( HttpServletResponse response , SysLogQueryCriteria criteria ) throws IOException { criteria . setLogType ( "<STR_LIT>" ) ; sysLogService . download ( sysLogService . queryAll ( criteria ) , response ) ; } @ GetMapping @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < SysLog > > queryLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( "<STR_LIT>" ) ; return new ResponseEntity < > ( sysLogService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) public ResponseEntity < PageResult < SysLog > > queryUserLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( "<STR_LIT>" ) ; criteria . setUsername ( SecurityUtils . getCurrentUsername ( ) ) ; return new ResponseEntity < > ( sysLogService . queryAllByUser ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < SysLog > > queryErrorLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( "<STR_LIT>" ) ; return new ResponseEntity < > ( sysLogService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > queryErrorLogDetail ( @ PathVariable Long id ) { return new ResponseEntity < > ( sysLogService . findByErrDetail ( id ) , HttpStatus . OK ) ; } @ DeleteMapping ( value = "<STR_LIT>" ) @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > delAllErrorLog ( ) { sysLogService . delAllByError ( ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ DeleteMapping ( value = "<STR_LIT>" ) @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > delAllInfoLog ( ) { sysLogService . delAllByInfo ( ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; @ Data public class DictDetailQueryCriteria { private String label ; private String dictName ; } </s>
<s> package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class DeployHistoryController { private final DeployHistoryService deployhistoryService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportDeployHistory ( HttpServletResponse response , DeployHistoryQueryCriteria criteria ) throws IOException { deployhistoryService . download ( deployhistoryService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < DeployHistory > > queryDeployHistory ( DeployHistoryQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( deployhistoryService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDeployHistory ( @ RequestBody Set < String > ids ) { deployhistoryService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface ServerMapper extends BaseMapper < Server > { Server findByIp ( @ Param ( "<STR_LIT>" ) String ip ) ; IPage < Server > findAll ( @ Param ( "<STR_LIT>" ) ServerQueryCriteria criteria , Page < Object > page ) ; List < Server > findAll ( @ Param ( "<STR_LIT>" ) ServerQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . security . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . EncryptUtils ; import me . zhengjie . utils . PageResult ; import org . springframework . data . domain . Pageable ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class OnlineController { private final OnlineUserService onlineUserService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < OnlineUserDto > > queryOnlineUser ( String username , Pageable pageable ) { return new ResponseEntity < > ( onlineUserService . getAll ( username , pageable ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportOnlineUser ( HttpServletResponse response , String username ) throws IOException { onlineUserService . download ( onlineUserService . getAll ( username ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteOnlineUser ( @ RequestBody Set < String > keys ) throws Exception { for ( String token : keys ) { token = EncryptUtils . desDecrypt ( token ) ; onlineUserService . logout ( token ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import java . time . LocalDateTime ; import java . util . Date ; public class DateUtilsTest { @ Test public void test1 ( ) { long l = System . currentTimeMillis ( ) / <NUM_LIT> ; LocalDateTime localDateTime = DateUtil . fromTimeStamp ( l ) ; System . out . print ( DateUtil . localDateTimeFormatyMdHms ( localDateTime ) ) ; } @ Test public void test2 ( ) { LocalDateTime now = LocalDateTime . now ( ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( now ) ) ; Date date = DateUtil . toDate ( now ) ; LocalDateTime localDateTime = DateUtil . toLocalDateTime ( date ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( localDateTime ) ) ; LocalDateTime localDateTime1 = DateUtil . fromTimeStamp ( date . getTime ( ) / <NUM_LIT> ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( localDateTime1 ) ) ; } } </s>
<s> package me . zhengjie . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . QiniuConfigMapper ; import me . zhengjie . service . QiNiuConfigService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class QiNiuConfigServiceImpl extends ServiceImpl < QiniuConfigMapper , QiniuConfig > implements QiNiuConfigService { @ Override @ Cacheable ( key = "<STR_LIT>" ) public QiniuConfig getConfig ( ) { QiniuConfig qiniuConfig = getById ( <NUM_LIT> ) ; return qiniuConfig == null ? new QiniuConfig ( ) : qiniuConfig ; } @ Override @ CacheEvict ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public void saveConfig ( QiniuConfig qiniuConfig ) { qiniuConfig . setId ( <NUM_LIT> ) ; String http = "<STR_LIT>" , https = "<STR_LIT>" ; if ( ! ( qiniuConfig . getHost ( ) . toLowerCase ( ) . startsWith ( http ) || qiniuConfig . getHost ( ) . toLowerCase ( ) . startsWith ( https ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } saveOrUpdate ( qiniuConfig ) ; } @ Override @ CacheEvict ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public void updateType ( String type ) { QiniuConfig qiniuConfig = getById ( <NUM_LIT> ) ; qiniuConfig . setType ( type ) ; saveOrUpdate ( qiniuConfig ) ; } } </s>
<s> package me . zhengjie . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotEmpty ; import java . util . List ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class EmailVo { @ NotEmpty private List < String > tos ; @ NotBlank private String subject ; @ NotBlank private String content ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . mapper . DictDetailMapper ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . DictMapper ; import me . zhengjie . modules . system . service . DictService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class DictServiceImpl extends ServiceImpl < DictMapper , Dict > implements DictService { private final DictMapper dictMapper ; private final RedisUtils redisUtils ; private final DictDetailMapper deleteDetail ; @ Override public PageResult < Dict > queryAll ( DictQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Dict > dicts = dictMapper . findAll ( criteria ) ; Long total = dictMapper . countAll ( criteria ) ; return PageUtil . toPage ( dicts , total ) ; } @ Override public List < Dict > queryAll ( DictQueryCriteria criteria ) { return dictMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Dict resources ) { save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Dict resources ) { delCaches ( resources ) ; Dict dict = getById ( resources . getId ( ) ) ; dict . setName ( resources . getName ( ) ) ; dict . setDescription ( resources . getDescription ( ) ) ; saveOrUpdate ( dict ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { List < Dict > dicts = dictMapper . selectBatchIds ( ids ) ; for ( Dict dict : dicts ) { delCaches ( dict ) ; } dictMapper . deleteBatchIds ( ids ) ; deleteDetail . deleteByDictBatchIds ( ids ) ; } @ Override public void download ( List < Dict > dicts , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Dict dict : dicts ) { if ( CollectionUtil . isNotEmpty ( dict . getDictDetails ( ) ) ) { for ( DictDetail dictDetail : dict . getDictDetails ( ) ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , dict . getName ( ) ) ; map . put ( "<STR_LIT>" , dict . getDescription ( ) ) ; map . put ( "<STR_LIT>" , dictDetail . getLabel ( ) ) ; map . put ( "<STR_LIT>" , dictDetail . getValue ( ) ) ; map . put ( "<STR_LIT>" , dictDetail . getCreateTime ( ) ) ; list . add ( map ) ; } } else { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , dict . getName ( ) ) ; map . put ( "<STR_LIT>" , dict . getDescription ( ) ) ; map . put ( "<STR_LIT>" , null ) ; map . put ( "<STR_LIT>" , null ) ; map . put ( "<STR_LIT>" , dict . getCreateTime ( ) ) ; list . add ( map ) ; } } FileUtil . downloadExcel ( list , response ) ; } public void delCaches ( Dict dict ) { redisUtils . del ( CacheKey . DICT_NAME + dict . getName ( ) ) ; } } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Set ; @ Mapper public interface RoleMapper extends BaseMapper < Role > { List < Role > queryAll ( ) ; Role findById ( @ Param ( "<STR_LIT>" ) Long roleId ) ; Role findByName ( @ Param ( "<STR_LIT>" ) String name ) ; List < Role > findByUserId ( @ Param ( "<STR_LIT>" ) Long userId ) ; Long countAll ( @ Param ( "<STR_LIT>" ) RoleQueryCriteria criteria ) ; List < Role > findAll ( @ Param ( "<STR_LIT>" ) RoleQueryCriteria criteria ) ; int countByDepts ( @ Param ( "<STR_LIT>" ) Set < Long > deptIds ) ; @ Select ( "<STR_LIT>" + "<STR_LIT>" ) List < Role > findByMenuId ( @ Param ( "<STR_LIT>" ) Long menuId ) ; } </s>
<s> package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . GenConfigService ; import me . zhengjie . service . GeneratorService ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class GeneratorController { private final GeneratorService generatorService ; private final GenConfigService genConfigService ; @ Value ( "<STR_LIT>" ) private Boolean generatorEnabled ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < PageResult < TableInfo > > queryTables ( @ RequestParam ( defaultValue = "<STR_LIT>" ) String name , Page < Object > page ) { return new ResponseEntity < > ( generatorService . getTables ( name , page ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < PageResult < ColumnInfo > > queryColumns ( @ RequestParam String tableName ) { List < ColumnInfo > columnInfos = generatorService . getColumns ( tableName ) ; return new ResponseEntity < > ( PageUtil . toPage ( columnInfos ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PutMapping public ResponseEntity < HttpStatus > saveColumn ( @ RequestBody List < ColumnInfo > columnInfos ) { generatorService . save ( columnInfos ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) public ResponseEntity < HttpStatus > syncColumn ( @ RequestBody List < String > tables ) { for ( String table : tables ) { generatorService . sync ( generatorService . getColumns ( table ) , generatorService . query ( table ) ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > generatorCode ( @ PathVariable String tableName , @ PathVariable Integer type , HttpServletRequest request , HttpServletResponse response ) { if ( ! generatorEnabled && type == <NUM_LIT> ) { throw new BadRequestException ( "<STR_LIT>" ) ; } switch ( type ) { case <NUM_LIT> : generatorService . generator ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) ) ; break ; case <NUM_LIT> : return generatorService . preview ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) ) ; case <NUM_LIT> : generatorService . download ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) , request , response ) ; break ; default : throw new BadRequestException ( "<STR_LIT>" ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . utils ; import com . baomidou . mybatisplus . core . metadata . IPage ; import java . util . * ; public class PageUtil extends cn . hutool . core . util . PageUtil { public static < T > List < T > paging ( int page , int size , List < T > list ) { int fromIndex = page * size ; int toIndex = page * size + size ; if ( fromIndex > list . size ( ) ) { return Collections . emptyList ( ) ; } else if ( toIndex >= list . size ( ) ) { return list . subList ( fromIndex , list . size ( ) ) ; } else { return list . subList ( fromIndex , toIndex ) ; } } public static < T > PageResult < T > toPage ( IPage < T > page ) { return new PageResult < > ( page . getRecords ( ) , page . getTotal ( ) ) ; } public static < T > PageResult < T > toPage ( List < T > list ) { return new PageResult < > ( list , list . size ( ) ) ; } public static < T > PageResult < T > noData ( ) { return new PageResult < > ( null , <NUM_LIT> ) ; } public static < T > PageResult < T > toPage ( List < T > list , long totalElements ) { return new PageResult < > ( list , totalElements ) ; } } </s>
<s> package me . zhengjie . utils ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . security . core . userdetails . UserDetailsService ; import java . util . List ; @ Slf4j public class SecurityUtils { public static UserDetails getCurrentUser ( ) { UserDetailsService userDetailsService = SpringContextHolder . getBean ( UserDetailsService . class ) ; return userDetailsService . loadUserByUsername ( getCurrentUsername ( ) ) ; } public static String getCurrentUsername ( ) { final Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { throw new BadRequestException ( HttpStatus . UNAUTHORIZED , "<STR_LIT>" ) ; } if ( authentication . getPrincipal ( ) instanceof UserDetails ) { UserDetails userDetails = ( UserDetails ) authentication . getPrincipal ( ) ; return userDetails . getUsername ( ) ; } throw new BadRequestException ( HttpStatus . UNAUTHORIZED , "<STR_LIT>" ) ; } public static Long getCurrentUserId ( ) { UserDetails userDetails = getCurrentUser ( ) ; JSONObject jsonObject = ( JSONObject ) JSON . toJSON ( userDetails ) ; return jsonObject . getJSONObject ( "<STR_LIT>" ) . getLong ( "<STR_LIT>" ) ; } public static List < Long > getCurrentUserDataScope ( ) { UserDetails userDetails = getCurrentUser ( ) ; JSONObject jsonObject = ( JSONObject ) JSON . toJSON ( userDetails ) ; JSONArray jsonArray = jsonObject . getJSONArray ( "<STR_LIT>" ) ; return JSON . parseArray ( jsonArray . toJSONString ( ) , Long . class ) ; } public static String getDataScopeType ( ) { List < Long > dataScopes = getCurrentUserDataScope ( ) ; if ( dataScopes . size ( ) != <NUM_LIT> ) { return "<STR_LIT>" ; } return DataScopeEnum . ALL . getValue ( ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DatabaseQueryCriteria { private String name ; private String jdbcUrl ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; public interface QiniuContentService extends IService < QiniuContent > { PageResult < QiniuContent > queryAll ( QiniuQueryCriteria criteria , Page < Object > page ) ; List < QiniuContent > queryAll ( QiniuQueryCriteria criteria ) ; QiniuContent upload ( MultipartFile file , QiniuConfig qiniuConfig ) ; String download ( QiniuContent content , QiniuConfig config ) ; void delete ( QiniuContent content , QiniuConfig config ) ; void synchronize ( QiniuConfig config ) ; void deleteAll ( Long [ ] ids , QiniuConfig config ) ; void downloadList ( List < QiniuContent > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . system . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . service . DictService ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class DictController { private final DictService dictService ; private static final String ENTITY_NAME = "<STR_LIT>" ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportDict ( HttpServletResponse response , DictQueryCriteria criteria ) throws IOException { dictService . download ( dictService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < List < Dict > > queryAllDict ( ) { return new ResponseEntity < > ( dictService . queryAll ( new DictQueryCriteria ( ) ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Dict > > queryDict ( DictQueryCriteria resources , Page < Object > page ) { return new ResponseEntity < > ( dictService . queryAll ( resources , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createDict ( @ Validated @ RequestBody Dict resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } dictService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateDict ( @ Validated ( Dict . Update . class ) @ RequestBody Dict resources ) { dictService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDict ( @ RequestBody Set < Long > ids ) { dictService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DictService extends IService < Dict > { PageResult < Dict > queryAll ( DictQueryCriteria criteria , Page < Object > page ) ; List < Dict > queryAll ( DictQueryCriteria criteria ) ; void create ( Dict resources ) ; void update ( Dict resources ) ; void delete ( Set < Long > ids ) ; void download ( List < Dict > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . quartz . config ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . mapper . QuartzJobMapper ; import me . zhengjie . modules . quartz . utils . QuartzManage ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . ApplicationArguments ; import org . springframework . boot . ApplicationRunner ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ RequiredArgsConstructor public class JobRunner implements ApplicationRunner { private static final Logger log = LoggerFactory . getLogger ( JobRunner . class ) ; private final QuartzJobMapper quartzJobMapper ; private final QuartzManage quartzManage ; @ Override public void run ( ApplicationArguments applicationArguments ) { List < QuartzJob > quartzJobs = quartzJobMapper . findByIsPauseIsFalse ( ) ; quartzJobs . forEach ( quartzManage :: addJob ) ; log . info ( "<STR_LIT>" ) ; } } </s>
<s> package me . zhengjie . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ZipUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . ColumnInfoMapper ; import me . zhengjie . service . GeneratorService ; import me . zhengjie . utils . * ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Slf4j @ Service @ RequiredArgsConstructor public class GeneratorServiceImpl extends ServiceImpl < ColumnInfoMapper , ColumnInfo > implements GeneratorService { private final ColumnInfoMapper columnInfoMapper ; private final String CONFIG_MESSAGE = "<STR_LIT>" ; @ Override public PageResult < TableInfo > getTables ( String name , Page < Object > page ) { return PageUtil . toPage ( columnInfoMapper . getTables ( name , page ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public List < ColumnInfo > getColumns ( String tableName ) { List < ColumnInfo > columnInfos = columnInfoMapper . findByTableNameOrderByIdAsc ( tableName ) ; if ( CollectionUtil . isNotEmpty ( columnInfos ) ) { return columnInfos ; } else { columnInfos = query ( tableName ) ; saveBatch ( columnInfos ) ; return columnInfos ; } } @ Override public List < ColumnInfo > query ( String tableName ) { List < ColumnInfo > columnInfos = columnInfoMapper . getColumns ( tableName ) ; for ( ColumnInfo columnInfo : columnInfos ) { columnInfo . setTableName ( tableName ) ; if ( GenUtil . PK . equalsIgnoreCase ( columnInfo . getKeyType ( ) ) && GenUtil . EXTRA . equalsIgnoreCase ( columnInfo . getExtra ( ) ) ) { columnInfo . setNotNull ( false ) ; } } return columnInfos ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void sync ( List < ColumnInfo > columnInfos , List < ColumnInfo > columnInfoList ) { for ( ColumnInfo columnInfo : columnInfoList ) { List < ColumnInfo > columns = columnInfos . stream ( ) . filter ( c -> c . getColumnName ( ) . equals ( columnInfo . getColumnName ( ) ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtil . isNotEmpty ( columns ) ) { ColumnInfo column = columns . get ( <NUM_LIT> ) ; column . setColumnType ( columnInfo . getColumnType ( ) ) ; column . setExtra ( columnInfo . getExtra ( ) ) ; column . setKeyType ( columnInfo . getKeyType ( ) ) ; if ( StringUtils . isBlank ( column . getRemark ( ) ) ) { column . setRemark ( columnInfo . getRemark ( ) ) ; } saveOrUpdate ( column ) ; } else { save ( columnInfo ) ; } } for ( ColumnInfo columnInfo : columnInfos ) { List < ColumnInfo > columns = columnInfoList . stream ( ) . filter ( c -> c . getColumnName ( ) . equals ( columnInfo . getColumnName ( ) ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtil . isEmpty ( columns ) ) { removeById ( columnInfo ) ; } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void save ( List < ColumnInfo > columnInfos ) { saveOrUpdateBatch ( columnInfos ) ; } @ Override public void generator ( GenConfig genConfig , List < ColumnInfo > columns ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } try { GenUtil . generatorCode ( columns , genConfig ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } @ Override public ResponseEntity < Object > preview ( GenConfig genConfig , List < ColumnInfo > columns ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } List < Map < String , Object > > genList = GenUtil . preview ( columns , genConfig ) ; return new ResponseEntity < > ( genList , HttpStatus . OK ) ; } @ Override public void download ( GenConfig genConfig , List < ColumnInfo > columns , HttpServletRequest request , HttpServletResponse response ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } try { File file = new File ( GenUtil . download ( columns , genConfig ) ) ; String zipPath = file . getPath ( ) + "<STR_LIT>" ; ZipUtil . zip ( file . getPath ( ) , zipPath ) ; FileUtil . downloadFile ( request , response , new File ( zipPath ) , true ) ; } catch ( IOException e ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import static me . zhengjie . utils . EncryptUtils . * ; import static org . junit . jupiter . api . Assertions . assertEquals ; public class EncryptUtilsTest { @ Test public void testDesEncrypt ( ) { try { assertEquals ( "<STR_LIT>" , desEncrypt ( "<STR_LIT>" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Test public void testDesDecrypt ( ) { try { assertEquals ( "<STR_LIT>" , desDecrypt ( "<STR_LIT>" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . alibaba . fastjson . annotation . JSONField ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Dept extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ JSONField ( serialize = false ) @ ApiModelProperty ( value = "<STR_LIT>" ) private Set < Role > roles ; @ TableField ( exist = false ) private List < Dept > children ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer deptSort ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ NotNull @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean enabled ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Long pid ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Integer subCount = <NUM_LIT> ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Dept dept = ( Dept ) o ; return Objects . equals ( id , dept . id ) && Objects . equals ( name , dept . name ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , name ) ; } public Boolean getHasChildren ( ) { return subCount > <NUM_LIT> ; } public Boolean getLeaf ( ) { return subCount <= <NUM_LIT> ; } public String getLabel ( ) { return name ; } } </s>
<s> package me . zhengjie . service . impl ; import com . alipay . api . AlipayClient ; import com . alipay . api . DefaultAlipayClient ; import com . alipay . api . request . AlipayTradePagePayRequest ; import com . alipay . api . request . AlipayTradeWapPayRequest ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . AliPayConfigMapper ; import me . zhengjie . service . AliPayService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CachePut ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class AliPayServiceImpl extends ServiceImpl < AliPayConfigMapper , AlipayConfig > implements AliPayService { @ Override @ Cacheable ( key = "<STR_LIT>" ) public AlipayConfig find ( ) { AlipayConfig alipayConfig = getById ( <NUM_LIT> ) ; return alipayConfig == null ? new AlipayConfig ( ) : alipayConfig ; } @ Override @ CachePut ( key = "<STR_LIT>" ) @ Transactional ( rollbackFor = Exception . class ) public AlipayConfig config ( AlipayConfig alipayConfig ) { alipayConfig . setId ( <NUM_LIT> ) ; saveOrUpdate ( alipayConfig ) ; return alipayConfig ; } @ Override public String toPayAsPc ( AlipayConfig alipay , TradeVo trade ) throws Exception { if ( alipay . getId ( ) == null ) { throw new BadRequestException ( "<STR_LIT>" ) ; } AlipayClient alipayClient = new DefaultAlipayClient ( alipay . getGatewayUrl ( ) , alipay . getAppId ( ) , alipay . getPrivateKey ( ) , alipay . getFormat ( ) , alipay . getCharset ( ) , alipay . getPublicKey ( ) , alipay . getSignType ( ) ) ; AlipayTradePagePayRequest request = new AlipayTradePagePayRequest ( ) ; request . setReturnUrl ( alipay . getReturnUrl ( ) ) ; request . setNotifyUrl ( alipay . getNotifyUrl ( ) ) ; request . setBizContent ( "<STR_LIT>" + "<STR_LIT>" + trade . getOutTradeNo ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + trade . getTotalAmount ( ) + "<STR_LIT>" + "<STR_LIT>" + trade . getSubject ( ) + "<STR_LIT>" + "<STR_LIT>" + trade . getBody ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + alipay . getSysServiceProviderId ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; return alipayClient . pageExecute ( request , "<STR_LIT>" ) . getBody ( ) ; } @ Override public String toPayAsWeb ( AlipayConfig alipay , TradeVo trade ) throws Exception { if ( alipay . getId ( ) == null ) { throw new BadRequestException ( "<STR_LIT>" ) ; } AlipayClient alipayClient = new DefaultAlipayClient ( alipay . getGatewayUrl ( ) , alipay . getAppId ( ) , alipay . getPrivateKey ( ) , alipay . getFormat ( ) , alipay . getCharset ( ) , alipay . getPublicKey ( ) , alipay . getSignType ( ) ) ; double money = Double . parseDouble ( trade . getTotalAmount ( ) ) ; double maxMoney = <NUM_LIT> ; if ( money <= <NUM_LIT> || money >= maxMoney ) { throw new BadRequestException ( "<STR_LIT>" ) ; } AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest ( ) ; request . setReturnUrl ( alipay . getReturnUrl ( ) ) ; request . setNotifyUrl ( alipay . getNotifyUrl ( ) ) ; request . setBizContent ( "<STR_LIT>" + "<STR_LIT>" + trade . getOutTradeNo ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + trade . getTotalAmount ( ) + "<STR_LIT>" + "<STR_LIT>" + trade . getSubject ( ) + "<STR_LIT>" + "<STR_LIT>" + trade . getBody ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + alipay . getSysServiceProviderId ( ) + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; return alipayClient . pageExecute ( request , "<STR_LIT>" ) . getBody ( ) ; } } </s>
<s> package me . zhengjie . modules . mnt . util ; import ch . ethz . ssh2 . Connection ; import ch . ethz . ssh2 . SCPClient ; import com . google . common . collect . Maps ; import java . io . IOException ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ScpClientUtil { static private Map < String , ScpClientUtil > instance = Maps . newHashMap ( ) ; static synchronized public ScpClientUtil getInstance ( String ip , int port , String username , String password ) { if ( instance . get ( ip ) == null ) { instance . put ( ip , new ScpClientUtil ( ip , port , username , password ) ) ; } return instance . get ( ip ) ; } public ScpClientUtil ( String ip , int port , String username , String password ) { this . ip = ip ; this . port = port ; this . username = username ; this . password = password ; } public void getFile ( String remoteFile , String localTargetDirectory ) { Connection conn = new Connection ( ip , port ) ; try { conn . connect ( ) ; boolean isAuthenticated = conn . authenticateWithPassword ( username , password ) ; if ( ! isAuthenticated ) { System . err . println ( "<STR_LIT>" ) ; } SCPClient client = new SCPClient ( conn ) ; client . get ( remoteFile , localTargetDirectory ) ; } catch ( IOException ex ) { Logger . getLogger ( SCPClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { conn . close ( ) ; } } public void putFile ( String localFile , String remoteTargetDirectory ) { putFile ( localFile , null , remoteTargetDirectory ) ; } public void putFile ( String localFile , String remoteFileName , String remoteTargetDirectory ) { putFile ( localFile , remoteFileName , remoteTargetDirectory , null ) ; } public void putFile ( String localFile , String remoteFileName , String remoteTargetDirectory , String mode ) { Connection conn = new Connection ( ip , port ) ; try { conn . connect ( ) ; boolean isAuthenticated = conn . authenticateWithPassword ( username , password ) ; if ( ! isAuthenticated ) { System . err . println ( "<STR_LIT>" ) ; } SCPClient client = new SCPClient ( conn ) ; if ( ( mode == null ) || ( mode . length ( ) == <NUM_LIT> ) ) { mode = "<STR_LIT>" ; } if ( remoteFileName == null ) { client . put ( localFile , remoteTargetDirectory ) ; } else { client . put ( localFile , remoteFileName , remoteTargetDirectory , mode ) ; } } catch ( IOException ex ) { Logger . getLogger ( ScpClientUtil . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { conn . close ( ) ; } } private String ip ; private int port ; private String username ; private String password ; } </s>
<s> package me . zhengjie . modules . security . security ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import org . springframework . security . config . annotation . SecurityConfigurerAdapter ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . web . DefaultSecurityFilterChain ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; @ RequiredArgsConstructor public class TokenConfigurer extends SecurityConfigurerAdapter < DefaultSecurityFilterChain , HttpSecurity > { private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; @ Override public void configure ( HttpSecurity http ) { TokenFilter customFilter = new TokenFilter ( tokenProvider , properties , onlineUserService , userCacheManager ) ; http . addFilterBefore ( customFilter , UsernamePasswordAuthenticationFilter . class ) ; } } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( "<STR_LIT>" ) public class EmailConfig implements Serializable { @ TableId ( "<STR_LIT>" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String host ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String port ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String user ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String pass ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String fromUser ; } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . sql . Timestamp ; import java . util . List ; @ Data @ NoArgsConstructor public class JobQueryCriteria { private String name ; private Boolean enabled ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import org . springframework . mock . web . MockMultipartFile ; import static me . zhengjie . utils . FileUtil . * ; import static org . junit . jupiter . api . Assertions . assertEquals ; public class FileUtilTest { @ Test public void testToFile ( ) { long retval = toFile ( new MockMultipartFile ( "<STR_LIT>" , ( byte [ ] ) null ) ) . getTotalSpace ( ) ; assertEquals ( <NUM_LIT> , retval ) ; } @ Test public void testGetExtensionName ( ) { assertEquals ( "<STR_LIT>" , getExtensionName ( "<STR_LIT>" ) ) ; assertEquals ( "<STR_LIT>" , getExtensionName ( "<STR_LIT>" ) ) ; } @ Test public void testGetFileNameNoEx ( ) { assertEquals ( "<STR_LIT>" , getFileNameNoEx ( "<STR_LIT>" ) ) ; assertEquals ( "<STR_LIT>" , getFileNameNoEx ( "<STR_LIT>" ) ) ; } @ Test public void testGetSize ( ) { assertEquals ( "<STR_LIT>" , getSize ( <NUM_LIT> ) ) ; assertEquals ( "<STR_LIT>" , getSize ( <NUM_LIT> ) ) ; assertEquals ( "<STR_LIT>" , getSize ( <NUM_LIT> ) ) ; assertEquals ( "<STR_LIT>" , getSize ( <NUM_LIT> ) ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DeployQueryCriteria { private String appName ; private List < Timestamp > createTime ; private Long offset ; private Long size ; } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . SysLog ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface SysLogMapper extends BaseMapper < SysLog > { List < SysLog > queryAll ( @ Param ( "<STR_LIT>" ) SysLogQueryCriteria criteria ) ; IPage < SysLog > queryAll ( @ Param ( "<STR_LIT>" ) SysLogQueryCriteria criteria , Page < SysLog > page ) ; IPage < SysLog > queryAllByUser ( @ Param ( "<STR_LIT>" ) SysLogQueryCriteria criteria , Page < SysLog > page ) ; String getExceptionDetails ( @ Param ( "<STR_LIT>" ) Long id ) ; void deleteByLevel ( @ Param ( "<STR_LIT>" ) String logType ) ; } </s>
<s> package me . zhengjie . annotation ; import me . zhengjie . aspect . LimitType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface Limit { String name ( ) default "<STR_LIT>" ; String key ( ) default "<STR_LIT>" ; String prefix ( ) default "<STR_LIT>" ; int period ( ) ; int count ( ) ; LimitType limitType ( ) default LimitType . CUSTOMER ; } </s>
<s> package me . zhengjie . modules . system . service ; import me . zhengjie . modules . system . domain . User ; import java . util . List ; public interface DataService { List < Long > getDeptIds ( User user ) ; } </s>
<s> package me . zhengjie . aspect ; import com . google . common . collect . ImmutableList ; import me . zhengjie . annotation . Limit ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . utils . RequestHolder ; import me . zhengjie . utils . StringUtils ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . aspectj . lang . reflect . MethodSignature ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . script . DefaultRedisScript ; import org . springframework . data . redis . core . script . RedisScript ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Method ; @ Aspect @ Component public class LimitAspect { private final RedisTemplate < Object , Object > redisTemplate ; private static final Logger logger = LoggerFactory . getLogger ( LimitAspect . class ) ; public LimitAspect ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; } @ Pointcut ( "<STR_LIT>" ) public void pointcut ( ) { } @ Around ( "<STR_LIT>" ) public Object around ( ProceedingJoinPoint joinPoint ) throws Throwable { HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ; MethodSignature signature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method signatureMethod = signature . getMethod ( ) ; Limit limit = signatureMethod . getAnnotation ( Limit . class ) ; LimitType limitType = limit . limitType ( ) ; String key = limit . key ( ) ; if ( StringUtils . isEmpty ( key ) ) { if ( limitType == LimitType . IP ) { key = StringUtils . getIp ( request ) ; } else { key = signatureMethod . getName ( ) ; } } ImmutableList < Object > keys = ImmutableList . of ( StringUtils . join ( limit . prefix ( ) , "<STR_LIT>" , key , "<STR_LIT>" , request . getRequestURI ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ; String luaScript = buildLuaScript ( ) ; RedisScript < Number > redisScript = new DefaultRedisScript < > ( luaScript , Number . class ) ; Number count = redisTemplate . execute ( redisScript , keys , limit . count ( ) , limit . period ( ) ) ; if ( null != count && count . intValue ( ) <= limit . count ( ) ) { logger . info ( "<STR_LIT>" , count , keys , limit . name ( ) ) ; return joinPoint . proceed ( ) ; } else { throw new BadRequestException ( "<STR_LIT>" ) ; } } private String buildLuaScript ( ) { return "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ; } } </s>
<s> package me . zhengjie . exception . handler ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . utils . ThrowableUtil ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . validation . FieldError ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ExceptionHandler ; import org . springframework . web . bind . annotation . RestControllerAdvice ; import static org . springframework . http . HttpStatus . * ; @ Slf4j @ RestControllerAdvice public class GlobalExceptionHandler { @ ExceptionHandler ( Throwable . class ) public ResponseEntity < ApiError > handleException ( Throwable e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getMessage ( ) ) ) ; } @ ExceptionHandler ( BadCredentialsException . class ) public ResponseEntity < ApiError > badCredentialsException ( BadCredentialsException e ) { String message = "<STR_LIT>" . equals ( e . getMessage ( ) ) ? "<STR_LIT>" : e . getMessage ( ) ; log . error ( message ) ; return buildResponseEntity ( ApiError . error ( message ) ) ; } @ ExceptionHandler ( value = BadRequestException . class ) public ResponseEntity < ApiError > badRequestException ( BadRequestException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getStatus ( ) , e . getMessage ( ) ) ) ; } @ ExceptionHandler ( value = EntityExistException . class ) public ResponseEntity < ApiError > entityExistException ( EntityExistException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getMessage ( ) ) ) ; } @ ExceptionHandler ( value = EntityNotFoundException . class ) public ResponseEntity < ApiError > entityNotFoundException ( EntityNotFoundException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( NOT_FOUND . value ( ) , e . getMessage ( ) ) ) ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) public ResponseEntity < ApiError > handleMethodArgumentNotValidException ( MethodArgumentNotValidException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; ObjectError objectError = e . getBindingResult ( ) . getAllErrors ( ) . get ( <NUM_LIT> ) ; String message = objectError . getDefaultMessage ( ) ; if ( objectError instanceof FieldError ) { message = ( ( FieldError ) objectError ) . getField ( ) + "<STR_LIT>" + message ; } return buildResponseEntity ( ApiError . error ( message ) ) ; } private ResponseEntity < ApiError > buildResponseEntity ( ApiError apiError ) { return new ResponseEntity < > ( apiError , HttpStatus . valueOf ( apiError . getStatus ( ) ) ) ; } } </s>
<s> package me . zhengjie . modules . security . config ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . security . * ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . utils . enums . RequestMethodEnum ; import org . springframework . context . ApplicationContext ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpMethod ; import org . springframework . security . config . annotation . method . configuration . EnableGlobalMethodSecurity ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . config . annotation . web . configuration . EnableWebSecurity ; import org . springframework . security . config . annotation . web . configuration . WebSecurityConfigurerAdapter ; import org . springframework . security . config . core . GrantedAuthorityDefaults ; import org . springframework . security . config . http . SessionCreationPolicy ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . mvc . method . RequestMappingInfo ; import org . springframework . web . servlet . mvc . method . annotation . RequestMappingHandlerMapping ; import java . util . * ; @ Configuration @ EnableWebSecurity @ RequiredArgsConstructor @ EnableGlobalMethodSecurity ( prePostEnabled = true , securedEnabled = true ) public class SpringSecurityConfig extends WebSecurityConfigurerAdapter { private final TokenProvider tokenProvider ; private final CorsFilter corsFilter ; private final JwtAuthenticationEntryPoint authenticationErrorHandler ; private final JwtAccessDeniedHandler jwtAccessDeniedHandler ; private final ApplicationContext applicationContext ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; @ Bean GrantedAuthorityDefaults grantedAuthorityDefaults ( ) { return new GrantedAuthorityDefaults ( "<STR_LIT>" ) ; } @ Bean public PasswordEncoder passwordEncoder ( ) { return new BCryptPasswordEncoder ( ) ; } @ Override protected void configure ( HttpSecurity httpSecurity ) throws Exception { RequestMappingHandlerMapping requestMappingHandlerMapping = ( RequestMappingHandlerMapping ) applicationContext . getBean ( "<STR_LIT>" ) ; Map < RequestMappingInfo , HandlerMethod > handlerMethodMap = requestMappingHandlerMapping . getHandlerMethods ( ) ; Map < String , Set < String > > anonymousUrls = getAnonymousUrl ( handlerMethodMap ) ; httpSecurity . csrf ( ) . disable ( ) . addFilterBefore ( corsFilter , UsernamePasswordAuthenticationFilter . class ) . exceptionHandling ( ) . authenticationEntryPoint ( authenticationErrorHandler ) . accessDeniedHandler ( jwtAccessDeniedHandler ) . and ( ) . headers ( ) . frameOptions ( ) . disable ( ) . and ( ) . sessionManagement ( ) . sessionCreationPolicy ( SessionCreationPolicy . STATELESS ) . and ( ) . authorizeRequests ( ) . antMatchers ( HttpMethod . GET , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( "<STR_LIT>" ) . permitAll ( ) . antMatchers ( HttpMethod . OPTIONS , "<STR_LIT>" ) . permitAll ( ) . antMatchers ( HttpMethod . GET , anonymousUrls . get ( RequestMethodEnum . GET . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . POST , anonymousUrls . get ( RequestMethodEnum . POST . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . PUT , anonymousUrls . get ( RequestMethodEnum . PUT . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . PATCH , anonymousUrls . get ( RequestMethodEnum . PATCH . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . DELETE , anonymousUrls . get ( RequestMethodEnum . DELETE . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( anonymousUrls . get ( RequestMethodEnum . ALL . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) . and ( ) . apply ( securityConfigurerAdapter ( ) ) ; } private TokenConfigurer securityConfigurerAdapter ( ) { return new TokenConfigurer ( tokenProvider , properties , onlineUserService , userCacheManager ) ; } private Map < String , Set < String > > getAnonymousUrl ( Map < RequestMappingInfo , HandlerMethod > handlerMethodMap ) { Map < String , Set < String > > anonymousUrls = new HashMap < > ( <NUM_LIT> ) ; Set < String > get = new HashSet < > ( ) ; Set < String > post = new HashSet < > ( ) ; Set < String > put = new HashSet < > ( ) ; Set < String > patch = new HashSet < > ( ) ; Set < String > delete = new HashSet < > ( ) ; Set < String > all = new HashSet < > ( ) ; for ( Map . Entry < RequestMappingInfo , HandlerMethod > infoEntry : handlerMethodMap . entrySet ( ) ) { HandlerMethod handlerMethod = infoEntry . getValue ( ) ; AnonymousAccess anonymousAccess = handlerMethod . getMethodAnnotation ( AnonymousAccess . class ) ; if ( null != anonymousAccess ) { List < RequestMethod > requestMethods = new ArrayList < > ( infoEntry . getKey ( ) . getMethodsCondition ( ) . getMethods ( ) ) ; RequestMethodEnum request = RequestMethodEnum . find ( requestMethods . size ( ) == <NUM_LIT> ? RequestMethodEnum . ALL . getType ( ) : requestMethods . get ( <NUM_LIT> ) . name ( ) ) ; switch ( Objects . requireNonNull ( request ) ) { case GET : get . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case POST : post . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case PUT : put . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case PATCH : patch . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case DELETE : delete . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; default : all . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; } } } anonymousUrls . put ( RequestMethodEnum . GET . getType ( ) , get ) ; anonymousUrls . put ( RequestMethodEnum . POST . getType ( ) , post ) ; anonymousUrls . put ( RequestMethodEnum . PUT . getType ( ) , put ) ; anonymousUrls . put ( RequestMethodEnum . PATCH . getType ( ) , patch ) ; anonymousUrls . put ( RequestMethodEnum . DELETE . getType ( ) , delete ) ; anonymousUrls . put ( RequestMethodEnum . ALL . getType ( ) , all ) ; return anonymousUrls ; } } </s>
<s> package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class AppQueryCriteria { private String name ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; public interface LocalStorageService extends IService < LocalStorage > { PageResult < LocalStorage > queryAll ( LocalStorageQueryCriteria criteria , Page < Object > page ) ; List < LocalStorage > queryAll ( LocalStorageQueryCriteria criteria ) ; LocalStorage create ( String name , MultipartFile file ) ; void update ( LocalStorage resources ) ; void deleteAll ( Long [ ] ids ) ; void download ( List < LocalStorage > localStorages , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class SysLogQueryCriteria { private String blurry ; private String username ; private String logType ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . service . impl ; import com . alibaba . fastjson . JSON ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . qiniu . common . QiniuException ; import com . qiniu . http . Response ; import com . qiniu . storage . BucketManager ; import com . qiniu . storage . Configuration ; import com . qiniu . storage . UploadManager ; import com . qiniu . storage . model . DefaultPutRet ; import com . qiniu . storage . model . FileInfo ; import com . qiniu . util . Auth ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . mapper . QiniuContentMapper ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . QiNiuUtil ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . QiniuContentService ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageUtil ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class QiniuContentServiceImpl extends ServiceImpl < QiniuContentMapper , QiniuContent > implements QiniuContentService { private final QiniuContentMapper qiniuContentMapper ; @ Value ( "<STR_LIT>" ) private Long maxSize ; @ Override public PageResult < QiniuContent > queryAll ( QiniuQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( qiniuContentMapper . findAll ( criteria , page ) ) ; } @ Override public List < QiniuContent > queryAll ( QiniuQueryCriteria criteria ) { return qiniuContentMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public QiniuContent upload ( MultipartFile file , QiniuConfig qiniuConfig ) { FileUtil . checkSize ( maxSize , file . getSize ( ) ) ; if ( qiniuConfig . getId ( ) == null ) { throw new BadRequestException ( "<STR_LIT>" ) ; } Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( qiniuConfig . getZone ( ) ) ) ; UploadManager uploadManager = new UploadManager ( cfg ) ; Auth auth = Auth . create ( qiniuConfig . getAccessKey ( ) , qiniuConfig . getSecretKey ( ) ) ; String upToken = auth . uploadToken ( qiniuConfig . getBucket ( ) ) ; try { String key = file . getOriginalFilename ( ) ; if ( qiniuContentMapper . findByKey ( key ) != null ) { key = QiNiuUtil . getKey ( key ) ; } Response response = uploadManager . put ( file . getBytes ( ) , key , upToken ) ; DefaultPutRet putRet = JSON . parseObject ( response . bodyString ( ) , DefaultPutRet . class ) ; QiniuContent content = qiniuContentMapper . findByKey ( FileUtil . getFileNameNoEx ( putRet . key ) ) ; if ( content == null ) { QiniuContent qiniuContent = new QiniuContent ( ) ; qiniuContent . setSuffix ( FileUtil . getExtensionName ( putRet . key ) ) ; qiniuContent . setBucket ( qiniuConfig . getBucket ( ) ) ; qiniuContent . setType ( qiniuConfig . getType ( ) ) ; qiniuContent . setKey ( FileUtil . getFileNameNoEx ( putRet . key ) ) ; qiniuContent . setUrl ( qiniuConfig . getHost ( ) + "<STR_LIT>" + putRet . key ) ; qiniuContent . setSize ( FileUtil . getSize ( Integer . parseInt ( String . valueOf ( file . getSize ( ) ) ) ) ) ; save ( qiniuContent ) ; } return content ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } } @ Override public String download ( QiniuContent content , QiniuConfig config ) { String finalUrl ; String type = "<STR_LIT>" ; if ( type . equals ( content . getType ( ) ) ) { finalUrl = content . getUrl ( ) ; } else { Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; long expireInSeconds = <NUM_LIT> ; finalUrl = auth . privateDownloadUrl ( content . getUrl ( ) , expireInSeconds ) ; } return finalUrl ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( QiniuContent content , QiniuConfig config ) { Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( config . getZone ( ) ) ) ; Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; BucketManager bucketManager = new BucketManager ( auth , cfg ) ; try { bucketManager . delete ( content . getBucket ( ) , content . getKey ( ) + "<STR_LIT>" + content . getSuffix ( ) ) ; } catch ( QiniuException ex ) { ex . printStackTrace ( ) ; } finally { removeById ( content ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void synchronize ( QiniuConfig config ) { if ( config . getId ( ) == null ) { throw new BadRequestException ( "<STR_LIT>" ) ; } Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( config . getZone ( ) ) ) ; Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; BucketManager bucketManager = new BucketManager ( auth , cfg ) ; String prefix = "<STR_LIT>" ; int limit = <NUM_LIT> ; String delimiter = "<STR_LIT>" ; BucketManager . FileListIterator fileListIterator = bucketManager . createFileListIterator ( config . getBucket ( ) , prefix , limit , delimiter ) ; while ( fileListIterator . hasNext ( ) ) { QiniuContent qiniuContent ; FileInfo [ ] items = fileListIterator . next ( ) ; for ( FileInfo item : items ) { if ( qiniuContentMapper . findByKey ( FileUtil . getFileNameNoEx ( item . key ) ) == null ) { qiniuContent = new QiniuContent ( ) ; qiniuContent . setSize ( FileUtil . getSize ( Integer . parseInt ( String . valueOf ( item . fsize ) ) ) ) ; qiniuContent . setSuffix ( FileUtil . getExtensionName ( item . key ) ) ; qiniuContent . setKey ( FileUtil . getFileNameNoEx ( item . key ) ) ; qiniuContent . setType ( config . getType ( ) ) ; qiniuContent . setBucket ( config . getBucket ( ) ) ; qiniuContent . setUrl ( config . getHost ( ) + "<STR_LIT>" + item . key ) ; save ( qiniuContent ) ; } } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void deleteAll ( Long [ ] ids , QiniuConfig config ) { for ( Long id : ids ) { delete ( getById ( id ) , config ) ; } } @ Override public void downloadList ( List < QiniuContent > queryAll , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QiniuContent content : queryAll ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , content . getKey ( ) ) ; map . put ( "<STR_LIT>" , content . getSuffix ( ) ) ; map . put ( "<STR_LIT>" , content . getBucket ( ) ) ; map . put ( "<STR_LIT>" , content . getSize ( ) ) ; map . put ( "<STR_LIT>" , content . getType ( ) ) ; map . put ( "<STR_LIT>" , content . getUpdateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . utils ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; import java . util . Objects ; public class RequestHolder { public static HttpServletRequest getHttpServletRequest ( ) { return ( ( ServletRequestAttributes ) Objects . requireNonNull ( RequestContextHolder . getRequestAttributes ( ) ) ) . getRequest ( ) ; } } </s>
<s> package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum CodeBiEnum { ONE ( <NUM_LIT> , "<STR_LIT>" ) , TWO ( <NUM_LIT> , "<STR_LIT>" ) ; private final Integer code ; private final String description ; public static CodeBiEnum find ( Integer code ) { for ( CodeBiEnum value : CodeBiEnum . values ( ) ) { if ( value . getCode ( ) . equals ( code ) ) { return value ; } } return null ; } } </s>
<s> package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeployHistoryService extends IService < DeployHistory > { PageResult < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria , Page < Object > page ) ; List < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria ) ; void create ( DeployHistory resources ) ; void delete ( Set < String > ids ) ; void download ( List < DeployHistory > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . security . rest ; import cn . hutool . core . util . IdUtil ; import com . wf . captcha . base . Captcha ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousDeleteMapping ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . annotation . rest . AnonymousPostMapping ; import me . zhengjie . config . RsaProperties ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . config . bean . LoginCodeEnum ; import me . zhengjie . modules . security . config . bean . LoginProperties ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . modules . security . service . dto . AuthUserDto ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . utils . RsaUtils ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . SecurityUtils ; import me . zhengjie . utils . StringUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . config . annotation . authentication . builders . AuthenticationManagerBuilder ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ Slf4j @ RestController @ RequestMapping ( "<STR_LIT>" ) @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) public class AuthorizationController { private final SecurityProperties properties ; private final RedisUtils redisUtils ; private final OnlineUserService onlineUserService ; private final TokenProvider tokenProvider ; private final AuthenticationManagerBuilder authenticationManagerBuilder ; @ Resource private LoginProperties loginProperties ; @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ AnonymousPostMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > login ( @ Validated @ RequestBody AuthUserDto authUser , HttpServletRequest request ) throws Exception { String password = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , authUser . getPassword ( ) ) ; String code = ( String ) redisUtils . get ( authUser . getUuid ( ) ) ; redisUtils . del ( authUser . getUuid ( ) ) ; if ( StringUtils . isBlank ( code ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( StringUtils . isBlank ( authUser . getCode ( ) ) || ! authUser . getCode ( ) . equalsIgnoreCase ( code ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( authUser . getUsername ( ) , password ) ; Authentication authentication = authenticationManagerBuilder . getObject ( ) . authenticate ( authenticationToken ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; String token = tokenProvider . createToken ( authentication ) ; final JwtUserDto jwtUserDto = ( JwtUserDto ) authentication . getPrincipal ( ) ; Map < String , Object > authInfo = new HashMap < String , Object > ( <NUM_LIT> ) { { put ( "<STR_LIT>" , properties . getTokenStartWith ( ) + token ) ; put ( "<STR_LIT>" , jwtUserDto ) ; } } ; if ( loginProperties . isSingleLogin ( ) ) { onlineUserService . kickOutForUsername ( authUser . getUsername ( ) ) ; } onlineUserService . save ( jwtUserDto , token , request ) ; return ResponseEntity . ok ( authInfo ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) public ResponseEntity < UserDetails > getUserInfo ( ) { return ResponseEntity . ok ( SecurityUtils . getCurrentUser ( ) ) ; } @ ApiOperation ( "<STR_LIT>" ) @ AnonymousGetMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > getCode ( ) { Captcha captcha = loginProperties . getCaptcha ( ) ; String uuid = properties . getCodeKey ( ) + IdUtil . simpleUUID ( ) ; String captchaValue = captcha . text ( ) ; if ( captcha . getCharType ( ) - <NUM_LIT> == LoginCodeEnum . ARITHMETIC . ordinal ( ) && captchaValue . contains ( "<STR_LIT>" ) ) { captchaValue = captchaValue . split ( "<STR_LIT>" ) [ <NUM_LIT> ] ; } redisUtils . set ( uuid , captchaValue , loginProperties . getLoginCode ( ) . getExpiration ( ) , TimeUnit . MINUTES ) ; Map < String , Object > imgResult = new HashMap < String , Object > ( <NUM_LIT> ) { { put ( "<STR_LIT>" , captcha . toBase64 ( ) ) ; put ( "<STR_LIT>" , uuid ) ; } } ; return ResponseEntity . ok ( imgResult ) ; } @ ApiOperation ( "<STR_LIT>" ) @ AnonymousDeleteMapping ( value = "<STR_LIT>" ) public ResponseEntity < Object > logout ( HttpServletRequest request ) { String token = tokenProvider . getToken ( request ) ; onlineUserService . logout ( token ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . security . config . bean ; import com . wf . captcha . * ; import com . wf . captcha . base . Captcha ; import lombok . Data ; import me . zhengjie . exception . BadConfigurationException ; import me . zhengjie . utils . StringUtils ; import java . awt . * ; import java . util . Objects ; @ Data public class LoginProperties { private boolean singleLogin = false ; private LoginCode loginCode ; public static final String cacheKey = "<STR_LIT>" ; public boolean isSingleLogin ( ) { return singleLogin ; } public Captcha getCaptcha ( ) { if ( Objects . isNull ( loginCode ) ) { loginCode = new LoginCode ( ) ; if ( Objects . isNull ( loginCode . getCodeType ( ) ) ) { loginCode . setCodeType ( LoginCodeEnum . ARITHMETIC ) ; } } return switchCaptcha ( loginCode ) ; } private Captcha switchCaptcha ( LoginCode loginCode ) { Captcha captcha ; switch ( loginCode . getCodeType ( ) ) { case ARITHMETIC : captcha = new FixedArithmeticCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case CHINESE : captcha = new ChineseCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case CHINESE_GIF : captcha = new ChineseGifCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case GIF : captcha = new GifCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case SPEC : captcha = new SpecCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; default : throw new BadConfigurationException ( "<STR_LIT>" ) ; } if ( StringUtils . isNotBlank ( loginCode . getFontName ( ) ) ) { captcha . setFont ( new Font ( loginCode . getFontName ( ) , Font . PLAIN , loginCode . getFontSize ( ) ) ) ; } return captcha ; } static class FixedArithmeticCaptcha extends ArithmeticCaptcha { public FixedArithmeticCaptcha ( int width , int height ) { super ( width , height ) ; } @ Override protected char [ ] alphas ( ) { int n1 = num ( <NUM_LIT> , <NUM_LIT> ) , n2 = num ( <NUM_LIT> , <NUM_LIT> ) ; int opt = num ( <NUM_LIT> ) ; int res = new int [ ] { n1 + n2 , n1 - n2 , n1 * n2 } [ opt ] ; char optChar = "<STR_LIT>" . charAt ( opt ) ; this . setArithmeticString ( String . format ( "<STR_LIT>" , n1 , optChar , n2 ) ) ; this . chars = String . valueOf ( res ) ; return chars . toCharArray ( ) ; } } } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . MenuMetaVo ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . mapper . MenuMapper ; import me . zhengjie . modules . system . mapper . RoleMenuMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . service . MenuService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class MenuServiceImpl extends ServiceImpl < MenuMapper , Menu > implements MenuService { private final MenuMapper menuMapper ; private final RoleMenuMapper roleMenuMapper ; private final UserMapper userMapper ; private final RoleService roleService ; private final RedisUtils redisUtils ; private static final String HTTP_PRE = "<STR_LIT>" ; private static final String HTTPS_PRE = "<STR_LIT>" ; private static final String YES_STR = "<STR_LIT>" ; private static final String NO_STR = "<STR_LIT>" ; private static final String BAD_REQUEST = "<STR_LIT>" ; @ Override public List < Menu > queryAll ( MenuQueryCriteria criteria , Boolean isQuery ) throws Exception { if ( Boolean . TRUE . equals ( isQuery ) ) { criteria . setPidIsNull ( true ) ; List < Field > fields = StringUtils . getAllFields ( criteria . getClass ( ) , new ArrayList < > ( ) ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object val = field . get ( criteria ) ; if ( "<STR_LIT>" . equals ( field . getName ( ) ) ) { continue ; } if ( ObjectUtil . isNotNull ( val ) ) { criteria . setPidIsNull ( null ) ; break ; } } } return menuMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public Menu findById ( long id ) { return getById ( id ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public List < Menu > findByUser ( Long currentUserId ) { List < Role > roles = roleService . findByUsersId ( currentUserId ) ; Set < Long > roleIds = roles . stream ( ) . map ( Role :: getId ) . collect ( Collectors . toSet ( ) ) ; LinkedHashSet < Menu > menus = menuMapper . findByRoleIdsAndTypeNot ( roleIds , <NUM_LIT> ) ; return new ArrayList < > ( menus ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Menu resources ) { if ( menuMapper . findByTitle ( resources . getTitle ( ) ) != null ) { throw new EntityExistException ( Menu . class , "<STR_LIT>" , resources . getTitle ( ) ) ; } if ( StringUtils . isNotBlank ( resources . getComponentName ( ) ) ) { if ( menuMapper . findByComponentName ( resources . getComponentName ( ) ) != null ) { throw new EntityExistException ( Menu . class , "<STR_LIT>" , resources . getComponentName ( ) ) ; } } if ( Long . valueOf ( <NUM_LIT> ) . equals ( resources . getPid ( ) ) ) { resources . setPid ( null ) ; } if ( resources . getIFrame ( ) ) { if ( ! ( resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTP_PRE ) || resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTPS_PRE ) ) ) { throw new BadRequestException ( BAD_REQUEST ) ; } } save ( resources ) ; resources . setSubCount ( <NUM_LIT> ) ; updateSubCnt ( resources . getPid ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Menu resources ) { if ( resources . getId ( ) . equals ( resources . getPid ( ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } Menu menu = getById ( resources . getId ( ) ) ; if ( resources . getIFrame ( ) ) { if ( ! ( resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTP_PRE ) || resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTPS_PRE ) ) ) { throw new BadRequestException ( BAD_REQUEST ) ; } } Menu menu1 = menuMapper . findByTitle ( resources . getTitle ( ) ) ; if ( menu1 != null && ! menu1 . getId ( ) . equals ( menu . getId ( ) ) ) { throw new EntityExistException ( Menu . class , "<STR_LIT>" , resources . getTitle ( ) ) ; } if ( resources . getPid ( ) . equals ( <NUM_LIT> ) ) { resources . setPid ( null ) ; } Long oldPid = menu . getPid ( ) ; Long newPid = resources . getPid ( ) ; if ( StringUtils . isNotBlank ( resources . getComponentName ( ) ) ) { menu1 = menuMapper . findByComponentName ( resources . getComponentName ( ) ) ; if ( menu1 != null && ! menu1 . getId ( ) . equals ( menu . getId ( ) ) ) { throw new EntityExistException ( Menu . class , "<STR_LIT>" , resources . getComponentName ( ) ) ; } } menu . setTitle ( resources . getTitle ( ) ) ; menu . setComponent ( resources . getComponent ( ) ) ; menu . setPath ( resources . getPath ( ) ) ; menu . setIcon ( resources . getIcon ( ) ) ; menu . setIFrame ( resources . getIFrame ( ) ) ; menu . setPid ( resources . getPid ( ) ) ; menu . setMenuSort ( resources . getMenuSort ( ) ) ; menu . setCache ( resources . getCache ( ) ) ; menu . setHidden ( resources . getHidden ( ) ) ; menu . setComponentName ( resources . getComponentName ( ) ) ; menu . setPermission ( resources . getPermission ( ) ) ; menu . setType ( resources . getType ( ) ) ; saveOrUpdate ( menu ) ; updateSubCnt ( oldPid ) ; updateSubCnt ( newPid ) ; delCaches ( resources . getId ( ) ) ; } @ Override public Set < Menu > getChildMenus ( List < Menu > menuList , Set < Menu > menuSet ) { for ( Menu menu : menuList ) { menuSet . add ( menu ) ; List < Menu > menus = menuMapper . findByPidOrderByMenuSort ( menu . getId ( ) ) ; if ( menus != null && menus . size ( ) != <NUM_LIT> ) { getChildMenus ( menus , menuSet ) ; } } return menuSet ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Menu > menuSet ) { for ( Menu menu : menuSet ) { delCaches ( menu . getId ( ) ) ; roleMenuMapper . deleteByMenuId ( menu . getId ( ) ) ; menuMapper . deleteById ( menu . getId ( ) ) ; updateSubCnt ( menu . getPid ( ) ) ; } } @ Override public List < Menu > getMenus ( Long pid ) { List < Menu > menus ; if ( pid != null && ! pid . equals ( <NUM_LIT> ) ) { menus = menuMapper . findByPidOrderByMenuSort ( pid ) ; } else { menus = menuMapper . findByPidIsNullOrderByMenuSort ( ) ; } return menus ; } @ Override public List < Menu > getSuperior ( Menu menu , List < Menu > menus ) { if ( menu . getPid ( ) == null ) { menus . addAll ( menuMapper . findByPidIsNullOrderByMenuSort ( ) ) ; return menus ; } menus . addAll ( menuMapper . findByPidOrderByMenuSort ( menu . getPid ( ) ) ) ; return getSuperior ( findById ( menu . getPid ( ) ) , menus ) ; } @ Override public List < Menu > buildTree ( List < Menu > menus ) { List < Menu > trees = new ArrayList < > ( ) ; Set < Long > ids = new HashSet < > ( ) ; for ( Menu menu : menus ) { if ( menu . getPid ( ) == null ) { trees . add ( menu ) ; } for ( Menu it : menus ) { if ( menu . getId ( ) . equals ( it . getPid ( ) ) ) { if ( menu . getChildren ( ) == null ) { menu . setChildren ( new ArrayList < > ( ) ) ; } menu . getChildren ( ) . add ( it ) ; ids . add ( it . getId ( ) ) ; } } } if ( trees . size ( ) == <NUM_LIT> ) { trees = menus . stream ( ) . filter ( s -> ! ids . contains ( s . getId ( ) ) ) . collect ( Collectors . toList ( ) ) ; } return trees ; } @ Override public List < MenuVo > buildMenus ( List < Menu > menus ) { List < MenuVo > list = new LinkedList < > ( ) ; menus . forEach ( menu -> { if ( menu != null ) { List < Menu > menuList = menu . getChildren ( ) ; MenuVo menuVo = new MenuVo ( ) ; menuVo . setName ( ObjectUtil . isNotEmpty ( menu . getComponentName ( ) ) ? menu . getComponentName ( ) : menu . getTitle ( ) ) ; menuVo . setPath ( menu . getPid ( ) == null ? "<STR_LIT>" + menu . getPath ( ) : menu . getPath ( ) ) ; menuVo . setHidden ( menu . getHidden ( ) ) ; if ( ! menu . getIFrame ( ) ) { if ( menu . getPid ( ) == null ) { menuVo . setComponent ( StringUtils . isEmpty ( menu . getComponent ( ) ) ? "<STR_LIT>" : menu . getComponent ( ) ) ; } else if ( menu . getType ( ) == <NUM_LIT> ) { menuVo . setComponent ( StringUtils . isEmpty ( menu . getComponent ( ) ) ? "<STR_LIT>" : menu . getComponent ( ) ) ; } else if ( StringUtils . isNoneBlank ( menu . getComponent ( ) ) ) { menuVo . setComponent ( menu . getComponent ( ) ) ; } } menuVo . setMeta ( new MenuMetaVo ( menu . getTitle ( ) , menu . getIcon ( ) , ! menu . getCache ( ) ) ) ; if ( CollectionUtil . isNotEmpty ( menuList ) ) { menuVo . setAlwaysShow ( true ) ; menuVo . setRedirect ( "<STR_LIT>" ) ; menuVo . setChildren ( buildMenus ( menuList ) ) ; } else if ( menu . getPid ( ) == null ) { MenuVo menuVo1 = new MenuVo ( ) ; menuVo1 . setMeta ( menuVo . getMeta ( ) ) ; if ( ! menu . getIFrame ( ) ) { menuVo1 . setPath ( "<STR_LIT>" ) ; menuVo1 . setName ( menuVo . getName ( ) ) ; menuVo1 . setComponent ( menuVo . getComponent ( ) ) ; } else { menuVo1 . setPath ( menu . getPath ( ) ) ; } menuVo . setName ( null ) ; menuVo . setMeta ( null ) ; menuVo . setComponent ( "<STR_LIT>" ) ; List < MenuVo > list1 = new ArrayList < > ( ) ; list1 . add ( menuVo1 ) ; menuVo . setChildren ( list1 ) ; } list . add ( menuVo ) ; } } ) ; return list ; } @ Override public void download ( List < Menu > menus , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Menu menu : menus ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , menu . getTitle ( ) ) ; map . put ( "<STR_LIT>" , menu . getType ( ) == null ? "<STR_LIT>" : menu . getType ( ) == <NUM_LIT> ? "<STR_LIT>" : "<STR_LIT>" ) ; map . put ( "<STR_LIT>" , menu . getPermission ( ) ) ; map . put ( "<STR_LIT>" , menu . getIFrame ( ) ? YES_STR : NO_STR ) ; map . put ( "<STR_LIT>" , menu . getHidden ( ) ? NO_STR : YES_STR ) ; map . put ( "<STR_LIT>" , menu . getCache ( ) ? YES_STR : NO_STR ) ; map . put ( "<STR_LIT>" , menu . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } private void updateSubCnt ( Long menuId ) { if ( menuId != null ) { int count = menuMapper . countByPid ( menuId ) ; menuMapper . updateSubCntById ( count , menuId ) ; } } public void delCaches ( Long id ) { List < User > users = userMapper . findByMenuId ( id ) ; redisUtils . del ( CacheKey . MENU_ID + id ) ; redisUtils . delByKeys ( CacheKey . MENU_USER , users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ) ; List < Role > roles = roleService . findByMenuId ( id ) ; redisUtils . delByKeys ( CacheKey . ROLE_ID , roles . stream ( ) . map ( Role :: getId ) . collect ( Collectors . toSet ( ) ) ) ; } } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . lang . Dict ; import cn . hutool . core . util . RandomUtil ; import cn . hutool . extra . template . Template ; import cn . hutool . extra . template . TemplateConfig ; import cn . hutool . extra . template . TemplateEngine ; import cn . hutool . extra . template . TemplateUtil ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . RedisUtils ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . Collections ; @ Service @ RequiredArgsConstructor public class VerifyServiceImpl implements VerifyService { @ Value ( "<STR_LIT>" ) private Long expiration ; private final RedisUtils redisUtils ; @ Override @ Transactional ( rollbackFor = Exception . class ) public EmailVo sendEmail ( String email , String key ) { EmailVo emailVo ; String content ; String redisKey = key + email ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( "<STR_LIT>" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; Template template = engine . getTemplate ( "<STR_LIT>" ) ; Object oldCode = redisUtils . get ( redisKey ) ; if ( oldCode == null ) { String code = RandomUtil . randomNumbers ( <NUM_LIT> ) ; if ( ! redisUtils . set ( redisKey , code , expiration ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } content = template . render ( Dict . create ( ) . set ( "<STR_LIT>" , code ) ) ; emailVo = new EmailVo ( Collections . singletonList ( email ) , "<STR_LIT>" , content ) ; } else { content = template . render ( Dict . create ( ) . set ( "<STR_LIT>" , oldCode ) ) ; emailVo = new EmailVo ( Collections . singletonList ( email ) , "<STR_LIT>" , content ) ; } return emailVo ; } @ Override public void validated ( String key , String code ) { Object value = redisUtils . get ( key ) ; if ( value == null || ! value . toString ( ) . equals ( code ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } else { redisUtils . del ( key ) ; } } } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( "<STR_LIT>" ) public class AlipayConfig implements Serializable { @ TableId ( "<STR_LIT>" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String appId ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String privateKey ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String publicKey ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String signType = "<STR_LIT>" ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String gatewayUrl = "<STR_LIT>" ; @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String charset = "<STR_LIT>" ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String notifyUrl ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String returnUrl ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String format = "<STR_LIT>" ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String sysServiceProviderId ; } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QiniuContentMapper extends BaseMapper < QiniuContent > { QiniuContent findByKey ( @ Param ( "<STR_LIT>" ) String name ) ; IPage < QiniuContent > findAll ( @ Param ( "<STR_LIT>" ) QiniuQueryCriteria criteria , Page < Object > page ) ; List < QiniuContent > findAll ( QiniuQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . quartz . utils ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . SpringContextHolder ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Method ; import java . util . concurrent . Callable ; @ Slf4j public class QuartzRunnable implements Callable < Object > { private final Object target ; private final Method method ; private final String params ; QuartzRunnable ( String beanName , String methodName , String params ) throws NoSuchMethodException , SecurityException { this . target = SpringContextHolder . getBean ( beanName ) ; this . params = params ; if ( StringUtils . isNotBlank ( params ) ) { this . method = target . getClass ( ) . getDeclaredMethod ( methodName , String . class ) ; } else { this . method = target . getClass ( ) . getDeclaredMethod ( methodName ) ; } } @ Override @ SuppressWarnings ( "<STR_LIT>" ) public Object call ( ) throws Exception { ReflectionUtils . makeAccessible ( method ) ; if ( StringUtils . isNotBlank ( params ) ) { method . invoke ( target , params ) ; } else { method . invoke ( target ) ; } return null ; } } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface MenuService extends IService < Menu > { List < Menu > queryAll ( MenuQueryCriteria criteria , Boolean isQuery ) throws Exception ; Menu findById ( long id ) ; void create ( Menu resources ) ; void update ( Menu resources ) ; Set < Menu > getChildMenus ( List < Menu > menuList , Set < Menu > menuSet ) ; List < Menu > buildTree ( List < Menu > menus ) ; List < MenuVo > buildMenus ( List < Menu > menus ) ; void delete ( Set < Menu > menuSet ) ; void download ( List < Menu > menus , HttpServletResponse response ) throws IOException ; List < Menu > getMenus ( Long pid ) ; List < Menu > getSuperior ( Menu menu , List < Menu > objects ) ; List < Menu > findByUser ( Long currentUserId ) ; } </s>
<s> package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum CodeEnum { PHONE_RESET_EMAIL_CODE ( "<STR_LIT>" , "<STR_LIT>" ) , EMAIL_RESET_EMAIL_CODE ( "<STR_LIT>" , "<STR_LIT>" ) , PHONE_RESET_PWD_CODE ( "<STR_LIT>" , "<STR_LIT>" ) , EMAIL_RESET_PWD_CODE ( "<STR_LIT>" , "<STR_LIT>" ) ; private final String key ; private final String description ; } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class RoleQueryCriteria { private String blurry ; private List < Timestamp > createTime ; private Long offset ; private Long size ; } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeptService extends IService < Dept > { List < Dept > queryAll ( DeptQueryCriteria criteria , Boolean isQuery ) throws Exception ; Dept findById ( Long id ) ; void create ( Dept resources ) ; void update ( Dept resources ) ; void delete ( Set < Dept > depts ) ; List < Dept > findByPid ( long pid ) ; Set < Dept > findByRoleId ( Long id ) ; void download ( List < Dept > depts , HttpServletResponse response ) throws IOException ; Set < Dept > getDeleteDepts ( List < Dept > deptList , Set < Dept > depts ) ; List < Dept > getSuperior ( Dept dept , List < Dept > depts ) ; Object buildTree ( List < Dept > depts ) ; List < Long > getDeptChildren ( List < Dept > deptList ) ; void verification ( Set < Dept > depts ) ; } </s>
<s> package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollUtil ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . AuthorityDto ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . mapper . RoleDeptMapper ; import me . zhengjie . modules . system . mapper . RoleMapper ; import me . zhengjie . modules . system . mapper . RoleMenuMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = "<STR_LIT>" ) public class RoleServiceImpl extends ServiceImpl < RoleMapper , Role > implements RoleService { private final RoleMapper roleMapper ; private final RoleDeptMapper roleDeptMapper ; private final RoleMenuMapper roleMenuMapper ; private final RedisUtils redisUtils ; private final UserMapper userMapper ; private final UserCacheManager userCacheManager ; @ Override public List < Role > queryAll ( ) { return roleMapper . queryAll ( ) ; } @ Override public List < Role > queryAll ( RoleQueryCriteria criteria ) { return roleMapper . findAll ( criteria ) ; } @ Override public PageResult < Role > queryAll ( RoleQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Role > roles = roleMapper . findAll ( criteria ) ; Long total = roleMapper . countAll ( criteria ) ; return PageUtil . toPage ( roles , total ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public Role findById ( long id ) { return roleMapper . findById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Role resources ) { if ( roleMapper . findByName ( resources . getName ( ) ) != null ) { throw new EntityExistException ( Role . class , "<STR_LIT>" , resources . getName ( ) ) ; } save ( resources ) ; if ( CollectionUtil . isNotEmpty ( resources . getDepts ( ) ) ) { roleDeptMapper . insertData ( resources . getId ( ) , resources . getDepts ( ) ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Role resources ) { Role role = getById ( resources . getId ( ) ) ; Role role1 = roleMapper . findByName ( resources . getName ( ) ) ; if ( role1 != null && ! role1 . getId ( ) . equals ( role . getId ( ) ) ) { throw new EntityExistException ( Role . class , "<STR_LIT>" , resources . getName ( ) ) ; } role . setName ( resources . getName ( ) ) ; role . setDescription ( resources . getDescription ( ) ) ; role . setDataScope ( resources . getDataScope ( ) ) ; role . setDepts ( resources . getDepts ( ) ) ; role . setLevel ( resources . getLevel ( ) ) ; saveOrUpdate ( role ) ; roleDeptMapper . deleteByRoleId ( resources . getId ( ) ) ; if ( CollectionUtil . isNotEmpty ( resources . getDepts ( ) ) ) { roleDeptMapper . insertData ( resources . getId ( ) , resources . getDepts ( ) ) ; } delCaches ( role . getId ( ) , null ) ; } @ Override public void updateMenu ( Role role ) { List < User > users = userMapper . findByRoleId ( role . getId ( ) ) ; roleMenuMapper . deleteByRoleId ( role . getId ( ) ) ; if ( CollUtil . isNotEmpty ( role . getMenus ( ) ) ) { roleMenuMapper . insertData ( role . getId ( ) , role . getMenus ( ) ) ; } delCaches ( role . getId ( ) , users ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { delCaches ( id , null ) ; } removeBatchByIds ( ids ) ; roleDeptMapper . deleteByRoleIds ( ids ) ; roleMenuMapper . deleteByRoleIds ( ids ) ; } @ Override public List < Role > findByUsersId ( Long userId ) { return roleMapper . findByUserId ( userId ) ; } @ Override public Integer findByRoles ( Set < Role > roles ) { if ( roles . size ( ) == <NUM_LIT> ) { return Integer . MAX_VALUE ; } Set < Role > roleSet = new HashSet < > ( ) ; for ( Role role : roles ) { roleSet . add ( findById ( role . getId ( ) ) ) ; } return Collections . min ( roleSet . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; } @ Override @ Cacheable ( key = "<STR_LIT>" ) public List < AuthorityDto > mapToGrantedAuthorities ( User user ) { Set < String > permissions = new HashSet < > ( ) ; if ( user . getIsAdmin ( ) ) { permissions . add ( "<STR_LIT>" ) ; return permissions . stream ( ) . map ( AuthorityDto :: new ) . collect ( Collectors . toList ( ) ) ; } List < Role > roles = roleMapper . findByUserId ( user . getId ( ) ) ; permissions = roles . stream ( ) . flatMap ( role -> role . getMenus ( ) . stream ( ) ) . map ( Menu :: getPermission ) . filter ( StringUtils :: isNotBlank ) . collect ( Collectors . toSet ( ) ) ; return permissions . stream ( ) . map ( AuthorityDto :: new ) . collect ( Collectors . toList ( ) ) ; } @ Override public void download ( List < Role > roles , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Role role : roles ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , role . getName ( ) ) ; map . put ( "<STR_LIT>" , role . getLevel ( ) ) ; map . put ( "<STR_LIT>" , role . getDescription ( ) ) ; map . put ( "<STR_LIT>" , role . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void verification ( Set < Long > ids ) { if ( userMapper . countByRoles ( ids ) > <NUM_LIT> ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } @ Override public List < Role > findByMenuId ( Long menuId ) { return roleMapper . findByMenuId ( menuId ) ; } public void delCaches ( Long id , List < User > users ) { users = CollectionUtil . isEmpty ( users ) ? userMapper . findByRoleId ( id ) : users ; if ( CollectionUtil . isNotEmpty ( users ) ) { users . forEach ( item -> userCacheManager . cleanUserCache ( item . getUsername ( ) ) ) ; Set < Long > userIds = users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ; redisUtils . delByKeys ( CacheKey . DATA_USER , userIds ) ; redisUtils . delByKeys ( CacheKey . MENU_USER , userIds ) ; redisUtils . delByKeys ( CacheKey . ROLE_AUTH , userIds ) ; } redisUtils . del ( CacheKey . ROLE_ID + id ) ; } } </s>
<s> package me . zhengjie . utils ; import com . alipay . api . AlipayApiException ; import com . alipay . api . internal . util . AlipaySignature ; import me . zhengjie . domain . AlipayConfig ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Component public class AlipayUtils { public String getOrderCode ( ) { SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" ) ; int a = ( int ) ( Math . random ( ) * <NUM_LIT> ) + <NUM_LIT> ; System . out . println ( a ) ; Date date = new Date ( ) ; String str = sdf . format ( date ) ; String [ ] split = str . split ( "<STR_LIT>" ) ; String s = split [ <NUM_LIT> ] + split [ <NUM_LIT> ] + split [ <NUM_LIT> ] ; String [ ] split1 = s . split ( "<STR_LIT>" ) ; String s1 = split1 [ <NUM_LIT> ] + split1 [ <NUM_LIT> ] ; String [ ] split2 = s1 . split ( "<STR_LIT>" ) ; return split2 [ <NUM_LIT> ] + split2 [ <NUM_LIT> ] + split2 [ <NUM_LIT> ] + a ; } public boolean rsaCheck ( HttpServletRequest request , AlipayConfig alipay ) { Map < String , String > params = new HashMap < > ( <NUM_LIT> ) ; Map < String , String [ ] > requestParams = request . getParameterMap ( ) ; for ( Object o : requestParams . keySet ( ) ) { String name = ( String ) o ; String [ ] values = requestParams . get ( name ) ; String valueStr = "<STR_LIT>" ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { valueStr = ( i == values . length - <NUM_LIT> ) ? valueStr + values [ i ] : valueStr + values [ i ] + "<STR_LIT>" ; } params . put ( name , valueStr ) ; } try { return AlipaySignature . rsaCheckV1 ( params , alipay . getPublicKey ( ) , alipay . getCharset ( ) , alipay . getSignType ( ) ) ; } catch ( AlipayApiException e ) { return false ; } } } </s>
<s> package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DatabaseService extends IService < Database > { PageResult < Database > queryAll ( DatabaseQueryCriteria criteria , Page < Object > page ) ; List < Database > queryAll ( DatabaseQueryCriteria criteria ) ; void create ( Database resources ) ; void update ( Database resources ) ; void delete ( Set < String > ids ) ; boolean testConnection ( Database resources ) ; void download ( List < Database > queryAll , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . domain . vo . JobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; @ Mapper public interface JobMapper extends BaseMapper < Job > { @ Select ( "<STR_LIT>" ) Job findByName ( @ Param ( "<STR_LIT>" ) String name ) ; List < Job > findAll ( @ Param ( "<STR_LIT>" ) JobQueryCriteria criteria ) ; IPage < Job > findAll ( @ Param ( "<STR_LIT>" ) JobQueryCriteria criteria , Page < Object > page ) ; } </s>
<s> package me . zhengjie . config . thread ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component public class AsyncTaskProperties { public static int corePoolSize ; public static int maxPoolSize ; public static int keepAliveSeconds ; public static int queueCapacity ; @ Value ( "<STR_LIT>" ) public void setCorePoolSize ( int corePoolSize ) { AsyncTaskProperties . corePoolSize = corePoolSize ; } @ Value ( "<STR_LIT>" ) public void setMaxPoolSize ( int maxPoolSize ) { AsyncTaskProperties . maxPoolSize = maxPoolSize ; } @ Value ( "<STR_LIT>" ) public void setKeepAliveSeconds ( int keepAliveSeconds ) { AsyncTaskProperties . keepAliveSeconds = keepAliveSeconds ; } @ Value ( "<STR_LIT>" ) public void setQueueCapacity ( int queueCapacity ) { AsyncTaskProperties . queueCapacity = queueCapacity ; } } </s>
<s> package me . zhengjie . modules . quartz . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QuartzJobMapper extends BaseMapper < QuartzJob > { IPage < QuartzJob > findAll ( @ Param ( "<STR_LIT>" ) QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzJob > findAll ( @ Param ( "<STR_LIT>" ) QuartzJobQueryCriteria criteria ) ; List < QuartzJob > findByIsPauseIsFalse ( ) ; } </s>
<s> package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . * ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . sql . Timestamp ; @ Data @ TableName ( "<STR_LIT>" ) public class QiniuContent implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ TableField ( "<STR_LIT>" ) @ ApiModelProperty ( value = "<STR_LIT>" ) private String key ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String bucket ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String size ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String url ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String suffix ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String type = "<STR_LIT>" ; @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = "<STR_LIT>" ) private Timestamp updateTime ; } </s>
<s> package me . zhengjie . config ; import lombok . Data ; import me . zhengjie . utils . ElConstant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . context . annotation . Configuration ; @ Data @ Configuration @ ConfigurationProperties ( prefix = "<STR_LIT>" ) public class FileProperties { private Long maxSize ; private Long avatarMaxSize ; private ElPath mac ; private ElPath linux ; private ElPath windows ; public ElPath getPath ( ) { String os = System . getProperty ( "<STR_LIT>" ) ; if ( os . toLowerCase ( ) . startsWith ( ElConstant . WIN ) ) { return windows ; } else if ( os . toLowerCase ( ) . startsWith ( ElConstant . MAC ) ) { return mac ; } return linux ; } @ Data public static class ElPath { private String path ; private String avatar ; } } </s>
<s> package me . zhengjie . utils ; public interface CallBack { void executor ( ) ; default String getCallBackName ( ) { return Thread . currentThread ( ) . getId ( ) + "<STR_LIT>" + this . getClass ( ) . getName ( ) ; } } </s>
<s> package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DatabaseMapper extends BaseMapper < Database > { IPage < Database > findAll ( @ Param ( "<STR_LIT>" ) DatabaseQueryCriteria criteria , Page < Object > page ) ; List < Database > findAll ( @ Param ( "<STR_LIT>" ) DatabaseQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . mnt . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . mapper . AppMapper ; import me . zhengjie . modules . mnt . mapper . DeployMapper ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . service . AppService ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class AppServiceImpl extends ServiceImpl < AppMapper , App > implements AppService { private final AppMapper appMapper ; private final DeployMapper deployMapper ; private final DeployServerMapper deployServerMapper ; @ Override public PageResult < App > queryAll ( AppQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( appMapper . queryAll ( criteria , page ) ) ; } @ Override public List < App > queryAll ( AppQueryCriteria criteria ) { return appMapper . queryAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( App resources ) { verification ( resources ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( App resources ) { verification ( resources ) ; App app = getById ( resources . getId ( ) ) ; app . copy ( resources ) ; saveOrUpdate ( app ) ; } private void verification ( App resources ) { String opt = "<STR_LIT>" ; String home = "<STR_LIT>" ; if ( ! ( resources . getUploadPath ( ) . startsWith ( opt ) || resources . getUploadPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( ! ( resources . getDeployPath ( ) . startsWith ( opt ) || resources . getDeployPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } if ( ! ( resources . getBackupPath ( ) . startsWith ( opt ) || resources . getBackupPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; Set < Long > deployIds = deployMapper . getIdByAppIds ( ids ) ; if ( deployIds != null && deployIds . size ( ) > <NUM_LIT> ) { deployServerMapper . deleteByDeployIds ( deployIds ) ; deployMapper . deleteBatchIds ( deployIds ) ; } } @ Override public void download ( List < App > apps , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( App app : apps ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , app . getName ( ) ) ; map . put ( "<STR_LIT>" , app . getPort ( ) ) ; map . put ( "<STR_LIT>" , app . getUploadPath ( ) ) ; map . put ( "<STR_LIT>" , app . getDeployPath ( ) ) ; map . put ( "<STR_LIT>" , app . getBackupPath ( ) ) ; map . put ( "<STR_LIT>" , app . getStartScript ( ) ) ; map . put ( "<STR_LIT>" , app . getDeployScript ( ) ) ; map . put ( "<STR_LIT>" , app . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . modules . quartz . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class QuartzJob extends BaseEntity implements Serializable { public static final String JOB_KEY = "<STR_LIT>" ; @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ NotNull ( groups = { Update . class } ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String uuid ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String jobName ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String beanName ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String methodName ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String params ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String cronExpression ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean isPause = false ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String personInCharge ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String email ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String subTask ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean pauseAfterFailure ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String description ; } </s>
<s> package me . zhengjie . config ; import org . springframework . boot . web . servlet . MultipartConfigFactory ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . servlet . MultipartConfigElement ; import java . io . File ; @ Configuration public class MultipartConfig { @ Bean MultipartConfigElement multipartConfigElement ( ) { MultipartConfigFactory factory = new MultipartConfigFactory ( ) ; String location = System . getProperty ( "<STR_LIT>" ) + "<STR_LIT>" ; File tmpFile = new File ( location ) ; if ( ! tmpFile . exists ( ) ) { if ( ! tmpFile . mkdirs ( ) ) { System . out . println ( "<STR_LIT>" ) ; } } factory . setLocation ( location ) ; return factory . createMultipartConfig ( ) ; } } </s>
<s> package me . zhengjie . modules . quartz . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QuartzLogMapper extends BaseMapper < QuartzLog > { IPage < QuartzLog > findAll ( @ Param ( "<STR_LIT>" ) QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzLog > findAll ( @ Param ( "<STR_LIT>" ) QuartzJobQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . exception ; import lombok . Getter ; import org . springframework . http . HttpStatus ; import static org . springframework . http . HttpStatus . BAD_REQUEST ; @ Getter public class BadRequestException extends RuntimeException { private Integer status = BAD_REQUEST . value ( ) ; public BadRequestException ( String msg ) { super ( msg ) ; } public BadRequestException ( HttpStatus status , String msg ) { super ( msg ) ; this . status = status . value ( ) ; } } </s>
<s> package me . zhengjie . utils ; import com . qiniu . storage . Region ; import java . text . SimpleDateFormat ; import java . util . Date ; public class QiNiuUtil { private static final String HUAD = "<STR_LIT>" ; private static final String HUAB = "<STR_LIT>" ; private static final String HUAN = "<STR_LIT>" ; private static final String BEIM = "<STR_LIT>" ; public static Region getRegion ( String zone ) { if ( HUAD . equals ( zone ) ) { return Region . huadong ( ) ; } else if ( HUAB . equals ( zone ) ) { return Region . huabei ( ) ; } else if ( HUAN . equals ( zone ) ) { return Region . huanan ( ) ; } else if ( BEIM . equals ( zone ) ) { return Region . beimei ( ) ; } else { return Region . qvmHuadong ( ) ; } } public static String getKey ( String file ) { SimpleDateFormat sdf = new SimpleDateFormat ( "<STR_LIT>" ) ; Date date = new Date ( ) ; return FileUtil . getFileNameNoEx ( file ) + "<STR_LIT>" + sdf . format ( date ) + "<STR_LIT>" + FileUtil . getExtensionName ( file ) ; } } </s>
<s> package me . zhengjie . modules . mnt . websocket ; import lombok . Data ; @ Data public class SocketMsg { private String msg ; private MsgType msgType ; public SocketMsg ( String msg , MsgType msgType ) { this . msg = msg ; this . msgType = msgType ; } } </s>
<s> package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DeptQueryCriteria { private List < Long > ids ; private String name ; private Boolean enabled ; private Long pid ; private Boolean pidIsNull ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import me . zhengjie . utils . enums . DataScopeEnum ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Role extends BaseEntity implements Serializable { @ NotNull ( groups = { Update . class } ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Set < User > users ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Set < Menu > menus ; @ TableField ( exist = false ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Set < Dept > depts ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String dataScope = DataScopeEnum . THIS_LEVEL . getValue ( ) ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer level = <NUM_LIT> ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String description ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Role role = ( Role ) o ; return Objects . equals ( id , role . id ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id ) ; } } </s>
<s> package me . zhengjie . modules . quartz . config ; import org . quartz . spi . TriggerFiredBundle ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . quartz . AdaptableJobFactory ; import org . springframework . stereotype . Component ; @ Configuration public class QuartzConfig { @ Component ( "<STR_LIT>" ) public static class QuartzJobFactory extends AdaptableJobFactory { private final AutowireCapableBeanFactory capableBeanFactory ; public QuartzJobFactory ( AutowireCapableBeanFactory capableBeanFactory ) { this . capableBeanFactory = capableBeanFactory ; } @ Override protected Object createJobInstance ( TriggerFiredBundle bundle ) throws Exception { Object jobInstance = super . createJobInstance ( bundle ) ; capableBeanFactory . autowireBean ( jobInstance ) ; return jobInstance ; } } } </s>
<s> package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Set ; @ Mapper public interface DeptMapper extends BaseMapper < Dept > { List < Dept > findAll ( @ Param ( "<STR_LIT>" ) DeptQueryCriteria criteria ) ; List < Dept > findByPid ( @ Param ( "<STR_LIT>" ) Long pid ) ; List < Dept > findByPidIsNull ( ) ; Set < Dept > findByRoleId ( @ Param ( "<STR_LIT>" ) Long roleId ) ; @ Select ( "<STR_LIT>" ) int countByPid ( @ Param ( "<STR_LIT>" ) Long pid ) ; @ Select ( "<STR_LIT>" ) void updateSubCntById ( @ Param ( "<STR_LIT>" ) Integer count , @ Param ( "<STR_LIT>" ) Long id ) ; } </s>
<s> package me . zhengjie ; import org . junit . jupiter . api . Test ; import org . springframework . boot . test . context . SpringBootTest ; @ SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) public class EladminSystemApplicationTests { @ Test public void contextLoads ( ) { } public static void main ( String [ ] args ) { } } </s>
<s> package me . zhengjie . utils ; public interface CacheKey { String USER_ID = "<STR_LIT>" ; String DATA_USER = "<STR_LIT>" ; String MENU_ID = "<STR_LIT>" ; String MENU_USER = "<STR_LIT>" ; String ROLE_AUTH = "<STR_LIT>" ; String ROLE_ID = "<STR_LIT>" ; String DEPT_ID = "<STR_LIT>" ; String JOB_ID = "<STR_LIT>" ; String DICT_NAME = "<STR_LIT>" ; } </s>
<s> package me . zhengjie . modules . quartz . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SpringContextHolder ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) @ Api ( tags = "<STR_LIT>" ) public class QuartzJobController { private static final String ENTITY_NAME = "<STR_LIT>" ; private final QuartzJobService quartzJobService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < QuartzJob > > queryQuartzJob ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( quartzJobService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportQuartzJob ( HttpServletResponse response , QuartzJobQueryCriteria criteria ) throws IOException { quartzJobService . download ( quartzJobService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportQuartzJobLog ( HttpServletResponse response , QuartzJobQueryCriteria criteria ) throws IOException { quartzJobService . downloadLog ( quartzJobService . queryAllLog ( criteria ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < QuartzLog > > queryQuartzJobLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( quartzJobService . queryAllLog ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createQuartzJob ( @ Validated @ RequestBody QuartzJob resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } checkBean ( resources . getBeanName ( ) ) ; quartzJobService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateQuartzJob ( @ Validated ( QuartzJob . Update . class ) @ RequestBody QuartzJob resources ) { checkBean ( resources . getBeanName ( ) ) ; quartzJobService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateQuartzJobStatus ( @ PathVariable Long id ) { quartzJobService . updateIsPause ( quartzJobService . getById ( id ) ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > executionQuartzJob ( @ PathVariable Long id ) { quartzJobService . execution ( quartzJobService . getById ( id ) ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteQuartzJob ( @ RequestBody Set < Long > ids ) { quartzJobService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private void checkBean ( String beanName ) { if ( ! SpringContextHolder . getAllServiceBeanName ( ) . contains ( beanName ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Objects ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Job extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ NotBlank @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ NotNull @ ApiModelProperty ( value = "<STR_LIT>" ) private Long jobSort ; @ NotNull @ ApiModelProperty ( value = "<STR_LIT>" ) private Boolean enabled ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Job job = ( Job ) o ; return Objects . equals ( id , job . id ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id ) ; } } </s>
<s> package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . util . IdUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . mapper . DeployHistoryMapper ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . DateUtil ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class DeployHistoryServiceImpl extends ServiceImpl < DeployHistoryMapper , DeployHistory > implements DeployHistoryService { private final DeployHistoryMapper deployhistoryMapper ; @ Override public PageResult < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( deployhistoryMapper . findAll ( criteria , page ) ) ; } @ Override public List < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria ) { return deployhistoryMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( DeployHistory resources ) { resources . setId ( IdUtil . simpleUUID ( ) ) ; resources . setDeployDate ( DateUtil . getTimeStamp ( ) ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < String > ids ) { removeBatchByIds ( ids ) ; } @ Override public void download ( List < DeployHistory > deployHistories , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( DeployHistory deployHistory : deployHistories ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , deployHistory . getDeployId ( ) ) ; map . put ( "<STR_LIT>" , deployHistory . getAppName ( ) ) ; map . put ( "<STR_LIT>" , deployHistory . getIp ( ) ) ; map . put ( "<STR_LIT>" , deployHistory . getDeployDate ( ) ) ; map . put ( "<STR_LIT>" , deployHistory . getDeployUser ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . PATCH ) public @ interface AnonymousPatchMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default "<STR_LIT>" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; } </s>
<s> package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . domain . EmailConfig ; public interface EmailService extends IService < EmailConfig > { EmailConfig config ( EmailConfig emailConfig , EmailConfig old ) throws Exception ; EmailConfig find ( ) ; void send ( EmailVo emailVo , EmailConfig emailConfig ) ; } </s>
<s> package me . zhengjie . exception ; import org . springframework . util . StringUtils ; public class EntityNotFoundException extends RuntimeException { public EntityNotFoundException ( Class clazz , String field , String val ) { super ( EntityNotFoundException . generateMessage ( clazz . getSimpleName ( ) , field , val ) ) ; } private static String generateMessage ( String entity , String field , String val ) { return StringUtils . capitalize ( entity ) + "<STR_LIT>" + field + "<STR_LIT>" + val + "<STR_LIT>" ; } } </s>
<s> package me . zhengjie . config ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . socket . server . standard . ServerEndpointExporter ; @ Configuration public class WebSocketConfig { @ Bean public ServerEndpointExporter serverEndpointExporter ( ) { return new ServerEndpointExporter ( ) ; } } </s>
<s> package me . zhengjie . modules . security . service ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . service . UserService ; import org . springframework . security . core . userdetails . UserDetailsService ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import org . springframework . stereotype . Service ; @ Slf4j @ RequiredArgsConstructor @ Service ( "<STR_LIT>" ) public class UserDetailsServiceImpl implements UserDetailsService { private final UserService userService ; private final RoleService roleService ; private final DataService dataService ; private final UserCacheManager userCacheManager ; @ Override public JwtUserDto loadUserByUsername ( String username ) { JwtUserDto jwtUserDto = userCacheManager . getUserCache ( username ) ; if ( jwtUserDto == null ) { User user ; try { user = userService . getLoginData ( username ) ; } catch ( EntityNotFoundException e ) { throw new UsernameNotFoundException ( username , e ) ; } if ( user == null ) { throw new UsernameNotFoundException ( "<STR_LIT>" ) ; } else { if ( ! user . getEnabled ( ) ) { throw new BadRequestException ( "<STR_LIT>" ) ; } jwtUserDto = new JwtUserDto ( user , dataService . getDeptIds ( user ) , roleService . mapToGrantedAuthorities ( user ) ) ; userCacheManager . addUserCache ( username , jwtUserDto ) ; } } return jwtUserDto ; } } </s>
<s> package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . PUT ) public @ interface AnonymousPutMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default "<STR_LIT>" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; } </s>
<s> package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . service . DatabaseService ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . modules . mnt . util . SqlUtils ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . Set ; @ Api ( tags = "<STR_LIT>" ) @ RestController @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) public class DatabaseController { private final String fileSavePath = FileUtil . getTmpDirPath ( ) + "<STR_LIT>" ; private final DatabaseService databaseService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportDatabase ( HttpServletResponse response , DatabaseQueryCriteria criteria ) throws IOException { databaseService . download ( databaseService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Database > > queryDatabase ( DatabaseQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( databaseService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createDatabase ( @ Validated @ RequestBody Database resources ) { databaseService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateDatabase ( @ Validated @ RequestBody Database resources ) { databaseService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDatabase ( @ RequestBody Set < String > ids ) { databaseService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > testConnect ( @ Validated @ RequestBody Database resources ) { return new ResponseEntity < > ( databaseService . testConnection ( resources ) , HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > uploadDatabase ( @ RequestBody MultipartFile file , HttpServletRequest request ) throws Exception { String id = request . getParameter ( "<STR_LIT>" ) ; Database database = databaseService . getById ( id ) ; String fileName ; if ( database != null ) { fileName = file . getOriginalFilename ( ) ; File executeFile = new File ( fileSavePath + fileName ) ; FileUtil . del ( executeFile ) ; file . transferTo ( executeFile ) ; String result = SqlUtils . executeFile ( database . getJdbcUrl ( ) , database . getUserName ( ) , database . getPwd ( ) , executeFile ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } else { throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . util . * ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = "<STR_LIT>" ) @ RequestMapping ( "<STR_LIT>" ) public class DeptController { private final DeptService deptService ; private static final String ENTITY_NAME = "<STR_LIT>" ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportDept ( HttpServletResponse response , DeptQueryCriteria criteria ) throws Exception { deptService . download ( deptService . queryAll ( criteria , false ) , response ) ; } @ ApiOperation ( "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Dept > > queryDept ( DeptQueryCriteria criteria ) throws Exception { List < Dept > depts = deptService . queryAll ( criteria , true ) ; return new ResponseEntity < > ( PageUtil . toPage ( depts ) , HttpStatus . OK ) ; } @ ApiOperation ( "<STR_LIT>" ) @ PostMapping ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > getDeptSuperior ( @ RequestBody List < Long > ids , @ RequestParam ( defaultValue = "<STR_LIT>" ) Boolean exclude ) { Set < Dept > deptSet = new LinkedHashSet < > ( ) ; for ( Long id : ids ) { Dept dept = deptService . findById ( id ) ; List < Dept > depts = deptService . getSuperior ( dept , new ArrayList < > ( ) ) ; if ( exclude ) { for ( Dept data : depts ) { if ( data . getId ( ) . equals ( dept . getPid ( ) ) ) { data . setSubCount ( data . getSubCount ( ) - <NUM_LIT> ) ; } } depts = depts . stream ( ) . filter ( i -> ! ids . contains ( i . getId ( ) ) ) . collect ( Collectors . toList ( ) ) ; } deptSet . addAll ( depts ) ; } return new ResponseEntity < > ( deptService . buildTree ( new ArrayList < > ( deptSet ) ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createDept ( @ Validated @ RequestBody Dept resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( "<STR_LIT>" + ENTITY_NAME + "<STR_LIT>" ) ; } deptService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateDept ( @ Validated ( Dept . Update . class ) @ RequestBody Dept resources ) { deptService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteDept ( @ RequestBody Set < Long > ids ) { Set < Dept > depts = new HashSet < > ( ) ; for ( Long id : ids ) { List < Dept > deptList = deptService . findByPid ( id ) ; depts . add ( deptService . findById ( id ) ) ; if ( CollectionUtil . isNotEmpty ( deptList ) ) { depts = deptService . getDeleteDepts ( deptList , depts ) ; } } deptService . verification ( depts ) ; deptService . delete ( depts ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } } </s>
<s> package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DeployHistoryMapper extends BaseMapper < DeployHistory > { IPage < DeployHistory > findAll ( @ Param ( "<STR_LIT>" ) DeployHistoryQueryCriteria criteria , Page < Object > page ) ; List < DeployHistory > findAll ( @ Param ( "<STR_LIT>" ) DeployHistoryQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface UserService extends IService < User > { User findById ( long id ) ; void create ( User resources ) ; void update ( User resources ) throws Exception ; void delete ( Set < Long > ids ) ; User findByName ( String userName ) ; User getLoginData ( String userName ) ; void updatePass ( String username , String encryptPassword ) ; Map < String , String > updateAvatar ( MultipartFile file ) ; void updateEmail ( String username , String email ) ; PageResult < User > queryAll ( UserQueryCriteria criteria , Page < Object > page ) ; List < User > queryAll ( UserQueryCriteria criteria ) ; void download ( List < User > queryAll , HttpServletResponse response ) throws IOException ; void updateCenter ( User resources ) ; void resetPwd ( Set < Long > ids , String pwd ) ; } </s>
<s> package me . zhengjie . annotation ; import java . lang . annotation . * ; @ Inherited @ Documented @ Target ( { ElementType . METHOD , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface AnonymousAccess { } </s>
<s> package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface AppService extends IService < App > { PageResult < App > queryAll ( AppQueryCriteria criteria , Page < Object > page ) ; List < App > queryAll ( AppQueryCriteria criteria ) ; void create ( App resources ) ; void update ( App resources ) ; void delete ( Set < Long > ids ) ; void download ( List < App > apps , HttpServletResponse response ) throws IOException ; } </s>
<s> package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ Api ( tags = "<STR_LIT>" ) @ RequiredArgsConstructor @ RequestMapping ( "<STR_LIT>" ) public class ServerController { private final ServerService serverService ; @ ApiOperation ( "<STR_LIT>" ) @ GetMapping ( value = "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public void exportServerDeploy ( HttpServletResponse response , ServerQueryCriteria criteria ) throws IOException { serverService . download ( serverService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = "<STR_LIT>" ) @ GetMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < PageResult < Server > > queryServerDeploy ( ServerQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( serverService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > createServerDeploy ( @ Validated @ RequestBody Server resources ) { serverService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PutMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > updateServerDeploy ( @ Validated @ RequestBody Server resources ) { serverService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ DeleteMapping @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > deleteServerDeploy ( @ RequestBody Set < Long > ids ) { serverService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( "<STR_LIT>" ) @ ApiOperation ( value = "<STR_LIT>" ) @ PostMapping ( "<STR_LIT>" ) @ PreAuthorize ( "<STR_LIT>" ) public ResponseEntity < Object > testConnectServerDeploy ( @ Validated @ RequestBody Server resources ) { return new ResponseEntity < > ( serverService . testConnect ( resources ) , HttpStatus . CREATED ) ; } } </s>
<s> package me . zhengjie . modules . mnt . websocket ; public enum MsgType { CONNECT , CLOSE , INFO , ERROR } </s>
<s> package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . util . IdUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . mapper . DatabaseMapper ; import me . zhengjie . modules . mnt . service . DatabaseService ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . modules . mnt . util . SqlUtils ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Slf4j @ Service @ RequiredArgsConstructor public class DatabaseServiceImpl extends ServiceImpl < DatabaseMapper , Database > implements DatabaseService { private final DatabaseMapper databaseMapper ; @ Override public PageResult < Database > queryAll ( DatabaseQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( databaseMapper . findAll ( criteria , page ) ) ; } @ Override public List < Database > queryAll ( DatabaseQueryCriteria criteria ) { return databaseMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Database resources ) { resources . setId ( IdUtil . simpleUUID ( ) ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Database resources ) { Database database = getById ( resources . getId ( ) ) ; database . copy ( resources ) ; saveOrUpdate ( database ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < String > ids ) { removeBatchByIds ( ids ) ; } @ Override public boolean testConnection ( Database resources ) { try { return SqlUtils . testConnection ( resources . getJdbcUrl ( ) , resources . getUserName ( ) , resources . getPwd ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; return false ; } } @ Override public void download ( List < Database > databases , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Database database : databases ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( "<STR_LIT>" , database . getName ( ) ) ; map . put ( "<STR_LIT>" , database . getJdbcUrl ( ) ) ; map . put ( "<STR_LIT>" , database . getUserName ( ) ) ; map . put ( "<STR_LIT>" , database . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } } </s>
<s> package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class DictDetail extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) private Long id ; @ TableField ( value = "<STR_LIT>" ) @ ApiModelProperty ( hidden = true ) private Long dictId ; @ TableField ( exist = false ) private Dict dict ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String label ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String value ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer dictSort = <NUM_LIT> ; } </s>
<s> package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class QiniuQueryCriteria { private String key ; private List < Timestamp > createTime ; } </s>
<s> package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . DELETE ) public @ interface AnonymousDeleteMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default "<STR_LIT>" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; } </s>
<s> package me . zhengjie . domain . vo ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . sql . Date ; import java . sql . Timestamp ; @ Data public class TradeVo { @ NotBlank private String body ; @ NotBlank private String subject ; @ ApiModelProperty ( hidden = true ) private String outTradeNo ; @ ApiModelProperty ( hidden = true ) private String tradeNo ; @ NotBlank private String totalAmount ; @ ApiModelProperty ( hidden = true ) private String state ; @ ApiModelProperty ( hidden = true ) private Timestamp createTime ; @ ApiModelProperty ( hidden = true ) private Date cancelTime ; } </s>
<s> package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . POST ) public @ interface AnonymousPostMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default "<STR_LIT>" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; } </s>
<s> package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface LocalStorageMapper extends BaseMapper < LocalStorage > { IPage < LocalStorage > findAll ( @ Param ( "<STR_LIT>" ) LocalStorageQueryCriteria criteria , Page < Object > page ) ; List < LocalStorage > findAll ( @ Param ( "<STR_LIT>" ) LocalStorageQueryCriteria criteria ) ; } </s>
<s> package me . zhengjie . modules . quartz . utils ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import org . quartz . * ; import org . quartz . impl . triggers . CronTriggerImpl ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import java . util . Date ; import static org . quartz . TriggerBuilder . newTrigger ; @ Slf4j @ Component public class QuartzManage { private static final String JOB_NAME = "<STR_LIT>" ; @ Resource private Scheduler scheduler ; public void addJob ( QuartzJob quartzJob ) { try { JobDetail jobDetail = JobBuilder . newJob ( ExecutionJob . class ) . withIdentity ( JOB_NAME + quartzJob . getId ( ) ) . build ( ) ; Trigger cronTrigger = newTrigger ( ) . withIdentity ( JOB_NAME + quartzJob . getId ( ) ) . startNow ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( quartzJob . getCronExpression ( ) ) ) . build ( ) ; cronTrigger . getJobDataMap ( ) . put ( QuartzJob . JOB_KEY , quartzJob ) ; ( ( CronTriggerImpl ) cronTrigger ) . setStartTime ( new Date ( ) ) ; scheduler . scheduleJob ( jobDetail , cronTrigger ) ; if ( quartzJob . getIsPause ( ) ) { pauseJob ( quartzJob ) ; } } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } public void updateJobCron ( QuartzJob quartzJob ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; } CronScheduleBuilder scheduleBuilder = CronScheduleBuilder . cronSchedule ( quartzJob . getCronExpression ( ) ) ; trigger = trigger . getTriggerBuilder ( ) . withIdentity ( triggerKey ) . withSchedule ( scheduleBuilder ) . build ( ) ; ( ( CronTriggerImpl ) trigger ) . setStartTime ( new Date ( ) ) ; trigger . getJobDataMap ( ) . put ( QuartzJob . JOB_KEY , quartzJob ) ; scheduler . rescheduleJob ( triggerKey , trigger ) ; if ( quartzJob . getIsPause ( ) ) { pauseJob ( quartzJob ) ; } } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } public void deleteJob ( QuartzJob quartzJob ) { try { JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . pauseJob ( jobKey ) ; scheduler . deleteJob ( jobKey ) ; } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } public void resumeJob ( QuartzJob quartzJob ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; } JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . resumeJob ( jobKey ) ; } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } public void runJobNow ( QuartzJob quartzJob ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; } JobDataMap dataMap = new JobDataMap ( ) ; dataMap . put ( QuartzJob . JOB_KEY , quartzJob ) ; JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . triggerJob ( jobKey , dataMap ) ; } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } public void pauseJob ( QuartzJob quartzJob ) { try { JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . pauseJob ( jobKey ) ; } catch ( Exception e ) { log . error ( "<STR_LIT>" , e ) ; throw new BadRequestException ( "<STR_LIT>" ) ; } } } </s>
<s> package me . zhengjie . config ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . data . domain . AuditorAware ; import org . springframework . stereotype . Component ; import java . util . Optional ; @ Component ( "<STR_LIT>" ) public class AuditorConfig implements AuditorAware < String > { @ Override public Optional < String > getCurrentAuditor ( ) { try { return Optional . of ( SecurityUtils . getCurrentUsername ( ) ) ; } catch ( Exception ignored ) { } return Optional . of ( "<STR_LIT>" ) ; } } </s>
<s> package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; import java . util . Objects ; @ Getter @ Setter @ TableName ( "<STR_LIT>" ) public class Server extends BaseEntity implements Serializable { @ TableId ( value = "<STR_LIT>" , type = IdType . AUTO ) @ ApiModelProperty ( value = "<STR_LIT>" , hidden = true ) private Long id ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String name ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String ip ; @ ApiModelProperty ( value = "<STR_LIT>" ) private Integer port ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String account ; @ ApiModelProperty ( value = "<STR_LIT>" ) private String password ; public void copy ( Server source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Server that = ( Server ) o ; return Objects . equals ( id , that . id ) && Objects . equals ( name , that . name ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , name ) ; } } </s>
<s> package me . zhengjie . utils ; import lombok . AccessLevel ; import lombok . Getter ; import lombok . RequiredArgsConstructor ; import java . util . List ; @ Getter @ RequiredArgsConstructor ( access = AccessLevel . PACKAGE ) public class PageResult < T > { private final List < T > content ; private final long totalElements ; } </s>
