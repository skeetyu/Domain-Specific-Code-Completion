<s> from django . apps import AppConfig <EOL> class ProductsConfig ( AppConfig ) : <EOL> default_auto_field = "<STR_LIT>" <EOL> name = "<STR_LIT>" <EOL> </s>
<s> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> def makemigaration ( ) : <EOL> subprocess . run ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , check = False ) <EOL> def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / "<STR_LIT>" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert not first_migration . exists ( ) <EOL> def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> apps_dir = Path ( ) <EOL> makemigaration ( ) <EOL> first_migration = apps_dir / "<STR_LIT>" <EOL> assert first_migration . exists ( ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert first_migration . exists ( ) <EOL> def test_rm_migrations_not_clean_repo ( django_project , runner : CommandRunner ) : <EOL> with pytest . raises ( cappa . Exit ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> </s>
<s> from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import read_falco_config <EOL> def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : <EOL> required_files = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> f"<STR_LIT>" , <EOL> f"<STR_LIT>" , <EOL> f"<STR_LIT>" , <EOL> ] <EOL> return all ( ( project_dir / file ) . exists ( ) for file in required_files ) <EOL> blueprint_path = Path ( "<STR_LIT>" ) . resolve ( strict = True ) <EOL> def test_start_project ( runner : CommandRunner ) : <EOL> runner . invoke ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> config = read_falco_config ( Path ( "<STR_LIT>" ) ) <EOL> config_keys = config . keys ( ) <EOL> assert "<STR_LIT>" in config . get ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" in config_keys <EOL> assert "<STR_LIT>" in config_keys <EOL> assert "<STR_LIT>" in config_keys <EOL> assert all_files_are_correctly_generated ( "<STR_LIT>" , project_dir = Path ( "<STR_LIT>" ) ) <EOL> def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / "<STR_LIT>" / "<STR_LIT>" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( "<STR_LIT>" , project_dir = project_dir ) <EOL> def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : <EOL> runner . invoke ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> project_dir = tmp_path / "<STR_LIT>" <EOL> assert project_dir . exists ( ) <EOL> assert all_files_are_correctly_generated ( "<STR_LIT>" , project_dir = project_dir ) <EOL> def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : <EOL> name , email = git_user_infos <EOL> runner . invoke ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> str ( blueprint_path ) , <EOL> ) <EOL> pyproject_content = ( Path ( "<STR_LIT>" ) / "<STR_LIT>" ) . read_text ( ) <EOL> assert name in pyproject_content <EOL> assert email in pyproject_content <EOL> </s>
<s> import pytest <EOL> from falco . commands . work import default_address <EOL> from falco . commands . work import default_server_cmd <EOL> from falco . commands . work import Work <EOL> from falco . config import write_falco_config <EOL> def test_env_resolution ( tmp_path ) : <EOL> assert Work ( ) . resolve_django_env ( ) <EOL> def test_env_resolution_with_env ( tmp_path ) : <EOL> ( tmp_path / "<STR_LIT>" ) . write_text ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" in Work ( ) . resolve_django_env ( ) <EOL> def test_without_pyproject_file ( ) : <EOL> assert Work ( ) . get_commands ( ) == { "<STR_LIT>" : default_server_cmd . format ( address = default_address ) } <EOL> def test_with_pyproject_file ( pyproject_toml ) : <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = { "<STR_LIT>" : "<STR_LIT>" } ) <EOL> assert Work ( ) . get_commands ( ) == { <EOL> "<STR_LIT>" : default_server_cmd . format ( address = default_address ) , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } <EOL> def test_override_server ( pyproject_toml ) : <EOL> work = { "<STR_LIT>" : "<STR_LIT>" , "<STR_LIT>" : "<STR_LIT>" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( ) . get_commands ( ) == work <EOL> @ pytest . mark . parametrize ( "<STR_LIT>" , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def test_override_server_through_arg ( address ) : <EOL> assert Work ( address = address ) . get_commands ( ) == { "<STR_LIT>" : default_server_cmd . format ( address = address ) } <EOL> @ pytest . mark . parametrize ( "<STR_LIT>" , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ) <EOL> def test_override_server_through_arg_by_pyproject ( pyproject_toml , address ) : <EOL> work = { "<STR_LIT>" : "<STR_LIT>" } <EOL> write_falco_config ( pyproject_path = pyproject_toml , work = work ) <EOL> assert Work ( address = address ) . get_commands ( ) == { "<STR_LIT>" : work [ "<STR_LIT>" ] . format ( address = address ) } <EOL> </s>
<s> from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from tests . commands . test_crud import healthy_django_project <EOL> def test_start_app ( django_project , runner : CommandRunner ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> assert healthy_django_project ( ) <EOL> </s>
<s> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = "<STR_LIT>" , <EOL> fields = [ <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( "<STR_LIT>" , models . TextField ( ) ) , <EOL> ( "<STR_LIT>" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , <EOL> ( "<STR_LIT>" , models . DateTimeField ( default = django . utils . timezone . now ) ) , <EOL> ] , <EOL> ) , <EOL> ] <EOL> </s>
<s> from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , str ( output . resolve ( ) ) ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = { "<STR_LIT>" : "<STR_LIT>" } ) <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> </s>
<s> from django . apps import AppConfig <EOL> class UsersConfig ( AppConfig ) : <EOL> default_auto_field = "<STR_LIT>" <EOL> name = "<STR_LIT>" <EOL> </s>
<s> import subprocess <EOL> from contextlib import suppress <EOL> import cappa <EOL> def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : <EOL> if ignore_dirty : <EOL> return <EOL> with suppress ( subprocess . CalledProcessError ) : <EOL> result = subprocess . run ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , capture_output = True , text = True , check = True ) <EOL> if result . stdout . strip ( ) == "<STR_LIT>" : <EOL> return <EOL> raise cappa . Exit ( <EOL> "<STR_LIT>" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> </s>
<s> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = "<STR_LIT>" , <EOL> fields = [ <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . EmailField ( max_length = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> ) ) , <EOL> ( "<STR_LIT>" , models . ManyToManyField ( to = "<STR_LIT>" ) ) , <EOL> ] , <EOL> ) , <EOL> ] <EOL> </s>
<s> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco import checks <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> def get_django_debug_value ( ) -> bool : <EOL> from django . conf import settings <EOL> return settings . DEBUG <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class RmMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = "<STR_LIT>" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) <EOL> if not django_debug_value : <EOL> raise cappa . Exit ( <EOL> "<STR_LIT>" , <EOL> code = <NUM_LIT> , <EOL> ) <EOL> if not self . apps_dir : <EOL> self . apps_dir = Path ( ) / project_name <EOL> apps = set ( ) <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> for folder in self . apps_dir . iterdir ( ) : <EOL> migration_dir = folder / "<STR_LIT>" <EOL> if not migration_dir . exists ( ) : <EOL> continue <EOL> apps . add ( folder . stem ) <EOL> for file in migration_dir . iterdir ( ) : <EOL> if file . suffix == "<STR_LIT>" and file . name not in [ "<STR_LIT>" ] : <EOL> file . unlink ( ) <EOL> apps_ = "<STR_LIT>" . join ( apps ) <EOL> rich_print ( f"<STR_LIT>" ) <EOL> </s>
<s> from __future__ import annotations <EOL> import os <EOL> import secrets <EOL> import shutil <EOL> import subprocess <EOL> from contextlib import contextmanager <EOL> from contextlib import suppress <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import httpx <EOL> from cookiecutter . config import get_user_config <EOL> from cookiecutter . exceptions import CookiecutterException <EOL> from cookiecutter . main import cookiecutter <EOL> from falco . commands import InstallCrudUtils <EOL> from falco . commands . crud . utils import run_html_formatters <EOL> from falco . commands . htmx import get_latest_tag as htmx_latest_tag <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import clean_project_name <EOL> from falco . utils import is_new_falco_cli_available <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> DEFAULT_SKIP = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class StartProject : <EOL> project_name : Annotated [ <EOL> str , <EOL> cappa . Arg ( parse = clean_project_name , help = "<STR_LIT>" ) , <EOL> ] <EOL> directory : Annotated [ Path | None , cappa . Arg ( help = "<STR_LIT>" ) ] = None <EOL> is_root : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = False <EOL> skip_new_version_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = False <EOL> blueprint : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> short = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = "<STR_LIT>" <EOL> local : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> short = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = False <EOL> checkout : Annotated [ str | None , cappa . Arg ( default = None , long = "<STR_LIT>" , short = "<STR_LIT>" , hidden = True ) ] = None <EOL> def __call__ ( self ) -> None : <EOL> if self . is_root and not self . directory : <EOL> raise cappa . Exit ( "<STR_LIT>" , code = <NUM_LIT> ) <EOL> if not self . skip_new_version_check and is_new_falco_cli_available ( ) : <EOL> message = ( <EOL> f"<STR_LIT>" <EOL> f"<STR_LIT>" <EOL> ) <EOL> rich_print ( message ) <EOL> response = Prompt . ask ( <EOL> f"<STR_LIT>" , <EOL> default = "<STR_LIT>" , <EOL> ) <EOL> if response . lower ( ) == "<STR_LIT>" : <EOL> rich_print ( <EOL> f"<STR_LIT>" <EOL> f"<STR_LIT>" <EOL> ) <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) <EOL> project_dir = self . init_project ( ) <EOL> with change_directory ( project_dir ) : <EOL> pyproject_path = Path ( "<STR_LIT>" ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) <EOL> env_file = Path ( "<STR_LIT>" ) <EOL> env_file . touch ( ) <EOL> env_file . write_text ( "<STR_LIT>" ) <EOL> config = { <EOL> "<STR_LIT>" : { "<STR_LIT>" : str ( crud_utils ) } , <EOL> "<STR_LIT>" : revision , <EOL> "<STR_LIT>" : DEFAULT_SKIP , <EOL> "<STR_LIT>" : self . blueprint , <EOL> } <EOL> if not self . local : <EOL> with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : <EOL> version = htmx_latest_tag ( ) <EOL> filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) <EOL> config [ "<STR_LIT>" ] = Htmx . format_for_config ( filepath , version ) <EOL> write_falco_config ( pyproject_path = pyproject_path , ** config ) <EOL> run_html_formatters ( project_dir / self . project_name / "<STR_LIT>" ) <EOL> msg = f"<STR_LIT>" <EOL> msg += ( <EOL> f"<STR_LIT>" <EOL> f"<STR_LIT>" <EOL> ) <EOL> rich_print ( msg ) <EOL> def init_project ( self ) -> Path : <EOL> author_name , author_email = get_authors_info ( ) <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> try : <EOL> project_dir = cookiecutter ( <EOL> self . blueprint , <EOL> no_input = True , <EOL> output_dir = self . directory or Path ( ) , <EOL> checkout = self . checkout , <EOL> extra_context = { <EOL> "<STR_LIT>" : self . project_name , <EOL> "<STR_LIT>" : author_name , <EOL> "<STR_LIT>" : author_email , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> } , <EOL> ) <EOL> except CookiecutterException as e : <EOL> msg = str ( e ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> if self . is_root : <EOL> renamed_project_dir = self . directory / "<STR_LIT>" <EOL> shutil . move ( project_dir , renamed_project_dir ) <EOL> for obj in Path ( renamed_project_dir ) . iterdir ( ) : <EOL> shutil . move ( obj , self . directory ) <EOL> renamed_project_dir . rmdir ( ) <EOL> project_dir = self . directory <EOL> return Path ( project_dir ) <EOL> def find_local_cookiecutter ( repo : str ) -> Path | None : <EOL> repo_name = repo . split ( "<STR_LIT>" ) [ - <NUM_LIT> ] . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> cookiecutters_dir = Path ( get_user_config ( ) [ "<STR_LIT>" ] ) <EOL> if not cookiecutters_dir . exists ( ) : <EOL> return None <EOL> for directory in cookiecutters_dir . iterdir ( ) : <EOL> if not directory . is_dir ( ) : <EOL> continue <EOL> is_empty = not list ( directory . iterdir ( ) ) <EOL> if directory . is_dir ( ) and not is_empty and directory . name == repo_name : <EOL> return directory <EOL> return None <EOL> def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : <EOL> name_to_urls = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } <EOL> repo = name_to_urls . get ( blueprint , blueprint ) <EOL> if repo . startswith ( "<STR_LIT>" ) and use_local : <EOL> if local_repo := find_local_cookiecutter ( repo ) : <EOL> repo = str ( local_repo . resolve ( ) ) <EOL> else : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , repo , "<STR_LIT>" ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> revision = result . stdout . split ( "<STR_LIT>" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) <EOL> return repo , revision <EOL> def get_authors_info ( ) -> tuple [ str , str ] : <EOL> default_author_name = "<STR_LIT>" <EOL> default_author_email = "<STR_LIT>" <EOL> git_config_cmd = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> try : <EOL> user_name_cmd = subprocess . run ( [ * git_config_cmd , "<STR_LIT>" ] , capture_output = True , text = True , check = False ) <EOL> user_email_cmd = subprocess . run ( [ * git_config_cmd , "<STR_LIT>" ] , capture_output = True , text = True , check = False ) <EOL> except FileNotFoundError : <EOL> return default_author_name , default_author_email <EOL> if user_email_cmd . returncode != <NUM_LIT> : <EOL> return default_author_name , default_author_email <EOL> return ( <EOL> user_name_cmd . stdout . strip ( "<STR_LIT>" ) , <EOL> user_email_cmd . stdout . strip ( "<STR_LIT>" ) , <EOL> ) <EOL> @ contextmanager <EOL> def change_directory ( new_directory : str | Path ) : <EOL> current_directory = Path . cwd ( ) <EOL> try : <EOL> os . chdir ( new_directory ) <EOL> yield <EOL> finally : <EOL> os . chdir ( current_directory ) <EOL> </s>
<s> from pathlib import Path <EOL> BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent <EOL> SECRET_KEY = "<STR_LIT>" <EOL> DEBUG = True <EOL> ALLOWED_HOSTS = [ ] <EOL> AUTH_USER_MODEL = "<STR_LIT>" <EOL> INSTALLED_APPS = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> MIDDLEWARE = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> ROOT_URLCONF = "<STR_LIT>" <EOL> TEMPLATES = [ <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : [ BASE_DIR / "<STR_LIT>" ] , <EOL> "<STR_LIT>" : True , <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] , <EOL> } , <EOL> } , <EOL> ] <EOL> WSGI_APPLICATION = "<STR_LIT>" <EOL> DATABASES = { <EOL> "<STR_LIT>" : { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : BASE_DIR / "<STR_LIT>" , <EOL> } <EOL> } <EOL> AUTH_PASSWORD_VALIDATORS = [ <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } , <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } , <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } , <EOL> { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } , <EOL> ] <EOL> LANGUAGE_CODE = "<STR_LIT>" <EOL> TIME_ZONE = "<STR_LIT>" <EOL> USE_I18N = True <EOL> USE_TZ = True <EOL> STATIC_URL = "<STR_LIT>" <EOL> DEFAULT_AUTO_FIELD = "<STR_LIT>" <EOL> CRISPY_ALLOWED_TEMPLATE_PACKS = "<STR_LIT>" <EOL> CRISPY_TEMPLATE_PACK = "<STR_LIT>" <EOL> SUPERUSER_EMAIL = "<STR_LIT>" <EOL> SUPERUSER_PASSWORD = "<STR_LIT>" <EOL> </s>
<s> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AlterField ( <EOL> model_name = "<STR_LIT>" , <EOL> name = "<STR_LIT>" , <EOL> field = models . BooleanField ( default = False ) , <EOL> ) , <EOL> ] <EOL> </s>
<s> import ast <EOL> import inspect <EOL> import subprocess <EOL> from collections . abc import Callable <EOL> from contextlib import contextmanager <EOL> from pathlib import Path <EOL> from typing import TypeVar <EOL> import cappa <EOL> import httpx <EOL> import tomlkit <EOL> from falco import falco_version <EOL> from rich . progress import Progress <EOL> from rich . progress import SpinnerColumn <EOL> from rich . progress import TextColumn <EOL> ReturnType = TypeVar ( "<STR_LIT>" ) <EOL> RICH_SUCCESS_MARKER = "<STR_LIT>" <EOL> RICH_ERROR_MARKER = "<STR_LIT>" <EOL> RICH_INFO_MARKER = "<STR_LIT>" <EOL> def clean_project_name ( val : str ) -> str : <EOL> return val . strip ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> def get_pyproject_file ( ) -> Path : <EOL> pyproject_path = Path ( "<STR_LIT>" ) <EOL> if pyproject_path . exists ( ) : <EOL> return pyproject_path <EOL> raise cappa . Exit ( "<STR_LIT>" , code = <NUM_LIT> ) <EOL> def get_project_name ( ) -> str : <EOL> pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) <EOL> return pyproject [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> @ contextmanager <EOL> def simple_progress ( description : str , display_text = "<STR_LIT>" ) : <EOL> progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) <EOL> progress . add_task ( description = description , total = None ) <EOL> try : <EOL> yield progress . start ( ) <EOL> finally : <EOL> progress . stop ( ) <EOL> @ contextmanager <EOL> def network_request_with_progress ( url : str , description : str ) : <EOL> try : <EOL> with simple_progress ( description ) : <EOL> yield httpx . get ( url ) <EOL> except httpx . ConnectError as e : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> class ShellCodeError ( Exception ) : <EOL> pass <EOL> def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : <EOL> source = inspect . getsource ( func ) <EOL> arguments_list = [ ] <EOL> for k , v in kwargs . items ( ) : <EOL> if isinstance ( v , str ) : <EOL> arguments_list . append ( f"<STR_LIT>" ) <EOL> else : <EOL> arguments_list . append ( f"<STR_LIT>" ) <EOL> arguments = "<STR_LIT>" . join ( arguments_list ) <EOL> func_call = f"<STR_LIT>" <EOL> code = f"<STR_LIT>" <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , code ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise ShellCodeError ( result . stderr ) <EOL> return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) <EOL> def is_new_falco_cli_available ( ) -> bool : <EOL> try : <EOL> with network_request_with_progress ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ) as response : <EOL> latest_version = response . json ( ) [ "<STR_LIT>" ] [ "<STR_LIT>" ] <EOL> current_version = falco_version <EOL> return latest_version != current_version <EOL> except cappa . Exit : <EOL> return False <EOL> </s>
<s> import falco <EOL> project = "<STR_LIT>" <EOL> copyright = "<STR_LIT>" <EOL> author = "<STR_LIT>" <EOL> version = falco . falco_version <EOL> release = version <EOL> extensions = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> todo_include_todos = True <EOL> extlinks = { <EOL> "<STR_LIT>" : ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> "<STR_LIT>" : ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> "<STR_LIT>" : ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> } <EOL> templates_path = [ "<STR_LIT>" ] <EOL> exclude_patterns = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> html_theme = "<STR_LIT>" <EOL> html_static_path = [ "<STR_LIT>" ] <EOL> html_baseurl = "<STR_LIT>" <EOL> html_title = "<STR_LIT>" <EOL> html_context = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } <EOL> html_theme_options = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : <NUM_LIT> , <EOL> } <EOL> html_logo = "<STR_LIT>" <EOL> html_favicon = "<STR_LIT>" <EOL> html_css_files = [ <EOL> "<STR_LIT>" , <EOL> ] <EOL> html_js_files = [ <EOL> ( <EOL> "<STR_LIT>" , <EOL> { "<STR_LIT>" : "<STR_LIT>" , "<STR_LIT>" : "<STR_LIT>" } , <EOL> ) , <EOL> "<STR_LIT>" , <EOL> ] <EOL> mermaid_version = "<STR_LIT>" <EOL> mermaid_output_format = "<STR_LIT>" <EOL> </s>
<s> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = "<STR_LIT>" , <EOL> name = "<STR_LIT>" , <EOL> field = models . DateTimeField ( blank = True , null = True ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = "<STR_LIT>" , <EOL> name = "<STR_LIT>" , <EOL> field = models . ImageField ( blank = True , null = True , upload_to = "<STR_LIT>" ) , <EOL> ) , <EOL> migrations . AddField ( <EOL> model_name = "<STR_LIT>" , <EOL> name = "<STR_LIT>" , <EOL> field = models . FileField ( blank = True , null = True , upload_to = "<STR_LIT>" ) , <EOL> ) , <EOL> ] <EOL> </s>
<s> from django . contrib import admin <EOL> from . models import Product <EOL> admin . site . register ( Product ) <EOL> </s>
<s> from pathlib import Path <EOL> from typing import cast <EOL> from typing import TypedDict <EOL> import tomlkit <EOL> from typing_extensions import Unpack <EOL> class FalcoConfig ( TypedDict , total = False ) : <EOL> revision : str <EOL> blueprint : str <EOL> skip : list [ str ] <EOL> work : dict [ str , str ] <EOL> htmx : str <EOL> crud : "<STR_LIT>" <EOL> class CRUDConfig ( TypedDict ) : <EOL> blueprints : str <EOL> utils_path : str <EOL> login_required : bool <EOL> skip_git_check : bool <EOL> always_migrate : bool <EOL> def parse_crud_config_from_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) : value for key , value in values . items ( ) } <EOL> def parse_crud_config_to_pyproject ( values : dict ) -> dict : <EOL> return { key . lower ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) : value for key , value in values . items ( ) } <EOL> def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : <EOL> new_falco_config = kwargs <EOL> new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( "<STR_LIT>" , { } ) ) <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> existing_falco_config = pyproject . get ( "<STR_LIT>" , { } ) . get ( "<STR_LIT>" , { } ) <EOL> existing_crud_config = existing_falco_config . pop ( "<STR_LIT>" , { } ) <EOL> existing_crud_config . update ( new_crud_config ) <EOL> existing_falco_config . update ( { ** new_falco_config , "<STR_LIT>" : existing_crud_config } ) <EOL> tool = pyproject . get ( "<STR_LIT>" , { } ) <EOL> tool . update ( { "<STR_LIT>" : existing_falco_config } ) <EOL> pyproject [ "<STR_LIT>" ] = tool <EOL> pyproject_path . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> def read_falco_config ( pyproject_path : Path ) -> FalcoConfig : <EOL> pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) <EOL> falco_config = pyproject . get ( "<STR_LIT>" , { } ) . get ( "<STR_LIT>" , { } ) <EOL> crud_config = falco_config . pop ( "<STR_LIT>" , { } ) <EOL> crud_config = parse_crud_config_from_pyproject ( crud_config ) <EOL> return cast ( FalcoConfig , { ** falco_config , "<STR_LIT>" : crud_config } ) <EOL> </s>
<s> from demo . users . models import User <EOL> from django . http import HttpRequest as HttpRequestBase <EOL> from django_htmx . middleware import HtmxDetails <EOL> class HttpRequest ( HttpRequestBase ) : <EOL> htmx : HtmxDetails <EOL> class AuthenticatedHttpRequest ( HttpRequest ) : <EOL> user : User <EOL> </s>
<s> import django . contrib . auth . models <EOL> import django . contrib . auth . validators <EOL> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> initial = True <EOL> dependencies = [ <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . CreateModel ( <EOL> name = "<STR_LIT>" , <EOL> fields = [ <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BigAutoField ( <EOL> auto_created = True , <EOL> primary_key = True , <EOL> serialize = False , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( "<STR_LIT>" , models . CharField ( max_length = <NUM_LIT> , verbose_name = "<STR_LIT>" ) ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . DateTimeField ( blank = True , null = True , verbose_name = "<STR_LIT>" ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = "<STR_LIT>" , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . CharField ( <EOL> error_messages = { "<STR_LIT>" : "<STR_LIT>" } , <EOL> help_text = "<STR_LIT>" , <EOL> max_length = <NUM_LIT> , <EOL> unique = True , <EOL> validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = "<STR_LIT>" ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = "<STR_LIT>" ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = "<STR_LIT>" ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BooleanField ( <EOL> default = False , <EOL> help_text = "<STR_LIT>" , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . BooleanField ( <EOL> default = True , <EOL> help_text = "<STR_LIT>" , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . DateTimeField ( default = django . utils . timezone . now , verbose_name = "<STR_LIT>" ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = "<STR_LIT>" , <EOL> related_name = "<STR_LIT>" , <EOL> related_query_name = "<STR_LIT>" , <EOL> to = "<STR_LIT>" , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ( <EOL> "<STR_LIT>" , <EOL> models . ManyToManyField ( <EOL> blank = True , <EOL> help_text = "<STR_LIT>" , <EOL> related_name = "<STR_LIT>" , <EOL> related_query_name = "<STR_LIT>" , <EOL> to = "<STR_LIT>" , <EOL> verbose_name = "<STR_LIT>" , <EOL> ) , <EOL> ) , <EOL> ] , <EOL> options = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : False , <EOL> } , <EOL> managers = [ <EOL> ( "<STR_LIT>" , django . contrib . auth . models . UserManager ( ) ) , <EOL> ] , <EOL> ) , <EOL> ] <EOL> </s>
<s> import io <EOL> import os <EOL> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import tomlkit <EOL> from cappa . testing import CommandRunner <EOL> def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> env_file = Path ( "<STR_LIT>" ) <EOL> env_template_file = Path ( "<STR_LIT>" ) <EOL> assert env_file . exists ( ) <EOL> assert env_template_file . exists ( ) <EOL> assert "<STR_LIT>" in env_file . read_text ( ) <EOL> assert "<STR_LIT>" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( "<STR_LIT>" ) <EOL> env_template_file = Path ( "<STR_LIT>" ) <EOL> env_file . write_text ( "<STR_LIT>" ) <EOL> env_template_file . write_text ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" in env_file . read_text ( ) <EOL> assert "<STR_LIT>" in env_template_file . read_text ( ) <EOL> def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : <EOL> env_file = Path ( "<STR_LIT>" ) <EOL> env_template_file = Path ( "<STR_LIT>" ) <EOL> env_file . write_text ( "<STR_LIT>" ) <EOL> env_template_file . write_text ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" in env_file . read_text ( ) <EOL> def test_print_value ( runner : CommandRunner , pyproject_toml ) : <EOL> env_template_file = Path ( "<STR_LIT>" ) <EOL> env_template_file . write_text ( "<STR_LIT>" ) <EOL> with patch ( "<STR_LIT>" , new = io . StringIO ( ) ) as fake_stdout : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> stdout = fake_stdout . getvalue ( ) <EOL> assert not Path ( "<STR_LIT>" ) . exists ( ) <EOL> assert "<STR_LIT>" in stdout <EOL> def test_prod_config ( runner : CommandRunner , pyproject_toml ) : <EOL> os . environ [ "<STR_LIT>" ] = "<STR_LIT>" <EOL> pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) ) <EOL> pyproject [ "<STR_LIT>" ] [ "<STR_LIT>" ] = [ { "<STR_LIT>" : "<STR_LIT>" , "<STR_LIT>" : "<STR_LIT>" } ] <EOL> pyproject_toml . write_text ( tomlkit . dumps ( pyproject ) ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" in Path ( "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" in Path ( "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" in Path ( "<STR_LIT>" ) . read_text ( ) <EOL> </s>
<s> import os <EOL> import sys <EOL> def main ( ) : <EOL> os . environ . setdefault ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> try : <EOL> from django . core . management import execute_from_command_line <EOL> except ImportError as exc : <EOL> raise ImportError ( <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> ) from exc <EOL> execute_from_command_line ( sys . argv ) <EOL> if __name__ == "<STR_LIT>" : <EOL> main ( ) <EOL> </s>
<s> from pathlib import Path <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . commands . htmx import Htmx <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> @ pytest . fixture ( autouse = True ) <EOL> def mock_latest_tag_getter ( ) : <EOL> def _get_latest_tag ( ) : <EOL> return "<STR_LIT>" <EOL> with patch ( "<STR_LIT>" , new = _get_latest_tag ) : <EOL> yield <EOL> def test_htmx_download ( runner : CommandRunner ) : <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_download_with_version ( runner : CommandRunner ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_download_with_specific_version ( runner : CommandRunner ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , str ( output . resolve ( ) ) ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == Path ( "<STR_LIT>" ) <EOL> def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> output = Path ( "<STR_LIT>" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> output = Path ( "<STR_LIT>" ) <EOL> assert output . exists ( ) <EOL> filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == output <EOL> def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = "<STR_LIT>" ) <EOL> existing_path = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" ) <EOL> filepath , _ = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) <EOL> assert filepath == existing_path <EOL> assert existing_path . exists ( ) <EOL> </s>
<s> __version__ = "<STR_LIT>" <EOL> </s>
<s> from django . db import models <EOL> class Order ( models . Model ) : <EOL> name = models . CharField ( max_length = <NUM_LIT> ) <EOL> email = models . EmailField ( ) <EOL> address = models . CharField ( max_length = <NUM_LIT> ) <EOL> postal_code = models . CharField ( max_length = <NUM_LIT> ) <EOL> city = models . CharField ( max_length = <NUM_LIT> ) <EOL> products = models . ManyToManyField ( "<STR_LIT>" ) <EOL> created = models . DateTimeField ( auto_now_add = True ) <EOL> completed = models . BooleanField ( default = False ) <EOL> receipt = models . FileField ( null = True , blank = True ) <EOL> image = models . ImageField ( null = True , blank = True ) <EOL> </s>
<s> import pathlib <EOL> from tempfile import TemporaryDirectory <EOL> from falco . commands import StartProject <EOL> from rich . console import Console <EOL> from rich . markup import escape <EOL> from rich . terminal_theme import DIMMED_MONOKAI <EOL> from rich . text import Text <EOL> from rich . tree import Tree <EOL> def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : <EOL> paths = sorted ( <EOL> pathlib . Path ( directory ) . iterdir ( ) , <EOL> key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , <EOL> ) <EOL> for path in paths : <EOL> if path . is_dir ( ) : <EOL> style = "<STR_LIT>" if path . name . startswith ( "<STR_LIT>" ) else "<STR_LIT>" <EOL> branch = tree . add ( <EOL> f"<STR_LIT>" , <EOL> style = style , <EOL> guide_style = style , <EOL> ) <EOL> walk_directory ( path , branch ) <EOL> else : <EOL> text_filename = Text ( path . name , "<STR_LIT>" ) <EOL> text_filename . highlight_regex ( r"<STR_LIT>" , "<STR_LIT>" ) <EOL> text_filename . stylize ( f"<STR_LIT>" ) <EOL> icon = "<STR_LIT>" if path . suffix == "<STR_LIT>" else "<STR_LIT>" <EOL> tree . add ( Text ( icon ) + text_filename ) <EOL> def main ( ) : <EOL> tree = Tree ( <EOL> "<STR_LIT>" <EOL> ) <EOL> with TemporaryDirectory ( ) as temp : <EOL> temp_dir = pathlib . Path ( temp ) <EOL> StartProject ( <EOL> project_name = "<STR_LIT>" , <EOL> directory = temp_dir . resolve ( ) , <EOL> is_root = True , <EOL> skip_new_version_check = True , <EOL> ) ( ) <EOL> walk_directory ( temp_dir , tree ) <EOL> console = Console ( record = True ) <EOL> with console . capture ( ) : <EOL> console . print ( tree ) <EOL> console . save_svg ( <EOL> "<STR_LIT>" , <EOL> title = "<STR_LIT>" , <EOL> theme = DIMMED_MONOKAI , <EOL> ) <EOL> if __name__ == "<STR_LIT>" : <EOL> main ( ) <EOL> </s>
<s> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> views_functions = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> html_templates = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> views_functions_entry_point = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> html_templates_point = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ] <EOL> forms_attributes = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> admin_attributes = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> def create_pyproject_crud_config ( ** kwargs ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , crud = kwargs ) <EOL> def healthy_django_project ( ) -> bool : <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> return result . returncode == <NUM_LIT> <EOL> def fix_users_import ( ) : <EOL> types = Path ( "<STR_LIT>" ) <EOL> types . write_text ( types . read_text ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) <EOL> def install_crud_utils ( runner ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> fix_users_import ( ) <EOL> def test_crud ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_all_models ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_login ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_entry_point ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions_entry_point : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates_point : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_entry_point_login ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions_entry_point : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates_point : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_only_html ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert not ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> assert not ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for f in views_functions : <EOL> assert f not in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates : <EOL> assert ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_only_python ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert ( app_dir / "<STR_LIT>" ) . exists ( ) <EOL> for a in forms_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for a in admin_attributes : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for f in views_functions : <EOL> assert f in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> for t in html_templates : <EOL> assert not ( app_dir / "<STR_LIT>" / "<STR_LIT>" / f"<STR_LIT>" ) . exists ( ) <EOL> def test_crud_repo_not_clean ( django_project , runner : CommandRunner ) : <EOL> with pytest . raises ( cappa . Exit ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> def test_crud_exclude_field ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> app_dir = Path ( "<STR_LIT>" ) <EOL> assert "<STR_LIT>" not in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" not in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" not in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> forms_attributes_ = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] <EOL> for a in forms_attributes_ : <EOL> assert a in ( app_dir / "<STR_LIT>" ) . read_text ( ) <EOL> def test_crud_login_required ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> views = ( Path ( "<STR_LIT>" ) / "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" in views <EOL> assert "<STR_LIT>" in views <EOL> def test_crud_config_pyproject_skip_git_check_set ( django_project , runner : CommandRunner ) : <EOL> create_pyproject_crud_config ( skip_git_check = True ) <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> views = ( Path ( "<STR_LIT>" ) / "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" in views <EOL> def test_crud_config_pyproject_login_required ( django_project , runner : CommandRunner ) : <EOL> create_pyproject_crud_config ( skip_git_check = True , login_required = True ) <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> views = ( Path ( "<STR_LIT>" ) / "<STR_LIT>" ) . read_text ( ) <EOL> assert "<STR_LIT>" in views <EOL> assert "<STR_LIT>" in views <EOL> def test_crud_config_pyproject_blueprints ( django_project , runner : CommandRunner ) : <EOL> bp = django_project / "<STR_LIT>" <EOL> bp . mkdir ( ) <EOL> html_file = bp / "<STR_LIT>" <EOL> html_file . touch ( ) <EOL> html_file . write_text ( "<STR_LIT>" ) <EOL> create_pyproject_crud_config ( blueprints = str ( Path ( "<STR_LIT>" ) ) , skip_git_check = True ) <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> views = ( Path ( "<STR_LIT>" ) / "<STR_LIT>" ) . read_text ( ) <EOL> rendered_file = Path ( "<STR_LIT>" ) / "<STR_LIT>" / "<STR_LIT>" / "<STR_LIT>" <EOL> assert rendered_file . exists ( ) <EOL> assert "<STR_LIT>" in rendered_file . read_text ( ) <EOL> assert "<STR_LIT>" in views <EOL> def test_crud_always_migrate ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> create_pyproject_crud_config ( always_migrate = True ) <EOL> settings = django_project / "<STR_LIT>" / "<STR_LIT>" <EOL> settings . write_text ( settings . read_text ( ) + "<STR_LIT>" + "<STR_LIT>" ) <EOL> install_crud_utils ( runner ) <EOL> with pytest . raises ( cappa . Exit ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert "<STR_LIT>" not in Path ( "<STR_LIT>" ) . read_text ( ) <EOL> assert not healthy_django_project ( ) <EOL> def test_forms_dates_widgets ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : <EOL> install_crud_utils ( runner ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> models = django_project / "<STR_LIT>" / "<STR_LIT>" / "<STR_LIT>" <EOL> models . write_text ( <EOL> models . read_text ( ) <EOL> + "<STR_LIT>" <EOL> + "<STR_LIT>" <EOL> + "<STR_LIT>" <EOL> ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert healthy_django_project ( ) <EOL> assert "<STR_LIT>" not in ( django_project / "<STR_LIT>" / "<STR_LIT>" ) . read_text ( ) <EOL> forms = django_project / "<STR_LIT>" / "<STR_LIT>" / "<STR_LIT>" <EOL> assert "<STR_LIT>" in forms . read_text ( ) <EOL> assert "<STR_LIT>" in forms . read_text ( ) <EOL> assert "<STR_LIT>" in forms . read_text ( ) <EOL> assert "<STR_LIT>" in forms . read_text ( ) <EOL> </s>
<s> import os <EOL> import subprocess <EOL> from unittest . mock import MagicMock <EOL> from unittest . mock import patch <EOL> import pytest <EOL> from cappa . testing import CommandRunner <EOL> from falco . __main__ import Falco <EOL> @ pytest . fixture ( autouse = True ) <EOL> def change_test_dir ( monkeypatch , tmp_path ) : <EOL> monkeypatch . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def runner ( ) : <EOL> return CommandRunner ( Falco ) <EOL> @ pytest . fixture <EOL> def django_project ( tmp_path ) : <EOL> project_dir = tmp_path / "<STR_LIT>" <EOL> subprocess . run ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , check = True ) <EOL> os . chdir ( project_dir ) <EOL> subprocess . run ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , check = True ) <EOL> model_code = <EOL> ( project_dir / "<STR_LIT>" / "<STR_LIT>" ) . write_text ( model_code ) <EOL> settings_file = project_dir / "<STR_LIT>" / "<STR_LIT>" <EOL> settings_content = settings_file . read_text ( ) <EOL> settings_file . write_text ( settings_content + "<STR_LIT>" + "<STR_LIT>" ) <EOL> ( project_dir / "<STR_LIT>" ) . write_text ( <EOL> ) <EOL> yield project_dir <EOL> os . chdir ( tmp_path ) <EOL> @ pytest . fixture <EOL> def set_git_repo_to_clean ( ) : <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = "<STR_LIT>" <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( "<STR_LIT>" , side_effect = mock_run ) : <EOL> yield <EOL> @ pytest . fixture <EOL> def pyproject_toml ( tmp_path ) : <EOL> pyproject_toml = tmp_path / "<STR_LIT>" <EOL> pyproject_toml . write_text ( <EOL> ) <EOL> yield pyproject_toml <EOL> pyproject_toml . unlink ( ) <EOL> @ pytest . fixture <EOL> def git_user_infos ( ) : <EOL> name = "<STR_LIT>" <EOL> email = "<STR_LIT>" <EOL> def mock_run ( args , ** kwargs ) : <EOL> if args == [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = name <EOL> return mock <EOL> if args == [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] : <EOL> mock = MagicMock ( ) <EOL> mock . returncode = <NUM_LIT> <EOL> mock . stdout = email <EOL> return mock <EOL> return original_run ( args , ** kwargs ) <EOL> original_run = subprocess . run <EOL> with patch ( "<STR_LIT>" , side_effect = mock_run ) : <EOL> yield name , email <EOL> </s>
<s> import importlib <EOL> import subprocess <EOL> from pathlib import Path <EOL> import cappa <EOL> from falco . utils import simple_progress <EOL> from jinja2 import Template <EOL> IMPORT_START_COMMENT = "<STR_LIT>" <EOL> IMPORT_END_COMMENT = "<STR_LIT>" <EOL> CODE_START_COMMENT = "<STR_LIT>" <EOL> CODE_END_COMMENT = "<STR_LIT>" <EOL> def render_to_string ( template_content : str , context : dict ) : <EOL> return Template ( template_content ) . render ( ** context ) <EOL> def get_crud_blueprints_path ( ) -> Path : <EOL> package = importlib . util . find_spec ( "<STR_LIT>" ) <EOL> if package is None : <EOL> raise cappa . Exit ( "<STR_LIT>" , code = <NUM_LIT> ) <EOL> return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / "<STR_LIT>" <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def run_python_formatters ( filepath : str | Path ) : <EOL> autoflake = [ <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> filepath , <EOL> ] <EOL> black = [ "<STR_LIT>" , filepath ] <EOL> isort = [ "<STR_LIT>" , filepath ] <EOL> subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def run_html_formatters ( filepath : str | Path ) : <EOL> djlint = [ "<STR_LIT>" , filepath , "<STR_LIT>" ] <EOL> subprocess . run ( djlint , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) <EOL> def extract_python_file_templates ( file_content : str ) -> tuple [ str , str ] : <EOL> imports_template = extract_content_from ( file_content , IMPORT_START_COMMENT , IMPORT_END_COMMENT ) <EOL> code_template = extract_content_from ( file_content , CODE_START_COMMENT , CODE_END_COMMENT ) <EOL> return imports_template , code_template <EOL> def extract_content_from ( text : str , start_comment : str , end_comment : str ) : <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> return text [ start_index : end_index ] <EOL> </s>
<s> import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import parso <EOL> from falco . commands . crud . utils import run_python_formatters <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> def get_settings_file_path ( ) -> str : <EOL> from django . conf import settings <EOL> s = settings . SETTINGS_MODULE <EOL> s = s . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> return f"<STR_LIT>" <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class StartApp : <EOL> app_name : Annotated [ str , cappa . Arg ( help = "<STR_LIT>" ) ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> apps_dir = Path ( ) / project_name <EOL> app_dir = apps_dir / self . app_name <EOL> final_app_name = f"<STR_LIT>" <EOL> try : <EOL> app_dir . mkdir ( ) <EOL> except FileExistsError as e : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> with simple_progress ( f"<STR_LIT>" ) : <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , self . app_name , app_dir ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> ( app_dir / "<STR_LIT>" ) . unlink ( ) <EOL> model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( "<STR_LIT>" ) else self . app_name . capitalize ( ) <EOL> models_file = app_dir / "<STR_LIT>" <EOL> models_file . write_text ( <EOL> ) <EOL> ( app_dir / "<STR_LIT>" ) . write_text ( "<STR_LIT>" ) <EOL> ( app_dir / "<STR_LIT>" ) . write_text ( "<STR_LIT>" ) <EOL> app_config_file = app_dir / "<STR_LIT>" <EOL> app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) <EOL> run_python_formatters ( models_file ) <EOL> run_python_formatters ( self . register_app ( app_name = final_app_name ) ) <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def register_app ( self , app_name : str ) -> Path : <EOL> names = [ "<STR_LIT>" , "<STR_LIT>" ] <EOL> settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) <EOL> module = parso . parse ( settings_file . read_text ( ) ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names <EOL> ) : <EOL> apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> elements = apps . children [ <NUM_LIT> ] <EOL> elements . children . append ( parso . parse ( f"<STR_LIT>" ) ) <EOL> new_content = module . get_code ( ) <EOL> settings_file . write_text ( new_content ) <EOL> break <EOL> except AttributeError : <EOL> continue <EOL> return settings_file <EOL> </s>
<s> import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> from typing import TypedDict <EOL> import cappa <EOL> import parso <EOL> from falco import checks <EOL> from falco . config import CRUDConfig <EOL> from falco . config import read_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import RICH_ERROR_MARKER <EOL> from falco . utils import RICH_INFO_MARKER <EOL> from falco . utils import RICH_SUCCESS_MARKER <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . install_crud_utils import InstallCrudUtils <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_html_formatters <EOL> from . utils import run_python_formatters <EOL> class DjangoField ( TypedDict ) : <EOL> verbose_name : str <EOL> editable : bool <EOL> class_name : str <EOL> accessor : str <EOL> class DjangoModel ( TypedDict ) : <EOL> name : str <EOL> name_plural : str <EOL> verbose_name : str <EOL> verbose_name_plural : str <EOL> fields : dict [ str , DjangoField ] <EOL> has_file_field : bool <EOL> has_editable_date_field : bool <EOL> class PythonBlueprintContext ( TypedDict ) : <EOL> project_name : str <EOL> login_required : bool <EOL> app_label : str <EOL> model_name : str <EOL> model_name_plural : str <EOL> model_verbose_name_plural : str <EOL> model_has_file_fields : bool <EOL> model_has_editable_date_fields : bool <EOL> model_fields : dict [ str , DjangoField ] <EOL> crud_utils_import : str <EOL> entry_point : bool <EOL> class UrlsForContext ( TypedDict ) : <EOL> list_view_url : str <EOL> create_view_url : str <EOL> detail_view_url : str <EOL> update_view_url : str <EOL> delete_view_url : str <EOL> class HtmlBlueprintContext ( UrlsForContext ) : <EOL> app_label : str <EOL> model_name : str <EOL> model_name_plural : str <EOL> model_verbose_name : str <EOL> model_verbose_name_plural : str <EOL> model_has_file_fields : bool <EOL> model_fields : dict [ str , DjangoField ] <EOL> @ cappa . command ( help = "<STR_LIT>" , name = "<STR_LIT>" ) <EOL> class ModelCRUD : <EOL> model_path : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> help = "<STR_LIT>" <EOL> ) , <EOL> ] <EOL> blueprints : Annotated [ <EOL> str , <EOL> cappa . Arg ( <EOL> default = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> excluded_fields : Annotated [ <EOL> list [ str ] , <EOL> cappa . Arg ( <EOL> short = True , <EOL> default = [ ] , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> only_python : Annotated [ <EOL> bool , <EOL> cappa . Arg ( default = False , long = "<STR_LIT>" , help = "<STR_LIT>" ) , <EOL> ] <EOL> only_html : Annotated [ <EOL> bool , <EOL> cappa . Arg ( default = False , long = "<STR_LIT>" , help = "<STR_LIT>" ) , <EOL> ] <EOL> entry_point : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> login_required : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> short = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> pyproject_path = Path ( "<STR_LIT>" ) <EOL> falco_config = read_falco_config ( pyproject_path = pyproject_path ) if pyproject_path . exists ( ) else { } <EOL> crud_config : CRUDConfig = falco_config . get ( "<STR_LIT>" , { } ) <EOL> self . blueprints = crud_config . get ( "<STR_LIT>" , self . blueprints ) <EOL> self . login_required = crud_config . get ( "<STR_LIT>" , self . login_required ) <EOL> self . skip_git_check = crud_config . get ( "<STR_LIT>" , self . skip_git_check ) <EOL> checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) <EOL> v = self . model_path . split ( "<STR_LIT>" ) <EOL> if len ( v ) == <NUM_LIT> : <EOL> name = None <EOL> app_label = v [ <NUM_LIT> ] <EOL> else : <EOL> name = v . pop ( ) <EOL> app_label = "<STR_LIT>" . join ( v ) <EOL> if crud_config . get ( "<STR_LIT>" , False ) : <EOL> commands = [ <EOL> f"<STR_LIT>" , <EOL> f"<STR_LIT>" , <EOL> ] <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> for cmd in commands : <EOL> result = subprocess . run ( cmd . split ( ) , capture_output = True , check = False , text = True ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr <EOL> raise cappa . Exit ( "<STR_LIT>" + msg , code = <NUM_LIT> ) <EOL> if self . entry_point and not name : <EOL> raise cappa . Exit ( "<STR_LIT>" , code = <NUM_LIT> ) <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> all_django_models = run_in_shell ( <EOL> get_models_data , <EOL> app_label = app_label , <EOL> excluded_fields = self . excluded_fields , <EOL> entry_point = self . entry_point , <EOL> ) <EOL> app_folder_path_str , app_name , templates_dir_str = run_in_shell ( <EOL> get_app_path_name_and_templates_dir , app_label = app_label <EOL> ) <EOL> app_folder_path = Path ( app_folder_path_str ) <EOL> templates_dir = Path ( templates_dir_str ) <EOL> django_models = ( <EOL> [ m for m in all_django_models if m [ "<STR_LIT>" ] . lower ( ) == name . lower ( ) ] if name else all_django_models <EOL> ) <EOL> if name and not django_models : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> python_blueprint_context : list [ PythonBlueprintContext ] = [ ] <EOL> html_blueprint_context : list [ HtmlBlueprintContext ] = [ ] <EOL> install_path , crud_utils_installed = InstallCrudUtils . get_install_path ( <EOL> project_name = project_name , <EOL> falco_config = falco_config , <EOL> ) <EOL> crud_utils_import = str ( install_path ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> for django_model in django_models : <EOL> python_blueprint_context . append ( <EOL> get_python_blueprint_context ( <EOL> project_name = project_name , <EOL> app_label = app_label , <EOL> django_model = django_model , <EOL> crud_utils_import = crud_utils_import , <EOL> login_required = self . login_required , <EOL> entry_point = self . entry_point , <EOL> ) <EOL> ) <EOL> html_blueprint_context . append ( get_html_blueprint_context ( app_label = app_label , django_model = django_model ) ) <EOL> updated_python_files = set ( ) <EOL> if not self . only_html : <EOL> python_blueprints = list ( ( get_crud_blueprints_path ( ) / "<STR_LIT>" ) . iterdir ( ) ) <EOL> updated_python_files . update ( <EOL> self . generate_python_code ( <EOL> app_label = app_label , <EOL> blueprints = python_blueprints , <EOL> app_folder_path = app_folder_path , <EOL> contexts = python_blueprint_context , <EOL> entry_point = self . entry_point , <EOL> ) <EOL> ) <EOL> updated_python_files . update ( <EOL> self . generating_urls ( <EOL> app_name = app_name , <EOL> app_folder_path = app_folder_path , <EOL> app_label = app_label , <EOL> django_models = django_models , <EOL> entry_point = self . entry_point , <EOL> ) <EOL> ) <EOL> updated_html_files = set ( ) <EOL> if not self . only_python : <EOL> html_blueprints = ( <EOL> list ( Path ( self . blueprints ) . glob ( "<STR_LIT>" ) ) <EOL> if self . blueprints <EOL> else list ( ( get_crud_blueprints_path ( ) / "<STR_LIT>" ) . iterdir ( ) ) <EOL> ) <EOL> updated_html_files . update ( <EOL> self . generate_html_templates ( <EOL> contexts = html_blueprint_context , <EOL> entry_point = self . entry_point , <EOL> blueprints = html_blueprints , <EOL> templates_dir = templates_dir , <EOL> ) <EOL> ) <EOL> for file in updated_python_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> for file in updated_html_files : <EOL> run_html_formatters ( str ( file ) ) <EOL> display_names = "<STR_LIT>" . join ( m . get ( "<STR_LIT>" ) for m in django_models ) <EOL> rich_print ( f"<STR_LIT>" ) <EOL> if not crud_utils_installed : <EOL> rich_print ( <EOL> f"<STR_LIT>" <EOL> f"<STR_LIT>" <EOL> ) <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def generate_python_code ( <EOL> self , <EOL> app_label : str , <EOL> app_folder_path : Path , <EOL> blueprints : list [ Path ] , <EOL> contexts : list [ "<STR_LIT>" ] , <EOL> * , <EOL> entry_point : bool , <EOL> ) -> list [ Path ] : <EOL> updated_files = [ ] <EOL> for blueprint in blueprints : <EOL> imports_template , code_template = extract_python_file_templates ( blueprint . read_text ( ) ) <EOL> file_name_without_jinja = "<STR_LIT>" . join ( blueprint . name . split ( "<STR_LIT>" ) [ : - <NUM_LIT> ] ) <EOL> file_to_write_to = app_folder_path / file_name_without_jinja <EOL> file_to_write_to . touch ( exist_ok = True ) <EOL> imports_content , code_content = "<STR_LIT>" , "<STR_LIT>" <EOL> for context in contexts : <EOL> model_name_lower = context [ "<STR_LIT>" ] . lower ( ) <EOL> imports_content += render_to_string ( imports_template , context ) <EOL> code_content += render_to_string ( code_template , context ) <EOL> if entry_point : <EOL> code_content = code_content . replace ( f"<STR_LIT>" , "<STR_LIT>" ) <EOL> code_content = code_content . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> file_to_write_to . write_text ( imports_content + file_to_write_to . read_text ( ) + code_content ) <EOL> updated_files . append ( file_to_write_to ) <EOL> model_name = contexts [ <NUM_LIT> ] [ "<STR_LIT>" ] if len ( contexts ) == <NUM_LIT> else None <EOL> updated_files . append ( <EOL> register_models_in_admin ( <EOL> app_folder_path = app_folder_path , <EOL> app_label = app_label , <EOL> model_name = model_name , <EOL> ) <EOL> ) <EOL> return updated_files <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def generating_urls ( <EOL> self , <EOL> app_folder_path : Path , <EOL> app_label : str , <EOL> app_name : str , <EOL> django_models : list [ "<STR_LIT>" ] , <EOL> * , <EOL> entry_point : bool , <EOL> ) -> list [ Path ] : <EOL> urls_content = "<STR_LIT>" <EOL> for django_model in django_models : <EOL> model_name_lower = django_model [ "<STR_LIT>" ] . lower ( ) <EOL> urlsafe_model_verbose_name_plural = django_model [ "<STR_LIT>" ] . lower ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> urls_content += get_urls ( <EOL> model_name_lower = model_name_lower , <EOL> urlsafe_model_verbose_name_plural = urlsafe_model_verbose_name_plural , <EOL> ) <EOL> if entry_point : <EOL> urls_content = urls_content . replace ( f"<STR_LIT>" , "<STR_LIT>" ) <EOL> urls_content = urls_content . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> urls_content = urls_content . replace ( f"<STR_LIT>" , "<STR_LIT>" ) <EOL> app_urls = app_folder_path / "<STR_LIT>" <EOL> updated_files = [ app_urls ] <EOL> if app_urls . exists ( ) : <EOL> urlpatterns = f"<STR_LIT>" <EOL> app_urls . write_text ( app_urls . read_text ( ) + urlpatterns ) <EOL> else : <EOL> app_urls . touch ( ) <EOL> app_urls . write_text ( initial_urls_content ( app_label , urls_content ) ) <EOL> updated_files . append ( register_app_urls ( app_label = app_label , app_name = app_name ) ) <EOL> return updated_files <EOL> @ simple_progress ( "<STR_LIT>" ) <EOL> def generate_html_templates ( <EOL> self , <EOL> templates_dir : Path , <EOL> blueprints : list [ Path ] , <EOL> contexts : list [ "<STR_LIT>" ] , <EOL> * , <EOL> entry_point : bool , <EOL> ) -> list [ Path ] : <EOL> updated_files = [ ] <EOL> templates_dir . mkdir ( exist_ok = True , parents = True ) <EOL> for blueprint in blueprints : <EOL> filecontent = blueprint . read_text ( ) <EOL> for context in contexts : <EOL> model_name_lower = context [ "<STR_LIT>" ] . lower ( ) <EOL> new_filename = f"<STR_LIT>" <EOL> if entry_point : <EOL> new_filename = blueprint . name . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> if new_filename . startswith ( "<STR_LIT>" ) : <EOL> new_filename = new_filename . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> file_to_write_to = templates_dir / new_filename <EOL> file_to_write_to . touch ( exist_ok = True ) <EOL> views_content = render_to_string ( filecontent , context = context ) <EOL> if entry_point : <EOL> views_content = views_content . replace ( f"<STR_LIT>" , "<STR_LIT>" ) <EOL> views_content = views_content . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> file_to_write_to . write_text ( views_content ) <EOL> updated_files . append ( file_to_write_to ) <EOL> return updated_files <EOL> def get_urls ( model_name_lower : str , urlsafe_model_verbose_name_plural : str ) -> str : <EOL> prefix = urlsafe_model_verbose_name_plural <EOL> return <EOL> def get_urls_template_string ( app_label : str , model_name_lower : str ) -> UrlsForContext : <EOL> return { <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> } <EOL> def initial_urls_content ( app_label : str , urls_content : str ) -> str : <EOL> return <EOL> def register_app_urls ( app_label : str , app_name : str ) -> Path : <EOL> root_url = run_in_shell ( get_root_url_config_path , eval_result = False ) <EOL> root_url = root_url . strip ( ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> rool_url_path = Path ( f"<STR_LIT>" ) <EOL> module = parso . parse ( rool_url_path . read_text ( ) ) <EOL> new_path = parso . parse ( f"<STR_LIT>" ) <EOL> for node in module . children : <EOL> try : <EOL> if ( <EOL> node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type <EOL> and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value == "<STR_LIT>" <EOL> ) : <EOL> patterns = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] <EOL> elements = patterns . children [ <NUM_LIT> ] <EOL> elements . children . append ( new_path ) <EOL> new_content = module . get_code ( ) <EOL> new_content = "<STR_LIT>" + new_content <EOL> rool_url_path . write_text ( new_content ) <EOL> break <EOL> except AttributeError : <EOL> continue <EOL> return rool_url_path <EOL> def register_models_in_admin ( app_folder_path : Path , app_label : str , model_name : str | None = None ) -> Path : <EOL> admin_file = app_folder_path / "<STR_LIT>" <EOL> admin_file . touch ( exist_ok = True ) <EOL> cmd_args = [ app_label ] <EOL> if model_name : <EOL> cmd_args . append ( model_name ) <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , * cmd_args ] , <EOL> capture_output = True , <EOL> text = True , <EOL> check = False , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> msg = result . stderr . split ( "<STR_LIT>" ) [ - <NUM_LIT> ] <EOL> rich_print ( f"<STR_LIT>" ) <EOL> return admin_file <EOL> admin_code = result . stdout . split ( "<STR_LIT>" , <NUM_LIT> ) [ <NUM_LIT> ] <EOL> admin_file . write_text ( admin_file . read_text ( ) + admin_code ) <EOL> if not model_name : <EOL> return admin_file <EOL> admin_lines = admin_file . read_text ( ) . split ( "<STR_LIT>" ) <EOL> _imports = [ ] <EOL> _code = [ ] <EOL> for line in admin_lines : <EOL> if line . startswith ( "<STR_LIT>" ) : <EOL> _imports . append ( line ) <EOL> else : <EOL> _code . append ( line ) <EOL> admin_file . write_text ( "<STR_LIT>" + "<STR_LIT>" . join ( _imports ) + "<STR_LIT>" + "<STR_LIT>" . join ( _code ) ) <EOL> return admin_file <EOL> def get_python_blueprint_context ( <EOL> project_name : str , <EOL> app_label : str , <EOL> django_model : DjangoModel , <EOL> crud_utils_import : str , <EOL> * , <EOL> login_required : bool , <EOL> entry_point : bool , <EOL> ) -> PythonBlueprintContext : <EOL> model_fields = django_model [ "<STR_LIT>" ] <EOL> model_name = django_model [ "<STR_LIT>" ] <EOL> return { <EOL> "<STR_LIT>" : project_name , <EOL> "<STR_LIT>" : app_label , <EOL> "<STR_LIT>" : login_required , <EOL> "<STR_LIT>" : model_name , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : model_fields , <EOL> "<STR_LIT>" : crud_utils_import , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : entry_point , <EOL> } <EOL> def get_html_blueprint_context ( app_label : str , django_model : DjangoModel ) -> HtmlBlueprintContext : <EOL> return { <EOL> "<STR_LIT>" : app_label , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> "<STR_LIT>" : django_model [ "<STR_LIT>" ] , <EOL> ** get_urls_template_string ( <EOL> app_label = app_label , <EOL> model_name_lower = django_model [ "<STR_LIT>" ] . lower ( ) , <EOL> ) , <EOL> } <EOL> def get_models_data ( app_label : str , excluded_fields : list [ str ] , * , entry_point : bool ) -> "<STR_LIT>" : <EOL> from django . apps import apps <EOL> models = apps . get_app_config ( app_label ) . get_models ( ) <EOL> file_fields = ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> dates_fields = ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> def get_model_dict ( model ) -> "<STR_LIT>" : <EOL> name = model . __name__ <EOL> name_lower = name . lower ( ) <EOL> if entry_point : <EOL> name_plural = app_label . lower ( ) <EOL> else : <EOL> name_plural = f"<STR_LIT>" if name . endswith ( "<STR_LIT>" ) else f"<STR_LIT>" <EOL> verbose_name = model . _meta . verbose_name <EOL> verbose_name_plural = model . _meta . verbose_name_plural <EOL> fields : dict [ str , "<STR_LIT>" ] = { <EOL> field . name : { <EOL> "<STR_LIT>" : field . verbose_name , <EOL> "<STR_LIT>" : field . editable , <EOL> "<STR_LIT>" : field . __class__ . __name__ , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> f"<STR_LIT>" + ( "<STR_LIT>" if field . __class__ . __name__ in file_fields else "<STR_LIT>" ) , <EOL> } <EOL> for field in model . _meta . fields <EOL> if field . name not in excluded_fields <EOL> } <EOL> return { <EOL> "<STR_LIT>" : name , <EOL> "<STR_LIT>" : name_plural , <EOL> "<STR_LIT>" : fields , <EOL> "<STR_LIT>" : verbose_name , <EOL> "<STR_LIT>" : verbose_name_plural , <EOL> "<STR_LIT>" : any ( f [ "<STR_LIT>" ] in file_fields for f in fields . values ( ) ) , <EOL> "<STR_LIT>" : any ( f [ "<STR_LIT>" ] in dates_fields and f [ "<STR_LIT>" ] for f in fields . values ( ) ) , <EOL> } <EOL> return [ get_model_dict ( model ) for model in models ] <EOL> def get_app_path_name_and_templates_dir ( app_label : str ) -> tuple [ str , str , str ] : <EOL> from django . apps import apps <EOL> from django . conf import settings <EOL> from pathlib import Path <EOL> app = apps . get_app_config ( app_label ) <EOL> dirs = settings . TEMPLATES [ <NUM_LIT> ] . get ( "<STR_LIT>" , [ ] ) <EOL> templates_dir = Path ( dirs [ <NUM_LIT> ] ) if dirs else Path ( app . path ) / "<STR_LIT>" <EOL> app_templates_dir = templates_dir / app_label <EOL> return str ( app . path ) , str ( app . name ) , str ( app_templates_dir ) <EOL> def get_root_url_config_path ( ) -> str : <EOL> from django . conf import settings <EOL> return settings . ROOT_URLCONF <EOL> </s>
<s> from pathlib import Path <EOL> root_dir = Path ( __file__ ) . parent . parent <EOL> readme = root_dir / "<STR_LIT>" <EOL> guides = root_dir / "<STR_LIT>" <EOL> guides_index = guides / "<STR_LIT>" <EOL> def get_rst_doc_title ( file : Path ) : <EOL> title = "<STR_LIT>" <EOL> for line in file . read_text ( ) . splitlines ( ) : <EOL> if line . startswith ( "<STR_LIT>" ) : <EOL> break <EOL> title = line <EOL> return title <EOL> def guides_files ( ) : <EOL> index_content = guides_index . read_text ( ) <EOL> toc_tree_directive = "<STR_LIT>" <EOL> start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) <EOL> def valid_line ( line ) : <EOL> return bool ( line ) and not line . strip ( ) . startswith ( "<STR_LIT>" ) <EOL> lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( "<STR_LIT>" ) if valid_line ( line ) ] <EOL> return [ guides / f"<STR_LIT>" for line in lines ] <EOL> def get_guides_list ( ) : <EOL> guides_md = [ ] <EOL> for file in guides_files ( ) : <EOL> if file . name . startswith ( "<STR_LIT>" ) : <EOL> continue <EOL> link = f"<STR_LIT>" <EOL> title = get_rst_doc_title ( file ) <EOL> guides_md . append ( f"<STR_LIT>" ) <EOL> return "<STR_LIT>" + "<STR_LIT>" . join ( guides_md ) + "<STR_LIT>" <EOL> def update_readme ( start_comment , end_comment , new_content ) : <EOL> text = readme . read_text ( ) <EOL> start_index = text . find ( start_comment ) + len ( start_comment ) <EOL> end_index = text . find ( end_comment ) <EOL> new_content = text [ : start_index ] + new_content + text [ end_index : ] <EOL> readme . write_text ( new_content ) <EOL> def main ( ) : <EOL> update_readme ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> get_guides_list ( ) , <EOL> ) <EOL> print ( "<STR_LIT>" ) <EOL> if __name__ == "<STR_LIT>" : <EOL> main ( ) <EOL> </s>
<s> from . install_crud_utils import InstallCrudUtils <EOL> from . model_crud import ModelCRUD <EOL> </s>
<s> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import FalcoConfig <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_project_name <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . utils import extract_python_file_templates <EOL> from . utils import get_crud_blueprints_path <EOL> from . utils import render_to_string <EOL> from . utils import run_python_formatters <EOL> @ cappa . command ( help = "<STR_LIT>" , name = "<STR_LIT>" ) <EOL> class InstallCrudUtils : <EOL> output_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = "<STR_LIT>" ) , <EOL> ] = None <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> output_dir = self . install ( project_name = project_name , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( pyproject_path = pyproject_path , crud = { "<STR_LIT>" : str ( output_dir ) } ) <EOL> rich_print ( f"<STR_LIT>" ) <EOL> def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : <EOL> output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] <EOL> output_dir . mkdir ( parents = True , exist_ok = True ) <EOL> ( output_dir / "<STR_LIT>" ) . touch ( exist_ok = True ) <EOL> generated_files = [ ] <EOL> context = { "<STR_LIT>" : project_name } <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> for file_path in ( get_crud_blueprints_path ( ) / "<STR_LIT>" ) . iterdir ( ) : <EOL> imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) <EOL> filename = "<STR_LIT>" . join ( file_path . name . split ( "<STR_LIT>" ) [ : - <NUM_LIT> ] ) <EOL> output_file = output_dir / filename <EOL> output_file . touch ( exist_ok = True ) <EOL> output_file . write_text ( <EOL> render_to_string ( imports_template , context ) <EOL> + render_to_string ( code_template , context ) <EOL> + output_file . read_text ( ) <EOL> ) <EOL> generated_files . append ( output_file ) <EOL> for file in generated_files : <EOL> run_python_formatters ( str ( file ) ) <EOL> return output_dir <EOL> @ classmethod <EOL> def get_install_path ( cls , project_name : str , falco_config : FalcoConfig ) -> tuple [ Path , bool ] : <EOL> if _import_path := falco_config . get ( "<STR_LIT>" , { } ) . get ( "<STR_LIT>" ) : <EOL> return Path ( _import_path ) , True <EOL> return Path ( f"<STR_LIT>" ) , False <EOL> </s>
<s> from __future__ import annotations <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from falco . config import write_falco_config <EOL> from falco . utils import get_pyproject_file <EOL> from falco . utils import network_request_with_progress <EOL> from httpx import codes <EOL> from rich import print as rich_print <EOL> from rich . panel import Panel <EOL> HTMX_DOWNLOAD_URL = "<STR_LIT>" <EOL> HTMX_GH_RELEASE_LATEST_URL = "<STR_LIT>" <EOL> HtmxConfig = tuple [ Path , str | None ] <EOL> def get_latest_tag ( ) -> str : <EOL> with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , "<STR_LIT>" ) as response : <EOL> try : <EOL> return response . json ( ) [ "<STR_LIT>" ] [ <NUM_LIT> : ] <EOL> except KeyError as e : <EOL> msg = ( <EOL> "<STR_LIT>" <EOL> "<STR_LIT>" <EOL> ) <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class Htmx : <EOL> version : Annotated [ str , cappa . Arg ( default = "<STR_LIT>" ) ] = "<STR_LIT>" <EOL> output : Annotated [ Path | None , cappa . Arg ( default = None , short = "<STR_LIT>" , long = "<STR_LIT>" ) ] = None <EOL> def __call__ ( self ) : <EOL> latest_version = get_latest_tag ( ) <EOL> version = self . version if self . version != "<STR_LIT>" else latest_version <EOL> try : <EOL> pyproject_path = get_pyproject_file ( ) <EOL> falco_config = read_falco_config ( pyproject_path ) <EOL> except cappa . Exit : <EOL> falco_config = { } <EOL> pyproject_path = None <EOL> filepath = self . download ( version , falco_config = falco_config ) <EOL> if pyproject_path : <EOL> write_falco_config ( <EOL> pyproject_path = pyproject_path , <EOL> htmx = self . format_for_config ( filepath , version ) , <EOL> ) <EOL> subtitle = ( <EOL> "<STR_LIT>" <EOL> if version == latest_version <EOL> else f"<STR_LIT>" <EOL> ) <EOL> rich_print ( <EOL> Panel ( <EOL> f"<STR_LIT>" , <EOL> subtitle = subtitle , <EOL> ) <EOL> ) <EOL> @ classmethod <EOL> def format_for_config ( cls , filepath : Path , version : str | None ) -> str : <EOL> return str ( filepath ) if version is None else f"<STR_LIT>" <EOL> def download ( self , version : str , falco_config : dict ) -> Path : <EOL> url = HTMX_DOWNLOAD_URL . format ( version = version ) <EOL> with network_request_with_progress ( url , f"<STR_LIT>" ) as response : <EOL> content = response . content . decode ( "<STR_LIT>" ) <EOL> if response . status_code == codes . NOT_FOUND : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) <EOL> filepath = self . resolve_filepath ( falco_config = falco_config ) <EOL> filepath . parent . mkdir ( parents = True , exist_ok = True ) <EOL> filepath . write_text ( content ) <EOL> return filepath <EOL> def resolve_filepath ( self , falco_config : dict ) -> Path : <EOL> if self . output : <EOL> filepath = self . output if str ( self . output ) . endswith ( "<STR_LIT>" ) else self . output / "<STR_LIT>" <EOL> elif self . output is None and "<STR_LIT>" in falco_config : <EOL> htmx_config = self . read_from_config ( falco_config ) <EOL> filepath , _ = htmx_config <EOL> else : <EOL> filepath = Path ( "<STR_LIT>" ) <EOL> return filepath <EOL> @ classmethod <EOL> def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : <EOL> htmx = falco_config . get ( "<STR_LIT>" ) <EOL> if not htmx : <EOL> return Path ( "<STR_LIT>" ) , None <EOL> try : <EOL> filepath , version = htmx . split ( "<STR_LIT>" ) <EOL> except ValueError : <EOL> return Path ( htmx ) , None <EOL> return Path ( filepath ) , version <EOL> </s>
<s> import subprocess <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . utils import get_project_name <EOL> from falco . utils import run_in_shell <EOL> from falco . utils import simple_progress <EOL> from rich import print as rich_print <EOL> from . rm_migrations import RmMigrations <EOL> def reset_migrations_table ( ) -> None : <EOL> from django . db import connection <EOL> with connection . cursor ( ) as cursor : <EOL> cursor . execute ( "<STR_LIT>" ) <EOL> @ cappa . command ( help = "<STR_LIT>" , name = "<STR_LIT>" ) <EOL> class ResetMigrations : <EOL> apps_dir : Annotated [ <EOL> Path | None , <EOL> cappa . Arg ( default = None , help = "<STR_LIT>" ) , <EOL> ] <EOL> skip_git_check : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> default = False , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> result = subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , <EOL> check = False , <EOL> capture_output = True , <EOL> text = True , <EOL> ) <EOL> if result . returncode != <NUM_LIT> : <EOL> raise cappa . Exit ( code = <NUM_LIT> ) <EOL> RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) <EOL> with simple_progress ( "<STR_LIT>" ) : <EOL> run_in_shell ( reset_migrations_table , eval_result = False ) <EOL> subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> subprocess . run ( <EOL> [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , <EOL> check = True , <EOL> stdout = subprocess . DEVNULL , <EOL> stderr = subprocess . DEVNULL , <EOL> ) <EOL> rich_print ( "<STR_LIT>" ) <EOL> </s>
<s> import os <EOL> import secrets <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> import tomlkit <EOL> from falco . utils import get_project_name <EOL> from rich import print as rich_print <EOL> from rich . prompt import Prompt <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class SyncDotenv : <EOL> fill_missing : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = False <EOL> print_env : Annotated [ <EOL> bool , <EOL> cappa . Arg ( <EOL> False , <EOL> short = "<STR_LIT>" , <EOL> long = "<STR_LIT>" , <EOL> help = "<STR_LIT>" , <EOL> ) , <EOL> ] = False <EOL> def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : <EOL> dotenv_file = Path ( "<STR_LIT>" ) <EOL> dotenv_template_file = Path ( "<STR_LIT>" ) <EOL> dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else "<STR_LIT>" <EOL> dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else "<STR_LIT>" <EOL> debug = os . getenv ( "<STR_LIT>" , "<STR_LIT>" ) . lower ( ) == "<STR_LIT>" <EOL> base_config = { "<STR_LIT>" : True } if debug else self . get_prod_config ( project_name ) <EOL> config = { <EOL> ** parse ( dotenv_template_content ) , <EOL> ** base_config , <EOL> ** parse ( dotenv_content ) , <EOL> } <EOL> if self . fill_missing : <EOL> for key , value in config . items ( ) : <EOL> if not value : <EOL> config [ key . upper ( ) ] = Prompt . ask ( f"<STR_LIT>" ) <EOL> dotenv_content = get_updated ( dotenv_content , config ) <EOL> if self . print_env : <EOL> rich_print ( dotenv_content ) <EOL> return <EOL> dotenv_file . touch ( exist_ok = True ) <EOL> dotenv_file . write_text ( dotenv_content ) <EOL> dotenv_template_content = get_updated ( <EOL> dotenv_template_content , <EOL> { key : "<STR_LIT>" for key in config } , <EOL> keep_original = True , <EOL> keep_whitespace = True , <EOL> ) <EOL> dotenv_template_file . touch ( exist_ok = True ) <EOL> dotenv_template_file . write_text ( dotenv_template_content ) <EOL> rich_print ( f"<STR_LIT>" ) <EOL> def get_prod_config ( self , project_name : str ) -> dict : <EOL> return { <EOL> "<STR_LIT>" : False , <EOL> "<STR_LIT>" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> "<STR_LIT>" : f"<STR_LIT>" , <EOL> "<STR_LIT>" : get_superuser_email ( project_name ) , <EOL> "<STR_LIT>" : secrets . token_urlsafe ( <NUM_LIT> ) , <EOL> } <EOL> def get_superuser_email ( project_name : str ) : <EOL> pyproject_file = Path ( "<STR_LIT>" ) <EOL> if pyproject_file . exists ( ) : <EOL> pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) <EOL> if authors := pyproject . get ( "<STR_LIT>" , { } ) . get ( "<STR_LIT>" , [ ] ) : <EOL> return authors [ <NUM_LIT> ] [ "<STR_LIT>" ] <EOL> return f"<STR_LIT>" <EOL> def parse ( env_content : str ) -> dict : <EOL> result = { } <EOL> for line in env_content . split ( "<STR_LIT>" ) : <EOL> stripped_line = line . strip ( ) <EOL> if stripped_line . startswith ( "<STR_LIT>" ) or not stripped_line : <EOL> continue <EOL> try : <EOL> key , value = stripped_line . split ( "<STR_LIT>" , <NUM_LIT> ) <EOL> except ValueError as e : <EOL> msg = f"<STR_LIT>" <EOL> raise cappa . Exit ( msg , code = <NUM_LIT> ) from e <EOL> result [ key ] = value <EOL> return result <EOL> def get_updated ( env_content : str , config : dict , * , keep_original = False , keep_whitespace = False ) -> str : <EOL> content_list = env_content . split ( "<STR_LIT>" ) <EOL> content_dict = { line . split ( "<STR_LIT>" ) [ <NUM_LIT> ] : line for line in content_list if "<STR_LIT>" in line } <EOL> new_content_list = content_list . copy ( ) <EOL> for key , value in config . items ( ) : <EOL> line = content_dict . get ( key ) <EOL> if line is not None : <EOL> index = new_content_list . index ( line ) <EOL> if not keep_original : <EOL> new_content_list [ index ] = f"<STR_LIT>" <EOL> else : <EOL> new_content_list . append ( f"<STR_LIT>" ) <EOL> if not keep_whitespace : <EOL> new_content_list = [ line . strip ( ) for line in new_content_list if line . strip ( ) ] <EOL> return "<STR_LIT>" . join ( new_content_list ) <EOL> </s>
<s> import os <EOL> from django . core . asgi import get_asgi_application <EOL> os . environ . setdefault ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> application = get_asgi_application ( ) <EOL> </s>
<s> from django . contrib . auth . models import AbstractUser <EOL> class User ( AbstractUser ) : <EOL> pass <EOL> </s>
<s> import os <EOL> import sys <EOL> from pathlib import Path <EOL> from typing import Annotated <EOL> import cappa <EOL> from falco . config import read_falco_config <EOL> from honcho . manager import Manager <EOL> from . sync_dotenv import parse as parse_dotenv <EOL> default_server_cmd = "<STR_LIT>" <EOL> default_address = "<STR_LIT>" <EOL> @ cappa . command ( help = "<STR_LIT>" ) <EOL> class Work : <EOL> address : Annotated [ str , cappa . Arg ( default = default_address , help = "<STR_LIT>" ) ] = default_address <EOL> def __call__ ( self ) -> None : <EOL> commands = self . get_commands ( ) <EOL> manager = Manager ( ) <EOL> django_env = self . resolve_django_env ( ) <EOL> for name , cmd in commands . items ( ) : <EOL> manager . add_process ( name , cmd , env = django_env ) <EOL> try : <EOL> manager . loop ( ) <EOL> finally : <EOL> manager . terminate ( ) <EOL> sys . exit ( manager . returncode ) <EOL> def resolve_django_env ( self ) -> dict : <EOL> current_dir = Path ( ) . resolve ( ) <EOL> env_file = current_dir / "<STR_LIT>" <EOL> env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { } <EOL> return { <EOL> ** os . environ , <EOL> "<STR_LIT>" : str ( current_dir ) , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> ** env_vars , <EOL> } <EOL> def get_commands ( self ) -> dict : <EOL> commands = { "<STR_LIT>" : default_server_cmd } <EOL> pyproject_file = Path ( "<STR_LIT>" ) <EOL> if pyproject_file . exists ( ) : <EOL> user_commands = read_falco_config ( pyproject_path = pyproject_file ) . get ( "<STR_LIT>" , { } ) <EOL> else : <EOL> user_commands = { } <EOL> commands |= user_commands <EOL> commands [ "<STR_LIT>" ] = commands [ "<STR_LIT>" ] . format ( address = self . address ) <EOL> return commands <EOL> </s>
<s> from django . apps import AppConfig <EOL> class OrdersConfig ( AppConfig ) : <EOL> default_auto_field = "<STR_LIT>" <EOL> name = "<STR_LIT>" <EOL> </s>
<s> from django . urls import path <EOL> from . import views <EOL> app_name = "<STR_LIT>" <EOL> urlpatterns = [ <EOL> path ( "<STR_LIT>" , views . product_list , name = "<STR_LIT>" ) , <EOL> path ( "<STR_LIT>" , views . product_create , name = "<STR_LIT>" ) , <EOL> path ( "<STR_LIT>" , views . product_detail , name = "<STR_LIT>" ) , <EOL> path ( "<STR_LIT>" , views . product_update , name = "<STR_LIT>" ) , <EOL> path ( "<STR_LIT>" , views . product_delete , name = "<STR_LIT>" ) , <EOL> ] <EOL> </s>
<s> import django . utils . timezone <EOL> from django . db import migrations <EOL> from django . db import models <EOL> class Migration ( migrations . Migration ) : <EOL> dependencies = [ <EOL> ( "<STR_LIT>" , "<STR_LIT>" ) , <EOL> ] <EOL> operations = [ <EOL> migrations . AddField ( <EOL> model_name = "<STR_LIT>" , <EOL> name = "<STR_LIT>" , <EOL> field = models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) , <EOL> preserve_default = False , <EOL> ) , <EOL> ] <EOL> </s>
<s> from pathlib import Path <EOL> from cappa . testing import CommandRunner <EOL> from falco . config import write_falco_config <EOL> def test_htmx_ext_download ( runner : CommandRunner ) : <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , str ( output . resolve ( ) ) ) <EOL> assert ( output / "<STR_LIT>" ) . exists ( ) <EOL> def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , str ( output . resolve ( ) ) ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = "<STR_LIT>" ) <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert output . exists ( ) <EOL> def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) : <EOL> pyproject_toml = Path ( "<STR_LIT>" ) <EOL> pyproject_toml . touch ( ) <EOL> write_falco_config ( pyproject_path = pyproject_toml , htmx = "<STR_LIT>" ) <EOL> output = Path ( "<STR_LIT>" ) <EOL> runner . invoke ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) <EOL> assert not output . exists ( ) <EOL> assert Path ( "<STR_LIT>" ) . exists ( ) <EOL> </s>
<s> from django . apps import AppConfig <EOL> class CoreConfig ( AppConfig ) : <EOL> default_auto_field = "<STR_LIT>" <EOL> name = "<STR_LIT>" <EOL> </s>
<s> from functools import wraps <EOL> from django . core . paginator import InvalidPage <EOL> from django . core . paginator import Paginator <EOL> from django . db . models import QuerySet <EOL> from django . http import Http404 <EOL> from django . http import HttpResponse <EOL> from django . template . loader import render_to_string <EOL> from django . utils . translation import gettext_lazy as _ <EOL> from . types import HttpRequest <EOL> def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : <EOL> paginator = Paginator ( queryset , page_size ) <EOL> page_number = request . GET . get ( "<STR_LIT>" ) or <NUM_LIT> <EOL> try : <EOL> page_number = int ( page_number ) <EOL> except ValueError as e : <EOL> if page_number == "<STR_LIT>" : <EOL> page_number = paginator . num_pages <EOL> else : <EOL> msg = "<STR_LIT>" <EOL> raise Http404 ( _ ( msg ) ) from e <EOL> try : <EOL> return paginator . page ( page_number ) <EOL> except InvalidPage as exc : <EOL> msg = "<STR_LIT>" <EOL> raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc <EOL> def for_htmx ( <EOL> * , <EOL> if_hx_target : str | None = None , <EOL> use_template : str | None = None , <EOL> use_partial : str | list [ str ] | None = None , <EOL> use_partial_from_params : bool = False , <EOL> ) : <EOL> if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> def decorator ( view ) : <EOL> @ wraps ( view ) <EOL> def _view ( request : HttpRequest , * args , ** kwargs ) : <EOL> resp = view ( request , * args , ** kwargs ) <EOL> if not request . htmx : <EOL> return resp <EOL> apply_decorator = if_hx_target is None or request . headers . get ( "<STR_LIT>" , None ) == if_hx_target <EOL> if not apply_decorator : <EOL> return resp <EOL> partials_to_use = use_partial <EOL> if not hasattr ( resp , "<STR_LIT>" ) : <EOL> if not resp . content and any ( <EOL> h in resp . headers <EOL> for h in ( <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> "<STR_LIT>" , <EOL> ) <EOL> ) : <EOL> return resp <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> if resp . is_rendered : <EOL> raise ValueError ( "<STR_LIT>" ) <EOL> if use_partial_from_params : <EOL> use_partial_from_params_val = _get_param_from_request ( request , "<STR_LIT>" ) <EOL> if use_partial_from_params_val is not None : <EOL> partials_to_use = use_partial_from_params_val <EOL> if use_template is not None : <EOL> resp . template_name = use_template <EOL> elif partials_to_use is not None : <EOL> if not isinstance ( partials_to_use , list ) : <EOL> partials_to_use = [ partials_to_use ] <EOL> rendered_partials = [ <EOL> render_to_string ( f"<STR_LIT>" , context = resp . context_data , request = request ) <EOL> for b in partials_to_use <EOL> ] <EOL> resp = HttpResponse ( <EOL> content = "<STR_LIT>" . join ( rendered_partials ) , <EOL> status = resp . status_code , <EOL> headers = resp . headers , <EOL> ) <EOL> return resp <EOL> return _view <EOL> return decorator <EOL> def _get_param_from_request ( request , param ) : <EOL> if param in request . GET : <EOL> return request . GET . getlist ( param ) <EOL> if request . method == "<STR_LIT>" and param in request . POST : <EOL> return request . POST . getlist ( param ) <EOL> return None <EOL> </s>
