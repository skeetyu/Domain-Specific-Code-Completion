<s> package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . content . SharedPreferences ; import android . content . res . XResources ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . os . Build ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . WppXposed ; import com . wmods . wppenhacer . xposed . core . WppCore ; import de . robv . android . xposed . XposedBridge ; public class DesignUtils { private static SharedPreferences mPrefs ; @ SuppressLint ( "<STR_LIT>" ) public static Drawable getDrawable ( int id ) { return Utils . getApplication ( ) . getDrawable ( id ) ; } @ Nullable public static Drawable getDrawableByName ( String name ) { var id = Utils . getID ( name , "<STR_LIT>" ) ; if ( id == <NUM_LIT> ) return null ; return DesignUtils . getDrawable ( id ) ; } @ Nullable public static Drawable getIconByName ( String name , boolean isTheme ) { var id = Utils . getID ( name , "<STR_LIT>" ) ; if ( id == <NUM_LIT> ) return null ; var icon = DesignUtils . getDrawable ( id ) ; if ( isTheme && icon != null ) { return DesignUtils . coloredDrawable ( icon , isNightMode ( ) ? Color . WHITE : Color . BLACK ) ; } return icon ; } @ NonNull public static Drawable coloredDrawable ( Drawable drawable , int color ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { drawable . setColorFilter ( new BlendModeColorFilter ( color , BlendMode . SRC_ATOP ) ) ; } else { drawable . setColorFilter ( color , PorterDuff . Mode . SRC_ATOP ) ; } return drawable ; } @ SuppressLint ( "<STR_LIT>" ) public static Drawable alphaDrawable ( Drawable drawable , int primaryTextColor , int i ) { Drawable coloredDrawable = DesignUtils . coloredDrawable ( drawable , primaryTextColor ) ; coloredDrawable . setAlpha ( i ) ; return coloredDrawable ; } @ NonNull public static Drawable createDrawable ( String type , int color ) { switch ( type ) { case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; var shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable selectorBg = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; selectorBg . getPaint ( ) . setColor ( color ) ; return selectorBg ; } case "<STR_LIT>" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case "<STR_LIT>" -> { float radius = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] outerRadii = new float [ ] { radius , radius , radius , radius , radius , radius , radius , radius } ; RoundRectShape roundRectShape = new RoundRectShape ( outerRadii , null , null ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( roundRectShape ) ; Paint paint = shapeDrawable . getPaint ( ) ; paint . setColor ( Color . TRANSPARENT ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( Utils . dipToPixels ( <NUM_LIT> ) ) ; paint . setColor ( color ) ; int inset = Utils . dipToPixels ( <NUM_LIT> ) ; return new InsetDrawable ( shapeDrawable , inset , inset , inset , inset ) ; } } return new ColorDrawable ( Color . BLACK ) ; } public static int getPrimaryTextColor ( ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } public static int getUnSeenColor ( ) { var primaryColor = mPrefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; if ( primaryColor == <NUM_LIT> || ! mPrefs . getBoolean ( "<STR_LIT>" , false ) ) { return <NUM_LIT> ; } return primaryColor ; } public static int getPrimarySurfaceColor ( ) { var backgroundColor = mPrefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; if ( backgroundColor == <NUM_LIT> || ! mPrefs . getBoolean ( "<STR_LIT>" , false ) ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } return backgroundColor ; } public static void setReplacementDrawable ( String name , Drawable replacement ) { if ( WppXposed . ResParam == null ) return ; WppXposed . ResParam . res . setReplacement ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" , name , new XResources . DrawableLoader ( ) { @ Override public Drawable newDrawable ( XResources res , int id ) throws Throwable { return replacement ; } } ) ; } public static boolean isNightMode ( ) { return WppCore . getDefaultTheme ( ) == - <NUM_LIT> ? isNightModeBySystem ( ) : WppCore . getDefaultTheme ( ) == <NUM_LIT> ; } public static boolean isNightModeBySystem ( ) { return ( Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . uiMode & <NUM_LIT> ) == <NUM_LIT> ; } public static void setPrefs ( SharedPreferences mPrefs ) { DesignUtils . mPrefs = mPrefs ; } public static boolean isValidColor ( String primaryColor ) { try { Color . parseColor ( primaryColor ) ; return true ; } catch ( Exception e ) { return false ; } } public static String checkSystemColor ( String color ) { if ( DesignUtils . isValidColor ( color ) ) { return color ; } try { if ( color . startsWith ( "<STR_LIT>" ) ) { var idColor = color . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; var colorRes = android . R . color . class . getField ( idColor ) . getInt ( null ) ; if ( colorRes != - <NUM_LIT> ) { return "<STR_LIT>" + Integer . toHexString ( ContextCompat . getColor ( Utils . getApplication ( ) , colorRes ) ) ; } } } catch ( Exception e ) { XposedBridge . log ( "<STR_LIT>" + e ) ; } return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . utils . ColorReplacement . replaceColors ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static de . robv . android . xposed . XposedHelpers . findAndHookConstructor ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . Manifest ; import android . app . Activity ; import android . app . Notification ; import android . content . pm . PackageManager ; import android . content . res . ColorStateList ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . utils . IColors ; import com . wmods . wppenhacer . views . WallpaperView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . xmlpull . v1 . XmlPullParser ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CustomTheme extends Feature { public static ClassLoader loader1 ; private HashMap < String , String > wallAlpha ; private HashMap < String , String > navAlpha ; private HashMap < String , String > toolbarAlpha ; private Properties properties ; public CustomTheme ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; loader1 = loader ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; hookColors ( ) ; hookWallpaper ( ) ; } private void hookWallpaper ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) && ! Objects . equals ( properties . getProperty ( "<STR_LIT>" ) , "<STR_LIT>" ) ) return ; var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedHelpers . findAndHookMethod ( clazz . getSuperclass ( ) , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_MEDIA_IMAGES ) == PackageManager . PERMISSION_GRANTED || ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { injectWallpaper ( activity . findViewById ( android . R . id . content ) ) ; } } } ) ; var hookFragmentView = Unobfuscator . loadFragmentViewMethod ( classLoader ) ; XposedBridge . hookMethod ( hookFragmentView , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( ViewGroup ) param . getResult ( ) ; replaceColors ( viewGroup , wallAlpha ) ; } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; XposedHelpers . findAndHookMethod ( FrameLayout . class , "<STR_LIT>" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; var viewGroup = ( ViewGroup ) param . thisObject ; var background = viewGroup . getBackground ( ) ; try { var colorfilters = XposedHelpers . getObjectField ( background , "<STR_LIT>" ) ; var fields = ReflectionUtils . getFieldsByType ( colorfilters . getClass ( ) , ColorStateList . class ) ; var colorStateList = ( ColorStateList ) fields . get ( <NUM_LIT> ) . get ( colorfilters ) ; if ( colorStateList == null ) return ; var color = IColors . toString ( colorStateList . getDefaultColor ( ) ) ; var newColor = navAlpha . get ( color ) ; if ( newColor != null ) { background . setTint ( IColors . parseColor ( newColor ) ) ; } } catch ( Throwable ignored ) { } } } ) ; var customWallpaper = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( customWallpaper || properties . containsKey ( "<STR_LIT>" ) ) { wallAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlpha = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( wallAlpha , ( <NUM_LIT> - wallpaperAlpha ) / <NUM_LIT> ) ; navAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlphaNav = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( navAlpha , ( <NUM_LIT> - wallpaperAlphaNav ) / <NUM_LIT> ) ; toolbarAlpha = new HashMap < > ( IColors . colors ) ; var colorOrig = "<STR_LIT>" ; var color = toolbarAlpha . get ( colorOrig ) ; if ( Objects . equals ( colorOrig , color ) ) toolbarAlpha . put ( colorOrig , "<STR_LIT>" ) ; var wallpaperToolbarAlpha = customWallpaper ? prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( "<STR_LIT>" ) , <NUM_LIT> ) ; replaceTransparency ( toolbarAlpha , ( <NUM_LIT> - wallpaperToolbarAlpha ) / <NUM_LIT> ) ; } } private void hookColors ( ) throws Exception { var customDrawable1 = Unobfuscator . loadExpandableWidgetClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable1 . getName ( ) ) ; var customDrawable2 = Unobfuscator . loadMaterialShapeDrawableClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable2 . getName ( ) ) ; var customDrawable3 = Unobfuscator . loadCustomDrawableClass ( classLoader ) ; logDebug ( "<STR_LIT>" + customDrawable3 . getName ( ) ) ; var primaryColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var secondaryColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var backgroundColorInt = prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; var primaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var secondaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var backgroundColor = DesignUtils . checkSystemColor ( properties . getProperty ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { primaryColor = primaryColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( primaryColorInt ) ; secondaryColor = secondaryColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( secondaryColorInt ) ; backgroundColor = backgroundColorInt == <NUM_LIT> ? "<STR_LIT>" : IColors . toString ( backgroundColorInt ) ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) || Objects . equals ( properties . getProperty ( "<STR_LIT>" ) , "<STR_LIT>" ) ) { for ( var c : IColors . colors . keySet ( ) ) { if ( ! primaryColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( primaryColor ) ) { primaryColor = primaryColor . length ( ) == <NUM_LIT> ? primaryColor : "<STR_LIT>" + primaryColor . substring ( <NUM_LIT> ) ; switch ( c ) { case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , primaryColor . substring ( <NUM_LIT> ) ) ; case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , primaryColor ) ; case "<STR_LIT>" -> IColors . colors . put ( c , "<STR_LIT>" + primaryColor . substring ( <NUM_LIT> ) ) ; } } if ( ! backgroundColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( backgroundColor ) ) { backgroundColor = backgroundColor . length ( ) == <NUM_LIT> ? backgroundColor : "<STR_LIT>" + backgroundColor . substring ( <NUM_LIT> ) ; switch ( c ) { case "<STR_LIT>" -> IColors . colors . put ( c , backgroundColor . substring ( <NUM_LIT> ) ) ; case "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" -> IColors . colors . put ( c , backgroundColor ) ; } } if ( ! secondaryColor . equals ( "<STR_LIT>" ) && DesignUtils . isValidColor ( secondaryColor ) ) { secondaryColor = secondaryColor . length ( ) == <NUM_LIT> ? secondaryColor : "<STR_LIT>" + secondaryColor . substring ( <NUM_LIT> ) ; if ( c . equals ( "<STR_LIT>" ) ) { IColors . colors . put ( c , secondaryColor ) ; } } } } findAndHookMethod ( Activity . class . getName ( ) , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; var colors = IColors . colors ; var activity = ( Activity ) param . thisObject ; var view = activity . findViewById ( android . R . id . content ) . getRootView ( ) ; replaceColors ( view , colors ) ; } } ) ; var intBgHook = new IntBgColorHook ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { findAndHookConstructor ( BlendModeColorFilter . class , int . class , BlendMode . class , intBgHook ) ; } findAndHookConstructor ( PorterDuffColorFilter . class , int . class , PorterDuff . Mode . class , intBgHook ) ; findAndHookMethod ( TextView . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Paint . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( GradientDrawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( ColorDrawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Notification . Builder . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , int . class , intBgHook ) ; var colorStateListHook = new ColorStateListHook ( ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , "<STR_LIT>" , int . class , intBgHook ) ; findAndHookMethod ( customDrawable3 , "<STR_LIT>" , ColorStateList . class , colorStateListHook ) ; var inflaterHook = ( XC_MethodHook ) new LayoutInflaterHook ( ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , XmlPullParser . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , int . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , "<STR_LIT>" , XmlPullParser . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var drawable = ( Drawable ) param . args [ <NUM_LIT> ] ; replaceColor ( drawable , colors ) ; } } ) ; } private void replaceTransparency ( HashMap < String , String > wallpaperColors , float mAlpha ) { var hexAlpha = Integer . toHexString ( ( int ) Math . ceil ( mAlpha * <NUM_LIT> ) ) ; hexAlpha = hexAlpha . length ( ) == <NUM_LIT> ? "<STR_LIT>" + hexAlpha : hexAlpha ; for ( var c : List . of ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) { var oldColor = wallpaperColors . get ( c ) ; if ( oldColor == null ) continue ; var newColor = "<STR_LIT>" + hexAlpha + oldColor . substring ( <NUM_LIT> ) ; wallpaperColors . put ( c , newColor ) ; wallpaperColors . put ( oldColor , newColor ) ; } } private void injectWallpaper ( View view ) { var content = ( ViewGroup ) view ; var rootView = ( ViewGroup ) content . getChildAt ( <NUM_LIT> ) ; var header = ( ViewGroup ) rootView . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; replaceColors ( header , toolbarAlpha ) ; var frameLayout = new WallpaperView ( rootView . getContext ( ) , prefs , properties ) ; rootView . addView ( frameLayout , <NUM_LIT> ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static class LayoutInflaterHook extends XC_MethodHook { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var view = ( View ) param . getResult ( ) ; if ( view == null ) return ; replaceColors ( view , colors ) ; } } public static class ColorStateListHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var colorStateList = param . args [ <NUM_LIT> ] ; if ( colorStateList != null ) { var mColors = ( int [ ] ) XposedHelpers . getObjectField ( colorStateList , "<STR_LIT>" ) ; for ( int i = <NUM_LIT> ; i < mColors . length ; i ++ ) { var sColor = IColors . toString ( mColors [ i ] ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { mColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { mColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } XposedHelpers . setObjectField ( colorStateList , "<STR_LIT>" , mColors ) ; param . args [ <NUM_LIT> ] = colorStateList ; } } } public static class IntBgColorHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var color = ( int ) param . args [ <NUM_LIT> ] ; var sColor = IColors . toString ( color ) ; if ( param . thisObject instanceof TextView textView ) { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( textView . getId ( ) == id ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( "<STR_LIT>" + sColor . substring ( sColor . length ( ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) ) ; return ; } } var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } } } </s>
<s> package com . wmods . wppenhacer . xposed . core . db ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XposedBridge ; public class MessageStore { private static MessageStore mInstance ; private SQLiteDatabase sqLiteDatabase ; private MessageStore ( ) { var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var dbFile = new File ( dataDir , "<STR_LIT>" ) ; if ( ! dbFile . exists ( ) ) return ; sqLiteDatabase = SQLiteDatabase . openDatabase ( dbFile . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READWRITE ) ; } public static MessageStore getInstance ( ) { synchronized ( MessageStore . class ) { if ( mInstance == null || mInstance . sqLiteDatabase == null || ! mInstance . sqLiteDatabase . isOpen ( ) ) { mInstance = new MessageStore ( ) ; } } return mInstance ; } public String getMessageById ( long id ) { if ( sqLiteDatabase == null ) return "<STR_LIT>" ; String message = "<STR_LIT>" ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = new String [ ] { String . valueOf ( id ) } ; cursor = sqLiteDatabase . query ( "<STR_LIT>" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return message ; } public String getOriginalMessageKey ( long id ) { if ( sqLiteDatabase == null ) return "<STR_LIT>" ; String message = "<STR_LIT>" ; try ( Cursor cursor = sqLiteDatabase . rawQuery ( "<STR_LIT>" + id + "<STR_LIT>" , null ) ) { if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( <NUM_LIT> ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } return message ; } public List < String > getAudioListByMessageList ( List < String > messageList ) { if ( sqLiteDatabase == null ) return new ArrayList < > ( ) ; List < String > list = new ArrayList < > ( ) ; Cursor cursor = null ; try { String sql = "<STR_LIT>" ; sql += String . join ( "<STR_LIT>" , messageList . stream ( ) . map ( m -> "<STR_LIT>" + m + "<STR_LIT>" ) . toArray ( String [ ] :: new ) ) ; sql += "<STR_LIT>" ; cursor = sqLiteDatabase . rawQuery ( sql , null ) ; if ( cursor . moveToFirst ( ) ) { do { int type = cursor . getInt ( <NUM_LIT> ) ; if ( type == <NUM_LIT> ) { list . add ( cursor . getString ( <NUM_LIT> ) ) ; } } while ( cursor . moveToNext ( ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return list ; } public synchronized void executeSQL ( String sql ) { try { if ( sqLiteDatabase == null ) return ; sqLiteDatabase . execSQL ( sql ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } public void storeMessageRead ( String messageId ) { if ( sqLiteDatabase == null ) return ; XposedBridge . log ( "<STR_LIT>" + messageId ) ; sqLiteDatabase . execSQL ( "<STR_LIT>" + messageId + "<STR_LIT>" ) ; } public boolean isReadMessageStatus ( String messageId ) { if ( sqLiteDatabase == null ) return false ; boolean result = false ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { "<STR_LIT>" } ; String selection = "<STR_LIT>" ; String [ ] selectionArgs = new String [ ] { messageId } ; cursor = sqLiteDatabase . query ( "<STR_LIT>" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { result = cursor . getInt ( cursor . getColumnIndexOrThrow ( "<STR_LIT>" ) ) == <NUM_LIT> ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return result ; } public SQLiteDatabase getDatabase ( ) { return sqLiteDatabase ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . app . Activity ; import android . app . Application ; import android . app . Instrumentation ; import android . content . BroadcastReceiver ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . components . SharedPreferencesWrapper ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . features . customization . BubbleColors ; import com . wmods . wppenhacer . xposed . features . customization . CustomTheme ; import com . wmods . wppenhacer . xposed . features . customization . CustomTime ; import com . wmods . wppenhacer . xposed . features . customization . CustomToolbar ; import com . wmods . wppenhacer . xposed . features . customization . CustomView ; import com . wmods . wppenhacer . xposed . features . customization . DotOnline ; import com . wmods . wppenhacer . xposed . features . customization . FilterGroups ; import com . wmods . wppenhacer . xposed . features . customization . HideTabs ; import com . wmods . wppenhacer . xposed . features . customization . IGStatus ; import com . wmods . wppenhacer . xposed . features . customization . SeparateGroup ; import com . wmods . wppenhacer . xposed . features . general . AntiRevoke ; import com . wmods . wppenhacer . xposed . features . general . CallType ; import com . wmods . wppenhacer . xposed . features . general . ChatLimit ; import com . wmods . wppenhacer . xposed . features . general . DeleteStatus ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . features . general . NewChat ; import com . wmods . wppenhacer . xposed . features . general . Others ; import com . wmods . wppenhacer . xposed . features . general . PinnedLimit ; import com . wmods . wppenhacer . xposed . features . general . SeenTick ; import com . wmods . wppenhacer . xposed . features . general . ShareLimit ; import com . wmods . wppenhacer . xposed . features . general . ShowEditMessage ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . features . media . DownloadProfile ; import com . wmods . wppenhacer . xposed . features . media . DownloadViewOnce ; import com . wmods . wppenhacer . xposed . features . media . MediaPreview ; import com . wmods . wppenhacer . xposed . features . media . MediaQuality ; import com . wmods . wppenhacer . xposed . features . media . StatusDownload ; import com . wmods . wppenhacer . xposed . features . others . Channels ; import com . wmods . wppenhacer . xposed . features . others . ChatFilters ; import com . wmods . wppenhacer . xposed . features . others . CopyStatus ; import com . wmods . wppenhacer . xposed . features . others . DebugFeature ; import com . wmods . wppenhacer . xposed . features . others . GroupAdmin ; import com . wmods . wppenhacer . xposed . features . others . Stickers ; import com . wmods . wppenhacer . xposed . features . others . TextStatusComposer ; import com . wmods . wppenhacer . xposed . features . others . ToastViewer ; import com . wmods . wppenhacer . xposed . features . privacy . CallPrivacy ; import com . wmods . wppenhacer . xposed . features . privacy . DndMode ; import com . wmods . wppenhacer . xposed . features . privacy . FreezeLastSeen ; import com . wmods . wppenhacer . xposed . features . privacy . GhostMode ; import com . wmods . wppenhacer . xposed . features . privacy . HideChat ; import com . wmods . wppenhacer . xposed . features . privacy . HideReceipt ; import com . wmods . wppenhacer . xposed . features . privacy . HideSeen ; import com . wmods . wppenhacer . xposed . features . privacy . HideTagForward ; import com . wmods . wppenhacer . xposed . features . privacy . ViewOnce ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FeatureLoader { public static Application mApp ; public final static String PACKAGE_WPP = "<STR_LIT>" ; public final static String PACKAGE_BUSINESS = "<STR_LIT>" ; private static final ArrayList < ErrorItem > list = new ArrayList < > ( ) ; private static List < String > supportedVersions ; private static String currentVersion ; public static void start ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , String sourceDir ) { if ( ! Unobfuscator . initDexKit ( sourceDir ) ) { XposedBridge . log ( "<STR_LIT>" ) ; return ; } Feature . DEBUG = pref . getBoolean ( "<STR_LIT>" , true ) ; XposedHelpers . findAndHookMethod ( Instrumentation . class , "<STR_LIT>" , Application . class , new XC_MethodHook ( ) { @ SuppressWarnings ( "<STR_LIT>" ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mApp = ( Application ) param . args [ <NUM_LIT> ] ; PackageManager packageManager = mApp . getPackageManager ( ) ; pref . registerOnSharedPreferenceChangeListener ( ( sharedPreferences , s ) -> pref . reload ( ) ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) ; XposedBridge . log ( packageInfo . versionName ) ; currentVersion = packageInfo . versionName ; supportedVersions = Arrays . asList ( mApp . getResources ( ) . getStringArray ( Objects . equals ( mApp . getPackageName ( ) , FeatureLoader . PACKAGE_WPP ) ? ResId . array . supported_versions_wpp : ResId . array . supported_versions_business ) ) ; try { SharedPreferencesWrapper . hookInit ( mApp . getClassLoader ( ) ) ; UnobfuscatorCache . init ( mApp , pref ) ; WppCore . Initialize ( loader ) ; if ( supportedVersions . stream ( ) . noneMatch ( s -> packageInfo . versionName . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) && ! pref . getBoolean ( "<STR_LIT>" , false ) ) { throw new Exception ( "<STR_LIT>" + packageInfo . versionName ) ; } DesignUtils . setPrefs ( pref ) ; initComponents ( loader , pref ) ; plugins ( loader , pref , packageInfo . versionName ) ; registerReceivers ( ) ; mApp . registerActivityLifecycleCallbacks ( new WaCallback ( ) ) ; sendEnabledBroadcast ( mApp ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( "<STR_LIT>" ) ; error . setWhatsAppVersion ( packageInfo . versionName ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + "<STR_LIT>" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) && ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , loader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ! list . isEmpty ( ) ) { var activity = ( Activity ) param . thisObject ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . error_detected ) ) . setMessage ( activity . getString ( ResId . string . version_error ) + String . join ( "<STR_LIT>" , list . stream ( ) . map ( ErrorItem :: getPluginName ) . toArray ( String [ ] :: new ) ) + "<STR_LIT>" + currentVersion + "<STR_LIT>" + String . join ( "<STR_LIT>" , supportedVersions ) ) . setPositiveButton ( activity . getString ( ResId . string . copy_to_clipboard ) , ( dialog , which ) -> { var clipboard = ( ClipboardManager ) mApp . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , String . join ( "<STR_LIT>" , list . stream ( ) . map ( ErrorItem :: toString ) . toArray ( String [ ] :: new ) ) ) ; clipboard . setPrimaryClip ( clip ) ; Toast . makeText ( mApp , ResId . string . copied_to_clipboard , Toast . LENGTH_SHORT ) . show ( ) ; dialog . dismiss ( ) ; } ) . show ( ) ; } } } ) ; } private static void initComponents ( ClassLoader loader , XSharedPreferences pref ) throws Exception { AlertDialogWpp . initDialog ( loader ) ; FMessageWpp . init ( loader ) ; } private static void registerReceivers ( ) { BroadcastReceiver restartReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( context . getPackageName ( ) . equals ( intent . getStringExtra ( "<STR_LIT>" ) ) ) { var appName = context . getPackageManager ( ) . getApplicationLabel ( context . getApplicationInfo ( ) ) ; Toast . makeText ( context , context . getString ( ResId . string . rebooting ) + "<STR_LIT>" + appName + "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; if ( ! Utils . doRestart ( context ) ) Toast . makeText ( context , "<STR_LIT>" + appName , Toast . LENGTH_SHORT ) . show ( ) ; } } } ; ContextCompat . registerReceiver ( mApp , restartReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver wppReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { sendEnabledBroadcast ( context ) ; } } ; ContextCompat . registerReceiver ( mApp , wppReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver restartManualReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; } } ; ContextCompat . registerReceiver ( mApp , restartManualReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) , ContextCompat . RECEIVER_EXPORTED ) ; } private static void sendEnabledBroadcast ( Context context ) { try { Intent wppIntent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; wppIntent . putExtra ( "<STR_LIT>" , context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) . versionName ) ; wppIntent . putExtra ( "<STR_LIT>" , context . getPackageName ( ) ) ; wppIntent . setPackage ( BuildConfig . APPLICATION_ID ) ; context . sendBroadcast ( wppIntent ) ; } catch ( Exception ignored ) { } } private static void plugins ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , @ NonNull String versionWpp ) { var classes = new Class < ? > [ ] { DebugFeature . class , MenuStatus . class , ShowEditMessage . class , AntiRevoke . class , CustomToolbar . class , CustomView . class , SeenTick . class , BubbleColors . class , CallPrivacy . class , CustomTheme . class , ChatLimit . class , SeparateGroup . class , DotOnline . class , DndMode . class , FreezeLastSeen . class , GhostMode . class , HideChat . class , HideReceipt . class , HideSeen . class , HideTagForward . class , HideTabs . class , IGStatus . class , MediaQuality . class , NewChat . class , Others . class , PinnedLimit . class , CustomTime . class , ShareLimit . class , StatusDownload . class , ViewOnce . class , CallType . class , MediaPreview . class , FilterGroups . class , Tasker . class , DeleteStatus . class , DownloadViewOnce . class , Channels . class , DownloadProfile . class , ChatFilters . class , GroupAdmin . class , Stickers . class , CopyStatus . class , TextStatusComposer . class , ToastViewer . class } ; for ( var classe : classes ) { try { var constructor = classe . getConstructor ( ClassLoader . class , XSharedPreferences . class ) ; var plugin = ( Feature ) constructor . newInstance ( loader , pref ) ; plugin . doHook ( ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( classe . getSimpleName ( ) ) ; error . setWhatsAppVersion ( versionWpp ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + "<STR_LIT>" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) && ! s . getClassName ( ) . startsWith ( "<STR_LIT>" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } private static class ErrorItem { private String pluginName ; private String whatsAppVersion ; private String error ; private String moduleVersion ; @ NonNull @ Override public String toString ( ) { return "<STR_LIT>" + getPluginName ( ) + '<STR_LIT>' + "<STR_LIT>" + getModuleVersion ( ) + '<STR_LIT>' + "<STR_LIT>" + getWhatsAppVersion ( ) + '<STR_LIT>' + "<STR_LIT>" + getError ( ) + '<STR_LIT>' ; } public String getWhatsAppVersion ( ) { return whatsAppVersion ; } public void setWhatsAppVersion ( String whatsAppVersion ) { this . whatsAppVersion = whatsAppVersion ; } public String getError ( ) { return error ; } public void setError ( String error ) { this . error = error ; } public String getPluginName ( ) { return pluginName ; } public void setPluginName ( String pluginName ) { this . pluginName = pluginName ; } public String getModuleVersion ( ) { return moduleVersion ; } public void setModuleVersion ( String moduleVersion ) { this . moduleVersion = moduleVersion ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . core . devkit ; import android . app . Application ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . content . res . Resources ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import java . util . stream . Collectors ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class UnobfuscatorCache { private final Application mApp ; private static UnobfuscatorCache mInstance ; private final SharedPreferences mShared ; private final Map < String , String > reverseResourceMap = new HashMap < > ( ) ; public UnobfuscatorCache ( Application app , XSharedPreferences shared ) { mApp = app ; try { mShared = mApp . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; long version = mShared . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; long currentVersion = mApp . getPackageManager ( ) . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) . getLongVersionCode ( ) ; long savedUpdateTime = mShared . getLong ( "<STR_LIT>" , <NUM_LIT> ) ; long lastUpdateTime = shared . getLong ( "<STR_LIT>" , - <NUM_LIT> ) ; if ( version != currentVersion || savedUpdateTime != lastUpdateTime ) { mShared . edit ( ) . clear ( ) . commit ( ) ; mShared . edit ( ) . putLong ( "<STR_LIT>" , currentVersion ) . commit ( ) ; mShared . edit ( ) . putLong ( "<STR_LIT>" , lastUpdateTime ) . commit ( ) ; } initCacheStrings ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "<STR_LIT>" + e . getMessage ( ) , e ) ; } } private void initCacheStrings ( ) { getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; getOfuscateIDString ( "<STR_LIT>" ) ; } public static UnobfuscatorCache getInstance ( ) { return mInstance ; } public static void init ( Application mApp , XSharedPreferences pref ) { mInstance = new UnobfuscatorCache ( mApp , pref ) ; } private void initializeReverseResourceMap ( ) { int numThreads = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ) ; try { var configuration = new Configuration ( mApp . getResources ( ) . getConfiguration ( ) ) ; configuration . setLocale ( Locale . ENGLISH ) ; var context = Utils . getApplication ( ) . createConfigurationContext ( configuration ) ; Resources resources = context . getResources ( ) ; int startId = <NUM_LIT> ; int endId = <NUM_LIT> ; int chunkSize = ( endId - startId + <NUM_LIT> ) / numThreads ; CountDownLatch latch = new CountDownLatch ( numThreads ) ; for ( int t = <NUM_LIT> ; t < numThreads ; t ++ ) { int threadStartId = startId + t * chunkSize ; int threadEndId = t == numThreads - <NUM_LIT> ? endId : threadStartId + chunkSize - <NUM_LIT> ; executor . submit ( ( ) -> { try { for ( int i = threadStartId ; i <= threadEndId ; i ++ ) { try { String resourceString = resources . getString ( i ) ; reverseResourceMap . put ( resourceString . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) , String . valueOf ( i ) ) ; } catch ( Resources . NotFoundException ignored ) { } } } finally { latch . countDown ( ) ; } } ) ; } latch . await ( ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { executor . shutdown ( ) ; } } private String getMapIdString ( String search ) { if ( reverseResourceMap . isEmpty ( ) ) { initializeReverseResourceMap ( ) ; } search = search . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; return reverseResourceMap . get ( search ) ; } public int getOfuscateIDString ( String search ) { search = search . toLowerCase ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; var id = mShared . getString ( search , null ) ; if ( id == null ) { id = getMapIdString ( search ) ; if ( id != null ) { mShared . edit ( ) . putString ( search , id ) . commit ( ) ; } } return id == null ? - <NUM_LIT> : Integer . parseInt ( id ) ; } public String getString ( String search ) { var id = getOfuscateIDString ( search ) ; return id == - <NUM_LIT> ? "<STR_LIT>" : mApp . getResources ( ) . getString ( id ) ; } public Field getField ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Field result = ( Field ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveField ( methodName , result ) ; return result ; } String [ ] ClassAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( ClassAndName [ <NUM_LIT> ] , loader ) ; return XposedHelpers . findField ( cls , ClassAndName [ <NUM_LIT> ] ) ; } public Method getMethod ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Method result = ( Method ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveMethod ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( "<STR_LIT>" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] , paramTypes ) ; } return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] ) ; } public Class < ? > getClass ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Class < ? > result = ( Class < ? > ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveClass ( methodName , result ) ; return result ; } return XposedHelpers . findClass ( value , loader ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveField ( String key , Field field ) { String value = field . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + field . getName ( ) ; mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveMethod ( String key , Method method ) { String value = method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + method . getName ( ) ; if ( method . getParameterTypes ( ) . length > <NUM_LIT> ) { value += "<STR_LIT>" + Arrays . stream ( method . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( "<STR_LIT>" ) public void saveClass ( String message , Class < ? > messageClass ) { mShared . edit ( ) . putString ( message , messageClass . getName ( ) ) . commit ( ) ; } private String getKeyName ( ) { AtomicReference < String > keyName = new AtomicReference < > ( "<STR_LIT>" ) ; Arrays . stream ( Thread . currentThread ( ) . getStackTrace ( ) ) . filter ( stackTraceElement -> stackTraceElement . getClassName ( ) . equals ( Unobfuscator . class . getName ( ) ) ) . findFirst ( ) . ifPresent ( stackTraceElement -> keyName . set ( stackTraceElement . getMethodName ( ) ) ) ; return keyName . get ( ) ; } public Constructor getConstructor ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { var result = ( Constructor ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; saveConstructor ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( "<STR_LIT>" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( "<STR_LIT>" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findConstructorExact ( cls , paramTypes ) ; } return XposedHelpers . findConstructorExact ( cls ) ; } @ SuppressWarnings ( "<STR_LIT>" ) private void saveConstructor ( String key , Constructor constructor ) { String value = constructor . getDeclaringClass ( ) . getName ( ) ; if ( constructor . getParameterTypes ( ) . length > <NUM_LIT> ) { value += "<STR_LIT>" + Arrays . stream ( constructor . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } public interface FunctionCall { Object call ( ) throws Exception ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class FreezeLastSeen extends Feature { public FreezeLastSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) && ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! WppCore . getPrivBoolean ( "<STR_LIT>" , false ) && prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var method = Unobfuscator . loadFreezeSeenMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . downgrade ; import static de . robv . android . xposed . XposedBridge . hookAllMethods ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . os . Build ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . lang . reflect . Field ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class Patch { public static void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam , XSharedPreferences prefs ) throws Throwable { if ( ! ( "<STR_LIT>" . equals ( lpparam . packageName ) ) || ! ( lpparam . processName . equals ( "<STR_LIT>" ) ) ) return ; XC_MethodHook hookDowngrade = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( null ) ; } } ; XC_MethodHook hookDowngrade2 = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , "<STR_LIT>" ) ; if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( true ) ; } } ; switch ( Build . VERSION . SDK_INT ) { case Build . VERSION_CODES . UPSIDE_DOWN_CAKE : findAndHookMethod ( "<STR_LIT>" , lpparam . classLoader , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , hookDowngrade ) ; break ; case Build . VERSION_CODES . TIRAMISU : var checkDowngrade = XposedHelpers . findMethodExactIfExists ( "<STR_LIT>" , lpparam . classLoader , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( checkDowngrade != null ) { XposedBridge . hookMethod ( checkDowngrade , hookDowngrade ) ; } break ; case Build . VERSION_CODES . S_V2 : case Build . VERSION_CODES . S : case Build . VERSION_CODES . R : var pmService = XposedHelpers . findClassIfExists ( "<STR_LIT>" , lpparam . classLoader ) ; if ( pmService != null ) { var checkDowngrade1 = XposedHelpers . findMethodExactIfExists ( pmService , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( checkDowngrade1 != null ) { XposedBridge . hookMethod ( checkDowngrade1 , hookDowngrade ) ; } var flymeCheckDowngrade = XposedHelpers . findMethodExactIfExists ( pmService , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( flymeCheckDowngrade != null ) XposedBridge . hookMethod ( flymeCheckDowngrade , hookDowngrade2 ) ; } break ; case Build . VERSION_CODES . Q : case Build . VERSION_CODES . P : Class < ? > packageClazz = XposedHelpers . findClass ( "<STR_LIT>" , lpparam . classLoader ) ; hookAllMethods ( XposedHelpers . findClass ( "<STR_LIT>" , lpparam . classLoader ) , "<STR_LIT>" , new XC_MethodHook ( ) { public void beforeHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object packageInfoLite = methodHookParam . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( packageInfoLite , "<STR_LIT>" ) ; if ( packageName == FeatureLoader . PACKAGE_WPP || packageName == FeatureLoader . PACKAGE_BUSINESS ) { Field field = packageClazz . getField ( "<STR_LIT>" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; field = packageClazz . getField ( "<STR_LIT>" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; } } } ) ; break ; default : XposedBridge . log ( "<STR_LIT>" + Build . VERSION . SDK_INT ) ; break ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; public class ResId { public static class drawable { public static int eye_disabled ; public static int eye_enabled ; public static int admin ; public static int preview_eye ; public static int ic_reload ; public static int refresh ; } public static class string { public static int edited_history ; public static int dnd_message ; public static int dnd_mode_title ; public static int freezelastseen_message ; public static int freezelastseen_title ; public static int activate ; public static int cancel ; public static int message_original ; public static int new_chat ; public static int number_with_country_code ; public static int message ; public static int download ; public static int error_when_saving_try_again ; public static int msg_text_status_not_downloadable ; public static int saved_to ; public static int restart_whatsapp ; public static int restart_wpp ; public static int send_blue_tick ; public static int sending_read_blue_tick ; public static int send ; public static int send_sticker ; public static int do_you_want_to_send_sticker ; public static int whatsapp_call ; public static int phone_call ; public static int yes ; public static int no ; public static int version_error ; public static int copy_to_clipboard ; public static int copied_to_clipboard ; public static int error_detected ; public static int rebooting ; public static int deleted_status ; public static int deleted_message ; public static int toast_online ; public static int message_removed_on ; public static int loading ; public static int delete_for_me ; public static int share_as_status ; public static int viewed_your_status ; public static int viewed_your_message ; public static int select_status_type ; public static int open_camera ; public static int edit_text ; public static int select_a_color ; public static int read_all_mark_as_read ; public static int grant_permission ; public static int expiration ; public static int deleted_a_message_in_group ; } public static class array { public static int supported_versions_wpp ; public static int supported_versions_business ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CustomTime extends Feature { public CustomTime ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var secondsToTime = prefs . getBoolean ( "<STR_LIT>" , false ) ; var ampm = prefs . getBoolean ( "<STR_LIT>" , false ) ; var secondsToTimeMethod = Unobfuscator . loadTimeToSecondsMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( secondsToTimeMethod ) ) ; XposedBridge . hookMethod ( secondsToTimeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var timestamp = ( long ) param . args [ <NUM_LIT> ] ; var date = new Date ( timestamp ) ; var patternDefault = "<STR_LIT>" ; var patternSeconds = "<STR_LIT>" ; if ( ampm ) { patternDefault = "<STR_LIT>" ; patternSeconds = "<STR_LIT>" ; } var pattern = secondsToTime ? patternSeconds : patternDefault ; var formattedDate = new SimpleDateFormat ( pattern , Locale . US ) . format ( date ) ; param . setResult ( getTextInHour ( formattedDate ) ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private String getTextInHour ( String date ) { var summary = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( summary == null ) return date ; else return date + "<STR_LIT>" + summary ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Stickers extends Feature { public Stickers ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var sendStickerMethod = Unobfuscator . loadSendStickerMethod ( classLoader ) ; XposedBridge . hookMethod ( sendStickerMethod , new XC_MethodHook ( ) { private Unhook unhooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { unhooked = XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , View . OnClickListener . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { View . OnClickListener mCaptureOnClickListener = ( View . OnClickListener ) param . args [ <NUM_LIT> ] ; if ( mCaptureOnClickListener == null ) return ; if ( ! ( param . thisObject instanceof ViewGroup ) ) return ; var view = ( View ) param . thisObject ; if ( view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) == null ) return ; param . args [ <NUM_LIT> ] = ( View . OnClickListener ) v -> { var context = view . getContext ( ) ; var dialog = new AlertDialogWpp ( view . getContext ( ) ) ; dialog . setTitle ( context . getString ( ResId . string . send_sticker ) ) ; var stickerView = ( ImageView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var padding = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( padding , padding , padding , padding ) ; var image = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; var params = new LinearLayout . LayoutParams ( size , size ) ; params . bottomMargin = padding ; image . setLayoutParams ( params ) ; image . setImageDrawable ( stickerView . getDrawable ( ) ) ; linearLayout . addView ( image ) ; TextView text = new TextView ( context ) ; text . setText ( context . getString ( ResId . string . do_you_want_to_send_sticker ) ) ; text . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; linearLayout . addView ( text ) ; dialog . setView ( linearLayout ) ; dialog . setPositiveButton ( context . getString ( ResId . string . send ) , ( dialog1 , which ) -> mCaptureOnClickListener . onClick ( view ) ) ; dialog . setNegativeButton ( context . getString ( ResId . string . cancel ) , null ) ; dialog . show ( ) ; } ; } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { unhooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . text . TextUtils ; import android . util . AttributeSet ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . RequiresApi ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . TextEditorActivity ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . nio . charset . Charset ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; import java . util . ArrayList ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import kotlin . io . FilesKt ; public class ThemePreference extends Preference implements FilePicker . OnUriPickedListener { public static File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; private androidx . appcompat . app . AlertDialog mainDialog ; public ThemePreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; setPersistent ( false ) ; } @ Override protected void onClick ( ) { super . onClick ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { if ( Environment . isExternalStorageManager ( ) ) { showThemeDialog ( ) ; } else { showAlertPermission ( ) ; } } else { showThemeDialog ( ) ; } } @ RequiresApi ( api = Build . VERSION_CODES . R ) private void showAlertPermission ( ) { MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( getContext ( ) ) ; builder . setTitle ( R . string . storage_permission ) ; builder . setMessage ( R . string . permission_storage ) ; builder . setPositiveButton ( R . string . allow , ( dialog , which ) -> { Intent intent = new Intent ( android . provider . Settings . ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setData ( Uri . fromParts ( "<STR_LIT>" , getContext ( ) . getPackageName ( ) , null ) ) ; getContext ( ) . startActivity ( intent ) ; } ) ; builder . setNegativeButton ( R . string . deny , ( dialog , which ) -> dialog . dismiss ( ) ) ; builder . show ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void showThemeDialog ( ) { final Context context = getContext ( ) ; List < String > folders = getFolders ( ) ; folders . add ( <NUM_LIT> , "<STR_LIT>" ) ; var folder_name = getSharedPreferences ( ) . getString ( getKey ( ) , null ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( context ) ; View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . preference_theme , null ) ; builder . setView ( dialogView ) ; LinearLayout folderListContainer = dialogView . findViewById ( R . id . folder_list_container ) ; Button newTheme = dialogView . findViewById ( R . id . create_theme_button ) ; newTheme . setOnClickListener ( v -> showCreateNewThemeDialog ( ) ) ; Button importTheme = dialogView . findViewById ( R . id . import_theme_button ) ; importTheme . setOnClickListener ( v -> { FilePicker . setOnUriPickedListener ( this ) ; FilePicker . fileCapture . launch ( new String [ ] { "<STR_LIT>" } ) ; } ) ; for ( String folder : folders ) { View itemView = LayoutInflater . from ( context ) . inflate ( R . layout . item_folder , null , false ) ; TextView folderNameView = itemView . findViewById ( R . id . folder_name ) ; folderNameView . setText ( folder ) ; if ( folder . equals ( folder_name ) ) { folderNameView . setTextColor ( ContextCompat . getColor ( context , R . color . md_theme_material_green_dark_onPrimaryContainer ) ) ; } itemView . setOnClickListener ( v -> { var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; sharedPreferences . edit ( ) . putString ( getKey ( ) , folder ) . commit ( ) ; var cssFile = new File ( rootDirectory , folder + "<STR_LIT>" ) ; if ( cssFile . exists ( ) ) { var code = FilesKt . readText ( cssFile , Charset . defaultCharset ( ) ) ; sharedPreferences . edit ( ) . putString ( "<STR_LIT>" , code ) . commit ( ) ; } else { sharedPreferences . edit ( ) . putString ( "<STR_LIT>" , "<STR_LIT>" ) . commit ( ) ; } mainDialog . dismiss ( ) ; } ) ; ImageButton editButton = itemView . findViewById ( R . id . edit_button ) ; if ( folder . equals ( "<STR_LIT>" ) ) { editButton . setVisibility ( View . INVISIBLE ) ; } else { editButton . setOnClickListener ( v -> { Intent intent = new Intent ( context , TextEditorActivity . class ) ; intent . putExtra ( "<STR_LIT>" , folder ) ; intent . putExtra ( "<STR_LIT>" , getKey ( ) ) ; ContextCompat . startActivity ( context , intent , null ) ; } ) ; } folderListContainer . addView ( itemView ) ; } mainDialog = builder . show ( ) ; } private List < String > getFolders ( ) { List < String > folderNames = new ArrayList < > ( ) ; File [ ] folders = rootDirectory . listFiles ( File :: isDirectory ) ; if ( folders != null ) { for ( File folder : folders ) { folderNames . add ( folder . getName ( ) ) ; } } return folderNames ; } private void showCreateNewThemeDialog ( ) { final Context context = getContext ( ) ; final EditText input = new EditText ( context ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . new_theme_name ) . setView ( input ) . setPositiveButton ( R . string . create , ( dialog , whichButton ) -> { String folderName = input . getText ( ) . toString ( ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { createNewFolder ( folderName ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . show ( ) ; } private void createNewFolder ( String folderName ) { File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) { if ( newFolder . mkdirs ( ) ) { mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } } } @ Override public void onUriPicked ( Uri uri ) { if ( uri == null ) return ; try ( var inputStream = getContext ( ) . getContentResolver ( ) . openInputStream ( uri ) ) { var zipInputStream = new ZipInputStream ( inputStream ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { Utils . showToast ( getContext ( ) . getString ( R . string . invalid_zip_file ) , <NUM_LIT> ) ; return ; } do { var name = zipEntry . getName ( ) ; if ( ! name . contains ( "<STR_LIT>" ) ) { continue ; } var folderName = name . substring ( <NUM_LIT> , name . lastIndexOf ( '<STR_LIT>' ) ) ; File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , "<STR_LIT>" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) newFolder . mkdirs ( ) ; var file = new File ( rootDirectory , name ) ; Files . copy ( zipInputStream , file . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; zipEntry = zipInputStream . getNextEntry ( ) ; } while ( zipEntry != null ) ; Utils . showToast ( getContext ( ) . getString ( R . string . theme_imported_successfully ) , <NUM_LIT> ) ; mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . view . ViewGroup ; import android . widget . AbsListView ; import android . widget . ListView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . adapter . IGStatusAdapter ; import com . wmods . wppenhacer . views . IGStatusView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatus extends Feature { public static ArrayList < Object > itens = new ArrayList < > ( ) ; private static final ArrayList < IGStatusView > mListStatusContainer = new ArrayList < > ( ) ; public IGStatus ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) || Utils . getApplication ( ) . getPackageName ( ) . equals ( "<STR_LIT>" ) ) return ; var getViewConversationMethod = Unobfuscator . loadGetViewConversationMethod ( classLoader ) ; XposedBridge . hookMethod ( getViewConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) . isInstance ( param . thisObject ) ) return ; if ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) . isInstance ( param . thisObject ) ) return ; var view = ( ViewGroup ) param . getResult ( ) ; if ( view == null ) return ; var mainView = ( ListView ) view . findViewById ( android . R . id . list ) ; mainView . setNestedScrollingEnabled ( true ) ; var mStatusContainer = new IGStatusView ( WppCore . getCurrentActivity ( ) ) ; var layoutParams = new AbsListView . LayoutParams ( AbsListView . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; mStatusContainer . setLayoutParams ( layoutParams ) ; mainView . addHeaderView ( mStatusContainer ) ; mListStatusContainer . add ( mStatusContainer ) ; } } ) ; var clazz2 = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var onUpdateStatusChanged = Unobfuscator . loadOnUpdateStatusChanged ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onUpdateStatusChanged ) ) ; var statusInfoClass = Unobfuscator . loadStatusInfoClass ( classLoader ) ; logDebug ( statusInfoClass ) ; XposedBridge . hookAllConstructors ( clazz2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { itens . add ( <NUM_LIT> , null ) ; for ( var mStatusContainer : mListStatusContainer ) { IGStatusAdapter mStatusAdapter = new IGStatusAdapter ( WppCore . getCurrentActivity ( ) , statusInfoClass ) ; mStatusContainer . setAdapter ( mStatusAdapter ) ; mStatusContainer . updateList ( ) ; } } } ) ; var onStatusListUpdatesClass = Unobfuscator . loadStatusListUpdatesClass ( classLoader ) ; logDebug ( onStatusListUpdatesClass ) ; XposedBridge . hookAllConstructors ( onStatusListUpdatesClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list1 = ( List ) param . args [ <NUM_LIT> ] ; var list2 = ( List ) param . args [ <NUM_LIT> ] ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; var onGetInvokeField = Unobfuscator . loadGetInvokeField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( onGetInvokeField ) ) ; XposedBridge . hookMethod ( onUpdateStatusChanged , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var object = onGetInvokeField . get ( param . args [ <NUM_LIT> ] ) ; var method = ReflectionUtils . findMethodUsingFilter ( object . getClass ( ) , method1 -> method1 . getReturnType ( ) . equals ( Object . class ) ) ; var StatusListUpdates = ReflectionUtils . callMethod ( method , object ) ; if ( StatusListUpdates == null ) return ; var lists = ReflectionUtils . findAllFieldsUsingFilter ( StatusListUpdates . getClass ( ) , field -> field . getType ( ) . equals ( List . class ) ) ; if ( lists . length < <NUM_LIT> ) return ; var list1 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; var list2 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . utils . ColorReplacement . replaceColors ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . content . res . ColorStateList ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Canvas ; import android . graphics . LinearGradient ; import android . graphics . PorterDuff ; import android . graphics . Shader ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RectShape ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . provider . Settings ; import android . text . TextUtils ; import android . util . Log ; import android . util . LruCache ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . RelativeLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . utils . IColors ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . ExecutorService ; import cz . vutbr . web . css . CSSFactory ; import cz . vutbr . web . css . CombinedSelector ; import cz . vutbr . web . css . Declaration ; import cz . vutbr . web . css . RuleSet ; import cz . vutbr . web . css . StyleSheet ; import cz . vutbr . web . css . Term ; import cz . vutbr . web . css . TermColor ; import cz . vutbr . web . css . TermFloatValue ; import cz . vutbr . web . css . TermFunction ; import cz . vutbr . web . css . TermLength ; import cz . vutbr . web . css . TermNumeric ; import cz . vutbr . web . css . TermURI ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class CustomView extends Feature { private DrawableCache cacheImages ; private HashMap < String , Drawable > chacheDrawables ; private ExecutorService mThreadService ; private static File themeDir ; public CustomView ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var filter_itens = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var folder_theme = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var custom_css = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; checkPermissions ( ) ; if ( ( TextUtils . isEmpty ( filter_itens ) && TextUtils . isEmpty ( folder_theme ) && TextUtils . isEmpty ( custom_css ) ) || ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; hookDrawableViews ( ) ; themeDir = new File ( ThemePreference . rootDirectory , folder_theme ) ; filter_itens += "<STR_LIT>" + custom_css ; cacheImages = new DrawableCache ( Utils . getApplication ( ) , <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; chacheDrawables = new HashMap < > ( ) ; var sheet = CSSFactory . parseString ( filter_itens , new URL ( "<STR_LIT>" ) ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; View rootView = activity . getWindow ( ) . getDecorView ( ) . getRootView ( ) ; rootView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( ( ) -> CompletableFuture . runAsync ( ( ) -> registerCssRules ( activity , ( ViewGroup ) rootView , sheet ) ) ) ; } } ) ; } private void hookDrawableViews ( ) { XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . thisObject ; var newDrawable = ( Drawable ) param . args [ <NUM_LIT> ] ; var hookedBackground = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( Unobfuscator . isCalledFromClass ( CustomView . class ) ) { if ( hookedBackground == null || view . getBackground ( ) != newDrawable ) { XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , newDrawable ) ; return ; } } else if ( hookedBackground == null ) return ; param . setResult ( null ) ; } } ) ; XposedHelpers . findAndHookMethod ( ImageView . class , "<STR_LIT>" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( ImageView ) param . thisObject ; var newDrawable = ( Drawable ) param . args [ <NUM_LIT> ] ; var mHookedDrawable = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( Unobfuscator . isCalledFromClass ( CustomView . class ) ) { if ( mHookedDrawable == null || view . getDrawable ( ) != newDrawable ) { XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , newDrawable ) ; return ; } } else if ( mHookedDrawable == null ) return ; param . setResult ( null ) ; } } ) ; } private void checkPermissions ( ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_MEDIA_IMAGES ) != PackageManager . PERMISSION_GRANTED ) { activity . requestPermissions ( new String [ ] { Manifest . permission . READ_MEDIA_IMAGES } , <NUM_LIT> ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( Activity . class , "<STR_LIT>" , int . class , String [ ] . class , int [ ] . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; var activity = ( Activity ) param . thisObject ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var results = ( int [ ] ) param . args [ <NUM_LIT> ] ; if ( Arrays . stream ( results ) . anyMatch ( result -> result != PackageManager . PERMISSION_GRANTED ) ) { activity . startActivity ( new Intent ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS , Uri . fromParts ( "<STR_LIT>" , activity . getPackageName ( ) , null ) ) ) ; Utils . showToast ( activity . getString ( ResId . string . grant_permission ) , Toast . LENGTH_LONG ) ; } } } } ) ; } private void registerCssRules ( Activity activity , ViewGroup currenView , StyleSheet sheet ) { try { for ( var selector : sheet ) { var ruleSet = ( RuleSet ) selector ; for ( var selectorItem : ruleSet . getSelectors ( ) ) { var item = selectorItem . get ( <NUM_LIT> ) ; String className ; String name ; if ( ( className = item . getClassName ( ) ) != null ) { className = className . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) . trim ( ) ; var clazz = XposedHelpers . findClass ( className , classLoader ) ; if ( clazz == null || ! clazz . isInstance ( activity ) ) continue ; name = selectorItem . get ( <NUM_LIT> ) . getIDName ( ) . trim ( ) ; } else { name = selectorItem . get ( <NUM_LIT> ) . getIDName ( ) . trim ( ) ; } int id = <NUM_LIT> ; if ( name . contains ( "<STR_LIT>" ) ) { try { id = android . R . id . class . getField ( name . substring ( <NUM_LIT> ) ) . getInt ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException ignored ) { } } else { id = Utils . getID ( name , "<STR_LIT>" ) ; } if ( id <= <NUM_LIT> ) continue ; var view = currenView . findViewById ( id ) ; if ( view == null || ! view . isShown ( ) || view . getVisibility ( ) != View . VISIBLE || ! view . isAttachedToWindow ( ) ) continue ; var ruleItem = new RuleItem ( selectorItem , ruleSet ) ; setCssRule ( view , ruleItem ) ; } } } catch ( Throwable ignored ) { } } private void setCssRule ( View currentView , RuleItem ruleItem ) { var resultViews = new ArrayList < View > ( ) ; captureSelector ( currentView , ruleItem . selector , <NUM_LIT> , resultViews ) ; if ( ruleItem . rule . getSelectors ( ) . length == <NUM_LIT> || ruleItem . rule . isEmpty ( ) || resultViews . isEmpty ( ) ) return ; for ( var view : resultViews ) { if ( view == null || ! view . isAttachedToWindow ( ) ) continue ; CompletableFuture . runAsync ( ( ) -> view . post ( ( ) -> { try { setRuleInView ( ruleItem , view ) ; } catch ( Throwable e ) { log ( e ) ; } } ) , Utils . getExecutor ( ) ) ; } } private void setRuleInView ( RuleItem ruleItem , View view ) { for ( var declaration : ruleItem . rule ) { var property = declaration . getProperty ( ) ; switch ( property ) { case "<STR_LIT>" -> { if ( declaration . size ( ) != <NUM_LIT> ) continue ; var color = ( TermColor ) declaration . get ( <NUM_LIT> ) ; var colorNew = ( TermColor ) declaration . get ( <NUM_LIT> ) ; var colorValue = IColors . toString ( color . getValue ( ) . getRGB ( ) ) ; var colorNewValue = IColors . toString ( colorNew . getValue ( ) . getRGB ( ) ) ; HashMap < String , String > colors = new HashMap < > ( ) ; colors . put ( colorValue , colorNewValue ) ; replaceColors ( view , colors ) ; if ( view instanceof ImageView imageView ) { var drawable = imageView . getDrawable ( ) ; if ( drawable == null ) continue ; drawable . setTint ( colorNew . getValue ( ) . getRGB ( ) ) ; view . postInvalidate ( ) ; } } case "<STR_LIT>" -> { var value = declaration . get ( <NUM_LIT> ) . toString ( ) ; switch ( value ) { case "<STR_LIT>" -> view . setVisibility ( View . GONE ) ; case "<STR_LIT>" -> view . setVisibility ( View . VISIBLE ) ; case "<STR_LIT>" -> view . setVisibility ( View . INVISIBLE ) ; } } case "<STR_LIT>" -> { if ( ! ( view instanceof TextView textView ) ) continue ; var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; textView . setTextSize ( getRealValue ( value , <NUM_LIT> ) ) ; } case "<STR_LIT>" -> { if ( ! ( view instanceof TextView textView ) ) continue ; var value = ( TermColor ) declaration . get ( <NUM_LIT> ) ; textView . setTextColor ( value . getValue ( ) . getRGB ( ) ) ; } case "<STR_LIT>" -> { var value = ( TermFloatValue ) declaration . get ( <NUM_LIT> ) ; view . setAlpha ( value . getValue ( ) ) ; } case "<STR_LIT>" -> { if ( ! ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) ) continue ; var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; if ( XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) != null || XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) != null ) continue ; setHookedDrawable ( view , draw ) ; } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermLength width ) { var height = ( TermLength ) declaration . get ( <NUM_LIT> ) ; if ( view instanceof ImageView imageView ) { if ( width . isPercentage ( ) || height . isPercentage ( ) ) { if ( width . getValue ( ) . intValue ( ) == <NUM_LIT> || height . getValue ( ) . intValue ( ) == <NUM_LIT> ) { imageView . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; continue ; } } var drawable = imageView . getDrawable ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( getRealValue ( width , imageView . getWidth ( ) ) == ( int ) widthObj && getRealValue ( height , imageView . getHeight ( ) ) == ( int ) heightObj ) continue ; } Bitmap resizedBitmap = Bitmap . createScaledBitmap ( bitmap , getRealValue ( width , imageView . getWidth ( ) ) , getRealValue ( height , imageView . getHeight ( ) ) , false ) ; var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , resizedBitmap ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( height , imageView . getHeight ( ) ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( width , imageView . getWidth ( ) ) ) ; setHookedDrawable ( imageView , resizeDrawable ) ; } else { var drawable = view . getBackground ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( getRealValue ( width , view . getWidth ( ) ) == ( int ) widthObj && getRealValue ( height , view . getHeight ( ) ) == ( int ) heightObj ) continue ; } Bitmap resizedBitmap = Bitmap . createScaledBitmap ( bitmap , getRealValue ( width , <NUM_LIT> ) , getRealValue ( height , <NUM_LIT> ) , false ) ; var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , resizedBitmap ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( height , <NUM_LIT> ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , getRealValue ( width , <NUM_LIT> ) ) ; view . setBackground ( resizeDrawable ) ; } } else { var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; } else { var drawable = view . getBackground ( ) ; if ( ! ( drawable instanceof BitmapDrawable ) ) continue ; Bitmap bitmap = ( ( BitmapDrawable ) drawable ) . getBitmap ( ) ; var widthObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; var heightObj = XposedHelpers . getAdditionalInstanceField ( view , "<STR_LIT>" ) ; if ( widthObj != null && heightObj != null ) { if ( ( int ) widthObj == view . getWidth ( ) && ( int ) heightObj == view . getHeight ( ) ) continue ; } var resizeDrawable = new BitmapDrawable ( view . getContext ( ) . getResources ( ) , Bitmap . createScaledBitmap ( bitmap , view . getWidth ( ) , view . getHeight ( ) , true ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , view . getHeight ( ) ) ; XposedHelpers . setAdditionalInstanceField ( view , "<STR_LIT>" , view . getWidth ( ) ) ; view . setBackground ( resizeDrawable ) ; } } } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { view . setBackgroundColor ( color . getValue ( ) . getRGB ( ) ) ; continue ; } if ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) { var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; view . setBackground ( draw ) ; continue ; } var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { view . setBackground ( null ) ; } else { setBackgroundModel ( view , declaration . get ( <NUM_LIT> ) ) ; } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { view . setBackground ( new ColorDrawable ( color . getValue ( ) . getRGB ( ) ) ) ; continue ; } if ( declaration . get ( <NUM_LIT> ) instanceof TermURI uri ) { var draw = cacheImages . getDrawable ( uri . getValue ( ) , view . getWidth ( ) , view . getHeight ( ) ) ; if ( draw == null ) continue ; view . setForeground ( draw ) ; continue ; } var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { view . setForeground ( null ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; view . getLayoutParams ( ) . width = getRealValue ( value , <NUM_LIT> ) ; view . requestLayout ( ) ; } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; view . getLayoutParams ( ) . height = getRealValue ( value , <NUM_LIT> ) ; } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_LEFT , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . leftMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_RIGHT , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . rightMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_TOP , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . topMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var value = ( TermLength ) declaration . get ( <NUM_LIT> ) ; var layoutParams = view . getLayoutParams ( ) ; if ( layoutParams instanceof RelativeLayout . LayoutParams rParams ) { rParams . addRule ( RelativeLayout . ALIGN_BOTTOM , getRealValue ( value , <NUM_LIT> ) ) ; } else if ( layoutParams instanceof ViewGroup . MarginLayoutParams fParams ) { fParams . bottomMargin = getRealValue ( value , <NUM_LIT> ) ; } } case "<STR_LIT>" -> { var mode = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( mode . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . clearColorFilter ( ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . clearColorFilter ( ) ; } } } else { if ( ! ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) ) continue ; try { var pMode = PorterDuff . Mode . valueOf ( mode ) ; if ( view instanceof ImageView imageView ) { imageView . setColorFilter ( color . getValue ( ) . getRGB ( ) , pMode ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . setColorFilter ( color . getValue ( ) . getRGB ( ) , pMode ) ; } } } catch ( IllegalArgumentException ignored ) { } } } case "<STR_LIT>" -> { if ( declaration . get ( <NUM_LIT> ) instanceof TermColor color ) { if ( view instanceof ImageView imageView ) { ColorStateList colorStateList = declaration . size ( ) == <NUM_LIT> ? ColorStateList . valueOf ( color . getValue ( ) . getRGB ( ) ) : getColorStateList ( declaration ) ; imageView . setImageTintList ( colorStateList ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { ColorStateList colorStateList = declaration . size ( ) == <NUM_LIT> ? ColorStateList . valueOf ( color . getValue ( ) . getRGB ( ) ) : getColorStateList ( declaration ) ; drawable . setTintList ( colorStateList ) ; } } } else { var value = declaration . get ( <NUM_LIT> ) . toString ( ) . trim ( ) ; if ( value . equals ( "<STR_LIT>" ) ) { if ( view instanceof ImageView imageView ) { imageView . setImageTintList ( null ) ; } else { var drawable = view . getBackground ( ) ; if ( drawable != null ) { drawable . setTintList ( null ) ; } } } } } } } } private void setHookedDrawable ( View view , Drawable draw ) { if ( view instanceof ImageView imageView ) { imageView . setImageDrawable ( draw ) ; } else { view . setBackground ( draw ) ; } } private void setBackgroundModel ( View view , Term < ? > value ) { if ( value instanceof TermFunction . LinearGradient gradient ) { try { var gradientDrawable = chacheDrawables . get ( value . toString ( ) ) ; if ( gradientDrawable == null ) { gradientDrawable = GradientDrawableParser . parseGradient ( gradient , view . getWidth ( ) , view . getHeight ( ) ) ; chacheDrawables . put ( value . toString ( ) , gradientDrawable ) ; } view . setBackground ( gradientDrawable ) ; } catch ( Exception e ) { log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } } @ NonNull private static ColorStateList getColorStateList ( Declaration declaration ) { var defaultFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; var pressedFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; var disabledFontColor = ( ( TermColor ) declaration . get ( <NUM_LIT> ) ) . getValue ( ) . getRGB ( ) ; return new ColorStateList ( new int [ ] [ ] { new int [ ] { android . R . attr . state_pressed } , new int [ ] { android . R . attr . state_enabled } , new int [ ] { android . R . attr . state_focused , android . R . attr . state_pressed } , new int [ ] { - android . R . attr . state_enabled } , new int [ ] { } } , new int [ ] { pressedFontColor , defaultFontColor , pressedFontColor , disabledFontColor , defaultFontColor } ) ; } private int getRealValue ( TermLength value , int size ) { if ( value . getUnit ( ) == TermNumeric . Unit . px ) { return Utils . dipToPixels ( value . getValue ( ) . intValue ( ) ) ; } else if ( value . isPercentage ( ) ) { return size * value . getValue ( ) . intValue ( ) / <NUM_LIT> ; } return value . getValue ( ) . intValue ( ) ; } private void captureSelector ( View currentView , CombinedSelector selector , int position , ArrayList < View > resultViews ) { if ( selector . size ( ) == position ) return ; var selectorItem = selector . get ( position ) ; if ( selectorItem . getClassName ( ) != null ) { captureSelector ( currentView , selector , position + <NUM_LIT> , resultViews ) ; } else if ( selectorItem . getIDName ( ) != null ) { var name = selectorItem . getIDName ( ) . trim ( ) ; int id = <NUM_LIT> ; if ( name . contains ( "<STR_LIT>" ) ) { try { id = android . R . id . class . getField ( name . substring ( <NUM_LIT> ) ) . getInt ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException ignored ) { } } else { id = Utils . getID ( name , "<STR_LIT>" ) ; } if ( id <= <NUM_LIT> ) return ; View view = currentView . getId ( ) == id ? currentView : currentView . findViewById ( id ) ; if ( view == null ) return ; if ( selector . size ( ) == position + <NUM_LIT> ) { resultViews . add ( view ) ; } else { captureSelector ( view , selector , position + <NUM_LIT> , resultViews ) ; } } else { if ( ! ( currentView instanceof ViewGroup viewGroup ) ) return ; var name = Arrays . stream ( selectorItem . toString ( ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . toArray ( String [ ] :: new ) ; var itemCount = new int [ ] { <NUM_LIT> } ; for ( int i = <NUM_LIT> ; i < viewGroup . getChildCount ( ) ; i ++ ) { var itemView = viewGroup . getChildAt ( i ) ; if ( ReflectionUtils . isClassSimpleNameString ( itemView . getClass ( ) , name [ <NUM_LIT> ] ) ) { if ( name . length > <NUM_LIT> ) if ( checkAttribute ( itemView , itemCount , name [ <NUM_LIT> ] ) ) continue ; if ( selector . size ( ) == position + <NUM_LIT> ) { resultViews . add ( itemView ) ; } else { captureSelector ( itemView , selector , position + <NUM_LIT> , resultViews ) ; } } else if ( isWidgetString ( name [ <NUM_LIT> ] ) && itemView instanceof ViewGroup viewGroup1 ) { for ( int j = <NUM_LIT> ; j < viewGroup1 . getChildCount ( ) ; j ++ ) { var childView = viewGroup1 . getChildAt ( j ) ; captureSelector ( childView , selector , position , resultViews ) ; } } } } } private boolean checkAttribute ( View itemView , int [ ] itemCount , String name ) { if ( name . startsWith ( "<STR_LIT>" ) ) { var startIndex = name . indexOf ( "<STR_LIT>" ) + <NUM_LIT> ; var endIndex = name . indexOf ( "<STR_LIT>" ) ; var index = Integer . parseInt ( name . substring ( startIndex , endIndex ) ) - <NUM_LIT> ; return index != itemCount [ <NUM_LIT> ] ++ ; } else if ( name . startsWith ( "<STR_LIT>" ) ) { var startIndex = name . indexOf ( "<STR_LIT>" ) + <NUM_LIT> ; var endIndex = name . indexOf ( "<STR_LIT>" ) ; var contains = name . substring ( startIndex , endIndex ) ; if ( itemView instanceof TextView textView ) { return ! textView . getText ( ) . toString ( ) . contains ( contains ) ; } else { return ! itemView . toString ( ) . contains ( contains ) ; } } return false ; } private boolean isWidgetString ( String view ) { return XposedHelpers . findClassIfExists ( "<STR_LIT>" + view , null ) != null ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public class DrawableCache { private final LruCache < String , CachedDrawable > drawableCache ; private final Context context ; public DrawableCache ( Context context , int maxSize ) { this . context = context . getApplicationContext ( ) ; drawableCache = new LruCache < > ( maxSize ) ; } private Drawable loadDrawableFromFile ( String filePath , int reqWidth , int reqHeight ) { File file = new File ( filePath ) ; var bitmap = BitmapFactory . decodeFile ( file . getAbsolutePath ( ) ) ; var newHeight = reqHeight < <NUM_LIT> ? bitmap . getHeight ( ) : Math . min ( bitmap . getHeight ( ) , reqHeight ) ; var newWidth = reqWidth < <NUM_LIT> ? bitmap . getWidth ( ) : Math . min ( bitmap . getWidth ( ) , reqWidth ) ; bitmap = Bitmap . createScaledBitmap ( bitmap , newWidth , newHeight , true ) ; return new BitmapDrawable ( context . getResources ( ) , bitmap ) ; } @ Nullable public Drawable getDrawable ( String filePath , int width , int height ) { File file = filePath . startsWith ( "<STR_LIT>" ) ? new File ( filePath ) : new File ( themeDir , filePath ) ; if ( ! file . exists ( ) || ! file . canRead ( ) ) { return null ; } String key = file . getAbsolutePath ( ) ; long lastModified = file . lastModified ( ) ; CachedDrawable cachedDrawable = drawableCache . get ( key ) ; if ( cachedDrawable != null && cachedDrawable . lastModified == lastModified ) { return cachedDrawable . drawable ; } Drawable cachedDrawableFromFile = loadDrawableFromCache ( key , lastModified ) ; if ( cachedDrawableFromFile != null ) { cachedDrawable = new CachedDrawable ( cachedDrawableFromFile , lastModified ) ; drawableCache . put ( key , cachedDrawable ) ; return cachedDrawableFromFile ; } Drawable drawable = loadDrawableFromFile ( key , width , height ) ; saveDrawableToCache ( key , ( BitmapDrawable ) drawable , lastModified ) ; cachedDrawable = new CachedDrawable ( drawable , lastModified ) ; drawableCache . put ( key , cachedDrawable ) ; return drawable ; } private void saveDrawableToCache ( String key , BitmapDrawable drawable , long lastModified ) { File cacheDir = context . getCacheDir ( ) ; File cacheLocation = new File ( cacheDir , "<STR_LIT>" ) ; if ( ! cacheLocation . exists ( ) ) { cacheLocation . mkdirs ( ) ; } File cacheFile = new File ( cacheLocation , getCacheFileName ( key ) ) ; File metadataFile = new File ( cacheLocation , getCacheFileName ( key ) + "<STR_LIT>" ) ; try ( OutputStream out = new FileOutputStream ( cacheFile ) ; ObjectOutputStream metaOut = new ObjectOutputStream ( new FileOutputStream ( metadataFile ) ) ) { drawable . getBitmap ( ) . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , out ) ; metaOut . writeLong ( lastModified ) ; Log . d ( "<STR_LIT>" , "<STR_LIT>" + cacheFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" , e ) ; } } private Drawable loadDrawableFromCache ( String key , long originalLastModified ) { File cacheDir = context . getCacheDir ( ) ; File cacheLocation = new File ( cacheDir , "<STR_LIT>" ) ; File cacheFile = new File ( cacheLocation , getCacheFileName ( key ) ) ; File metadataFile = new File ( cacheLocation , getCacheFileName ( key ) + "<STR_LIT>" ) ; if ( ! cacheFile . exists ( ) || ! metadataFile . exists ( ) ) { log ( "<STR_LIT>" + cacheFile . getAbsolutePath ( ) ) ; return null ; } try ( ObjectInputStream metaIn = new ObjectInputStream ( new FileInputStream ( metadataFile ) ) ) { long cachedLastModified = metaIn . readLong ( ) ; if ( cachedLastModified != originalLastModified ) { return null ; } Bitmap bitmap = BitmapFactory . decodeFile ( cacheFile . getAbsolutePath ( ) ) ; if ( bitmap != null ) { return new BitmapDrawable ( context . getResources ( ) , bitmap ) ; } } catch ( IOException e ) { Log . e ( "<STR_LIT>" , "<STR_LIT>" , e ) ; } return null ; } private String getCacheFileName ( String input ) { return String . valueOf ( Objects . hash ( input ) ) ; } private static class CachedDrawable { Drawable drawable ; long lastModified ; CachedDrawable ( Drawable drawable , long lastModified ) { this . drawable = drawable ; this . lastModified = lastModified ; } } } public static class RuleItem { public CombinedSelector selector ; public RuleSet rule ; public RuleItem ( CombinedSelector selectorItem , RuleSet ruleSet ) { this . selector = selectorItem ; this . rule = ruleSet ; } } public static class GradientDrawableParser { public static BitmapDrawable parseGradient ( TermFunction . LinearGradient cssGradient , int width , int height ) { int [ ] colors = new int [ cssGradient . getColorStops ( ) . size ( ) ] ; float [ ] positions = new float [ cssGradient . getColorStops ( ) . size ( ) ] ; float angle = cssGradient . getAngle ( ) . getValue ( ) ; for ( int i = cssGradient . getColorStops ( ) . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { colors [ i ] = cssGradient . getColorStops ( ) . get ( i ) . getColor ( ) . getValue ( ) . getRGB ( ) ; positions [ i ] = cssGradient . getColorStops ( ) . get ( i ) . getLength ( ) . getValue ( ) / <NUM_LIT> ; } LinearGradient linearGradient = createLinearGradient ( angle , colors , positions , width , height ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new RectShape ( ) ) ; shapeDrawable . setIntrinsicWidth ( width ) ; shapeDrawable . setIntrinsicHeight ( height ) ; shapeDrawable . getPaint ( ) . setShader ( linearGradient ) ; Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; shapeDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , width , height ) ; shapeDrawable . draw ( new Canvas ( bitmap ) ) ; return new BitmapDrawable ( Utils . getApplication ( ) . getResources ( ) , bitmap ) ; } private static LinearGradient createLinearGradient ( float angle , int [ ] colors , float [ ] positions , int width , int height ) { float x0 , y0 , x1 , y1 ; double radians = Math . toRadians ( angle ) ; x0 = ( float ) ( <NUM_LIT> * width + <NUM_LIT> * width * Math . cos ( radians - Math . PI / <NUM_LIT> ) ) ; y0 = ( float ) ( <NUM_LIT> * height + <NUM_LIT> * height * Math . sin ( radians - Math . PI / <NUM_LIT> ) ) ; x1 = ( float ) ( <NUM_LIT> * width + <NUM_LIT> * width * Math . cos ( radians + Math . PI / <NUM_LIT> ) ) ; y1 = ( float ) ( <NUM_LIT> * height + <NUM_LIT> * height * Math . sin ( radians + Math . PI / <NUM_LIT> ) ) ; return new LinearGradient ( x0 , y0 , x1 , y1 , colors , positions , Shader . TileMode . CLAMP ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . res . Resources ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . text . TextUtils ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . DelMessageStore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . text . DateFormat ; import java . util . Arrays ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiRevoke extends Feature { private static final HashMap < String , HashSet < String > > messageRevokedMap = new HashMap < > ( ) ; public AntiRevoke ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var antiRevokeMessageMethod = Unobfuscator . loadAntiRevokeMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( antiRevokeMessageMethod ) ) ; var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var unknownStatusPlaybackMethod = Unobfuscator . loadUnknownStatusPlaybackMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( unknownStatusPlaybackMethod ) ) ; var statusPlaybackField = Unobfuscator . loadStatusPlaybackViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( statusPlaybackField ) ) ; XposedBridge . hookMethod ( antiRevokeMessageMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Exception { var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; var messageKey = fMessage . getKey ( ) ; var deviceJid = fMessage . getDeviceJid ( ) ; var id = fMessage . getRowId ( ) ; var messageID = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; if ( WppCore . getPrivBoolean ( messageID + "<STR_LIT>" , false ) ) { WppCore . removePrivKey ( messageID + "<STR_LIT>" ) ; var activity = WppCore . getCurrentActivity ( ) ; Class < ? > StatusPlaybackActivityClass = classLoader . loadClass ( "<STR_LIT>" ) ; if ( activity != null && StatusPlaybackActivityClass . isInstance ( activity ) ) { activity . finish ( ) ; } return ; } var rawString = WppCore . getRawString ( messageKey . remoteJid ) ; if ( WppCore . isGroup ( rawString ) ) { if ( deviceJid != null && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } else if ( ! messageKey . isFromMe && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var dateTextView = ( TextView ) param . args [ <NUM_LIT> ] ; isMRevoked ( objMessage , dateTextView , "<STR_LIT>" ) ; } } ) ; XposedBridge . hookMethod ( unknownStatusPlaybackMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var obj = param . args [ <NUM_LIT> ] ; var objMessage = param . args [ <NUM_LIT> ] ; Object objView = statusPlaybackField . get ( obj ) ; Field [ ] textViews = Arrays . stream ( statusPlaybackField . getType ( ) . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) == TextView . class ) . toArray ( Field [ ] :: new ) ; if ( textViews == null ) { log ( "<STR_LIT>" ) ; return ; } int dateId = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; for ( Field textView : textViews ) { TextView textView1 = ( TextView ) XposedHelpers . getObjectField ( objView , textView . getName ( ) ) ; if ( textView1 == null || textView1 . getId ( ) == dateId ) { isMRevoked ( objMessage , textView1 , "<STR_LIT>" ) ; break ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static Drawable scaleImage ( Resources resources , Drawable image , float scaleFactor ) { if ( ! ( image instanceof BitmapDrawable ) ) { return image ; } Bitmap b = ( ( BitmapDrawable ) image ) . getBitmap ( ) ; int sizeX = Math . round ( image . getIntrinsicWidth ( ) * scaleFactor ) ; int sizeY = Math . round ( image . getIntrinsicHeight ( ) * scaleFactor ) ; Bitmap bitmapResized = Bitmap . createScaledBitmap ( b , sizeX , sizeY , false ) ; return new BitmapDrawable ( resources , bitmapResized ) ; } private static void saveRevokedMessage ( FMessageWpp fMessage ) { var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; HashSet < String > messages = getRevokedMessages ( fMessage ) ; messages . add ( messageKey ) ; DelMessageStore . getInstance ( Utils . getApplication ( ) ) . insertMessage ( stripJID , messageKey , System . currentTimeMillis ( ) ) ; } private static HashSet < String > getRevokedMessages ( FMessageWpp fMessage ) { String jid = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; if ( messageRevokedMap . containsKey ( jid ) ) { return messageRevokedMap . get ( jid ) ; } var messages = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getMessagesByJid ( jid ) ; if ( messages == null ) messages = new HashSet < > ( ) ; messageRevokedMap . put ( jid , messages ) ; return messages ; } private void isMRevoked ( Object objMessage , TextView dateTextView , String antirevokeType ) { if ( dateTextView == null ) return ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; var messageRevokedList = getRevokedMessages ( fMessage ) ; var id = fMessage . getRowId ( ) ; String keyOrig = null ; if ( messageRevokedList . contains ( key . messageID ) || ( ( keyOrig = MessageStore . getInstance ( ) . getOriginalMessageKey ( id ) ) != null && messageRevokedList . contains ( keyOrig ) ) ) { var timestamp = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getTimestampByMessageId ( keyOrig == null ? key . messageID : keyOrig ) ; if ( timestamp > <NUM_LIT> ) { Locale locale = Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . getLocales ( ) . get ( <NUM_LIT> ) ; DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , locale ) ; var date = dateFormat . format ( new Date ( timestamp ) ) ; dateTextView . getPaint ( ) . setUnderlineText ( true ) ; dateTextView . setOnClickListener ( v -> Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . message_removed_on ) , date ) , Toast . LENGTH_LONG ) ) ; } var antirevokeValue = Integer . parseInt ( prefs . getString ( antirevokeType , "<STR_LIT>" ) ) ; if ( antirevokeValue == <NUM_LIT> ) { var newTextData = UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) + "<STR_LIT>" + dateTextView . getText ( ) ; dateTextView . setText ( newTextData ) ; } else if ( antirevokeValue == <NUM_LIT> ) { var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; var drawable = scaleImage ( Utils . getApplication ( ) . getResources ( ) , icon , <NUM_LIT> ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( Color . RED , PorterDuff . Mode . SRC_ATOP ) ) ; dateTextView . setCompoundDrawablesWithIntrinsicBounds ( null , null , drawable , null ) ; dateTextView . setCompoundDrawablePadding ( <NUM_LIT> ) ; } } else { dateTextView . setCompoundDrawables ( null , null , null , null ) ; var revokeNotice = UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) + "<STR_LIT>" ; var dateText = dateTextView . getText ( ) . toString ( ) ; if ( dateText . contains ( revokeNotice ) ) { dateTextView . setText ( dateText . replace ( revokeNotice , "<STR_LIT>" ) ) ; } dateTextView . getPaint ( ) . setUnderlineText ( false ) ; dateTextView . setOnClickListener ( null ) ; } } private int antiRevoke ( FMessageWpp fMessage ) { showToast ( fMessage ) ; var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; var revokeboolean = stripJID . equals ( "<STR_LIT>" ) ? Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) : Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( revokeboolean == <NUM_LIT> ) return revokeboolean ; var messageRevokedList = getRevokedMessages ( fMessage ) ; if ( ! messageRevokedList . contains ( messageKey ) ) { try { AsyncTask . THREAD_POOL_EXECUTOR . execute ( ( ) -> { saveRevokedMessage ( fMessage ) ; try { var mConversation = WppCore . getCurrentConversation ( ) ; if ( mConversation != null && WppCore . stripJID ( WppCore . getCurrentRawJID ( ) ) . equals ( stripJID ) ) { mConversation . runOnUiThread ( ( ) -> { if ( mConversation . hasWindowFocus ( ) ) { mConversation . startActivity ( mConversation . getIntent ( ) ) ; mConversation . overridePendingTransition ( <NUM_LIT> , <NUM_LIT> ) ; mConversation . getWindow ( ) . getDecorView ( ) . findViewById ( android . R . id . content ) . postInvalidate ( ) ; } else { mConversation . recreate ( ) ; } } ) ; } } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } ) ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } return revokeboolean ; } private void showToast ( FMessageWpp fMessage ) { var jidAuthor = WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ; var messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_message ) ; var isStatus = Objects . equals ( WppCore . stripJID ( jidAuthor ) , "<STR_LIT>" ) ; if ( isStatus ) { messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_status ) ; jidAuthor = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; } if ( TextUtils . isEmpty ( jidAuthor ) ) return ; String name = WppCore . getContactName ( WppCore . createUserJid ( jidAuthor ) ) ; if ( TextUtils . isEmpty ( name ) ) { name = WppCore . stripJID ( jidAuthor ) ; } String message ; if ( WppCore . isGroup ( jidAuthor ) && fMessage . getUserJid ( ) != null ) { var participantJid = fMessage . getUserJid ( ) ; String participantName = WppCore . getContactName ( participantJid ) ; if ( TextUtils . isEmpty ( participantName ) ) { participantName = WppCore . stripJID ( WppCore . getRawString ( participantJid ) ) ; } message = Utils . getApplication ( ) . getString ( ResId . string . deleted_a_message_in_group , participantName , name ) ; } else { message = name + "<STR_LIT>" + messageSuffix ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { Utils . showToast ( message , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jidAuthor ) , isStatus ? "<STR_LIT>" : "<STR_LIT>" ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . Menu ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Channels extends Feature { public Channels ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void removeItems ( ArrayList < ? > arrList , boolean channels , boolean removechannelRec , Class < ? > headerChannelItem , Class < ? > listChannelItem , Class < ? > removeChannelRecClass ) { arrList . removeIf ( ( e ) -> { if ( channels ) { if ( headerChannelItem . isInstance ( e ) || listChannelItem . isInstance ( e ) ) return true ; } if ( channels || removechannelRec ) { return removeChannelRecClass . isInstance ( e ) ; } return false ; } ) ; } @ Override public void doHook ( ) throws Throwable { var channels = prefs . getBoolean ( "<STR_LIT>" , false ) ; var removechannelRec = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( channels || removechannelRec ) { var removeChannelRecClass = Unobfuscator . loadRemoveChannelRecClass ( classLoader ) ; log ( "<STR_LIT>" + removeChannelRecClass ) ; var headerChannelItem = Unobfuscator . loadHeaderChannelItemClass ( classLoader ) ; log ( "<STR_LIT>" + headerChannelItem ) ; var listChannelItem = Unobfuscator . loadListChannelItemClass ( classLoader ) ; log ( "<STR_LIT>" + listChannelItem ) ; var listUpdateItems = Unobfuscator . loadListUpdateItemsConstructor ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getConstructorDescriptor ( listUpdateItems ) ) ; XposedBridge . hookMethod ( listUpdateItems , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list = ReflectionUtils . findArrayOfType ( param . args , ArrayList . class ) ; if ( list . isEmpty ( ) ) return ; var arrList = ( ArrayList < ? > ) list . get ( <NUM_LIT> ) . second ; removeItems ( arrList , channels , removechannelRec , headerChannelItem , listChannelItem , removeChannelRecClass ) ; } } ) ; XposedBridge . hookAllConstructors ( removeChannelRecClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pairs = ReflectionUtils . findArrayOfType ( param . args , List . class ) ; for ( var pair : pairs ) { param . args [ pair . first ] = new ArrayList < > ( ) ; } } } ) ; if ( channels ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var menuItem = menu . findItem ( id ) ; if ( menuItem != null ) { menuItem . setVisible ( false ) ; } } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . graphics . PorterDuffColorFilter ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewStub ; import android . widget . ImageView ; import android . widget . TextView ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class ColorReplacement { public static void replaceColors ( View view , HashMap < String , String > colors ) { if ( view instanceof ImageView imageView ) { Image . replace ( imageView , colors ) ; } else if ( view instanceof TextView textView ) { Text . replace ( textView , colors ) ; } else if ( view instanceof ViewGroup viewGroup ) { Group . replace ( viewGroup , colors ) ; } else if ( view instanceof ViewStub viewStub ) { replaceColor ( viewStub . getBackground ( ) , colors ) ; } else if ( view . getClass ( ) . equals ( findClass ( "<STR_LIT>" , loader1 ) ) ) { CircularProgressBar . replace ( view , colors ) ; } } public static class Image { static void replace ( ImageView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var colorFilter = view . getColorFilter ( ) ; if ( colorFilter == null ) return ; if ( colorFilter instanceof PorterDuffColorFilter filter ) { var color = ( int ) XposedHelpers . callMethod ( filter , "<STR_LIT>" ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setColorFilter ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setColorFilter ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } } public static class CircularProgressBar { static void replace ( Object view , HashMap < String , String > colors ) { var progressColor = ( int ) callMethod ( view , "<STR_LIT>" ) ; var progressBackgroundColor = ( int ) callMethod ( view , "<STR_LIT>" ) ; var pcSColor = IColors . toString ( progressColor ) ; var pcbSColor = IColors . toString ( progressBackgroundColor ) ; var newPColor = colors . get ( pcSColor ) ; var newPBColor = colors . get ( pcbSColor ) ; if ( newPColor != null ) { callMethod ( view , "<STR_LIT>" , parseColor ( newPColor ) ) ; } if ( newPBColor != null ) { callMethod ( view , "<STR_LIT>" , parseColor ( newPBColor ) ) ; } } } public static class Text { static void replace ( TextView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var color = view . getCurrentTextColor ( ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setTextColor ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setTextColor ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } public static class Group { static void replace ( ViewGroup view , HashMap < String , String > colors ) { var bg = view . getBackground ( ) ; var count = view . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var child = view . getChildAt ( i ) ; replaceColors ( child , colors ) ; } replaceColor ( bg , colors ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class WaCallback implements Application . ActivityLifecycleCallbacks { @ Override public void onActivityCreated ( @ NonNull Activity activity , @ Nullable Bundle bundle ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; } @ Override public void onActivityStarted ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . START ) ; WppCore . activities . add ( activity ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void onActivityResumed ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; if ( WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ) { WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; try { new AlertDialogWpp ( activity ) . setMessage ( activity . getString ( ResId . string . restart_wpp ) ) . setPositiveButton ( activity . getString ( ResId . string . yes ) , ( dialog , which ) -> { if ( ! Utils . doRestart ( activity ) ) Toast . makeText ( activity , "<STR_LIT>" , Toast . LENGTH_SHORT ) . show ( ) ; } ) . setNegativeButton ( activity . getString ( ResId . string . no ) , null ) . show ( ) ; } catch ( Exception ignored ) { } } triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . RESUME ) ; } @ Override public void onActivityPaused ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . PAUSE ) ; } @ Override public void onActivityStopped ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . END ) ; WppCore . activities . remove ( activity ) ; } private static void triggerActivityState ( @ NonNull Activity activity , WppCore . ActivityChangeState . ChangeType type ) { for ( WppCore . ActivityChangeState listener : WppCore . listenerChat ) { listener . onChange ( activity , type ) ; } } @ Override public void onActivitySaveInstanceState ( @ NonNull Activity activity , @ NonNull Bundle bundle ) { } @ Override public void onActivityDestroyed ( @ NonNull Activity activity ) { WppCore . activities . remove ( activity ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . os . Handler ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class Tasker extends Feature { private static FMessageWpp fMessage ; private static boolean taskerEnabled ; public Tasker ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { taskerEnabled = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! taskerEnabled ) return ; hookReceiveMessage ( ) ; registerSenderMessage ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private void registerSenderMessage ( ) { IntentFilter filter = new IntentFilter ( "<STR_LIT>" ) ; ContextCompat . registerReceiver ( Utils . getApplication ( ) , new SenderMessageBroadcastReceiver ( ) , filter , ContextCompat . RECEIVER_EXPORTED ) ; } public synchronized static void sendTaskerEvent ( String name , String number , String event ) { if ( ! taskerEnabled ) return ; Intent intent = new Intent ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , name ) ; intent . putExtra ( "<STR_LIT>" , number ) ; intent . putExtra ( "<STR_LIT>" , event ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } public void hookReceiveMessage ( ) throws Throwable { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; XposedBridge . hookMethod ( method2 , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; } } ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" || param . args [ <NUM_LIT> ] == null || fMessage == null ) return ; var userJid = fMessage . getKey ( ) . remoteJid ; var rawJid = WppCore . getRawString ( userJid ) ; var name = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( rawJid ) ; var msg = fMessage . getMessageStr ( ) ; if ( TextUtils . isEmpty ( msg ) || TextUtils . isEmpty ( number ) || rawJid . startsWith ( "<STR_LIT>" ) ) return ; new Handler ( Utils . getApplication ( ) . getMainLooper ( ) ) . post ( ( ) -> { Intent intent = new Intent ( "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , number ) ; intent . putExtra ( "<STR_LIT>" , name ) ; intent . putExtra ( "<STR_LIT>" , msg ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } ) ; } } ) ; } public static class SenderMessageBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { XposedBridge . log ( "<STR_LIT>" ) ; var number = intent . getStringExtra ( "<STR_LIT>" ) ; if ( number == null ) { number = String . valueOf ( intent . getLongExtra ( "<STR_LIT>" , <NUM_LIT> ) ) ; number = Objects . equals ( number , "<STR_LIT>" ) ? null : number ; } var message = intent . getStringExtra ( "<STR_LIT>" ) ; if ( number == null || message == null ) return ; number = number . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; WppCore . sendMessage ( number , message ) ; } } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . GradientDrawable ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . View ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . SeekBar ; import android . widget . TextView ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; public class SimpleColorPickerDialog extends AlertDialogWpp { private final OnColorSelectedListener listener ; private int selectedColor = Color . BLACK ; private boolean isUpdating = false ; public SimpleColorPickerDialog ( Context context , OnColorSelectedListener listener ) { super ( context ) ; this . listener = listener ; } @ Override public Dialog create ( ) { setTitle ( getContext ( ) . getString ( ResId . string . select_a_color ) ) ; LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; final SeekBar redSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar greenSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar blueSeekBar = new SeekBar ( getContext ( ) ) ; redSeekBar . setMax ( <NUM_LIT> ) ; greenSeekBar . setMax ( <NUM_LIT> ) ; blueSeekBar . setMax ( <NUM_LIT> ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , redSeekBar ) ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , greenSeekBar ) ) ; layout . addView ( createSeekBarLayout ( "<STR_LIT>" , blueSeekBar ) ) ; final View colorPreview = new View ( getContext ( ) ) ; colorPreview . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( selectedColor ) ; borderDrawable . setStroke ( <NUM_LIT> , DesignUtils . getPrimaryTextColor ( ) ) ; colorPreview . setBackground ( borderDrawable ) ; layout . addView ( colorPreview ) ; final EditText hexInput = new EditText ( getContext ( ) ) ; hexInput . setHint ( "<STR_LIT>" ) ; layout . addView ( hexInput ) ; redSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; greenSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; blueSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; hexInput . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { if ( ! isUpdating && s . length ( ) == <NUM_LIT> && s . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { try { isUpdating = true ; selectedColor = Color . parseColor ( s . toString ( ) ) ; borderDrawable . setColor ( selectedColor ) ; redSeekBar . setProgress ( Color . red ( selectedColor ) ) ; greenSeekBar . setProgress ( Color . green ( selectedColor ) ) ; blueSeekBar . setProgress ( Color . blue ( selectedColor ) ) ; isUpdating = false ; } catch ( IllegalArgumentException e ) { } } } @ Override public void afterTextChanged ( Editable s ) { } } ) ; setPositiveButton ( "<STR_LIT>" , ( dialogInterface , i ) -> { if ( listener != null ) { listener . onColorSelected ( selectedColor ) ; } dismiss ( ) ; } ) ; setNegativeButton ( getContext ( ) . getString ( ResId . string . cancel ) , ( dialogInterface , i ) -> { dismiss ( ) ; } ) ; setView ( layout ) ; return super . create ( ) ; } private void updateColorPreview ( GradientDrawable borderDrawable , SeekBar redSeekBar , SeekBar greenSeekBar , SeekBar blueSeekBar , EditText hexInput ) { int red = redSeekBar . getProgress ( ) ; int green = greenSeekBar . getProgress ( ) ; int blue = blueSeekBar . getProgress ( ) ; selectedColor = Color . rgb ( red , green , blue ) ; borderDrawable . setColor ( selectedColor ) ; hexInput . setText ( String . format ( "<STR_LIT>" , red , green , blue ) ) ; } private LinearLayout createSeekBarLayout ( String label , SeekBar seekBar ) { LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; TextView labelView = new TextView ( getContext ( ) ) ; labelView . setText ( label ) ; labelView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; layout . addView ( labelView ) ; layout . addView ( seekBar ) ; return layout ; } public interface OnColorSelectedListener { void onColorSelected ( int color ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . components ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FMessageWpp { public static Class < ? > TYPE ; private static boolean initialized ; private static Method userJidMethod ; private static Field keyMessage ; private static Field getFieldIdMessage ; private static Method deviceJidMethod ; private static Method messageMethod ; private static Method messageWithMediaMethod ; private final Object fmessage ; public FMessageWpp ( Object fMessage ) { if ( fMessage == null ) throw new RuntimeException ( "<STR_LIT>" ) ; this . fmessage = fMessage ; try { init ( fMessage . getClass ( ) . getClassLoader ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void init ( ClassLoader classLoader ) throws Exception { if ( initialized ) return ; initialized = true ; TYPE = Unobfuscator . loadFMessageClass ( classLoader ) ; var userJidClass = classLoader . loadClass ( "<STR_LIT>" ) ; userJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == userJidClass ) ; keyMessage = Unobfuscator . loadMessageKeyField ( classLoader ) ; messageMethod = Unobfuscator . loadNewMessageMethod ( classLoader ) ; messageWithMediaMethod = Unobfuscator . loadNewMessageWithMediaMethod ( classLoader ) ; getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; deviceJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getReturnType ( ) . equals ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ) ; } public Object getUserJid ( ) { try { return userJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getDeviceJid ( ) { try { return deviceJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public long getRowId ( ) { try { return getFieldIdMessage . getLong ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return <NUM_LIT> ; } public Key getKey ( ) { try { return new Key ( keyMessage . get ( fmessage ) ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getObject ( ) { return fmessage ; } public String getMessageStr ( ) { try { var message = ( String ) messageMethod . invoke ( fmessage ) ; if ( message != null ) return message ; return ( String ) messageWithMediaMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; return null ; } } public static class Key { public final Object thisObject ; public final String messageID ; public final boolean isFromMe ; public final Object remoteJid ; public Key ( Object key ) { this . thisObject = key ; this . messageID = ( String ) XposedHelpers . getObjectField ( key , "<STR_LIT>" ) ; this . isFromMe = XposedHelpers . getBooleanField ( key , "<STR_LIT>" ) ; this . remoteJid = XposedHelpers . getObjectField ( key , "<STR_LIT>" ) ; } } } </s>
<s> package com . wmods . wppenhacer . listeners ; import android . view . GestureDetector ; import android . view . MotionEvent ; public class DoubleTapListener extends GestureDetector . SimpleOnGestureListener { private final OnDoubleClickListener listener ; public DoubleTapListener ( OnDoubleClickListener listener ) { this . listener = listener ; } @ Override public boolean onDoubleTap ( MotionEvent e ) { listener . onDoubleClick ( ) ; return true ; } public interface OnDoubleClickListener { void onDoubleClick ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . xposed . features . customization . SeparateGroup . tabs ; import android . os . Bundle ; import android . view . MenuItem ; import android . view . View ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . ArrayList ; import java . util . List ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideTabs extends Feature { private Object mTabPagerInstance ; public HideTabs ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var hidetabs = prefs . getStringSet ( "<STR_LIT>" , null ) ; var igstatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( hidetabs == null || hidetabs . isEmpty ( ) ) return ; var home = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var hideTabsList = hidetabs . stream ( ) . map ( Integer :: valueOf ) . collect ( Collectors . toList ( ) ) ; var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var ListField = Unobfuscator . getFieldByType ( home , List . class ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var list = ( List < Integer > ) XposedHelpers . getStaticObjectField ( home , ListField . getName ( ) ) ; for ( var item : hideTabsList ) { if ( item != SeparateGroup . STATUS || ! igstatus ) { list . remove ( item ) ; } } } } ) ; var OnTabItemAddMethod = Unobfuscator . loadOnTabItemAddMethod ( classLoader ) ; XposedBridge . hookMethod ( OnTabItemAddMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menuItem = ( MenuItem ) param . getResult ( ) ; var menuItemId = menuItem . getItemId ( ) ; if ( hideTabsList . contains ( menuItemId ) ) { menuItem . setVisible ( false ) ; } } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; logDebug ( loadTabFrameClass ) ; XposedBridge . hookAllMethods ( FrameLayout . class , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; if ( tabs != null ) { var arr = new ArrayList < > ( tabs ) ; arr . removeAll ( hideTabsList ) ; if ( arr . size ( ) == <NUM_LIT> ) { ( ( View ) param . thisObject ) . setVisibility ( View . GONE ) ; } } for ( var item : hideTabsList ) { View view ; if ( ( view = ( ( View ) param . thisObject ) . findViewById ( item ) ) != null ) { view . setVisibility ( View . GONE ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Class < ? > TabsPagerClass = classLoader . loadClass ( "<STR_LIT>" ) ; var tabsField = Unobfuscator . getFieldByType ( param . thisObject . getClass ( ) , TabsPagerClass ) ; mTabPagerInstance = tabsField . get ( param . thisObject ) ; } } ) ; var onMenuItemSelected = Unobfuscator . loadOnMenuItemSelected ( classLoader ) ; XposedBridge . hookMethod ( onMenuItemSelected , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject == mTabPagerInstance ) { var index = ( int ) param . args [ <NUM_LIT> ] ; var idxAtual = ( int ) XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; param . args [ <NUM_LIT> ] = getNewTabIndex ( hideTabsList , idxAtual , index ) ; } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , int . class , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject != mTabPagerInstance ) return ; for ( var item : hideTabsList ) { var index = tabs . indexOf ( item ) ; if ( index == - <NUM_LIT> ) continue ; if ( ( int ) param . args [ <NUM_LIT> ] == index ) { ( ( View ) param . args [ <NUM_LIT> ] ) . setVisibility ( View . GONE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public int getNewTabIndex ( List hidetabs , int indexAtual , int index ) { if ( tabs == null ) return index ; var tabIsHidden = hidetabs . contains ( tabs . get ( index ) ) ; if ( ! tabIsHidden ) return index ; var newIndex = index > indexAtual ? index + <NUM_LIT> : index - <NUM_LIT> ; if ( newIndex < <NUM_LIT> ) return <NUM_LIT> ; if ( newIndex >= tabs . size ( ) ) return indexAtual ; return getNewTabIndex ( hidetabs , indexAtual , newIndex ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . media . MediaScannerConnection ; import android . os . Environment ; import android . os . Handler ; import android . os . Looper ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . Properties ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import de . robv . android . xposed . XposedBridge ; public class Utils { private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; private static final ExecutorService executorCachedService = Executors . newCachedThreadPool ( ) ; @ NonNull public static Application getApplication ( ) { return FeatureLoader . mApp == null ? App . getInstance ( ) : FeatureLoader . mApp ; } public static ExecutorService getExecutor ( ) { return executorService ; } public static ExecutorService getExecutorCachedService ( ) { return executorCachedService ; } public static boolean doRestart ( Context context ) { PackageManager packageManager = context . getPackageManager ( ) ; Intent intent = packageManager . getLaunchIntentForPackage ( context . getPackageName ( ) ) ; if ( intent == null ) return false ; ComponentName componentName = intent . getComponent ( ) ; Intent mainIntent = Intent . makeRestartActivityTask ( componentName ) ; mainIntent . setPackage ( context . getPackageName ( ) ) ; context . startActivity ( mainIntent ) ; Runtime . getRuntime ( ) . exit ( <NUM_LIT> ) ; return true ; } @ SuppressLint ( "<STR_LIT>" ) public static int getID ( String name , String type ) { try { return getApplication ( ) . getApplicationContext ( ) . getResources ( ) . getIdentifier ( name , type , getApplication ( ) . getPackageName ( ) ) ; } catch ( Exception e ) { XposedBridge . log ( "<STR_LIT>" + name + "<STR_LIT>" + type + "<STR_LIT>" + e ) ; return - <NUM_LIT> ; } } public static int dipToPixels ( float dipValue ) { DisplayMetrics metrics = FeatureLoader . mApp . getResources ( ) . getDisplayMetrics ( ) ; return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dipValue , metrics ) ; } public static String getMyNumber ( ) { return FeatureLoader . mApp . getSharedPreferences ( FeatureLoader . mApp . getPackageName ( ) + "<STR_LIT>" , Context . MODE_PRIVATE ) . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static String getDateTimeFromMillis ( long timestamp ) { return new SimpleDateFormat ( "<STR_LIT>" , Locale . ENGLISH ) . format ( new Date ( timestamp ) ) ; } public static String getDestination ( SharedPreferences prefs , String name ) { var folderPath = prefs . getString ( "<STR_LIT>" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "<STR_LIT>" ) + "<STR_LIT>" + name + "<STR_LIT>" ; var filePath = new File ( folderPath ) ; if ( ! filePath . exists ( ) ) filePath . mkdirs ( ) ; return filePath . getAbsolutePath ( ) + "<STR_LIT>" ; } public static String copyFile ( File srcFile , File destFile ) { if ( srcFile == null || ! srcFile . exists ( ) ) return "<STR_LIT>" ; try ( FileInputStream in = new FileInputStream ( srcFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; Utils . scanFile ( destFile ) ; return "<STR_LIT>" ; } out . write ( bArr , <NUM_LIT> , read ) ; } } catch ( IOException e ) { XposedBridge . log ( e . getMessage ( ) ) ; return e . getMessage ( ) ; } } public static void showToast ( String message , int length ) { if ( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) { Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ) ; } } public static void setToClipboard ( String string ) { ClipboardManager clipboard = ( ClipboardManager ) Utils . getApplication ( ) . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( "<STR_LIT>" , string ) ; clipboard . setPrimaryClip ( clip ) ; } public static String generateName ( Object userJid , String fileFormat ) { var contactName = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; return toValidFileName ( contactName ) + "<STR_LIT>" + number + "<STR_LIT>" + new SimpleDateFormat ( "<STR_LIT>" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + "<STR_LIT>" + fileFormat ; } public static Object getDefaultValue ( Class < ? > paramType ) { if ( paramType == int . class || paramType == Integer . class ) { return <NUM_LIT> ; } else if ( paramType == long . class || paramType == Long . class ) { return <NUM_LIT> ; } else if ( paramType == double . class || paramType == Double . class ) { return <NUM_LIT> ; } else if ( paramType == boolean . class || paramType == Boolean . class ) { return false ; } return null ; } @ NonNull public static String toValidFileName ( @ NonNull String input ) { return input . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static void scanFile ( File file ) { MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { file . getAbsolutePath ( ) } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( s , uri ) -> { } ) ; } public static Properties extractProperties ( String text ) { Properties properties = new Properties ( ) ; Pattern pattern = Pattern . compile ( "<STR_LIT>" , Pattern . DOTALL ) ; Matcher matcher = pattern . matcher ( text ) ; if ( matcher . find ( ) ) { String propertiesText = matcher . group ( <NUM_LIT> ) ; String [ ] lines = propertiesText . split ( "<STR_LIT>" ) ; for ( String line : lines ) { String [ ] keyValue = line . split ( "<STR_LIT>" ) ; String key = keyValue [ <NUM_LIT> ] . strip ( ) ; String value = keyValue [ <NUM_LIT> ] . strip ( ) . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; properties . put ( key , value ) ; } } return properties ; } public static int tryParseInt ( String wallpaperAlpha , int i ) { try { return Integer . parseInt ( wallpaperAlpha . trim ( ) ) ; } catch ( Exception e ) { return i ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class DndMode extends Feature { public DndMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { if ( ! WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ) return ; var dndMethod = Unobfuscator . loadDndModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( dndMethod ) ) ; XposedBridge . hookMethod ( dndMethod , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . NonNull ; import java . util . HashSet ; public class DelMessageStore extends SQLiteOpenHelper { private static DelMessageStore mInstance ; private DelMessageStore ( @ NonNull Context context ) { super ( context , "<STR_LIT>" , null , <NUM_LIT> ) ; } public static DelMessageStore getInstance ( Context ctx ) { synchronized ( DelMessageStore . class ) { if ( mInstance == null || ! mInstance . getWritableDatabase ( ) . isOpen ( ) ) { mInstance = new DelMessageStore ( ctx ) ; } } return mInstance ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { if ( oldVersion < <NUM_LIT> ) { if ( ! checkColumnExists ( sqLiteDatabase , "<STR_LIT>" , "<STR_LIT>" ) ) { sqLiteDatabase . execSQL ( "<STR_LIT>" ) ; } } } public void insertMessage ( String jid , String msgid , long timestamp ) { try ( SQLiteDatabase dbWrite = this . getWritableDatabase ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( "<STR_LIT>" , jid ) ; values . put ( "<STR_LIT>" , msgid ) ; values . put ( "<STR_LIT>" , timestamp ) ; dbWrite . insert ( "<STR_LIT>" , null , values ) ; } } public HashSet < String > getMessagesByJid ( String jid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; Cursor query = dbReader . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { jid } , null , null , null ) ; HashSet < String > messages = new HashSet < > ( ) ; try { if ( query . moveToFirst ( ) ) { do { messages . add ( query . getString ( query . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ) ; } while ( query . moveToNext ( ) ) ; } } finally { query . close ( ) ; dbReader . close ( ) ; } return messages ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { sqLiteDatabase . execSQL ( "<STR_LIT>" ) ; } public long getTimestampByMessageId ( String msgid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; try ( dbReader ; Cursor query = dbReader . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { msgid } , null , null , null ) ) { if ( query . moveToFirst ( ) ) { return query . getLong ( query . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; } return <NUM_LIT> ; } } private boolean checkColumnExists ( SQLiteDatabase db , String tableName , String columnName ) { try ( Cursor cursor = db . rawQuery ( "<STR_LIT>" + tableName + "<STR_LIT>" , null ) ) { if ( cursor != null ) { int nameIndex = cursor . getColumnIndex ( "<STR_LIT>" ) ; while ( cursor . moveToNext ( ) ) { String currentColumnName = cursor . getString ( nameIndex ) ; if ( columnName . equals ( currentColumnName ) ) { return true ; } } } } catch ( Exception ignored ) { } return false ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . devkit ; import android . app . Activity ; import android . content . ContentValues ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . NinePatchDrawable ; import android . net . Uri ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . TextView ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . luckypray . dexkit . DexKitBridge ; import org . luckypray . dexkit . query . FindClass ; import org . luckypray . dexkit . query . FindMethod ; import org . luckypray . dexkit . query . enums . StringMatchType ; import org . luckypray . dexkit . query . matchers . ClassMatcher ; import org . luckypray . dexkit . query . matchers . MethodMatcher ; import org . luckypray . dexkit . query . matchers . base . OpCodesMatcher ; import org . luckypray . dexkit . result . ClassData ; import org . luckypray . dexkit . result . ClassDataList ; import org . luckypray . dexkit . result . MethodData ; import org . luckypray . dexkit . result . MethodDataList ; import org . luckypray . dexkit . result . UsingFieldData ; import org . luckypray . dexkit . util . DexSignUtil ; import java . io . File ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . Timer ; import java . util . TimerTask ; import java . util . stream . Collectors ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Unobfuscator { private static DexKitBridge dexkit ; public static final String BUBBLE_COLORS_BALLOON_INCOMING_NORMAL = "<STR_LIT>" ; public static final String BUBBLE_COLORS_BALLOON_INCOMING_NORMAL_EXT = "<STR_LIT>" ; public static final HashMap < String , Object > cache = new HashMap < > ( ) ; static { System . loadLibrary ( "<STR_LIT>" ) ; } public static boolean initDexKit ( String path ) { try { dexkit = DexKitBridge . create ( path ) ; } catch ( Exception e ) { return false ; } return true ; } public static Method findFirstMethodUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) throws Exception { MethodMatcher matcher = new MethodMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } MethodDataList result = dexkit . findMethod ( new FindMethod ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return null ; for ( MethodData methodData : result ) { if ( methodData . isMethod ( ) ) return methodData . getMethodInstance ( classLoader ) ; } throw new NoSuchMethodException ( ) ; } public static Method [ ] findAllMethodUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) { MethodMatcher matcher = new MethodMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } MethodDataList result = dexkit . findMethod ( new FindMethod ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return new Method [ <NUM_LIT> ] ; return result . stream ( ) . filter ( MethodData :: isMethod ) . map ( methodData -> { try { return methodData . getMethodInstance ( classLoader ) ; } catch ( NoSuchMethodException e ) { return null ; } } ) . filter ( Objects :: nonNull ) . toArray ( Method [ ] :: new ) ; } public static Class < ? > findFirstClassUsingStrings ( ClassLoader classLoader , StringMatchType type , String ... strings ) throws Exception { var matcher = new ClassMatcher ( ) ; for ( String string : strings ) { matcher . addUsingString ( string , type ) ; } var result = dexkit . findClass ( new FindClass ( ) . matcher ( matcher ) ) ; if ( result . isEmpty ( ) ) return null ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } public static Field getFieldByType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( type ) ) . findFirst ( ) . orElse ( null ) ; } public static Field getFieldByExtendType ( Class < ? > cls , Class < ? > type ) { return Arrays . stream ( cls . getFields ( ) ) . filter ( f -> type . isAssignableFrom ( f . getType ( ) ) ) . findFirst ( ) . orElse ( null ) ; } public static String getMethodDescriptor ( Method method ) { if ( method == null ) return null ; return method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + method . getName ( ) + "<STR_LIT>" + Arrays . stream ( method . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) + "<STR_LIT>" ; } public static String getConstructorDescriptor ( Constructor constructor ) { if ( constructor == null ) return null ; return constructor . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + constructor . getName ( ) + "<STR_LIT>" + Arrays . stream ( constructor . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( "<STR_LIT>" ) ) + "<STR_LIT>" ; } public static String getFieldDescriptor ( Field field ) { return field . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + field . getName ( ) + "<STR_LIT>" + field . getType ( ) . getName ( ) ; } public static boolean isCalledFromClass ( Class < ? > cls ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; for ( StackTraceElement stackTraceElement : trace ) { if ( stackTraceElement . getClassName ( ) . equals ( cls . getName ( ) ) ) return true ; } return false ; } public static boolean isCalledFromMethod ( Method method ) { var trace = Thread . currentThread ( ) . getStackTrace ( ) ; for ( StackTraceElement stackTraceElement : trace ) { if ( stackTraceElement . getClassName ( ) . equals ( method . getDeclaringClass ( ) . getName ( ) ) && stackTraceElement . getMethodName ( ) . equals ( method . getName ( ) ) ) return true ; } return false ; } public static Method loadFreezeSeenMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ) ) ; } public static Method loadGhostModeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; if ( method . getParameterTypes ( ) . length > <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == int . class ) return method ; throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadReceiptMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method [ ] methods = findAllMethodUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; var deviceJidClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; Method bestMethod = Arrays . stream ( methods ) . filter ( method -> method . getParameterTypes ( ) . length > <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == deviceJidClass ) . findFirst ( ) . orElse ( null ) ; if ( bestMethod == null ) throw new Exception ( "<STR_LIT>" ) ; return bestMethod ; } ) ; } public static Method loadReceiptOutsideChat ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = loadReceiptMethod ( classLoader ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; var classData = dexkit . getClassData ( method . getDeclaringClass ( ) ) ; if ( classData == null ) throw new Exception ( "<STR_LIT>" ) ; var methodResult = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( methodResult . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodResult . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadReceiptInChat ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = loadReceiptMethod ( classLoader ) ; var methodDataList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . addUsingNumber ( <NUM_LIT> ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method ) ) ) ) ; if ( methodDataList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodDataList . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadForwardTagMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > messageInfoClass = loadFMessageClass ( classLoader ) ; var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( methodList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; var invokes = methodList . get ( <NUM_LIT> ) . getInvokes ( ) ; for ( var invoke : invokes ) { var method = invoke . getMethodInstance ( classLoader ) ; if ( method . getParameterCount ( ) == <NUM_LIT> && method . getParameterTypes ( ) [ <NUM_LIT> ] == int . class && method . getDeclaringClass ( ) == messageInfoClass && method . getReturnType ( ) == void . class ) { return method ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Class < ? > loadForwardClassMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ) ; } public static Method loadHideViewSendReadJob ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var classData = dexkit . getClassData ( XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ; var methodResult = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Equals ) ) ) ; if ( methodResult . isEmpty ( ) ) { methodResult = classData . getSuperClass ( ) . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Equals ) ) ) ; } if ( methodResult . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methodResult . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadHideViewInChatMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadHideViewMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadHideViewAudioMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Class < ? > loadFMessageClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var messageClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( messageClass == null ) throw new Exception ( "<STR_LIT>" ) ; return messageClass ; } ) ; } public static Method loadTabListMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > classMain = findFirstClassUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" ) ; if ( classMain == null ) throw new Exception ( "<STR_LIT>" ) ; Method method = Arrays . stream ( classMain . getMethods ( ) ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadTabFragmentMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > clsFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; Method result = Arrays . stream ( clsFrag . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getReturnType ( ) . equals ( List . class ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadTabNameMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method tabListMethod = loadGetTabMethod ( classLoader ) ; Class < ? > cls = tabListMethod . getDeclaringClass ( ) ; if ( Modifier . isAbstract ( cls . getModifiers ( ) ) ) { var findClass = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( cls . getName ( ) ) . addUsingString ( "<STR_LIT>" ) ) ) ; cls = findClass . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } Method result = Arrays . stream ( cls . getMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getReturnType ( ) . equals ( String . class ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadFabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > cls = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; List < ClassData > classes = List . of ( dexkit . getClassData ( cls ) ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( classes ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . usingNumbers ( <NUM_LIT> ) . returnType ( int . class ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadIconTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconTabField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > cls = loadIconTabMethod ( classLoader ) . getDeclaringClass ( ) ; Class < ? > clsType = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var result = Arrays . stream ( cls . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( clsType ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconTabLayoutField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > clsType = loadIconTabField ( classLoader ) . getType ( ) ; Class < ? > framelayout = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var result = Arrays . stream ( clsType . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( framelayout ) ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Field loadIconMenuField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { Class < ? > clsType = loadIconTabLayoutField ( classLoader ) . getType ( ) ; Class < ? > menuClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; return Arrays . stream ( clsType . getFields ( ) ) . filter ( f -> f . getType ( ) . equals ( menuClass ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadTabCountMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Method result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadEnableCountTabMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Constructor loadEnableCountTabConstructor1 ( ClassLoader classLoader ) throws Exception { var countMethod = loadEnableCountTabMethod ( classLoader ) ; var indiceClass = countMethod . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Constructor loadEnableCountTabConstructor2 ( ClassLoader classLoader ) throws Exception { var countTabConstructor1 = loadEnableCountTabConstructor1 ( classLoader ) ; var indiceClass = countTabConstructor1 . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Constructor loadEnableCountTabConstructor3 ( ClassLoader classLoader ) throws Exception { var countTabConstructor1 = loadEnableCountTabConstructor1 ( classLoader ) ; var indiceClass = countTabConstructor1 . getParameterTypes ( ) [ <NUM_LIT> ] ; var result = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . superClass ( indiceClass . getName ( ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } public static Method loadTimeToSecondsMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > cls = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( cls == null ) throw new Exception ( "<STR_LIT>" ) ; var clsData = dexkit . getClassData ( cls ) ; var method = XposedHelpers . findMethodBestMatch ( Calendar . class , "<STR_LIT>" , long . class ) ; var result = clsData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method ) ) . returnType ( String . class ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadDndModeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Equals , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } private static Class < ? > loadMediaQualityClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazzMediaClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazzMediaClass == null ) throw new Exception ( "<STR_LIT>" ) ; return clazzMediaClass ; } ) ; } public static Method loadMediaQualityResolutionMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadMediaQualityClass ( classLoader ) ; return Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadMediaQualityBitrateMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadMediaQualityClass ( classLoader ) ; return Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterTypes ( ) . length == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getReturnType ( ) . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadMediaQualityVideoMethod2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class loadMediaQualityVideoLimitClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadShareLimitMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadShareMapItemField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var shareLimitMethod = loadShareLimitMethod ( classLoader ) ; var methodData = dexkit . getMethodData ( shareLimitMethod ) ; var usingFields = Objects . requireNonNull ( methodData ) . getUsingFields ( ) ; for ( var ufield : usingFields ) { var field = ufield . getField ( ) . getFieldInstance ( classLoader ) ; if ( field . getType ( ) == Map . class ) return field ; } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadStatusActivePage ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class < ? > loadStatusDownloadMediaClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadMenuStatusClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( id ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadMenuStatusMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) ) ) ; if ( methods . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return methods . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadStatusDownloadFileField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var clazz = loadStatusDownloadMediaClass ( classLoader ) ; var clazz2 = clazz . getField ( "<STR_LIT>" ) . getType ( ) ; var field = getFieldByType ( clazz2 , File . class ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Class < ? > loadStatusDownloadSubMenuClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var classes = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Contains ) . returnType ( void . class ) ) ) ) ; if ( classes . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classes . get ( <NUM_LIT> ) . getInstance ( classLoader ) ; } ) ; } public static Class < ? > loadStatusDownloadMenuClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method [ ] loadViewOnceMethod ( ClassLoader classLoader ) throws Exception { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" , StringMatchType . Contains ) ) ) ; if ( method . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; var methodData = method . get ( <NUM_LIT> ) ; var listMethods = methodData . getInvokes ( ) ; var list = new ArrayList < Method > ( ) ; for ( MethodData m : listMethods ) { var mInstance = m . getMethodInstance ( classLoader ) ; if ( mInstance . getDeclaringClass ( ) . isInterface ( ) && mInstance . getDeclaringClass ( ) . getMethods ( ) . length == <NUM_LIT> ) { ClassDataList listClasses = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addInterface ( mInstance . getDeclaringClass ( ) . getName ( ) ) ) ) ; for ( ClassData c : listClasses ) { Class < ? > clazz = c . getInstance ( classLoader ) ; var resultMethod = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m1 -> m1 . getParameterCount ( ) == <NUM_LIT> && m1 . getReturnType ( ) . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; if ( resultMethod == null ) continue ; list . add ( resultMethod ) ; } return list . toArray ( new Method [ <NUM_LIT> ] ) ; } } throw new Exception ( "<STR_LIT>" ) ; } public static Class loadViewOnceClass ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } public static Method loadViewOnceStoreMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } public static Method loadViewOnceDownloadMenuMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , Menu . class ) && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , MenuInflater . class ) && m . getDeclaringClass ( ) == clazz ) . findFirst ( ) ; if ( ! method . isPresent ( ) ) throw new Exception ( "<STR_LIT>" ) ; return method . get ( ) ; } ) ; } public static Field loadViewOnceDownloadMenuField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var method = loadViewOnceDownloadMenuMethod ( classLoader ) ; var clazz = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var methodData = dexkit . getMethodData ( method ) ; var fields = methodData . getUsingFields ( ) ; for ( UsingFieldData field : fields ) { Field field1 = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( field1 . getType ( ) == int . class && field1 . getDeclaringClass ( ) == clazz ) { return field1 ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Field loadViewOnceDownloadMenuField2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var methodData = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) . get ( <NUM_LIT> ) ; var clazz = methodData . getMethodInstance ( classLoader ) . getDeclaringClass ( ) ; var fields = methodData . getUsingFields ( ) ; for ( UsingFieldData field : fields ) { Field field1 = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( field1 . getType ( ) == int . class && field1 . getDeclaringClass ( ) == clazz ) { return field1 ; } } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadViewOnceDownloadMenuCallMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> ( ( m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , int . class ) && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , clazz ) ) || ( m . getParameterCount ( ) == <NUM_LIT> && Objects . equals ( m . getParameterTypes ( ) [ <NUM_LIT> ] , int . class ) ) ) && Modifier . isPublic ( m . getModifiers ( ) ) && Object . class . isAssignableFrom ( m . getReturnType ( ) ) ) . findFirst ( ) ; if ( ! method . isPresent ( ) ) throw new Exception ( "<STR_LIT>" ) ; return method . get ( ) ; } ) ; } public static Class < ? > loadExpandableWidgetClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class < ? > loadMaterialShapeDrawableClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class < ? > loadCustomDrawableClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadPropsBooleanMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPropsIntegerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPropsJsonMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } private static ClassData loadAntiRevokeImplClass ( ) throws Exception { var classes = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( classes . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return classes . get ( <NUM_LIT> ) ; } public static Method loadAntiRevokeOnStartMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var classData = loadAntiRevokeImplClass ( ) ; MethodDataList mdOnStart = dexkit . findMethod ( FindMethod . create ( ) . searchInClass ( List . of ( dexkit . getClassData ( conversation ) ) ) . matcher ( MethodMatcher . create ( ) . addInvoke ( Objects . requireNonNull ( classData ) . getDescriptor ( ) + "<STR_LIT>" ) ) ) ; if ( mdOnStart . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return mdOnStart . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadAntiRevokeConvChatField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > chatClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; Field field = getFieldByType ( conversation , chatClass ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Field loadAntiRevokeChatJidField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > chatClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; Class < ? > jidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; Field field = getFieldByExtendType ( chatClass , jidClass ) ; if ( field == null ) throw new Exception ( "<STR_LIT>" ) ; return field ; } ) ; } public static Method loadAntiRevokeMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Method method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadMessageKeyField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . fieldCount ( <NUM_LIT> ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . name ( "<STR_LIT>" ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; for ( ClassData classData : classList ) { Class < ? > keyMessageClass = classData . getInstance ( loader ) ; var classMessage = loadFMessageClass ( loader ) ; var fields = ReflectionUtils . getFieldsByExtendType ( classMessage , keyMessageClass ) ; if ( fields . isEmpty ( ) ) continue ; return fields . get ( fields . size ( ) - <NUM_LIT> ) ; } throw new Exception ( "<STR_LIT>" ) ; } ) ; } public static Method loadAntiRevokeBubbleMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > bubbleClass = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( bubbleClass == null ) throw new Exception ( "<STR_LIT>" ) ; var result = Arrays . stream ( bubbleClass . getMethods ( ) ) . filter ( m -> m . getParameterCount ( ) > <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] == ViewGroup . class && m . getParameterTypes ( ) [ <NUM_LIT> ] == TextView . class ) . findFirst ( ) . orElse ( null ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadUnknownStatusPlaybackMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var statusPlaybackClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var classData = List . of ( dexkit . getClassData ( statusPlaybackClass ) ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( classData ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadStatusPlaybackViewField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > class1 = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; ClassDataList classView = dexkit . findClass ( FindClass . create ( ) . matcher ( ClassMatcher . create ( ) . methodCount ( <NUM_LIT> ) . addFieldForType ( class1 ) ) ) ; if ( classView . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; Class < ? > clsViewStatus = classView . get ( <NUM_LIT> ) . getInstance ( loader ) ; Class < ? > class2 = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; return Arrays . stream ( class2 . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) == clsViewStatus ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Class < ? > loadMessageStoreClass2 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var result = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadBlueOnReplayMessageJobMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadBlueOnReplayWaJobManagerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var job = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; var method = Arrays . stream ( result . getMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] == job ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method [ ] loadArchiveHideViewMethod ( ClassLoader loader ) throws Exception { if ( cache . containsKey ( "<STR_LIT>" ) ) return ( Method [ ] ) cache . get ( "<STR_LIT>" ) ; var methods = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( methods . length == <NUM_LIT> ) throw new Exception ( "<STR_LIT>" ) ; ArrayList < Method > result = new ArrayList < > ( ) ; for ( var m : methods ) { result . add ( m . getDeclaringClass ( ) . getMethod ( "<STR_LIT>" , boolean . class ) ) ; } var resultArray = result . toArray ( new Method [ <NUM_LIT> ] ) ; cache . put ( "<STR_LIT>" , resultArray ) ; return resultArray ; } public static Method loadAntiRevokeOnCallReceivedMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetContactInfoMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Class < ? > class1 = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( class1 == null ) throw new Exception ( "<STR_LIT>" ) ; var jidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var result = ReflectionUtils . findMethodUsingFilter ( class1 , m -> m . getParameterCount ( ) == <NUM_LIT> && jidClass . isAssignableFrom ( m . getParameterTypes ( ) [ <NUM_LIT> ] ) && m . getReturnType ( ) != void . class ) ; if ( result == null ) throw new Exception ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadOnChangeStatus ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { Method [ ] methods = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var method = Arrays . stream ( methods ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Field loadViewHolderField1 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { Class < ? > class1 = loadOnChangeStatus ( loader ) . getDeclaringClass ( ) . getSuperclass ( ) ; Class < ? > classViewHolder = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; return getFieldByType ( class1 , classViewHolder ) ; } ) ; } public static Method loadStatusUserMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var id = UnobfuscatorCache . getInstance ( ) . getOfuscateIDString ( "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) throw new Exception ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadSendPresenceMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPinnedLimitMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadPinnedHashSetMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new Exception ( "<STR_LIT>" ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getReturnType ( ) . equals ( Set . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new Exception ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetFiltersMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazzFilters = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazzFilters == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return Arrays . stream ( clazzFilters . getDeclaredMethods ( ) ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; } ) ; } public static Method loadPinnedInChatMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . returnType ( int . class ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadBlueOnReplayCreateMenuConversationMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var conversationClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; if ( conversationClass == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( conversationClass . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( Menu . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadBlueOnReplayViewButtonMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadBlueOnReplayStatusViewMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadChatLimitDeleteMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getReturnType ( ) . equals ( long . class ) && Modifier . isStatic ( m . getModifiers ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) { var methodList = Objects . requireNonNull ( dexkit . getClassData ( clazz ) ) . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . opCodes ( new OpCodesMatcher ( ) . opNames ( List . of ( "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ) ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; method = methodList . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } return method ; } ) ; } public static Method loadChatLimitDelete2Method ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadNewMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazzMessage = loadFMessageClass ( loader ) ; var clazzData = Objects . requireNonNull ( dexkit . getClassData ( clazzMessage ) ) ; var methodData = clazzData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) { var field = clazzMessage . getDeclaredField ( "<STR_LIT>" ) ; methodData = clazzData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field ) ) . returnType ( String . class ) ) ) ; } if ( methodData . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodData . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Method loadNewMessageWithMediaMethod ( ClassLoader loader ) throws Exception { var clazzMessage = Objects . requireNonNull ( dexkit . getClassData ( loadFMessageClass ( loader ) ) ) ; var methodData = clazzMessage . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) { methodData = clazzMessage . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . returnType ( String . class ) ) ) ; if ( methodData . isEmpty ( ) ) return null ; } return methodData . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } public static Method loadMessageEditMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetEditMessageMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; if ( methodData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( invoke . getParamTypes ( ) . isEmpty ( ) && Objects . equals ( invoke . getDeclaredClass ( ) , methodData . getParamTypes ( ) . get ( <NUM_LIT> ) ) ) { return invoke . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadSetEditMessageField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var classData = dexkit . getClassData ( loadFMessageClass ( loader ) ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var usingFields = methodData . getUsingFields ( ) ; for ( var f : usingFields ) { var field = f . getField ( ) ; if ( field . getDeclaredClass ( ) . equals ( classData ) && field . getType ( ) . getName ( ) . equals ( long . class . getName ( ) ) ) { return field . getFieldInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadEditMessageShowMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var fields = Arrays . stream ( clazz . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( TextView . class ) ) . toArray ( Field [ ] :: new ) ; var classData = dexkit . getClassData ( clazz ) ; if ( fields . length == <NUM_LIT> ) throw new RuntimeException ( "<STR_LIT>" ) ; for ( var field : fields ) { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field ) ) . paramCount ( <NUM_LIT> ) ) . searchInClass ( List . of ( classData ) ) ) ; if ( ! result . isEmpty ( ) ) return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadEditMessageViewField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = loadEditMessageShowMethod ( loader ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var fields = methodData . getUsingFields ( ) ; for ( var ufield : fields ) { var field = ufield . getField ( ) ; if ( field . getType ( ) . getName ( ) . equals ( TextView . class . getName ( ) ) ) { return field . getFieldInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Class loadDialogViewClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var id = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingNumber ( id ) . returnType ( FrameLayout . class ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getDeclaredClass ( ) . getInstance ( loader ) ; } ) ; } public static Constructor loadRecreateFragmentConstructor ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( loader , ( ) -> { var data = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( data . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; if ( ! data . single ( ) . isConstructor ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return data . single ( ) . getConstructorInstance ( loader ) ; } ) ; } public static Method loadOnTabItemAddMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return result ; } ) ; } public static Method loadScrollPagerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var result = findAllMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var method = Arrays . stream ( result ) . filter ( m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGetViewConversationMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = Arrays . stream ( clazz . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getReturnType ( ) . equals ( View . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( LayoutInflater . class ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadOnMenuItemSelected ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var aClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var result = Arrays . stream ( aClass . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( boolean . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( boolean . class ) ) . collect ( Collectors . toList ( ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) ; } ) ; } public static Method loadOnUpdateStatusChanged ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var clazz = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var clazzData = dexkit . getClassData ( clazz ) ; var methodSeduleche = XposedHelpers . findMethodBestMatch ( Timer . class , "<STR_LIT>" , TimerTask . class , long . class , long . class ) ; var result = dexkit . findMethod ( new FindMethod ( ) . searchInClass ( List . of ( clazzData ) ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( methodSeduleche ) ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadGetInvokeField ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( loader , ( ) -> { var method = loadOnUpdateStatusChanged ( loader ) ; var methodData = dexkit . getMethodData ( DexSignUtil . getMethodDescriptor ( method ) ) ; var fields = methodData . getUsingFields ( ) ; var field = fields . stream ( ) . map ( UsingFieldData :: getField ) . filter ( f -> f . getDeclaredClass ( ) . equals ( methodData . getDeclaredClass ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( field == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return field . getFieldInstance ( loader ) ; } ) ; } public static Class < ? > loadStatusInfoClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadStatusListUpdatesClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadTabFrameClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static List < Method > loadNineDrawableMethods ( ClassLoader loader ) throws Exception { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . returnType ( NinePatchDrawable . class ) . paramCount ( <NUM_LIT> ) ) ) ; if ( result . isEmpty ( ) ) return Collections . emptyList ( ) ; var arr = new ArrayList < Method > ( ) ; for ( var m : result ) { if ( m . isMethod ( ) ) arr . add ( m . getMethodInstance ( loader ) ) ; } return arr ; } public static Class loadOnMenuItemClickClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadOnMenuItemClickClass2 ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadRemoveChannelRecClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadFilterAdaperClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazzList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) ) ) ) ; if ( clazzList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazzList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadSeeMoreMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var classList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) . addUsingNumber ( <NUM_LIT> ) ) . addMethod ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( int . class ) . addParamType ( boolean . class ) ) ) ) ; if ( classList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var clazzData = classList . get ( <NUM_LIT> ) ; XposedBridge . log ( clazzData . toString ( ) ) ; for ( var method : clazzData . getMethods ( ) ) { if ( method . getParamCount ( ) == <NUM_LIT> && method . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( int . class . getName ( ) ) && method . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( boolean . class . getName ( ) ) ) { return method . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadSendStickerMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadMaterialAlertDialog ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var callConfirmationFragment = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = ReflectionUtils . findMethodUsingFilter ( callConfirmationFragment , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( android . os . Bundle . class ) ) ; var methodData = dexkit . getMethodData ( method ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( invoke . isMethod ( ) && Modifier . isStatic ( invoke . getModifiers ( ) ) && invoke . getParamCount ( ) == <NUM_LIT> && invoke . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( Context . class . getName ( ) ) ) { return invoke . getMethodInstance ( loader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadGetIntPreferences ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( SharedPreferences . class ) . addParamType ( String . class ) . modifiers ( Modifier . STATIC | Modifier . PUBLIC ) . returnType ( int . class ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodList . get ( <NUM_LIT> ) . getMethodInstance ( loader ) ; } ) ; } public static Field loadProfileInfoField ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var fieldList = ReflectionUtils . getFieldsByExtendType ( clazz , XposedHelpers . findClass ( "<STR_LIT>" , loader ) ) ; if ( fieldList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return fieldList . get ( <NUM_LIT> ) ; } public static Method loadProximitySensorMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadGroupAdminMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadJidFactory ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadGroupCheckAdminMethod ( ClassLoader loader ) throws Exception { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; var userJidClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var methods = ReflectionUtils . findAllMethodsUsingFilter ( clazz , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( userJidClass ) && m . getReturnType ( ) . equals ( boolean . class ) ) ; if ( methods == null || methods . length == <NUM_LIT> ) throw new RuntimeException ( "<STR_LIT>" ) ; return methods [ methods . length - <NUM_LIT> ] ; } public static Constructor loadStartPrefsConfig ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( loader , ( ) -> { var results = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getConstructorInstance ( loader ) ; } ) ; } public static Method loadCheckOnlineMethod ( ClassLoader loader ) throws Exception { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } public static Method loadEphemeralInsertdb ( ClassLoader loader ) throws Exception { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . addUsingString ( "<STR_LIT>" ) . returnType ( ContentValues . class ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var methodData = method . get ( <NUM_LIT> ) ; return methodData . getMethodInstance ( loader ) ; } public static Method loadDefEmojiClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var method = findFirstMethodUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Class loadVideoViewContainerClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadImageVewContainerClass ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazzList = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . addUsingNumber ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) . addUsingNumber ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) ) ; if ( clazzList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazzList . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Class loadMediaQualityProcessor ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var clazz = findFirstClassUsingStrings ( loader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method getFilterInitMethod ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( loader , ( ) -> { var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( loader ) ; var constructor = filterAdaperClass . getConstructors ( ) [ <NUM_LIT> ] ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( constructor ) ) ) ) ; if ( methods . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var method = methods . stream ( ) . filter ( m -> m . getParamCount ( ) == <NUM_LIT> && m . getParamTypes ( ) . get ( <NUM_LIT> ) . getName ( ) . equals ( cFrag . getName ( ) ) ) . findFirst ( ) . orElse ( null ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . getMethodInstance ( loader ) ; } ) ; } public static Class getFilterView ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var results = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addMethod ( new MethodMatcher ( ) . name ( "<STR_LIT>" ) ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Class loadActionUser ( ClassLoader loader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( loader , ( ) -> { var results = dexkit . findClass ( new FindClass ( ) . matcher ( new ClassMatcher ( ) . addUsingString ( "<STR_LIT>" ) ) ) ; if ( results . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return results . get ( <NUM_LIT> ) . getInstance ( loader ) ; } ) ; } public static Method loadOnPlaybackFinished ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadNextStatusRunMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var methodList = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . name ( "<STR_LIT>" ) ) ) ; if ( methodList . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methodList . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadOnInsertReceipt ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadSendAudioTypeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = classLoader . loadClass ( "<STR_LIT>" ) . getMethod ( "<STR_LIT>" , int . class , int . class , android . content . Intent . class ) ; var methodData = dexkit . getMethodData ( method ) ; var invokes = methodData . getInvokes ( ) ; for ( var invoke : invokes ) { if ( ! invoke . isMethod ( ) ) continue ; var m1 = invoke . getMethodInstance ( classLoader ) ; var params = Arrays . asList ( m1 . getParameterTypes ( ) ) ; if ( params . contains ( List . class ) && params . contains ( int . class ) && params . contains ( boolean . class ) && params . contains ( Uri . class ) ) { return m1 ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Field loadOriginFMessageField ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getField ( classLoader , ( ) -> { var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingString ( "<STR_LIT>" ) . paramCount ( <NUM_LIT> ) . returnType ( boolean . class ) ) ) ; var clazz = loadFMessageClass ( classLoader ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; var fields = result . get ( <NUM_LIT> ) . getUsingFields ( ) ; for ( var field : fields ) { var f = field . getField ( ) . getFieldInstance ( classLoader ) ; if ( f . getDeclaringClass ( ) . equals ( clazz ) ) { return f ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Method loadForwardAudioTypeMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var result = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( result == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return result ; } ) ; } public static Class loadFragmentLoader ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadShowDialogStatusMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var clazz = loadFragmentLoader ( classLoader ) ; var frag = classLoader . loadClass ( "<STR_LIT>" ) ; var result = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . addParamType ( frag ) . addParamType ( clazz ) . returnType ( void . class ) . modifiers ( Modifier . PUBLIC | Modifier . STATIC ) ) ) ; if ( result . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return result . get ( <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadPlaybackSpeed ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Constructor loadListUpdateItemsConstructor ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getConstructor ( classLoader , ( ) -> { var method = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . paramCount ( <NUM_LIT> ) . returnType ( void . class ) . addParamType ( Object . class ) . addUsingNumber ( <NUM_LIT> ) ) ) ; if ( method . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return method . get ( <NUM_LIT> ) . getClassInstance ( classLoader ) . getConstructors ( ) [ <NUM_LIT> ] ; } ) ; } public static Class loadHeaderChannelItemClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Class loadListChannelItemClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadTextStatusComposer ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method1 = Activity . class . getDeclaredMethod ( "<STR_LIT>" ) ; var method2 = View . class . getDeclaredMethod ( "<STR_LIT>" , Drawable . class ) ; var clazz = classLoader . loadClass ( "<STR_LIT>" ) ; var fieldInt = ReflectionUtils . findFieldUsingFilter ( clazz , field -> field . getType ( ) == int . class ) ; var classData = dexkit . getClassData ( clazz ) ; if ( classData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methods = classData . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method1 ) ) . addInvoke ( DexSignUtil . getMethodDescriptor ( method2 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( fieldInt ) ) . modifiers ( Modifier . PUBLIC | Modifier . STATIC ) ) ) ; if ( methods . isEmpty ( ) ) throw new RuntimeException ( "<STR_LIT>" ) ; return methods . get ( methods . size ( ) - <NUM_LIT> ) . getMethodInstance ( classLoader ) ; } ) ; } public static Method loadTextStatusComposer2 ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { Class < ? > TextDataClass = classLoader . loadClass ( "<STR_LIT>" ) ; var clazz = classLoader . loadClass ( "<STR_LIT>" ) ; var field1 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var field2 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var field3 = TextDataClass . getDeclaredField ( "<STR_LIT>" ) ; var classData = dexkit . getClassData ( clazz ) ; if ( classData == null ) throw new RuntimeException ( "<STR_LIT>" ) ; var methods = dexkit . findMethod ( new FindMethod ( ) . matcher ( new MethodMatcher ( ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field1 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field2 ) ) . addUsingField ( DexSignUtil . getFieldDescriptor ( field3 ) ) . modifiers ( Modifier . PUBLIC ) ) ) ; for ( var method : methods ) { var callers = method . getCallers ( ) ; if ( callers . stream ( ) . anyMatch ( methodData -> methodData . getDeclaredClassName ( ) . contains ( "<STR_LIT>" ) ) ) { return method . getMethodInstance ( classLoader ) ; } } throw new RuntimeException ( "<STR_LIT>" ) ; } ) ; } public static Class < ? > loadExpirationClass ( ClassLoader classLoader ) { var methods = findAllMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; var expirationMethod = Arrays . stream ( methods ) . filter ( methodData -> methodData . getReturnType ( ) . equals ( Date . class ) ) . findFirst ( ) . orElse ( null ) ; if ( expirationMethod == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return expirationMethod . getDeclaringClass ( ) ; } public static Class < ? > loadMsgDatabaseClass ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var aClass = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" , "<STR_LIT>" ) ; if ( aClass == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return aClass ; } ) ; } public static Class < ? > loadAbsViewHolder ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getClass ( classLoader , ( ) -> { var clazz = findFirstClassUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( clazz == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return clazz ; } ) ; } public static Method loadFragmentViewMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } public static Method loadCopiedMessageMethod ( ClassLoader classLoader ) throws Exception { return UnobfuscatorCache . getInstance ( ) . getMethod ( classLoader , ( ) -> { var method = findFirstMethodUsingStrings ( classLoader , StringMatchType . Contains , "<STR_LIT>" ) ; if ( method == null ) throw new RuntimeException ( "<STR_LIT>" ) ; return method ; } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core . components ; import android . content . ContextWrapper ; import android . content . SharedPreferences ; import androidx . annotation . Nullable ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; public class SharedPreferencesWrapper implements SharedPreferences { private final static HashSet < SPrefHook > prefHook = new HashSet < > ( ) ; private final SharedPreferences mPreferences ; public SharedPreferencesWrapper ( SharedPreferences sharedPreferences ) { mPreferences = sharedPreferences ; } @ Override public Map < String , ? > getAll ( ) { return mPreferences . getAll ( ) ; } @ Nullable @ Override public String getString ( String s , @ Nullable String s1 ) { var value = mPreferences . getString ( s , s1 ) ; return ( String ) hookValue ( s , value ) ; } @ Nullable @ Override public Set < String > getStringSet ( String s , @ Nullable Set < String > set ) { var value = mPreferences . getStringSet ( s , set ) ; return ( Set < String > ) hookValue ( s , value ) ; } @ Override public int getInt ( String s , int i ) { var value = mPreferences . getInt ( s , i ) ; return ( int ) hookValue ( s , value ) ; } @ Override public long getLong ( String s , long l ) { var value = mPreferences . getLong ( s , l ) ; return ( long ) hookValue ( s , value ) ; } @ Override public float getFloat ( String s , float v ) { var value = mPreferences . getFloat ( s , v ) ; return ( float ) hookValue ( s , value ) ; } @ Override public boolean getBoolean ( String s , boolean b ) { var value = mPreferences . getBoolean ( s , b ) ; return ( boolean ) hookValue ( s , value ) ; } @ Override public boolean contains ( String s ) { return mPreferences . contains ( s ) ; } @ Override public Editor edit ( ) { return mPreferences . edit ( ) ; } @ Override public void registerOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . registerOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; } @ Override public void unregisterOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . unregisterOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; } public static void hookInit ( ClassLoader classLoader ) { XposedHelpers . findAndHookMethod ( ContextWrapper . class . getName ( ) , classLoader , "<STR_LIT>" , String . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pref = ( SharedPreferences ) param . getResult ( ) ; if ( pref instanceof SharedPreferencesWrapper ) return ; param . setResult ( new SharedPreferencesWrapper ( pref ) ) ; } } ) ; } public static void addHook ( SPrefHook hook ) { prefHook . add ( hook ) ; } private Object hookValue ( String key , Object value ) { for ( SPrefHook hook : prefHook ) { value = hook . hookValue ( key , value ) ; } return value ; } public interface SPrefHook { @ Nullable Object hookValue ( String key , Object value ) ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . ViewGroup ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CompletableFuture ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import kotlin . io . FilesKt ; import rikka . core . util . IOUtils ; public class TextEditorActivity extends AppCompatActivity { private String folderName ; private ActivityResultLauncher < String > mGetContent ; private ActivityResultLauncher < String > mExportFile ; private WebView webView ; @ SuppressLint ( "<STR_LIT>" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; super . onCreate ( savedInstanceState ) ; webView = new WebView ( this ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . getSettings ( ) . setAllowContentAccess ( true ) ; webView . getSettings ( ) . setDomStorageEnabled ( true ) ; webView . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( true ) ; webView . getSettings ( ) . setJavaScriptCanOpenWindowsAutomatically ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) ) ; webView . setWebChromeClient ( new WebChromeClient ( ) ) ; updateWebViewContent ( "<STR_LIT>" ) ; setContentView ( webView , new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; mGetContent = registerForActivityResult ( new ActivityResultContracts . GetContent ( ) , this :: onUriSelected ) ; mExportFile = registerForActivityResult ( new ActivityResultContracts . CreateDocument ( "<STR_LIT>" ) , this :: exportAsZip ) ; folderName = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { readFile ( folderName ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void updateWebViewContent ( String newContent ) { if ( webView != null ) { try { var inputStream = getAssets ( ) . open ( "<STR_LIT>" ) ; var code = IOUtils . toString ( inputStream ) ; code = code . replace ( "<STR_LIT>" , newContent ) ; webView . loadDataWithBaseURL ( "<STR_LIT>" , code , "<STR_LIT>" , "<STR_LIT>" , null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } private CompletableFuture < String > getTextareaContentAsync ( ) { CompletableFuture < String > future = new CompletableFuture < > ( ) ; if ( webView != null ) { webView . evaluateJavascript ( "<STR_LIT>" , content -> { if ( content != null ) { content = content . substring ( <NUM_LIT> , content . length ( ) - <NUM_LIT> ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) ; } future . complete ( content ) ; } ) ; } else { future . completeExceptionally ( new Exception ( "<STR_LIT>" ) ) ; } return future ; } private void readFile ( String folderName ) { try { File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , "<STR_LIT>" ) ; if ( cssCode . exists ( ) ) { var code = FilesKt . readText ( cssCode , Charset . defaultCharset ( ) ) ; updateWebViewContent ( code ) ; } else { cssCode . createNewFile ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . css_editor_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) { case R . id . menuitem_save -> { try { getTextareaContentAsync ( ) . thenAccept ( content -> { String code = content ; File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , "<STR_LIT>" ) ; FilesKt . writeText ( cssCode , code , Charset . defaultCharset ( ) ) ; Toast . makeText ( this , R . string . saved , Toast . LENGTH_SHORT ) . show ( ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; var key = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; if ( key != null && prefs . getString ( key , "<STR_LIT>" ) . equals ( folderName ) ) { prefs . edit ( ) . putString ( "<STR_LIT>" , code ) . commit ( ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } case R . id . menuitem_exit -> finish ( ) ; case R . id . menuitem_clear -> { updateWebViewContent ( "<STR_LIT>" ) ; } case R . id . menuitem_import_image -> { mGetContent . launch ( "<STR_LIT>" ) ; } case R . id . menuitem_export -> { mExportFile . launch ( folderName + "<STR_LIT>" ) ; } } return super . onOptionsItemSelected ( item ) ; } private void exportAsZip ( Uri uri ) { try ( var outputStream = getContentResolver ( ) . openOutputStream ( uri ) ) { var zipOutputStream = new ZipOutputStream ( outputStream ) ; var dir = ThemePreference . rootDirectory . getAbsolutePath ( ) + "<STR_LIT>" ; var folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; var files = getAllFilesPath ( folderFolder ) ; for ( File file : files ) { var name = file . getAbsolutePath ( ) . replace ( dir , "<STR_LIT>" ) ; zipOutputStream . putNextEntry ( new ZipEntry ( name ) ) ; var bytes = FilesKt . readBytes ( file ) ; zipOutputStream . write ( bytes ) ; zipOutputStream . closeEntry ( ) ; } zipOutputStream . close ( ) ; Toast . makeText ( this , R . string . exported , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , <NUM_LIT> ) ; } } private List < File > getAllFilesPath ( File folderFolder ) { File [ ] files = folderFolder . listFiles ( ) ; if ( files == null ) { return Collections . emptyList ( ) ; } ArrayList < File > list = new ArrayList < > ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { list . addAll ( getAllFilesPath ( file ) ) ; } else { list . add ( file ) ; } } return list ; } public void onUriSelected ( Uri uri ) { if ( uri == null ) { return ; } var linearLayout = new LinearLayout ( this ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; var input = new EditText ( this ) ; input . setHint ( "<STR_LIT>" ) ; input . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; linearLayout . addView ( input ) ; new AlertDialog . Builder ( this ) . setTitle ( R . string . enter_image_file_name ) . setPositiveButton ( "<STR_LIT>" , ( dialog , which ) -> { var fileName = input . getText ( ) . toString ( ) ; if ( fileName . endsWith ( "<STR_LIT>" ) ) { copyFromUri ( fileName , uri ) ; } else { Toast . makeText ( this , R . string . error_image_name , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . setView ( linearLayout ) . show ( ) ; } public void copyFromUri ( String fileName , Uri uri ) { var outFolder = new File ( ThemePreference . rootDirectory , folderName ) ; try ( InputStream inputStream = getContentResolver ( ) . openInputStream ( uri ) ) { Bitmap bitmap = BitmapFactory . decodeStream ( inputStream ) ; var outFile = new File ( outFolder , fileName ) ; FileOutputStream out = new FileOutputStream ( outFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , out ) ; out . close ( ) ; Toast . makeText ( this , getString ( R . string . imported_as ) + fileName , Toast . LENGTH_LONG ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( this , "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import java . io . ByteArrayOutputStream ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; public abstract class HKDF { public static HKDF createFor ( int version ) { if ( version == <NUM_LIT> ) { return new HKDFv3 ( ) ; } throw new AssertionError ( "<STR_LIT>" + version ) ; } public byte [ ] deriveSecrets ( byte [ ] arr_b , byte [ ] arr_b1 , int v ) { return this . deriveSecrets ( arr_b , new byte [ <NUM_LIT> ] , arr_b1 , v ) ; } public byte [ ] deriveSecrets ( byte [ ] inputKeyMaterial , byte [ ] salt , byte [ ] info , int outputLength ) { byte [ ] derivedKey ; try { Mac mac = Mac . getInstance ( "<STR_LIT>" ) ; mac . init ( new SecretKeySpec ( salt , "<STR_LIT>" ) ) ; derivedKey = mac . doFinal ( inputKeyMaterial ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException e ) { throw new AssertionError ( e ) ; } try { int iterations = ( int ) Math . ceil ( ( ( double ) outputLength ) / <NUM_LIT> ) ; byte [ ] outputKey = new byte [ <NUM_LIT> ] ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; for ( int i = getIterationStartOffset ( ) ; i < getIterationStartOffset ( ) + iterations ; ++ i ) { Mac macIteration = Mac . getInstance ( "<STR_LIT>" ) ; macIteration . init ( new SecretKeySpec ( derivedKey , "<STR_LIT>" ) ) ; macIteration . update ( outputKey ) ; if ( info != null ) { macIteration . update ( info ) ; } macIteration . update ( ( byte ) i ) ; outputKey = macIteration . doFinal ( ) ; int remainingLength = Math . min ( outputLength , outputKey . length ) ; outputStream . write ( outputKey , <NUM_LIT> , remainingLength ) ; outputLength -= remainingLength ; } return outputStream . toByteArray ( ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException ex ) { throw new AssertionError ( ex ) ; } } protected abstract int getIterationStartOffset ( ) ; } </s>
<s> package com . wmods . wppenhacer . adapter ; import android . content . Context ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; public class MessageAdapter extends ArrayAdapter < MessageHistory . MessageItem > { private final Context context ; private final List < MessageHistory . MessageItem > items ; public MessageAdapter ( Context context , List < MessageHistory . MessageItem > items ) { super ( context , android . R . layout . simple_list_item_2 , android . R . id . text1 , items ) ; this . context = context ; this . items = items ; } @ Override public int getCount ( ) { return items . size ( ) ; } @ Override public MessageHistory . MessageItem getItem ( int position ) { return items . get ( position ) ; } @ Override public long getItemId ( int position ) { return position ; } @ NonNull @ Override public View getView ( int position , View convertView , @ NonNull ViewGroup parent ) { View view1 = super . getView ( position , convertView , parent ) ; TextView textView0 = view1 . findViewById ( android . R . id . text1 ) ; textView0 . setTextSize ( <NUM_LIT> ) ; textView0 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView0 . setText ( this . items . get ( position ) . message ) ; TextView textView1 = view1 . findViewById ( android . R . id . text2 ) ; textView1 . setTextSize ( <NUM_LIT> ) ; textView1 . setAlpha ( <NUM_LIT> ) ; textView1 . setTypeface ( null , Typeface . ITALIC ) ; textView1 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; var timestamp = this . items . get ( position ) . timestamp ; textView1 . setText ( ( timestamp == <NUM_LIT> ? context . getString ( ResId . string . message_original ) : "<STR_LIT>" + Utils . getDateTimeFromMillis ( timestamp ) ) ) ; return view1 ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments . base ; import android . view . View ; import android . widget . Toast ; import androidx . annotation . IdRes ; import androidx . annotation . StringRes ; import androidx . appcompat . widget . Toolbar ; import androidx . core . view . MenuProvider ; import androidx . fragment . app . Fragment ; import androidx . navigation . NavController ; import androidx . navigation . NavDirections ; import androidx . navigation . fragment . NavHostFragment ; import com . google . android . material . snackbar . Snackbar ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . R ; import java . util . concurrent . Callable ; import java . util . concurrent . Future ; import java . util . concurrent . FutureTask ; public class BaseFragment extends Fragment { public void navigateUp ( ) { getNavController ( ) . navigateUp ( ) ; } public NavController getNavController ( ) { return NavHostFragment . findNavController ( this ) ; } public boolean safeNavigate ( @ IdRes int resId ) { try { getNavController ( ) . navigate ( resId ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public boolean safeNavigate ( NavDirections direction ) { try { getNavController ( ) . navigate ( direction ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public void setupToolbar ( Toolbar toolbar , View tipsView , int title ) { setupToolbar ( toolbar , tipsView , getString ( title ) , - <NUM_LIT> ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , int title , int menu ) { setupToolbar ( toolbar , tipsView , getString ( title ) , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu ) { setupToolbar ( toolbar , tipsView , title , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu , View . OnClickListener navigationOnClickListener ) { toolbar . setNavigationOnClickListener ( navigationOnClickListener == null ? ( v -> navigateUp ( ) ) : navigationOnClickListener ) ; toolbar . setNavigationIcon ( R . drawable . ic_baseline_arrow_back_24 ) ; toolbar . setTitle ( title ) ; toolbar . setTooltipText ( title ) ; if ( tipsView != null ) tipsView . setTooltipText ( title ) ; if ( menu != - <NUM_LIT> ) { toolbar . inflateMenu ( menu ) ; if ( this instanceof MenuProvider self ) { toolbar . setOnMenuItemClickListener ( self :: onMenuItemSelected ) ; self . onPrepareMenu ( toolbar . getMenu ( ) ) ; } } } public void runAsync ( Runnable runnable ) { App . getExecutorService ( ) . submit ( runnable ) ; } public < T > Future < T > runAsync ( Callable < T > callable ) { return App . getExecutorService ( ) . submit ( callable ) ; } public void runOnUiThread ( Runnable runnable ) { App . getMainHandler ( ) . post ( runnable ) ; } public < T > Future < T > runOnUiThread ( Callable < T > callable ) { var task = new FutureTask < > ( callable ) ; runOnUiThread ( task ) ; return task ; } public void showHint ( @ StringRes int res , boolean lengthShort , @ StringRes int actionRes , View . OnClickListener action ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , App . getInstance ( ) . getString ( actionRes ) , action ) ; } public void showHint ( @ StringRes int res , boolean lengthShort ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort ) { showHint ( str , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort , CharSequence actionStr , View . OnClickListener action ) { var container = getView ( ) ; if ( isResumed ( ) && container != null ) { var snackbar = Snackbar . make ( container , str , lengthShort ? Snackbar . LENGTH_SHORT : Snackbar . LENGTH_LONG ) ; if ( actionStr != null && action != null ) snackbar . setAction ( actionStr , action ) ; snackbar . show ( ) ; return ; } runOnUiThread ( ( ) -> { try { Toast . makeText ( App . getInstance ( ) , str , lengthShort ? Toast . LENGTH_SHORT : Toast . LENGTH_LONG ) . show ( ) ; } catch ( Throwable ignored ) { } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import android . os . Message ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallPrivacy extends Feature { public CallPrivacy ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var onCallReceivedMethod = Unobfuscator . loadAntiRevokeOnCallReceivedMethod ( classLoader ) ; XposedBridge . hookMethod ( onCallReceivedMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { Object callinfo = ( ( Message ) param . args [ <NUM_LIT> ] ) . obj ; Class < ? > callInfoClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; if ( callinfo == null || ! callInfoClass . isInstance ( callinfo ) ) return ; if ( ( boolean ) XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ) return ; var userJid = XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ; var callId = XposedHelpers . callMethod ( callinfo , "<STR_LIT>" ) ; var type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; Tasker . sendTaskerEvent ( WppCore . getContactName ( userJid ) , WppCore . stripJID ( WppCore . getRawString ( userJid ) ) , "<STR_LIT>" ) ; var blockCall = checkCallBlock ( userJid , type ) ; if ( ! blockCall ) return ; var clazzVoip = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var rejectType = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; switch ( rejectType ) { case "<STR_LIT>" : case "<STR_LIT>" : var rejectCallMethod = ReflectionUtils . findMethodUsingFilter ( clazzVoip , m -> m . getName ( ) . equals ( "<STR_LIT>" ) ) ; var obj = new Object [ rejectCallMethod . getParameterCount ( ) ] ; obj [ <NUM_LIT> ] = callId ; obj [ <NUM_LIT> ] = "<STR_LIT>" . equals ( rejectType ) ? null : rejectType ; if ( obj . length > <NUM_LIT> ) { obj [ <NUM_LIT> ] = <NUM_LIT> ; } ReflectionUtils . callMethod ( rejectCallMethod , null , obj ) ; param . setResult ( true ) ; break ; case "<STR_LIT>" : try { XposedHelpers . callStaticMethod ( clazzVoip , "<STR_LIT>" , true ) ; } catch ( NoSuchMethodError e ) { XposedHelpers . callStaticMethod ( clazzVoip , "<STR_LIT>" , true , <NUM_LIT> ) ; } param . setResult ( true ) ; break ; default : } } } ) ; XposedBridge . hookAllMethods ( classLoader . loadClass ( "<STR_LIT>" ) , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) . equals ( "<STR_LIT>" ) ) return ; var userJid = param . args [ <NUM_LIT> ] ; var type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var block = checkCallBlock ( userJid , type ) ; if ( block ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; } public boolean checkCallBlock ( Object userJid , int type ) throws IllegalAccessException , InvocationTargetException { if ( type == <NUM_LIT> ) return false ; if ( type == <NUM_LIT> ) return true ; var jid = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; if ( jid == null ) return false ; switch ( type ) { case <NUM_LIT> : if ( WppCore . stripJID ( jid ) . equals ( jid ) ) { jid = jid . split ( "<STR_LIT>" ) [ <NUM_LIT> ] + "<STR_LIT>" ; } var contactName = WppCore . getSContactName ( WppCore . createUserJid ( jid ) , true ) ; return TextUtils . isEmpty ( contactName ) || contactName . equals ( jid ) ; case <NUM_LIT> : var callBlockList = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var blockList = Arrays . stream ( callBlockList . substring ( <NUM_LIT> , callBlockList . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var blockNumber : blockList ) { if ( ! TextUtils . isEmpty ( blockNumber ) && jid . contains ( blockNumber ) ) { return true ; } } return false ; case <NUM_LIT> : var callWhiteList = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var whiteList = Arrays . stream ( callWhiteList . substring ( <NUM_LIT> , callWhiteList . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var whiteNumber : whiteList ) { if ( ! TextUtils . isEmpty ( whiteNumber ) && jid . contains ( whiteNumber ) ) { return false ; } } return true ; } return false ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Dialog ; import android . content . Intent ; import android . net . Uri ; import android . os . BaseBundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallType extends Feature { private XC_MethodHook . Unhook hookBundleBoolean ; public CallType ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var intPreferences = Unobfuscator . loadGetIntPreferences ( classLoader ) ; XposedBridge . hookMethod ( intPreferences , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var callConfirmationFragment = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var method = ReflectionUtils . findMethodUsingFilter ( callConfirmationFragment , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( android . os . Bundle . class ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { private boolean isVideoCall ; private String jid ; private Dialog newDialog ; private Unhook hookBundleString ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString = XposedHelpers . findAndHookMethod ( BaseBundle . class , "<STR_LIT>" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { jid = ( String ) param . getResult ( ) ; } } } ) ; hookBundleBoolean = XposedHelpers . findAndHookMethod ( BaseBundle . class , "<STR_LIT>" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == "<STR_LIT>" ) { isVideoCall = ( boolean ) param . getResult ( ) ; } } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString . unhook ( ) ; hookBundleBoolean . unhook ( ) ; if ( jid == null || isVideoCall ) return ; var origDialog = ( Dialog ) param . getResult ( ) ; var context = origDialog . getContext ( ) ; var mAlertDialog = new AlertDialogWpp ( origDialog . getContext ( ) ) ; mAlertDialog . setTitle ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; mAlertDialog . setItems ( new String [ ] { context . getString ( ResId . string . phone_call ) , context . getString ( ResId . string . whatsapp_call ) } , ( dialog , which ) -> { newDialog . dismiss ( ) ; switch ( which ) { case <NUM_LIT> : var intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_DIAL ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + WppCore . stripJID ( jid ) ) ) ; context . startActivity ( intent ) ; break ; case <NUM_LIT> : origDialog . show ( ) ; break ; } } ) ; newDialog = mAlertDialog . create ( ) ; param . setResult ( newDialog ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . text . InputType ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . EditText ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class NewChat extends Feature { public NewChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) { var homeActivity = findClass ( "<STR_LIT>" , classLoader ) ; var newSettings = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; XposedHelpers . findAndHookMethod ( homeActivity , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . new_chat ) ; var drawable = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( item1 -> { var view = new LinearLayout ( activity ) ; view . setGravity ( Gravity . CENTER ) ; view . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; var edt = new EditText ( view . getContext ( ) ) ; edt . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; edt . setMaxLines ( <NUM_LIT> ) ; edt . setInputType ( InputType . TYPE_CLASS_PHONE ) ; edt . setTransformationMethod ( null ) ; edt . setHint ( ResId . string . number_with_country_code ) ; view . addView ( edt ) ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . new_chat ) ) . setView ( view ) . setPositiveButton ( activity . getString ( ResId . string . message ) , ( dialog , which ) -> { var number = edt . getText ( ) . toString ( ) ; var numberFomatted = number . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; var intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" + numberFomatted ) ) ; intent . setPackage ( Utils . getApplication ( ) . getPackageName ( ) ) ; activity . startActivity ( intent ) ; } ) . setNegativeButton ( activity . getString ( ResId . string . cancel ) , null ) . show ( ) ; return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . graphics . drawable . Drawable ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class TabDialogContent extends LinearLayout { private TextView mTitle ; private LinearLayout contentLinear ; public TabDialogContent ( Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { var params = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; setLayoutParams ( params ) ; setOrientation ( VERTICAL ) ; setBackground ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimarySurfaceColor ( ) ) ) ; setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; LinearLayout layoutLine = new LinearLayout ( context ) ; layoutLine . setOrientation ( LinearLayout . HORIZONTAL ) ; var layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL ; layoutParams . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutLine . setLayoutParams ( layoutParams ) ; ImageView imageView = new ImageView ( context ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , LinearLayout . LayoutParams . MATCH_PARENT ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimaryTextColor ( ) ) ) ; layoutLine . addView ( imageView ) ; addView ( layoutLine ) ; mTitle = new TextView ( context ) ; var paramsTitle = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTitle . gravity = Gravity . CENTER ; paramsTitle . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mTitle . setLayoutParams ( paramsTitle ) ; mTitle . setGravity ( Gravity . CENTER ) ; mTitle . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; mTitle . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; mTitle . setTypeface ( null , Typeface . BOLD ) ; addView ( mTitle ) ; var view = new View ( context ) ; var paramsView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; paramsView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; view . setLayoutParams ( paramsView ) ; view . setBackgroundColor ( Color . GRAY ) ; addView ( view ) ; contentLinear = new LinearLayout ( context ) ; contentLinear . setOrientation ( LinearLayout . HORIZONTAL ) ; contentLinear . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var paramsContent = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsContent . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; contentLinear . setLayoutParams ( paramsContent ) ; addView ( contentLinear ) ; } public void setTitle ( String title ) { mTitle . setText ( title ) ; } public void addTab ( String title , @ Nullable Drawable image , @ Nullable View . OnClickListener listener ) { var linearLayout = new LinearLayout ( getContext ( ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER ) ; var params = new LinearLayout . LayoutParams ( <NUM_LIT> , LinearLayout . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> ) ; linearLayout . setLayoutParams ( params ) ; linearLayout . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; linearLayout . setBackground ( DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimaryTextColor ( ) ) ) ; linearLayout . setOnClickListener ( listener ) ; var imageView = new ImageView ( getContext ( ) ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( image ) ; linearLayout . addView ( imageView ) ; var textView = new TextView ( getContext ( ) ) ; var paramsTextView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTextView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; textView . setLayoutParams ( paramsTextView ) ; textView . setText ( title ) ; textView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; textView . setTypeface ( null , Typeface . BOLD ) ; linearLayout . addView ( textView ) ; contentLinear . addView ( linearLayout ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Bitmap ; import android . graphics . RecordingCanvas ; import android . os . Build ; import android . util . Pair ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Others ; import org . json . JSONObject ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MediaQuality extends Feature { public MediaQuality ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var videoQuality = prefs . getBoolean ( "<STR_LIT>" , false ) ; var imageQuality = prefs . getBoolean ( "<STR_LIT>" , false ) ; Others . propsBoolean . put ( <NUM_LIT> , false ) ; if ( videoQuality ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; var jsonProperty = Unobfuscator . loadPropsJsonMethod ( classLoader ) ; XposedBridge . hookMethod ( jsonProperty , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var json = ( JSONObject ) param . getResult ( ) ; for ( int i = <NUM_LIT> ; i < json . length ( ) ; i ++ ) { var key = ( String ) json . names ( ) . opt ( i ) ; var jSONObject = json . getJSONObject ( key ) ; jSONObject . put ( "<STR_LIT>" , <NUM_LIT> ) ; jSONObject . put ( "<STR_LIT>" , <NUM_LIT> ) ; } } } } ) ; var resolutionMethod = Unobfuscator . loadMediaQualityResolutionMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( resolutionMethod ) ) ; XposedBridge . hookMethod ( resolutionMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var pair = new Pair < > ( param . args [ <NUM_LIT> ] , param . args [ <NUM_LIT> ] ) ; param . setResult ( pair ) ; } } ) ; var bitrateMethod = Unobfuscator . loadMediaQualityBitrateMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bitrateMethod ) ) ; XposedBridge . hookMethod ( bitrateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { param . setResult ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; } } ) ; var videoMethod = Unobfuscator . loadMediaQualityVideoMethod2 ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( videoMethod ) ) ; XposedBridge . hookMethod ( videoMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var resizeVideo = param . getResult ( ) ; var originalVieo = param . args [ <NUM_LIT> ] ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { var widthDest = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var heightDest = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var landscapeDest = widthDest > heightDest ; var widthDest2 = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var heightDest2 = XposedHelpers . getIntField ( resizeVideo , "<STR_LIT>" ) ; var landscapeDest2 = widthDest2 > heightDest2 ; var widthSrc = XposedHelpers . getIntField ( originalVieo , "<STR_LIT>" ) ; var heightSrc = XposedHelpers . getIntField ( originalVieo , "<STR_LIT>" ) ; var rotation = ( landscapeDest2 != landscapeDest ) ; XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , rotation ? heightSrc : widthSrc ) ; XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , rotation ? widthSrc : heightSrc ) ; } if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { XposedHelpers . setIntField ( resizeVideo , "<STR_LIT>" , <NUM_LIT> ) ; } } } } ) ; var videoLimitClass = Unobfuscator . loadMediaQualityVideoLimitClass ( classLoader ) ; logDebug ( videoLimitClass ) ; XposedHelpers . findAndHookConstructor ( videoLimitClass , int . class , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } } ) ; } if ( imageQuality ) { int [ ] props = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; int max = <NUM_LIT> ; int min = <NUM_LIT> ; for ( int index = <NUM_LIT> ; index < props . length ; index ++ ) { if ( index <= <NUM_LIT> ) { Others . propsInteger . put ( props [ index ] , min ) ; } else { Others . propsInteger . put ( props [ index ] , max ) ; } } Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; var mediaQualityProcessor = Unobfuscator . loadMediaQualityProcessor ( classLoader ) ; XposedBridge . hookAllConstructors ( mediaQualityProcessor , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { XposedHelpers . findAndHookMethod ( RecordingCanvas . class , "<STR_LIT>" , Bitmap . class , XC_MethodReplacement . DO_NOTHING ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import android . content . res . ColorStateList ; import android . graphics . Bitmap ; import android . graphics . NinePatch ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . DrawableContainer ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . NinePatchDrawable ; import android . graphics . drawable . RippleDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . StateListDrawable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class DrawableColors { private static final HashMap < Bitmap , Integer > ninePatchs = new HashMap < > ( ) ; public static void replaceColor ( Drawable drawable , HashMap < String , String > colors ) { if ( DesignUtils . isNightMode ( ) ) { colors . remove ( "<STR_LIT>" ) ; } if ( drawable instanceof StateListDrawable stateListDrawable ) { var count = StateListDrawableCompact . getStateCount ( stateListDrawable ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var stateDrawable = StateListDrawableCompact . getStateDrawable ( stateListDrawable , i ) ; if ( stateDrawable != null ) replaceColor ( stateDrawable , colors ) ; } } else if ( drawable instanceof DrawableContainer drawableContainer ) { var containerState = drawableContainer . getConstantState ( ) ; var drawables = ( Drawable [ ] ) XposedHelpers . getObjectField ( containerState , "<STR_LIT>" ) ; for ( var drawable1 : drawables ) { replaceColor ( drawable1 , colors ) ; } } else if ( drawable instanceof LayerDrawable layerDrawable ) { var layerState = layerDrawable . getConstantState ( ) ; var mChildren = ( Object [ ] ) XposedHelpers . getObjectField ( layerState , "<STR_LIT>" ) ; for ( var childDrawable : mChildren ) { if ( childDrawable != null ) { var drawable1 = ( Drawable ) XposedHelpers . getObjectField ( childDrawable , "<STR_LIT>" ) ; replaceColor ( drawable1 , colors ) ; } } } else if ( drawable instanceof GradientDrawable gradientDrawable ) { var gradientColors = gradientDrawable . getColors ( ) ; if ( gradientColors != null ) { for ( var i = <NUM_LIT> ; i < gradientColors . length ; i ++ ) { var gradientColor = IColors . toString ( gradientColors [ i ] ) ; var newColor = colors . get ( gradientColor ) ; if ( newColor != null ) { gradientColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! gradientColor . startsWith ( "<STR_LIT>" ) && ! gradientColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = gradientColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( gradientColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) gradientColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } gradientDrawable . setColors ( gradientColors ) ; } } else if ( drawable instanceof InsetDrawable insetDrawable ) { replaceColor ( insetDrawable . getDrawable ( ) , colors ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { var color = getNinePatchDrawableColor ( ninePatchDrawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { ninePatchDrawable . setTintList ( ColorStateList . valueOf ( parseColor ( newColor ) ) ) ; } } else { if ( drawable == null ) return ; var color = getColor ( drawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } else { if ( ! sColor . startsWith ( "<STR_LIT>" ) && ! sColor . startsWith ( "<STR_LIT>" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( sColorSub + newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } } } } } public static int getColor ( Drawable drawable ) { if ( drawable == null ) return <NUM_LIT> ; int color = <NUM_LIT> ; if ( drawable instanceof ColorDrawable colorDrawable ) { color = getColorDrawableColor ( colorDrawable ) ; } else if ( drawable instanceof ShapeDrawable shapeDrawable ) { color = getShapeDrawableColor ( shapeDrawable ) ; } else if ( drawable instanceof RippleDrawable rippleDrawable ) { color = getRippleDrawableColor ( rippleDrawable ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { color = getNinePatchDrawableColor ( ninePatchDrawable ) ; } else if ( drawable instanceof InsetDrawable insetDrawable ) { color = getInsetDrawableColor ( insetDrawable ) ; } return color ; } private static int getInsetDrawableColor ( InsetDrawable insetDrawable ) { var mDrawable = ( Drawable ) XposedHelpers . getObjectField ( insetDrawable , "<STR_LIT>" ) ; return getColor ( mDrawable ) ; } public static int getNinePatchDrawableColor ( NinePatchDrawable ninePatchDrawable ) { var state = ninePatchDrawable . getConstantState ( ) ; var ninePatch = ( NinePatch ) XposedHelpers . getObjectField ( state , "<STR_LIT>" ) ; var bitmap = ninePatch . getBitmap ( ) ; var corSalva = ninePatchs . get ( bitmap ) ; if ( corSalva != null ) return corSalva ; HashMap < Integer , Integer > contagemCores = new HashMap < > ( ) ; int corMaisFrequente = <NUM_LIT> ; int contagemMaxima = <NUM_LIT> ; for ( int x = <NUM_LIT> ; x < bitmap . getWidth ( ) ; x ++ ) { for ( int y = <NUM_LIT> ; y < bitmap . getHeight ( ) ; y ++ ) { int cor = bitmap . getPixel ( x , y ) ; int contagemAtual = contagemCores . getOrDefault ( cor , <NUM_LIT> ) + <NUM_LIT> ; contagemCores . put ( cor , contagemAtual ) ; if ( contagemAtual > contagemMaxima ) { corMaisFrequente = cor ; contagemMaxima = contagemAtual ; } } } ninePatchs . put ( bitmap , corMaisFrequente ) ; return corMaisFrequente ; } private static int getRippleDrawableColor ( RippleDrawable rippleDrawable ) { var state = rippleDrawable . getConstantState ( ) ; var rippleStateClass = XposedHelpers . findClass ( "<STR_LIT>" , loader1 ) ; try { return XposedHelpers . getIntField ( state , "<STR_LIT>" ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; return <NUM_LIT> ; } } public static int getColorDrawableColor ( ColorDrawable colorDrawable ) { return colorDrawable . getColor ( ) ; } public static int getShapeDrawableColor ( ShapeDrawable shapeDrawable ) { return shapeDrawable . getPaint ( ) . getColor ( ) ; } } </s>
<s> package com . wmods . wppenhacer ; import android . Manifest ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Environment ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . Fragment ; import androidx . viewpager2 . widget . ViewPager2 ; import com . google . android . material . navigation . NavigationBarView ; import com . wmods . wppenhacer . activities . AboutActivity ; import com . wmods . wppenhacer . adapter . MainPagerAdapter ; import com . wmods . wppenhacer . databinding . ActivityMainBinding ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; public class MainActivity extends AppCompatActivity { private ActivityMainBinding binding ; public static File mainDir ; @ Override protected void onCreate ( Bundle savedInstanceState ) { setTheme ( R . style . AppTheme ) ; getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; App . changeLanguage ( this ) ; super . onCreate ( savedInstanceState ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayShowHomeEnabled ( true ) ; getSupportActionBar ( ) . setIcon ( R . mipmap . launcher ) ; } binding = ActivityMainBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; MainPagerAdapter pagerAdapter = new MainPagerAdapter ( this ) ; binding . viewPager . setAdapter ( pagerAdapter ) ; binding . navView . setOnItemSelectedListener ( new NavigationBarView . OnItemSelectedListener ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override public boolean onNavigationItemSelected ( @ NonNull MenuItem item ) { return switch ( item . getItemId ( ) ) { case R . id . navigation_home -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_chat -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_privacy -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_media -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_colors -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } default -> false ; } ; } } ) ; binding . viewPager . registerOnPageChangeCallback ( new ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; binding . navView . getMenu ( ) . getItem ( position ) . setChecked ( true ) ; } } ) ; setupPermissions ( ) ; createMainDir ( ) ; FilePicker . registerFilePicker ( this ) ; } private void setupPermissions ( ) { ArrayList < String > permissions = new ArrayList < > ( ) ; if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_MEDIA_IMAGES ) != PackageManager . PERMISSION_GRANTED && Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { permissions . add ( Manifest . permission . READ_MEDIA_IMAGES ) ; } if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { permissions . add ( Manifest . permission . READ_EXTERNAL_STORAGE ) ; } if ( ! permissions . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , permissions . toArray ( new String [ <NUM_LIT> ] ) , <NUM_LIT> ) ; } } private void createMainDir ( ) { mainDir = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) , "<STR_LIT>" ) ; if ( ! mainDir . exists ( ) ) { mainDir . mkdir ( ) ; } var nomedia = new File ( mainDir , "<STR_LIT>" ) ; if ( ! nomedia . exists ( ) ) { try { nomedia . createNewFile ( ) ; } catch ( IOException ignored ) { } } } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; for ( Fragment fragment : getSupportFragmentManager ( ) . getFragments ( ) ) { fragment . onActivityResult ( requestCode , resultCode , data ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . header_menu , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { if ( item . getItemId ( ) == R . id . menu_about ) { startActivity ( new Intent ( this , AboutActivity . class ) ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } public static boolean isXposedEnabled ( ) { return false ; } } </s>
<s> package com . wmods . wppenhacer . views ; import static de . robv . android . xposed . XposedBridge . log ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . view . WindowManager ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileOutputStream ; import java . util . Properties ; import de . robv . android . xposed . XSharedPreferences ; @ SuppressLint ( "<STR_LIT>" ) public class WallpaperView extends FrameLayout { private final XSharedPreferences prefs ; private final Properties properties ; public WallpaperView ( @ NonNull Context context , XSharedPreferences preferences , Properties properties ) { super ( context ) ; this . prefs = preferences ; this . properties = properties ; init ( context ) ; } private void init ( Context context ) { ImageView bgView = new ImageView ( context ) ; bgView . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . MATCH_PARENT , FrameLayout . LayoutParams . MATCH_PARENT ) ) ; bgView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; bgView . setAdjustViewBounds ( false ) ; try { String image = ThemePreference . rootDirectory . getAbsolutePath ( ) + "<STR_LIT>" + prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) + "<STR_LIT>" + properties . getProperty ( "<STR_LIT>" ) ; if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { image = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } Drawable drawable = getDrawableImage ( image ) ; bgView . setImageDrawable ( drawable ) ; addView ( bgView ) ; } catch ( Exception e ) { log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private Drawable getDrawableImage ( String imagePath ) throws Exception { var fileOut = getContext ( ) . getFilesDir ( ) . getAbsolutePath ( ) + "<STR_LIT>" + "<STR_LIT>" ; var file = new File ( imagePath ) ; if ( ! file . exists ( ) ) return null ; String filePath = file . getAbsolutePath ( ) ; long lastModified = file . lastModified ( ) ; String cacheKey = filePath + "<STR_LIT>" + lastModified ; String cachedData = WppCore . getPrivString ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( cacheKey . equals ( cachedData ) && new File ( fileOut ) . exists ( ) ) { Bitmap bitmap = BitmapFactory . decodeFile ( fileOut ) ; return new BitmapDrawable ( getResources ( ) , bitmap ) ; } Bitmap bitmap = BitmapFactory . decodeFile ( imagePath ) ; DisplayMetrics displayMetrics = new DisplayMetrics ( ) ; var windowManager = ( WindowManager ) getContext ( ) . getSystemService ( Context . WINDOW_SERVICE ) ; windowManager . getDefaultDisplay ( ) . getMetrics ( displayMetrics ) ; int width = displayMetrics . widthPixels ; int height = displayMetrics . heightPixels ; var scaledBitmap = Bitmap . createScaledBitmap ( bitmap , width , height , true ) ; try ( var outputStream = new FileOutputStream ( fileOut ) ) { scaledBitmap . compress ( Bitmap . CompressFormat . JPEG , <NUM_LIT> , outputStream ) ; outputStream . flush ( ) ; } WppCore . setPrivString ( "<STR_LIT>" , cacheKey ) ; bitmap . recycle ( ) ; return new BitmapDrawable ( getResources ( ) , scaledBitmap ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . os . BaseBundle ; import android . os . Message ; import android . text . TextUtils ; import android . view . GestureDetector ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . listeners . DoubleTapListener ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . AnimationUtil ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Others extends Feature { public static HashMap < Integer , Boolean > propsBoolean = new HashMap < > ( ) ; public static HashMap < Integer , Integer > propsInteger = new HashMap < > ( ) ; private Properties properties ; public Others ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var novoTema = prefs . getBoolean ( "<STR_LIT>" , false ) ; var menuWIcons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var newSettings = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filterChats = prefs . getString ( "<STR_LIT>" , null ) ; var strokeButtons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var outlinedIcons = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showDnd = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showFreezeLastSeen = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filterSeen = prefs . getBoolean ( "<STR_LIT>" , false ) ; var fbstyle = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var metaai = prefs . getBoolean ( "<STR_LIT>" , false ) ; var topnav = prefs . getBoolean ( "<STR_LIT>" , false ) ; var proximity = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showOnline = prefs . getBoolean ( "<STR_LIT>" , false ) ; var floatingMenu = prefs . getBoolean ( "<STR_LIT>" , false ) ; var filter_items = prefs . getString ( "<STR_LIT>" , null ) ; var disable_defemojis = prefs . getBoolean ( "<STR_LIT>" , false ) ; var autonext_status = prefs . getBoolean ( "<STR_LIT>" , false ) ; var audio_type = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var audio_transcription = prefs . getBoolean ( "<STR_LIT>" , false ) ; var oldStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var igstatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var verticalStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var animationEmojis = prefs . getBoolean ( "<STR_LIT>" , false ) ; propsInteger . put ( <NUM_LIT> , oldStatus ? igstatus ? <NUM_LIT> : <NUM_LIT> : <NUM_LIT> ) ; propsBoolean . put ( <NUM_LIT> , filterSeen ) ; propsBoolean . put ( <NUM_LIT> , novoTema ) ; propsBoolean . put ( <NUM_LIT> , menuWIcons ) ; propsBoolean . put ( <NUM_LIT> , newSettings ) ; propsBoolean . put ( <NUM_LIT> , Objects . equals ( filterChats , "<STR_LIT>" ) ) ; propsBoolean . put ( <NUM_LIT> , strokeButtons ) ; propsBoolean . put ( <NUM_LIT> , outlinedIcons ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , floatingMenu ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , animationEmojis ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; if ( metaai ) { propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; } if ( audio_transcription ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; } if ( verticalStatus ) { propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; } else { propsInteger . put ( <NUM_LIT> , fbstyle ) ; propsInteger . put ( <NUM_LIT> , fbstyle ) ; } hookProps ( ) ; hookMenuOptions ( newSettings , showFreezeLastSeen , showDnd , filterChats ) ; if ( proximity ) { var proximitySensorMethod = Unobfuscator . loadProximitySensorMethod ( classLoader ) ; XposedBridge . hookMethod ( proximitySensorMethod , XC_MethodReplacement . DO_NOTHING ) ; } if ( filter_items != null && prefs . getBoolean ( "<STR_LIT>" , true ) ) { filterItems ( filter_items ) ; } if ( disable_defemojis ) { disable_defEmojis ( ) ; } if ( autonext_status ) { autoNextStatus ( ) ; } if ( audio_type > <NUM_LIT> ) { sendAudioType ( audio_type ) ; } customPlayBackSpeed ( ) ; showOnline ( showOnline ) ; animationList ( ) ; stampCopiedMessage ( ) ; doubleTapReaction ( ) ; } private void doubleTapReaction ( ) throws Exception { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( View ) param . thisObject ; if ( viewGroup == null ) return ; var gestureDetector = new GestureDetector ( viewGroup . getContext ( ) , new DoubleTapListener ( ( ) -> { var reactionView = ( ViewGroup ) viewGroup . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( reactionView != null && reactionView . getVisibility ( ) == View . VISIBLE ) { for ( int i = <NUM_LIT> ; i < reactionView . getChildCount ( ) ; i ++ ) { if ( reactionView . getChildAt ( i ) instanceof TextView textView ) { if ( textView . getText ( ) . toString ( ) . contains ( "<STR_LIT>" ) ) { WppCore . sendReaction ( "<STR_LIT>" , param . args [ <NUM_LIT> ] ) ; return ; } } } } WppCore . sendReaction ( "<STR_LIT>" , param . args [ <NUM_LIT> ] ) ; } ) ) ; viewGroup . setOnTouchListener ( ( v , event ) -> gestureDetector . onTouchEvent ( event ) ) ; } } ) ; } private void stampCopiedMessage ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var copiedMessage = Unobfuscator . loadCopiedMessageMethod ( classLoader ) ; XposedBridge . hookMethod ( copiedMessage , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var Collection = ( java . util . Collection ) param . args [ param . args . length - <NUM_LIT> ] ; param . args [ param . args . length - <NUM_LIT> ] = new ArrayList < Object > ( Collection ) { @ Override public int size ( ) { return <NUM_LIT> ; } } ; } } ) ; } private void animationList ( ) throws Exception { var animation = prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; if ( ! Objects . equals ( animation , "<STR_LIT>" ) ) { view . startAnimation ( AnimationUtil . getAnimation ( animation ) ) ; } else { if ( properties . containsKey ( "<STR_LIT>" ) ) { var animation = AnimationUtil . getAnimation ( properties . getProperty ( "<STR_LIT>" ) ) ; if ( animation != null ) { view . startAnimation ( animation ) ; } } } } } ) ; } private void customPlayBackSpeed ( ) throws Exception { var voicenote_speed = prefs . getFloat ( "<STR_LIT>" , <NUM_LIT> ) ; var playBackSpeed = Unobfuscator . loadPlaybackSpeed ( classLoader ) ; XposedBridge . hookMethod ( playBackSpeed , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( ( float ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = voicenote_speed ; } } } ) ; var voicenoteClass = classLoader . loadClass ( "<STR_LIT>" ) ; var method = ReflectionUtils . findAllMethodsUsingFilter ( voicenoteClass , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == int . class && method1 . getReturnType ( ) . equals ( void . class ) ) ; XposedBridge . hookMethod ( method [ method . length - <NUM_LIT> ] , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var view = ( View ) param . thisObject ; var playback = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( playback != null ) { playback . setText ( String . valueOf ( voicenote_speed ) . replace ( "<STR_LIT>" , "<STR_LIT>" ) + "<STR_LIT>" ) ; } } } } ) ; } private void sendAudioType ( int audio_type ) throws Exception { var sendAudioTypeMethod = Unobfuscator . loadSendAudioTypeMethod ( classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( sendAudioTypeMethod ) ) ; XposedBridge . hookMethod ( sendAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var results = ReflectionUtils . findArrayOfType ( param . args , Integer . class ) ; if ( results . size ( ) < <NUM_LIT> ) { log ( "<STR_LIT>" ) ; return ; } var mediaType = results . get ( <NUM_LIT> ) ; if ( ( int ) mediaType . second != <NUM_LIT> ) return ; var audioType = results . get ( <NUM_LIT> ) ; param . args [ audioType . first ] = audio_type - <NUM_LIT> ; } } ) ; var originFMessageField = Unobfuscator . loadOriginFMessageField ( classLoader ) ; var forwardAudioTypeMethod = Unobfuscator . loadForwardAudioTypeMethod ( classLoader ) ; XposedBridge . hookMethod ( forwardAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = param . getResult ( ) ; originFMessageField . setAccessible ( true ) ; originFMessageField . setInt ( fMessage , audio_type - <NUM_LIT> ) ; } } ) ; } private void autoNextStatus ( ) throws Exception { Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( "<STR_LIT>" ) ; var runNextStatusMethod = Unobfuscator . loadNextStatusRunMethod ( classLoader ) ; XposedBridge . hookMethod ( runNextStatusMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var obj = XposedHelpers . getObjectField ( param . thisObject , "<STR_LIT>" ) ; if ( StatusPlaybackContactFragmentClass . isInstance ( obj ) ) { param . setResult ( null ) ; } } } ) ; var onPlayBackFinished = Unobfuscator . loadOnPlaybackFinished ( classLoader ) ; XposedBridge . hookMethod ( onPlayBackFinished , XC_MethodReplacement . DO_NOTHING ) ; } private void disable_defEmojis ( ) throws Exception { var defEmojiClass = Unobfuscator . loadDefEmojiClass ( classLoader ) ; XposedBridge . hookMethod ( defEmojiClass , XC_MethodReplacement . returnConstant ( null ) ) ; } private void filterItems ( String filterItems ) { var itens = filterItems . split ( "<STR_LIT>" ) ; var idsFilter = new ArrayList < Integer > ( ) ; for ( String item : itens ) { var id = Utils . getID ( item , "<STR_LIT>" ) ; if ( id > <NUM_LIT> ) { idsFilter . add ( id ) ; } } XposedHelpers . findAndHookMethod ( View . class , "<STR_LIT>" , boolean . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . thisObject ; var id = view . getId ( ) ; if ( id > <NUM_LIT> && idsFilter . contains ( id ) && view . getVisibility ( ) == View . VISIBLE ) { view . setVisibility ( View . GONE ) ; } } } ) ; } private void showOnline ( boolean showOnline ) throws Exception { var checkOnlineMethod = Unobfuscator . loadCheckOnlineMethod ( classLoader ) ; XposedBridge . hookMethod ( checkOnlineMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var message = ( Message ) param . args [ <NUM_LIT> ] ; if ( message . arg1 != <NUM_LIT> ) return ; BaseBundle baseBundle = ( BaseBundle ) message . obj ; var jid = baseBundle . getString ( "<STR_LIT>" ) ; if ( WppCore . isGroup ( jid ) ) return ; var name = WppCore . getContactName ( WppCore . createUserJid ( jid ) ) ; name = TextUtils . isEmpty ( name ) ? WppCore . stripJID ( jid ) : name ; if ( showOnline ) Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . toast_online ) , name ) , Toast . LENGTH_SHORT ) ; Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jid ) , "<STR_LIT>" ) ; } } ) ; } @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ) private static void InsertDNDOption ( Menu menu , Activity home , boolean newSettings ) { var dndmode = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . dnd_mode_title ) ) ; var drawable = DesignUtils . getDrawableByName ( dndmode ? "<STR_LIT>" : "<STR_LIT>" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! dndmode ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . dnd_mode_title ) ) . setMessage ( home . getString ( ResId . string . dnd_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" } ) private static void InsertFreezeLastSeenOption ( Menu menu , Activity home , boolean newSettings ) { final boolean freezelastseen = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . freezelastseen_title ) ) ; var drawable = Utils . getApplication ( ) . getDrawable ( freezelastseen ? ResId . drawable . eye_disabled : ResId . drawable . eye_enabled ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! freezelastseen ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . freezelastseen_title ) ) . setMessage ( home . getString ( ResId . string . freezelastseen_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( "<STR_LIT>" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } private void hookProps ( ) throws Exception { var methodPropsBoolean = Unobfuscator . loadPropsBooleanMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPropsBoolean ) ) ; var dataUsageActivityClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookMethod ( methodPropsBoolean , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsBoolean . get ( i ) ; if ( propValue != null ) { switch ( i ) { case <NUM_LIT> : if ( Unobfuscator . isCalledFromClass ( dataUsageActivityClass ) ) return ; break ; } param . setResult ( propValue ) ; } } } ) ; var methodPropsInteger = Unobfuscator . loadPropsIntegerMethod ( classLoader ) ; XposedBridge . hookMethod ( methodPropsInteger , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsInteger . get ( i ) ; if ( propValue == null ) return ; param . setResult ( propValue ) ; } } ) ; } private void hookMenuOptions ( boolean newSettings , boolean showFreezeLastSeen , boolean showDnd , String filterChats ) { XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var activity = ( Activity ) param . thisObject ; if ( prefs . getBoolean ( "<STR_LIT>" , true ) ) { var iconDraw = activity . getDrawable ( ResId . drawable . refresh ) ; iconDraw . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; var itemMenu = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . restart_whatsapp ) . setIcon ( iconDraw ) . setOnMenuItemClickListener ( item -> { Utils . doRestart ( activity ) ; return true ; } ) ; if ( newSettings ) { itemMenu . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } } if ( showFreezeLastSeen ) { InsertFreezeLastSeenOption ( menu , activity , newSettings ) ; } if ( showDnd ) { InsertDNDOption ( menu , activity , newSettings ) ; } else { var dndmode = WppCore . getPrivBoolean ( "<STR_LIT>" , false ) ; if ( dndmode ) { WppCore . setPrivBoolean ( "<STR_LIT>" , false ) ; Utils . doRestart ( activity ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . findItem ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( item != null ) { item . setVisible ( Objects . equals ( filterChats , "<STR_LIT>" ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashSet ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class PinnedLimit extends Feature { public PinnedLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override @ SuppressLint ( "<STR_LIT>" ) public void doHook ( ) throws Throwable { var pinnedLimitMethod = Unobfuscator . loadPinnedLimitMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( pinnedLimitMethod ) ) ; var pinnedSetMethod = Unobfuscator . loadPinnedHashSetMethod ( classLoader ) ; var pinnedInChatMethod = Unobfuscator . loadPinnedInChatMethod ( classLoader ) ; XposedBridge . hookMethod ( pinnedInChatMethod , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; XposedBridge . hookMethod ( pinnedSetMethod , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pinnedset = ( Set ) param . getResult ( ) ; PinnedLinkedHashSet < Object > pinnedMod ; if ( ! ( pinnedset instanceof PinnedLinkedHashSet ) ) { pinnedMod = new PinnedLinkedHashSet < > ( ) ; pinnedMod . addAll ( pinnedset ) ; var setField = Unobfuscator . getFieldByType ( pinnedSetMethod . getDeclaringClass ( ) , Set . class ) ; XposedHelpers . setObjectField ( param . thisObject , setField . getName ( ) , pinnedMod ) ; param . setResult ( pinnedMod ) ; } else { pinnedMod = ( PinnedLinkedHashSet < Object > ) pinnedset ; } pinnedMod . setLimit ( prefs . getBoolean ( "<STR_LIT>" , false ) ? <NUM_LIT> : <NUM_LIT> ) ; } } ) ; var idPin = Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ; XposedBridge . hookMethod ( pinnedLimitMethod , new XC_MethodHook ( ) { private Unhook hooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( param . args . length > <NUM_LIT> && param . args [ <NUM_LIT> ] instanceof MenuItem menuItem ) { if ( menuItem . getItemId ( ) != idPin ) return ; hooked = XposedHelpers . findAndHookMethod ( HashSet . class , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( hooked != null ) hooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private static class PinnedLinkedHashSet < T > extends java . util . LinkedHashSet < T > { private int limit ; @ Override public int size ( ) { if ( super . size ( ) >= limit ) { return <NUM_LIT> ; } return <NUM_LIT> ; } public void setLimit ( int i ) { this . limit = i ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideTagForward extends Feature { public HideTagForward ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method method = Unobfuscator . loadForwardTagMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; Class < ? > forwardClass = Unobfuscator . loadForwardClassMethod ( classLoader ) ; logDebug ( "<STR_LIT>" + forwardClass . getName ( ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var arg = ( int ) param . args [ <NUM_LIT> ] ; if ( arg == <NUM_LIT> ) { if ( Unobfuscator . isCalledFromClass ( forwardClass ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . OvalShape ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DotOnline extends Feature { private Object mStatusUser ; private Object mInstancePresence ; public DotOnline ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var showOnlineText = prefs . getBoolean ( "<STR_LIT>" , false ) ; var showOnlineIcon = prefs . getBoolean ( "<STR_LIT>" , false ) ; if ( ! showOnlineText && ! showOnlineIcon ) return ; var classViewHolder = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookAllConstructors ( classViewHolder , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var context = ( Context ) param . args [ <NUM_LIT> ] ; var content = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( showOnlineText ) { var linearLayout = new LinearLayout ( context ) ; linearLayout . setGravity ( Gravity . END | Gravity . TOP ) ; content . addView ( linearLayout ) ; TextView lastSeenText = new TextView ( context ) ; lastSeenText . setId ( <NUM_LIT> ) ; lastSeenText . setTextSize ( <NUM_LIT> ) ; lastSeenText . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; lastSeenText . setGravity ( Gravity . CENTER_VERTICAL ) ; lastSeenText . setVisibility ( View . INVISIBLE ) ; linearLayout . addView ( lastSeenText ) ; } if ( showOnlineIcon ) { var contactView = ( FrameLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var photoView = ( ImageView ) contactView . getChildAt ( <NUM_LIT> ) ; contactView . removeView ( photoView ) ; var relativeLayout = new RelativeLayout ( context ) ; relativeLayout . setId ( <NUM_LIT> ) ; var params = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params . addRule ( RelativeLayout . CENTER_IN_PARENT ) ; photoView . setLayoutParams ( params ) ; relativeLayout . addView ( photoView ) ; contactView . addView ( relativeLayout ) ; var imageView = new ImageView ( context ) ; imageView . setId ( <NUM_LIT> ) ; var params2 = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params2 . addRule ( RelativeLayout . ALIGN_TOP , photoView . getId ( ) ) ; params2 . addRule ( RelativeLayout . ALIGN_RIGHT , photoView . getId ( ) ) ; params2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; imageView . setLayoutParams ( params2 ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new OvalShape ( ) ) ; shapeDrawable . getPaint ( ) . setColor ( Color . GREEN ) ; shapeDrawable . setIntrinsicHeight ( <NUM_LIT> ) ; shapeDrawable . setIntrinsicWidth ( <NUM_LIT> ) ; imageView . setImageDrawable ( shapeDrawable ) ; imageView . setVisibility ( View . INVISIBLE ) ; relativeLayout . addView ( imageView ) ; } } } ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var getStatusUser = Unobfuscator . loadStatusUserMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getStatusUser ) ) ; var sendPresenceMethod = Unobfuscator . loadSendPresenceMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( sendPresenceMethod ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookAllConstructors ( getStatusUser . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mStatusUser = param . thisObject ; } } ) ; XposedBridge . hookAllConstructors ( sendPresenceMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mInstancePresence = param . thisObject ; } } ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var object = param . args [ <NUM_LIT> ] ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; var getAdapterPositionMethod = ReflectionUtils . findMethodUsingFilter ( absViewHolderClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; var position = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; ImageView csDot = showOnlineIcon ? view . findViewById ( <NUM_LIT> ) . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineIcon ) { csDot . setVisibility ( View . INVISIBLE ) ; } TextView lastSeenText = showOnlineText ? view . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineText ) { lastSeenText . setVisibility ( View . INVISIBLE ) ; } var jidFiled = Unobfuscator . getFieldByExtendType ( object . getClass ( ) , XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ) ; var jidObject = jidFiled . get ( object ) ; var jid = WppCore . getRawString ( jidObject ) ; if ( WppCore . isGroup ( jid ) ) return ; Class < ? > JidClass = classLoader . loadClass ( "<STR_LIT>" ) ; var method = ReflectionUtils . findMethodUsingFilter ( sendPresenceMethod . getDeclaringClass ( ) , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && JidClass . isAssignableFrom ( method1 . getParameterTypes ( ) [ <NUM_LIT> ] ) && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == sendPresenceMethod . getDeclaringClass ( ) ) ; var instance = ReflectionUtils . callMethod ( method , null , jidObject , mInstancePresence ) ; sendPresenceMethod . invoke ( null , jidObject , instance , mInstancePresence ) ; var status = ( String ) getStatusUser . invoke ( mStatusUser , object ) ; var currentPosition = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; if ( currentPosition != position ) return ; if ( ! TextUtils . isEmpty ( status ) && status . trim ( ) . equals ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ) { if ( csDot != null ) { csDot . setVisibility ( View . VISIBLE ) ; } } if ( ! TextUtils . isEmpty ( status ) ) { if ( lastSeenText != null ) { lastSeenText . setText ( status ) ; lastSeenText . setVisibility ( View . VISIBLE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . utils ; import android . graphics . Color ; import java . util . HashMap ; public class IColors { public static HashMap < String , String > colors = new HashMap < > ( ) ; static { colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; colors . put ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static int parseColor ( String str ) { return Color . parseColor ( str ) ; } public static String toString ( int i ) { return "<STR_LIT>" + Integer . toHexString ( i ) ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments . base ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . preference . PreferenceFragmentCompat ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import rikka . material . preference . MaterialSwitchPreference ; public abstract class BasePreferenceFragment extends PreferenceFragmentCompat implements SharedPreferences . OnSharedPreferenceChangeListener { protected SharedPreferences mPrefs ; @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { mPrefs = PreferenceManager . getDefaultSharedPreferences ( requireContext ( ) ) ; mPrefs . registerOnSharedPreferenceChangeListener ( this ) ; } @ NonNull @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { chanceStates ( null ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , @ Nullable String s ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; App . getInstance ( ) . sendBroadcast ( intent ) ; chanceStates ( s ) ; } private void setPreferenceState ( String key , boolean enabled ) { var pref = findPreference ( key ) ; if ( pref != null ) { pref . setEnabled ( enabled ) ; if ( pref instanceof MaterialSwitchPreference && ! enabled ) { ( ( MaterialSwitchPreference ) pref ) . setChecked ( false ) ; } } } @ SuppressLint ( "<STR_LIT>" ) private void chanceStates ( String key ) { if ( Objects . equals ( key , "<STR_LIT>" ) ) { var mode = Integer . parseInt ( mPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; App . setThemeMode ( mode ) ; } if ( Objects . equals ( key , "<STR_LIT>" ) ) { mPrefs . edit ( ) . commit ( ) ; Utils . doRestart ( requireContext ( ) ) ; } var igstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; var verticalstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! igstatus ) ; var oldstatus = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; setPreferenceState ( "<STR_LIT>" , ! ( oldstatus || verticalstatus ) ) ; setPreferenceState ( "<STR_LIT>" , ! oldstatus ) ; var channels = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! channels && ! oldstatus ) ; var freezelastseen = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! freezelastseen ) ; var separategroups = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! separategroups ) ; var filtergroups = mPrefs . getBoolean ( "<STR_LIT>" , false ) ; setPreferenceState ( "<STR_LIT>" , ! filtergroups ) ; var callBlockContacts = findPreference ( "<STR_LIT>" ) ; var callWhiteContacts = findPreference ( "<STR_LIT>" ) ; if ( callBlockContacts != null && callWhiteContacts != null ) { var callType = Integer . parseInt ( mPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; switch ( callType ) { case <NUM_LIT> : callBlockContacts . setEnabled ( true ) ; callWhiteContacts . setEnabled ( false ) ; break ; case <NUM_LIT> : callWhiteContacts . setEnabled ( true ) ; callBlockContacts . setEnabled ( false ) ; break ; default : callWhiteContacts . setEnabled ( false ) ; callBlockContacts . setEnabled ( false ) ; break ; } } } } </s>
<s> package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . Context ; import android . content . Intent ; import android . os . Handler ; import android . os . Looper ; import androidx . appcompat . app . AppCompatDelegate ; import androidx . preference . PreferenceManager ; import java . util . Locale ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import rikka . material . app . LocaleDelegate ; public class App extends Application { private static App instance ; private static final ExecutorService executorService = Executors . newCachedThreadPool ( ) ; private static final Handler MainHandler = new Handler ( Looper . getMainLooper ( ) ) ; @ SuppressLint ( "<STR_LIT>" ) @ Override public void onCreate ( ) { super . onCreate ( ) ; instance = this ; var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; sharedPreferences . edit ( ) . putLong ( "<STR_LIT>" , System . currentTimeMillis ( ) ) . commit ( ) ; var mode = Integer . parseInt ( sharedPreferences . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; setThemeMode ( mode ) ; changeLanguage ( this ) ; } public static void setThemeMode ( int mode ) { switch ( mode ) { case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_YES ) ; break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; break ; } } public static App getInstance ( ) { return instance ; } public static ExecutorService getExecutorService ( ) { return executorService ; } public static Handler getMainHandler ( ) { return MainHandler ; } public void restartApp ( String packageWpp ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , packageWpp ) ; sendBroadcast ( intent ) ; } public static void changeLanguage ( Context context ) { var force = PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( "<STR_LIT>" , false ) ; LocaleDelegate . setDefaultLocale ( force ? Locale . ENGLISH : Locale . getDefault ( ) ) ; var res = context . getResources ( ) ; var config = res . getConfiguration ( ) ; config . setLocale ( LocaleDelegate . getDefaultLocale ( ) ) ; res . updateConfiguration ( config , res . getDisplayMetrics ( ) ) ; } } </s>
<s> package com . wmods . wppenhacer ; import android . net . Uri ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . utils . RealPathUtil ; import java . io . File ; public class FilePicker { private static OnFilePickedListener mOnFilePickedListener ; private static AppCompatActivity mActivity ; public static ActivityResultLauncher < String > fileSalve ; private static OnUriPickedListener mOnUriPickedListener ; public static ActivityResultLauncher < String [ ] > fileCapture ; public static ActivityResultLauncher < Uri > directoryCapture ; public static void registerFilePicker ( AppCompatActivity activity ) { mActivity = activity ; fileCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocument ( ) , FilePicker :: setFile ) ; directoryCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocumentTree ( ) , FilePicker :: setDirectory ) ; fileSalve = activity . registerForActivityResult ( new ActivityResultContracts . CreateDocument ( "<STR_LIT>" ) , FilePicker :: setFile ) ; } private static void setFile ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFilePath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } private static void setDirectory ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFolderPath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } public static void setOnFilePickedListener ( OnFilePickedListener onFilePickedListener ) { mOnFilePickedListener = onFilePickedListener ; } public static void setOnUriPickedListener ( OnUriPickedListener onFilePickedListener ) { mOnUriPickedListener = onFilePickedListener ; } public interface OnFilePickedListener { void onFilePicked ( File file ) ; } public interface OnUriPickedListener { void onUriPicked ( Uri uri ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . utils ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DebugUtils { public static void debugFields ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( "<STR_LIT>" + cls . getName ( ) ) ; for ( var field : cls . getDeclaredFields ( ) ) { try { field . setAccessible ( true ) ; var name = field . getName ( ) ; var value = field . get ( thisObject ) ; if ( value != null && value . getClass ( ) . isArray ( ) ) { value = Arrays . toString ( ( Object [ ] ) value ) ; } XposedBridge . log ( "<STR_LIT>" + name + "<STR_LIT>" + value ) ; } catch ( Exception ignored ) { } } } public static void debugAllMethods ( String className , String methodName , boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { XposedBridge . hookAllMethods ( XposedHelpers . findClass ( className , Utils . getApplication ( ) . getClassLoader ( ) ) , methodName , getDebugMethodHook ( printMethods , printFields , printArgs , printTrace ) ) ; } public static XC_MethodHook getDebugMethodHook ( boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { return new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { XposedBridge . log ( "<STR_LIT>" ) ; XposedBridge . log ( "<STR_LIT>" + param . method . getDeclaringClass ( ) . getName ( ) + "<STR_LIT>" + param . method . getName ( ) + "<STR_LIT>" + param . thisObject ) ; if ( printArgs ) { debugArgs ( param . args ) ; XposedBridge . log ( "<STR_LIT>" + ( param . getResult ( ) == null ? null : param . getResult ( ) . getClass ( ) . getName ( ) ) + "<STR_LIT>" + param . getResult ( ) ) ; } if ( printFields ) { debugFields ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printMethods ) { debugMethods ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printTrace ) { for ( var trace : Thread . currentThread ( ) . getStackTrace ( ) ) { XposedBridge . log ( "<STR_LIT>" + trace . toString ( ) ) ; } } XposedBridge . log ( "<STR_LIT>" ) ; } } ; } public static void debugArgs ( Object [ ] args ) { for ( var i = <NUM_LIT> ; i < args . length ; i ++ ) { XposedBridge . log ( "<STR_LIT>" + i + "<STR_LIT>" + ( args [ i ] == null ? null : args [ i ] . getClass ( ) . getName ( ) ) + "<STR_LIT>" + args [ i ] ) ; } } public static void debugMethods ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( "<STR_LIT>" + cls . getName ( ) ) ; for ( var method : cls . getDeclaredMethods ( ) ) { if ( method . getParameterCount ( ) > <NUM_LIT> ) continue ; try { method . setAccessible ( true ) ; XposedBridge . log ( "<STR_LIT>" + method . getName ( ) + "<STR_LIT>" + method . invoke ( thisObject ) ) ; } catch ( Exception ignored ) { } } } } </s>
<s> package com . wmods . wppenhacer . utils ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . os . Build ; import androidx . annotation . Nullable ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class StateListDrawableCompact { private static final Class < ? > mClass = StateListDrawable . class ; private StateListDrawableCompact ( ) { } public static int getStateCount ( StateListDrawable stateListDrawable ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateCount ( ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , "<STR_LIT>" ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable ) ; if ( invoke instanceof Integer ) { return ( Integer ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return <NUM_LIT> ; } @ Nullable public static Drawable getStateDrawable ( StateListDrawable stateListDrawable , int i ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateDrawable ( i ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , "<STR_LIT>" , Integer . TYPE ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable , i ) ; if ( invoke instanceof Drawable ) { return ( Drawable ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return null ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import android . annotation . SuppressLint ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . BaseAdapter ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeparateGroup extends Feature { public static final int CHATS = <NUM_LIT> ; public static final int STATUS = <NUM_LIT> ; public static final int CALLS = <NUM_LIT> ; public static final int COMMUNITY = <NUM_LIT> ; public static final int GROUPS = <NUM_LIT> ; public static ArrayList < Integer > tabs = new ArrayList < > ( ) ; public static HashMap < Integer , Object > tabInstances = new HashMap < > ( ) ; public SeparateGroup ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var home = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; hookTabList ( home ) ; if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; hookTabIcon ( ) ; hookTabInstance ( cFrag ) ; hookTabName ( home ) ; hookTabCount ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private void hookTabCount ( ) throws Exception { var runMethod = Unobfuscator . loadTabCountMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( runMethod ) ) ; var enableCountMethod = Unobfuscator . loadEnableCountTabMethod ( classLoader ) ; var constructor1 = Unobfuscator . loadEnableCountTabConstructor1 ( classLoader ) ; var constructor2 = Unobfuscator . loadEnableCountTabConstructor2 ( classLoader ) ; var constructor3 = Unobfuscator . loadEnableCountTabConstructor3 ( classLoader ) ; constructor3 . setAccessible ( true ) ; logDebug ( Unobfuscator . getMethodDescriptor ( enableCountMethod ) ) ; XposedBridge . hookMethod ( enableCountMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( { "<STR_LIT>" , "<STR_LIT>" } ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var indexTab = ( int ) param . args [ <NUM_LIT> ] ; if ( indexTab == tabs . indexOf ( CHATS ) ) { var chatCount = <NUM_LIT> ; var groupCount = <NUM_LIT> ; synchronized ( SeparateGroup . class ) { var db = MessageStore . getInstance ( ) . getDatabase ( ) ; var sql = "<STR_LIT>" ; var cursor = db . rawQuery ( sql , null ) ; while ( cursor . moveToNext ( ) ) { int jid = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int groupType = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int archived = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; int chatLocked = cursor . getInt ( cursor . getColumnIndex ( "<STR_LIT>" ) ) ; if ( archived != <NUM_LIT> || ( groupType != <NUM_LIT> && groupType != <NUM_LIT> ) || chatLocked != <NUM_LIT> ) continue ; var sql2 = "<STR_LIT>" ; var cursor1 = db . rawQuery ( sql2 , new String [ ] { String . valueOf ( jid ) } ) ; if ( ! cursor1 . moveToFirst ( ) ) continue ; var server = cursor1 . getString ( cursor1 . getColumnIndex ( "<STR_LIT>" ) ) ; if ( server . equals ( "<STR_LIT>" ) ) { groupCount ++ ; } else { chatCount ++ ; } cursor1 . close ( ) ; } cursor . close ( ) ; } if ( tabs . contains ( CHATS ) && tabInstances . containsKey ( CHATS ) ) { var instance12 = chatCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( chatCount ) ; var instance22 = constructor1 . newInstance ( instance12 ) ; param . args [ <NUM_LIT> ] = instance22 ; } if ( tabs . contains ( GROUPS ) && tabInstances . containsKey ( GROUPS ) ) { var instance2 = groupCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( groupCount ) ; var instance1 = constructor1 . newInstance ( instance2 ) ; enableCountMethod . invoke ( param . thisObject , param . args [ <NUM_LIT> ] , instance1 , tabs . indexOf ( GROUPS ) ) ; } } } } ) ; } private void hookTabIcon ( ) throws Exception { var iconTabMethod = Unobfuscator . loadIconTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( iconTabMethod ) ) ; var iconField = Unobfuscator . loadIconTabField ( classLoader ) ; var iconFrameField = Unobfuscator . loadIconTabLayoutField ( classLoader ) ; var iconMenuField = Unobfuscator . loadIconMenuField ( classLoader ) ; XposedBridge . hookMethod ( iconTabMethod , new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var superClass = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( superClass != null && superClass == iconTabMethod . getDeclaringClass ( ) ) { var field1 = superClass . getDeclaredField ( iconField . getName ( ) ) . get ( param . thisObject ) ; var field2 = getObjectField ( field1 , iconFrameField . getName ( ) ) ; if ( field2 == null ) return ; var menu = ( Menu ) getObjectField ( field2 , iconMenuField . getName ( ) ) ; if ( menu == null ) return ; var menuItem = ( MenuItem ) menu . findItem ( GROUPS ) ; if ( menuItem != null ) { menuItem . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; } } } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void hookTabName ( Class < ? > home ) throws Exception { var tabNameMethod = Unobfuscator . loadTabNameMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( tabNameMethod ) ) ; XposedBridge . hookMethod ( tabNameMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; var tab = ( int ) param . args [ <NUM_LIT> ] ; if ( tab == GROUPS ) { param . setResult ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; } } } ) ; } private void hookTabInstance ( Class < ? > cFrag ) throws Exception { var getTabMethod = Unobfuscator . loadGetTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getTabMethod ) ) ; var methodTabInstance = Unobfuscator . loadTabFragmentMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodTabInstance ) ) ; var recreateFragmentMethod = Unobfuscator . loadRecreateFragmentConstructor ( classLoader ) ; XposedBridge . hookMethod ( recreateFragmentMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var object = param . args [ <NUM_LIT> ] ; var desc = XposedHelpers . getObjectField ( object , "<STR_LIT>" ) ; if ( desc == null ) return ; var split = desc . toString ( ) . split ( "<STR_LIT>" ) ; var id = <NUM_LIT> ; try { id = Integer . parseInt ( split [ split . length - <NUM_LIT> ] ) ; } catch ( Exception ignored ) { return ; } if ( id == GROUPS || id == CHATS ) { var convFragment = XposedHelpers . getObjectField ( param . thisObject , "<STR_LIT>" ) ; tabInstances . remove ( id ) ; tabInstances . put ( id , convFragment ) ; } } } ) ; XposedBridge . hookMethod ( getTabMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; if ( tabId == GROUPS || tabId == CHATS ) { var convFragment = cFrag . newInstance ( ) ; param . setResult ( convFragment ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; tabInstances . remove ( tabId ) ; tabInstances . put ( tabId , param . getResult ( ) ) ; } } ) ; XposedBridge . hookMethod ( methodTabInstance , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var chatsList = ( List ) param . getResult ( ) ; var resultList = filterChat ( param . thisObject , chatsList ) ; param . setResult ( resultList ) ; } } ) ; var fabintMethod = Unobfuscator . loadFabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( fabintMethod ) ) ; XposedBridge . hookMethod ( fabintMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Objects . equals ( tabInstances . get ( GROUPS ) , param . thisObject ) ) { param . setResult ( GROUPS ) ; } } } ) ; var publishResultsMethod = Unobfuscator . loadGetFiltersMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( publishResultsMethod ) ) ; XposedBridge . hookMethod ( publishResultsMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var filters = param . args [ <NUM_LIT> ] ; var chatsList = ( List ) XposedHelpers . getObjectField ( filters , "<STR_LIT>" ) ; var baseField = Unobfuscator . getFieldByExtendType ( publishResultsMethod . getDeclaringClass ( ) , BaseAdapter . class ) ; if ( baseField == null ) return ; var convField = Unobfuscator . getFieldByType ( baseField . getType ( ) , cFrag ) ; Object thiz = convField . get ( baseField . get ( param . thisObject ) ) ; if ( thiz == null ) return ; var resultList = filterChat ( thiz , chatsList ) ; XposedHelpers . setObjectField ( filters , "<STR_LIT>" , resultList ) ; XposedHelpers . setIntField ( filters , "<STR_LIT>" , resultList . size ( ) ) ; } } ) ; } private List filterChat ( Object thiz , List chatsList ) { var tabChat = tabInstances . get ( CHATS ) ; var tabGroup = tabInstances . get ( GROUPS ) ; if ( ! Objects . equals ( tabChat , thiz ) && ! Objects . equals ( tabGroup , thiz ) ) { return chatsList ; } var editableChatList = new ArrayListFilter ( Objects . equals ( tabGroup , thiz ) ) ; editableChatList . addAll ( chatsList ) ; return editableChatList ; } private void hookTabList ( @ NonNull Class < ? > home ) throws Exception { var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var fieldTabsList = Arrays . stream ( home . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( List . class ) ) . findFirst ( ) . orElse ( null ) ; if ( fieldTabsList == null ) { throw new NullPointerException ( "<STR_LIT>" ) ; } fieldTabsList . setAccessible ( true ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { tabs = ( ArrayList < Integer > ) fieldTabsList . get ( null ) ; if ( tabs == null ) return ; if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! tabs . contains ( GROUPS ) ) { tabs . add ( tabs . isEmpty ( ) ? <NUM_LIT> : <NUM_LIT> , GROUPS ) ; } } } ) ; } public static class ArrayListFilter extends ArrayList < Object > { private final boolean isGroup ; public ArrayListFilter ( boolean isGroup ) { this . isGroup = isGroup ; } @ Override public void add ( int index , Object element ) { if ( checkGroup ( element ) ) { super . add ( index , element ) ; } } @ Override public boolean add ( Object object ) { if ( checkGroup ( object ) ) { return super . add ( object ) ; } return true ; } @ Override public boolean addAll ( @ NonNull Collection c ) { for ( var chat : c ) { if ( checkGroup ( chat ) ) { super . add ( chat ) ; } } return true ; } private boolean checkGroup ( Object chat ) { var requiredServer = isGroup ? "<STR_LIT>" : "<STR_LIT>" ; var jid = getObjectField ( chat , "<STR_LIT>" ) ; if ( XposedHelpers . findMethodExactIfExists ( jid . getClass ( ) , "<STR_LIT>" ) != null ) { var server = ( String ) callMethod ( jid , "<STR_LIT>" ) ; return server . equals ( requiredServer ) ; } return true ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DownloadViewOnce extends Feature { public DownloadViewOnce ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var initIntField = Unobfuscator . loadViewOnceDownloadMenuField2 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( initIntField ) ) ; var callMethod = Unobfuscator . loadViewOnceDownloadMenuCallMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( callMethod ) ) ; var fileField = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( fileField ) ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { try { var i = XposedHelpers . getIntField ( param . thisObject , initIntField . getName ( ) ) ; var message = callMethod . getParameterCount ( ) == <NUM_LIT> ? XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , param . thisObject , i ) : XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , i ) ; if ( message != null ) { var fileData = XposedHelpers . getObjectField ( message , "<STR_LIT>" ) ; var file = ( File ) ReflectionUtils . getField ( fileField , fileData ) ; var dest = Utils . getDestination ( prefs , "<STR_LIT>" ) ; var userJid = new FMessageWpp ( message ) . getKey ( ) . remoteJid ; var fileExtension = file . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; var name = Utils . generateName ( userJid , fileExtension ) ; var error = Utils . copyFile ( file , new File ( dest , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + dest , Toast . LENGTH_LONG ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_LONG ) ; } } } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; } return true ; } ) ; } } } ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . graphics . Color ; import android . view . View ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class BottomDialogWpp { private final Dialog dialog ; public BottomDialogWpp ( @ NonNull Dialog dialog ) { this . dialog = dialog ; } public void dismissDialog ( ) { dialog . dismiss ( ) ; } public void showDialog ( ) { dialog . show ( ) ; if ( dialog . getWindow ( ) != null ) { dialog . getWindow ( ) . setBackgroundDrawable ( null ) ; dialog . getWindow ( ) . setDimAmount ( <NUM_LIT> ) ; var view = dialog . getWindow ( ) . getDecorView ( ) ; view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) . setBackgroundColor ( Color . TRANSPARENT ) ; dialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_PAN ) ; } } public void setContentView ( View view ) { dialog . setContentView ( view ) ; } public void setCanceledOnTouchOutside ( boolean b ) { dialog . setCanceledOnTouchOutside ( b ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . os . Bundle ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import java . lang . reflect . Field ; import de . robv . android . xposed . XSharedPreferences ; public class DeleteStatus extends Feature { public DeleteStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var fragmentloader = Unobfuscator . loadFragmentLoader ( classLoader ) ; var showDialogStatus = Unobfuscator . loadShowDialogStatusMethod ( classLoader ) ; Class < ? > StatusDeleteDialogFragmentClass = classLoader . loadClass ( "<STR_LIT>" ) ; Field fieldBundle = ReflectionUtils . getFieldByType ( fragmentloader , Bundle . class ) ; var item = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . delete_for_me ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . delete_for_me , <NUM_LIT> , ResId . string . delete_for_me ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessage ) { try { var status = StatusDeleteDialogFragmentClass . newInstance ( ) ; var key = fMessage . getKey ( ) ; var bundle = getBundle ( key ) ; WppCore . setPrivBoolean ( key . messageID + "<STR_LIT>" , true ) ; log ( key . messageID ) ; fieldBundle . set ( status , bundle ) ; showDialogStatus . invoke ( status , status , fragmentInstance ) ; } catch ( Exception e ) { log ( e ) ; } } } ; menuStatuses . add ( item ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } @ NonNull private static Bundle getBundle ( FMessageWpp . Key key ) { var bundle = new Bundle ( ) ; bundle . putString ( "<STR_LIT>" , WppCore . getRawString ( key . remoteJid ) ) ; bundle . putBoolean ( "<STR_LIT>" , key . isFromMe ) ; bundle . putString ( "<STR_LIT>" , key . messageID ) ; return bundle ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import android . view . View ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideChat extends Feature { public static View . OnClickListener mClickListenerLocked ; public HideChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! Objects . equals ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) , "<STR_LIT>" ) ) { var archiveHideViewMethod = Unobfuscator . loadArchiveHideViewMethod ( classLoader ) ; for ( var method : archiveHideViewMethod ) { logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = false ; } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . SharedPreferences ; import android . database . sqlite . SQLiteDatabase ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . BottomDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class WppCore { static final HashSet < ActivityChangeState > listenerChat = new HashSet < > ( ) ; @ SuppressLint ( "<STR_LIT>" ) static Activity mCurrentActivity ; static LinkedHashSet < Activity > activities = new LinkedHashSet < > ( ) ; private static Class < ? > mGenJidClass ; private static Method mGenJidMethod ; private static Class bottomDialog ; private static Field convChatField ; private static Field chatJidField ; private static SharedPreferences privPrefs ; private static Object mStartUpConfig ; private static Object mActionUser ; private static SQLiteDatabase mWaDatabase ; public static void Initialize ( ClassLoader loader ) throws Exception { privPrefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; var mSendReadClass = XposedHelpers . findClass ( "<STR_LIT>" , loader ) ; var subClass = ReflectionUtils . findConstructorUsingFilter ( mSendReadClass , ( constructor ) -> constructor . getParameterCount ( ) == <NUM_LIT> ) . getParameterTypes ( ) [ <NUM_LIT> ] ; mGenJidClass = ReflectionUtils . findFieldUsingFilter ( subClass , ( field ) -> Modifier . isStatic ( field . getModifiers ( ) ) ) . getType ( ) ; mGenJidMethod = ReflectionUtils . findMethodUsingFilter ( mGenJidClass , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && ! Modifier . isStatic ( method . getModifiers ( ) ) ) ; bottomDialog = Unobfuscator . loadDialogViewClass ( loader ) ; convChatField = Unobfuscator . loadAntiRevokeConvChatField ( loader ) ; chatJidField = Unobfuscator . loadAntiRevokeChatJidField ( loader ) ; var startPrefsConfig = Unobfuscator . loadStartPrefsConfig ( loader ) ; XposedBridge . hookMethod ( startPrefsConfig , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mStartUpConfig = param . thisObject ; } } ) ; var actionUser = Unobfuscator . loadActionUser ( loader ) ; XposedBridge . hookAllConstructors ( actionUser , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mActionUser = param . thisObject ; } } ) ; loadWADatabase ( ) ; } public static void sendMessage ( String number , String message ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilterIfExists ( mActionUser . getClass ( ) , ( method ) -> List . class . isAssignableFrom ( method . getReturnType ( ) ) && ReflectionUtils . findIndexOfType ( method . getParameterTypes ( ) , String . class ) != - <NUM_LIT> ) ; if ( senderMethod != null ) { var userJid = createUserJid ( number + "<STR_LIT>" ) ; if ( userJid == null ) { Utils . showToast ( "<STR_LIT>" , Toast . LENGTH_SHORT ) ; return ; } var newObject = new Object [ senderMethod . getParameterCount ( ) ] ; for ( int i = <NUM_LIT> ; i < newObject . length ; i ++ ) { var param = senderMethod . getParameterTypes ( ) [ i ] ; newObject [ i ] = Utils . getDefaultValue ( param ) ; } var index = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , String . class ) ; newObject [ index ] = message ; var index2 = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , List . class ) ; newObject [ index2 ] = Collections . singletonList ( userJid ) ; senderMethod . invoke ( mActionUser , newObject ) ; Utils . showToast ( "<STR_LIT>" + number , Toast . LENGTH_SHORT ) ; } } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void sendReaction ( String s , Object objMessage ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilter ( mActionUser . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && Arrays . equals ( method . getParameterTypes ( ) , new Class [ ] { FMessageWpp . TYPE , String . class , boolean . class } ) ) ; senderMethod . invoke ( mActionUser , objMessage , s , ! TextUtils . isEmpty ( s ) ) ; } catch ( Exception e ) { Utils . showToast ( "<STR_LIT>" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void loadWADatabase ( ) { if ( mWaDatabase != null ) return ; var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var database = new File ( dataDir , "<STR_LIT>" ) ; if ( database . exists ( ) ) { mWaDatabase = SQLiteDatabase . openDatabase ( database . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READONLY ) ; } } public static Activity getCurrentActivity ( ) { return mCurrentActivity ; } public static int getDefaultTheme ( ) { if ( mStartUpConfig != null ) { var result = ReflectionUtils . findMethodUsingFilterIfExists ( mStartUpConfig . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; if ( result != null ) { var value = ReflectionUtils . callMethod ( result , mStartUpConfig ) ; if ( value != null ) return ( int ) value ; } } var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; return startup_prefs . getInt ( "<STR_LIT>" , <NUM_LIT> ) ; } @ NonNull public static String getContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String name = getSContactName ( userJid , false ) ; if ( ! TextUtils . isEmpty ( name ) ) return name ; return getWppContactName ( userJid ) ; } @ NonNull public static String getSContactName ( Object userJid , boolean saveOnly ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String selection ; if ( saveOnly ) { selection = "<STR_LIT>" ; } else { selection = "<STR_LIT>" ; } String name = null ; var rawJid = getRawString ( userJid ) ; var cursor = mWaDatabase . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , selection , new String [ ] { rawJid } , null , null , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { name = cursor . getString ( <NUM_LIT> ) ; cursor . close ( ) ; } return name == null ? "<STR_LIT>" : name ; } @ NonNull public static String getWppContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return "<STR_LIT>" ; String name = null ; var rawJid = getRawString ( userJid ) ; var cursor2 = mWaDatabase . query ( "<STR_LIT>" , new String [ ] { "<STR_LIT>" } , "<STR_LIT>" , new String [ ] { rawJid } , null , null , null ) ; if ( cursor2 != null && cursor2 . moveToFirst ( ) ) { name = cursor2 . getString ( <NUM_LIT> ) ; cursor2 . close ( ) ; } return name == null ? "<STR_LIT>" : name ; } public static Object createUserJid ( String rawjid ) { var genInstance = XposedHelpers . newInstance ( mGenJidClass ) ; try { return mGenJidMethod . invoke ( genInstance , rawjid ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public static String getRawString ( Object userjid ) { if ( userjid == null ) return null ; return ( String ) XposedHelpers . callMethod ( userjid , "<STR_LIT>" ) ; } public static boolean isGroup ( String str ) { if ( str == null ) return false ; return str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) || ( ! str . contains ( "<STR_LIT>" ) && str . length ( ) > <NUM_LIT> ) ; } public static String getCurrentRawJID ( ) { var conversation = getCurrentConversation ( ) ; if ( conversation == null ) return null ; var chatField = XposedHelpers . getObjectField ( conversation , convChatField . getName ( ) ) ; var chatJidObj = XposedHelpers . getObjectField ( chatField , chatJidField . getName ( ) ) ; return getRawString ( chatJidObj ) ; } public static String stripJID ( String str ) { try { return ( str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) || str . contains ( "<STR_LIT>" ) ) ? str . substring ( <NUM_LIT> , str . indexOf ( "<STR_LIT>" ) ) : str ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; return str ; } } public static Drawable getContactPhotoDrawable ( String jid ) { var file = getContactPhotoFile ( jid ) ; if ( file == null ) return null ; return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; } public static File getContactPhotoFile ( String jid ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + "<STR_LIT>" ; File file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + stripJID ( jid ) + "<STR_LIT>" ) ; if ( ! file . exists ( ) ) file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" + jid + "<STR_LIT>" ) ; if ( file . exists ( ) ) return file ; return null ; } public static String getMyName ( ) { var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( "<STR_LIT>" , Context . MODE_PRIVATE ) ; return startup_prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static SharedPreferences getMainPrefs ( ) { return Utils . getApplication ( ) . getSharedPreferences ( Utils . getApplication ( ) . getPackageName ( ) + "<STR_LIT>" , Context . MODE_PRIVATE ) ; } public static String getMyBio ( ) { var mainPrefs = getMainPrefs ( ) ; return mainPrefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ; } public static Drawable getMyPhoto ( ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + "<STR_LIT>" ; File file = new File ( datafolder + "<STR_LIT>" + "<STR_LIT>" + "<STR_LIT>" ) ; if ( file . exists ( ) ) return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; return null ; } public static BottomDialogWpp createBottomDialog ( Context context ) { return new BottomDialogWpp ( ( Dialog ) XposedHelpers . newInstance ( bottomDialog , context , <NUM_LIT> ) ) ; } @ Nullable public static Activity getCurrentConversation ( ) { if ( mCurrentActivity == null ) return null ; Class < ? > conversation = XposedHelpers . findClass ( "<STR_LIT>" , mCurrentActivity . getClassLoader ( ) ) ; if ( conversation . isInstance ( mCurrentActivity ) ) return mCurrentActivity ; return null ; } @ SuppressLint ( "<STR_LIT>" ) public static void setPrivString ( String key , String value ) { privPrefs . edit ( ) . putString ( key , value ) . commit ( ) ; } public static String getPrivString ( String key , String defaultValue ) { return privPrefs . getString ( key , defaultValue ) ; } @ SuppressLint ( "<STR_LIT>" ) public static void removePrivKey ( String s ) { if ( s != null && privPrefs . contains ( s ) ) privPrefs . edit ( ) . remove ( s ) . commit ( ) ; } @ SuppressLint ( "<STR_LIT>" ) public static void setPrivBoolean ( String key , boolean value ) { privPrefs . edit ( ) . putBoolean ( key , value ) . commit ( ) ; } public static boolean getPrivBoolean ( String key , boolean defaultValue ) { return privPrefs . getBoolean ( key , defaultValue ) ; } public static void addListenerChat ( ActivityChangeState listener ) { listenerChat . add ( listener ) ; } public interface ActivityChangeState { void onChange ( Object object , ChangeType type ) ; enum ChangeType { START , END , RESUME , PAUSE } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . content . Context ; import android . database . Cursor ; import android . graphics . Color ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . HKDF ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Objects ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import javax . crypto . Cipher ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okio . BufferedSink ; import okio . Okio ; public class MediaPreview extends Feature { private static final String HTML_LOADING = "<STR_LIT>" ; private static final String HTML_VIDEO = "<STR_LIT>" ; private static final String HTML_IMAGE = "<STR_LIT>" ; private File filePath ; private AlertDialog dialog ; static HashMap < String , byte [ ] > MEDIA_KEYS = new HashMap < > ( ) ; static { MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; MEDIA_KEYS . put ( "<STR_LIT>" , "<STR_LIT>" . getBytes ( ) ) ; } public MediaPreview ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , true ) ) return ; var getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; var videoViewContainerClass = Unobfuscator . loadVideoViewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( videoViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; var surface = ( ViewGroup ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var controlFrame = surface . getChildAt ( <NUM_LIT> ) ; surface . removeViewAt ( <NUM_LIT> ) ; var linearLayout = new LinearLayout ( context ) ; surface . addView ( linearLayout ) ; linearLayout . addView ( controlFrame ) ; var prevBtn = new ImageView ( context ) ; var layoutParams = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams . gravity = Gravity . CENTER ; prevBtn . setLayoutParams ( layoutParams ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( "<STR_LIT>" ) ) ; } ) ; } } ) ; var imageViewContainerClass = Unobfuscator . loadImageVewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( imageViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ViewGroup mediaContainer = view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; ViewGroup controlFrame = view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . WRAP_CONTENT , FrameLayout . LayoutParams . WRAP_CONTENT , Gravity . CENTER ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; mediaContainer . removeView ( controlFrame ) ; linearLayout . addView ( controlFrame ) ; mediaContainer . addView ( linearLayout ) ; var prevBtn = new ImageView ( context ) ; var layoutParams2 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams2 . gravity = Gravity . CENTER ; layoutParams2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; prevBtn . setLayoutParams ( layoutParams2 ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; controlFrame . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( ( ) -> { if ( prevBtn . getVisibility ( ) != controlFrame . getVisibility ( ) ) prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; } ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( "<STR_LIT>" ) ) ; } ) ; } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void startPlayer ( long id , Context context , boolean isNewsletter ) { var executor = Executors . newSingleThreadExecutor ( ) ; try { Cursor cursor0 = MessageStore . getInstance ( ) . getDatabase ( ) . rawQuery ( String . format ( Locale . ENGLISH , "<STR_LIT>" , id ) , null ) ; if ( cursor0 != null && cursor0 . getCount ( ) > <NUM_LIT> ) { cursor0 . moveToFirst ( ) ; AtomicReference < String > url = new AtomicReference < > ( cursor0 . getString ( <NUM_LIT> ) ) ; String mine_type = cursor0 . getString ( <NUM_LIT> ) ; String media_key = cursor0 . getString ( <NUM_LIT> ) ; String direct_path = cursor0 . getString ( <NUM_LIT> ) ; cursor0 . close ( ) ; if ( isNewsletter ) { url . set ( "<STR_LIT>" + direct_path ) ; } var alertDialog = new AlertDialog . Builder ( context ) ; FrameLayout frameLayout = new FrameLayout ( context ) ; var webView = new WebView ( context ) ; webView . getSettings ( ) . setAllowFileAccess ( true ) ; webView . getSettings ( ) . setSupportZoom ( true ) ; webView . getSettings ( ) . setBuiltInZoomControls ( true ) ; webView . getSettings ( ) . setDisplayZoomControls ( false ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; webView . loadDataWithBaseURL ( null , HTML_LOADING . replace ( "<STR_LIT>" , context . getString ( ResId . string . loading ) ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; frameLayout . addView ( webView ) ; alertDialog . setView ( frameLayout ) ; alertDialog . setOnDismissListener ( dialog1 -> { if ( filePath != null && filePath . exists ( ) ) { filePath . delete ( ) ; } if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } ) ; dialog = alertDialog . create ( ) ; dialog . show ( ) ; executor . execute ( ( ) -> decodeMedia ( url . get ( ) , media_key , mine_type , executor , webView , isNewsletter ) ) ; } } catch ( Exception e ) { logDebug ( e ) ; Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) dialog . dismiss ( ) ; if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } } private void decodeMedia ( String url , String mediaKey , String mimeType , ExecutorService executor , WebView webView , boolean isNewsletter ) { try { String fileExtension = mimeType . startsWith ( "<STR_LIT>" ) ? "<STR_LIT>" : "<STR_LIT>" ; filePath = new File ( Utils . getApplication ( ) . getCacheDir ( ) , "<STR_LIT>" + fileExtension ) ; byte [ ] encryptedData = Objects . requireNonNull ( new OkHttpClient . Builder ( ) . addInterceptor ( chain -> chain . proceed ( chain . request ( ) . newBuilder ( ) . addHeader ( "<STR_LIT>" , "<STR_LIT>" ) . build ( ) ) ) . build ( ) . newCall ( new Request . Builder ( ) . url ( url ) . build ( ) ) . execute ( ) . body ( ) ) . source ( ) . readByteArray ( ) ; if ( filePath . exists ( ) ) { filePath . delete ( ) ; } byte [ ] decryptedData = isNewsletter ? encryptedData : decryptMedia ( encryptedData , mediaKey , mimeType ) ; assert decryptedData != null ; try ( BufferedSink bufferedSink = Okio . buffer ( Okio . sink ( filePath ) ) ) { bufferedSink . write ( decryptedData ) ; } webView . post ( ( ) -> { String fileUrl = "<STR_LIT>" + filePath . getAbsolutePath ( ) ; if ( mimeType . contains ( "<STR_LIT>" ) ) { webView . loadDataWithBaseURL ( null , HTML_IMAGE . replace ( "<STR_LIT>" , fileUrl ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; } else { webView . loadDataWithBaseURL ( null , HTML_VIDEO . replace ( "<STR_LIT>" , fileUrl ) , "<STR_LIT>" , "<STR_LIT>" , null ) ; } } ) ; } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) { dialog . dismiss ( ) ; } } finally { if ( ! executor . isShutdown ( ) ) { executor . shutdownNow ( ) ; } } } private byte [ ] decryptMedia ( byte [ ] encryptedData , String mediaKey , String mimeType ) throws Exception { if ( mediaKey . length ( ) % <NUM_LIT> != <NUM_LIT> || mediaKey . length ( ) != <NUM_LIT> ) { throw new IllegalArgumentException ( "<STR_LIT>" ) ; } byte [ ] keyBytes = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i += <NUM_LIT> ) { keyBytes [ i / <NUM_LIT> ] = ( byte ) ( ( Character . digit ( mediaKey . charAt ( i ) , <NUM_LIT> ) << <NUM_LIT> ) + Character . digit ( mediaKey . charAt ( i + <NUM_LIT> ) , <NUM_LIT> ) ) ; } byte [ ] typeKey = MEDIA_KEYS . getOrDefault ( mimeType , MEDIA_KEYS . get ( "<STR_LIT>" ) ) ; byte [ ] derivedKey = HKDF . createFor ( <NUM_LIT> ) . deriveSecrets ( keyBytes , typeKey , <NUM_LIT> ) ; byte [ ] iv = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; byte [ ] aesKey = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; Cipher cipher = Cipher . getInstance ( "<STR_LIT>" ) ; cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( aesKey , "<STR_LIT>" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( Arrays . copyOfRange ( encryptedData , <NUM_LIT> , encryptedData . length - <NUM_LIT> ) ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideSeen extends Feature { public HideSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method SendReadReceiptJobMethod = Unobfuscator . loadHideViewSendReadJob ( classLoader ) ; var sendJob = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( SendReadReceiptJobMethod ) ) ; var hideread = prefs . getBoolean ( "<STR_LIT>" , false ) ; var hideread_group = prefs . getBoolean ( "<STR_LIT>" , false ) ; var hidestatusview = prefs . getBoolean ( "<STR_LIT>" , false ) ; XposedBridge . hookMethod ( SendReadReceiptJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! sendJob . isInstance ( param . thisObject ) ) return ; var srj = sendJob . cast ( param . thisObject ) ; var messageIds = XposedHelpers . getObjectField ( srj , "<STR_LIT>" ) ; var firstmessage = ( String ) Array . get ( messageIds , <NUM_LIT> ) ; if ( firstmessage != null && WppCore . getPrivBoolean ( firstmessage + "<STR_LIT>" , false ) ) { WppCore . removePrivKey ( firstmessage + "<STR_LIT>" ) ; return ; } var jid = ( String ) XposedHelpers . getObjectField ( srj , "<STR_LIT>" ) ; if ( jid == null ) return ; if ( WppCore . isGroup ( jid ) ) { if ( hideread_group ) param . setResult ( null ) ; } else if ( jid . startsWith ( "<STR_LIT>" ) ) { if ( hidestatusview ) param . setResult ( null ) ; } else if ( hideread ) { param . setResult ( null ) ; } } } ) ; Method hideViewInChatMethod = Unobfuscator . loadHideViewInChatMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewInChatMethod ) ) ; Method hideViewMethod = Unobfuscator . loadHideViewMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewMethod ) ) ; XposedBridge . hookMethod ( hideViewMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! Unobfuscator . isCalledFromMethod ( hideViewInChatMethod ) ) return ; if ( param . args [ <NUM_LIT> ] == null || ! param . args [ <NUM_LIT> ] . equals ( "<STR_LIT>" ) ) return ; var jid = WppCore . getCurrentRawJID ( ) ; if ( WppCore . isGroup ( jid ) ) { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) param . args [ <NUM_LIT> ] = null ; } else if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . args [ <NUM_LIT> ] = null ; } } } ) ; var methodPlayerViewJid = Unobfuscator . loadHideViewAudioMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPlayerViewJid ) ) ; XposedBridge . hookMethod ( methodPlayerViewJid , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) param . setResult ( true ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . ActivityAboutBinding ; public class AboutActivity extends AppCompatActivity { private ActivityAboutBinding binding ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; binding = ActivityAboutBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; binding . btnTelegram . setOnClickListener ( v -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; binding . btnGithub . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; binding . btnDonate . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( "<STR_LIT>" ) ) ; startActivity ( intent ) ; } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . view . View ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CopyStatus extends Feature { public CopyStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . getResult ( ) ; var caption = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( caption != null ) { caption . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( caption . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; var viewStatusMethod = Unobfuscator . loadBlueOnReplayStatusViewMethod ( classLoader ) ; XposedBridge . hookMethod ( viewStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var text = ( TextView ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( text != null ) { text . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( text . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . adapter ; import androidx . annotation . NonNull ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . viewpager2 . adapter . FragmentStateAdapter ; import com . wmods . wppenhacer . ui . fragments . CustomizationFragment ; import com . wmods . wppenhacer . ui . fragments . GeneralFragment ; import com . wmods . wppenhacer . ui . fragments . HomeFragment ; import com . wmods . wppenhacer . ui . fragments . MediaFragment ; import com . wmods . wppenhacer . ui . fragments . PrivacyFragment ; public class MainPagerAdapter extends FragmentStateAdapter { public MainPagerAdapter ( @ NonNull FragmentActivity fragmentActivity ) { super ( fragmentActivity ) ; } @ NonNull @ Override public Fragment createFragment ( int position ) { return switch ( position ) { case <NUM_LIT> -> new GeneralFragment ( ) ; case <NUM_LIT> -> new PrivacyFragment ( ) ; case <NUM_LIT> -> new MediaFragment ( ) ; case <NUM_LIT> -> new CustomizationFragment ( ) ; default -> new HomeFragment ( ) ; } ; } @ Override public int getItemCount ( ) { return <NUM_LIT> ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . annotation . SuppressLint ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . FragmentActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . MainActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . FragmentHomeBinding ; import com . wmods . wppenhacer . ui . fragments . base . BaseFragment ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Date ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import rikka . core . util . IOUtils ; public class HomeFragment extends BaseFragment { private FragmentHomeBinding binding ; @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; var intentFilter = new IntentFilter ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; ContextCompat . registerReceiver ( requireContext ( ) , new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { try { if ( FeatureLoader . PACKAGE_WPP . equals ( intent . getStringExtra ( "<STR_LIT>" ) ) ) receiverBroadcastWpp ( context , intent ) ; else receiverBroadcastBusiness ( context , intent ) ; } catch ( Exception ignored ) { } } } , intentFilter , ContextCompat . RECEIVER_EXPORTED ) ; } public View onCreateView ( @ NonNull LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { binding = FragmentHomeBinding . inflate ( inflater , container , false ) ; checkStateWpp ( requireActivity ( ) ) ; binding . rebootBtn . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; disableWpp ( requireActivity ( ) ) ; } ) ; binding . rebootBtn2 . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; disableBusiness ( requireActivity ( ) ) ; } ) ; binding . exportBtn . setOnClickListener ( view -> saveConfigs ( this . getContext ( ) ) ) ; binding . importBtn . setOnClickListener ( view -> importConfigs ( this . getContext ( ) ) ) ; binding . resetBtn . setOnClickListener ( view -> resetConfigs ( this . getContext ( ) ) ) ; return binding . getRoot ( ) ; } @ SuppressLint ( "<STR_LIT>" ) private void receiverBroadcastBusiness ( Context context , Intent intent ) { binding . statusTitle3 . setText ( R . string . business_in_background ) ; var version = intent . getStringExtra ( "<STR_LIT>" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) { binding . statusSummary3 . setText ( getString ( R . string . version_s , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary3 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn2 . setVisibility ( View . VISIBLE ) ; binding . statusSummary3 . setVisibility ( View . VISIBLE ) ; binding . statusIcon3 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } @ SuppressLint ( "<STR_LIT>" ) private void receiverBroadcastWpp ( Context context , Intent intent ) { binding . statusTitle2 . setText ( R . string . whatsapp_in_background ) ; var version = intent . getStringExtra ( "<STR_LIT>" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( "<STR_LIT>" , "<STR_LIT>" ) ) ) ) { binding . statusSummary1 . setText ( getString ( R . string . version_s , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary1 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn . setVisibility ( View . VISIBLE ) ; binding . statusSummary1 . setVisibility ( View . VISIBLE ) ; binding . statusIcon2 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } private void resetConfigs ( Context context ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; Utils . showToast ( context . getString ( R . string . configs_reset ) , Toast . LENGTH_SHORT ) ; } private static @ NonNull JSONObject getJsonObject ( SharedPreferences prefs ) throws JSONException { var entries = prefs . getAll ( ) ; var JSOjsonObject = new JSONObject ( ) ; for ( var entry : entries . entrySet ( ) ) { var type = new JSONObject ( ) ; var keyValue = entry . getValue ( ) ; if ( keyValue instanceof HashSet < ? > hashSet ) { keyValue = new JSONArray ( new ArrayList < > ( hashSet ) ) ; } type . put ( "<STR_LIT>" , entry . getValue ( ) . getClass ( ) . getSimpleName ( ) ) ; type . put ( "<STR_LIT>" , keyValue ) ; JSOjsonObject . put ( entry . getKey ( ) , type ) ; } return JSOjsonObject ; } private void saveConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var output = context . getContentResolver ( ) . openOutputStream ( uri ) ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var JSOjsonObject = getJsonObject ( prefs ) ; Objects . requireNonNull ( output ) . write ( JSOjsonObject . toString ( <NUM_LIT> ) . getBytes ( ) ) ; } Toast . makeText ( context , context . getString ( R . string . configs_saved ) , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( "<STR_LIT>" , Locale . US ) ; String formattedDate = dateFormat . format ( new Date ( ) ) ; FilePicker . fileSalve . launch ( "<STR_LIT>" + formattedDate + "<STR_LIT>" ) ; } private void importConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var input = context . getContentResolver ( ) . openInputStream ( uri ) ) { var data = IOUtils . toString ( input ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var jsonObject = new JSONObject ( data ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; var key = jsonObject . keys ( ) ; while ( key . hasNext ( ) ) { var keyName = key . next ( ) ; var value = jsonObject . get ( keyName ) ; var type = value . getClass ( ) . getSimpleName ( ) ; if ( value instanceof JSONObject valueJson ) { value = valueJson . get ( "<STR_LIT>" ) ; type = valueJson . getString ( "<STR_LIT>" ) ; } if ( type . equals ( JSONArray . class . getSimpleName ( ) ) ) { var jsonArray = ( JSONArray ) value ; HashSet < String > hashSet = new HashSet < > ( ) ; for ( var i = <NUM_LIT> ; i < jsonArray . length ( ) ; i ++ ) { hashSet . add ( jsonArray . getString ( i ) ) ; } prefs . edit ( ) . putStringSet ( keyName , hashSet ) . apply ( ) ; } else if ( type . equals ( String . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putString ( keyName , ( String ) value ) . apply ( ) ; } else if ( type . equals ( Boolean . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putBoolean ( keyName , ( boolean ) value ) . apply ( ) ; } else if ( type . equals ( Integer . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putInt ( keyName , ( int ) value ) . apply ( ) ; } else if ( type . equals ( Long . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putLong ( keyName , ( long ) value ) . apply ( ) ; } else if ( type . equals ( Double . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } else if ( type . equals ( Float . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } } } Toast . makeText ( context , context . getString ( R . string . configs_imported ) , Toast . LENGTH_SHORT ) . show ( ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; } catch ( Exception e ) { Log . e ( "<STR_LIT>" , e . getMessage ( ) , e ) ; Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; FilePicker . fileCapture . launch ( new String [ ] { "<STR_LIT>" } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void checkStateWpp ( FragmentActivity activity ) { if ( MainActivity . isXposedEnabled ( ) ) { binding . statusIcon . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; binding . statusTitle . setText ( R . string . module_enabled ) ; binding . statusSummary . setText ( String . format ( getString ( R . string . version_s ) , BuildConfig . VERSION_NAME ) ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_green ) ) ; } else { binding . statusIcon . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle . setText ( R . string . module_disabled ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary . setVisibility ( View . GONE ) ; } if ( isInstalled ( FeatureLoader . PACKAGE_WPP ) ) { disableWpp ( activity ) ; } else { binding . status2 . setVisibility ( View . GONE ) ; } if ( isInstalled ( FeatureLoader . PACKAGE_BUSINESS ) ) { disableBusiness ( activity ) ; } else { binding . status3 . setVisibility ( View . GONE ) ; } checkWpp ( activity ) ; binding . deviceName . setText ( Build . MANUFACTURER ) ; binding . sdk . setText ( String . valueOf ( Build . VERSION . SDK_INT ) ) ; binding . modelName . setText ( Build . DEVICE ) ; binding . listWpp . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ) ; binding . listBusiness . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ) ; } private boolean isInstalled ( String packageWpp ) { try { App . getInstance ( ) . getPackageManager ( ) . getPackageInfo ( packageWpp , <NUM_LIT> ) ; return true ; } catch ( Exception ignored ) { } return false ; } private void disableBusiness ( FragmentActivity activity ) { binding . statusIcon3 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle3 . setText ( R . string . business_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status3 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary3 . setVisibility ( View . GONE ) ; binding . rebootBtn2 . setVisibility ( View . GONE ) ; } private void disableWpp ( FragmentActivity activity ) { binding . statusIcon2 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle2 . setText ( R . string . whatsapp_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status2 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary1 . setVisibility ( View . GONE ) ; binding . rebootBtn . setVisibility ( View . GONE ) ; } private static void checkWpp ( FragmentActivity activity ) { Intent checkWpp = new Intent ( BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; activity . sendBroadcast ( checkWpp ) ; } @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; binding = null ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Color ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class DownloadProfile extends Feature { public DownloadProfile ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var loadProfileInfoField = Unobfuscator . loadProfileInfoField ( classLoader ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; if ( icon != null ) { icon . setTint ( Color . WHITE ) ; item . setIcon ( icon ) ; } item . setOnMenuItemClickListener ( menuItem -> { var subCls = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( subCls == null ) { log ( new Exception ( "<STR_LIT>" ) ) ; return true ; } var field = Unobfuscator . getFieldByType ( subCls , loadProfileInfoField . getDeclaringClass ( ) ) ; var jidObj = ReflectionUtils . getField ( loadProfileInfoField , ReflectionUtils . getField ( field , param . thisObject ) ) ; var jid = WppCore . stripJID ( WppCore . getRawString ( jidObj ) ) ; var file = WppCore . getContactPhotoFile ( jid ) ; var destPath = Utils . getDestination ( prefs , "<STR_LIT>" ) ; var name = Utils . generateName ( jidObj , "<STR_LIT>" ) ; var error = Utils . copyFile ( file , new File ( destPath , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destPath , Toast . LENGTH_LONG ) . show ( ) ; } else { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_LONG ) . show ( ) ; } return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . media ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . content . Intent ; import android . content . SharedPreferences ; import android . media . MediaScannerConnection ; import android . net . Uri ; import android . os . Environment ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . utils . MimeTypeUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Collections ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class StatusDownload extends Feature { private Field fieldFile ; public StatusDownload ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; var downloadStatus = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . download ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . download , <NUM_LIT> , ResId . string . download ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { downloadFile ( fMessageWpp ) ; } } ; menuStatuses . add ( downloadStatus ) ; var sharedMenu = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( fMessage . getKey ( ) . isFromMe ) return null ; if ( menu . findItem ( ResId . string . share_as_status ) != null ) return null ; return menu . add ( <NUM_LIT> , ResId . string . share_as_status , <NUM_LIT> , ResId . string . share_as_status ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sharedStatus ( fMessageWpp ) ; } } ; menuStatuses . add ( sharedMenu ) ; } private void sharedStatus ( FMessageWpp fMessageWpp ) { try { var fileData = XposedHelpers . getObjectField ( fMessageWpp . getObject ( ) , "<STR_LIT>" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , "<STR_LIT>" ) ; intent . putExtra ( "<STR_LIT>" , new ArrayList < > ( Collections . singleton ( "<STR_LIT>" ) ) ) ; intent . putExtra ( "<STR_LIT>" , new ArrayList < > ( Collections . singleton ( Uri . fromFile ( file ) ) ) ) ; intent . putExtra ( "<STR_LIT>" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } private void downloadFile ( FMessageWpp fMessage ) { try { var fileData = XposedHelpers . getObjectField ( fMessage . getObject ( ) , "<STR_LIT>" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . msg_text_status_not_downloadable ) , Toast . LENGTH_SHORT ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; var userJid = fMessage . getUserJid ( ) ; var fileType = file . getName ( ) . substring ( file . getName ( ) . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) ; var destination = getPathDestination ( prefs , file ) ; var name = Utils . generateName ( userJid , fileType ) ; var destinationFile = new File ( destination , name ) ; var error = Utils . copyFile ( file , destinationFile ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destinationFile . getAbsolutePath ( ) , Toast . LENGTH_SHORT ) ; log ( "<STR_LIT>" + destinationFile . getAbsolutePath ( ) ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + "<STR_LIT>" + error , Toast . LENGTH_SHORT ) ; } } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private boolean copyFile ( SharedPreferences prefs , File file ) throws IOException { if ( file == null || ! file . exists ( ) ) throw new IOException ( "<STR_LIT>" ) ; var destination = getPathDestination ( prefs , file ) ; try ( FileInputStream in = new FileInputStream ( file ) ; FileOutputStream out = new FileOutputStream ( destination ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { destination } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( path , uri ) -> { } ) ; return true ; } out . write ( bArr , <NUM_LIT> , read ) ; } } } @ NonNull private String getPathDestination ( SharedPreferences sharedPreferences , @ NonNull File f ) { var fileName = f . getName ( ) . toLowerCase ( ) ; var mediaPath = getStatusFolderPath ( sharedPreferences , MimeTypeUtils . getMimeTypeFromExtension ( fileName ) ) ; if ( ! mediaPath . exists ( ) ) mediaPath . mkdirs ( ) ; return mediaPath + "<STR_LIT>" ; } @ NonNull private File getStatusFolderPath ( SharedPreferences sharedPreferences , @ NonNull String mimeType ) { String folderPath = sharedPreferences . getString ( "<STR_LIT>" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "<STR_LIT>" ) ; if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else if ( mimeType . contains ( "<STR_LIT>" ) ) { folderPath += "<STR_LIT>" ; } else { folderPath += "<STR_LIT>" ; } return new File ( folderPath ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FilterGroups extends Feature { private Method methodSetFilter ; private Object mFilterInstance ; private Object mConversationFragment ; private Method methodInitFilter ; private TextView tabConversas ; private TextView tabGrupos ; public FilterGroups ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) || prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( Utils . getApplication ( ) . getPackageName ( ) . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( classLoader ) ; methodSetFilter = ReflectionUtils . findMethodUsingFilter ( filterAdaperClass , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; XposedBridge . hookAllConstructors ( filterAdaperClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mFilterInstance = param . thisObject ; } } ) ; var cFrag = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; XposedBridge . hookAllConstructors ( cFrag , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mConversationFragment = param . thisObject ; } } ) ; methodInitFilter = Unobfuscator . getFilterInitMethod ( classLoader ) ; var filterView = Unobfuscator . getFilterView ( classLoader ) ; XposedHelpers . findAndHookConstructor ( filterView , android . content . Context . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { setSetupSeparate ( ( ViewGroup ) param . thisObject ) ; } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void setSetupSeparate ( ViewGroup view ) { var context = view . getContext ( ) ; if ( view . findViewById ( <NUM_LIT> ) != null ) return ; var container = new LinearLayout ( context ) ; container . setOrientation ( LinearLayout . VERTICAL ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; container . setId ( <NUM_LIT> ) ; var filter = view . getChildAt ( <NUM_LIT> ) ; view . removeView ( filter ) ; LinearLayout mainLayout = new LinearLayout ( context ) ; mainLayout . setOrientation ( LinearLayout . VERTICAL ) ; var params = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . leftMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . rightMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . bottomMargin = Utils . dipToPixels ( <NUM_LIT> ) ; mainLayout . setLayoutParams ( params ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , DesignUtils . getUnSeenColor ( ) ) ; borderDrawable . setCornerRadius ( Utils . dipToPixels ( <NUM_LIT> ) ) ; mainLayout . setBackground ( borderDrawable ) ; LinearLayout tabLayout = new LinearLayout ( context ) ; tabLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; mainLayout . addView ( tabLayout , new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; tabConversas = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , <NUM_LIT> ) ; tabConversas . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabConversas . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabGrupos = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , <NUM_LIT> ) ; tabGrupos . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabGrupos . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabLayout . addView ( tabConversas ) ; tabLayout . addView ( tabGrupos ) ; updateContent ( <NUM_LIT> ) ; container . addView ( mainLayout ) ; container . addView ( filter ) ; view . addView ( container , <NUM_LIT> ) ; } private TextView createTab ( Context context , String text , int left ) { TextView tab = new TextView ( context ) ; tab . setText ( text ) ; tab . setGravity ( Gravity . CENTER ) ; tab . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; tab . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; setDrawableSelected ( tab , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , left ) ; return tab ; } private void setDrawableSelected ( View view , int colorBackground , int colorStroke , int left ) { float border = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] rects = left == <NUM_LIT> ? new float [ ] { border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , border , border } : new float [ ] { <NUM_LIT> , <NUM_LIT> , border , border , border , border , <NUM_LIT> , <NUM_LIT> } ; ShapeDrawable shape = new ShapeDrawable ( new RoundRectShape ( rects , null , null ) ) ; shape . getPaint ( ) . setColor ( colorBackground ) ; shape . setAlpha ( <NUM_LIT> ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , colorStroke ) ; borderDrawable . setCornerRadii ( rects ) ; LayerDrawable layerDrawable = new LayerDrawable ( new Drawable [ ] { borderDrawable , shape } ) ; layerDrawable . setLayerInset ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; view . setBackground ( layerDrawable ) ; } private void updateContent ( int position ) { if ( position == <NUM_LIT> ) { setDrawableSelected ( tabConversas , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setDrawableSelected ( tabGrupos , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } else { setDrawableSelected ( tabConversas , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setDrawableSelected ( tabGrupos , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } } private void setFilter ( int position ) { try { ReflectionUtils . callMethod ( methodInitFilter , null , mConversationFragment ) ; ReflectionUtils . callMethod ( methodSetFilter , mFilterInstance , position + <NUM_LIT> ) ; } catch ( Exception e ) { logDebug ( e ) ; } } @ NonNull @ Override public String getPluginName ( ) { return null ; } } </s>
<s> package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . database . Cursor ; import android . os . Bundle ; import android . provider . ContactsContract ; import android . text . Editable ; import android . text . TextWatcher ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ListView ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; public class ContactPickerActivity extends AppCompatActivity { private String mKey ; private ListView contactListView ; private ArrayAdapter < String > adapter ; private HashSet < String > selectedNumbers = new HashSet < > ( ) ; private final List < Contact > allContacts = new ArrayList < > ( ) ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; setContentView ( R . layout . activity_contact_picker ) ; mKey = getIntent ( ) . getStringExtra ( "<STR_LIT>" ) ; contactListView = findViewById ( R . id . contactListView ) ; Button selectButton = findViewById ( R . id . selectButton ) ; EditText searchBar = findViewById ( R . id . searchBar ) ; ArrayList < String > selectedNumbersInIntent = getIntent ( ) . getStringArrayListExtra ( "<STR_LIT>" ) ; if ( selectedNumbersInIntent != null ) { selectedNumbers = new HashSet < > ( selectedNumbersInIntent ) ; } loadAllContacts ( ) ; insertContactsInList ( allContacts ) ; selectButton . setOnClickListener ( view -> { Intent resultIntent = new Intent ( ) ; resultIntent . putExtra ( "<STR_LIT>" , new ArrayList < > ( selectedNumbers ) ) ; resultIntent . putExtra ( "<STR_LIT>" , mKey ) ; setResult ( Activity . RESULT_OK , resultIntent ) ; finish ( ) ; } ) ; searchBar . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { String searchText = charSequence . toString ( ) . toLowerCase ( ) ; List < Contact > filteredContacts = allContacts . stream ( ) . filter ( contact -> contact . name . toLowerCase ( ) . contains ( searchText ) || contact . number . contains ( searchText ) ) . collect ( Collectors . toList ( ) ) ; insertContactsInList ( filteredContacts ) ; } @ Override public void afterTextChanged ( Editable editable ) { } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void loadAllContacts ( ) { allContacts . clear ( ) ; Set < String > uniqueNumbers = new HashSet < > ( ) ; Cursor cursor = getContentResolver ( ) . query ( ContactsContract . CommonDataKinds . Phone . CONTENT_URI , null , null , null , ContactsContract . CommonDataKinds . Phone . STARRED + "<STR_LIT>" + ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME + "<STR_LIT>" ) ; if ( cursor != null ) { while ( cursor . moveToNext ( ) ) { String nome = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME ) ) ; String numero = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . NUMBER ) ) ; int starred = cursor . getInt ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . STARRED ) ) ; String numeroLimpo = numero . replaceAll ( "<STR_LIT>" , "<STR_LIT>" ) ; if ( ! uniqueNumbers . contains ( numeroLimpo ) ) { uniqueNumbers . add ( numeroLimpo ) ; allContacts . add ( new Contact ( nome , numeroLimpo , starred == <NUM_LIT> ) ) ; } } cursor . close ( ) ; } } @ SuppressLint ( "<STR_LIT>" ) private void insertContactsInList ( List < Contact > contacts ) { List < String > contactList = contacts . stream ( ) . map ( contact -> contact . name + "<STR_LIT>" + contact . number ) . collect ( Collectors . toList ( ) ) ; contactList . sort ( ( contact1 , contact2 ) -> { String number1 = contact1 . substring ( contact1 . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; String number2 = contact2 . substring ( contact2 . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; boolean isSelected1 = selectedNumbers . contains ( number1 ) ; boolean isSelected2 = selectedNumbers . contains ( number2 ) ; if ( isSelected1 && ! isSelected2 ) { return - <NUM_LIT> ; } else if ( ! isSelected1 && isSelected2 ) { return <NUM_LIT> ; } else { return contact1 . compareToIgnoreCase ( contact2 ) ; } } ) ; adapter = new ArrayAdapter < > ( this , android . R . layout . simple_list_item_multiple_choice , contactList ) ; contactListView . setAdapter ( adapter ) ; contactListView . setChoiceMode ( ListView . CHOICE_MODE_MULTIPLE ) ; for ( int i = <NUM_LIT> ; i < contactList . size ( ) ; i ++ ) { String contactInfo = contactList . get ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; if ( selectedNumbers . contains ( number ) ) { contactListView . setItemChecked ( i , true ) ; } } contactListView . setOnItemClickListener ( ( adapterView , view , i , l ) -> { String contactInfo = adapter . getItem ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( "<STR_LIT>" ) + <NUM_LIT> ) . trim ( ) ; if ( selectedNumbers . contains ( number ) ) { selectedNumbers . remove ( number ) ; } else { selectedNumbers . add ( number ) ; } } ) ; } public static class Contact { public String name ; public String number ; public boolean isStarred ; public Contact ( String name , String number , boolean isStarred ) { this . name = name ; this . number = number ; this . isStarred = isStarred ; } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . content . ContentValues ; import android . os . Bundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ChatLimit extends Feature { public ChatLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var antiDisappearing = prefs . getBoolean ( "<STR_LIT>" , false ) ; var revokeallmessages = prefs . getBoolean ( "<STR_LIT>" , false ) ; var chatLimitDeleteMethod = Unobfuscator . loadChatLimitDeleteMethod ( classLoader ) ; var chatLimitDelete2Method = Unobfuscator . loadChatLimitDelete2Method ( classLoader ) ; var epUpdateMethod = Unobfuscator . loadEphemeralInsertdb ( classLoader ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { MessageStore . getInstance ( ) . executeSQL ( "<STR_LIT>" ) ; } } } ) ; XposedBridge . hookMethod ( epUpdateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { var contentValues = ( ContentValues ) param . getResult ( ) ; contentValues . put ( "<STR_LIT>" , <NUM_LIT> ) ; } } } ) ; XposedBridge . hookMethod ( chatLimitDeleteMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Unobfuscator . isCalledFromMethod ( chatLimitDelete2Method ) && revokeallmessages ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var seeMoreMethod = Unobfuscator . loadSeeMoreMethod ( classLoader ) ; XposedBridge . hookMethod ( seeMoreMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . adapter ; import static com . wmods . wppenhacer . xposed . features . customization . IGStatus . itens ; import android . content . Context ; import android . content . Intent ; import android . graphics . Color ; import android . graphics . Typeface ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . TabDialogContent ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . Objects ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatusAdapter extends ArrayAdapter { private final Class < ? > clazzImageStatus ; private final Class < ? > statusInfoClazz ; private final Method setCountStatus ; @ NonNull @ Override public View getView ( int position , @ Nullable View convertView , @ NonNull ViewGroup parent ) { var item = itens . get ( position ) ; IGStatusViewHolder holder ; if ( convertView == null ) { holder = new IGStatusViewHolder ( ) ; convertView = createLayoutStatus ( holder ) ; convertView . setTag ( holder ) ; } else { holder = ( IGStatusViewHolder ) convertView . getTag ( ) ; } if ( item == null ) { holder . setInfo ( "<STR_LIT>" ) ; } else if ( statusInfoClazz . isInstance ( item ) ) { holder . setInfo ( item ) ; } convertView . setOnClickListener ( v -> { if ( holder . myStatus ) { var activity = WppCore . getCurrentActivity ( ) ; var dialog = WppCore . createBottomDialog ( activity ) ; var tabdialog = new TabDialogContent ( activity ) ; tabdialog . setTitle ( activity . getString ( ResId . string . select_status_type ) ) ; tabdialog . addTab ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( "<STR_LIT>" , getContext ( ) . getClassLoader ( ) ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . open_camera ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , "<STR_LIT>" ) ; A09 . putExtra ( "<STR_LIT>" , "<STR_LIT>" ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , false ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; A09 . putExtra ( "<STR_LIT>" , <NUM_LIT> ) ; activity . startActivity ( A09 ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . edit_text ) , DesignUtils . getIconByName ( "<STR_LIT>" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , "<STR_LIT>" ) ; activity . startActivity ( A09 ) ; dialog . dismissDialog ( ) ; } ) ; dialog . setContentView ( tabdialog ) ; dialog . showDialog ( ) ; return ; } var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( "<STR_LIT>" , getContext ( ) . getClassLoader ( ) ) ) ; intent . putExtra ( "<STR_LIT>" , holder . jid ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } ) ; return convertView ; } public IGStatusAdapter ( @ NonNull Context context , @ NonNull Class < ? > statusInfoClazz ) { super ( context , <NUM_LIT> ) ; this . clazzImageStatus = XposedHelpers . findClass ( "<STR_LIT>" , this . getContext ( ) . getClassLoader ( ) ) ; this . statusInfoClazz = statusInfoClazz ; this . setCountStatus = ReflectionUtils . findMethodUsingFilter ( this . clazzImageStatus , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; } @ Override public int getCount ( ) { return itens . size ( ) ; } class IGStatusViewHolder { public ImageView igStatusContactPhoto ; public RelativeLayout addButton ; public TextView igStatusContactName ; public boolean myStatus ; private String jid ; public void setInfo ( Object item ) { if ( Objects . equals ( item , "<STR_LIT>" ) ) { myStatus = true ; igStatusContactName . setText ( UnobfuscatorCache . getInstance ( ) . getString ( "<STR_LIT>" ) ) ; igStatusContactPhoto . setImageDrawable ( WppCore . getMyPhoto ( ) ) ; setCountStatus ( <NUM_LIT> , <NUM_LIT> ) ; return ; } var statusInfo = XposedHelpers . getObjectField ( item , "<STR_LIT>" ) ; var field = ReflectionUtils . getFieldByType ( statusInfo . getClass ( ) , XposedHelpers . findClass ( "<STR_LIT>" , statusInfoClazz . getClassLoader ( ) ) ) ; var userJid = ReflectionUtils . getField ( field , statusInfo ) ; var contactName = WppCore . getContactName ( userJid ) ; jid = WppCore . getRawString ( userJid ) ; igStatusContactName . setText ( contactName ) ; var profile = WppCore . getContactPhotoDrawable ( jid ) ; if ( profile == null ) profile = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; igStatusContactPhoto . setImageDrawable ( profile ) ; var countUnseen = XposedHelpers . getIntField ( statusInfo , "<STR_LIT>" ) ; var total = XposedHelpers . getIntField ( statusInfo , "<STR_LIT>" ) ; setCountStatus ( countUnseen , total ) ; } public void setCountStatus ( int countUnseen , int total ) { if ( setCountStatus != null ) { try { setCountStatus . invoke ( igStatusContactPhoto , countUnseen , total ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } } } @ NonNull private RelativeLayout createLayoutStatus ( IGStatusViewHolder holder ) { RelativeLayout relativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams relativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , ViewGroup . LayoutParams . WRAP_CONTENT ) ; relativeLayout . setLayoutParams ( relativeParams ) ; FrameLayout frameLayout = new FrameLayout ( this . getContext ( ) ) ; frameLayout . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; LinearLayout linearLayout = new LinearLayout ( this . getContext ( ) ) ; LinearLayout . LayoutParams linearParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( linearParams ) ; RelativeLayout internalRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams internalRelativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; internalRelativeLayout . setLayoutParams ( internalRelativeParams ) ; var contactPhoto = ( ImageView ) XposedHelpers . newInstance ( this . clazzImageStatus , this . getContext ( ) ) ; RelativeLayout . LayoutParams photoParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; contactPhoto . setLayoutParams ( photoParams ) ; contactPhoto . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; contactPhoto . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; contactPhoto . setImageDrawable ( DesignUtils . getDrawableByName ( "<STR_LIT>" ) ) ; holder . igStatusContactPhoto = contactPhoto ; contactPhoto . setClickable ( true ) ; XposedHelpers . callMethod ( contactPhoto , "<STR_LIT>" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . callMethod ( contactPhoto , "<STR_LIT>" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . setObjectField ( contactPhoto , "<STR_LIT>" , Color . GRAY ) ; XposedHelpers . setObjectField ( contactPhoto , "<STR_LIT>" , DesignUtils . getUnSeenColor ( ) ) ; RelativeLayout addBtnRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; addBtnRelativeLayout . setBackgroundColor ( Color . TRANSPARENT ) ; RelativeLayout . LayoutParams addBtnParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_BOTTOM ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_END ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; addBtnRelativeLayout . setLayoutParams ( addBtnParams ) ; addBtnRelativeLayout . setVisibility ( View . GONE ) ; holder . addButton = addBtnRelativeLayout ; ImageView iconImageView = new ImageView ( this . getContext ( ) ) ; RelativeLayout . LayoutParams iconParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; iconImageView . setLayoutParams ( iconParams ) ; var icon = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; iconImageView . setImageDrawable ( icon ) ; iconImageView . setBackgroundColor ( Color . TRANSPARENT ) ; addBtnRelativeLayout . addView ( iconImageView ) ; internalRelativeLayout . addView ( contactPhoto ) ; internalRelativeLayout . addView ( addBtnRelativeLayout ) ; TextView contactName = new TextView ( this . getContext ( ) ) ; contactName . setEllipsize ( TextUtils . TruncateAt . END ) ; contactName . setGravity ( Gravity . CENTER ) ; LinearLayout . LayoutParams nameParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; contactName . setLayoutParams ( nameParams ) ; contactName . setText ( "<STR_LIT>" ) ; contactName . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; contactName . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; contactName . setTypeface ( Typeface . DEFAULT_BOLD ) ; contactName . setMaxLines ( <NUM_LIT> ) ; holder . igStatusContactName = contactName ; linearLayout . addView ( internalRelativeLayout ) ; linearLayout . addView ( contactName ) ; frameLayout . addView ( linearLayout ) ; relativeLayout . addView ( frameLayout ) ; return relativeLayout ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideReceipt extends Feature { public HideReceipt ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method ) ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method2 ) ) ; var method3 = Unobfuscator . loadReceiptInChat ( classLoader ) ; logDebug ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( method3 ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; if ( ! Unobfuscator . isCalledFromMethod ( method2 ) && ! Unobfuscator . isCalledFromMethod ( method3 ) ) return ; var jid = WppCore . getRawString ( param . args [ <NUM_LIT> ] ) ; if ( ( jid == null || jid . contains ( "<STR_LIT>" ) ) && param . args [ <NUM_LIT> ] != "<STR_LIT>" ) { param . args [ <NUM_LIT> ] = "<STR_LIT>" ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . content . ContextWrapper ; import android . content . res . XModuleResources ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . xposed . AntiUpdater ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . downgrade . Patch ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . IXposedHookZygoteInit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class WppXposed implements IXposedHookLoadPackage , IXposedHookInitPackageResources , IXposedHookZygoteInit { private static XSharedPreferences pref ; private String MODULE_PATH ; public static XC_InitPackageResources . InitPackageResourcesParam ResParam ; @ NonNull public static XSharedPreferences getPref ( ) { if ( pref == null ) { pref = new XSharedPreferences ( BuildConfig . APPLICATION_ID , BuildConfig . APPLICATION_ID + "<STR_LIT>" ) ; pref . makeWorldReadable ( ) ; pref . reload ( ) ; } return pref ; } @ SuppressLint ( "<STR_LIT>" ) @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam ) throws Throwable { var packageName = lpparam . packageName ; var classLoader = lpparam . classLoader ; if ( packageName . equals ( BuildConfig . APPLICATION_ID ) ) { XposedHelpers . findAndHookMethod ( MainActivity . class . getName ( ) , lpparam . classLoader , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( true ) ) ; XposedHelpers . findAndHookMethod ( PreferenceManager . class . getName ( ) , lpparam . classLoader , "<STR_LIT>" , XC_MethodReplacement . returnConstant ( ContextWrapper . MODE_WORLD_READABLE ) ) ; return ; } XposedBridge . log ( "<STR_LIT>" + lpparam . packageName ) ; AntiUpdater . hookSession ( pref ) ; Patch . handleLoadPackage ( lpparam , pref ) ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var sourceDir = lpparam . appInfo . sourceDir ; FeatureLoader . start ( classLoader , getPref ( ) , sourceDir ) ; disableSecureFlag ( ) ; } @ Override public void handleInitPackageResources ( XC_InitPackageResources . InitPackageResourcesParam resparam ) throws Throwable { var packageName = resparam . packageName ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; XModuleResources modRes = XModuleResources . createInstance ( MODULE_PATH , resparam . res ) ; for ( var field : ResId . string . class . getFields ( ) ) { var field1 = R . string . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . array . class . getFields ( ) ) { var field1 = R . array . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . drawable . class . getFields ( ) ) { var field1 = R . drawable . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } ResParam = resparam ; } @ Override public void initZygote ( StartupParam startupParam ) throws Throwable { MODULE_PATH = startupParam . modulePath ; } public void disableSecureFlag ( ) { XposedHelpers . findAndHookMethod ( Window . class , "<STR_LIT>" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; } } ) ; XposedHelpers . findAndHookMethod ( Window . class , "<STR_LIT>" , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . setResult ( null ) ; } } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed ; import android . content . pm . PackageInstaller ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . io . IOException ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiUpdater { public static void hookSession ( XSharedPreferences prefs ) { XposedBridge . hookAllMethods ( PackageInstaller . class , "<STR_LIT>" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var session = ( PackageInstaller . SessionParams ) param . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( session , "<STR_LIT>" ) ; if ( packageName . equals ( FeatureLoader . PACKAGE_WPP ) || packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) { if ( prefs . getBoolean ( "<STR_LIT>" , false ) ) { param . setThrowable ( new IOException ( "<STR_LIT>" ) ) ; } } } } ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . ListView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . widget . NestedScrollView ; import com . wmods . wppenhacer . adapter . MessageAdapter ; import com . wmods . wppenhacer . views . NoScrollListView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ShowEditMessage extends Feature { public ShowEditMessage ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var onStartMethod = Unobfuscator . loadAntiRevokeOnStartMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onStartMethod ) ) ; var onMessageEdit = Unobfuscator . loadMessageEditMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onMessageEdit ) ) ; var getEditMessage = Unobfuscator . loadGetEditMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getEditMessage ) ) ; var editMessageShowMethod = Unobfuscator . loadEditMessageShowMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( editMessageShowMethod ) ) ; var editMessageViewField = Unobfuscator . loadEditMessageViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( editMessageViewField ) ) ; XposedBridge . hookMethod ( onMessageEdit , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var editMessage = getEditMessage . invoke ( param . args [ <NUM_LIT> ] ) ; if ( editMessage == null ) return ; long timestamp = XposedHelpers . getLongField ( editMessage , "<STR_LIT>" ) ; if ( timestamp == <NUM_LIT> ) return ; var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; long id = fMessage . getRowId ( ) ; String newMessage = fMessage . getMessageStr ( ) ; if ( newMessage == null ) { var methods = ReflectionUtils . findAllMethodsUsingFilter ( param . args [ <NUM_LIT> ] . getClass ( ) , method -> method . getReturnType ( ) == String . class && ReflectionUtils . isOverridden ( method ) ) ; for ( var method : methods ) { newMessage = ( String ) method . invoke ( param . args [ <NUM_LIT> ] ) ; if ( newMessage != null ) break ; } if ( newMessage == null ) return ; } try { MessageHistory . getInstance ( ) . insertMessage ( id , newMessage , timestamp ) ; } catch ( Exception e ) { logDebug ( e ) ; } } } ) ; XposedBridge . hookMethod ( editMessageShowMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var textView = ( TextView ) editMessageViewField . get ( param . thisObject ) ; if ( textView != null && ! textView . getText ( ) . toString ( ) . contains ( "<STR_LIT>" ) ) { textView . getPaint ( ) . setUnderlineText ( true ) ; textView . append ( "<STR_LIT>" ) ; textView . setOnClickListener ( ( v ) -> { try { var messageObj = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var fMesage = new FMessageWpp ( messageObj ) ; long id = fMesage . getRowId ( ) ; var msg = new MessageHistory . MessageItem ( id , MessageStore . getInstance ( ) . getMessageById ( id ) , <NUM_LIT> ) ; var messages = MessageHistory . getInstance ( ) . getMessages ( id ) ; if ( messages == null ) { messages = new ArrayList < > ( ) ; } else { messages . add ( <NUM_LIT> , msg ) ; } showBottomDialog ( messages ) ; } catch ( Exception exception0 ) { logDebug ( exception0 ) ; } } ) ; } } } ) ; } @ SuppressLint ( "<STR_LIT>" ) private void showBottomDialog ( ArrayList < MessageHistory . MessageItem > messages ) { Objects . requireNonNull ( WppCore . getCurrentConversation ( ) ) . runOnUiThread ( ( ) -> { var ctx = ( Context ) WppCore . getCurrentConversation ( ) ; var dialog = WppCore . createBottomDialog ( ctx ) ; NestedScrollView nestedScrollView0 = new NestedScrollView ( ctx , null ) ; nestedScrollView0 . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; nestedScrollView0 . setFillViewport ( true ) ; nestedScrollView0 . setFitsSystemWindows ( true ) ; LinearLayout linearLayout = new LinearLayout ( ctx ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; LinearLayout . LayoutParams layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; linearLayout . setFitsSystemWindows ( true ) ; linearLayout . setMinimumHeight ( layoutParams . height = Utils . getApplication ( ) . getResources ( ) . getDisplayMetrics ( ) . heightPixels / <NUM_LIT> ) ; linearLayout . setLayoutParams ( layoutParams ) ; int dip = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( dip , dip , dip , <NUM_LIT> ) ; var bg = DesignUtils . createDrawable ( "<STR_LIT>" , DesignUtils . getPrimarySurfaceColor ( ) ) ; linearLayout . setBackground ( bg ) ; TextView titleView = new TextView ( ctx ) ; LinearLayout . LayoutParams layoutParams1 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams1 . weight = <NUM_LIT> ; layoutParams1 . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; titleView . setLayoutParams ( layoutParams1 ) ; titleView . setTextSize ( <NUM_LIT> ) ; titleView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; titleView . setTypeface ( null , Typeface . BOLD ) ; titleView . setText ( ResId . string . edited_history ) ; var adapter = new MessageAdapter ( ctx , messages ) ; ListView listView = new NoScrollListView ( ctx ) ; LinearLayout . LayoutParams layoutParams2 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; layoutParams2 . weight = <NUM_LIT> ; listView . setLayoutParams ( layoutParams2 ) ; listView . setAdapter ( adapter ) ; ImageView imageView0 = new ImageView ( ctx ) ; LinearLayout . LayoutParams layoutParams4 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams4 . gravity = <NUM_LIT> ; layoutParams4 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; var bg2 = DesignUtils . createDrawable ( "<STR_LIT>" , Color . BLACK ) ; imageView0 . setBackground ( DesignUtils . alphaDrawable ( bg2 , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; imageView0 . setLayoutParams ( layoutParams4 ) ; Button okButton = new Button ( ctx ) ; LinearLayout . LayoutParams layoutParams3 = new LinearLayout . LayoutParams ( - <NUM_LIT> , - <NUM_LIT> ) ; layoutParams3 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams3 . gravity = <NUM_LIT> ; okButton . setLayoutParams ( layoutParams3 ) ; okButton . setGravity ( <NUM_LIT> ) ; var drawable = DesignUtils . createDrawable ( "<STR_LIT>" , Color . BLACK ) ; okButton . setBackground ( DesignUtils . alphaDrawable ( drawable , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; okButton . setText ( "<STR_LIT>" ) ; okButton . setOnClickListener ( ( View view ) -> dialog . dismissDialog ( ) ) ; linearLayout . addView ( imageView0 ) ; linearLayout . addView ( titleView ) ; linearLayout . addView ( listView ) ; linearLayout . addView ( okButton ) ; nestedScrollView0 . addView ( linearLayout ) ; dialog . setContentView ( nestedScrollView0 ) ; dialog . setCanceledOnTouchOutside ( true ) ; dialog . showDialog ( ) ; } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class GhostMode extends Feature { public GhostMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var ghostmode_t = prefs . getBoolean ( "<STR_LIT>" , false ) ; var ghostmode_r = prefs . getBoolean ( "<STR_LIT>" , false ) ; Method method = Unobfuscator . loadGhostModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) { var p1 = ( int ) param . args [ <NUM_LIT> ] ; if ( ( p1 == <NUM_LIT> && ghostmode_r ) || ( p1 == <NUM_LIT> && ghostmode_t ) ) { param . setResult ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . views ; import android . content . Context ; import android . view . ViewGroup ; import android . widget . ListView ; public class NoScrollListView extends ListView { public NoScrollListView ( Context context ) { super ( context ) ; } public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( <NUM_LIT> , MeasureSpec . AT_MOST ) ) ; ViewGroup . LayoutParams layoutParams = this . getLayoutParams ( ) ; layoutParams . height = this . getMeasuredHeight ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . annotation . SuppressLint ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class GroupAdmin extends Feature { public GroupAdmin ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var jidFactory = Unobfuscator . loadJidFactory ( classLoader ) ; var grpAdmin1 = Unobfuscator . loadGroupAdminMethod ( classLoader ) ; var grpcheckAdmin = Unobfuscator . loadGroupCheckAdminMethod ( classLoader ) ; var hooked = new XC_MethodHook ( ) { @ SuppressLint ( "<STR_LIT>" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = XposedHelpers . callMethod ( param . thisObject , "<STR_LIT>" ) ; var userJidClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var methodResult = ReflectionUtils . findMethodUsingFilter ( fMessage . getClass ( ) , method -> method . getReturnType ( ) == userJidClass && method . getParameterCount ( ) == <NUM_LIT> ) ; var userJid = ReflectionUtils . callMethod ( methodResult , fMessage ) ; var chatCurrentJid = WppCore . getCurrentRawJID ( ) ; if ( ! WppCore . isGroup ( chatCurrentJid ) ) return ; var field = ReflectionUtils . getFieldByType ( param . thisObject . getClass ( ) , grpcheckAdmin . getDeclaringClass ( ) ) ; var grpParticipants = field . get ( param . thisObject ) ; var jidGrp = jidFactory . invoke ( null , chatCurrentJid ) ; var result = ReflectionUtils . callMethod ( grpcheckAdmin , grpParticipants , jidGrp , userJid ) ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ImageView iconAdmin ; if ( ( iconAdmin = view . findViewById ( <NUM_LIT> ) ) == null ) { var nameGroup = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var view1 = new LinearLayout ( context ) ; view1 . setOrientation ( LinearLayout . HORIZONTAL ) ; view1 . setGravity ( Gravity . CENTER_VERTICAL ) ; var nametv = nameGroup . getChildAt ( <NUM_LIT> ) ; iconAdmin = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; iconAdmin . setLayoutParams ( new LinearLayout . LayoutParams ( size , size ) ) ; iconAdmin . setImageResource ( ResId . drawable . admin ) ; iconAdmin . setId ( <NUM_LIT> ) ; nameGroup . removeView ( nametv ) ; view1 . addView ( nametv ) ; view1 . addView ( iconAdmin ) ; nameGroup . addView ( view1 , <NUM_LIT> ) ; } iconAdmin . setVisibility ( result != null && ( boolean ) result ? View . VISIBLE : View . GONE ) ; } } ; XposedBridge . hookMethod ( grpAdmin1 , hooked ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class CustomizationFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_customization , rootKey ) ; } } </s>
<s> package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class GeneralFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_general , rootKey ) ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . util . AttributeSet ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . ContactPickerActivity ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; public class ContactPickerPreference extends Preference implements Preference . OnPreferenceClickListener { public static final int REQUEST_CONTACT_PICKER = <NUM_LIT> ; public static final int PERMISSIONS_REQUEST_READ_CONTACTS = <NUM_LIT> ; private CharSequence summaryOff ; private CharSequence summaryOn ; private ArrayList < String > mContacts ; public ContactPickerPreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs ) ; } @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { if ( ContextCompat . checkSelfPermission ( getContext ( ) , Manifest . permission . READ_CONTACTS ) != PackageManager . PERMISSION_GRANTED ) { ( ( Activity ) getContext ( ) ) . requestPermissions ( new String [ ] { Manifest . permission . READ_CONTACTS } , PERMISSIONS_REQUEST_READ_CONTACTS ) ; } else { startContactPickerActivity ( ) ; } return true ; } private void init ( Context context , AttributeSet attrs ) { setOnPreferenceClickListener ( this ) ; var typedArray = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . ContactPickerPreference , <NUM_LIT> , <NUM_LIT> ) ; summaryOff = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOff ) ; summaryOn = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOn ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; String namesString = prefs . getString ( getKey ( ) , "<STR_LIT>" ) ; if ( namesString . length ( ) > <NUM_LIT> ) { mContacts = Arrays . stream ( namesString . substring ( <NUM_LIT> , namesString . length ( ) - <NUM_LIT> ) . split ( "<STR_LIT>" ) ) . map ( item -> item . trim ( ) ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; } if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } public void startContactPickerActivity ( ) { Context context = getContext ( ) ; Intent intent = new Intent ( context , ContactPickerActivity . class ) ; if ( mContacts != null ) { intent . putStringArrayListExtra ( "<STR_LIT>" , mContacts ) ; } intent . putExtra ( "<STR_LIT>" , getKey ( ) ) ; ( ( Activity ) getContext ( ) ) . startActivityForResult ( intent , REQUEST_CONTACT_PICKER ) ; } public void handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode == REQUEST_CONTACT_PICKER && resultCode == Activity . RESULT_OK ) { mContacts = data . getStringArrayListExtra ( "<STR_LIT>" ) ; getSharedPreferences ( ) . edit ( ) . putString ( getKey ( ) , mContacts . toString ( ) ) . apply ( ) ; if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . app . Activity ; import android . widget . EditText ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . views . dialog . SimpleColorPickerDialog ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class TextStatusComposer extends Feature { private static final AtomicReference < ColorData > colorData = new AtomicReference < > ( ) ; public TextStatusComposer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var setColorTextComposer = Unobfuscator . loadTextStatusComposer ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( setColorTextComposer ) ) ; XposedHelpers . findAndHookMethod ( "<STR_LIT>" , classLoader , "<STR_LIT>" , classLoader . loadClass ( "<STR_LIT>" ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var viewRoot = activity . getWindow ( ) . getDecorView ( ) ; var pickerColor = viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var entry = ( EditText ) viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; pickerColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { try { Field fieldInt = ReflectionUtils . findFieldUsingFilter ( param . thisObject . getClass ( ) , field -> field . getType ( ) == int . class ) ; fieldInt . setInt ( param . thisObject , color ) ; ReflectionUtils . callMethod ( setColorTextComposer , null , param . thisObject ) ; } catch ( Exception e ) { log ( e ) ; } } ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; var textColor = viewRoot . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; textColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { var colorData = new ColorData ( ) ; colorData . instance = param . thisObject ; colorData . color = color ; TextStatusComposer . colorData . set ( colorData ) ; entry . setTextColor ( color ) ; } ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; } } ) ; var setColorTextComposer2 = Unobfuscator . loadTextStatusComposer2 ( classLoader ) ; log ( "<STR_LIT>" + Unobfuscator . getMethodDescriptor ( setColorTextComposer2 ) ) ; XposedBridge . hookMethod ( setColorTextComposer2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( colorData . get ( ) != null ) { var message = param . getResult ( ) ; var textData = XposedHelpers . getObjectField ( message , "<STR_LIT>" ) ; XposedHelpers . setObjectField ( textData , "<STR_LIT>" , colorData . get ( ) . color ) ; colorData . set ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } public static class ColorData { public Object instance ; public int color ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . others ; import android . database . sqlite . SQLiteDatabase ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class ToastViewer extends Feature { private static final long MIN_INTERVAL = <NUM_LIT> ; private static final Map < String , Long > lastEventTimeMap = new HashMap < > ( ) ; private static final ScheduledExecutorService scheduler = Executors . newScheduledThreadPool ( <NUM_LIT> ) ; public ToastViewer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; startCleanupTask ( ) ; } @ Override public void doHook ( ) throws Throwable { var toastViewedStatus = prefs . getBoolean ( "<STR_LIT>" , false ) ; var toastViewedMessage = prefs . getBoolean ( "<STR_LIT>" , false ) ; var onInsertReceipt = Unobfuscator . loadOnInsertReceipt ( classLoader ) ; XposedBridge . hookMethod ( onInsertReceipt , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var type = ( int ) param . args [ <NUM_LIT> ] ; var id = ( long ) param . args [ <NUM_LIT> ] ; if ( type != <NUM_LIT> ) return ; var PhoneUserJid = param . args [ <NUM_LIT> ] ; CompletableFuture . runAsync ( ( ) -> { var raw = WppCore . getRawString ( PhoneUserJid ) ; var UserJid = WppCore . createUserJid ( raw ) ; var contactName = WppCore . getContactName ( UserJid ) ; if ( TextUtils . isEmpty ( contactName ) ) contactName = WppCore . stripJID ( raw ) ; var sql = MessageStore . getInstance ( ) . getDatabase ( ) ; checkDataBase ( sql , id , contactName , raw , toastViewedMessage , toastViewedStatus ) ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } private synchronized void checkDataBase ( SQLiteDatabase sql , long id , String contactName , String raw , boolean toastViewedMessage , boolean toast_viewed_status ) { try ( var result2 = sql . query ( "<STR_LIT>" , null , "<STR_LIT>" , new String [ ] { String . valueOf ( id ) } , null , null , null ) ) { if ( ! result2 . moveToNext ( ) ) return ; var participantHash = result2 . getString ( result2 . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; if ( participantHash != null ) { if ( toast_viewed_status ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_status , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , "<STR_LIT>" ) ; return ; } if ( Objects . equals ( WppCore . getCurrentRawJID ( ) , raw ) ) return ; var chat_id = result2 . getLong ( result2 . getColumnIndexOrThrow ( "<STR_LIT>" ) ) ; try ( var result3 = sql . query ( "<STR_LIT>" , null , "<STR_LIT>" , new String [ ] { String . valueOf ( chat_id ) } , null , null , null ) ) { if ( ! result3 . moveToNext ( ) ) return ; var key = raw + "<STR_LIT>" + "<STR_LIT>" ; long currentTime = System . currentTimeMillis ( ) ; Long lastEventTime = lastEventTimeMap . get ( key ) ; if ( lastEventTime == null || ( currentTime - lastEventTime ) >= MIN_INTERVAL ) { lastEventTimeMap . put ( key , currentTime ) ; if ( toastViewedMessage ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_message , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , "<STR_LIT>" ) ; } } } } private void startCleanupTask ( ) { scheduler . scheduleWithFixedDelay ( ( ) -> { long currentTime = System . currentTimeMillis ( ) ; synchronized ( lastEventTimeMap ) { lastEventTimeMap . entrySet ( ) . removeIf ( entry -> ( currentTime - entry . getValue ( ) ) >= MIN_INTERVAL ) ; } } , MIN_INTERVAL , MIN_INTERVAL , TimeUnit . MILLISECONDS ) ; } } </s>
<s> package com . wmods . wppenhacer . preference ; import android . content . Context ; import android . content . res . TypedArray ; import android . util . AttributeSet ; import android . widget . SeekBar ; import android . widget . TextView ; import androidx . preference . Preference ; import androidx . preference . PreferenceViewHolder ; import com . wmods . wppenhacer . R ; public class FloatSeekBarPreference extends Preference implements SeekBar . OnSeekBarChangeListener { private float minValue ; private float maxValue ; private float valueSpacing ; private String format ; private SeekBar seekbar ; private TextView textView ; private float defaultValue = <NUM_LIT> ; private float newValue = <NUM_LIT> ; public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs , defStyleAttr , defStyleRes ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { this ( context , attrs , defStyleAttr , <NUM_LIT> ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs ) { this ( context , attrs , androidx . preference . R . attr . seekBarPreferenceStyle ) ; } public FloatSeekBarPreference ( Context context ) { this ( context , null ) ; } @ Override protected Object onGetDefaultValue ( TypedArray ta , int index ) { defaultValue = ta . getFloat ( index , <NUM_LIT> ) ; return defaultValue ; } @ Override protected void onSetInitialValue ( Object defaultValue ) { newValue = getPersistedFloat ( ( defaultValue instanceof Float ) ? ( Float ) defaultValue : this . defaultValue ) ; } @ Override public void onBindViewHolder ( PreferenceViewHolder holder ) { super . onBindViewHolder ( holder ) ; holder . itemView . setClickable ( false ) ; seekbar = ( SeekBar ) holder . findViewById ( R . id . seekbar ) ; textView = ( TextView ) holder . findViewById ( R . id . seekbar_value ) ; seekbar . setOnSeekBarChangeListener ( this ) ; seekbar . setMax ( ( int ) ( ( maxValue - minValue ) / valueSpacing ) ) ; seekbar . setProgress ( ( int ) ( ( newValue - minValue ) / valueSpacing ) ) ; seekbar . setEnabled ( isEnabled ( ) ) ; textView . setText ( String . format ( format , newValue ) ) ; } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! fromUser ) { return ; } float v = minValue + progress * valueSpacing ; textView . setText ( String . format ( format , v ) ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { float v = minValue + seekBar . getProgress ( ) * valueSpacing ; persistFloat ( v ) ; } private void init ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { setWidgetLayoutResource ( R . layout . pref_float_seekbar ) ; TypedArray ta = context . obtainStyledAttributes ( attrs , R . styleable . FloatSeekBarPreference , defStyleAttr , defStyleRes ) ; minValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_minValue , <NUM_LIT> ) ; maxValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_maxValue , <NUM_LIT> ) ; valueSpacing = ta . getFloat ( R . styleable . FloatSeekBarPreference_valueSpacing , <NUM_LIT> ) ; format = ta . getString ( R . styleable . FloatSeekBarPreference_format ) ; if ( format == null ) { format = "<STR_LIT>" ; } ta . recycle ( ) ; } public float getValue ( ) { return ( seekbar != null ) ? ( seekbar . getProgress ( ) * valueSpacing ) + minValue : <NUM_LIT> ; } public void setValue ( float value ) { newValue = value ; persistFloat ( value ) ; notifyChanged ( ) ; } } </s>
<s> package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Handler ; import android . os . Looper ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . collection . ArraySet ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeenTick extends Feature { private static final ArraySet < MessageInfo > messages = new ArraySet < > ( ) ; private static Object mWaJobManager ; private static Class < ? > mSendReadClass ; private static Method WaJobManagerMethod ; private static String currentJid ; private static String currentScreen = "<STR_LIT>" ; private static final HashMap < String , ImageView > messageMap = new HashMap < > ( ) ; public SeenTick ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var messageSendClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; WaJobManagerMethod = Unobfuscator . loadBlueOnReplayWaJobManagerMethod ( classLoader ) ; var messageJobMethod = Unobfuscator . loadBlueOnReplayMessageJobMethod ( classLoader ) ; mSendReadClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; WppCore . addListenerChat ( ( activity , type ) -> { if ( activity . getClass ( ) . getSimpleName ( ) . equals ( "<STR_LIT>" ) && ( type == WppCore . ActivityChangeState . ChangeType . START || type == WppCore . ActivityChangeState . ChangeType . RESUME ) ) { var jid = WppCore . getCurrentRawJID ( ) ; if ( ! Objects . equals ( jid , currentJid ) ) { currentJid = jid ; messages . clear ( ) ; } currentScreen = "<STR_LIT>" ; } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; messages . add ( new MessageInfo ( fMessage , key . messageID , fMessage . getUserJid ( ) ) ) ; } } ) ; XposedBridge . hookMethod ( messageJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var obj = messageSendClass . cast ( param . thisObject ) ; var rawJid = ( String ) XposedHelpers . getObjectField ( obj , "<STR_LIT>" ) ; var handler = new Handler ( Looper . getMainLooper ( ) ) ; if ( Objects . equals ( currentScreen , "<STR_LIT>" ) ) { if ( messages . isEmpty ( ) ) return ; MessageStore . getInstance ( ) . storeMessageRead ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; var view = messageMap . get ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; if ( view != null ) view . post ( ( ) -> setSeenButton ( view , true ) ) ; handler . post ( ( ) -> sendBlueTickStatus ( currentJid ) ) ; } else handler . post ( ( ) -> sendBlueTick ( rawJid ) ) ; } } ) ; XposedBridge . hookAllConstructors ( WaJobManagerMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mWaJobManager = param . thisObject ; } } ) ; var ticktype = Integer . parseInt ( prefs . getString ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( ticktype == <NUM_LIT> ) return ; var onCreateMenuConversationMethod = Unobfuscator . loadBlueOnReplayCreateMenuConversationMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateMenuConversationMethod ) ) ; XposedBridge . hookMethod ( onCreateMenuConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var menuItem = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) ; if ( ticktype == <NUM_LIT> ) menuItem . setShowAsAction ( <NUM_LIT> ) ; menuItem . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; menuItem . setOnMenuItemClickListener ( item -> { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTick ( currentJid ) ; return true ; } ) ; } } ) ; var setPageActiveMethod = Unobfuscator . loadStatusActivePage ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( setPageActiveMethod ) ) ; var fieldList = Unobfuscator . getFieldByType ( setPageActiveMethod . getDeclaringClass ( ) , List . class ) ; XposedBridge . hookMethod ( setPageActiveMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var position = ( int ) param . args [ <NUM_LIT> ] ; var list = ( List < ? > ) XposedHelpers . getObjectField ( param . args [ <NUM_LIT> ] , fieldList . getName ( ) ) ; var fMessage = new FMessageWpp ( list . get ( position ) ) ; var messageKey = ( String ) fMessage . getKey ( ) . messageID ; var jid = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; messages . clear ( ) ; messages . add ( new MessageInfo ( fMessage , messageKey , null ) ) ; currentJid = jid ; currentScreen = "<STR_LIT>" ; } } ) ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; if ( ticktype == <NUM_LIT> ) { XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( "<STR_LIT>" , false ) ) return ; var fMessageField = ReflectionUtils . getFieldByExtendType ( param . thisObject . getClass ( ) , FMessageWpp . TYPE ) ; var fMessage = new FMessageWpp ( ReflectionUtils . getField ( fMessageField , param . thisObject ) ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; var view = ( View ) param . getResult ( ) ; var contentView = ( LinearLayout ) view . findViewById ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; var buttonImage = new ImageView ( view . getContext ( ) ) ; LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . gravity = Gravity . CENTER_VERTICAL ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; buttonImage . setLayoutParams ( params ) ; buttonImage . setImageResource ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; GradientDrawable border = new GradientDrawable ( ) ; border . setShape ( GradientDrawable . RECTANGLE ) ; border . setStroke ( <NUM_LIT> , Color . WHITE ) ; border . setCornerRadius ( <NUM_LIT> ) ; border . setColor ( Color . parseColor ( "<STR_LIT>" ) ) ; buttonImage . setBackground ( border ) ; contentView . setOrientation ( LinearLayout . HORIZONTAL ) ; contentView . addView ( buttonImage , <NUM_LIT> ) ; messageMap . put ( key . messageID , buttonImage ) ; buttonImage . setOnClickListener ( v -> CompletableFuture . runAsync ( ( ) -> { Utils . showToast ( view . getContext ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTickStatus ( currentJid ) ; setSeenButton ( buttonImage , true ) ; } ) ) ; CompletableFuture . runAsync ( ( ) -> { var seen = MessageStore . getInstance ( ) . isReadMessageStatus ( key . messageID ) ; setSeenButton ( buttonImage , seen ) ; } ) ; } } ) ; } else { MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . send_blue_tick ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . send_blue_tick , <NUM_LIT> , ResId . string . send_blue_tick ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; } MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . read_all_mark_as_read ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . read_all_mark_as_read , <NUM_LIT> , ResId . string . read_all_mark_as_read ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { try { messages . clear ( ) ; var listStatusField = ReflectionUtils . getFieldByExtendType ( fragmentInstance . getClass ( ) , List . class ) ; var listStatus = ( List ) listStatusField . get ( fragmentInstance ) ; for ( int i = <NUM_LIT> ; i < listStatus . size ( ) ; i ++ ) { var fMessage = new FMessageWpp ( listStatus . get ( i ) ) ; var messageId = fMessage . getKey ( ) . messageID ; if ( ! fMessage . getKey ( ) . isFromMe ) { messages . add ( new MessageInfo ( fMessage , messageId , null ) ) ; } var view = messageMap . get ( messageId ) ; if ( view != null ) { view . post ( ( ) -> setSeenButton ( view , true ) ) ; } } } catch ( Exception e ) { log ( e ) ; } sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var classThreadMessage = Unobfuscator . loadFMessageClass ( classLoader ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( "<STR_LIT>" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) . setIcon ( Utils . getID ( "<STR_LIT>" , "<STR_LIT>" ) ) ; if ( ticktype == <NUM_LIT> ) item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { var messageField = Unobfuscator . getFieldByExtendType ( menuMethod . getDeclaringClass ( ) , classThreadMessage ) ; var messageObject = XposedHelpers . getObjectField ( param . thisObject , messageField . getName ( ) ) ; sendBlueTickMedia ( messageObject , true ) ; Toast . makeText ( Utils . getApplication ( ) , ResId . string . sending_read_blue_tick , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } ) ; } } } ) ; } public static void setSeenButton ( ImageView buttonImage , boolean b ) { Drawable originalDrawable = DesignUtils . getDrawableByName ( "<STR_LIT>" ) ; Drawable clonedDrawable ; if ( originalDrawable instanceof BitmapDrawable ) { Bitmap bitmap = ( ( BitmapDrawable ) originalDrawable ) . getBitmap ( ) ; Bitmap clonedBitmap = bitmap . copy ( bitmap . getConfig ( ) , true ) ; clonedDrawable = new BitmapDrawable ( buttonImage . getResources ( ) , clonedBitmap ) ; } else { clonedDrawable = Objects . requireNonNull ( originalDrawable . getConstantState ( ) ) . newDrawable ( ) . mutate ( ) ; } if ( b ) { clonedDrawable . setColorFilter ( Color . CYAN , PorterDuff . Mode . SRC_ATOP ) ; } buttonImage . setImageDrawable ( clonedDrawable ) ; buttonImage . postInvalidate ( ) ; } private void sendBlueTick ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; var messagekeys = messages . stream ( ) . map ( item -> item . messageId ) . collect ( Collectors . toList ( ) ) ; var listAudios = MessageStore . getInstance ( ) . getAudioListByMessageList ( messagekeys ) ; logDebug ( "<STR_LIT>" + listAudios ) ; for ( var messageKey : listAudios ) { var mInfo = messages . stream ( ) . filter ( messageInfo -> messageInfo . messageId . equals ( messageKey ) ) . findAny ( ) ; if ( mInfo . isPresent ( ) ) { messages . remove ( mInfo . get ( ) ) ; sendBlueTickMedia ( mInfo . get ( ) . fMessage . getObject ( ) , false ) ; } } sendBlueTickMsg ( currentJid ) ; } private void sendBlueTickMsg ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; try { logDebug ( "<STR_LIT>" + currentJid ) ; HashMap < Object , List < String > > map = new HashMap < > ( ) ; for ( var messageInfo : messages ) { map . computeIfAbsent ( messageInfo . userJid , k -> new ArrayList < > ( ) ) ; Objects . requireNonNull ( map . get ( messageInfo . userJid ) ) . add ( messageInfo . messageId ) ; } var userJidTarget = WppCore . createUserJid ( currentJid ) ; for ( var userjid : map . keySet ( ) ) { var messages = Objects . requireNonNull ( map . get ( userjid ) ) . toArray ( new String [ <NUM_LIT> ] ) ; WppCore . setPrivBoolean ( messages [ <NUM_LIT> ] + "<STR_LIT>" , true ) ; var participant = WppCore . isGroup ( currentJid ) ? userjid : null ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidTarget , participant , null , null , messages , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; } messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private void sendBlueTickStatus ( String currentJid ) { logDebug ( "<STR_LIT>" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . equals ( "<STR_LIT>" ) ) return ; try { logDebug ( "<STR_LIT>" + currentJid ) ; var arr_s = messages . stream ( ) . map ( item -> item . messageId ) . toArray ( String [ ] :: new ) ; Arrays . stream ( arr_s ) . forEach ( s -> MessageStore . getInstance ( ) . storeMessageRead ( s ) ) ; var userJidSender = WppCore . createUserJid ( "<STR_LIT>" ) ; var userJid = WppCore . createUserJid ( currentJid ) ; WppCore . setPrivBoolean ( arr_s [ <NUM_LIT> ] + "<STR_LIT>" , true ) ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidSender , userJid , null , null , arr_s , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } private void sendBlueTickMedia ( Object messageObject , boolean clear ) { try { logDebug ( "<STR_LIT>" + WppCore . getCurrentRawJID ( ) ) ; var sendPlayerClass = XposedHelpers . findClass ( "<STR_LIT>" , classLoader ) ; var sendJob = XposedHelpers . newInstance ( sendPlayerClass , messageObject ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; if ( clear ) messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( "<STR_LIT>" + e . getMessage ( ) ) ; } } @ NonNull @ Override public String getPluginName ( ) { return "<STR_LIT>" ; } static class MessageInfo { public Object userJid ; public String messageId ; public FMessageWpp fMessage ; public MessageInfo ( FMessageWpp fMessage , String messageId , Object userJid ) { this . messageId = messageId ; this . fMessage = fMessage ; this . userJid = userJid ; } @ Override public boolean equals ( @ Nullable Object obj ) { if ( obj instanceof MessageInfo messageInfo ) { return Objects . equals ( messageId , messageInfo . messageId ) && Objects . equals ( fMessage , messageInfo . fMessage ) && Objects . equals ( userJid , messageInfo . userJid ) ; } return false ; } @ NonNull @ Override public String toString ( ) { return messageId ; } } } </s>
