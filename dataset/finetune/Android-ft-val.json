[{"input": "package com . android . internal . os ; public class ZygoteInit { public static void main ( String [ ] argv ) {", "output": "throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import java . util . Date ; public class HistoryComment extends Comment { public static final String STATE_NORMAL = \"<STR_LIT>\" ; public static final String STATE_SHADOW_BAN = \"<STR_LIT>\" ; public static final String STATE_DELETED = \"<STR_LIT>\" ; public static final String STATE_INVISIBLE = \"<STR_LIT>\" ; public static final String STATE_UNDER_REVIEW = \"<STR_LIT>\" ; public static final String STATE_SUSPECTED_NO_PROBLEM = \"<STR_LIT>\" ; public static final String STATE_UNKNOWN = \"<STR_LIT>\" ; public static final String STATE_COMMENT_AREA_DIED = \"<STR_LIT>\" ; public static final String STATE_SENSITIVE = \"<STR_LIT>\" ; public static final int CHECKED_NO_CHECK = <NUM_LIT> ; public static final int CHECKED_NOT_MARTIAL_LAW = <NUM_LIT> ; public static final int CHECKED_ONLY_BANNED_IN_THIS_AREA = <NUM_LIT> ; public static final int CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA = <NUM_LIT> ; public static final int CHECKED_MARTIAL_LAW = <NUM_LIT> ; public int like , replyCount ; public int checkedArea ; public String firstState ; public String lastState ; public Date lastCheckDate ; public SensitiveScanResult sensitiveScanResult ; public HistoryComment ( CommentArea commentArea , long rpid , long parent , long root , String comment , Date date , int like , int replyCount , String lastState , Date lastCheckDate , int checkedArea , String firstState , String pictures , SensitiveScanResult sensitiveScanResult ) { super ( commentArea , rpid , parent , root , comment , pictures , date ) ; this . like = like ; this . replyCount = replyCount ; this . lastState = lastState ; this . lastCheckDate = lastCheckDate ; this . checkedArea = checkedArea ; this . firstState = firstState ; this . sensitiveScanResult = sensitiveScanResult ; } public HistoryComment ( long oid , String sourceId , int type , long rpid , long parent , long root , String comment , Date date , int like , int replyCount , String lastState , Date lastCheckDate ) { super ( new CommentArea ( oid , sourceId , type ) , rpid , parent , root , comment , null , date ) ; this . like = like ; this . replyCount = replyCount ; if ( lastState . equals ( \"<STR_LIT>\" ) ) { lastState = STATE_SHADOW_BAN ; firstState = STATE_NORMAL ; } if ( lastState . equals ( \"<STR_LIT>\" ) ) { lastState = STATE_DELETED ; } this . lastState = lastState ; this . lastCheckDate = lastCheckDate ; } public HistoryComment ( Comment originalComment ) { super ( originalComment . commentArea , originalComment . rpid , originalComment . parent , originalComment . root , originalComment . comment , originalComment . pictures , originalComment . date ) ; } public String getFormatLastCheckDateFor_yMd ( ) { return getFormatDateFor_yMd ( lastCheckDate ) ; } public String getFormatLastCheckDateFor_yMdHms ( ) { return getFormatDateFor_yMdHms ( lastCheckDate ) ; } public void setFirstStateAndCurrentState ( String state ) { this . firstState = state ; this . lastState = state ; } public static String getStateDesc ( String state ) { if ( TextUtils . isEmpty ( state ) ) { return \"<STR_LIT>\" ; } switch ( state ) { case STATE_NORMAL : return \"<STR_LIT>\" ; case STATE_SHADOW_BAN : return \"<STR_LIT>\" ; case STATE_DELETED : return \"<STR_LIT>\" ; case STATE_INVISIBLE : return \"<STR_LIT>\" ; case STATE_UNDER_REVIEW : return \"<STR_LIT>\" ;", "output": "case STATE_SUSPECTED_NO_PROBLEM : return \"<STR_LIT>\" ; case STATE_SENSITIVE : return \"<STR_LIT>\" ; case STATE_UNKNOWN : return \"<STR_LIT>\" ; default : return state ; } } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + like + \"<STR_LIT>\" + replyCount + \"<STR_LIT>\" + checkedArea + \"<STR_LIT>\" + firstState + '<STR_LIT>' + \"<STR_LIT>\" + lastState + '<STR_LIT>' + \"<STR_LIT>\" + lastCheckDate + \"<STR_LIT>\" + sensitiveScanResult + \"<STR_LIT>\" + commentArea + \"<STR_LIT>\" + rpid + \"<STR_LIT>\" + parent + \"<STR_LIT>\" + root + \"<STR_LIT>\" + comment + '<STR_LIT>' + \"<STR_LIT>\" + pictures + '<STR_LIT>' + \"<STR_LIT>\" + date + '<STR_LIT>' ; } }"}, {"input": "package com . appspa . update . service ; import android . app . Notification ; import android . app . NotificationChannel ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . os . Binder ; import android . os . Build ; import android . os . Handler ; import android . os . IBinder ; import android . os . Looper ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . app . NotificationCompat ; import com . appspa . update . AppSpace ; import com . appspa . update . R ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . utils . ApkUtils ; import com . appspa . update . utils . FileUtils ; import com . appspa . update . utils . PatchUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; import static com . appspa . update . entity . UpdateError . ERROR . DOWNLOAD_FAILED ; import static com . appspa . update . entity . UpdateError . ERROR . FAIL_PATCH ; public class DownloadService extends Service { private static final int DOWNLOAD_NOTIFY_ID = <NUM_LIT> ; private static boolean sIsRunning = false ; private static final String CHANNEL_ID = \"<STR_LIT>\" ; private static final CharSequence CHANNEL_NAME = \"<STR_LIT>\" ; private NotificationManager mNotificationManager ; private NotificationCompat . Builder mBuilder ; public static void bindService ( ServiceConnection connection ) { Intent intent = new Intent ( AppSpace . getContext ( ) , DownloadService . class ) ; AppSpace . getContext ( ) . startService ( intent ) ; AppSpace . getContext ( ) . bindService ( intent , connection , Context . BIND_AUTO_CREATE ) ; sIsRunning = true ; } private void stop ( String contentText ) { if ( mBuilder != null ) { mBuilder . setContentTitle ( UpdateUtils . getAppName ( DownloadService . this ) ) . setContentText ( contentText ) ; Notification notification = mBuilder . build ( ) ; notification . flags = Notification . FLAG_AUTO_CANCEL ; mNotificationManager . notify ( DOWNLOAD_NOTIFY_ID , notification ) ; } close ( ) ; } private void close ( ) { sIsRunning = false ; stopSelf ( ) ; } public static boolean isRunning ( ) { return sIsRunning ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; mNotificationManager = ( NotificationManager ) getSystemService ( android . content . Context . NOTIFICATION_SERVICE ) ; } @ Nullable @ Override public IBinder onBind ( Intent intent ) { sIsRunning = true ; return new DownloadBinder ( ) ; } @ Override public boolean onUnbind ( Intent intent ) { sIsRunning = false ; return super . onUnbind ( intent ) ; } @ Override public void onDestroy ( ) { mNotificationManager = null ; mBuilder = null ; super . onDestroy ( ) ; } private void setUpNotification ( @ NonNull DownloadEntity downloadEntity ) { if ( ! downloadEntity . isShowNotification ( ) ) { return ; } initNotification ( ) ; } private void initNotification ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { NotificationChannel channel = new NotificationChannel ( CHANNEL_ID , CHANNEL_NAME , NotificationManager . IMPORTANCE_HIGH ) ; channel . enableVibration ( false ) ; channel . enableLights ( false ) ; mNotificationManager . createNotificationChannel ( channel ) ; } mBuilder = getNotificationBuilder ( ) ; mNotificationManager . notify ( DOWNLOAD_NOTIFY_ID , mBuilder . build ( ) ) ; } private NotificationCompat . Builder getNotificationBuilder ( ) { return new NotificationCompat . Builder ( this , CHANNEL_ID ) . setContentTitle ( getString ( R . string . space_start_download ) ) . setContentText ( getString ( R . string . space_connecting_service ) ) . setSmallIcon ( R . drawable . spa_icon_app_update ) . setLargeIcon ( UpdateUtils . drawable2Bitmap ( UpdateUtils . getAppIcon ( DownloadService . this ) ) ) . setOngoing ( true ) . setAutoCancel ( true ) . setWhen ( System . currentTimeMillis ( ) ) ; } public class DownloadBinder extends Binder { private FileDownloadCallBack mFileDownloadCallBack ; private UpdateEntity mUpdateEntity ; public void start ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { mUpdateEntity = updateEntity ; startDownload ( updateEntity , mFileDownloadCallBack = new FileDownloadCallBack ( updateEntity , downloadListener ) ) ; } public void stop ( String msg ) { if ( mFileDownloadCallBack != null ) { mFileDownloadCallBack . onCancel ( ) ; mFileDownloadCallBack = null ; } if ( mUpdateEntity . getIUpdateHttpService ( ) != null ) { mUpdateEntity . getIUpdateHttpService ( ) . cancelDownload ( mUpdateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ) ; } else { UpdateLog . e ( \"<STR_LIT>\" ) ; } DownloadService . this . stop ( msg ) ; } public void showNotification ( ) { if ( mBuilder == null && DownloadService . isRunning ( ) ) { initNotification ( ) ; } } } private void startDownload ( @ NonNull UpdateEntity updateEntity , @ NonNull FileDownloadCallBack fileDownloadCallBack ) { DownloadEntity downLoadEntity = updateEntity . getCurDownloadEntity ( ) ; String apkUrl = downLoadEntity . getDownloadUrl ( ) ; if ( TextUtils . isEmpty ( apkUrl ) ) { String contentText = getString ( R . string . space_tip_download_url_error ) ; stop ( contentText ) ; return ; } String apkName = UpdateUtils . getFileNameByDownloadUrl ( apkUrl ) ; File apkCacheDir = FileUtils . getFileByPath ( updateEntity . getCacheDir ( ) ) ; if ( apkCacheDir == null ) { apkCacheDir = UpdateUtils . getDefaultDiskCacheDir ( ) ; } try { if ( ! FileUtils . isFileExists ( apkCacheDir ) ) { apkCacheDir . mkdirs ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } String target = apkCacheDir + File . separator + updateEntity . getVersionName ( ) ; UpdateLog . d ( \"<STR_LIT>\" + apkUrl + \"<STR_LIT>\" + target + \"<STR_LIT>\" + apkName ) ; if ( updateEntity . getIUpdateHttpService ( ) != null ) { updateEntity . getIUpdateHttpService ( ) . download ( apkUrl , target , apkName , fileDownloadCallBack ) ; } else { UpdateLog . e ( \"<STR_LIT>\" ) ; } } private class FileDownloadCallBack implements IUpdateHttpService . DownloadCallback { private final DownloadEntity mDownloadEntity ; private OnFileDownloadListener mOnFileDownloadListener ; private final boolean mIsAutoInstall ; private int mOldRate = <NUM_LIT> ; private boolean mIsCancel ; private final Handler mMainHandler ; FileDownloadCallBack ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener listener ) { mDownloadEntity = updateEntity . getCurDownloadEntity ( ) ; mIsAutoInstall = updateEntity . isAutoInstall ( ) ; mOnFileDownloadListener = listener ; mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; } @ Override public void onStart ( ) { if ( mIsCancel ) { return ; } mNotificationManager . cancel ( DOWNLOAD_NOTIFY_ID ) ; mBuilder = null ; setUpNotification ( mDownloadEntity ) ; dispatchOnStart ( ) ; } private void dispatchOnStart ( ) { if ( UpdateUtils . isMainThread ( ) ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onStart ( ) ; } } else { mMainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onStart ( ) ; } } } ) ; } } @ Override public void onProgress ( float progress , long total ) { if ( mIsCancel ) { return ; } int rate = Math . round ( progress * <NUM_LIT> ) ; if ( canRefreshProgress ( rate ) ) { dispatchOnProgress ( progress , total ) ; if ( mBuilder != null ) { mBuilder . setContentTitle ( getString ( R . string . space_lab_downloading ) + UpdateUtils . getAppName ( DownloadService . this ) ) . setContentText ( rate + \"<STR_LIT>\" ) . setProgress ( <NUM_LIT> , rate , false ) . setWhen ( System . currentTimeMillis ( ) ) ; Notification notification = mBuilder . build ( ) ; notification . flags = Notification . FLAG_AUTO_CANCEL | Notification . FLAG_ONLY_ALERT_ONCE ; mNotificationManager . notify ( DOWNLOAD_NOTIFY_ID , notification ) ; } mOldRate = rate ; } } private boolean canRefreshProgress ( int newRate ) { if ( mBuilder != null ) { return Math . abs ( newRate - mOldRate ) >= <NUM_LIT> ; } else { return Math . abs ( newRate - mOldRate ) >= <NUM_LIT> ; } } private void dispatchOnProgress ( final float progress , final long total ) { if ( UpdateUtils . isMainThread ( ) ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onProgress ( progress , total ) ; } } else { mMainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onProgress ( progress , total ) ; } } } ) ; } } @ Override public void onSuccess ( final File file ) { File apkFile ; if ( mDownloadEntity != null && mDownloadEntity . isPatch ( ) ) {", "output": "if ( ! mDownloadEntity . isFileValid ( file ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . FAIL_OLD_MD5 , \"<STR_LIT>\" ) ; return ; } String newApkPath = file . getAbsolutePath ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; long currentTime = System . currentTimeMillis ( ) ; int result = patchApk ( DownloadService . this , file , newApkPath ) ; UpdateLog . d ( \"<STR_LIT>\" + ( System . currentTimeMillis ( ) - currentTime ) ) ; if ( result == <NUM_LIT> ) { apkFile = new File ( newApkPath ) ; } else { onError ( FAIL_PATCH , new Throwable ( \"<STR_LIT>\" ) ) ; return ; } } else { apkFile = file ; } if ( UpdateUtils . isMainThread ( ) ) { handleOnSuccess ( apkFile ) ; } else { mMainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { handleOnSuccess ( apkFile ) ; } } ) ; } } private int patchApk ( Context context , File patchFile , String newAPKPath ) { String oldApkSource = ApkUtils . getSourceApkPath ( context , context . getPackageName ( ) ) ; return PatchUtils . patch ( oldApkSource , newAPKPath , patchFile . getAbsolutePath ( ) ) ; } private void handleOnSuccess ( File file ) { if ( mIsCancel ) { return ; } if ( mOnFileDownloadListener != null ) { if ( ! mOnFileDownloadListener . onCompleted ( file ) ) { close ( ) ; return ; } } UpdateLog . d ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; try { if ( UpdateUtils . isAppOnForeground ( DownloadService . this ) ) { mNotificationManager . cancel ( DOWNLOAD_NOTIFY_ID ) ; if ( mIsAutoInstall ) { _AppSpace . startInstallApk ( DownloadService . this , file , mDownloadEntity ) ; } else { showDownloadCompleteNotification ( file ) ; } } else { showDownloadCompleteNotification ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } close ( ) ; } @ Override public void onError ( Throwable throwable ) { onError ( DOWNLOAD_FAILED , throwable ) ; } public void onError ( int code , Throwable throwable ) { if ( mIsCancel ) { return ; } _AppSpace . onUpdateError ( code , throwable != null ? throwable . getMessage ( ) : \"<STR_LIT>\" ) ; dispatchOnError ( throwable ) ; try { mNotificationManager . cancel ( DOWNLOAD_NOTIFY_ID ) ; close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void dispatchOnError ( final Throwable throwable ) { if ( UpdateUtils . isMainThread ( ) ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onError ( throwable ) ; } } else { mMainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( mOnFileDownloadListener != null ) { mOnFileDownloadListener . onError ( throwable ) ; } } } ) ; } } void onCancel ( ) { mOnFileDownloadListener = null ; mIsCancel = true ; } } private void showDownloadCompleteNotification ( File file ) { Intent installAppIntent = ApkUtils . getInstallAppIntent ( file ) ; PendingIntent contentIntent = PendingIntent . getActivity ( DownloadService . this , <NUM_LIT> , installAppIntent , PendingIntent . FLAG_UPDATE_CURRENT ) ; if ( mBuilder == null ) { mBuilder = getNotificationBuilder ( ) ; } mBuilder . setContentIntent ( contentIntent ) . setContentTitle ( UpdateUtils . getAppName ( DownloadService . this ) ) . setContentText ( getString ( R . string . space_download_complete ) ) . setProgress ( <NUM_LIT> , <NUM_LIT> , false ) . setDefaults ( ( Notification . DEFAULT_ALL ) ) ; Notification notification = mBuilder . build ( ) ; notification . flags = Notification . FLAG_AUTO_CANCEL ; mNotificationManager . notify ( DOWNLOAD_NOTIFY_ID , notification ) ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import androidx . annotation . NonNull ; public interface PopupTextProvider { @ NonNull CharSequence getPopupText ( @ NonNull View view , int position ) ;", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; import java . io . File ; import java . util . ArrayDeque ; import java . util . Arrays ; import java . util . Objects ; import java . util . Queue ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . LinkedBlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferJob ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferJob ; public class JobPublisher { public static final int sliceSize = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private FileTransferJob currentFileSliceJob ; private TransferJob currentTransferJob ; private final BlockingDeque < TransferJob > transferJobQueue ; private Queue < File > fileQueue ; public JobPublisher ( ) { this . transferJobQueue = new LinkedBlockingDeque < > ( ) ; this . fileQueue = new ArrayDeque < > ( ) ; } public synchronized FileTransferJob getNextJob ( ) throws InterruptedException { if ( currentFileSliceJob != null ) { long startSeek = currentFileSliceJob . startRange + sliceSize ; long endSeek = startSeek + sliceSize ; if ( endSeek <= currentFileSliceJob . getTotalSize ( ) ) { currentFileSliceJob = new FileTransferJob ( currentFileSliceJob , startSeek , endSeek ) ; return currentFileSliceJob ; } else if ( startSeek <= currentFileSliceJob . getTotalSize ( ) ) { currentFileSliceJob = new FileTransferJob ( currentFileSliceJob , startSeek , currentFileSliceJob . getTotalSize ( ) ) ; return currentFileSliceJob ; } else { currentFileSliceJob = null ; } } if ( fileQueue . isEmpty ( ) ) { currentTransferJob = Objects . requireNonNull ( transferJobQueue . take ( ) ) ; fileQueue = currentTransferJob . fileQueue ; } File file = fileQueue . poll ( ) ; assert file != null ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files != null ) { fileQueue . addAll ( Arrays . asList ( files ) ) ; } } else if ( file . isFile ( ) ) { if ( file . length ( ) >= sliceSize * <NUM_LIT> ) { currentFileSliceJob = new FileTransferJob ( currentTransferJob . localDir , currentTransferJob . remoteDir , file , <NUM_LIT> , sliceSize ) ;", "output": "return currentFileSliceJob ; } } return new FileTransferJob ( currentTransferJob . localDir , currentTransferJob . remoteDir , file ) ; } public void addJob ( TransferJob transferJob ) { transferJobQueue . add ( transferJob ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . core . os . TraceCompat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . TimeUnit ; final class GapWorker implements Runnable { static final ThreadLocal < GapWorker > sGapWorker = new ThreadLocal < > ( ) ; ArrayList < RecyclerView > mRecyclerViews = new ArrayList < > ( ) ; long mPostTimeNs ; long mFrameIntervalNs ; static class Task { public boolean immediate ; public int viewVelocity ; public int distanceToItem ; public RecyclerView view ; public int position ; public void clear ( ) { immediate = false ; viewVelocity = <NUM_LIT> ; distanceToItem = <NUM_LIT> ; view = null ; position = <NUM_LIT> ; } } private ArrayList < Task > mTasks = new ArrayList < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static class LayoutPrefetchRegistryImpl implements RecyclerView . LayoutManager . LayoutPrefetchRegistry { int mPrefetchDx ; int mPrefetchDy ; int [ ] mPrefetchArray ; int mCount ; void setPrefetchVector ( int dx , int dy ) { mPrefetchDx = dx ; mPrefetchDy = dy ; } void collectPrefetchPositionsFromView ( RecyclerView view , boolean nested ) { mCount = <NUM_LIT> ; if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } final RecyclerView . LayoutManager layout = view . mLayout ; if ( view . mAdapter != null && layout != null && layout . isItemPrefetchEnabled ( ) ) { if ( nested ) { if ( ! view . mAdapterHelper . hasPendingUpdates ( ) ) { layout . collectInitialPrefetchPositions ( view . mAdapter . getItemCount ( ) , this ) ; } } else { if ( ! view . hasPendingAdapterUpdates ( ) ) { layout . collectAdjacentPrefetchPositions ( mPrefetchDx , mPrefetchDy , view . mState , this ) ; } } if ( mCount > layout . mPrefetchMaxCountObserved ) { layout . mPrefetchMaxCountObserved = mCount ; layout . mPrefetchMaxObservedInInitialPrefetch = nested ; view . mRecycler . updateViewCacheSize ( ) ; } } } @ Override public void addPosition ( int layoutPosition , int pixelDistance ) { if ( layoutPosition < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( pixelDistance < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } final int storagePosition = mCount * <NUM_LIT> ; if ( mPrefetchArray == null ) { mPrefetchArray = new int [ <NUM_LIT> ] ; Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } else if ( storagePosition >= mPrefetchArray . length ) { final int [ ] oldArray = mPrefetchArray ; mPrefetchArray = new int [ storagePosition * <NUM_LIT> ] ; System . arraycopy ( oldArray , <NUM_LIT> , mPrefetchArray , <NUM_LIT> , oldArray . length ) ; } mPrefetchArray [ storagePosition ] = layoutPosition ; mPrefetchArray [ storagePosition + <NUM_LIT> ] = pixelDistance ; mCount ++ ; } boolean lastPrefetchIncludedPosition ( int position ) { if ( mPrefetchArray != null ) { final int count = mCount * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < count ; i += <NUM_LIT> ) { if ( mPrefetchArray [ i ] == position ) return true ; } } return false ; } void clearPrefetchPositions ( ) { if ( mPrefetchArray != null ) { Arrays . fill ( mPrefetchArray , - <NUM_LIT> ) ; } mCount = <NUM_LIT> ; } } public void add ( RecyclerView recyclerView ) { if ( RecyclerView . sDebugAssertionsEnabled && mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerViews . add ( recyclerView ) ; } public void remove ( RecyclerView recyclerView ) { boolean removeSuccess = mRecyclerViews . remove ( recyclerView ) ; if ( RecyclerView . sDebugAssertionsEnabled && ! removeSuccess ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } void postFromTraversal ( RecyclerView recyclerView , int prefetchDx , int prefetchDy ) { if ( recyclerView . isAttachedToWindow ( ) ) { if ( RecyclerView . sDebugAssertionsEnabled && ! mRecyclerViews . contains ( recyclerView ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( mPostTimeNs == <NUM_LIT> ) { mPostTimeNs = recyclerView . getNanoTime ( ) ; recyclerView . post ( this ) ; } } recyclerView . mPrefetchRegistry . setPrefetchVector ( prefetchDx , prefetchDy ) ; } static Comparator < Task > sTaskComparator = new Comparator < Task > ( ) { @ Override public int compare ( Task lhs , Task rhs ) { if ( ( lhs . view == null ) != ( rhs . view == null ) ) { return lhs . view == null ? <NUM_LIT> : - <NUM_LIT> ; } if ( lhs . immediate != rhs . immediate ) { return lhs . immediate ? - <NUM_LIT> : <NUM_LIT> ; } int deltaViewVelocity = rhs . viewVelocity - lhs . viewVelocity ; if ( deltaViewVelocity != <NUM_LIT> ) return deltaViewVelocity ; int deltaDistanceToItem = lhs . distanceToItem - rhs . distanceToItem ; if ( deltaDistanceToItem != <NUM_LIT> ) return deltaDistanceToItem ; return <NUM_LIT> ; } } ; private void buildTaskList ( ) { final int viewCount = mRecyclerViews . size ( ) ; int totalTaskCount = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { view . mPrefetchRegistry . collectPrefetchPositionsFromView ( view , false ) ; totalTaskCount += view . mPrefetchRegistry . mCount ; } } mTasks . ensureCapacity ( totalTaskCount ) ; int totalTaskIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < viewCount ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) != View . VISIBLE ) { continue ; } LayoutPrefetchRegistryImpl prefetchRegistry = view . mPrefetchRegistry ; final int viewVelocity = Math . abs ( prefetchRegistry . mPrefetchDx ) + Math . abs ( prefetchRegistry . mPrefetchDy ) ; for ( int j = <NUM_LIT> ; j < prefetchRegistry . mCount * <NUM_LIT> ; j += <NUM_LIT> ) { final Task task ; if ( totalTaskIndex >= mTasks . size ( ) ) { task = new Task ( ) ; mTasks . add ( task ) ; } else { task = mTasks . get ( totalTaskIndex ) ; } final int distanceToItem = prefetchRegistry . mPrefetchArray [ j + <NUM_LIT> ] ; task . immediate = distanceToItem <= viewVelocity ; task . viewVelocity = viewVelocity ; task . distanceToItem = distanceToItem ; task . view = view ; task . position = prefetchRegistry . mPrefetchArray [ j ] ; totalTaskIndex ++ ; } } Collections . sort ( mTasks , sTaskComparator ) ; } static boolean isPrefetchPositionAttached ( RecyclerView view , int position ) { final int childCount = view . mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View attachedView = view . mChildHelper . getUnfilteredChildAt ( i ) ; RecyclerView . ViewHolder holder = RecyclerView . getChildViewHolderInt ( attachedView ) ; if ( holder . mPosition == position && ! holder . isInvalid ( ) ) { return true ; } } return false ; } private RecyclerView . ViewHolder prefetchPositionWithDeadline ( RecyclerView view , int position , long deadlineNs ) { if ( isPrefetchPositionAttached ( view , position ) ) { return null ; } RecyclerView . Recycler recycler = view . mRecycler ; RecyclerView . ViewHolder holder ; try { view . onEnterLayoutOrScroll ( ) ; holder = recycler . tryGetViewHolderForPositionByDeadline ( position , false , deadlineNs ) ; if ( holder != null ) { if ( holder . isBound ( ) && ! holder . isInvalid ( ) ) { recycler . recycleView ( holder . itemView ) ; } else { recycler . addViewHolderToRecycledViewPool ( holder , false ) ; } } } finally { view . onExitLayoutOrScroll ( false ) ; } return holder ; } private void prefetchInnerRecyclerViewWithDeadline ( @ Nullable RecyclerView innerView , long deadlineNs ) { if ( innerView == null ) { return ; } if ( innerView . mDataSetHasChangedAfterLayout && innerView . mChildHelper . getUnfilteredChildCount ( ) != <NUM_LIT> ) { innerView . removeAndRecycleViews ( ) ; } final LayoutPrefetchRegistryImpl innerPrefetchRegistry = innerView . mPrefetchRegistry ; innerPrefetchRegistry . collectPrefetchPositionsFromView ( innerView , true ) ; if ( innerPrefetchRegistry . mCount != <NUM_LIT> ) { try { TraceCompat . beginSection ( RecyclerView . TRACE_NESTED_PREFETCH_TAG ) ; innerView . mState . prepareForNestedPrefetch ( innerView . mAdapter ) ; for ( int i = <NUM_LIT> ; i < innerPrefetchRegistry . mCount * <NUM_LIT> ; i += <NUM_LIT> ) { final int innerPosition = innerPrefetchRegistry . mPrefetchArray [ i ] ; prefetchPositionWithDeadline ( innerView , innerPosition , deadlineNs ) ; } } finally { TraceCompat . endSection ( ) ; } } } private void flushTaskWithDeadline ( Task task , long deadlineNs ) { long taskDeadlineNs = task . immediate ? RecyclerView . FOREVER_NS : deadlineNs ; RecyclerView . ViewHolder holder = prefetchPositionWithDeadline ( task . view , task . position , taskDeadlineNs ) ; if ( holder != null && holder . mNestedRecyclerView != null && holder . isBound ( ) && ! holder . isInvalid ( ) ) { prefetchInnerRecyclerViewWithDeadline ( holder . mNestedRecyclerView . get ( ) , deadlineNs ) ; } } private void flushTasksWithDeadline ( long deadlineNs ) { for ( int i = <NUM_LIT> ; i < mTasks . size ( ) ; i ++ ) { final Task task = mTasks . get ( i ) ; if ( task . view == null ) { break ; } flushTaskWithDeadline ( task , deadlineNs ) ; task . clear ( ) ; } } void prefetch ( long deadlineNs ) { buildTaskList ( ) ; flushTasksWithDeadline ( deadlineNs ) ; } @ Override public void run ( ) { try { TraceCompat . beginSection ( RecyclerView . TRACE_PREFETCH_TAG ) ; if ( mRecyclerViews . isEmpty ( ) ) { return ; } final int size = mRecyclerViews . size ( ) ; long latestFrameVsyncMs = <NUM_LIT> ;", "output": "for ( int i = <NUM_LIT> ; i < size ; i ++ ) { RecyclerView view = mRecyclerViews . get ( i ) ; if ( view . getWindowVisibility ( ) == View . VISIBLE ) { latestFrameVsyncMs = Math . max ( view . getDrawingTime ( ) , latestFrameVsyncMs ) ; } } if ( latestFrameVsyncMs == <NUM_LIT> ) { return ; } long nextFrameNs = TimeUnit . MILLISECONDS . toNanos ( latestFrameVsyncMs ) + mFrameIntervalNs ; prefetch ( nextFrameNs ) ; } finally { mPostTimeNs = <NUM_LIT> ; TraceCompat . endSection ( ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; public interface DeleteDownloadedModelResultCallback { void success ( ) ;", "output": "void error ( Exception exception ) ; }"}, {"input": "package external . org . apache . commons . lang3 ; import java . io . File ; public class SystemUtils { private static final String OS_NAME_WINDOWS_PREFIX = \"<STR_LIT>\" ; private static final String USER_HOME_KEY = \"<STR_LIT>\" ; private static final String USER_DIR_KEY = \"<STR_LIT>\" ; private static final String JAVA_IO_TMPDIR_KEY = \"<STR_LIT>\" ; private static final String JAVA_HOME_KEY = \"<STR_LIT>\" ; public static final String AWT_TOOLKIT = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String FILE_ENCODING = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String FILE_SEPARATOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_AWT_FONTS = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_AWT_GRAPHICSENV = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_AWT_HEADLESS = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_AWT_PRINTERJOB = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_CLASS_PATH = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_CLASS_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_COMPILER = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_ENDORSED_DIRS = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_EXT_DIRS = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_HOME = getSystemProperty ( JAVA_HOME_KEY ) ; public static final String JAVA_IO_TMPDIR = getSystemProperty ( JAVA_IO_TMPDIR_KEY ) ; public static final String JAVA_LIBRARY_PATH = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_RUNTIME_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_RUNTIME_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_SPECIFICATION_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_SPECIFICATION_VENDOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_SPECIFICATION_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; private static final JavaVersion JAVA_SPECIFICATION_VERSION_AS_ENUM = JavaVersion . get ( JAVA_SPECIFICATION_VERSION ) ; public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VENDOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VENDOR_URL = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_INFO = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_SPECIFICATION_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_SPECIFICATION_VENDOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_SPECIFICATION_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_VENDOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String JAVA_VM_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String LINE_SEPARATOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String OS_ARCH = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String OS_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String OS_VERSION = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String PATH_SEPARATOR = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String USER_COUNTRY = getSystemProperty ( \"<STR_LIT>\" ) == null ? getSystemProperty ( \"<STR_LIT>\" ) : getSystemProperty ( \"<STR_LIT>\" ) ; public static final String USER_DIR = getSystemProperty ( USER_DIR_KEY ) ; public static final String USER_HOME = getSystemProperty ( USER_HOME_KEY ) ; public static final String USER_LANGUAGE = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String USER_NAME = getSystemProperty ( \"<STR_LIT>\" ) ; public static final String USER_TIMEZONE = getSystemProperty ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_1 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_2 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_3 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_4 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_5 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_6 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_JAVA_1_7 = getJavaVersionMatches ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_AIX = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_HP_UX = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_IRIX = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_LINUX = getOSMatchesName ( \"<STR_LIT>\" ) || getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_MAC = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_MAC_OSX = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_FREE_BSD = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_OPEN_BSD = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_NET_BSD = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_OS2 = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_SOLARIS = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_SUN_OS = getOSMatchesName ( \"<STR_LIT>\" ) ; public static final boolean IS_OS_UNIX = IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX || IS_OS_MAC_OSX || IS_OS_SOLARIS || IS_OS_SUN_OS || IS_OS_FREE_BSD || IS_OS_OPEN_BSD || IS_OS_NET_BSD ; public static final boolean IS_OS_WINDOWS = getOSMatchesName ( OS_NAME_WINDOWS_PREFIX ) ; public static final boolean IS_OS_WINDOWS_2000 = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_2003 = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_2008 = getOSMatches ( OS_NAME_WINDOWS_PREFIX + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_95 = getOSMatches ( OS_NAME_WINDOWS_PREFIX + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_98 = getOSMatches ( OS_NAME_WINDOWS_PREFIX + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_ME = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_NT = getOSMatchesName ( OS_NAME_WINDOWS_PREFIX + \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_XP = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_VISTA = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static final boolean IS_OS_WINDOWS_7 = getOSMatches ( OS_NAME_WINDOWS_PREFIX , \"<STR_LIT>\" ) ; public static File getJavaHome ( ) { return new File ( System . getProperty ( JAVA_HOME_KEY ) ) ; } public static File getJavaIoTmpDir ( ) { return new File ( System . getProperty ( JAVA_IO_TMPDIR_KEY ) ) ; } private static boolean getJavaVersionMatches ( String versionPrefix ) { return isJavaVersionMatch ( JAVA_SPECIFICATION_VERSION , versionPrefix ) ; } private static boolean getOSMatches ( String osNamePrefix , String osVersionPrefix ) { return isOSMatch ( OS_NAME , OS_VERSION , osNamePrefix , osVersionPrefix ) ; } private static boolean getOSMatchesName ( String osNamePrefix ) { return isOSNameMatch ( OS_NAME , osNamePrefix ) ; } private static String getSystemProperty ( String property ) { try { return System . getProperty ( property ) ; } catch ( SecurityException ex ) { System . err . println ( \"<STR_LIT>\" + property + \"<STR_LIT>\" ) ; return null ; } } public static File getUserDir ( ) { return new File ( System . getProperty ( USER_DIR_KEY ) ) ; } public static File getUserHome ( ) { return new File ( System . getProperty ( USER_HOME_KEY ) ) ; } public static boolean isJavaAwtHeadless ( ) { return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS . equals ( Boolean . TRUE . toString ( ) ) : false ; } public static boolean isJavaVersionAtLeast ( JavaVersion requiredVersion ) { return JAVA_SPECIFICATION_VERSION_AS_ENUM . atLeast ( requiredVersion ) ; } static boolean isJavaVersionMatch ( String version , String versionPrefix ) { if ( version == null ) { return false ; } return version . startsWith ( versionPrefix ) ; } static boolean isOSMatch ( String osName , String osVersion , String osNamePrefix , String osVersionPrefix ) { if ( osName == null || osVersion == null ) { return false ; } return osName . startsWith ( osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ; } static boolean isOSNameMatch ( String osName , String osNamePrefix ) { if ( osName == null ) { return false ; } return osName . startsWith ( osNamePrefix ) ; } public SystemUtils ( ) { super ( ) ;", "output": "} }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class SetChannelOptions { @ NonNull private String channel ; public SetChannelOptions ( @ NonNull String channel ) { this . channel = channel ; } @ NonNull public String getChannel ( ) {", "output": "return channel ; } }"}, {"input": "package com . reactnative . wheelpicker ; import android . graphics . Color ; import android . os . Handler ; import android . text . TextUtils ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . SimpleViewManager ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import javax . annotation . Nonnull ; import javax . annotation . Nullable ; public class PickerViewManager extends SimpleViewManager < PickerView > { public static final String REACT_CLASS = \"<STR_LIT>\" ; @ Nonnull @ Override public String getName ( ) { return REACT_CLASS ; } @ Nonnull @ Override protected PickerView createViewInstance ( @ Nonnull ThemedReactContext reactContext ) { return new PickerView ( reactContext ) ; } @ Override public void onDropViewInstance ( @ Nonnull PickerView view ) { super . onDropViewInstance ( view ) ; Handler handler = view . wheelView . getHandler ( ) ; if ( handler != null ) { handler . removeCallbacksAndMessages ( null ) ; } } @ Nullable @ Override public Map < String , Object > getExportedCustomBubblingEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( \"<STR_LIT>\" , MapBuilder . of ( \"<STR_LIT>\" , MapBuilder . of ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) . build ( ) ;", "output": "} @ ReactProp ( name = \"<STR_LIT>\" ) public void selectedIndex ( PickerView pickerView , int index ) { pickerView . setSelectedItem ( index ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setTextSize ( PickerView pickerView , int size ) { pickerView . setTextSize ( size ) ; } @ ReactProp ( name = \"<STR_LIT>\" , defaultInt = <NUM_LIT> ) public void setItemHeight ( PickerView pickerView , int height ) { pickerView . setItemHeight ( PixelUtil . toPixelFromDIP ( height ) ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setTextColorCenter ( PickerView pickerView , String color ) { if ( ! TextUtils . isEmpty ( color ) ) { pickerView . setTextColorCenter ( Color . parseColor ( color ) ) ; } } @ ReactProp ( name = \"<STR_LIT>\" ) public void setTextColorOut ( PickerView pickerView , String color ) { if ( ! TextUtils . isEmpty ( color ) ) { pickerView . setTextColorOut ( Color . parseColor ( color ) ) ; } } @ ReactProp ( name = \"<STR_LIT>\" ) public void items ( PickerView pickerView , ReadableArray items ) { if ( items == null ) { pickerView . setItems ( Collections . < String > emptyList ( ) ) ; } else { List < String > list = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < items . size ( ) ; i ++ ) { list . add ( items . getString ( i ) ) ; } pickerView . setItems ( list ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . util . Log ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . math . BigInteger ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; public class FileAudioInputStream extends InputStream { private InputStream in ; private long nextSleepTime = - <NUM_LIT> ; private long totalSleepMs = <NUM_LIT> ; private static final String TAG = \"<STR_LIT>\" ; public FileAudioInputStream ( String file ) throws FileNotFoundException { in = new FileInputStream ( file ) ; } public FileAudioInputStream ( InputStream in ) { this . in = in ; } @ Override public int read ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public int read ( byte [ ] buffer , int byteOffset , int byteCount ) throws IOException { int bytePerMs = <NUM_LIT> * <NUM_LIT> / <NUM_LIT> ; int count = bytePerMs * <NUM_LIT> ; if ( byteCount < count ) { count = byteCount ; } if ( nextSleepTime > <NUM_LIT> ) { try { long sleepMs = nextSleepTime - System . currentTimeMillis ( ) ; if ( sleepMs > <NUM_LIT> ) { Log . i ( TAG , \"<STR_LIT>\" + sleepMs ) ; Thread . sleep ( sleepMs ) ; totalSleepMs += sleepMs ; } }", "output": "catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } int r = in . read ( buffer , byteOffset , count ) ; nextSleepTime = System . currentTimeMillis ( ) + r / bytePerMs ; return r ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Log . i ( TAG , \"<STR_LIT>\" + totalSleepMs ) ; if ( null != in ) { in . close ( ) ; } } private String md5 ( byte [ ] buffer , int byteOffset , int byteCount ) { try { MessageDigest digest = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; digest . reset ( ) ; digest . update ( buffer , byteOffset , byteCount ) ; BigInteger bigInt = new BigInteger ( <NUM_LIT> , digest . digest ( ) ) ; return bigInt . toString ( <NUM_LIT> ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return null ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import java . util . Map ; import retrofit2 . Call ; import retrofit2 . http . Body ; import retrofit2 . http . Field ; import retrofit2 . http . FieldMap ; import retrofit2 . http . FormUrlEncoded ; import retrofit2 . http . GET ; import retrofit2 . http . Header ; import retrofit2 . http . POST ; import retrofit2 . http . Query ; public interface BiliApiService { int COMMENT_SORT_BY_TIME = <NUM_LIT> ; int COMMENT_SORT_BY_LIKE = <NUM_LIT> ; int COMMENT_SORT_BY_REPLY_COUNT = <NUM_LIT> ; int COMMENT_SORT_MODE_HOT = <NUM_LIT> ; int COMMENT_SORT_MODE_TIME = <NUM_LIT> ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < VideoInfo > > getVideoInfoByAid ( @ Query ( \"<STR_LIT>\" ) long aid ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < VideoInfo > > getVideoInfoByBvid ( @ Query ( \"<STR_LIT>\" ) String bvid ) ; @ FormUrlEncoded @ POST ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentAddResult > > postComment ( @ Header ( \"<STR_LIT>\" ) String cookie , @ FieldMap Map < String , String > map ) ;", "output": "@ FormUrlEncoded @ POST ( \"<STR_LIT>\" ) Call < GeneralResponse < Object > > deleteComment ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Field ( \"<STR_LIT>\" ) String csrf , @ Field ( \"<STR_LIT>\" ) long oid , @ Field ( \"<STR_LIT>\" ) int type , @ Field ( \"<STR_LIT>\" ) long rpid ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentReplyPage > > getCommentReply ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Query ( \"<STR_LIT>\" ) String csrf , @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int pn , @ Query ( \"<STR_LIT>\" ) int ps , @ Query ( \"<STR_LIT>\" ) long root , @ Query ( \"<STR_LIT>\" ) int type , @ Query ( \"<STR_LIT>\" ) int sort ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentReplyPage > > getCommentReply ( @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int pn , @ Query ( \"<STR_LIT>\" ) int ps , @ Query ( \"<STR_LIT>\" ) long root , @ Query ( \"<STR_LIT>\" ) int type , @ Query ( \"<STR_LIT>\" ) int sort ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentPage > > getCommentPageNoAccount ( @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int type , @ Query ( \"<STR_LIT>\" ) int pn , @ Query ( \"<STR_LIT>\" ) int sort ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentPage > > getCommentPageHasAccount ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Query ( \"<STR_LIT>\" ) String csrf , @ Query ( \"<STR_LIT>\" ) int sort , @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int pn , @ Query ( \"<STR_LIT>\" ) int type ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentPage > > getCommentMainPageHasAccount ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int type , @ Query ( \"<STR_LIT>\" ) int mode , @ Query ( \"<STR_LIT>\" ) int next , @ Query ( \"<STR_LIT>\" ) long seek_rpid ) ; @ GET ( \"<STR_LIT>\" ) Call < GeneralResponse < CommentPage > > getCommentMainPageNoAccount ( @ Header ( \"<STR_LIT>\" ) String cookie_buvid3 , @ Query ( \"<STR_LIT>\" ) long oid , @ Query ( \"<STR_LIT>\" ) int type , @ Query ( \"<STR_LIT>\" ) int mode , @ Query ( \"<STR_LIT>\" ) int next , @ Query ( \"<STR_LIT>\" ) long seek_rpid ) ; @ POST ( \"<STR_LIT>\" ) Call < GeneralResponse < ForwardDynamicResult > > forwardDynamic ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Query ( \"<STR_LIT>\" ) String platform , @ Query ( \"<STR_LIT>\" ) String csrf , @ Body ForwardDynamicReqObject forwardDynamicReqObject ) ; @ POST ( \"<STR_LIT>\" ) Call < GeneralResponse < Object > > removeDynamic ( @ Header ( \"<STR_LIT>\" ) String cookie , @ Query ( \"<STR_LIT>\" ) String platform , @ Query ( \"<STR_LIT>\" ) String csrf , @ Body RemoveDynamicReqObject removeDynamicReqObject ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import static android . content . Context . DOWNLOAD_SERVICE ; import android . app . DownloadManager ; import android . net . Uri ; import android . os . Environment ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . cloudinary . android . MediaManager ; import com . cloudinary . android . UploadRequest ; import com . cloudinary . android . callback . ErrorInfo ; import com . cloudinary . android . callback . UploadCallback ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; public class Cloudinary { class ActiveDownload { public String path ; public DownloadResourceResultCallback callback ; ActiveDownload ( String path , DownloadResourceResultCallback callback ) { this . path = path ; this . callback = callback ; } } private HashMap < Long , ActiveDownload > activeDownloads = new HashMap < Long , ActiveDownload > ( ) ; private CloudinaryPlugin plugin ; public Cloudinary ( CloudinaryPlugin plugin ) { this . plugin = plugin ; } public void initialize ( String cloudName ) { HashMap config = new HashMap ( ) ; config . put ( \"<STR_LIT>\" , cloudName ) ; config . put ( \"<STR_LIT>\" , true ) ; MediaManager . init ( plugin . getContext ( ) , config ) ; } public void uploadResource ( String resourceType , String path , String uploadPreset , @ Nullable String publicId , UploadResourceResultCallback callback ) { UploadRequest request = MediaManager . get ( ) . upload ( Uri . parse ( path ) ) . unsigned ( uploadPreset ) . option ( \"<STR_LIT>\" , resourceType ) ; if ( publicId != null ) { request . option ( \"<STR_LIT>\" , publicId ) ; } request . callback ( new UploadCallback ( ) { @ Override public void onStart ( String requestId ) { } @ Override public void onProgress ( String requestId , long bytes , long totalBytes ) { } @ Override public void onSuccess ( String requestId , Map resultData ) { callback . success ( resultData ) ; } @ Override public void onError ( String requestId , ErrorInfo error ) { callback . error ( error . getDescription ( ) ) ; } @ Override public void onReschedule ( String requestId , ErrorInfo error ) { } } ) . dispatch ( ) ; } public void downloadResource ( String url , DownloadResourceResultCallback callback ) { String fileName = url . substring ( url . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; DownloadManager . Request request = new DownloadManager . Request ( Uri . parse ( url ) ) . setNotificationVisibility ( DownloadManager . Request . VISIBILITY_HIDDEN ) . setDestinationInExternalPublicDir ( Environment . DIRECTORY_DOWNLOADS , fileName ) . setAllowedOverMetered ( true ) . setAllowedOverRoaming ( true ) ; DownloadManager downloadManager = ( DownloadManager ) plugin . getContext ( ) . getSystemService ( DOWNLOAD_SERVICE ) ; long downloadId = downloadManager . enqueue ( request ) ; String path = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) , fileName ) . getAbsolutePath ( ) ; activeDownloads . put ( downloadId , new ActiveDownload ( path , callback ) ) ; } public void handleDownloadCompleted ( long downloadId ) { ActiveDownload download = activeDownloads . get ( downloadId ) ; if ( download == null ) { return ;", "output": "} download . callback . success ( download . path ) ; } }"}, {"input": "package com . simon . harmonichackernews . linkpreview ; import android . content . Context ; import android . text . TextUtils ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . data . RepoInfo ; import com . simon . harmonichackernews . network . NetworkComponent ; import org . json . JSONObject ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class GitHubInfoGetter { public static boolean isValidGitHubUrl ( String url ) { String regex = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( url ) ; return matcher . matches ( ) ; } public static void getInfo ( String githubUrl , Context ctx , GetterCallback callback ) { try { String [ ] parts = githubUrl . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( \"<STR_LIT>\" ) ; String username = parts [ <NUM_LIT> ] ; String repoName = parts [ <NUM_LIT> ] ; String apiUrl = \"<STR_LIT>\" + username + \"<STR_LIT>\" + repoName ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , apiUrl , response -> { try { JSONObject jsonResponse = new JSONObject ( response ) ; RepoInfo repoInfo = new RepoInfo ( ) ; if ( jsonResponse . has ( \"<STR_LIT>\" ) ) { JSONObject owner = jsonResponse . getJSONObject ( \"<STR_LIT>\" ) ; repoInfo . owner = readJsonProp ( owner , \"<STR_LIT>\" ) ; } repoInfo . name = jsonResponse . optString ( \"<STR_LIT>\" ) ; repoInfo . about = readJsonProp ( jsonResponse , \"<STR_LIT>\" ) ; repoInfo . website = readJsonProp ( jsonResponse , \"<STR_LIT>\" ) ; if ( jsonResponse . has ( \"<STR_LIT>\" ) && ! jsonResponse . get ( \"<STR_LIT>\" ) . toString ( ) . equals ( \"<STR_LIT>\" ) ) { JSONObject license = jsonResponse . getJSONObject ( \"<STR_LIT>\" ) ; if ( license . has ( \"<STR_LIT>\" ) && license . getString ( \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { repoInfo . license = \"<STR_LIT>\" ; } else { repoInfo . license = readJsonProp ( license , \"<STR_LIT>\" ) ; } } repoInfo . language = readJsonProp ( jsonResponse , \"<STR_LIT>\" ) ; repoInfo . stars = jsonResponse . optInt ( \"<STR_LIT>\" ) ; repoInfo . watching = jsonResponse . optInt ( \"<STR_LIT>\" ) ; repoInfo . forks = jsonResponse . optInt ( \"<STR_LIT>\" ) ; callback . onSuccess ( repoInfo ) ; } catch ( Exception e ) { callback . onFailure ( \"<STR_LIT>\" ) ; e . printStackTrace ( ) ; } } , error -> { error . printStackTrace ( ) ;", "output": "callback . onFailure ( \"<STR_LIT>\" ) ; } ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( ctx ) ; queue . add ( stringRequest ) ; } catch ( Exception e ) { callback . onFailure ( \"<STR_LIT>\" ) ; } } private static String readJsonProp ( JSONObject jsonObject , String key ) { String input = jsonObject . optString ( key ) ; if ( TextUtils . isEmpty ( input ) || input . equals ( \"<STR_LIT>\" ) ) { return null ; } return input ; } public interface GetterCallback { void onSuccess ( RepoInfo repoInfo ) ; void onFailure ( String reason ) ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewParent ; import androidx . core . graphics . Insets ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . views . scroll . ReactScrollView ; public class KeyboardAutoHandler { private final KeyboardInsetsView view ; private final ThemedReactContext reactContext ; public KeyboardAutoHandler ( KeyboardInsetsView view , ThemedReactContext reactContext ) { this . view = view ; this . reactContext = reactContext ; } private int keyboardHeight ; private boolean forceUpdated = false ; void onStart ( View focusView , int keyboardHeight ) { adjustScrollViewOffsetIfNeeded ( focusView ) ; if ( keyboardHeight != this . keyboardHeight ) { forceUpdated = true ; } this . keyboardHeight = keyboardHeight ; } void onEnd ( View focusView , int keyboardHeight ) { } void onApplyWindowInsets ( WindowInsetsCompat insets , View focusView , int keyboardHeight ) { if ( focusView == null ) { view . setTranslationY ( <NUM_LIT> ) ; return ; } adjustScrollViewOffsetIfNeeded ( focusView ) ; if ( keyboardHeight != this . keyboardHeight ) { forceUpdated = true ; } this . keyboardHeight = keyboardHeight ; handleKeyboardTransition ( insets , focusView ) ; } void handleKeyboardTransition ( WindowInsetsCompat insets , View focusView ) { Insets imeInsets = insets . getInsets ( WindowInsetsCompat . Type . ime ( ) ) ;", "output": "EdgeInsets edge = SystemUI . getEdgeInsetsForView ( focusView ) ; float extraHeight = PixelUtil . toPixelFromDIP ( view . getExtraHeight ( ) ) ; float translationY = <NUM_LIT> ; if ( imeInsets . bottom > <NUM_LIT> ) { float bottomInset = Math . max ( edge . bottom - extraHeight , <NUM_LIT> ) ; translationY = - Math . max ( imeInsets . bottom - bottomInset , <NUM_LIT> ) ; } if ( forceUpdated ) { forceUpdated = false ; view . setTranslationY ( translationY ) ; } if ( SystemUI . isImeVisible ( view ) && view . getTranslationY ( ) < translationY ) { return ; } view . setTranslationY ( translationY ) ; } private void adjustScrollViewOffsetIfNeeded ( View focusView ) { ReactScrollView scrollView = findClosestScrollView ( focusView ) ; if ( scrollView != null ) { Rect offset = new Rect ( ) ; focusView . getDrawingRect ( offset ) ; scrollView . offsetDescendantRectToMyCoords ( focusView , offset ) ; float extraHeight = PixelUtil . toPixelFromDIP ( view . getExtraHeight ( ) ) ; float dy = scrollView . getHeight ( ) + scrollView . getScrollY ( ) - offset . bottom - extraHeight ; if ( dy < <NUM_LIT> ) { scrollView . scrollTo ( <NUM_LIT> , ( int ) ( scrollView . getScrollY ( ) - dy ) ) ; scrollView . requestLayout ( ) ; } } } private static ReactScrollView findClosestScrollView ( View view ) { ViewParent viewParent = view . getParent ( ) ; if ( viewParent instanceof ReactScrollView ) { return ( ReactScrollView ) viewParent ; } if ( viewParent instanceof View ) { return findClosestScrollView ( ( View ) viewParent ) ; } return null ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import static android . app . Notification . VISIBILITY_SECRET ; import android . annotation . SuppressLint ; import android . app . NotificationChannel ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Handler ; import android . os . IBinder ; import androidx . core . app . NotificationCompat ; public class WaitService extends Service { public static final int ID_WAIT_PROGRESS = <NUM_LIT> ; public static final int ID_WAIT_OVER = <NUM_LIT> ; public static final String CHANNEL_ID_TIMER = \"<STR_LIT>\" ; public static final String CHANNEL_ID_OVER = \"<STR_LIT>\" ; long waitTime ; Handler handler ; NotificationCompat . Builder builder ; NotificationManager manager ; long rpid ; String comment ; public WaitService ( ) { } @ Override public IBinder onBind ( Intent intent ) { return null ; } @ Override public void onCreate ( ) { handler = new Handler ( ) ; manager = ( NotificationManager ) getSystemService ( Context . NOTIFICATION_SERVICE ) ; builder = new NotificationCompat . Builder ( getApplicationContext ( ) , CHANNEL_ID_TIMER ) . setWhen ( System . currentTimeMillis ( ) ) . setPriority ( NotificationCompat . PRIORITY_HIGH ) . setSmallIcon ( R . drawable . launcher ) . setContentTitle ( \"<STR_LIT>\" ) . setContentText ( \"<STR_LIT>\" ) . setOngoing ( true ) . setProgress ( <NUM_LIT> , <NUM_LIT> , false ) ; NotificationChannel notificationChannel ; if ( android . os . Build . VERSION . SDK_INT >= android . os . Build . VERSION_CODES . O ) { notificationChannel = new NotificationChannel ( CHANNEL_ID_TIMER , \"<STR_LIT>\" , NotificationManager . IMPORTANCE_DEFAULT ) ; notificationChannel . setVibrationPattern ( new long [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ) ; notificationChannel . setLockscreenVisibility ( VISIBILITY_SECRET ) ; notificationChannel . enableLights ( true ) ; notificationChannel . setShowBadge ( true ) ; notificationChannel . enableVibration ( true ) ; manager . createNotificationChannel ( notificationChannel ) ; notificationChannel = new NotificationChannel ( CHANNEL_ID_OVER , \"<STR_LIT>\" , NotificationManager . IMPORTANCE_DEFAULT ) ; notificationChannel . setVibrationPattern ( new long [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ) ; notificationChannel . setLockscreenVisibility ( VISIBILITY_SECRET ) ; notificationChannel . enableLights ( true ) ; notificationChannel . setShowBadge ( true ) ; notificationChannel . enableVibration ( true ) ; manager . createNotificationChannel ( notificationChannel ) ; } } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { waitTime = intent . getLongExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( waitTime < <NUM_LIT> ) { waitTime = <NUM_LIT> ; } rpid = intent . getLongExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; comment = intent . getStringExtra ( \"<STR_LIT>\" ) ; manager . notify ( ID_WAIT_PROGRESS , builder . build ( ) ) ; startTimer ( ) ; return super . onStartCommand ( intent , flags , startId ) ; } private void startTimer ( ) { new Thread ( ( ) -> { int graduation = <NUM_LIT> ; long sleepSeg = waitTime / graduation ; for ( int i = <NUM_LIT> ; i <= graduation ; i ++ ) { try { Thread . sleep ( sleepSeg ) ; int finalI = i ; handler . post ( ( ) -> { builder . setProgress ( graduation , finalI , false ) ; builder . setContentText ( finalI * sleepSeg + \"<STR_LIT>\" + graduation * sleepSeg + \"<STR_LIT>\" ) ; manager . notify ( ID_WAIT_PROGRESS , builder . build ( ) ) ; if ( finalI == graduation ) { manager . cancel ( ID_WAIT_PROGRESS ) ; } } ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; }", "output": "} waitOver ( ) ; } ) . start ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void waitOver ( ) { NotificationCompat . Builder builder1 = new NotificationCompat . Builder ( this , CHANNEL_ID_OVER ) ; Intent intent = new Intent ( this , ByXposedLaunchedActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , ByXposedLaunchedActivity . TODO_CONTINUE_CHECK_COMMENT ) ; intent . putExtra ( \"<STR_LIT>\" , rpid ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; SharedPreferences sp_counter = getSharedPreferences ( \"<STR_LIT>\" , MODE_PRIVATE ) ; int id = sp_counter . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( this , id , intent , PendingIntent . FLAG_MUTABLE ) ; System . out . println ( \"<STR_LIT>\" + pendingIntent ) ; builder1 . setWhen ( System . currentTimeMillis ( ) ) . setPriority ( NotificationCompat . PRIORITY_MAX ) . setSmallIcon ( R . drawable . launcher ) . setContentIntent ( pendingIntent ) . setContentTitle ( \"<STR_LIT>\" ) . setContentText ( comment != null ? comment : \"<STR_LIT>\" ) . setAutoCancel ( true ) ; manager . notify ( id , builder1 . build ( ) ) ; id ++ ; sp_counter . edit ( ) . putInt ( \"<STR_LIT>\" , id ) . apply ( ) ; stopSelf ( ) ; } }"}, {"input": "package com . appspa . update . proxy . impl ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateParser ; public abstract class AbstractUpdateParser implements IUpdateParser { @ Override public void parseJson ( String json , IUpdateParseCallback callback ) throws Exception { } @ Override public boolean isAsyncParser ( ) {", "output": "return false ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . PointF ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class LinearSnapHelper extends SnapHelper { private static final float INVALID_DISTANCE = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Override public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return RecyclerView . NO_POSITION ; } final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) {", "output": "return RecyclerView . NO_POSITION ; } final View currentView = findSnapView ( layoutManager ) ; if ( currentView == null ) { return RecyclerView . NO_POSITION ; } final int currentPosition = layoutManager . getPosition ( currentView ) ; if ( currentPosition == RecyclerView . NO_POSITION ) { return RecyclerView . NO_POSITION ; } RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd == null ) { return RecyclerView . NO_POSITION ; } int vDeltaJump , hDeltaJump ; if ( layoutManager . canScrollHorizontally ( ) ) { hDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getHorizontalHelper ( layoutManager ) , velocityX , <NUM_LIT> ) ; if ( vectorForEnd . x < <NUM_LIT> ) { hDeltaJump = - hDeltaJump ; } } else { hDeltaJump = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { vDeltaJump = estimateNextPositionDiffForFling ( layoutManager , getVerticalHelper ( layoutManager ) , <NUM_LIT> , velocityY ) ; if ( vectorForEnd . y < <NUM_LIT> ) { vDeltaJump = - vDeltaJump ; } } else { vDeltaJump = <NUM_LIT> ; } int deltaJump = layoutManager . canScrollVertically ( ) ? vDeltaJump : hDeltaJump ; if ( deltaJump == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } int targetPos = currentPosition + deltaJump ; if ( targetPos < <NUM_LIT> ) { targetPos = <NUM_LIT> ; } if ( targetPos >= itemCount ) { targetPos = itemCount - <NUM_LIT> ; } return targetPos ; } @ Override public View findSnapView ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild <= <NUM_LIT> ) { return <NUM_LIT> ; } int distance = Math . abs ( distances [ <NUM_LIT> ] ) > Math . abs ( distances [ <NUM_LIT> ] ) ? distances [ <NUM_LIT> ] : distances [ <NUM_LIT> ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } private float computeDistancePerChild ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { View minPosView = null ; View maxPosView = null ; int minPos = Integer . MAX_VALUE ; int maxPos = Integer . MIN_VALUE ; int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return INVALID_DISTANCE ; } for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View child = layoutManager . getChildAt ( i ) ; final int pos = layoutManager . getPosition ( child ) ; if ( pos == RecyclerView . NO_POSITION ) { continue ; } if ( pos < minPos ) { minPos = pos ; minPosView = child ; } if ( pos > maxPos ) { maxPos = pos ; maxPosView = child ; } } if ( minPosView == null || maxPosView == null ) { return INVALID_DISTANCE ; } int start = Math . min ( helper . getDecoratedStart ( minPosView ) , helper . getDecoratedStart ( maxPosView ) ) ; int end = Math . max ( helper . getDecoratedEnd ( minPosView ) , helper . getDecoratedEnd ( maxPosView ) ) ; int distance = end - start ; if ( distance == <NUM_LIT> ) { return INVALID_DISTANCE ; } return <NUM_LIT> * distance / ( ( maxPos - minPos ) + <NUM_LIT> ) ; } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) { mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ; } return mHorizontalHelper ; } }"}, {"input": "package com . wmods . wppenhacer . utils ; import android . annotation . SuppressLint ; import android . content . ContentUris ; import android . content . Context ; import android . database . Cursor ; import android . net . Uri ; import android . os . Environment ; import android . provider . DocumentsContract ; import android . provider . MediaStore ; public class RealPathUtil { @ SuppressLint ( \"<STR_LIT>\" ) public static String getRealFilePath ( final Context context , final Uri uri ) { if ( DocumentsContract . isDocumentUri ( context , uri ) ) { if ( isExternalStorageDocument ( uri ) ) { final String docId = DocumentsContract . getDocumentId ( uri ) ; final String [ ] split = docId . split ( \"<STR_LIT>\" ) ; final String type = split [ <NUM_LIT> ] ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( type ) ) { return Environment . getExternalStorageDirectory ( ) + \"<STR_LIT>\" + split [ <NUM_LIT> ] ; } } else if ( isDownloadsDocument ( uri ) ) { final String id = DocumentsContract . getDocumentId ( uri ) ; final Uri contentUri = ContentUris . withAppendedId ( Uri . parse ( \"<STR_LIT>\" ) , Long . parseLong ( id ) ) ; return getDataColumn ( context , contentUri , null , null ) ; } else if ( isMediaDocument ( uri ) ) { final String docId = DocumentsContract . getDocumentId ( uri ) ; final String [ ] split = docId . split ( \"<STR_LIT>\" ) ; final String type = split [ <NUM_LIT> ] ; Uri contentUri ; if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Video . Media . EXTERNAL_CONTENT_URI ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Audio . Media . EXTERNAL_CONTENT_URI ; } else { contentUri = MediaStore . Files . getContentUri ( \"<STR_LIT>\" ) ; } final String selection = \"<STR_LIT>\" ; final String [ ] selectionArgs = new String [ ] { split [ <NUM_LIT> ] } ; return getDataColumn ( context , contentUri , selection , selectionArgs ) ; } } else if ( \"<STR_LIT>\" . equalsIgnoreCase ( uri . getScheme ( ) ) ) { if ( isGooglePhotosUri ( uri ) ) return uri . getLastPathSegment ( ) ; return getDataColumn ( context , uri , null , null ) ; } else if ( \"<STR_LIT>\" . equalsIgnoreCase ( uri . getScheme ( ) ) ) { return uri . getPath ( ) ; } return null ; } @ SuppressLint ( \"<STR_LIT>\" ) public static String getRealFolderPath ( final Context context , final Uri uri ) { if ( DocumentsContract . isTreeUri ( uri ) ) { if ( isExternalStorageDocument ( uri ) ) { final String docId = DocumentsContract . getTreeDocumentId ( uri ) ; final String [ ] split = docId . split ( \"<STR_LIT>\" ) ; final String type = split [ <NUM_LIT> ] ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( type ) ) { return Environment . getExternalStorageDirectory ( ) + \"<STR_LIT>\" + ( split . length > <NUM_LIT> ? split [ <NUM_LIT> ] : \"<STR_LIT>\" ) ; } } else if ( isDownloadsDocument ( uri ) ) { final String id = DocumentsContract . getTreeDocumentId ( uri ) ; final Uri contentUri = ContentUris . withAppendedId ( Uri . parse ( \"<STR_LIT>\" ) , Long . parseLong ( id ) ) ; return getDataColumn ( context , contentUri , null , null ) ; } else if ( isMediaDocument ( uri ) ) { final String docId = DocumentsContract . getTreeDocumentId ( uri ) ; final String [ ] split = docId . split ( \"<STR_LIT>\" ) ; final String type = split [ <NUM_LIT> ] ; Uri contentUri ; if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Video . Media . EXTERNAL_CONTENT_URI ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { contentUri = MediaStore . Audio . Media . EXTERNAL_CONTENT_URI ; } else { contentUri = MediaStore . Files . getContentUri ( \"<STR_LIT>\" ) ; } final String selection = \"<STR_LIT>\" ; final String [ ] selectionArgs = new String [ ] { split [ <NUM_LIT> ] } ; return getDataColumn ( context , contentUri , selection , selectionArgs ) ; } } else if ( \"<STR_LIT>\" . equalsIgnoreCase ( uri . getScheme ( ) ) ) { if ( isGooglePhotosUri ( uri ) ) return uri . getLastPathSegment ( ) ; return getDataColumn ( context , uri , null , null ) ; } else if ( \"<STR_LIT>\" . equalsIgnoreCase ( uri . getScheme ( ) ) ) { return uri . getPath ( ) ; } return null ; } public static String getDataColumn ( Context context , Uri uri , String selection , String [ ] selectionArgs ) { Cursor cursor = null ; final String column = \"<STR_LIT>\" ; final String [ ] projection = { column } ; try { cursor = context . getContentResolver ( ) . query ( uri , projection , selection , selectionArgs , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { final int index = cursor . getColumnIndexOrThrow ( column ) ; return cursor . getString ( index ) ; } } finally { if ( cursor != null ) cursor . close ( ) ; } return null ; } public static boolean isExternalStorageDocument ( Uri uri ) { return \"<STR_LIT>\" . equals ( uri . getAuthority ( ) ) ; } public static boolean isDownloadsDocument ( Uri uri ) { return \"<STR_LIT>\" . equals ( uri . getAuthority ( ) ) ; } public static boolean isMediaDocument ( Uri uri ) { return \"<STR_LIT>\" . equals ( uri . getAuthority ( ) ) ;", "output": "} public static boolean isGooglePhotosUri ( Uri uri ) { return \"<STR_LIT>\" . equals ( uri . getAuthority ( ) ) ; } }"}, {"input": "public class Test { SSLContext sslContext ; X509TrustManager trustManager ; public void test1 ( ) { sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , null , null ) ; } public void test2 ( ) { TrustManagerFactory instance = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; instance . init ( ( KeyStore ) null ) ; } public void test3 ( ) { OkHttpClient client = new OkHttpClient . Builder ( ) . certificatePinner ( new CertificatePinner . Builder ( ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . build ( ) ) . build ( ) ; OkHttpClient client = new OkHttpClient . Builder ( ) . certificatePinner ( new CertificatePinner . Builder ( ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . build ( ) ) . build ( ) ; } public void test4 ( ) { TrustManager [ ] trustManagers = new TrustManager [ <NUM_LIT> ] ; trustManagers [ <NUM_LIT> ] = new PinningTrustManager ( SystemKeyStore . getInstance ( context ) , pins , <NUM_LIT> ) ; SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , trustManagers , null ) ; HttpsURLConnection urlConnection = ( HttpsURLConnection ) url . openConnection ( ) ; urlConnection . connect ( ) ; } public void test5 ( ) { TrustManager [ ] trustManagers = new TrustManager [ <NUM_LIT> ] ; trustManagers [ <NUM_LIT> ] = new PinningTrustManager ( SystemKeyStore . getInstance ( context ) , pins , <NUM_LIT> ) ;", "output": "SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , trustManagers , null ) ; HttpsURLConnection urlConnection = ( HttpsURLConnection ) url . openConnection ( ) ; test3 ( ) ; urlConnection . setSSLSocketFactory ( sslContext . getSocketFactory ( ) ) ; urlConnection . connect ( ) ; } public void test6 ( ) { TrustManager [ ] trustManagers = new TrustManager [ <NUM_LIT> ] ; trustManagers [ <NUM_LIT> ] = new PinningTrustManager ( SystemKeyStore . getInstance ( context ) , pins , <NUM_LIT> ) ; SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , trustManagers , null ) ; HttpsURLConnection urlConnection ; urlConnection = ( HttpsURLConnection ) url . openConnection ( ) ; test3 ( ) ; urlConnection . connect ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . util . Pair ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . stream . IntStream ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ChatFilters extends Feature { public ChatFilters ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( classLoader ) ; XposedBridge . hookAllConstructors ( filterAdaperClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var argResult = IntStream . range ( <NUM_LIT> , param . args . length ) . mapToObj ( i -> new Pair < > ( i , param . args [ i ] ) ) . filter ( p -> p . second instanceof List ) . findFirst ( ) . orElse ( null ) ; if ( argResult != null ) { var newList = new ArrayList < Object > ( ( List ) argResult . second ) ; newList . removeIf ( item -> { var name = XposedHelpers . getObjectField ( item , \"<STR_LIT>\" ) ; return name == null || name == \"<STR_LIT>\" || name == \"<STR_LIT>\" ; }", "output": ") ; param . args [ argResult . first ] = newList ; } } } ) ; var methodSetFilter = Arrays . stream ( filterAdaperClass . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) . findFirst ( ) . orElse ( null ) ; XposedBridge . hookMethod ( methodSetFilter , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var index = ( int ) param . args [ <NUM_LIT> ] ; var field = Unobfuscator . getFieldByType ( methodSetFilter . getDeclaringClass ( ) , List . class ) ; var list = ( List ) field . get ( param . thisObject ) ; if ( list == null || index >= list . size ( ) ) { param . setResult ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Rect ; import android . view . View ; public abstract class OrientationHelper { private static final int INVALID_SIZE = Integer . MIN_VALUE ; protected final RecyclerView . LayoutManager mLayoutManager ; public static final int HORIZONTAL = RecyclerView . HORIZONTAL ; public static final int VERTICAL = RecyclerView . VERTICAL ; private int mLastTotalSpace = INVALID_SIZE ; final Rect mTmpRect = new Rect ( ) ; private OrientationHelper ( RecyclerView . LayoutManager layoutManager ) { mLayoutManager = layoutManager ; } public RecyclerView . LayoutManager getLayoutManager ( ) { return mLayoutManager ; } public void onLayoutComplete ( ) { mLastTotalSpace = getTotalSpace ( ) ; } public int getTotalSpaceChange ( ) { return INVALID_SIZE == mLastTotalSpace ? <NUM_LIT> : getTotalSpace ( ) - mLastTotalSpace ; } public abstract int getDecoratedStart ( View view ) ; public abstract int getDecoratedEnd ( View view ) ; public abstract int getTransformedEndWithDecoration ( View view ) ; public abstract int getTransformedStartWithDecoration ( View view ) ; public abstract int getDecoratedMeasurement ( View view ) ; public abstract int getDecoratedMeasurementInOther ( View view ) ; public abstract int getStartAfterPadding ( ) ; public abstract int getEndAfterPadding ( ) ; public abstract int getEnd ( ) ; public abstract void offsetChildren ( int amount ) ; public abstract int getTotalSpace ( ) ; public abstract void offsetChild ( View view , int offset ) ; public abstract int getEndPadding ( ) ; public abstract int getMode ( ) ; public abstract int getModeInOther ( ) ; public static OrientationHelper createOrientationHelper ( RecyclerView . LayoutManager layoutManager , @ RecyclerView . Orientation int orientation ) { switch ( orientation ) { case HORIZONTAL : return createHorizontalHelper ( layoutManager ) ; case VERTICAL : return createVerticalHelper ( layoutManager ) ; } throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } public static OrientationHelper createHorizontalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getWidth ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenHorizontal ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingLeft ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedRight ( view ) + params . rightMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedLeft ( view ) - params . leftMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . right ; } @ Override public int getTransformedStartWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . left ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getWidth ( ) - mLayoutManager . getPaddingLeft ( ) - mLayoutManager . getPaddingRight ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetLeftAndRight ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingRight ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getWidthMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getHeightMode ( ) ; } } ; } public static OrientationHelper createVerticalHelper ( RecyclerView . LayoutManager layoutManager ) { return new OrientationHelper ( layoutManager ) { @ Override public int getEndAfterPadding ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getEnd ( ) { return mLayoutManager . getHeight ( ) ; } @ Override public void offsetChildren ( int amount ) { mLayoutManager . offsetChildrenVertical ( amount ) ; } @ Override public int getStartAfterPadding ( ) { return mLayoutManager . getPaddingTop ( ) ; } @ Override public int getDecoratedMeasurement ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredHeight ( view ) + params . topMargin + params . bottomMargin ; } @ Override public int getDecoratedMeasurementInOther ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedMeasuredWidth ( view ) + params . leftMargin + params . rightMargin ; } @ Override public int getDecoratedEnd ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; } @ Override public int getDecoratedStart ( View view ) { final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; return mLayoutManager . getDecoratedTop ( view ) - params . topMargin ; } @ Override public int getTransformedEndWithDecoration ( View view ) { mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . bottom ; } @ Override public int getTransformedStartWithDecoration ( View view ) {", "output": "mLayoutManager . getTransformedBoundingBox ( view , true , mTmpRect ) ; return mTmpRect . top ; } @ Override public int getTotalSpace ( ) { return mLayoutManager . getHeight ( ) - mLayoutManager . getPaddingTop ( ) - mLayoutManager . getPaddingBottom ( ) ; } @ Override public void offsetChild ( View view , int offset ) { view . offsetTopAndBottom ( offset ) ; } @ Override public int getEndPadding ( ) { return mLayoutManager . getPaddingBottom ( ) ; } @ Override public int getMode ( ) { return mLayoutManager . getHeightMode ( ) ; } @ Override public int getModeInOther ( ) { return mLayoutManager . getWidthMode ( ) ; } } ; } }"}, {"input": "package org . woheller69 . weather . weather_api . open_meteo ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . preference . PreferenceManager ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion ; import org . woheller69 . weather . weather_api . IDataExtractor ; import java . util . ArrayList ; import java . util . List ; public class OMDataExtractor implements IDataExtractor { private Context context ; public OMDataExtractor ( Context context ) { this . context = context ; } @ Override public CurrentWeatherData extractCurrentWeather ( String data ) { try { JSONObject jsonData = new JSONObject ( data ) ; CurrentWeatherData weatherData = new CurrentWeatherData ( ) ; weatherData . setTimestamp ( System . currentTimeMillis ( ) / <NUM_LIT> ) ; IApiToDatabaseConversion conversion = new OMToDatabaseConversion ( ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) weatherData . setWeatherID ( conversion . convertWeatherCategory ( jsonData . getString ( \"<STR_LIT>\" ) ) ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) weatherData . setTemperatureCurrent ( ( float ) jsonData . getDouble ( \"<STR_LIT>\" ) ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) weatherData . setWindSpeed ( ( float ) jsonData . getDouble ( \"<STR_LIT>\" ) ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) weatherData . setWindDirection ( ( float ) jsonData . getDouble ( \"<STR_LIT>\" ) ) ; weatherData . setTimeSunrise ( <NUM_LIT> ) ; weatherData . setTimeSunset ( <NUM_LIT> ) ; weatherData . setHumidity ( <NUM_LIT> ) ; weatherData . setPressure ( <NUM_LIT> ) ; weatherData . setCloudiness ( <NUM_LIT> ) ; return weatherData ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; } @ Override public List < WeekForecast > extractWeekForecast ( String data ) { try { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; List < WeekForecast > weekforecasts = new ArrayList < > ( ) ; JSONObject jsonData = new JSONObject ( data ) ; JSONArray timeArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray weathercodeArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray tempMaxArray = null ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempMaxArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempMaxArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray tempMinArray = null ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempMinArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempMinArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray sunriseArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray sunsetArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray uvIndexArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray precipitationArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray windSpeedArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray snowfallArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray showersArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray rainArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray sunshineDurationArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; IApiToDatabaseConversion conversion = new OMToDatabaseConversion ( ) ; for ( int i = <NUM_LIT> ; i < timeArray . length ( ) ; i ++ ) { WeekForecast weekForecast = new WeekForecast ( ) ; weekForecast . setTimestamp ( System . currentTimeMillis ( ) / <NUM_LIT> ) ; if ( timeArray != null && ! timeArray . isNull ( i ) ) weekForecast . setForecastTime ( ( timeArray . getLong ( i ) + <NUM_LIT> * <NUM_LIT> ) * <NUM_LIT> ) ;", "output": "if ( weathercodeArray != null && ! weathercodeArray . isNull ( i ) ) weekForecast . setWeatherID ( conversion . convertWeatherCategory ( weathercodeArray . getString ( i ) ) ) ; if ( tempMaxArray != null && ! tempMaxArray . isNull ( i ) ) weekForecast . setMaxTemperature ( ( float ) tempMaxArray . getDouble ( i ) ) ; if ( tempMinArray != null && ! tempMinArray . isNull ( i ) ) weekForecast . setMinTemperature ( ( float ) tempMinArray . getDouble ( i ) ) ; if ( sunriseArray != null && ! sunriseArray . isNull ( i ) ) weekForecast . setTimeSunrise ( sunriseArray . getLong ( i ) ) ; if ( sunsetArray != null && ! sunsetArray . isNull ( i ) ) weekForecast . setTimeSunset ( sunsetArray . getLong ( i ) ) ; if ( sunshineDurationArray != null && ! sunshineDurationArray . isNull ( i ) ) weekForecast . setSunshineHours ( ( float ) ( sunshineDurationArray . getDouble ( i ) / <NUM_LIT> ) ) ; if ( uvIndexArray != null && ! uvIndexArray . isNull ( i ) ) { weekForecast . setUv_index ( ( float ) uvIndexArray . getDouble ( i ) ) ; } else weekForecast . setUv_index ( - <NUM_LIT> ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { float precipitationAmount = <NUM_LIT> ; if ( snowfallArray != null && ! snowfallArray . isNull ( i ) ) precipitationAmount += ( float ) snowfallArray . getDouble ( i ) * <NUM_LIT> ; if ( rainArray != null && ! rainArray . isNull ( i ) ) precipitationAmount += ( float ) rainArray . getDouble ( i ) ; if ( showersArray != null && ! showersArray . isNull ( i ) ) precipitationAmount += ( float ) showersArray . getDouble ( i ) ; weekForecast . setPrecipitation ( precipitationAmount ) ; } else { if ( precipitationArray != null && ! precipitationArray . isNull ( i ) ) weekForecast . setPrecipitation ( ( float ) precipitationArray . getDouble ( i ) ) ; } if ( windSpeedArray != null && ! windSpeedArray . isNull ( i ) ) weekForecast . setWind_speed ( ( float ) windSpeedArray . getDouble ( i ) ) ; weekforecasts . add ( weekForecast ) ; } return weekforecasts ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; } @ Override public List < HourlyForecast > extractHourlyForecast ( String data ) { try { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; List < HourlyForecast > hourlyForecasts = new ArrayList < > ( ) ; JSONObject jsonData = new JSONObject ( data ) ; JSONArray timeArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray weathercodeArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray tempArray = null ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray rhArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray pressureArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray precipitationArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray windSpeedArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray windDirArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray snowfallArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray showersArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray rainArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; IApiToDatabaseConversion conversion = new OMToDatabaseConversion ( ) ; for ( int i = <NUM_LIT> ; i < timeArray . length ( ) ; i ++ ) { HourlyForecast hourlyForecast = new HourlyForecast ( ) ; hourlyForecast . setTimestamp ( System . currentTimeMillis ( ) / <NUM_LIT> ) ; if ( timeArray != null && ! timeArray . isNull ( i ) ) hourlyForecast . setForecastTime ( timeArray . getLong ( i ) * <NUM_LIT> ) ; if ( weathercodeArray != null && ! weathercodeArray . isNull ( i ) ) hourlyForecast . setWeatherID ( conversion . convertWeatherCategory ( weathercodeArray . getString ( i ) ) ) ; if ( tempArray != null && ! tempArray . isNull ( i ) ) hourlyForecast . setTemperature ( ( float ) tempArray . getDouble ( i ) ) ; if ( rhArray != null && ! rhArray . isNull ( i ) ) hourlyForecast . setHumidity ( ( float ) rhArray . getDouble ( i ) ) ; if ( pressureArray != null && ! pressureArray . isNull ( i ) ) hourlyForecast . setPressure ( ( float ) pressureArray . getDouble ( i ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { float precipitationAmount = <NUM_LIT> ; if ( snowfallArray != null && ! snowfallArray . isNull ( i ) ) precipitationAmount += ( float ) snowfallArray . getDouble ( i ) * <NUM_LIT> ; if ( rainArray != null && ! rainArray . isNull ( i ) ) precipitationAmount += ( float ) rainArray . getDouble ( i ) ; if ( showersArray != null && ! showersArray . isNull ( i ) ) precipitationAmount += ( float ) showersArray . getDouble ( i ) ; hourlyForecast . setPrecipitation ( precipitationAmount ) ; } else { if ( precipitationArray != null && ! precipitationArray . isNull ( i ) ) hourlyForecast . setPrecipitation ( ( float ) precipitationArray . getDouble ( i ) ) ; } if ( windSpeedArray != null && ! windSpeedArray . isNull ( i ) ) hourlyForecast . setWindSpeed ( ( float ) windSpeedArray . getDouble ( i ) ) ; if ( windDirArray != null && ! windDirArray . isNull ( i ) ) hourlyForecast . setWindDirection ( ( float ) windDirArray . getDouble ( i ) ) ; hourlyForecasts . add ( hourlyForecast ) ; } return hourlyForecasts ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; } @ Override public List < QuarterHourlyForecast > extractQuarterHourlyForecast ( String data ) { try { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = new ArrayList < > ( ) ; JSONObject jsonData = new JSONObject ( data ) ; JSONArray timeArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray weathercodeArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray tempArray = null ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; if ( jsonData . has ( \"<STR_LIT>\" ) ) tempArray = jsonData . getJSONArray ( \"<STR_LIT>\" ) ; JSONArray precipitationArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray windSpeedArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray snowfallArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray showersArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; JSONArray rainArray = jsonData . has ( \"<STR_LIT>\" ) ? jsonData . getJSONArray ( \"<STR_LIT>\" ) : null ; IApiToDatabaseConversion conversion = new OMToDatabaseConversion ( ) ; for ( int i = <NUM_LIT> ; i < timeArray . length ( ) ; i ++ ) { QuarterHourlyForecast quarterHourlyForecast = new QuarterHourlyForecast ( ) ; quarterHourlyForecast . setTimestamp ( System . currentTimeMillis ( ) / <NUM_LIT> ) ; if ( timeArray != null && ! timeArray . isNull ( i ) ) quarterHourlyForecast . setForecastTime ( timeArray . getLong ( i ) * <NUM_LIT> ) ; if ( weathercodeArray != null && ! weathercodeArray . isNull ( i ) ) quarterHourlyForecast . setWeatherID ( conversion . convertWeatherCategory ( weathercodeArray . getString ( i ) ) ) ; if ( tempArray != null && ! tempArray . isNull ( i ) ) quarterHourlyForecast . setTemperature ( ( float ) tempArray . getDouble ( i ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { float precipitationAmount = <NUM_LIT> ; if ( snowfallArray != null && ! snowfallArray . isNull ( i ) ) precipitationAmount += ( float ) snowfallArray . getDouble ( i ) * <NUM_LIT> ; if ( rainArray != null && ! rainArray . isNull ( i ) ) precipitationAmount += ( float ) rainArray . getDouble ( i ) ; if ( showersArray != null && ! showersArray . isNull ( i ) ) precipitationAmount += ( float ) showersArray . getDouble ( i ) ; quarterHourlyForecast . setPrecipitation ( precipitationAmount ) ; } else { if ( precipitationArray != null && ! precipitationArray . isNull ( i ) ) quarterHourlyForecast . setPrecipitation ( ( float ) precipitationArray . getDouble ( i ) ) ; } if ( windSpeedArray != null && ! windSpeedArray . isNull ( i ) ) quarterHourlyForecast . setWindSpeed ( ( float ) windSpeedArray . getDouble ( i ) ) ; quarterHourlyForecasts . add ( quarterHourlyForecast ) ; } return quarterHourlyForecasts ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . JSON ; import java . util . List ; public class ForwardDynamicReqObject { public DynReq dyn_req ; public WebRepostSrc web_repost_src ; public static ForwardDynamicReqObject getInstance ( String uid , String dynIdStr ) { ForwardDynamicReqObject object = JSON . parseObject ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , ForwardDynamicReqObject . class ) ; object . web_repost_src . dyn_id_str = dynIdStr ; long currentTimeMillis = System . currentTimeMillis ( ) ; String t = String . valueOf ( currentTimeMillis ) ; object . dyn_req . upload_id = uid + \"<STR_LIT>\" + ( currentTimeMillis / <NUM_LIT> ) + \"<STR_LIT>\" + t . substring ( t . length ( ) - <NUM_LIT> ) + \"<STR_LIT>\" ;", "output": "return object ; } public ForwardDynamicReqObject ( ) { } public static class DynReq { public Content content ; public int scene ; public String attach_card ; public String upload_id ; public Meta meta ; public static class Content { public List < Object > contents ; } public static class Meta { public AppMeta app_meta ; public static class AppMeta { public String from ; public String mobi_app ; } } } public static class WebRepostSrc { public String dyn_id_str ; } }"}, {"input": "package org . woheller69 . weather . firststart ; import android . content . Context ; import android . content . Intent ; import android . graphics . Color ; import android . os . Build ; import android . os . Bundle ; import androidx . viewpager . widget . PagerAdapter ; import androidx . viewpager . widget . ViewPager ; import androidx . appcompat . app . AppCompatActivity ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . TextView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . activities . SettingsActivity ; public class TutorialActivity extends AppCompatActivity { private ViewPager viewPager ; private MyViewPagerAdapter myViewPagerAdapter ; private LinearLayout dotsLayout ; private TextView [ ] dots ; private int [ ] layouts ; private Button btnNext ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_tutorial ) ; viewPager = ( ViewPager ) findViewById ( R . id . view_pager ) ; dotsLayout = ( LinearLayout ) findViewById ( R . id . layoutDots ) ; btnNext = ( Button ) findViewById ( R . id . btn_next ) ; layouts = new int [ ] { R . layout . tutorial_slide1 , R . layout . tutorial_slide2 , R . layout . tutorial_slide3 } ; addBottomDots ( <NUM_LIT> ) ; changeStatusBarColor ( ) ; myViewPagerAdapter = new MyViewPagerAdapter ( ) ; viewPager . setAdapter ( myViewPagerAdapter ) ; viewPager . addOnPageChangeListener ( viewPagerPageChangeListener ) ; btnNext . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { int current = getItem ( + <NUM_LIT> ) ; if ( current < layouts . length ) { viewPager . setCurrentItem ( current ) ; } else { launchSettings ( ) ; } } } ) ; } private void addBottomDots ( int currentPage ) { dots = new TextView [ layouts . length ] ; int [ ] colorsActive = getResources ( ) . getIntArray ( R . array . array_dot_active ) ; int [ ] colorsInactive = getResources ( ) . getIntArray ( R . array . array_dot_inactive ) ; dotsLayout . removeAllViews ( ) ; for ( int i = <NUM_LIT> ; i < dots . length ; i ++ ) { dots [ i ] = new TextView ( this ) ; dots [ i ] . setText ( \"<STR_LIT>\" ) ; dots [ i ] . setTextSize ( <NUM_LIT> ) ; dots [ i ] . setTextColor ( colorsInactive [ currentPage ] ) ; dotsLayout . addView ( dots [ i ] ) ; } if ( dots . length > <NUM_LIT> ) dots [ currentPage ] . setTextColor ( colorsActive [ currentPage ] ) ; } private int getItem ( int i ) { return viewPager . getCurrentItem ( ) + i ; } private void launchHomeScreen ( ) { startActivity ( new Intent ( TutorialActivity . this , ForecastCityActivity . class ) ) ; finish ( ) ;", "output": "} private void launchSettings ( ) { startActivity ( new Intent ( TutorialActivity . this , SettingsActivity . class ) ) ; finish ( ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; viewPagerPageChangeListener . onPageSelected ( viewPager . getCurrentItem ( ) ) ; } ViewPager . OnPageChangeListener viewPagerPageChangeListener = new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageSelected ( int position ) { addBottomDots ( position ) ; if ( position == layouts . length - <NUM_LIT> ) { btnNext . setText ( getString ( R . string . okay ) ) ; } else { btnNext . setText ( getString ( R . string . next ) ) ; } } @ Override public void onPageScrolled ( int arg0 , float arg1 , int arg2 ) { } @ Override public void onPageScrollStateChanged ( int arg0 ) { } } ; private void changeStatusBarColor ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { Window window = getWindow ( ) ; window . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; window . setStatusBarColor ( Color . TRANSPARENT ) ; } } public class MyViewPagerAdapter extends PagerAdapter { private LayoutInflater layoutInflater ; public MyViewPagerAdapter ( ) { } @ Override public Object instantiateItem ( ViewGroup container , int position ) { layoutInflater = ( LayoutInflater ) getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; final View view = layoutInflater . inflate ( layouts [ position ] , container , false ) ; container . addView ( view ) ; return view ; } @ Override public int getCount ( ) { return layouts . length ; } @ Override public boolean isViewFromObject ( View view , Object obj ) { return view == obj ; } @ Override public void destroyItem ( ViewGroup container , int position , Object object ) { View view = ( View ) object ; container . removeView ( view ) ; } } }"}, {"input": "package org . woheller69 . weather . ui . util ; import android . content . Context ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . Response ; import com . android . volley . toolbox . StringRequest ; import com . android . volley . toolbox . Volley ; public class geocodingApiCall { private static geocodingApiCall mInstance ; private RequestQueue mRequestQueue ; private static Context mCtx ; public geocodingApiCall ( Context ctx ) { mCtx = ctx . getApplicationContext ( ) ; mRequestQueue = getRequestQueue ( ) ; } public static synchronized geocodingApiCall getInstance ( Context context ) { if ( mInstance == null ) { mInstance = new geocodingApiCall ( context ) ; } return mInstance ; } public RequestQueue getRequestQueue ( ) { if ( mRequestQueue == null ) { mRequestQueue = Volley . newRequestQueue ( mCtx . getApplicationContext ( ) ) ; } return mRequestQueue ; } public < T > void addToRequestQueue ( Request < T > req ) { getRequestQueue ( ) . add ( req ) ; }", "output": "public static void make ( Context ctx , String query , String url , String lang , Response . Listener < String > listener , Response . ErrorListener errorListener ) { url = url + query + \"<STR_LIT>\" + lang ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , listener , errorListener ) ; geocodingApiCall . getInstance ( ctx ) . addToRequestQueue ( stringRequest ) ; } }"}, {"input": "package com . reactnative . activityindicator ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class ActivityIndicatorPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new ActivityIndicatorManager ( ) ) ;", "output": "} }"}, {"input": "package android . content . pm ; import java . io . File ; public class PackageParser { public static class PackageLite { public final String packageName = null ; } public static PackageLite parsePackageLite ( String packageFile , int flags ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static PackageLite parsePackageLite ( File packageFile , int flags ) throws PackageParserException {", "output": "throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static class PackageParserException extends Exception { } }"}, {"input": "package com . simon . harmonichackernews ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . view . View ; import androidx . activity . OnBackPressedCallback ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . FragmentTransaction ; import com . gw . swipeback . SwipeBackLayout ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . SplitChangeHandler ; import com . simon . harmonichackernews . utils . ThemeUtils ; public class CommentsActivity extends BaseActivity implements CommentsFragment . BottomSheetFragmentCallback { public static String PREVENT_BACK = \"<STR_LIT>\" ; private boolean disableSwipeAtComments ; private SwipeBackLayout swipeBackLayout ; private SplitChangeHandler splitChangeHandler ; private boolean swipeBack = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; swipeBack = ! SettingsUtils . shouldDisableCommentsSwipeBack ( getApplicationContext ( ) ) ; ThemeUtils . setupTheme ( this , swipeBack ) ; if ( swipeBack && Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && Build . VERSION . SDK_INT < Build . VERSION_CODES . UPSIDE_DOWN_CAKE ) { setTranslucent ( true ) ; } setContentView ( R . layout . activity_comments ) ; CommentsFragment fragment = new CommentsFragment ( ) ; fragment . setArguments ( getIntent ( ) . getExtras ( ) ) ; FragmentTransaction transaction = getSupportFragmentManager ( ) . beginTransaction ( ) ; transaction . replace ( R . id . comment_fragment_container_view , fragment ) ; transaction . commit ( ) ; swipeBackLayout = findViewById ( R . id . swipeBackLayout ) ; this . splitChangeHandler = new SplitChangeHandler ( this , swipeBackLayout ) ; swipeBackLayout . setSwipeBackListener ( new SwipeBackLayout . OnSwipeBackListener ( ) { @ Override public void onViewPositionChanged ( View mView , float swipeBackFraction , float swipeBackFactor ) { mView . invalidate ( ) ; } @ Override public void onViewSwipeFinished ( View mView , boolean isEnd ) { if ( isEnd ) { finish ( ) ; overridePendingTransition ( <NUM_LIT> , <NUM_LIT> ) ; } } } ) ; disableSwipeAtComments = ! swipeBack ; } @ Override public void onSwitchView ( boolean isAtWebView ) { if ( splitChangeHandler . isWithinSplit ( ) && getIntent ( ) != null ) { swipeBackLayout . setActive ( ! getIntent ( ) . getBooleanExtra ( PREVENT_BACK , false ) ) ;", "output": "return ; } if ( isAtWebView ) { swipeBackLayout . setActive ( false ) ; } else { swipeBackLayout . setActive ( ! disableSwipeAtComments ) ; } } @ Override protected void onResume ( ) { super . onResume ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . UPSIDE_DOWN_CAKE && swipeBack ) { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { setTranslucent ( true ) ; } } , <NUM_LIT> ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . UPSIDE_DOWN_CAKE && swipeBack ) { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { setTranslucent ( false ) ; } } , <NUM_LIT> ) ; } } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; splitChangeHandler . teardown ( ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . foregroundservice ; import android . Manifest ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . provider . Settings ; import androidx . activity . result . ActivityResult ; import com . getcapacitor . Bridge ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . PermissionState ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginHandle ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . getcapacitor . annotation . Permission ; import com . getcapacitor . annotation . PermissionCallback ; import java . util . ArrayList ; import org . json . JSONObject ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , permissions = @ Permission ( strings = { Manifest . permission . POST_NOTIFICATIONS } , alias = ForegroundServicePlugin . LOCAL_NOTIFICATIONS ) ) public class ForegroundServicePlugin extends Plugin { public static final String LOCAL_NOTIFICATIONS = \"<STR_LIT>\" ; public static final String TAG = \"<STR_LIT>\" ; public static final String BUTTON_CLICKED_EVENT = \"<STR_LIT>\" ; public static Bridge staticBridge = null ; private static final String MOVE_TO_FOREGROUND_CALLBACK_NAME = \"<STR_LIT>\" ; private static final String REQUEST_MANAGE_OVERLAY_PERMISSION_CALLBACK_NAME = \"<STR_LIT>\" ; private ForegroundService implementation ; @ Override public void load ( ) { try { staticBridge = this . bridge ; implementation = new ForegroundService ( this ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void moveToForeground ( PluginCall call ) { try { String packageName = getContext ( ) . getPackageName ( ) ; Intent intent = getContext ( ) . getApplicationContext ( ) . getPackageManager ( ) . getLaunchIntentForPackage ( packageName ) ; startActivityForResult ( call , intent , MOVE_TO_FOREGROUND_CALLBACK_NAME ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void startForegroundService ( PluginCall call ) { try { implementation . stopForegroundService ( ) ; } catch ( Exception exception ) { } try { String body = call . getString ( \"<STR_LIT>\" ) ; String icon = call . getString ( \"<STR_LIT>\" ) ; int id = call . getInt ( \"<STR_LIT>\" ) ; String title = call . getString ( \"<STR_LIT>\" ) ; JSArray buttons = call . getArray ( \"<STR_LIT>\" , new JSArray ( ) ) ; ArrayList < Bundle > buttonBundles = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < buttons . length ( ) ; i ++ ) { JSONObject button = buttons . getJSONObject ( i ) ;", "output": "Bundle buttonBundle = new Bundle ( ) ; buttonBundle . putString ( \"<STR_LIT>\" , button . getString ( \"<STR_LIT>\" ) ) ; buttonBundle . putInt ( \"<STR_LIT>\" , button . getInt ( \"<STR_LIT>\" ) ) ; buttonBundles . add ( buttonBundle ) ; } implementation . startForegroundService ( body , icon , id , title , buttonBundles ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void stopForegroundService ( PluginCall call ) { try { implementation . stopForegroundService ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ Override @ PluginMethod public void checkPermissions ( PluginCall call ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . TIRAMISU ) { JSObject result = new JSObject ( ) ; result . put ( LOCAL_NOTIFICATIONS , \"<STR_LIT>\" ) ; call . resolve ( result ) ; } else { super . checkPermissions ( call ) ; } } @ Override @ PluginMethod public void requestPermissions ( PluginCall call ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . TIRAMISU ) { JSObject result = new JSObject ( ) ; result . put ( LOCAL_NOTIFICATIONS , \"<STR_LIT>\" ) ; call . resolve ( result ) ; } else { if ( getPermissionState ( LOCAL_NOTIFICATIONS ) == PermissionState . GRANTED ) { this . checkPermissions ( call ) ; } else { requestPermissionForAlias ( LOCAL_NOTIFICATIONS , call , \"<STR_LIT>\" ) ; } } } @ PluginMethod public void requestManageOverlayPermission ( PluginCall call ) { try { if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { if ( Settings . canDrawOverlays ( getContext ( ) . getApplicationContext ( ) ) ) { return ; } String packageName = getContext ( ) . getPackageName ( ) ; Intent intent = new Intent ( Settings . ACTION_MANAGE_OVERLAY_PERMISSION , Uri . parse ( \"<STR_LIT>\" + packageName ) ) ; startActivityForResult ( call , intent , REQUEST_MANAGE_OVERLAY_PERMISSION_CALLBACK_NAME ) ; } else { call . resolve ( ) ; } } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void checkManageOverlayPermission ( PluginCall call ) { try { boolean granted = true ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { granted = Settings . canDrawOverlays ( getContext ( ) . getApplicationContext ( ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , granted ) ; call . resolve ( result ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } public static void onButtonClicked ( int buttonId ) { try { ForegroundServicePlugin plugin = ForegroundServicePlugin . getForegroundServicePluginInstance ( ) ; if ( plugin == null ) { return ; } plugin . handleButtonClicked ( buttonId ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } } @ ActivityCallback private void moveToForegroundResult ( PluginCall call , ActivityResult result ) { if ( call == null ) { return ; } call . resolve ( ) ; } @ ActivityCallback private void requestManageOverlayPermissionResult ( PluginCall call , ActivityResult result ) { if ( call == null ) { return ; } checkManageOverlayPermission ( call ) ; } @ PermissionCallback private void permissionsCallback ( PluginCall call ) { this . checkPermissions ( call ) ; } private void handleButtonClicked ( int buttonId ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , buttonId ) ; notifyListeners ( BUTTON_CLICKED_EVENT , result ) ; } private static ForegroundServicePlugin getForegroundServicePluginInstance ( ) { if ( staticBridge == null || staticBridge . getWebView ( ) == null ) { return null ; } PluginHandle handle = staticBridge . getPlugin ( \"<STR_LIT>\" ) ; if ( handle == null ) { return null ; } return ( ForegroundServicePlugin ) handle . getInstance ( ) ; } }"}, {"input": "package com . simon . harmonichackernews . network ; import android . content . Context ; import android . os . Looper ; import androidx . annotation . NonNull ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . Volley ; import com . simon . harmonichackernews . BuildConfig ; import java . io . IOException ; import okhttp3 . Interceptor ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class NetworkComponent { private static volatile OkHttpClient okHttpClientInstance ; private static RequestQueue requestQueueInstance ; public static OkHttpClient getOkHttpClientInstance ( ) { if ( okHttpClientInstance == null ) {", "output": "synchronized ( NetworkComponent . class ) { if ( okHttpClientInstance == null ) { Interceptor userAgentInterceptor = new Interceptor ( ) { @ Override public Response intercept ( Chain chain ) throws IOException { Request originalRequest = chain . request ( ) ; Request requestWithUserAgent = originalRequest . newBuilder ( ) . header ( \"<STR_LIT>\" , \"<STR_LIT>\" + BuildConfig . VERSION_NAME + \"<STR_LIT>\" + BuildConfig . BUILD_TYPE ) . build ( ) ; return chain . proceed ( requestWithUserAgent ) ; } } ; okHttpClientInstance = new OkHttpClient . Builder ( ) . addInterceptor ( userAgentInterceptor ) . build ( ) ; } } } return okHttpClientInstance ; } public static RequestQueue getRequestQueueInstance ( Context context ) { if ( BuildConfig . DEBUG && ! Looper . getMainLooper ( ) . isCurrentThread ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( requestQueueInstance == null ) { requestQueueInstance = Volley . newRequestQueue ( context . getApplicationContext ( ) , new VolleyOkHttp3StackInterceptors ( ) ) ; } return requestQueueInstance ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageResult ; public interface ProcessImageResultCallback { void success ( ProcessImageResult result ) ;", "output": "void cancel ( ) ; void error ( Exception exception ) ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import android . text . TextUtils ; import com . alibaba . fastjson . JSON ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Locale ; public class Comment { public CommentArea commentArea ; public long rpid ; public long parent ; public long root ; public String comment ; public String pictures ; public Date date ; public Comment ( CommentArea commentArea , long rpid , long parent , long root , String comment , String pictures , Date date ) { this . commentArea = commentArea ; this . rpid = rpid ; this . comment = comment ;", "output": "this . date = date ; this . parent = parent ; this . root = root ; this . pictures = pictures ; } public long getTimeStampDate ( ) { return date . getTime ( ) ; } public String getFormatDateFor_yMd ( ) { return getFormatDateFor_yMd ( date ) ; } public String getFormatDateFor_yMdHms ( ) { return getFormatDateFor_yMdHms ( date ) ; } public static String getFormatDateFor_yMd ( Date date ) { SimpleDateFormat sdf = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . CHINA ) ; return sdf . format ( date ) ; } public static String getFormatDateFor_yMdHms ( Date date ) { SimpleDateFormat sdf = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . CHINA ) ; return sdf . format ( date ) ; } public String getPictures ( ) { return pictures ; } public void setPictures ( String pictures ) { this . pictures = pictures ; } public List < PictureInfo > getPictureInfoList ( ) { if ( ! hasPictures ( ) ) { return null ; } return PictureInfo . parseJson ( pictures ) ; } public boolean hasPictures ( ) { return ! TextUtils . isEmpty ( pictures ) ; } public static class PictureInfo { public int img_height ; public double img_size ; public String img_src ; public int img_width ; public static List < PictureInfo > parseJson ( String jsonString ) { return JSON . parseArray ( jsonString , PictureInfo . class ) ; } public static String toJsonString ( List < PictureInfo > imageInfoList ) { return JSON . toJSONString ( imageInfoList ) ; } } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + commentArea + \"<STR_LIT>\" + rpid + \"<STR_LIT>\" + parent + \"<STR_LIT>\" + root + \"<STR_LIT>\" + comment + '<STR_LIT>' + \"<STR_LIT>\" + pictures + '<STR_LIT>' + \"<STR_LIT>\" + date + '<STR_LIT>' ; } }"}, {"input": "import java . util . Random ; import java . lang . * ; import java . security . SecureRandom ; public class A {", "output": "String a = \"<STR_LIT>\" ; private int test ( ) { return <NUM_LIT> + new Random ( ) . nextInt ( <NUM_LIT> ) ; } private int test2random ( ) { return <NUM_LIT> + Math . random ( ) ; } private int test3gen ( ) { Random r = new Random ( ) ; return r . nextDouble ( ) ; } private int test4 ( ) { SecureRandom number = new SecureRandom ( <NUM_LIT> ) ; return number . nextInt ( <NUM_LIT> ) ; } private int random ( ) { int b = <NUM_LIT> ; return b + <NUM_LIT> ; } private int random ( ) { SecureRandom number = new SecureRandom ( ) ; return number . nextInt ( <NUM_LIT> ) ; } private int gen_token ( ) { return abc ( new Date ( ) . getTime ( ) ) ; } private int gen_token ( ) { Calendar c = Calendar . getInstance ( ) ; int mseconds = c . get ( Calendar . MILLISECOND ) } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import androidx . test . platform . app . InstrumentationRegistry ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) {", "output": "Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import java . util . ArrayList ; import java . util . List ; import android . annotation . SuppressLint ; import android . content . Context ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import android . util . AttributeSet ; import android . util . Log ; import android . widget . TextView ; public class JellyBeanSpanFixTextView extends androidx . appcompat . widget . AppCompatTextView { private static class FixingResult { public final boolean fixed ; public final List < Object > spansWithSpacesBefore ; public final List < Object > spansWithSpacesAfter ; public static FixingResult fixed ( List < Object > spansWithSpacesBefore , List < Object > spansWithSpacesAfter ) { return new FixingResult ( true , spansWithSpacesBefore , spansWithSpacesAfter ) ; } public static FixingResult notFixed ( ) { return new FixingResult ( false , null , null ) ; } private FixingResult ( boolean fixed , List < Object > spansWithSpacesBefore , List < Object > spansWithSpacesAfter ) { this . fixed = fixed ; this . spansWithSpacesBefore = spansWithSpacesBefore ; this . spansWithSpacesAfter = spansWithSpacesAfter ; } } public JellyBeanSpanFixTextView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } public JellyBeanSpanFixTextView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public JellyBeanSpanFixTextView ( Context context ) { super ( context ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { try { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } catch ( IndexOutOfBoundsException e ) { fixOnMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } } private void fixOnMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { CharSequence text = getText ( ) ; if ( text instanceof Spanned ) { SpannableStringBuilder builder = new SpannableStringBuilder ( text ) ; fixSpannedWithSpaces ( builder , widthMeasureSpec , heightMeasureSpec ) ; } else { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" ) ; } fallbackToString ( widthMeasureSpec , heightMeasureSpec ) ; } } private void fixSpannedWithSpaces ( SpannableStringBuilder builder , int widthMeasureSpec , int heightMeasureSpec ) { long startFix = System . currentTimeMillis ( ) ; FixingResult result = addSpacesAroundSpansUntilFixed ( builder , widthMeasureSpec , heightMeasureSpec ) ; if ( result . fixed ) { removeUnneededSpaces ( widthMeasureSpec , heightMeasureSpec , builder , result ) ; } else { fallbackToString ( widthMeasureSpec , heightMeasureSpec ) ; } if ( HtmlTextView . DEBUG ) { long fixDuration = System . currentTimeMillis ( ) - startFix ; Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + fixDuration ) ; } } private FixingResult addSpacesAroundSpansUntilFixed ( SpannableStringBuilder builder , int widthMeasureSpec , int heightMeasureSpec ) { Object [ ] spans = builder . getSpans ( <NUM_LIT> , builder . length ( ) , Object . class ) ; List < Object > spansWithSpacesBefore = new ArrayList < > ( spans . length ) ; List < Object > spansWithSpacesAfter = new ArrayList < > ( spans . length ) ; for ( Object span : spans ) { int spanStart = builder . getSpanStart ( span ) ; if ( isNotSpace ( builder , spanStart - <NUM_LIT> ) ) { builder . insert ( spanStart , \"<STR_LIT>\" ) ; spansWithSpacesBefore . add ( span ) ; } int spanEnd = builder . getSpanEnd ( span ) ; if ( isNotSpace ( builder , spanEnd ) ) { builder . insert ( spanEnd , \"<STR_LIT>\" ) ; spansWithSpacesAfter . add ( span ) ; } try { setTextAndMeasure ( builder , widthMeasureSpec , heightMeasureSpec ) ; return FixingResult . fixed ( spansWithSpacesBefore , spansWithSpacesAfter ) ; } catch ( IndexOutOfBoundsException ignored ) {", "output": "} } if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" ) ; } return FixingResult . notFixed ( ) ; } private boolean isNotSpace ( CharSequence text , int where ) { return where < <NUM_LIT> || where >= text . length ( ) || text . charAt ( where ) != '<STR_LIT>' ; } @ SuppressLint ( \"<STR_LIT>\" ) private void setTextAndMeasure ( CharSequence text , int widthMeasureSpec , int heightMeasureSpec ) { setText ( text ) ; super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void removeUnneededSpaces ( int widthMeasureSpec , int heightMeasureSpec , SpannableStringBuilder builder , FixingResult result ) { for ( Object span : result . spansWithSpacesAfter ) { int spanEnd = builder . getSpanEnd ( span ) ; builder . delete ( spanEnd , spanEnd + <NUM_LIT> ) ; try { setTextAndMeasure ( builder , widthMeasureSpec , heightMeasureSpec ) ; } catch ( IndexOutOfBoundsException ignored ) { builder . insert ( spanEnd , \"<STR_LIT>\" ) ; } } boolean needReset = true ; for ( Object span : result . spansWithSpacesBefore ) { int spanStart = builder . getSpanStart ( span ) ; builder . delete ( spanStart - <NUM_LIT> , spanStart ) ; try { setTextAndMeasure ( builder , widthMeasureSpec , heightMeasureSpec ) ; needReset = false ; } catch ( IndexOutOfBoundsException ignored ) { needReset = true ; int newSpanStart = spanStart - <NUM_LIT> ; builder . insert ( newSpanStart , \"<STR_LIT>\" ) ; } } if ( needReset ) { setText ( builder ) ; super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } } private void fallbackToString ( int widthMeasureSpec , int heightMeasureSpec ) { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" ) ; } String fallbackText = getText ( ) . toString ( ) ; setTextAndMeasure ( fallbackText , widthMeasureSpec , heightMeasureSpec ) ; } }"}, {"input": "package org . woheller69 . weather . ui . viewPager ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . fragment . app . FragmentManager ; import androidx . lifecycle . Lifecycle ; import androidx . viewpager2 . adapter . FragmentStateAdapter ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . WeatherCityFragment ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import java . util . Collections ; import java . util . List ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; public class WeatherPagerAdapter extends FragmentStateAdapter implements IUpdateableCityUI { private Context mContext ; private SQLiteHelper database ; private List < CityToWatch > cities ; public WeatherPagerAdapter ( Context context , @ NonNull FragmentManager supportFragmentManager , @ NonNull Lifecycle lifecycle ) { super ( supportFragmentManager , lifecycle ) ; this . mContext = context ; this . database = SQLiteHelper . getInstance ( context ) ; loadCities ( ) ; } public void loadCities ( ) { this . cities = database . getAllCitiesToWatch ( ) ; Collections . sort ( cities , ( o1 , o2 ) -> o1 . getRank ( ) - o2 . getRank ( ) ) ; } @ NonNull @ Override public WeatherCityFragment createFragment ( int position ) { Bundle args = new Bundle ( ) ; args . putInt ( \"<STR_LIT>\" , cities . get ( position ) . getCityId ( ) ) ; return WeatherCityFragment . newInstance ( args ) ; } @ Override public int getItemCount ( ) { return cities . size ( ) ; } public CharSequence getPageTitle ( int position ) { return cities . get ( position ) . getCityName ( ) ; } public static void refreshSingleData ( Context context , Boolean asap , int cityId ) { Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , asap ) ; intent . putExtra ( \"<STR_LIT>\" , cityId ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } @ Override public void processNewCurrentWeatherData ( CurrentWeatherData data ) { } @ Override public void processNewForecasts ( List < HourlyForecast > hourlyForecasts ) { } @ Override public void processNewWeekForecasts ( List < WeekForecast > forecasts ) { } public int getCityIDForPos ( int pos ) { CityToWatch city = cities . get ( pos ) ; return city . getCityId ( ) ;", "output": "} public int getPosForCityID ( int cityID ) { for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { CityToWatch city = cities . get ( i ) ; if ( city . getCityId ( ) == cityID ) { return i ; } } return - <NUM_LIT> ; } public float getLatForPos ( int pos ) { CityToWatch city = cities . get ( pos ) ; return city . getLatitude ( ) ; } public float getLonForPos ( int pos ) { CityToWatch city = cities . get ( pos ) ; return city . getLongitude ( ) ; } }"}, {"input": "package com . reactnative . pulltorefresh . event ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . Event ; import com . reactnative . pulltorefresh . PullToRefreshState ; public class StateChangedEvent extends Event < StateChangedEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; private final PullToRefreshState state ; public StateChangedEvent ( int surfaceId , int viewTag , PullToRefreshState state ) { super ( surfaceId , viewTag ) ; this . state = state ; } @ Override public String getEventName ( ) { return Name ;", "output": "} @ Nullable protected WritableMap getEventData ( ) { WritableMap map = Arguments . createMap ( ) ; map . putInt ( \"<STR_LIT>\" , state . ordinal ( ) ) ; return map ; } }"}, {"input": "package com . appspa . update . utils ; import android . app . Activity ; import android . content . Context ; import android . content . ContextWrapper ; import android . graphics . Rect ; import android . os . Build ; import android . util . DisplayMetrics ; import android . view . Display ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . Window ; import android . view . WindowManager ; import android . view . inputmethod . InputMethodManager ; import android . widget . EditText ; public final class DialogUtils { private DialogUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean showWindow ( Activity activity , Window window , IWindowShower iWindowShower ) { if ( activity == null || window == null || iWindowShower == null ) { return false ; } window . addFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; iWindowShower . show ( window ) ; syncSystemUiVisibility ( activity , window ) ; window . clearFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; return true ; } public static boolean syncSystemUiVisibility ( Activity original , Window target ) { if ( original == null ) { return false ; } return syncSystemUiVisibility ( original . getWindow ( ) , target ) ; } public static boolean syncSystemUiVisibility ( Window original , Window target ) { if ( original == null || target == null ) { return false ; } target . getDecorView ( ) . setSystemUiVisibility ( original . getDecorView ( ) . getSystemUiVisibility ( ) ) ; return true ; } public interface IWindowShower { void show ( Window window ) ; } public static Activity findActivity ( Context context ) { if ( context instanceof Activity ) { return ( Activity ) context ; } if ( context instanceof ContextWrapper ) { ContextWrapper wrapper = ( ContextWrapper ) context ; return findActivity ( wrapper . getBaseContext ( ) ) ; } return null ; } public static boolean isShouldHideInput ( Window window , MotionEvent event ) { if ( window == null || event == null ) { return false ; } if ( ! isSoftInputShow ( window ) ) { return false ; } if ( ! ( window . getCurrentFocus ( ) instanceof EditText ) ) { return false ; } View decorView = window . getDecorView ( ) ; if ( decorView instanceof ViewGroup ) { return findTouchEditText ( ( ViewGroup ) decorView , event ) == null ; } return false ; } private static View findTouchEditText ( ViewGroup viewGroup , MotionEvent event ) { if ( viewGroup == null ) { return null ; } for ( int i = <NUM_LIT> ; i < viewGroup . getChildCount ( ) ; i ++ ) { View child = viewGroup . getChildAt ( i ) ; if ( child == null || ! child . isShown ( ) ) { continue ; }", "output": "if ( ! isTouchView ( child , event ) ) { continue ; } if ( child instanceof EditText ) { return child ; } else if ( child instanceof ViewGroup ) { return findTouchEditText ( ( ViewGroup ) child , event ) ; } } return null ; } private static boolean isTouchView ( View view , MotionEvent event ) { if ( view == null || event == null ) { return false ; } Rect rect = new Rect ( ) ; view . getGlobalVisibleRect ( rect ) ; return rect . contains ( ( int ) event . getX ( ) , ( int ) event . getY ( ) ) ; } private static boolean isSoftInputShow ( Window window ) { if ( window != null && window . getDecorView ( ) instanceof ViewGroup ) { return isSoftInputShow ( ( ViewGroup ) window . getDecorView ( ) ) ; } return false ; } private static boolean isSoftInputShow ( ViewGroup rootView ) { if ( rootView == null ) { return false ; } int viewHeight = rootView . getHeight ( ) ; Rect rect = new Rect ( ) ; rootView . getWindowVisibleDisplayFrame ( rect ) ; int space = viewHeight - rect . bottom - getNavigationBarHeight ( rootView . getContext ( ) ) ; return space > <NUM_LIT> ; } private static int getNavigationBarHeight ( Context context ) { WindowManager windowManager ; if ( context instanceof Activity ) { windowManager = ( ( Activity ) context ) . getWindowManager ( ) ; } else { windowManager = ( WindowManager ) context . getSystemService ( Context . WINDOW_SERVICE ) ; } if ( windowManager == null ) { return <NUM_LIT> ; } Display defaultDisplay = windowManager . getDefaultDisplay ( ) ; DisplayMetrics realDisplayMetrics = new DisplayMetrics ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN_MR1 ) { defaultDisplay . getRealMetrics ( realDisplayMetrics ) ; } int realHeight = realDisplayMetrics . heightPixels ; int realWidth = realDisplayMetrics . widthPixels ; DisplayMetrics displayMetrics = new DisplayMetrics ( ) ; defaultDisplay . getMetrics ( displayMetrics ) ; int displayHeight = displayMetrics . heightPixels ; int displayWidth = displayMetrics . widthPixels ; if ( realHeight - displayHeight > <NUM_LIT> ) { return realHeight - displayHeight ; } return Math . max ( realWidth - displayWidth , <NUM_LIT> ) ; } public static void hideSoftInput ( final View view ) { if ( view == null ) { return ; } InputMethodManager imm = ( InputMethodManager ) view . getContext ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; if ( imm == null ) { return ; } imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; } }"}, {"input": "package in . hridayan . ashell . utils ; import android . content . Context ; import android . os . AsyncTask ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . net . HttpURLConnection ; import java . net . URL ; public class FetchLatestVersionCode extends AsyncTask < String , Void , Integer > { private Context context ; private FetchLatestVersionCodeCallback callback ; public FetchLatestVersionCode ( Context context , FetchLatestVersionCodeCallback callback ) { this . context = context ; this . callback = callback ; } @ Override protected Integer doInBackground ( String ... params ) { StringBuilder result = new StringBuilder ( ) ; try { URL url = new URL ( params [ <NUM_LIT> ] ) ; HttpURLConnection urlConnection = ( HttpURLConnection ) url . openConnection ( ) ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { result . append ( line ) . append ( \"<STR_LIT>\" ) ; } } finally { urlConnection . disconnect ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return Preferences . CONNECTION_ERROR ; }", "output": "int latestVersionCode = Utils . extractVersionCode ( result . toString ( ) ) ; if ( Utils . isUpdateAvailable ( latestVersionCode ) ) { return Preferences . UPDATE_AVAILABLE ; } else { return Preferences . UPDATE_NOT_AVAILABLE ; } } @ Override protected void onPostExecute ( Integer result ) { if ( callback != null ) { callback . onResult ( result ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . nl . translate . TranslateRemoteModel ; import java . util . Set ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class TranslationPlugin extends Plugin { public static final String ERROR_LANGUAGE_MISSING = \"<STR_LIT>\" ; public static final String ERROR_TEXT_MISSING = \"<STR_LIT>\" ; public static final String ERROR_SOURCE_LANGUAGE_MISSING = \"<STR_LIT>\" ; public static final String ERROR_TARGET_LANGUAGE_MISSING = \"<STR_LIT>\" ; private Translation implementation = new Translation ( ) ; @ PluginMethod public void deleteDownloadedModel ( PluginCall call ) { try { String language = call . getString ( \"<STR_LIT>\" ) ; if ( language == null ) { call . reject ( ERROR_LANGUAGE_MISSING ) ; return ; } implementation . deleteDownloadedModel ( language , new DeleteDownloadedModelResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } @ PluginMethod public void downloadModel ( PluginCall call ) { try { String language = call . getString ( \"<STR_LIT>\" ) ; if ( language == null ) { call . reject ( ERROR_LANGUAGE_MISSING ) ; return ; } implementation . downloadModel ( language , new DownloadModelResultCallback ( ) { @ Override public void success ( ) { call . resolve ( ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } @ PluginMethod public void getDownloadedModels ( PluginCall call ) { try { implementation . getDownloadedModels ( new GetDownloadedModelsResultCallback ( ) { @ Override public void success ( Set < TranslateRemoteModel > models ) { JSArray languagesResult = new JSArray ( ) ; for ( TranslateRemoteModel model : models ) { languagesResult . put ( model . getLanguage ( ) ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , languagesResult ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } @ PluginMethod public void translate ( PluginCall call ) { try { String text = call . getString ( \"<STR_LIT>\" ) ; if ( text == null ) { call . reject ( ERROR_TEXT_MISSING ) ; return ; } String sourceLanguage = call . getString ( \"<STR_LIT>\" ) ; if ( sourceLanguage == null ) { call . reject ( ERROR_SOURCE_LANGUAGE_MISSING ) ; return ; } String targetLanguage = call . getString ( \"<STR_LIT>\" ) ; if ( targetLanguage == null ) { call . reject ( ERROR_TARGET_LANGUAGE_MISSING ) ; return ; } implementation . translate ( text , sourceLanguage , targetLanguage , new TranslateResultCallback ( ) { @ Override public void success ( String text ) {", "output": "JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , text ) ; call . resolve ( result ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( message , exception ) ; call . reject ( message ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . interfaces ; import androidx . annotation . NonNull ; public interface NonEmptyCallback < T > extends Callback {", "output": "void success ( @ NonNull T result ) ; }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; import android . webkit . MimeTypeMap ; public class MimeTypeUtils { public static String getMimeTypeFromExtension ( String url ) { String type = \"<STR_LIT>\" ;", "output": "String extension = MimeTypeMap . getFileExtensionFromUrl ( url ) ; if ( extension != null ) { type = MimeTypeMap . getSingleton ( ) . getMimeTypeFromExtension ( extension ) ; } return type ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces . Result ; public class GetMinZoomRatioResult implements Result { private float zoomRatio ; public GetMinZoomRatioResult ( float zoomRatio ) {", "output": "this . zoomRatio = zoomRatio ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , zoomRatio ) ; return result ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . ISOLATED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . SHARED_STABLE_IDS ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . ALLOW ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_POSITION ; import android . util . Log ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . IdentityHashMap ; import java . util . List ; class ConcatAdapterController implements NestedAdapterWrapper . Callback { private final ConcatAdapter mConcatAdapter ; private final ViewTypeStorage mViewTypeStorage ; private List < WeakReference < RecyclerView > > mAttachedRecyclerViews = new ArrayList < > ( ) ; private final IdentityHashMap < ViewHolder , NestedAdapterWrapper > mBinderLookup = new IdentityHashMap < > ( ) ; private List < NestedAdapterWrapper > mWrappers = new ArrayList < > ( ) ; private WrapperAndLocalPosition mReusableHolder = new WrapperAndLocalPosition ( ) ; @ NonNull private final ConcatAdapter . Config . StableIdMode mStableIdMode ; private final StableIdStorage mStableIdStorage ; ConcatAdapterController ( ConcatAdapter concatAdapter , ConcatAdapter . Config config ) { mConcatAdapter = concatAdapter ; if ( config . isolateViewTypes ) { mViewTypeStorage = new ViewTypeStorage . IsolatedViewTypeStorage ( ) ; } else { mViewTypeStorage = new ViewTypeStorage . SharedIdRangeViewTypeStorage ( ) ; } mStableIdMode = config . stableIdMode ; if ( config . stableIdMode == NO_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . NoStableIdStorage ( ) ; } else if ( config . stableIdMode == ISOLATED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . IsolatedStableIdStorage ( ) ; } else if ( config . stableIdMode == SHARED_STABLE_IDS ) { mStableIdStorage = new StableIdStorage . SharedPoolStableIdStorage ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Nullable private NestedAdapterWrapper findWrapperFor ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return null ; } return mWrappers . get ( index ) ; } private int indexOfWrapper ( Adapter < ViewHolder > adapter ) { final int limit = mWrappers . size ( ) ; for ( int i = <NUM_LIT> ; i < limit ; i ++ ) { if ( mWrappers . get ( i ) . adapter == adapter ) { return i ; } } return - <NUM_LIT> ; } boolean addAdapter ( Adapter < ViewHolder > adapter ) { return addAdapter ( mWrappers . size ( ) , adapter ) ; } boolean addAdapter ( int index , Adapter < ViewHolder > adapter ) { if ( index < <NUM_LIT> || index > mWrappers . size ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + mWrappers . size ( ) + \"<STR_LIT>\" + index ) ; } if ( hasStableIds ( ) ) { Preconditions . checkArgument ( adapter . hasStableIds ( ) , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } else { if ( adapter . hasStableIds ( ) ) { Log . w ( ConcatAdapter . TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } NestedAdapterWrapper existing = findWrapperFor ( adapter ) ; if ( existing != null ) { return false ; } NestedAdapterWrapper wrapper = new NestedAdapterWrapper ( adapter , this , mViewTypeStorage , mStableIdStorage . createStableIdLookup ( ) ) ; mWrappers . add ( index , wrapper ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onAttachedToRecyclerView ( recyclerView ) ; } } if ( wrapper . getCachedItemCount ( ) > <NUM_LIT> ) { mConcatAdapter . notifyItemRangeInserted ( countItemsBefore ( wrapper ) , wrapper . getCachedItemCount ( ) ) ; } calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } boolean removeAdapter ( Adapter < ViewHolder > adapter ) { final int index = indexOfWrapper ( adapter ) ; if ( index == - <NUM_LIT> ) { return false ; } NestedAdapterWrapper wrapper = mWrappers . get ( index ) ; int offset = countItemsBefore ( wrapper ) ; mWrappers . remove ( index ) ; mConcatAdapter . notifyItemRangeRemoved ( offset , wrapper . getCachedItemCount ( ) ) ; for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { RecyclerView recyclerView = reference . get ( ) ; if ( recyclerView != null ) { adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } wrapper . dispose ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; return true ; } private int countItemsBefore ( NestedAdapterWrapper wrapper ) { int count = <NUM_LIT> ; for ( NestedAdapterWrapper item : mWrappers ) { if ( item != wrapper ) { count += item . getCachedItemCount ( ) ; } else { break ; } } return count ; } public long getItemId ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; long globalItemId = wrapperAndPos . mWrapper . getItemId ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return globalItemId ; } @ Override public void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) { mConcatAdapter . notifyDataSetChanged ( ) ; calculateAndUpdateStateRestorationPolicy ( ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeChanged ( positionStart + offset , itemCount , payload ) ; } @ Override public void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { final int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeInserted ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemRangeRemoved ( positionStart + offset , itemCount ) ; } @ Override public void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) { int offset = countItemsBefore ( nestedAdapterWrapper ) ; mConcatAdapter . notifyItemMoved ( fromPosition + offset , toPosition + offset ) ; } @ Override public void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) { calculateAndUpdateStateRestorationPolicy ( ) ; } private void calculateAndUpdateStateRestorationPolicy ( ) { StateRestorationPolicy newPolicy = computeStateRestorationPolicy ( ) ; if ( newPolicy != mConcatAdapter . getStateRestorationPolicy ( ) ) { mConcatAdapter . internalSetStateRestorationPolicy ( newPolicy ) ; } } private StateRestorationPolicy computeStateRestorationPolicy ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { StateRestorationPolicy strategy = wrapper . adapter . getStateRestorationPolicy ( ) ; if ( strategy == PREVENT ) { return PREVENT ; } else if ( strategy == PREVENT_WHEN_EMPTY && wrapper . getCachedItemCount ( ) == <NUM_LIT> ) { return PREVENT ; } } return ALLOW ; } public int getTotalCount ( ) { int total = <NUM_LIT> ; for ( NestedAdapterWrapper wrapper : mWrappers ) { total += wrapper . getCachedItemCount ( ) ; } return total ; } public int getItemViewType ( int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; int itemViewType = wrapperAndPos . mWrapper . getItemViewType ( wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; return itemViewType ; } public ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { NestedAdapterWrapper wrapper = mViewTypeStorage . getWrapperForGlobalType ( globalViewType ) ; return wrapper . onCreateViewHolder ( parent , globalViewType ) ; } public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { WrapperAndLocalPosition wrapper = findWrapperAndLocalPosition ( globalPosition ) ; Pair < Adapter < ? extends ViewHolder > , Integer > pair = new Pair < > ( wrapper . mWrapper . adapter , wrapper . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapper ) ; return pair ; } @ NonNull private WrapperAndLocalPosition findWrapperAndLocalPosition ( int globalPosition ) { WrapperAndLocalPosition result ; if ( mReusableHolder . mInUse ) { result = new WrapperAndLocalPosition ( ) ; } else { mReusableHolder . mInUse = true ; result = mReusableHolder ; } int localPosition = globalPosition ; for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( wrapper . getCachedItemCount ( ) > localPosition ) { result . mWrapper = wrapper ; result . mLocalPosition = localPosition ; break ; } localPosition -= wrapper . getCachedItemCount ( ) ; } if ( result . mWrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + globalPosition ) ; } return result ; } private void releaseWrapperAndLocalPosition ( WrapperAndLocalPosition wrapperAndLocalPosition ) { wrapperAndLocalPosition . mInUse = false ; wrapperAndLocalPosition . mWrapper = null ; wrapperAndLocalPosition . mLocalPosition = - <NUM_LIT> ; mReusableHolder = wrapperAndLocalPosition ; } public void onBindViewHolder ( ViewHolder holder , int globalPosition ) { WrapperAndLocalPosition wrapperAndPos = findWrapperAndLocalPosition ( globalPosition ) ; mBinderLookup . put ( holder , wrapperAndPos . mWrapper ) ; wrapperAndPos . mWrapper . onBindViewHolder ( holder , wrapperAndPos . mLocalPosition ) ; releaseWrapperAndLocalPosition ( wrapperAndPos ) ; } public boolean canRestoreState ( ) { for ( NestedAdapterWrapper wrapper : mWrappers ) { if ( ! wrapper . adapter . canRestoreState ( ) ) { return false ; } } return true ; } public void onViewAttachedToWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewAttachedToWindow ( holder ) ; } public void onViewDetachedFromWindow ( ViewHolder holder ) { NestedAdapterWrapper wrapper = getWrapper ( holder ) ; wrapper . adapter . onViewDetachedFromWindow ( holder ) ; } public void onViewRecycled ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } wrapper . adapter . onViewRecycled ( holder ) ; mBinderLookup . remove ( holder ) ; } public boolean onFailedToRecycleView ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } final boolean result = wrapper . adapter . onFailedToRecycleView ( holder ) ; mBinderLookup . remove ( holder ) ; return result ; } @ NonNull private NestedAdapterWrapper getWrapper ( ViewHolder holder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( holder ) ; if ( wrapper == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + holder + \"<STR_LIT>\" + this ) ; } return wrapper ; } private boolean isAttachedTo ( RecyclerView recyclerView ) { for ( WeakReference < RecyclerView > reference : mAttachedRecyclerViews ) { if ( reference . get ( ) == recyclerView ) { return true ; } } return false ; } public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { if ( isAttachedTo ( recyclerView ) ) { return ; } mAttachedRecyclerViews . add ( new WeakReference < > ( recyclerView ) ) ; for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onAttachedToRecyclerView ( recyclerView ) ; } } public void onDetachedFromRecyclerView ( RecyclerView recyclerView ) { for ( int i = mAttachedRecyclerViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { WeakReference < RecyclerView > reference = mAttachedRecyclerViews . get ( i ) ; if ( reference . get ( ) == null ) { mAttachedRecyclerViews . remove ( i ) ; } else if ( reference . get ( ) == recyclerView ) { mAttachedRecyclerViews . remove ( i ) ; break ; } } for ( NestedAdapterWrapper wrapper : mWrappers ) { wrapper . adapter . onDetachedFromRecyclerView ( recyclerView ) ; } } public int getLocalAdapterPosition ( Adapter < ? extends ViewHolder > adapter , ViewHolder viewHolder , int globalPosition ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( viewHolder ) ; if ( wrapper == null ) { return NO_POSITION ; } int itemsBefore = countItemsBefore ( wrapper ) ; int localPosition = globalPosition - itemsBefore ; int itemCount = wrapper . adapter . getItemCount ( ) ; if ( localPosition < <NUM_LIT> || localPosition >= itemCount ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + localPosition + \"<STR_LIT>\" + \"<STR_LIT>\" + itemCount + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + adapter ) ; } return wrapper . adapter . findRelativeAdapterPositionIn ( adapter , viewHolder , localPosition ) ;", "output": "} @ Nullable public Adapter < ? extends ViewHolder > getBoundAdapter ( ViewHolder viewHolder ) { NestedAdapterWrapper wrapper = mBinderLookup . get ( viewHolder ) ; if ( wrapper == null ) { return null ; } return wrapper . adapter ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public List < Adapter < ? extends ViewHolder > > getCopyOfAdapters ( ) { if ( mWrappers . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List < Adapter < ? extends ViewHolder > > adapters = new ArrayList < > ( mWrappers . size ( ) ) ; for ( NestedAdapterWrapper wrapper : mWrappers ) { adapters . add ( wrapper . adapter ) ; } return adapters ; } public boolean hasStableIds ( ) { return mStableIdMode != NO_STABLE_IDS ; } static class WrapperAndLocalPosition { NestedAdapterWrapper mWrapper ; int mLocalPosition ; boolean mInUse ; } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . content . SharedPreferences ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . TimeZone ; public class CourseOfDayAdapter extends RecyclerView . Adapter < CourseOfDayAdapter . CourseOfDayViewHolder > { private List < HourlyForecast > courseOfDayList ; private Context context ; private TextView recyclerViewHeader ; private RecyclerView recyclerView ; private RecyclerView weekRecyclerView ; private Date courseOfDayHeaderDate ; CourseOfDayAdapter ( List < HourlyForecast > courseOfDayList , Context context , TextView recyclerViewHeader , RecyclerView recyclerView ) { this . context = context ; this . courseOfDayList = courseOfDayList ; this . recyclerViewHeader = recyclerViewHeader ; this . recyclerView = recyclerView ; if ( courseOfDayList != null && courseOfDayList . size ( ) != <NUM_LIT> && courseOfDayList . get ( <NUM_LIT> ) != null ) { this . courseOfDayHeaderDate = new Date ( courseOfDayList . get ( <NUM_LIT> ) . getLocalForecastTime ( context ) ) ; } else this . courseOfDayHeaderDate = new Date ( ) ; } public void setWeekRecyclerView ( RecyclerView weekRecyclerView ) { this . weekRecyclerView = weekRecyclerView ; } public Date getCourseOfDayHeaderDate ( ) { return this . courseOfDayHeaderDate ; } @ Override public CourseOfDayViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . list_item_course_of_day , parent , false ) ; return new CourseOfDayViewHolder ( view ) ; } @ Override public void onBindViewHolder ( CourseOfDayViewHolder holder , int position ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( courseOfDayList . get ( position ) . getCity_id ( ) ) ; Calendar forecastTime = Calendar . getInstance ( ) ; forecastTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; forecastTime . setTimeInMillis ( courseOfDayList . get ( position ) . getLocalForecastTime ( context ) ) ; boolean isDay ; if ( currentWeather . getTimeSunrise ( ) == <NUM_LIT> || currentWeather . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( courseOfDayList . get ( position ) . getCity_id ( ) ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && forecastTime . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || forecastTime . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { Calendar sunSetTime = Calendar . getInstance ( ) ; sunSetTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; sunSetTime . setTimeInMillis ( currentWeather . getTimeSunset ( ) * <NUM_LIT> + currentWeather . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunSetTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunSetTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; Calendar sunRiseTime = Calendar . getInstance ( ) ; sunRiseTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; sunRiseTime . setTimeInMillis ( currentWeather . getTimeSunrise ( ) * <NUM_LIT> + currentWeather . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunRiseTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunRiseTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; isDay = forecastTime . after ( sunRiseTime ) && forecastTime . before ( sunSetTime ) ; } holder . time . setText ( StringFormatUtils . formatTimeWithoutZone ( context , courseOfDayList . get ( position ) . getLocalForecastTime ( context ) ) ) ; updateRecyclerViewHeader ( ) ; holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( courseOfDayList . get ( position ) . getWindSpeed ( ) ) ) ; setIcon ( courseOfDayList . get ( position ) . getWeatherID ( ) , holder . weather , isDay ) ; holder . humidity . setText ( StringFormatUtils . formatInt ( courseOfDayList . get ( position ) . getHumidity ( ) , context . getString ( R . string . units_rh ) ) ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { holder . pressure . setText ( StringFormatUtils . formatInt ( courseOfDayList . get ( position ) . getPressure ( ) , context . getString ( R . string . units_hPa ) ) ) ; holder . pressure . setVisibility ( View . VISIBLE ) ; } else holder . pressure . setVisibility ( View . GONE ) ; holder . temperature . setText ( StringFormatUtils . formatTemperature ( context , courseOfDayList . get ( position ) . getTemperature ( ) ) ) ; holder . wind_speed . setText ( StringFormatUtils . formatWindSpeed ( context , courseOfDayList . get ( position ) . getWindSpeed ( ) ) ) ; holder . wind_speed . setBackground ( StringFormatUtils . colorWindSpeed ( context , courseOfDayList . get ( position ) . getWindSpeed ( ) ) ) ; holder . wind_direction . setRotation ( courseOfDayList . get ( position ) . getWindDirection ( ) ) ; if ( courseOfDayList . get ( position ) . getPrecipitation ( ) == <NUM_LIT> ) holder . precipitation . setText ( \"<STR_LIT>\" ) ; else holder . precipitation . setText ( StringFormatUtils . formatPrecipitation ( context , courseOfDayList . get ( position ) . getPrecipitation ( ) ) ) ; } private void updateRecyclerViewHeader ( ) { RecyclerView . LayoutManager manager = recyclerView . getLayoutManager ( ) ; LinearLayoutManager llm = ( LinearLayoutManager ) manager ; assert llm != null ;", "output": "int visiblePosition = llm . findFirstVisibleItemPosition ( ) ; if ( visiblePosition > - <NUM_LIT> ) { Calendar HeaderTime = Calendar . getInstance ( ) ; HeaderTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; HeaderTime . setTimeInMillis ( courseOfDayList . get ( visiblePosition ) . getLocalForecastTime ( context ) ) ; int headerday = HeaderTime . get ( Calendar . DAY_OF_WEEK ) ; headerday = StringFormatUtils . getDayLong ( headerday ) ; recyclerViewHeader . setText ( context . getResources ( ) . getString ( headerday ) + \"<STR_LIT>\" + StringFormatUtils . formatDate ( courseOfDayList . get ( visiblePosition ) . getLocalForecastTime ( context ) ) + \"<STR_LIT>\" ) ; courseOfDayHeaderDate = HeaderTime . getTime ( ) ; if ( weekRecyclerView != null ) { WeekWeatherAdapter weekadapter = ( WeekWeatherAdapter ) weekRecyclerView . getAdapter ( ) ; weekadapter . setCourseOfDayHeaderDate ( courseOfDayHeaderDate ) ; } } } @ Override public int getItemCount ( ) { if ( courseOfDayList == null ) return <NUM_LIT> ; else return courseOfDayList . size ( ) ; } class CourseOfDayViewHolder extends RecyclerView . ViewHolder { TextView time ; ImageView weather ; TextView temperature ; TextView humidity ; TextView pressure ; TextView precipitation ; TextView wind_speed ; ImageView wind_direction ; ImageView windicon ; CourseOfDayViewHolder ( View itemView ) { super ( itemView ) ; time = itemView . findViewById ( R . id . course_of_day_time ) ; weather = itemView . findViewById ( R . id . course_of_day_weather ) ; temperature = itemView . findViewById ( R . id . course_of_day_temperature ) ; humidity = itemView . findViewById ( R . id . course_of_day_humidity ) ; pressure = itemView . findViewById ( R . id . course_of_day_pressure ) ; precipitation = itemView . findViewById ( R . id . course_of_day_precipitation ) ; wind_speed = itemView . findViewById ( R . id . course_of_day_wind_speed ) ; wind_direction = itemView . findViewById ( R . id . course_of_day_wind_direction ) ; windicon = itemView . findViewById ( R . id . course_of_day_wind_icon ) ; } } public void setIcon ( int value , ImageView imageView , boolean isDay ) { imageView . setImageResource ( UiResourceProvider . getIconResourceForWeatherCategory ( value , isDay ) ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class MartialLawCommentAreaListAdapter extends RecyclerView . Adapter < MartialLawCommentAreaListAdapter . ViewHolder > { ArrayList < MartialLawCommentArea > areaArrayList ; Context context ; private StatisticsDBOpenHelper statisticsDBOpenHelper ; public MartialLawCommentAreaListAdapter ( ArrayList < MartialLawCommentArea > areaArrayList , Context context ) { statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; this . areaArrayList = areaArrayList ; Collections . reverse ( this . areaArrayList ) ; this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View itemView = View . inflate ( context , R . layout . item_martial_law_comment_area , null ) ; return new ViewHolder ( itemView ) ; } public void addData ( List < MartialLawCommentArea > areaArrayList ) { Collections . reverse ( areaArrayList ) ; this . areaArrayList . addAll ( <NUM_LIT> , areaArrayList ) ; notifyDataSetChanged ( ) ; } @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { MartialLawCommentArea area = areaArrayList . get ( position ) ; byte [ ] coverImageData = statisticsDBOpenHelper . selectMartialLawCommentAreaCoverImage ( area . oid ) ; if ( area . type == CommentArea . AREA_TYPE_DYNAMIC11 || area . type == CommentArea . AREA_TYPE_DYNAMIC17 ) { holder . cover_image . setImageDrawable ( context . getDrawable ( R . drawable . dynmic ) ) ; } else { holder . cover_image . setImageBitmap ( BitmapFactory . decodeByteArray ( coverImageData , <NUM_LIT> , coverImageData . length ) ) ; } holder . txv_title . setText ( area . title ) ; holder . txv_up . setText ( \"<STR_LIT>\" + area . up ) ; holder . txv_source_id_ia . setText ( area . sourceId ) ; String areaType = null ; switch ( area . type ) { case CommentArea . AREA_TYPE_VIDEO : areaType = \"<STR_LIT>\" ; holder . img_area_type . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_smart_display_24 ) ) ; break ;", "output": "case CommentArea . AREA_TYPE_ARTICLE : areaType = \"<STR_LIT>\" ; holder . img_area_type . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_art_track_24 ) ) ; break ; case CommentArea . AREA_TYPE_DYNAMIC11 : case CommentArea . AREA_TYPE_DYNAMIC17 : areaType = \"<STR_LIT>\" ; holder . img_area_type . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_insert_chart_24 ) ) ; break ; } String defaultDisposalMethod = null ; switch ( area . defaultDisposalMethod ) { case MartialLawCommentArea . DISPOSAL_METHOD_SHADOW_BAN : holder . img_band_type . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; defaultDisposalMethod = \"<STR_LIT>\" ; break ; case MartialLawCommentArea . DISPOSAL_METHOD_QUICK_DELETE : holder . img_band_type . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; defaultDisposalMethod = \"<STR_LIT>\" ; break ; } holder . txv_default_disposal_method . setText ( defaultDisposalMethod ) ; String finalDefaultDisposalMethod = defaultDisposalMethod ; String finalAreaType = areaType + \"<STR_LIT>\" + area . type + \"<STR_LIT>\" ; holder . itemView . setOnClickListener ( v -> { View dialogView = View . inflate ( context , R . layout . dialog_martial_law_comment_area_info , null ) ; TextView txv_title = dialogView . findViewById ( R . id . txv_title ) ; TextView txv_up = dialogView . findViewById ( R . id . txv_up ) ; TextView txv_oid = dialogView . findViewById ( R . id . txv_oid ) ; TextView txv_source_id = dialogView . findViewById ( R . id . txv_source_id ) ; TextView txv_band_type = dialogView . findViewById ( R . id . txv_old_status ) ; TextView txv_area_type = dialogView . findViewById ( R . id . txv_area_type ) ; txv_title . setText ( area . title ) ; txv_up . setText ( \"<STR_LIT>\" + area . up ) ; txv_oid . setText ( String . valueOf ( area . oid ) ) ; txv_source_id . setText ( area . sourceId ) ; txv_band_type . setText ( finalDefaultDisposalMethod ) ; txv_area_type . setText ( finalAreaType ) ; new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setView ( dialogView ) . setPositiveButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( \"<STR_LIT>\" , ( dialog12 , which ) -> { new AlertDialog . Builder ( context ) . setMessage ( \"<STR_LIT>\" ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog14 , which2 ) -> { if ( statisticsDBOpenHelper . deleteMartialLawCommentArea ( area . oid ) != <NUM_LIT> ) { areaArrayList . remove ( holder . getAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getAdapterPosition ( ) ) ; Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; } ) . setNegativeButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Uri uri = Uri . parse ( CommentUtil . sourceIdToUrl ( area ) ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } } ) . show ( ) ; } ) ; } @ Override public int getItemCount ( ) { return areaArrayList . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { View itemView ; ImageView cover_image , img_area_type , img_band_type ; TextView txv_title , txv_source_id_ia , txv_up , txv_default_disposal_method ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; this . itemView = itemView ; cover_image = itemView . findViewById ( R . id . cover_image ) ; img_area_type = itemView . findViewById ( R . id . img_area_type ) ; img_band_type = itemView . findViewById ( R . id . img_old_status ) ; txv_title = itemView . findViewById ( R . id . txv_title ) ; txv_source_id_ia = itemView . findViewById ( R . id . txv_source_id_ia ) ; txv_up = itemView . findViewById ( R . id . txv_up ) ; txv_default_disposal_method = itemView . findViewById ( R . id . txv_default_disposal_method ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetVersionCodeResult implements Result { private String versionCode ; public GetVersionCodeResult ( String versionCode ) { this . versionCode = versionCode ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , versionCode ) ;", "output": "return result ; } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import android . content . pm . PackageInfo ; import android . os . IInterface ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( value = \"<STR_LIT>\" ) public interface IWebViewUpdateService { String SERVICE = \"<STR_LIT>\" ; @ Method ( value = \"<STR_LIT>\" , type = Method . STATIC ) IInterface asInterface ( android . os . IBinder obj ) ;", "output": "@ Method ( value = \"<STR_LIT>\" ) PackageInfo getCurrentWebViewPackage ( ) ; }"}, {"input": "package external . org . apache . commons . lang3 . exception ; public class CloneFailedException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; public CloneFailedException ( final String message ) {", "output": "super ( message ) ; } public CloneFailedException ( final Throwable cause ) { super ( cause ) ; } public CloneFailedException ( final String message , final Throwable cause ) { super ( message , cause ) ; } }"}, {"input": "public class MainActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; WebView webview2 = new WebView ( this ) ; setContentView ( webview2 ) ; String url = \"<STR_LIT>\" ; webview2 . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( false ) ; webview2 . getSettings ( ) . setJavaScriptEnabled ( true ) ; webview2 . getSettings ( ) . setAllowFileAccess ( false ) ; webview2 . getSettings ( ) . setAllowContentAccess ( false ) ; webview2 . getSettings ( ) . setAllowFileAccessFromFileURLs ( false ) ;", "output": "webview2 . loadUrl ( url ) ; } private class MainActivityWebView extends WebView { protected void test ( ) { String url = \"<STR_LIT>\" ; getSettings ( ) . setAllowUniversalAccessFromFileURLs ( false ) ; getSettings ( ) . setJavaScriptEnabled ( true ) ; getSettings ( ) . setAllowFileAccess ( false ) ; this . getSettings ( ) . setAllowContentAccess ( true ) ; getSettings ( ) . setAllowFileAccessFromFileURLs ( false ) ; this . loadUrl ( url ) ; } } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . animation . LayoutTransition ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Arrays ; import java . util . Comparator ; final class AnimateLayoutChangeDetector { private static final ViewGroup . MarginLayoutParams ZERO_MARGIN_LAYOUT_PARAMS ; static { ZERO_MARGIN_LAYOUT_PARAMS = new ViewGroup . MarginLayoutParams ( MATCH_PARENT , MATCH_PARENT ) ; ZERO_MARGIN_LAYOUT_PARAMS . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ;", "output": "} private LinearLayoutManager mLayoutManager ; AnimateLayoutChangeDetector ( @ NonNull LinearLayoutManager llm ) { mLayoutManager = llm ; } private static boolean hasRunningChangingLayoutTransition ( View view ) { if ( view instanceof ViewGroup ) { ViewGroup viewGroup = ( ViewGroup ) view ; LayoutTransition layoutTransition = viewGroup . getLayoutTransition ( ) ; if ( layoutTransition != null && layoutTransition . isChangingLayout ( ) ) { return true ; } int childCount = viewGroup . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( viewGroup . getChildAt ( i ) ) ) { return true ; } } } return false ; } boolean mayHaveInterferingAnimations ( ) { return ( ! arePagesLaidOutContiguously ( ) || mLayoutManager . getChildCount ( ) <= <NUM_LIT> ) && hasRunningChangingLayoutTransition ( ) ; } private boolean arePagesLaidOutContiguously ( ) { int childCount = mLayoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return true ; } boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int [ ] [ ] bounds = new int [ childCount ] [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; ViewGroup . MarginLayoutParams margin ; if ( layoutParams instanceof ViewGroup . MarginLayoutParams ) { margin = ( ViewGroup . MarginLayoutParams ) layoutParams ; } else { margin = ZERO_MARGIN_LAYOUT_PARAMS ; } bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getLeft ( ) - margin . leftMargin : view . getTop ( ) - margin . topMargin ; bounds [ i ] [ <NUM_LIT> ] = isHorizontal ? view . getRight ( ) + margin . rightMargin : view . getBottom ( ) + margin . bottomMargin ; } Arrays . sort ( bounds , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] lhs , int [ ] rhs ) { return lhs [ <NUM_LIT> ] - rhs [ <NUM_LIT> ] ; } } ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( bounds [ i - <NUM_LIT> ] [ <NUM_LIT> ] != bounds [ i ] [ <NUM_LIT> ] ) { return false ; } } int pageSize = bounds [ <NUM_LIT> ] [ <NUM_LIT> ] - bounds [ <NUM_LIT> ] [ <NUM_LIT> ] ; if ( bounds [ <NUM_LIT> ] [ <NUM_LIT> ] > <NUM_LIT> || bounds [ childCount - <NUM_LIT> ] [ <NUM_LIT> ] < pageSize ) { return false ; } return true ; } private boolean hasRunningChangingLayoutTransition ( ) { int childCount = mLayoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { if ( hasRunningChangingLayoutTransition ( mLayoutManager . getChildAt ( i ) ) ) { return true ; } } return false ; } }"}, {"input": "package com . wmods . wppenhacer . preference ; import android . content . Context ; import android . util . AttributeSet ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . R ; import java . io . File ; import java . nio . file . Files ; import java . util . Arrays ; public class FileSelectPreference extends Preference implements Preference . OnPreferenceClickListener , FilePicker . OnFilePickedListener { private String [ ] mineTypes ; private boolean selectDirectory ; public FileSelectPreference ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs ) ; } public FileSelectPreference ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( context , attrs ) ; } public FileSelectPreference ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( context , attrs ) ; } @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { FilePicker . setOnFilePickedListener ( this ) ;", "output": "if ( selectDirectory ) { FilePicker . directoryCapture . launch ( null ) ; return true ; } FilePicker . fileCapture . launch ( mineTypes ) ; return false ; } @ Override public void onFilePicked ( File file ) { if ( file . isDirectory ( ) ) { try { var tmpFile = Files . write ( new File ( file , \"<STR_LIT>\" ) . toPath ( ) , new byte [ <NUM_LIT> ] ) . toFile ( ) ; boolean delete = tmpFile . delete ( ) ; } catch ( Exception ignored ) { Toast . makeText ( this . getContext ( ) , R . string . failed_save_directory , Toast . LENGTH_SHORT ) . show ( ) ; return ; } } else if ( ! file . canRead ( ) ) { Toast . makeText ( this . getContext ( ) , R . string . unable_to_read_this_file , Toast . LENGTH_SHORT ) . show ( ) ; return ; } getSharedPreferences ( ) . edit ( ) . putString ( getKey ( ) , file . getAbsolutePath ( ) ) . apply ( ) ; setSummary ( file . getAbsolutePath ( ) ) ; } public void init ( Context context , AttributeSet attrs ) { setOnPreferenceClickListener ( this ) ; var typedArray = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . FileSelectPreference , <NUM_LIT> , <NUM_LIT> ) ; var attrsArray = typedArray . getTextArray ( R . styleable . FileSelectPreference_android_entryValues ) ; if ( attrsArray != null ) { mineTypes = Arrays . stream ( attrsArray ) . map ( String :: valueOf ) . toArray ( String [ ] :: new ) ; } else { mineTypes = new String [ ] { \"<STR_LIT>\" } ; } selectDirectory = typedArray . getBoolean ( R . styleable . FileSelectPreference_directory , false ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var keyValue = prefs . getString ( this . getKey ( ) , null ) ; setSummary ( keyValue ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import static com . simon . harmonichackernews . utils . Utils . GLOBAL_SHARED_PREFERENCES_KEY ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Resources ; import androidx . preference . PreferenceManager ; import com . simon . harmonichackernews . R ; import java . util . HashSet ; import java . util . Set ; public class SettingsUtils { public static Set < Integer > readIntSetFromSharedPreferences ( Context ctx , String key ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; Set < String > emptyBackup = new HashSet < > ( ) ; Set < String > stringSet = sharedPref . getStringSet ( key , emptyBackup ) ;", "output": "Set < Integer > intSet = new HashSet < > ( stringSet . size ( ) ) ; for ( String string : stringSet ) { intSet . add ( Integer . parseInt ( string ) ) ; } return intSet ; } public static void saveIntSetToSharedPreferences ( Context ctx , String key , Set < Integer > set ) { Set < String > stringSet = new HashSet < > ( set . size ( ) ) ; for ( Integer integer : set ) { stringSet . add ( integer . toString ( ) ) ; } saveStringSetToSharedPreferences ( ctx , key , stringSet ) ; } public static Set < String > readStringSetFromSharedPreferences ( Context ctx , String key ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; Set < String > emptyBackup = new HashSet < > ( ) ; return sharedPref . getStringSet ( key , emptyBackup ) ; } public static void saveStringSetToSharedPreferences ( Context ctx , String key , Set < String > set ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; SharedPreferences . Editor editor = sharedPref . edit ( ) ; editor . putStringSet ( key , set ) . apply ( ) ; } public static void saveStringToSharedPreferences ( Context ctx , String key , String text ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; SharedPreferences . Editor editor = sharedPref . edit ( ) ; editor . putString ( key , text ) . apply ( ) ; } public static String readStringFromSharedPreferences ( Context ctx , String key ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; return sharedPref . getString ( key , null ) ; } public static String readStringFromSharedPreferences ( Context ctx , String key , String fallback ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; return sharedPref . getString ( key , fallback ) ; } public static boolean shouldShowPoints ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldShowCommentsCount ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldUseCompactView ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldShowThumbnails ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldCollapseParent ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldShowIndex ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldShowNavigationButtons ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldHideJobs ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldCollapseTopLevel ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static int getPreferredHotness ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } public static String getPreferredFont ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static boolean shouldUseExternalBrowser ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseMonochromeCommentDepthIndicators ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseIntegratedWebView ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldEnableFoldableSupport ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static String shouldPreloadWebView ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static boolean shouldMatchWebViewTheme ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldBlockAds ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldDisableCommentsSwipeBack ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldShowTopLevelDepthIndicator ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldAlwaysOpenComments ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseCompactHeader ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseLeftAlign ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseTransparentStatusBar ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseSpecialNighttimeTheme ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseCommentsAnimation ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldUseCommentsScrollbar ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldHideClicked ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseLinkPreviewArxiv ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseLinkPreviewGithub ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldUseLinkPreviewWikipedia ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean shouldShowChangelog ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , true , ctx ) ; } public static boolean shouldSwapCommentLongPressTap ( Context ctx ) { return getBooleanPref ( \"<STR_LIT>\" , false , ctx ) ; } public static boolean getBooleanPref ( String key , boolean backup , Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getBoolean ( key , backup ) ; } public static int getPreferredCommentTextSize ( Context ctx ) { return Integer . parseInt ( PreferenceManager . getDefaultSharedPreferences ( ctx ) . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } public static String getPreferredStoryType ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getPreferredCommentSorting ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getPreferredFaviconProvider ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static int getBookmarksIndex ( Resources res ) { String [ ] sortingOptions = res . getStringArray ( R . array . sorting_options ) ; for ( int i = sortingOptions . length - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( sortingOptions [ i ] . equals ( \"<STR_LIT>\" ) ) { return i ; } } return sortingOptions . length - <NUM_LIT> ; } public static int getJobsIndex ( Resources res ) { String [ ] sortingOptions = res . getStringArray ( R . array . sorting_options ) ; for ( int i = sortingOptions . length - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( sortingOptions [ i ] . equals ( \"<STR_LIT>\" ) ) { return i ; } } return sortingOptions . length - <NUM_LIT> ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import de . robv . android . xposed . XSharedPreferences ; public class DebugFeature extends Feature { public DebugFeature ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ;", "output": "} }"}, {"input": "package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class MediaFragment extends BasePreferenceFragment { @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) {", "output": "super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_media , rootKey ) ; } }"}, {"input": "package com . appspa . update . utils ; import android . content . Context ; import android . content . res . ColorStateList ; import android . graphics . Color ; import androidx . annotation . ColorInt ; import androidx . annotation . ColorRes ; import java . util . Random ; public final class ColorUtils { private ColorUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static ColorStateList getColorStateList ( int pressedColor , int normalColor ) { return new ColorStateList ( new int [ ] [ ] { { android . R . attr . state_enabled , android . R . attr . state_pressed } , { android . R . attr . state_enabled } , { } } , new int [ ] { pressedColor , normalColor , Color . WHITE } ) ; } public static int colorDeep ( int color ) { int alpha = Color . alpha ( color ) ; int red = Color . red ( color ) ; int green = Color . green ( color ) ; int blue = Color . blue ( color ) ; float ratio = <NUM_LIT> ; red = ( int ) ( red * ratio ) ; green = ( int ) ( green * ratio ) ; blue = ( int ) ( blue * ratio ) ; return Color . argb ( alpha , red , green , blue ) ; } public static boolean isColorDark ( @ ColorInt int color ) { double darkness = <NUM_LIT> - ( <NUM_LIT> * Color . red ( color ) + <NUM_LIT> * Color . green ( color ) + <NUM_LIT> * Color . blue ( color ) ) / <NUM_LIT> ; return darkness >= <NUM_LIT> ; } public static int getRandomColor ( int alpha , int lower , int upper ) { return new RandomColor ( alpha , lower , upper ) . getColor ( ) ; } public static int getRandomColor ( ) { return new RandomColor ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) . getColor ( ) ; } public static int getColor ( Context context , @ ColorRes int resId ) { return context . getResources ( ) . getColor ( resId ) ; } public static class RandomColor { int alpha ; int lower ; int upper ; RandomColor ( int alpha , int lower , int upper ) { if ( upper <= lower ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } setAlpha ( alpha ) ; setLower ( lower ) ; setUpper ( upper ) ; } public int getColor ( ) { int red = getLower ( ) + new Random ( ) . nextInt ( getUpper ( ) - getLower ( ) + <NUM_LIT> ) ; int green = getLower ( ) + new Random ( ) . nextInt ( getUpper ( ) - getLower ( ) + <NUM_LIT> ) ; int blue = getLower ( ) + new Random ( ) . nextInt ( getUpper ( ) - getLower ( ) + <NUM_LIT> ) ; return Color . argb ( getAlpha ( ) , red , green , blue ) ; } public int getAlpha ( ) { return alpha ;", "output": "} public void setAlpha ( int alpha ) { if ( alpha > <NUM_LIT> ) alpha = <NUM_LIT> ; if ( alpha < <NUM_LIT> ) alpha = <NUM_LIT> ; this . alpha = alpha ; } int getLower ( ) { return lower ; } void setLower ( int lower ) { if ( lower < <NUM_LIT> ) lower = <NUM_LIT> ; this . lower = lower ; } int getUpper ( ) { return upper ; } void setUpper ( int upper ) { if ( upper > <NUM_LIT> ) upper = <NUM_LIT> ; this . upper = upper ; } } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . text . style . ReplacementSpan ; public class DrawTableLinkSpan extends ReplacementSpan { private static final String DEFAULT_TABLE_LINK_TEXT = \"<STR_LIT>\" ; private static float DEFAULT_TEXT_SIZE = <NUM_LIT> ; private static int DEFAULT_TEXT_COLOR = Color . BLUE ; protected String mTableLinkText = DEFAULT_TABLE_LINK_TEXT ; protected float mTextSize = DEFAULT_TEXT_SIZE ; protected int mTextColor = DEFAULT_TEXT_COLOR ; public DrawTableLinkSpan newInstance ( ) { final DrawTableLinkSpan drawTableLinkSpan = new DrawTableLinkSpan ( ) ; drawTableLinkSpan . setTableLinkText ( mTableLinkText ) ; drawTableLinkSpan . setTextSize ( mTextSize ) ; drawTableLinkSpan . setTextColor ( mTextColor ) ; return drawTableLinkSpan ; } @ Override public int getSize ( Paint paint , CharSequence text , int start , int end , Paint . FontMetricsInt fm ) { int width = ( int ) paint . measureText ( mTableLinkText , <NUM_LIT> , mTableLinkText . length ( ) ) ; mTextSize = paint . getTextSize ( ) ; return width ; } @ Override public void draw ( Canvas canvas , CharSequence text , int start , int end , float x , int top , int y , int bottom , Paint paint ) { final Paint paint2 = new Paint ( ) ; paint2 . setStyle ( Paint . Style . STROKE ) ; paint2 . setColor ( mTextColor ) ; paint2 . setAntiAlias ( true ) ; paint2 . setTextSize ( mTextSize ) ; canvas . drawText ( mTableLinkText , x , bottom , paint2 ) ; } public void setTableLinkText ( String tableLinkText ) { this . mTableLinkText = tableLinkText ; } public void setTextSize ( float textSize ) { this . mTextSize = textSize ; } public void setTextColor ( int textColor ) { this . mTextColor = textColor ; } public String getTableLinkText ( ) { return mTableLinkText ; } public float getTextSize ( ) { return mTextSize ; } public int getTextColor ( ) {", "output": "return mTextColor ; } }"}, {"input": "package com . reactnative . imagecrop ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Color ; import android . media . ExifInterface ; import android . net . Uri ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . facebook . common . logging . FLog ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . RCTEventEmitter ; import com . yalantis . ucrop . callback . BitmapCropCallback ; import com . yalantis . ucrop . callback . OverlayViewChangeListener ; import com . yalantis . ucrop . view . GestureCropImageView ; import com . yalantis . ucrop . view . OverlayView ; import com . yalantis . ucrop . view . UCropView ; import java . io . File ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . UUID ; public class RNImageCropView extends FrameLayout { private static final int DEFAULT_COMPRESS_QUALITY = <NUM_LIT> ; private static final Bitmap . CompressFormat DEFAULT_COMPRESS_FORMAT = Bitmap . CompressFormat . PNG ; private static final String TAG = \"<STR_LIT>\" ; private String fileUri ; private Uri mOutputUri ; public void setFileUri ( String fileUri ) { FLog . i ( TAG , \"<STR_LIT>\" + fileUri ) ; this . fileUri = fileUri ; } private String cropStyle ; public void setCropStyle ( String cropStyle ) { this . cropStyle = cropStyle ; FLog . i ( TAG , \"<STR_LIT>\" + cropStyle ) ; } private ObjectRect objectRect ; public void setObjectRect ( ReadableMap map ) { FLog . i ( TAG , \"<STR_LIT>\" + map ) ; this . objectRect = ObjectRect . fromReadableMap ( map ) ; } public void initProperties ( ) { try { mGestureCropImageView . setImageURI ( Uri . parse ( fileUri ) ) ; mGestureCropImageView . setImageUri ( Uri . parse ( fileUri ) , mOutputUri ) ; } catch ( Exception e ) { FLog . i ( TAG , \"<STR_LIT>\" + e . getMessage ( ) ) ; return ; } try { mGestureCropImageView . setBackgroundColor ( Color . BLACK ) ; mGestureCropImageView . setRotateEnabled ( false ) ; if ( cropStyle != null && cropStyle . equals ( \"<STR_LIT>\" ) ) { mOverlayView . setShowCropGrid ( false ) ; mOverlayView . setCircleDimmedLayer ( true ) ; mOverlayView . setShowCropFrame ( false ) ; mGestureCropImageView . setTargetAspectRatio ( <NUM_LIT> ) ; } else { mOverlayView . setFreestyleCropMode ( OverlayView . FREESTYLE_CROP_MODE_ENABLE ) ; if ( objectRect != null ) { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; File file = new File ( fileUri . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; BitmapFactory . decodeFile ( file . getAbsolutePath ( ) , options ) ; int imageHeight = options . outHeight ; int imageWidth = options . outWidth ; int degree = getBitmapDegree ( file ) ; if ( degree == <NUM_LIT> || degree == <NUM_LIT> ) { FLog . i ( TAG , \"<STR_LIT>\" ) ; int tmp = imageWidth ; imageWidth = imageHeight ; imageHeight = tmp ; } FLog . i ( TAG , \"<STR_LIT>\" + imageHeight ) ; FLog . i ( TAG , \"<STR_LIT>\" + imageWidth ) ; setupDetectedObjectBounds ( imageWidth , imageHeight , objectRect . getTop ( ) , objectRect . getLeft ( ) , objectRect . getWidth ( ) , objectRect . getHeight ( ) ) ; } else { mGestureCropImageView . setTargetAspectRatio ( <NUM_LIT> ) ; } } } catch ( Exception e ) { FLog . i ( TAG , \"<STR_LIT>\" + e . getMessage ( ) ) ; } } private void setupDetectedObjectBounds ( float imageWidth , float imageHeight , float top , float left , float width , float height ) { postDelayed ( new Runnable ( ) { @ Override public void run ( ) { try { Field mTargetAspectRatioField = OverlayView . class . getDeclaredField ( \"<STR_LIT>\" ) ; mTargetAspectRatioField . setAccessible ( true ) ; float mTargetAspectRatio = mTargetAspectRatioField . getFloat ( mOverlayView ) ; Field mThisHeightField = OverlayView . class . getDeclaredField ( \"<STR_LIT>\" ) ; mThisHeightField . setAccessible ( true ) ; int mThisHeight = mThisHeightField . getInt ( mOverlayView ) ; Field mThisWidthField = OverlayView . class . getDeclaredField ( \"<STR_LIT>\" ) ; mThisWidthField . setAccessible ( true ) ; int mThisWidth = mThisWidthField . getInt ( mOverlayView ) ; int halfDiff = ( mThisHeight - ( int ) ( mThisWidth / mTargetAspectRatio ) ) / <NUM_LIT> ; float mLeft = mOverlayView . getPaddingLeft ( ) + mThisWidth * ( left / imageWidth ) ; float mTop = mOverlayView . getPaddingTop ( ) + halfDiff + ( mThisWidth / mTargetAspectRatio ) * top / imageHeight ; float mRight = mLeft + mThisWidth * width / imageWidth ; float mBottom = mTop + mThisWidth / mTargetAspectRatio * height / imageHeight ; mOverlayView . getCropViewRect ( ) . set ( mLeft , mTop , mRight , mBottom ) ; OverlayViewChangeListener overlayViewChangeListener = mOverlayView . getOverlayViewChangeListener ( ) ; if ( overlayViewChangeListener != null ) { overlayViewChangeListener . onCropRectUpdated ( mOverlayView . getCropViewRect ( ) ) ; } Method updateGridPointsMethod = OverlayView . class . getDeclaredMethod ( \"<STR_LIT>\" ) ; updateGridPointsMethod . setAccessible ( true ) ; updateGridPointsMethod . invoke ( mOverlayView ) ; mOverlayView . postInvalidate ( ) ; } catch ( Exception e ) { FLog . e ( TAG , \"<STR_LIT>\" + e . getMessage ( ) ) ; } } } , <NUM_LIT> ) ; } private UCropView mUCropView ; private GestureCropImageView mGestureCropImageView ;", "output": "private OverlayView mOverlayView ; public RNImageCropView ( Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . rn_crop_view , this , true ) ; mUCropView = view . findViewById ( R . id . ucrop ) ; mGestureCropImageView = mUCropView . getCropImageView ( ) ; mOverlayView = mUCropView . getOverlayView ( ) ; mOutputUri = Uri . fromFile ( new File ( context . getCacheDir ( ) , UUID . randomUUID ( ) . toString ( ) + \"<STR_LIT>\" ) ) ; FLog . i ( TAG , \"<STR_LIT>\" + mOutputUri . toString ( ) ) ; } public void crop ( ) { mGestureCropImageView . cropAndSaveImage ( DEFAULT_COMPRESS_FORMAT , DEFAULT_COMPRESS_QUALITY , new BitmapCropCallback ( ) { @ Override public void onBitmapCropped ( @ NonNull Uri resultUri , int offsetX , int offsetY , int imageWidth , int imageHeight ) { FLog . i ( TAG , \"<STR_LIT>\" + resultUri . toString ( ) ) ; onCropped ( resultUri . toString ( ) ) ; } @ Override public void onCropFailure ( @ NonNull Throwable t ) { FLog . i ( TAG , \"<STR_LIT>\" + t . toString ( ) ) ; } } ) ; } private void onCropped ( String uri ) { WritableMap data = Arguments . createMap ( ) ; data . putString ( \"<STR_LIT>\" , uri ) ; ReactContext reactContext = ( ReactContext ) getContext ( ) ; reactContext . getJSModule ( RCTEventEmitter . class ) . receiveEvent ( getId ( ) , \"<STR_LIT>\" , data ) ; } private int getBitmapDegree ( File file ) { int degree = <NUM_LIT> ; try { ExifInterface exifInterface = new ExifInterface ( file . getAbsolutePath ( ) ) ; int orientation = exifInterface . getAttributeInt ( ExifInterface . TAG_ORIENTATION , ExifInterface . ORIENTATION_NORMAL ) ; switch ( orientation ) { case ExifInterface . ORIENTATION_ROTATE_90 : degree = <NUM_LIT> ; break ; case ExifInterface . ORIENTATION_ROTATE_180 : degree = <NUM_LIT> ; break ; case ExifInterface . ORIENTATION_ROTATE_270 : degree = <NUM_LIT> ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return degree ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import android . util . Log ; import android . view . View ; import androidx . core . graphics . Insets ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . EventDispatcher ; public class KeyboardManualHandler { private final KeyboardInsetsView view ; private final ThemedReactContext reactContext ; public KeyboardManualHandler ( KeyboardInsetsView view , ThemedReactContext reactContext ) { this . view = view ; this . reactContext = reactContext ; } void onStart ( View focusView , int keyboardHeight ) { sendEvent ( new KeyboardStatusChangedEvent ( view . getId ( ) , keyboardHeight , SystemUI . isImeVisible ( view ) , true ) ) ; } void onEnd ( View focusView , int keyboardHeight ) { sendEvent ( new KeyboardStatusChangedEvent ( view . getId ( ) , keyboardHeight , SystemUI . isImeVisible ( view ) , false ) ) ; } void onApplyWindowInsets ( WindowInsetsCompat insets , View focusView , int keyboardHeight ) { sendEvent ( new KeyboardStatusChangedEvent ( view . getId ( ) , keyboardHeight , SystemUI . isImeVisible ( view ) , true ) ) ; handleKeyboardTransition ( insets , focusView ) ;", "output": "sendEvent ( new KeyboardStatusChangedEvent ( view . getId ( ) , keyboardHeight , SystemUI . isImeVisible ( view ) , false ) ) ; } void handleKeyboardTransition ( WindowInsetsCompat insets , View focusView ) { Insets imeInsets = insets . getInsets ( WindowInsetsCompat . Type . ime ( ) ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + imeInsets . bottom ) ; sendEvent ( new KeyboardPositionChangedEvent ( view . getId ( ) , imeInsets . bottom ) ) ; } private void sendEvent ( Event < ? > event ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , view . getId ( ) ) ; eventDispatcher . dispatchEvent ( event ) ; } }"}, {"input": "package de . robv . android . xposed . services ; import java . io . ByteArrayInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import de . robv . android . xposed . SELinuxHelper ; public abstract class BaseService { public static final int R_OK = <NUM_LIT> ; public static final int W_OK = <NUM_LIT> ; public static final int X_OK = <NUM_LIT> ; public static final int F_OK = <NUM_LIT> ; public boolean hasDirectFileAccess ( ) { return false ; } public abstract boolean checkFileAccess ( String filename , int mode ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean checkFileExists ( String filename ) { return checkFileAccess ( filename , F_OK ) ; } public abstract FileResult statFile ( String filename ) throws IOException ; public long getFileSize ( String filename ) throws IOException { return statFile ( filename ) . size ; } public long getFileModificationTime ( String filename ) throws IOException { return statFile ( filename ) . mtime ; } public abstract byte [ ] readFile ( String filename ) throws IOException ; public abstract FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException ; public abstract FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException ; public InputStream getFileInputStream ( String filename ) throws IOException { return new ByteArrayInputStream ( readFile ( filename ) ) ; } public FileResult getFileInputStream ( String filename , long previousSize , long previousTime ) throws IOException { FileResult result = readFile ( filename , previousSize , previousTime ) ; if ( result . content == null ) return result ; return new FileResult ( new ByteArrayInputStream ( result . content ) , result . size , result . mtime ) ; } BaseService ( ) { } static void ensureAbsolutePath ( String filename ) { if ( ! filename . startsWith ( \"<STR_LIT>\" ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + filename ) ; } } static void throwCommonIOException ( int errno , String errorMsg , String filename , String defaultText ) throws IOException {", "output": "switch ( errno ) { case <NUM_LIT> : case <NUM_LIT> : throw new FileNotFoundException ( errorMsg != null ? errorMsg : \"<STR_LIT>\" + filename ) ; case <NUM_LIT> : throw new FileNotFoundException ( errorMsg != null ? errorMsg : \"<STR_LIT>\" + filename ) ; case <NUM_LIT> : throw new OutOfMemoryError ( errorMsg ) ; case <NUM_LIT> : throw new FileNotFoundException ( errorMsg != null ? errorMsg : \"<STR_LIT>\" + filename ) ; default : throw new IOException ( errorMsg != null ? errorMsg : \"<STR_LIT>\" + errno + defaultText + filename ) ; } } }"}, {"input": "package com . norman . webviewup . lib ; import org . junit . Test ; import static org . junit . Assert . * ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) {", "output": "assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; public class MessageHistory extends SQLiteOpenHelper { private static MessageHistory mInstance ; private SQLiteDatabase dbWrite ; public MessageHistory ( Context context ) { super ( context , \"<STR_LIT>\" , null , <NUM_LIT> ) ; } public static MessageHistory getInstance ( ) { synchronized ( MessageHistory . class ) { if ( mInstance == null || ! mInstance . getReadableDatabase ( ) . isOpen ( ) ) { mInstance = new MessageHistory ( Utils . getApplication ( ) ) ; mInstance . dbWrite = mInstance . getWritableDatabase ( ) ;", "output": "} } return mInstance ; } public final void insertMessage ( long id , String message , long timestamp ) { synchronized ( this ) { ContentValues contentValues0 = new ContentValues ( ) ; contentValues0 . put ( \"<STR_LIT>\" , id ) ; contentValues0 . put ( \"<STR_LIT>\" , message ) ; contentValues0 . put ( \"<STR_LIT>\" , timestamp ) ; dbWrite . insert ( \"<STR_LIT>\" , null , contentValues0 ) ; } } public ArrayList < MessageItem > getMessages ( long v ) { Cursor history = dbWrite . query ( \"<STR_LIT>\" , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } , \"<STR_LIT>\" , new String [ ] { String . valueOf ( v ) } , null , null , null ) ; if ( history == null ) { return null ; } if ( ! history . moveToFirst ( ) ) { history . close ( ) ; return null ; } ArrayList < MessageItem > messages = new ArrayList < > ( ) ; do { long id = history . getLong ( history . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long timestamp = history . getLong ( history . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String message = history . getString ( history . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; messages . add ( new MessageItem ( id , message , timestamp ) ) ; } while ( history . moveToNext ( ) ) ; return messages ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { sqLiteDatabase . execSQL ( \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { } public static class MessageItem { public long id ; public String message ; public long timestamp ; public MessageItem ( long id , String message , long timestamp ) { this . id = id ; this . message = message ; this . timestamp = timestamp ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment ; import android . os . Build ; import android . util . ArrayMap ; import android . util . Log ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . ForwardDynamicReqObject ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . ForwardDynamicResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . RemoveDynamicReqObject ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . ServiceGenerator ; import okhttp3 . FormBody ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . RequestBody ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; import retrofit2 . Call ; public class CommentManipulator { public OkHttpClient httpClient ; private OkHttpClient httpClientNoRedirects ; private BiliApiService biliApiService ; private String cookie ; private String deputyCookie ; public CommentManipulator ( String cookie , String deputyCookie ) { this . httpClient = OkHttpUtil . getHttpClient ( ) ; httpClientNoRedirects = new OkHttpClient . Builder ( ) . followRedirects ( false ) . build ( ) ; this . biliApiService = ServiceGenerator . createService ( BiliApiService . class ) ; this . cookie = cookie ; this . deputyCookie = deputyCookie ; } public void setCookie ( String cookie ) { this . cookie = cookie ; } public String getCookie ( ) { return cookie ; } public boolean cookieAreSet ( ) { if ( cookie == null ) { return false ; } return cookie . contains ( \"<STR_LIT>\" ) ; } public boolean deputyCookieAreSet ( ) { if ( deputyCookie == null ) { return false ; } return deputyCookie . contains ( \"<STR_LIT>\" ) ; } public String getCsrfFromCookie ( boolean isDeputy ) { String cookie = isDeputy ? this . deputyCookie : this . cookie ; int csrfIndex = cookie . indexOf ( \"<STR_LIT>\" ) ; return cookie . substring ( csrfIndex + <NUM_LIT> , csrfIndex + <NUM_LIT> + <NUM_LIT> ) ; } public Call < GeneralResponse < VideoInfo > > getVideoInfoByAid ( long aid ) { return biliApiService . getVideoInfoByAid ( aid ) ; } public String bvidToOid ( String bvid ) throws IOException { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + bvid ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; String aid = null ; if ( response . code ( ) == <NUM_LIT> ) { JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; if ( respJson . getInteger ( \"<STR_LIT>\" ) == <NUM_LIT> ) { aid = respJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; } } return aid ; } public CommentArea dvidToCommentArea ( String dvid ) throws IOException { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + dvid ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + Build . VERSION . RELEASE + \"<STR_LIT>\" + Build . MODEL + \"<STR_LIT>\" + Build . ID + \"<STR_LIT>\" + \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , cookie ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; String aid = null ; int comment_type = CommentArea . AREA_TYPE_DYNAMIC11 ; if ( response . code ( ) == <NUM_LIT> ) { JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; if ( respJson . getInteger ( \"<STR_LIT>\" ) == <NUM_LIT> ) { aid = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; comment_type = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getInteger ( \"<STR_LIT>\" ) ; } } if ( aid != null ) { return new CommentArea ( Long . parseLong ( aid ) , dvid , comment_type ) ; } else { return null ; } } public CommentAddResult sendComment ( String comment , long parent , long root , CommentArea commentArea , boolean isDeputyAccount ) throws IOException , BiliBiliApiException { Call < GeneralResponse < CommentAddResult > > call = getSendCommentCall ( comment , parent , root , commentArea , isDeputyAccount ) ; GeneralResponse < CommentAddResult > body = call . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { return body . data ; } else { throw new BiliBiliApiException ( body , \"<STR_LIT>\" + comment ) ; } } public Call < GeneralResponse < CommentAddResult > > getSendCommentCall ( String comment , long parent , long root , CommentArea commentArea , boolean isDeputyAccount ) { ArrayMap < String , String > arrayMap = new ArrayMap < > ( ) ; arrayMap . put ( \"<STR_LIT>\" , getCsrfFromCookie ( isDeputyAccount ) ) ; arrayMap . put ( \"<STR_LIT>\" , comment ) ; arrayMap . put ( \"<STR_LIT>\" , String . valueOf ( commentArea . oid ) ) ; arrayMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; arrayMap . put ( \"<STR_LIT>\" , String . valueOf ( parent ) ) ; arrayMap . put ( \"<STR_LIT>\" , String . valueOf ( root ) ) ; arrayMap . put ( \"<STR_LIT>\" , String . valueOf ( commentArea . type ) ) ; return biliApiService . postComment ( isDeputyAccount ? deputyCookie : getCookie ( ) , arrayMap ) ; } public BiliComment findComment ( CommentArea commentArea , long rpid , long root ) throws IOException , BiliBiliApiException { List < BiliComment > replies ; if ( root == <NUM_LIT> ) { GeneralResponse < CommentPage > body = biliApiService . getCommentPageNoAccount ( commentArea . oid , commentArea . type , <NUM_LIT> , BiliApiService . COMMENT_SORT_BY_TIME ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; replies = body . data . replies ; if ( replies != null && replies . size ( ) > <NUM_LIT> ) { for ( BiliComment reply : replies ) { if ( reply . rpid == rpid ) { return reply ; } } } return null ; } else { return findCommentFromCommentReplyArea ( commentArea , rpid , root , false ) ; } } public BiliComment findCommentFromCommentReplyArea ( CommentArea commentArea , long rpid , long root , boolean hasAccount ) throws IOException , BiliBiliApiException { GeneralResponse < CommentPage > body ; if ( hasAccount ) { body = biliApiService . getCommentMainPageHasAccount ( cookie , commentArea . oid , commentArea . type , BiliApiService . COMMENT_SORT_MODE_TIME , <NUM_LIT> , rpid ) . execute ( ) . body ( ) ; } else { body = biliApiService . getCommentMainPageNoAccount ( getBuvid3Cookie ( ) , commentArea . oid , commentArea . type , BiliApiService . COMMENT_SORT_MODE_TIME , <NUM_LIT> , rpid ) . execute ( ) . body ( ) ; } OkHttpUtil . respNotNull ( body ) ; if ( ! body . isSuccess ( ) ) { throw new BiliBiliApiException ( body , \"<STR_LIT>\" ) ; } List < BiliComment > comments = new ArrayList < > ( body . data . replies ) ; if ( body . data . top_replies != null ) { comments . addAll ( body . data . top_replies ) ; } for ( BiliComment comment : comments ) { if ( comment . rpid == root ) { List < BiliComment > replies = comment . replies ; if ( replies != null ) { for ( BiliComment reply : replies ) { if ( reply . rpid == rpid ) { return reply ; } } } } } return null ; } public BiliComment findCommentUsingSeekRpid ( Comment comment , boolean hasAccount ) throws IOException , BiliBiliApiException { CommentArea commentArea = comment . commentArea ; GeneralResponse < CommentPage > body ; if ( hasAccount ) { body = biliApiService . getCommentMainPageHasAccount ( cookie , commentArea . oid , commentArea . type , BiliApiService . COMMENT_SORT_MODE_TIME , <NUM_LIT> , comment . rpid ) . execute ( ) . body ( ) ; } else { body = biliApiService . getCommentMainPageNoAccount ( getBuvid3Cookie ( ) , commentArea . oid , commentArea . type , BiliApiService . COMMENT_SORT_MODE_TIME , <NUM_LIT> , comment . rpid ) . execute ( ) . body ( ) ; } OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { List < BiliComment > comments = body . data . replies ; if ( comments == null || comments . size ( ) == <NUM_LIT> ) { return null ; } for ( BiliComment gotAComment : comments ) { if ( gotAComment . rpid == comment . rpid ) { return gotAComment ; } } List < BiliComment > topReplies = body . data . top_replies ; if ( topReplies == null || topReplies . size ( ) == <NUM_LIT> ) { return null ; } for ( BiliComment aTopComment : topReplies ) { if ( aTopComment . rpid == comment . rpid ) { return aTopComment ; } } return null ; } else { throw new BiliBiliApiException ( body , \"<STR_LIT>\" ) ; } } public interface PageTurnListener { void onPageTurn ( int page ) ; } public CommentArea matchCommentArea ( String input ) throws IOException { if ( input . startsWith ( \"<STR_LIT>\" ) ) { if ( bvidToOid ( input ) != null ) { return new CommentArea ( Long . parseLong ( bvidToOid ( input ) ) , input , CommentArea . AREA_TYPE_VIDEO ) ; } else { return null ; }", "output": "} else if ( input . startsWith ( \"<STR_LIT>\" ) ) { return new CommentArea ( ( Long . parseLong ( input . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) , input , CommentArea . AREA_TYPE_ARTICLE ) ; } if ( input . startsWith ( \"<STR_LIT>\" ) ) { Request request = new Request . Builder ( ) . url ( input ) . build ( ) ; Response response = httpClientNoRedirects . newCall ( request ) . execute ( ) ; input = response . header ( \"<STR_LIT>\" ) ; System . out . println ( input ) ; } if ( input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; if ( bvidToOid ( sourceId ) != null ) { return new CommentArea ( Long . parseLong ( bvidToOid ( sourceId ) ) , sourceId , CommentArea . AREA_TYPE_VIDEO ) ; } else { return null ; } } else if ( input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) ) { String text = \"<STR_LIT>\" ; String aid = input . substring ( input . indexOf ( text ) + text . length ( ) ) ; return new CommentArea ( Long . parseLong ( aid . substring ( <NUM_LIT> ) ) , aid , CommentArea . AREA_TYPE_VIDEO ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) || input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; return new CommentArea ( Long . parseLong ( sourceId ) , \"<STR_LIT>\" + sourceId , CommentArea . AREA_TYPE_ARTICLE ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; return new CommentArea ( Long . parseLong ( sourceId ) , \"<STR_LIT>\" + sourceId , CommentArea . AREA_TYPE_ARTICLE ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; return new CommentArea ( Long . parseLong ( sourceId ) , \"<STR_LIT>\" + sourceId , CommentArea . AREA_TYPE_ARTICLE ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) ) { return dvidToCommentArea ( subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; return dvidToCommentArea ( sourceId ) ; } else if ( input . startsWith ( \"<STR_LIT>\" ) ) { String sourceId = subUrl ( input , \"<STR_LIT>\" , <NUM_LIT> ) ; return dvidToCommentArea ( sourceId ) ; } return null ; } public void matchCommentAreaInUi ( String input , MatchCommentAreaCallBack callBack ) { TaskManger . start ( ( ) -> { try { CommentArea commentArea = matchCommentArea ( input ) ; TaskManger . postOnUiThread ( ( ) -> callBack . onMatchedArea ( commentArea ) ) ; } catch ( IOException e ) { TaskManger . postOnUiThread ( ( ) -> callBack . onNetworkError ( e ) ) ; } } ) ; } public interface MatchCommentAreaCallBack { void onNetworkError ( IOException e ) ; void onMatchedArea ( CommentArea commentArea ) ; } private String subUrl ( String url , String text , int length ) { String subText = url . substring ( url . indexOf ( text ) + text . length ( ) , url . indexOf ( text ) + text . length ( ) + length ) ; System . out . println ( subText ) ; return subText ; } public MartialLawCommentArea getMartialLawCommentArea ( CommentArea commentArea , long testCommentRpid , boolean isDeputyAccount ) throws IOException { byte [ ] coverImageData = null ; String title = null , up = null ; GeneralResponse < CommentReplyPage > resp = getCommentReplyHasAccount ( commentArea , testCommentRpid , <NUM_LIT> , isDeputyAccount ) ; if ( commentArea . type == CommentArea . AREA_TYPE_VIDEO ) { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + commentArea . sourceId ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( response . code ( ) == <NUM_LIT> ) { JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; if ( respJson . getInteger ( \"<STR_LIT>\" ) == <NUM_LIT> ) { String picUrl = respJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; Request request1 = new Request . Builder ( ) . url ( picUrl + \"<STR_LIT>\" ) . build ( ) ; Response response1 = httpClient . newCall ( request1 ) . execute ( ) ; coverImageData = response1 . body ( ) . bytes ( ) ; title = respJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; up = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; } } } else if ( commentArea . type == CommentArea . AREA_TYPE_ARTICLE ) { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + commentArea . oid ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( response . code ( ) == <NUM_LIT> ) { JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; if ( respJson . getInteger ( \"<STR_LIT>\" ) == <NUM_LIT> ) { String picUrl = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONArray ( \"<STR_LIT>\" ) . getString ( <NUM_LIT> ) ; Request request1 = new Request . Builder ( ) . url ( picUrl + \"<STR_LIT>\" ) . build ( ) ; Response response1 = httpClient . newCall ( request1 ) . execute ( ) ; coverImageData = response1 . body ( ) . bytes ( ) ; title = respJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; up = respJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; } } } else if ( commentArea . type == CommentArea . AREA_TYPE_DYNAMIC11 || commentArea . type == CommentArea . AREA_TYPE_DYNAMIC17 ) { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" + commentArea . sourceId ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( response . code ( ) == <NUM_LIT> ) { JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; if ( respJson . getInteger ( \"<STR_LIT>\" ) == <NUM_LIT> ) { up = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; title = respJson . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; if ( title . length ( ) > <NUM_LIT> ) { title = title . substring ( <NUM_LIT> , <NUM_LIT> ) ; title += \"<STR_LIT>\" ; } } } } else { return null ; } String defaultDisposalMethod = null ; if ( resp . code == CommentAddResult . CODE_DELETED ) { defaultDisposalMethod = MartialLawCommentArea . DISPOSAL_METHOD_QUICK_DELETE ; } else { defaultDisposalMethod = MartialLawCommentArea . DISPOSAL_METHOD_SHADOW_BAN ; } return new MartialLawCommentArea ( commentArea , defaultDisposalMethod , title , up , coverImageData ) ; } public JSONObject appealComment ( String id , String reason ) throws IOException { String idType = \"<STR_LIT>\" ; if ( id . startsWith ( \"<STR_LIT>\" ) ) { idType = \"<STR_LIT>\" ; } RequestBody requestBody = new FormBody . Builder ( ) . add ( \"<STR_LIT>\" , getCsrfFromCookie ( false ) ) . add ( idType , id ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . add ( \"<STR_LIT>\" , reason ) . build ( ) ; Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" ) . header ( \"<STR_LIT>\" , cookie ) . post ( requestBody ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; JSONObject respJson = JSON . parseObject ( response . body ( ) . string ( ) ) ; Log . i ( \"<STR_LIT>\" , respJson . toJSONString ( ) ) ; return respJson ; } public Call < GeneralResponse < Object > > createDeleteCommentCall ( CommentArea commentArea , long rpid ) { return biliApiService . deleteComment ( getCookie ( ) , getCsrfFromCookie ( false ) , commentArea . oid , commentArea . type , rpid ) ; } public GeneralResponse < Object > deleteComment ( CommentArea commentArea , long rpid , boolean isDeputyAccount ) throws IOException , BiliBiliApiException { GeneralResponse < Object > body = biliApiService . deleteComment ( isDeputyAccount ? deputyCookie : getCookie ( ) , getCsrfFromCookie ( isDeputyAccount ) , commentArea . oid , commentArea . type , rpid ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; if ( ! body . isSuccess ( ) ) { throw new BiliBiliApiException ( body , String . format ( \"<STR_LIT>\" , rpid , getDedeUserID ( isDeputyAccount ) ) ) ; } return body ; } public GeneralResponse < CommentReplyPage > getCommentReplyNoAccount ( CommentArea commentArea , long rootRpid , int pn ) throws IOException { return biliApiService . getCommentReply ( commentArea . oid , pn , <NUM_LIT> , rootRpid , commentArea . type , <NUM_LIT> ) . execute ( ) . body ( ) ; } public GeneralResponse < CommentReplyPage > getCommentReplyHasAccount ( CommentArea commentArea , long rootRpid , int pn , boolean isDeputyAccount ) throws IOException { return biliApiService . getCommentReply ( isDeputyAccount ? deputyCookie : cookie , getCsrfFromCookie ( isDeputyAccount ) , commentArea . oid , pn , <NUM_LIT> , rootRpid , commentArea . type , <NUM_LIT> ) . execute ( ) . body ( ) ; } public ForwardDynamicResult forwardDynamicUsingSubAccount ( @ NonNull String dynamicId ) throws IOException , BiliBiliApiException { GeneralResponse < ForwardDynamicResult > body = biliApiService . forwardDynamic ( deputyCookie , \"<STR_LIT>\" , getCsrfFromCookie ( true ) , ForwardDynamicReqObject . getInstance ( getDedeUserID ( true ) , dynamicId ) ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; if ( ! body . isSuccess ( ) ) { throw new BiliBiliApiException ( body , \"<STR_LIT>\" ) ; } return body . data ; } public void deleteDynamicUsingSubAccount ( @ NonNull String dynamicId ) throws IOException , BiliBiliApiException { GeneralResponse < Object > response = biliApiService . removeDynamic ( deputyCookie , \"<STR_LIT>\" , getCsrfFromCookie ( true ) , new RemoveDynamicReqObject ( dynamicId ) ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( response ) ; if ( ! response . isSuccess ( ) ) { throw new BiliBiliApiException ( response , \"<STR_LIT>\" + dynamicId + \"<STR_LIT>\" ) ; } } public boolean checkCookieNotFailed ( ) throws IOException { Request request = new Request . Builder ( ) . url ( \"<STR_LIT>\" ) . addHeader ( \"<STR_LIT>\" , cookie ) . build ( ) ; ResponseBody body = httpClient . newCall ( request ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; JSONObject userProfileJSON = JSON . parseObject ( body . string ( ) ) ; JSONObject userProfile = userProfileJSON . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) ; return userProfile != null ; } public String getBuvid3Cookie ( ) { String patternString = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( patternString ) ; Matcher matcher = pattern . matcher ( cookie ) ; matcher . find ( ) ; return matcher . group ( ) ; } public String getDedeUserID ( boolean isDeputy ) { String patternString = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( patternString ) ; Matcher matcher = pattern . matcher ( isDeputy ? deputyCookie : cookie ) ; matcher . find ( ) ; return matcher . group ( <NUM_LIT> ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . bean ; import java . io . File ; import java . util . ArrayDeque ; import java . util . List ; import java . util . Queue ; public class TransferJob { public File localDir ; public String remoteDir ; public Queue < File > fileQueue ; public TransferJob ( File localDir , String remoteDir , List < File > files ) {", "output": "this . localDir = localDir ; this . remoteDir = remoteDir ; this . fileQueue = new ArrayDeque < > ( ) ; fileQueue . addAll ( files ) ; } }"}, {"input": "package com . appspa . update . utils ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . ApplicationInfo ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . content . pm . PackageManager . NameNotFoundException ; import android . net . Uri ; import android . os . Build ; import android . text . TextUtils ; import androidx . annotation . RequiresPermission ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . _AppSpace ; import java . io . File ; import java . io . IOException ; import java . util . Iterator ; import java . util . List ; import static android . Manifest . permission . INSTALL_PACKAGES ; public final class ApkUtils { private static final int APP_INSTALL_AUTO = <NUM_LIT> ; private static final int APP_INSTALL_INTERNAL = <NUM_LIT> ; private static final int APP_INSTALL_EXTERNAL = <NUM_LIT> ; public static final int REQUEST_CODE_INSTALL_APP = <NUM_LIT> ; private static boolean sSupportSilentInstall = true ; public static boolean isSupportSilentInstall ( ) { return sSupportSilentInstall ; } public static void setSupportSilentInstall ( boolean supportSilentInstall ) { ApkUtils . sSupportSilentInstall = supportSilentInstall ; } private ApkUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean install ( Context context , File apkFile ) throws IOException { return isSupportSilentInstall ( ) ? install ( context , apkFile . getCanonicalPath ( ) ) : installNormal ( context , apkFile . getCanonicalPath ( ) ) ; } public static boolean install ( Context context , String filePath ) { if ( ApkUtils . isSystemApplication ( context ) || ShellUtils . checkRootPermission ( ) ) { return installAppSilent ( context , filePath ) ; } return installNormal ( context , filePath ) ; } @ RequiresPermission ( INSTALL_PACKAGES ) public static boolean installAppSilent ( Context context , String filePath ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . N ) { return installAppSilentBelow24 ( context , filePath ) ; } else { return installAppSilentAbove24 ( context . getPackageName ( ) , filePath ) ; } } @ RequiresPermission ( INSTALL_PACKAGES ) private static boolean installAppSilentBelow24 ( Context context , String filePath ) { File file = FileUtils . getFileByPath ( filePath ) ; if ( ! FileUtils . isFileExists ( file ) ) { return false ; } String pmParams = \"<STR_LIT>\" + getInstallLocationParams ( ) ; StringBuilder command = new StringBuilder ( ) . append ( \"<STR_LIT>\" ) . append ( pmParams ) . append ( \"<STR_LIT>\" ) . append ( filePath . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; ShellUtils . CommandResult commandResult = ShellUtils . execCommand ( command . toString ( ) , ! isSystemApplication ( context ) , true ) ; return commandResult . successMsg != null && ( commandResult . successMsg . contains ( \"<STR_LIT>\" ) || commandResult . successMsg . contains ( \"<STR_LIT>\" ) ) ; } private static String getInstallLocationParams ( ) { int location = getInstallLocation ( ) ; switch ( location ) { case APP_INSTALL_INTERNAL : return \"<STR_LIT>\" ; case APP_INSTALL_EXTERNAL : return \"<STR_LIT>\" ; default : break ; } return \"<STR_LIT>\" ; } public static int getInstallLocation ( ) { ShellUtils . CommandResult commandResult = ShellUtils . execCommand ( \"<STR_LIT>\" , false , true ) ; if ( commandResult . result == <NUM_LIT> && commandResult . successMsg != null && commandResult . successMsg . length ( ) > <NUM_LIT> ) { try { int location = Integer . parseInt ( commandResult . successMsg . substring ( <NUM_LIT> , <NUM_LIT> ) ) ; switch ( location ) { case APP_INSTALL_INTERNAL : return APP_INSTALL_INTERNAL ; case APP_INSTALL_EXTERNAL : return APP_INSTALL_EXTERNAL ; default : break ; } } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } } return APP_INSTALL_AUTO ; } @ RequiresPermission ( INSTALL_PACKAGES ) private static boolean installAppSilentAbove24 ( String packageName , String filePath ) { File file = FileUtils . getFileByPath ( filePath ) ; if ( ! FileUtils . isFileExists ( file ) ) { return false ; } boolean isRoot = isDeviceRooted ( ) ; String command = \"<STR_LIT>\" + packageName + \"<STR_LIT>\" + filePath ; ShellUtils . CommandResult commandResult = ShellUtils . execCommand ( command , isRoot ) ; return ( commandResult . successMsg != null && commandResult . successMsg . toLowerCase ( ) . contains ( \"<STR_LIT>\" ) ) ; } private static boolean installNormal ( Context context , String filePath ) { File file = FileUtils . getFileByPath ( filePath ) ; return FileUtils . isFileExists ( file ) && installNormal ( context , file ) ; } private static boolean installNormal ( Context context , File appFile ) { try { Intent intent = getInstallAppIntent ( appFile ) ; if ( context . getPackageManager ( ) . queryIntentActivities ( intent , <NUM_LIT> ) . size ( ) > <NUM_LIT> ) { if ( context instanceof Activity ) { ( ( Activity ) context ) . startActivityForResult ( intent , REQUEST_CODE_INSTALL_APP ) ; } else { context . startActivity ( intent ) ; } return true ; } } catch ( Exception e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , \"<STR_LIT>\" ) ; } return false ; } public static Intent getInstallAppIntent ( File appFile ) { try { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { intent . addFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_PERSISTABLE_URI_PERMISSION ) ; } Uri fileUri = FileUtils . getUriByFile ( appFile ) ; intent . setDataAndType ( fileUri , \"<STR_LIT>\" ) ; return intent ; } catch ( Exception e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , \"<STR_LIT>\" ) ; } return null ; } private static boolean isDeviceRooted ( ) { String su = \"<STR_LIT>\" ; String [ ] locations = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; for ( String location : locations ) { if ( new File ( location + su ) . exists ( ) ) { return true ; } } return false ; } private static boolean isSystemApplication ( Context context ) { return context != null && isSystemApplication ( context , context . getPackageName ( ) ) ; } private static boolean isSystemApplication ( Context context , String packageName ) { return context != null && isSystemApplication ( context . getPackageManager ( ) , packageName ) ; } private static boolean isSystemApplication ( PackageManager packageManager , String packageName ) { if ( packageManager == null || packageName == null || packageName . length ( ) == <NUM_LIT> ) { return false ; } try { ApplicationInfo app = packageManager . getApplicationInfo ( packageName , <NUM_LIT> ) ; return ( app != null && ( app . flags & ApplicationInfo . FLAG_SYSTEM ) > <NUM_LIT> ) ; } catch ( NameNotFoundException e ) { e . printStackTrace ( ) ; } return false ; } public static PackageInfo getInstalledApkPackageInfo ( Context context , String packageName ) { PackageManager pm = context . getPackageManager ( ) ; List < PackageInfo > apps = pm . getInstalledPackages ( PackageManager . GET_SIGNATURES ) ; Iterator < PackageInfo > it = apps . iterator ( ) ; while ( it . hasNext ( ) ) { PackageInfo packageinfo = it . next ( ) ; String thisName = packageinfo . packageName ; if ( thisName . equals ( packageName ) ) { return packageinfo ; } } return null ; } public static String getSourceApkPath ( Context context , String packageName ) { if ( TextUtils . isEmpty ( packageName ) ) return null ; try { ApplicationInfo appInfo = context . getPackageManager ( ) . getApplicationInfo ( packageName , <NUM_LIT> ) ; return appInfo . sourceDir ; } catch ( NameNotFoundException e ) { e . printStackTrace ( ) ; } return null ; }", "output": "}"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class ViewOnce extends Feature { private boolean isFromMe ; public ViewOnce ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var methods = Unobfuscator . loadViewOnceMethod ( classLoader ) ; var classViewOnce = Unobfuscator . loadViewOnceClass ( classLoader ) ; logDebug ( classViewOnce ) ; var viewOnceStoreMethod = Unobfuscator . loadViewOnceStoreMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewOnceStoreMethod ) ) ; XposedBridge . hookMethod ( viewOnceStoreMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; isFromMe = false ; var messageObject = param . args [ <NUM_LIT> ] ; if ( messageObject == null ) return ; isFromMe = new FMessageWpp ( messageObject ) . getKey ( ) . isFromMe ; } } ) ; for ( var method : methods ) { logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( ( int ) param . getResult ( ) != <NUM_LIT> && ( Unobfuscator . isCalledFromClass ( classViewOnce ) ) ) { param . setResult ( <NUM_LIT> ) ; } else if ( ( int ) param . getResult ( ) != <NUM_LIT> && ! isFromMe && ( Unobfuscator . isCalledFromClass ( viewOnceStoreMethod . getDeclaringClass ( ) ) ) ) {", "output": "param . setResult ( <NUM_LIT> ) ; } } } ) ; } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; public class HKDFv3 extends HKDF { @ Override protected int getIterationStartOffset ( ) { return <NUM_LIT> ; }", "output": "}"}, {"input": "package com . cgutman . adblib ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; public class AdbMessage { private ByteBuffer mMessageBuffer ; private byte [ ] payload ; private AdbMessage ( ) { } public AdbMessage ( int command , int arg0 , int arg1 , byte [ ] data ) { mMessageBuffer = ByteBuffer . allocate ( AdbProtocol . ADB_HEADER_LENGTH ) . order ( ByteOrder . LITTLE_ENDIAN ) ; mMessageBuffer . putInt ( <NUM_LIT> , command ) ; mMessageBuffer . putInt ( <NUM_LIT> , arg0 ) ; mMessageBuffer . putInt ( <NUM_LIT> , arg1 ) ; mMessageBuffer . putInt ( <NUM_LIT> , ( data == null ? <NUM_LIT> : data . length ) ) ; mMessageBuffer . putInt ( <NUM_LIT> , ( data == null ? <NUM_LIT> : checksum ( data ) ) ) ; mMessageBuffer . putInt ( <NUM_LIT> , command ^ <NUM_LIT> ) ; payload = data ; } public AdbMessage ( int command , int arg0 , int arg1 ) { this ( command , arg0 , arg1 , ( byte [ ] ) null ) ; } public static AdbMessage parseAdbMessage ( AdbChannel in ) throws IOException { AdbMessage msg = new AdbMessage ( ) ; ByteBuffer packet = ByteBuffer . allocate ( AdbProtocol . ADB_HEADER_LENGTH ) . order ( ByteOrder . LITTLE_ENDIAN ) ; in . readx ( packet . array ( ) , AdbProtocol . ADB_HEADER_LENGTH ) ; msg . mMessageBuffer = packet ; if ( msg . getPayloadLength ( ) != <NUM_LIT> ) { msg . setPayload ( new byte [ msg . getPayloadLength ( ) ] ) ; in . readx ( msg . getPayload ( ) , msg . getPayloadLength ( ) ) ; } return msg ; } public static int checksum ( byte [ ] payload ) { int checksum = <NUM_LIT> ; for ( byte b : payload ) { if ( b >= <NUM_LIT> ) checksum += b ; else checksum += b + <NUM_LIT> ; } return checksum ; } public int getCommand ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ; } public int getArg0 ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ;", "output": "} public int getArg1 ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ; } public int getPayloadLength ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ; } public int getChecksum ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ; } public int getMagic ( ) { return mMessageBuffer . getInt ( <NUM_LIT> ) ; } public byte [ ] getMessage ( ) { return mMessageBuffer . array ( ) ; } public byte [ ] getPayload ( ) { return payload ; } public void setPayload ( byte [ ] payload ) { this . payload = payload ; } }"}, {"input": "package org . akanework . gramophone . logic . ui ; import android . animation . TimeInterpolator ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Interpolator ; import android . view . animation . LinearInterpolator ; import android . view . animation . PathInterpolator ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class CustomSmoothScroller extends RecyclerView . SmoothScroller { public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; private final DisplayMetrics mDisplayMetrics ; protected LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected TimeInterpolator mDecelerateInterpolator = new PathInterpolator ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; @ SuppressLint ( \"<STR_LIT>\" ) public CustomSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , ( Interpolator ) mDecelerateInterpolator ) ; afterTargetFound ( ) ; } } protected void afterTargetFound ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ;", "output": "if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ; final int right = layoutManager . getDecoratedRight ( view ) + params . rightMargin ; final int start = layoutManager . getPaddingLeft ( ) ; final int end = layoutManager . getWidth ( ) - layoutManager . getPaddingRight ( ) ; return calculateDtToFit ( left , right , start , end , snapPreference ) ; } }"}, {"input": "package com . norman . webviewup . demo ; import android . app . Activity ; import android . os . Bundle ; import android . webkit . WebResourceRequest ; import android . webkit . WebSettings ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . TextView ; public class WebViewActivity extends Activity { private WebView mWebView ; private TextView userAgentTextView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_webview ) ; mWebView = findViewById ( R . id . webview ) ; userAgentTextView = findViewById ( R . id . userAgentTextView ) ; WebSettings webSettings = mWebView . getSettings ( ) ; userAgentTextView . setText ( webSettings . getUserAgentString ( ) ) ; webSettings . setJavaScriptEnabled ( true ) ; mWebView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , WebResourceRequest request ) { return false ; } }", "output": ") ; mWebView . loadUrl ( \"<STR_LIT>\" ) ; } @ Override public void onBackPressed ( ) { if ( mWebView . canGoBack ( ) ) { mWebView . goBack ( ) ; } else { super . onBackPressed ( ) ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Gravity ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . text . SimpleDateFormat ; import java . util . Arrays ; import java . util . Date ; import java . util . Locale ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CustomToolbar extends Feature { private String mDateExpiration ; public CustomToolbar ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var showName = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var showBio = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var typeArchive = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var methodHook = new MethodHook ( showName , showBio , typeArchive ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Bundle . class , methodHook ) ; expirationAboutInfo ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } public void expirationAboutInfo ( ) throws Exception { var expirationClass = Unobfuscator . loadExpirationClass ( classLoader ) ; XposedBridge . hookAllConstructors ( expirationClass , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var method = ReflectionUtils . findMethodUsingFilter ( param . thisObject . getClass ( ) , m -> m . getReturnType ( ) . equals ( Date . class ) ) ; var date = ( Date ) method . invoke ( param . thisObject ) ; mDateExpiration = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) . format ( Objects . requireNonNull ( date ) ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , classLoader . loadClass ( \"<STR_LIT>\" ) , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var viewRoot = activity . getWindow ( ) . getDecorView ( ) ; var version = ( TextView ) viewRoot . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( version != null ) { version . setText ( version . getText ( ) + \"<STR_LIT>\" + activity . getString ( ResId . string . expiration , mDateExpiration ) ) ; } } } ) ; } public static class MethodHook extends XC_MethodHook { private final boolean showName ; private final boolean showBio ; private final String typeArchive ; public MethodHook ( boolean showName , boolean showBio , String typeArchive ) { this . showName = showName ; this . showBio = showBio ; this . typeArchive = typeArchive ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var homeActivity = ( Activity ) param . thisObject ; var actionbar = XposedHelpers . callMethod ( homeActivity , \"<STR_LIT>\" ) ; var toolbar = homeActivity . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var logo = toolbar . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var name = WppCore . getMyName ( ) ; var bio = WppCore . getMyBio ( ) ; if ( typeArchive . equals ( \"<STR_LIT>\" ) ) { var ref = new Object ( ) { int clickCount = <NUM_LIT> ; long lastClickTime = <NUM_LIT> ; } ; toolbar . setOnClickListener ( v -> { long currentTime = System . currentTimeMillis ( ) ; if ( currentTime - ref . lastClickTime < <NUM_LIT> ) { ref . clickCount ++ ; } else { ref . clickCount = <NUM_LIT> ; }", "output": "ref . lastClickTime = currentTime ; if ( ref . clickCount == <NUM_LIT> ) { ref . clickCount = <NUM_LIT> ; Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , \"<STR_LIT>\" ) ; homeActivity . startActivity ( intent ) ; } } ) ; } else if ( typeArchive . equals ( \"<STR_LIT>\" ) ) { toolbar . setOnLongClickListener ( v -> { Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , \"<STR_LIT>\" ) ; homeActivity . startActivity ( intent ) ; return true ; } ) ; } if ( ! showBio && ! showName ) return ; if ( ! ( logo . getParent ( ) instanceof LinearLayout parent ) ) { var methods = Arrays . stream ( actionbar . getClass ( ) . getDeclaredMethods ( ) ) . filter ( m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] == CharSequence . class ) . toArray ( Method [ ] :: new ) ; if ( showName ) { methods [ <NUM_LIT> ] . invoke ( actionbar , name ) ; } if ( showBio ) { methods [ <NUM_LIT> ] . invoke ( actionbar , bio ) ; } XposedBridge . hookMethod ( methods [ <NUM_LIT> ] , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( showName ) { param . args [ <NUM_LIT> ] = name ; } } } ) ; return ; } var mTitle = new TextView ( homeActivity ) ; mTitle . setText ( showName ? name : \"<STR_LIT>\" ) ; mTitle . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; mTitle . setTextSize ( <NUM_LIT> ) ; mTitle . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; parent . addView ( mTitle ) ; if ( showBio ) { TextView mSubtitle = new TextView ( homeActivity ) ; mSubtitle . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; mSubtitle . setText ( bio ) ; mSubtitle . setTextSize ( <NUM_LIT> ) ; mSubtitle . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; mSubtitle . setMarqueeRepeatLimit ( - <NUM_LIT> ) ; mSubtitle . setEllipsize ( TextUtils . TruncateAt . MARQUEE ) ; mSubtitle . setSingleLine ( ) ; mSubtitle . setSelected ( true ) ; parent . addView ( mSubtitle ) ; } else { mTitle . setGravity ( Gravity . CENTER ) ; } parent . removeView ( logo ) ; } } }"}, {"input": "package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; public class UpgradePackageSource extends UpgradeSource { private final String packageName ; private PackageInfo packageInfo ; public UpgradePackageSource ( Context context , String packageName ) { super ( context ) ; this . packageName = packageName ; } public synchronized PackageInfo getPackageInfo ( ) { return packageInfo ; } public String getPackageName ( ) { return packageName ; } @ Override protected void onPrepare ( Object params ) { try { int flags = params instanceof Integer ? ( int ) params : <NUM_LIT> ; packageInfo = getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , flags ) ; if ( packageInfo == null ) { throw new PackageManager . NameNotFoundException ( \"<STR_LIT>\" + packageName + \"<STR_LIT>\" ) ; } process ( <NUM_LIT> ) ; success ( ) ; } catch ( PackageManager . NameNotFoundException e ) { error ( e ) ; } }", "output": "}"}, {"input": "package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import com . baidu . aip . asrwakeup3 . core . R ; import com . baidu . aip . asrwakeup3 . core . util . AuthUtil ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . Map ; public class ActivityMiniUnit extends AppCompatActivity implements EventListener { protected TextView txtLog ; protected TextView txtResult ; protected Button btn ; protected Button stopBtn ; private static String DESC_TEXT = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private EventManager asr ; private boolean logTime = true ; protected boolean enableOffline = false ; private String BOT_ID = \"<STR_LIT>\" ; private void start ( ) { txtLog . setText ( \"<STR_LIT>\" ) ; Map < String , Object > params = AuthUtil . getParam ( ) ; String event = null ; event = SpeechConstant . ASR_START ; if ( enableOffline ) { params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; } params . put ( SpeechConstant . ACCEPT_AUDIO_VOLUME , false ) ; params . put ( SpeechConstant . PID , <NUM_LIT> ) ; params . put ( SpeechConstant . BOT_SESSION_LIST , unitParams ( ) ) ; ( new AutoCheck ( getApplicationContext ( ) , new Handler ( ) { public void handleMessage ( Message msg ) { if ( msg . what == <NUM_LIT> ) { AutoCheck autoCheck = ( AutoCheck ) msg . obj ; synchronized ( autoCheck ) { String message = autoCheck . obtainErrorMessage ( ) ; txtLog . append ( message + \"<STR_LIT>\" ) ; ; } } } } , enableOffline ) ) . checkAsr ( params ) ; String json = null ; json = new JSONObject ( params ) . toString ( ) ; asr . send ( event , json , null , <NUM_LIT> , <NUM_LIT> ) ; printLog ( \"<STR_LIT>\" + json ) ; } private void stop ( ) { printLog ( \"<STR_LIT>\" ) ; asr . send ( SpeechConstant . ASR_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } private void loadOfflineEngine ( ) { Map < String , Object > params = new LinkedHashMap < String , Object > ( ) ; params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; params . put ( SpeechConstant . ASR_OFFLINE_ENGINE_GRAMMER_FILE_PATH , \"<STR_LIT>\" ) ; asr . send ( SpeechConstant . ASR_KWS_LOAD_ENGINE , new JSONObject ( params ) . toString ( ) , null , <NUM_LIT> , <NUM_LIT> ) ; } private void unloadOfflineEngine ( ) { asr . send ( SpeechConstant . ASR_KWS_UNLOAD_ENGINE , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . common_mini ) ; initView ( ) ; initPermission ( ) ; asr = EventManagerFactory . create ( this , \"<STR_LIT>\" ) ; asr . registerListener ( this ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { start ( ) ; } } ) ; stopBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { stop ( ) ; } } ) ; if ( enableOffline ) { loadOfflineEngine ( ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; if ( enableOffline ) { unloadOfflineEngine ( ) ; } asr . unregisterListener ( this ) ; } private JSONArray unitParams ( ) { JSONArray json = new JSONArray ( ) ; try { JSONObject bot = new JSONObject ( ) ; bot . put ( \"<STR_LIT>\" , BOT_ID ) ; bot . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bot . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; json . put ( bot ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return json ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String logTxt = \"<STR_LIT>\" + name ; if ( params != null && ! params . isEmpty ( ) ) { logTxt += \"<STR_LIT>\" + params ; } if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { if ( params != null && params . contains ( \"<STR_LIT>\" ) ) { if ( length > <NUM_LIT> && data . length > <NUM_LIT> ) { logTxt += \"<STR_LIT>\" + new String ( data , offset , length ) ; } } } else if ( data != null ) { logTxt += \"<STR_LIT>\" + data . length ; } printLog ( logTxt ) ; } private void printLog ( String text ) { if ( logTime ) { text += \"<STR_LIT>\" + System . currentTimeMillis ( ) ; } text += \"<STR_LIT>\" ; Log . i ( getClass ( ) . getName ( ) , text ) ; txtLog . append ( text + \"<STR_LIT>\" ) ; } private void initView ( ) { txtResult = ( TextView ) findViewById ( R . id . txtResult ) ; txtLog = ( TextView ) findViewById ( R . id . txtLog ) ; btn = ( Button ) findViewById ( R . id . btn ) ; stopBtn = ( Button ) findViewById ( R . id . btn_stop ) ; txtLog . setText ( DESC_TEXT + \"<STR_LIT>\" ) ; } private void initPermission ( ) { String permissions [ ] = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String tmpList [ ] = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; }", "output": "} @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . content . ComponentName ; import android . content . Context ; import android . content . ServiceConnection ; import android . os . IBinder ; import java . io . File ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import rikka . shizuku . Shizuku ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class Utils { private static Shizuku . UserServiceArgs args ; public static synchronized Shizuku . UserServiceArgs getUserServiceArgs ( Context context ) { if ( args == null ) { args = new Shizuku . UserServiceArgs ( new ComponentName ( context , TransferServiceBinder . class ) ) . daemon ( false ) . processNameSuffix ( \"<STR_LIT>\" ) . debuggable ( true ) . version ( <NUM_LIT> ) ; } return args ; } public static void sortFiles ( List < ParcelableRemoteFile > fileList ) { fileList . sort ( ( f1 , f2 ) -> { if ( f1 . isDirectory ( ) && ! f2 . isDirectory ( ) ) { return - <NUM_LIT> ; } else if ( ! f1 . isDirectory ( ) && f2 . isDirectory ( ) ) { return <NUM_LIT> ; } else { return f1 . getName ( ) . compareTo ( f2 . getName ( ) ) ; } } ) ; } public static String getParentByPath ( String path ) { if ( ! path . endsWith ( String . valueOf ( File . separatorChar ) ) ) { path += File . separatorChar ; } int lastIndex = path . lastIndexOf ( File . separatorChar ) ; if ( lastIndex != - <NUM_LIT> ) { int secondLastIndex = path . lastIndexOf ( File . separatorChar , lastIndex - <NUM_LIT> ) ; if ( secondLastIndex != - <NUM_LIT> ) { return path . substring ( <NUM_LIT> , secondLastIndex ) + File . separatorChar ; } else if ( lastIndex != <NUM_LIT> ) { return File . separator ; } } return null ; } public static String formatSpeed ( long bytesPerSecond ) { if ( bytesPerSecond < <NUM_LIT> ) {", "output": "return bytesPerSecond + \"<STR_LIT>\" ; } if ( bytesPerSecond < <NUM_LIT> * <NUM_LIT> ) { return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , bytesPerSecond / <NUM_LIT> ) ; } return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , bytesPerSecond / ( <NUM_LIT> * <NUM_LIT> ) ) ; } public static String formatDateTime ( long milliseconds ) { return new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) . format ( new Date ( milliseconds ) ) ; } public static String formatFileSize ( long size ) { if ( size < <NUM_LIT> ) { return size + \"<STR_LIT>\" ; } if ( size < <NUM_LIT> * <NUM_LIT> ) { return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , size / <NUM_LIT> ) ; } if ( size < <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , size / ( <NUM_LIT> * <NUM_LIT> ) ) ; } return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , size / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; public class ControllerIdentifiers { public static final short SHUTDOWN = <NUM_LIT> ; public static final short GET_WLAN_ADDRESS = <NUM_LIT> ; public static final short LIST_FILES = <NUM_LIT> ; public static final short TRANSPORT_FILES = <NUM_LIT> ;", "output": "}"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Intent ; public class ShareUtils { private final static String SHARE_BASE_URL = \"<STR_LIT>\" ; public static Intent getShareIntent ( String content ) { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_SEND ) ; intent . putExtra ( Intent . EXTRA_TEXT , content ) ; intent . setType ( \"<STR_LIT>\" ) ; return Intent . createChooser ( intent , null ) ; } public static Intent getShareIntent ( int id ) { return getShareIntent ( SHARE_BASE_URL + id ) ; } public static Intent getShareIntentWithTitle ( String title , String url ) { return getShareIntent ( title + \"<STR_LIT>\" + url ) ; }", "output": "public static Intent getShareIntentWithTitle ( String title , int id ) { return getShareIntent ( title + \"<STR_LIT>\" + SHARE_BASE_URL + id ) ; } }"}, {"input": "package in . hridayan . ashell . utils ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . hardware . usb . UsbDevice ; import android . hardware . usb . UsbManager ; import android . os . Handler ; import android . util . Base64 ; import android . util . Log ; import android . widget . Toast ; import com . cgutman . adblib . AdbBase64 ; import com . cgutman . adblib . AdbConnection ; import com . cgutman . adblib . AdbStream ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . utils . OtgUtils . ByteUtils ; import in . hridayan . ashell . utils . OtgUtils . Const ; import in . hridayan . ashell . utils . OtgUtils . MessageOtg ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . concurrent . atomic . AtomicBoolean ; public class OtgUtils { public static class MessageOtg { public static final int DEVICE_NOT_FOUND = <NUM_LIT> ; public static final int CONNECTING = <NUM_LIT> ; public static final int DEVICE_FOUND = <NUM_LIT> ; public static final int FLASHING = <NUM_LIT> ; public static final int INSTALLING_PROGRESS = <NUM_LIT> ; public static final int PUSH_PART = <NUM_LIT> ; public static final int PM_INST_PART = <NUM_LIT> ; public static final String USB_PERMISSION = \"<STR_LIT>\" ; } public static class ByteUtils { public static byte [ ] concat ( byte [ ] ... arrays ) { int totalLength = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < arrays . length ; i ++ ) { totalLength += arrays [ i ] . length ; }", "output": "byte [ ] result = new byte [ totalLength ] ; int currentIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < arrays . length ; i ++ ) { System . arraycopy ( arrays [ i ] , <NUM_LIT> , result , currentIndex , arrays [ i ] . length ) ; currentIndex += arrays [ i ] . length ; } return result ; } public static final byte [ ] intToByteArray ( int value ) { return ByteBuffer . allocate ( <NUM_LIT> ) . order ( ByteOrder . LITTLE_ENDIAN ) . putInt ( value ) . array ( ) ; } } public static class UsbReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; UsbDevice device = intent . getParcelableExtra ( UsbManager . EXTRA_DEVICE ) ; if ( device == null ) return ; String manufacturer = device . getManufacturerName ( ) ; String product = device . getProductName ( ) ; if ( UsbManager . ACTION_USB_DEVICE_ATTACHED . equals ( action ) ) { showToast ( context , \"<STR_LIT>\" + manufacturer + \"<STR_LIT>\" + product ) ; } else if ( UsbManager . ACTION_USB_DEVICE_DETACHED . equals ( action ) ) { showToast ( context , \"<STR_LIT>\" + manufacturer + \"<STR_LIT>\" + product ) ; sendIntentUponDetached ( context ) ; } } private void showToast ( Context context , String message ) { Toast . makeText ( context , message , Toast . LENGTH_SHORT ) . show ( ) ; } private void sendIntentUponDetached ( Context context ) { Intent intent = new Intent ( context , MainActivity . class ) ; intent . setAction ( \"<STR_LIT>\" ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; context . startActivity ( intent ) ; } } public static class Push { private AdbConnection adbConnection ; private File local ; private String remotePath ; public Push ( AdbConnection adbConnection , File local , String remotePath ) { this . adbConnection = adbConnection ; this . local = local ; this . remotePath = remotePath ; } public void execute ( Handler handler ) throws InterruptedException , IOException { AdbStream stream = adbConnection . open ( \"<STR_LIT>\" ) ; String sendId = \"<STR_LIT>\" ; String mode = \"<STR_LIT>\" ; int length = ( remotePath + mode ) . length ( ) ; stream . write ( ByteUtils . concat ( sendId . getBytes ( ) , ByteUtils . intToByteArray ( length ) ) ) ; stream . write ( remotePath . getBytes ( ) ) ; stream . write ( mode . getBytes ( ) ) ; byte [ ] buff = new byte [ adbConnection . getMaxData ( ) ] ; InputStream is = new FileInputStream ( local ) ; long sent = <NUM_LIT> ; long total = local . length ( ) ; int lastProgress = <NUM_LIT> ; while ( true ) { int read = is . read ( buff ) ; if ( read < <NUM_LIT> ) { break ; } stream . write ( ByteUtils . concat ( \"<STR_LIT>\" . getBytes ( ) , ByteUtils . intToByteArray ( read ) ) ) ; if ( read == buff . length ) { stream . write ( buff ) ; } else { byte [ ] tmp = new byte [ read ] ; System . arraycopy ( buff , <NUM_LIT> , tmp , <NUM_LIT> , read ) ; stream . write ( tmp ) ; } sent += read ; final int progress = ( int ) ( sent * <NUM_LIT> / total ) ; if ( lastProgress != progress ) { handler . sendMessage ( handler . obtainMessage ( MessageOtg . INSTALLING_PROGRESS , MessageOtg . PUSH_PART , progress ) ) ; lastProgress = progress ; } } stream . write ( ByteUtils . concat ( \"<STR_LIT>\" . getBytes ( ) , ByteUtils . intToByteArray ( ( int ) System . currentTimeMillis ( ) ) ) ) ; byte [ ] res = stream . read ( ) ; Log . d ( Const . TAG , new String ( res ) ) ; stream . write ( ByteUtils . concat ( \"<STR_LIT>\" . getBytes ( ) , ByteUtils . intToByteArray ( <NUM_LIT> ) ) ) ; } } public static class Const { public static final String TAG = \"<STR_LIT>\" ; public static final double PUSH_PERCENT = <NUM_LIT> ; } public static class ExternalCmdStore { private static SharedPreferences sharedPreferences ; private static String CMD_KEY = \"<STR_LIT>\" ; private static void initShared ( Context context ) { if ( sharedPreferences == null ) sharedPreferences = context . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; } public static void put ( Context context , String cmd ) { initShared ( context ) ; sharedPreferences . edit ( ) . putString ( CMD_KEY , cmd ) . apply ( ) ; } public static String get ( Context context ) { initShared ( context ) ; return sharedPreferences . getString ( CMD_KEY , null ) ; } } public static class Install { private AdbConnection adbConnection ; private String remotePath ; private long installTimeAssumption = <NUM_LIT> ; public Install ( AdbConnection adbConnection , String remotePath , long installTimeAssumption ) { this . adbConnection = adbConnection ; this . remotePath = remotePath ; this . installTimeAssumption = installTimeAssumption ; } public void execute ( final Handler handler ) throws IOException , InterruptedException { final AtomicBoolean done = new AtomicBoolean ( false ) ; try { AdbStream stream = adbConnection . open ( \"<STR_LIT>\" + remotePath ) ; new Thread ( ) { @ Override public void run ( ) { int percent = <NUM_LIT> ; while ( ! done . get ( ) ) { handler . sendMessage ( handler . obtainMessage ( MessageOtg . INSTALLING_PROGRESS , MessageOtg . PM_INST_PART , percent ) ) ; if ( percent < <NUM_LIT> ) { percent += <NUM_LIT> ; try { Thread . sleep ( installTimeAssumption / <NUM_LIT> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } } . start ( ) ; while ( ! stream . isClosed ( ) ) { try { Log . d ( Const . TAG , new String ( stream . read ( ) ) ) ; } catch ( IOException e ) { break ; } } } finally { done . set ( true ) ; handler . sendMessage ( handler . obtainMessage ( MessageOtg . INSTALLING_PROGRESS , MessageOtg . PM_INST_PART , <NUM_LIT> ) ) ; } } } public static class MyAdbBase64 implements AdbBase64 { @ Override public String encodeToString ( byte [ ] data ) { return Base64 . encodeToString ( data , Base64 . NO_WRAP ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; public class RecogResult { private static final int ERROR_NONE = <NUM_LIT> ; private String origalJson ; private String [ ] resultsRecognition ; private String origalResult ; private String sn ; private String desc ; private String resultType ; private int error = - <NUM_LIT> ; private int subError = - <NUM_LIT> ; public static RecogResult parseJson ( String jsonStr ) { RecogResult result = new RecogResult ( ) ; result . setOrigalJson ( jsonStr ) ; try { JSONObject json = new JSONObject ( jsonStr ) ; int error = json . optInt ( \"<STR_LIT>\" ) ; int subError = json . optInt ( \"<STR_LIT>\" ) ; result . setError ( error ) ; result . setDesc ( json . optString ( \"<STR_LIT>\" ) ) ; result . setResultType ( json . optString ( \"<STR_LIT>\" ) ) ; result . setSubError ( subError ) ; if ( error == ERROR_NONE ) { result . setOrigalResult ( json . getString ( \"<STR_LIT>\" ) ) ; JSONArray arr = json . optJSONArray ( \"<STR_LIT>\" ) ; if ( arr != null ) { int size = arr . length ( ) ; String [ ] recogs = new String [ size ] ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { recogs [ i ] = arr . getString ( i ) ; } result . setResultsRecognition ( recogs ) ; } } } catch ( JSONException e ) { e . printStackTrace ( ) ; } return result ; } public boolean hasError ( ) { return error != ERROR_NONE ; } public boolean isFinalResult ( ) { return \"<STR_LIT>\" . equals ( resultType ) ; } public boolean isPartialResult ( ) { return \"<STR_LIT>\" . equals ( resultType ) ; } public boolean isNluResult ( ) { return \"<STR_LIT>\" . equals ( resultType ) ; } public String getOrigalJson ( ) { return origalJson ; } public void setOrigalJson ( String origalJson ) { this . origalJson = origalJson ; } public String [ ] getResultsRecognition ( ) { return resultsRecognition ; } public void setResultsRecognition ( String [ ] resultsRecognition ) { this . resultsRecognition = resultsRecognition ; }", "output": "public String getSn ( ) { return sn ; } public void setSn ( String sn ) { this . sn = sn ; } public int getError ( ) { return error ; } public void setError ( int error ) { this . error = error ; } public String getDesc ( ) { return desc ; } public void setDesc ( String desc ) { this . desc = desc ; } public String getOrigalResult ( ) { return origalResult ; } public void setOrigalResult ( String origalResult ) { this . origalResult = origalResult ; } public String getResultType ( ) { return resultType ; } public void setResultType ( String resultType ) { this . resultType = resultType ; } public int getSubError ( ) { return subError ; } public void setSubError ( int subError ) { this . subError = subError ; } }"}]