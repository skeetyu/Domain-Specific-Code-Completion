[{"input": "public class A { public void onCreate ( ) { StrictMode . setThreadPolicy ( new StrictMode . ThreadPolicy . Builder ( ) . detectDiskReads ( ) . detectDiskWrites ( ) . detectNetwork ( ) . penaltyLog ( ) . build ( ) ) ;", "output": "StrictMode . setVmPolicy ( new StrictMode . VmPolicy . Builder ( ) . detectLeakedSqlLiteObjects ( ) . detectLeakedClosableObjects ( ) . penaltyLog ( ) . penaltyDeath ( ) . build ( ) ) ; super . onCreate ( ) ; } }"}, {"input": "package com . reactnative . nestedscroll ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class NestedScrollViewPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ;", "output": "} @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new NestedScrollViewHeaderManager ( ) , new NestedScrollViewManager ( ) ) ; } }"}, {"input": "package android . content . res ; public class XResForwarder { private final Resources res ; private final int id ; public XResForwarder ( Resources res , int id ) { this . res = res ; this . id = id ; } public Resources getResources ( ) { return res ; }", "output": "public int getId ( ) { return id ; } }"}, {"input": "package com . google . android . material . slider ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . util . AttributeSet ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . slider . OverlaySlider . OnChangeListener ; import com . google . android . material . slider . OverlaySlider . OnSliderTouchListener ; @ SuppressLint ( \"<STR_LIT>\" ) public class OverlaySlider extends BaseOverlaySlider < OverlaySlider , OnChangeListener , OnSliderTouchListener > { public OverlaySlider ( @ NonNull Context context ) { this ( context , null ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , R . attr . sliderStyle ) ; } public OverlaySlider ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; TypedArray a = context . obtainStyledAttributes ( attrs , new int [ ] { android . R . attr . value } ) ; if ( a . hasValue ( <NUM_LIT> ) ) { setValue ( a . getFloat ( <NUM_LIT> , <NUM_LIT> ) ) ; } a . recycle ( ) ; } public float getValue ( ) { return getValues ( ) . get ( <NUM_LIT> ) ;", "output": "} public void setValue ( float value ) { setValues ( value ) ; } @ Override public void setCustomThumbDrawable ( @ DrawableRes int drawableResId ) { super . setCustomThumbDrawable ( drawableResId ) ; } @ Override public void setCustomThumbDrawable ( @ NonNull Drawable drawable ) { super . setCustomThumbDrawable ( drawable ) ; } @ Override protected boolean pickActiveThumb ( ) { if ( getActiveThumbIndex ( ) != - <NUM_LIT> ) { return true ; } setActiveThumbIndex ( <NUM_LIT> ) ; return true ; } public interface OnChangeListener extends BaseOnChangeListener < OverlaySlider > { @ Override void onValueChange ( @ NonNull OverlaySlider slider , float value , boolean fromUser ) ; } public interface OnSliderTouchListener extends BaseOnSliderTouchListener < OverlaySlider > { @ Override void onStartTrackingTouch ( @ NonNull OverlaySlider slider ) ; @ Override void onStopTrackingTouch ( @ NonNull OverlaySlider slider ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class WaCallback implements Application . ActivityLifecycleCallbacks { @ Override public void onActivityCreated ( @ NonNull Activity activity , @ Nullable Bundle bundle ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; } @ Override public void onActivityStarted ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . START ) ; WppCore . activities . add ( activity ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onActivityResumed ( @ NonNull Activity activity ) { WppCore . mCurrentActivity = activity ; WppCore . activities . add ( activity ) ; if ( WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) ) { WppCore . setPrivBoolean ( \"<STR_LIT>\" , false ) ; try { new AlertDialogWpp ( activity ) . setMessage ( activity . getString ( ResId . string . restart_wpp ) ) . setPositiveButton ( activity . getString ( ResId . string . yes ) , ( dialog , which ) -> { if ( ! Utils . doRestart ( activity ) ) Toast . makeText ( activity , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ;", "output": "} ) . setNegativeButton ( activity . getString ( ResId . string . no ) , null ) . show ( ) ; } catch ( Exception ignored ) { } } triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . RESUME ) ; } @ Override public void onActivityPaused ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . PAUSE ) ; } @ Override public void onActivityStopped ( @ NonNull Activity activity ) { triggerActivityState ( activity , WppCore . ActivityChangeState . ChangeType . END ) ; WppCore . activities . remove ( activity ) ; } private static void triggerActivityState ( @ NonNull Activity activity , WppCore . ActivityChangeState . ChangeType type ) { for ( WppCore . ActivityChangeState listener : WppCore . listenerChat ) { listener . onChange ( activity , type ) ; } } @ Override public void onActivitySaveInstanceState ( @ NonNull Activity activity , @ NonNull Bundle bundle ) { } @ Override public void onActivityDestroyed ( @ NonNull Activity activity ) { WppCore . activities . remove ( activity ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface StartScanResultCallback { void success ( ) ; void error ( Exception exception ) ;", "output": "}"}, {"input": "package external . org . apache . commons . lang3 ; public class CharSequenceUtils { public CharSequenceUtils ( ) { super ( ) ; } public static CharSequence subSequence ( CharSequence cs , int start ) { return cs == null ? null : cs . subSequence ( start , cs . length ( ) ) ; } static int indexOf ( CharSequence cs , int searchChar , int start ) { if ( cs instanceof String ) { return ( ( String ) cs ) . indexOf ( searchChar , start ) ; } else { int sz = cs . length ( ) ; if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } for ( int i = start ; i < sz ; i ++ ) { if ( cs . charAt ( i ) == searchChar ) { return i ; } } return - <NUM_LIT> ; } } static int indexOf ( CharSequence cs , CharSequence searchChar , int start ) { return cs . toString ( ) . indexOf ( searchChar . toString ( ) , start ) ; } static int lastIndexOf ( CharSequence cs , int searchChar , int start ) { if ( cs instanceof String ) {", "output": "return ( ( String ) cs ) . lastIndexOf ( searchChar , start ) ; } else { int sz = cs . length ( ) ; if ( start < <NUM_LIT> ) { return - <NUM_LIT> ; } if ( start >= sz ) { start = sz - <NUM_LIT> ; } for ( int i = start ; i >= <NUM_LIT> ; -- i ) { if ( cs . charAt ( i ) == searchChar ) { return i ; } } return - <NUM_LIT> ; } } static int lastIndexOf ( CharSequence cs , CharSequence searchChar , int start ) { return cs . toString ( ) . lastIndexOf ( searchChar . toString ( ) , start ) ; } static char [ ] toCharArray ( CharSequence cs ) { if ( cs instanceof String ) { return ( ( String ) cs ) . toCharArray ( ) ; } else { int sz = cs . length ( ) ; char [ ] array = new char [ cs . length ( ) ] ; for ( int i = <NUM_LIT> ; i < sz ; i ++ ) { array [ i ] = cs . charAt ( i ) ; } return array ; } } static boolean regionMatches ( CharSequence cs , boolean ignoreCase , int thisStart , CharSequence substring , int start , int length ) { if ( cs instanceof String && substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , thisStart , ( String ) substring , start , length ) ; } else { return cs . toString ( ) . regionMatches ( ignoreCase , thisStart , substring . toString ( ) , start , length ) ; } } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import android . os . IBinder ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; import java . util . Map ; @ ClassName ( value = \"<STR_LIT>\" ) public interface IServiceManager { @ Method ( value = \"<STR_LIT>\" , type = Method . STATIC ) IBinder getService ( String name ) ; @ Field ( value = \"<STR_LIT>\" , type = Field . STATIC ) Map < String , IBinder > getServiceCache ( ) ;", "output": "}"}, {"input": "package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . content . Context ; import java . io . IOException ; import java . io . InputStream ; import java . io . PipedInputStream ; import java . io . PipedOutputStream ; public class InPipedStream { private PipedInputStream pipedInputStream ; private PipedOutputStream pipedOutputStream ; private Context context ; private InPipedStream ( Context context ) { pipedInputStream = new PipedInputStream ( ) ; pipedOutputStream = new PipedOutputStream ( ) ; this . context = context ; } private void start ( ) throws IOException { pipedInputStream . connect ( pipedOutputStream ) ; Runnable run = new Runnable ( ) { @ Override public void run ( ) { try { final InputStream is = context . getAssets ( ) . open ( \"<STR_LIT>\" ) ; int bytePerMs = <NUM_LIT> * <NUM_LIT> / <NUM_LIT> ; int count = bytePerMs * <NUM_LIT> ; int r = <NUM_LIT> ; byte [ ] buffer = new byte [ count ] ; do { r = is . read ( buffer ) ; int sleepTime = <NUM_LIT> ; if ( r > <NUM_LIT> ) { pipedOutputStream . write ( buffer , <NUM_LIT> , count ) ;", "output": "sleepTime = r / bytePerMs ; } else if ( r == <NUM_LIT> ) { sleepTime = <NUM_LIT> ; } if ( sleepTime > <NUM_LIT> ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } while ( r >= <NUM_LIT> ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } } ; ( new Thread ( run ) ) . start ( ) ; } public static PipedInputStream createAndStart ( Context context ) { InPipedStream obj = new InPipedStream ( context ) ; try { obj . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } return obj . pipedInputStream ; } }"}, {"input": "package xposed . dummy ; import android . content . res . Resources ; import android . content . res . TypedArray ; public class XTypedArraySuperClass extends TypedArray { protected XTypedArraySuperClass ( Resources resources , int [ ] data , int [ ] indices , int len ) { super ( null , null , null , <NUM_LIT> ) ; throw new UnsupportedOperationException ( ) ; }", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import android . Manifest ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Service ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . content . pm . PackageManager ; import android . hardware . input . InputManager ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Environment ; import android . os . IBinder ; import android . os . RemoteException ; import android . provider . Settings ; import android . view . Menu ; import android . view . MenuItem ; import android . view . MotionEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Spinner ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Locale ; import java . util . Objects ; import java . util . Set ; import rikka . shizuku . Shizuku ; import rikka . sui . Sui ; import top . weixiansen574 . hybridfilexfer . droidcore . Error ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class MainActivity extends AppCompatActivity implements View . OnClickListener , ServiceConnection { private Context context ; private Button btn_start_server ; private Button btn_to_transfer ; private Spinner spinner ; private TextView usb_state , wifi_state ; private boolean isRoot ; private ConnectThread connectThread ; private ITransferService iTransferService ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; context = this ; usb_state = findViewById ( R . id . usb_state ) ; wifi_state = findViewById ( R . id . wifi_state ) ; spinner = findViewById ( R . id . spinner_mode ) ; btn_start_server = findViewById ( R . id . start_server ) ; btn_to_transfer = findViewById ( R . id . to_transfer ) ; spinner = findViewById ( R . id . spinner_mode ) ; btn_start_server . setOnClickListener ( this ) ; btn_to_transfer . setOnClickListener ( this ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public void onClick ( View v ) { int id = v . getId ( ) ; if ( id == R . id . start_server ) { System . out . println ( spinner . getSelectedItemPosition ( ) ) ; if ( ! checkPermissionOrRequest ( ) ) {", "output": "Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; return ; } if ( iTransferService == null ) { startServer ( ) ; } else { stopServerAndDisconnectService ( ) ; } } else if ( id == R . id . to_transfer ) { Intent intent = new Intent ( context , TransferActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , isRoot ) ; startActivity ( intent ) ; } } @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { ITransferService iTransferService = ITransferService . Stub . asInterface ( service ) ; System . out . println ( \"<STR_LIT>\" + service + \"<STR_LIT>\" + iTransferService ) ; if ( this . iTransferService == null ) { this . iTransferService = iTransferService ; onConnectedService ( iTransferService ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; } } @ Override public void onServiceDisconnected ( ComponentName name ) { System . out . println ( name + \"<STR_LIT>\" ) ; } private void startServer ( ) { if ( spinner . getSelectedItemPosition ( ) == <NUM_LIT> ) { System . out . println ( \"<STR_LIT>\" ) ; if ( ! Sui . init ( getPackageName ( ) ) ) { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; return ; } else { if ( Shizuku . checkSelfPermission ( ) != <NUM_LIT> ) { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; Shizuku . requestPermission ( <NUM_LIT> ) ; return ; } } isRoot = true ; } else { System . out . println ( \"<STR_LIT>\" ) ; isRoot = false ; } btn_start_server . setEnabled ( false ) ; bindService ( ) ; } private void bindService ( ) { if ( isRoot ) { Shizuku . bindUserService ( Utils . getUserServiceArgs ( context ) , this ) ; } else { Intent intent = new Intent ( context , TransferServices . class ) ; bindService ( intent , this , Service . BIND_AUTO_CREATE ) ; } } private void unbindService ( ) { if ( isRoot ) { Shizuku . unbindUserService ( Utils . getUserServiceArgs ( context ) , this , true ) ; } else { unbindService ( this ) ; } } private void onConnectedService ( ITransferService service ) { btn_start_server . setEnabled ( true ) ; usb_state . setText ( \"<STR_LIT>\" ) ; wifi_state . setText ( \"<STR_LIT>\" ) ; btn_start_server . setText ( \"<STR_LIT>\" ) ; connectThread = new ConnectThread ( this , service ) ; connectThread . start ( ) ; } public void stopServerAndDisconnectService ( ) { btn_start_server . setEnabled ( false ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { System . out . println ( \"<STR_LIT>\" ) ; iTransferService . stopServer ( ) ; System . out . println ( \"<STR_LIT>\" ) ; if ( connectThread != null ) { connectThread . shutdown ( ) ; try { connectThread . join ( ) ; } catch ( InterruptedException ignored ) { } } runOnUiThread ( ( ) -> { unbindService ( ) ; onServerStopped ( ) ; } ) ; } catch ( RemoteException e ) { runOnUiThread ( ( ) -> { unbindService ( ) ; onServerStopped ( ) ; } ) ; } } } ) . start ( ) ; } private void onServerStopped ( ) { iTransferService = null ; usb_state . setText ( \"<STR_LIT>\" ) ; wifi_state . setText ( \"<STR_LIT>\" ) ; btn_start_server . setText ( \"<STR_LIT>\" ) ; btn_start_server . setEnabled ( true ) ; btn_to_transfer . setEnabled ( false ) ; } private void onServerStarted ( ) { usb_state . setText ( \"<STR_LIT>\" ) ; wifi_state . setText ( \"<STR_LIT>\" ) ; btn_to_transfer . setEnabled ( true ) ; } private boolean checkPermissionOrRequest ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { if ( Environment . isExternalStorageManager ( ) ) { return true ; } else { Intent intent = new Intent ( Settings . ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION ) ; startActivityForResult ( intent , <NUM_LIT> ) ; return false ; } } else { if ( ContextCompat . checkSelfPermission ( this , android . Manifest . permission . WRITE_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { return true ; } else { ActivityCompat . requestPermissions ( this , new String [ ] { android . Manifest . permission . WRITE_EXTERNAL_STORAGE , Manifest . permission . READ_EXTERNAL_STORAGE } , <NUM_LIT> ) ; return false ; } } } public static class ConnectThread extends Thread { private final MainActivity activity ; private boolean shutdown = false ; private final ITransferService service ; public ConnectThread ( MainActivity activity , ITransferService service ) { this . activity = activity ; this . service = service ; } @ Override public void run ( ) { try { Error error = service . startServer ( ) ; activity . runOnUiThread ( ( ) -> { if ( error != null ) { if ( ! shutdown ) { Toast . makeText ( activity , error . getErrorCode ( ) == Error . CODE_PORT_IS_OCCUPIED ? \"<STR_LIT>\" : \"<STR_LIT>\" + error . getExceptionMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; activity . stopServerAndDisconnectService ( ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; } } else { activity . onServerStarted ( ) ; } } ) ; if ( error == null ) { service . waitingForDied ( ) ; System . out . println ( \"<STR_LIT>\" ) ; } } catch ( RemoteException e ) { activity . runOnUiThread ( ( ) -> { Toast . makeText ( activity , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; activity . stopServerAndDisconnectService ( ) ; } ) ; } } public void shutdown ( ) { shutdown = true ; } } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == R . id . github ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" ) ) ; startActivity ( intent ) ; return true ; } else if ( itemId == R . id . update ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" ) ) ; startActivity ( intent ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; if ( iTransferService != null ) { System . out . println ( \"<STR_LIT>\" ) ; unbindService ( ) ; } } }"}, {"input": "package com . example . mycontentprovider ; import android . content . ContentProvider ; import android . content . ContentUris ; import android . content . ContentValues ; import android . content . Context ; import android . content . UriMatcher ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteException ; import android . database . sqlite . SQLiteOpenHelper ; import android . database . sqlite . SQLiteQueryBuilder ; import android . net . Uri ; import java . util . HashMap ; public class MyProvider extends ContentProvider { public MyProvider ( ) { } static final String PROVIDER_NAME = \"<STR_LIT>\" ; static final String URL = \"<STR_LIT>\" + PROVIDER_NAME + \"<STR_LIT>\" ; static final Uri CONTENT_URI = Uri . parse ( URL ) ; static final String id = \"<STR_LIT>\" ; static final String name = \"<STR_LIT>\" ; static final int uriCode = <NUM_LIT> ; static final UriMatcher uriMatcher ; private static HashMap < String , String > values ; static { uriMatcher = new UriMatcher ( UriMatcher . NO_MATCH ) ; uriMatcher . addURI ( PROVIDER_NAME , \"<STR_LIT>\" , uriCode ) ; uriMatcher . addURI ( PROVIDER_NAME , \"<STR_LIT>\" , uriCode ) ; } @ Override public String getType ( Uri uri ) { switch ( uriMatcher . match ( uri ) ) { case uriCode : return \"<STR_LIT>\" ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + uri ) ; } } @ Override public boolean onCreate ( ) { Context context = getContext ( ) ; DatabaseHelper dbHelper = new DatabaseHelper ( context ) ; db = dbHelper . getWritableDatabase ( ) ; if ( db != null ) { return true ; } return false ; } @ Override public Cursor query ( Uri uri , String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { SQLiteQueryBuilder qb = new SQLiteQueryBuilder ( ) ; qb . setTables ( TABLE_NAME ) ; switch ( uriMatcher . match ( uri ) ) { case uriCode : qb . setProjectionMap ( values ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + uri ) ; } String s = \"<STR_LIT>\" + projection [ <NUM_LIT> ] ; if ( sortOrder == null || sortOrder == \"<STR_LIT>\" ) { sortOrder = id ; } Cursor c = qb . query ( db , projection , selection , selectionArgs , null , null , sortOrder ) ; c . setNotificationUri ( getContext ( ) . getContentResolver ( ) , uri ) ; return c ; } @ Override public Uri insert ( Uri uri , ContentValues values ) { long rowID = db . insert ( TABLE_NAME , \"<STR_LIT>\" , values ) ; if ( rowID > <NUM_LIT> ) { Uri _uri = ContentUris . withAppendedId ( CONTENT_URI , rowID ) ; getContext ( ) . getContentResolver ( ) . notifyChange ( _uri , null ) ; return _uri ; }", "output": "throw new SQLiteException ( \"<STR_LIT>\" + uri ) ; } @ Override public int update ( Uri uri , ContentValues values , String selection , String [ ] selectionArgs ) { int count = <NUM_LIT> ; switch ( uriMatcher . match ( uri ) ) { case uriCode : count = db . update ( TABLE_NAME , values , selection , selectionArgs ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; } @ Override public int delete ( Uri uri , String selection , String [ ] selectionArgs ) { int count = <NUM_LIT> ; switch ( uriMatcher . match ( uri ) ) { case uriCode : count = db . delete ( TABLE_NAME , selection , selectionArgs ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; } private SQLiteDatabase db ; static final String DATABASE_NAME = \"<STR_LIT>\" ; static final String TABLE_NAME = \"<STR_LIT>\" ; static final int DATABASE_VERSION = <NUM_LIT> ; static final String CREATE_DB_TABLE = \"<STR_LIT>\" + TABLE_NAME + \"<STR_LIT>\" + \"<STR_LIT>\" ; private static class DatabaseHelper extends SQLiteOpenHelper { DatabaseHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( CREATE_DB_TABLE ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( \"<STR_LIT>\" + TABLE_NAME ) ; onCreate ( db ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import android . app . DownloadManager ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import com . getcapacitor . Logger ; public class DownloadBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { try { String action = intent . getAction ( ) ; if ( DownloadManager . ACTION_DOWNLOAD_COMPLETE . equals ( action ) ) { long downloadId = intent . getLongExtra ( DownloadManager . EXTRA_DOWNLOAD_ID , - <NUM_LIT> ) ; CloudinaryPlugin . onDownloadCompleted ( downloadId ) ; } } catch ( Exception exception ) { Logger . error ( CloudinaryPlugin . TAG , exception . getMessage ( ) , exception ) ;", "output": "} } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import java . io . File ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; public class ParcelableRemoteFile extends RemoteFile implements Parcelable { public ParcelableRemoteFile ( File file ) { super ( file ) ; } public ParcelableRemoteFile ( RemoteFile remoteFile ) { super ( remoteFile ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( this . name ) ; dest . writeString ( this . path ) ; dest . writeLong ( this . lastModified ) ;", "output": "dest . writeLong ( this . size ) ; dest . writeByte ( this . isDirectory ? ( byte ) <NUM_LIT> : ( byte ) <NUM_LIT> ) ; } public void readFromParcel ( Parcel source ) { this . name = source . readString ( ) ; this . path = source . readString ( ) ; this . lastModified = source . readLong ( ) ; this . size = source . readLong ( ) ; this . isDirectory = source . readByte ( ) != <NUM_LIT> ; } protected ParcelableRemoteFile ( Parcel in ) { this . name = in . readString ( ) ; this . path = in . readString ( ) ; this . lastModified = in . readLong ( ) ; this . size = in . readLong ( ) ; this . isDirectory = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < ParcelableRemoteFile > CREATOR = new Creator < ParcelableRemoteFile > ( ) { @ Override public ParcelableRemoteFile createFromParcel ( Parcel source ) { return new ParcelableRemoteFile ( source ) ; } @ Override public ParcelableRemoteFile [ ] newArray ( int size ) { return new ParcelableRemoteFile [ size ] ; } } ; }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . media . MediaScannerConnection ; import android . os . Environment ; import android . os . Handler ; import android . os . Looper ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . Properties ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import de . robv . android . xposed . XposedBridge ; public class Utils { private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; private static final ExecutorService executorCachedService = Executors . newCachedThreadPool ( ) ; @ NonNull public static Application getApplication ( ) { return FeatureLoader . mApp == null ? App . getInstance ( ) : FeatureLoader . mApp ; } public static ExecutorService getExecutor ( ) { return executorService ; } public static ExecutorService getExecutorCachedService ( ) { return executorCachedService ; } public static boolean doRestart ( Context context ) { PackageManager packageManager = context . getPackageManager ( ) ; Intent intent = packageManager . getLaunchIntentForPackage ( context . getPackageName ( ) ) ; if ( intent == null ) return false ; ComponentName componentName = intent . getComponent ( ) ; Intent mainIntent = Intent . makeRestartActivityTask ( componentName ) ; mainIntent . setPackage ( context . getPackageName ( ) ) ; context . startActivity ( mainIntent ) ; Runtime . getRuntime ( ) . exit ( <NUM_LIT> ) ; return true ; } @ SuppressLint ( \"<STR_LIT>\" ) public static int getID ( String name , String type ) { try { return getApplication ( ) . getApplicationContext ( ) . getResources ( ) . getIdentifier ( name , type , getApplication ( ) . getPackageName ( ) ) ; } catch ( Exception e ) { XposedBridge . log ( \"<STR_LIT>\" + name + \"<STR_LIT>\" + type + \"<STR_LIT>\" + e ) ; return - <NUM_LIT> ; } } public static int dipToPixels ( float dipValue ) { DisplayMetrics metrics = FeatureLoader . mApp . getResources ( ) . getDisplayMetrics ( ) ; return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dipValue , metrics ) ; } public static String getMyNumber ( ) { return FeatureLoader . mApp . getSharedPreferences ( FeatureLoader . mApp . getPackageName ( ) + \"<STR_LIT>\" , Context . MODE_PRIVATE ) . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String getDateTimeFromMillis ( long timestamp ) { return new SimpleDateFormat ( \"<STR_LIT>\" , Locale . ENGLISH ) . format ( new Date ( timestamp ) ) ; } public static String getDestination ( SharedPreferences prefs , String name ) { var folderPath = prefs . getString ( \"<STR_LIT>\" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" ) + \"<STR_LIT>\" + name + \"<STR_LIT>\" ; var filePath = new File ( folderPath ) ; if ( ! filePath . exists ( ) ) filePath . mkdirs ( ) ; return filePath . getAbsolutePath ( ) + \"<STR_LIT>\" ; } public static String copyFile ( File srcFile , File destFile ) { if ( srcFile == null || ! srcFile . exists ( ) ) return \"<STR_LIT>\" ; try ( FileInputStream in = new FileInputStream ( srcFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; Utils . scanFile ( destFile ) ; return \"<STR_LIT>\" ; } out . write ( bArr , <NUM_LIT> , read ) ; } } catch ( IOException e ) { XposedBridge . log ( e . getMessage ( ) ) ; return e . getMessage ( ) ; } } public static void showToast ( String message , int length ) { if ( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) { Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . post ( ( ) -> Toast . makeText ( Utils . getApplication ( ) , message , length ) . show ( ) ) ; } } public static void setToClipboard ( String string ) { ClipboardManager clipboard = ( ClipboardManager ) Utils . getApplication ( ) . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( \"<STR_LIT>\" , string ) ; clipboard . setPrimaryClip ( clip ) ; } public static String generateName ( Object userJid , String fileFormat ) { var contactName = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; return toValidFileName ( contactName ) + \"<STR_LIT>\" + number + \"<STR_LIT>\" + new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + \"<STR_LIT>\" + fileFormat ; } public static Object getDefaultValue ( Class < ? > paramType ) { if ( paramType == int . class || paramType == Integer . class ) { return <NUM_LIT> ; } else if ( paramType == long . class || paramType == Long . class ) { return <NUM_LIT> ; } else if ( paramType == double . class || paramType == Double . class ) { return <NUM_LIT> ; } else if ( paramType == boolean . class || paramType == Boolean . class ) { return false ; } return null ; } @ NonNull public static String toValidFileName ( @ NonNull String input ) { return input . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static void scanFile ( File file ) { MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { file . getAbsolutePath ( ) } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( s , uri ) -> { } ) ; } public static Properties extractProperties ( String text ) { Properties properties = new Properties ( ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" , Pattern . DOTALL ) ; Matcher matcher = pattern . matcher ( text ) ; if ( matcher . find ( ) ) { String propertiesText = matcher . group ( <NUM_LIT> ) ; String [ ] lines = propertiesText . split ( \"<STR_LIT>\" ) ; for ( String line : lines ) { String [ ] keyValue = line . split ( \"<STR_LIT>\" ) ; String key = keyValue [ <NUM_LIT> ] . strip ( ) ; String value = keyValue [ <NUM_LIT> ] . strip ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "properties . put ( key , value ) ; } } return properties ; } public static int tryParseInt ( String wallpaperAlpha , int i ) { try { return Integer . parseInt ( wallpaperAlpha . trim ( ) ) ; } catch ( Exception e ) { return i ; } } }"}, {"input": "package com . appspa . update . utils ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . res . AssetFileDescriptor ; import android . database . Cursor ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . provider . MediaStore ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RequiresApi ; import androidx . core . content . FileProvider ; import com . appspa . update . AppSpace ; import java . io . Closeable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public final class FileUtils { public static final String MODE_READ_ONLY = \"<STR_LIT>\" ; private static final String EXT_STORAGE_PATH = getExtStoragePath ( ) ; private static final String EXT_STORAGE_DIR = EXT_STORAGE_PATH + File . separator ; private static final String APP_EXT_STORAGE_PATH = EXT_STORAGE_DIR + \"<STR_LIT>\" ; private static final String EXT_DOWNLOADS_PATH = getExtDownloadsPath ( ) ; private static final String EXT_PICTURES_PATH = getExtPicturesPath ( ) ; private static final String EXT_DCIM_PATH = getExtDCIMPath ( ) ; private FileUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } @ Nullable public static File getFileByPath ( final String filePath ) { return isSpace ( filePath ) ? null : new File ( filePath ) ; } public static boolean isFileExists ( final File file ) { if ( file == null ) { return false ; } if ( file . exists ( ) ) { return true ; } return isFileExists ( file . getAbsolutePath ( ) ) ; } public static boolean isFileExists ( final String filePath ) { File file = getFileByPath ( filePath ) ; if ( file == null ) { return false ; } if ( file . exists ( ) ) { return true ; } return isFileExistsApi29 ( filePath ) ; } private static boolean isFileExistsApi29 ( String filePath ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { AssetFileDescriptor afd = null ; try { Uri uri = Uri . parse ( filePath ) ; afd = openAssetFileDescriptor ( uri ) ; if ( afd == null ) { return false ; } else { closeIOQuietly ( afd ) ; } } catch ( FileNotFoundException e ) { return false ; } finally { closeIOQuietly ( afd ) ; } return true ; } return false ; } public static InputStream getFileInputStream ( File file ) throws FileNotFoundException { if ( isScopedStorageMode ( ) ) { return getContentResolver ( ) . openInputStream ( getUriByFile ( file ) ) ; } else { return new FileInputStream ( file ) ; } } public static Uri getUriByFile ( final File file ) { if ( file == null ) { return null ; } if ( isScopedStorageMode ( ) && isPublicPath ( file ) ) { String filePath = file . getAbsolutePath ( ) ; if ( filePath . startsWith ( EXT_DOWNLOADS_PATH ) ) { return getDownloadContentUri ( AppSpace . getContext ( ) , file ) ; } else if ( filePath . startsWith ( EXT_PICTURES_PATH ) || filePath . startsWith ( EXT_DCIM_PATH ) ) { return getMediaContentUri ( AppSpace . getContext ( ) , file ) ; } else { return getUriForFile ( file ) ;", "output": "} } else { return getUriForFile ( file ) ; } } @ Nullable public static Uri getUriForFile ( final File file ) { if ( file == null ) { return null ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { String authority = AppSpace . getContext ( ) . getPackageName ( ) + \"<STR_LIT>\" ; return FileProvider . getUriForFile ( AppSpace . getContext ( ) , authority , file ) ; } else { return Uri . fromFile ( file ) ; } } public static boolean isScopedStorageMode ( ) { return Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q && ! Environment . isExternalStorageLegacy ( ) ; } public static Uri getMediaContentUri ( Context context , File mediaFile ) { String filePath = mediaFile . getAbsolutePath ( ) ; Uri baseUri = MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; Cursor cursor = context . getContentResolver ( ) . query ( baseUri , new String [ ] { MediaStore . Images . Media . _ID } , MediaStore . Images . Media . DATA + \"<STR_LIT>\" , new String [ ] { filePath } , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { int id = cursor . getInt ( cursor . getColumnIndex ( MediaStore . MediaColumns . _ID ) ) ; cursor . close ( ) ; return Uri . withAppendedPath ( baseUri , \"<STR_LIT>\" + id ) ; } else { if ( mediaFile . exists ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( MediaStore . Images . Media . DATA , filePath ) ; return context . getContentResolver ( ) . insert ( baseUri , values ) ; } return null ; } } @ RequiresApi ( api = Build . VERSION_CODES . Q ) public static Uri getDownloadContentUri ( Context context , File file ) { String filePath = file . getAbsolutePath ( ) ; Uri baseUri = MediaStore . Downloads . EXTERNAL_CONTENT_URI ; Cursor cursor = context . getContentResolver ( ) . query ( baseUri , new String [ ] { MediaStore . Downloads . _ID } , MediaStore . Downloads . DATA + \"<STR_LIT>\" , new String [ ] { filePath } , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { int id = cursor . getInt ( cursor . getColumnIndex ( MediaStore . DownloadColumns . _ID ) ) ; cursor . close ( ) ; return Uri . withAppendedPath ( baseUri , \"<STR_LIT>\" + id ) ; } else { if ( file . exists ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( MediaStore . Downloads . DATA , filePath ) ; return context . getContentResolver ( ) . insert ( baseUri , values ) ; } return null ; } } public static boolean isPrivatePath ( @ NonNull Context context , @ NonNull String path ) { if ( isSpace ( path ) ) { return false ; } String appIntPath = getAppIntPath ( context ) ; String appExtPath = getAppExtPath ( context ) ; return ( ! TextUtils . isEmpty ( appIntPath ) && path . startsWith ( appIntPath ) ) || ( ! TextUtils . isEmpty ( appExtPath ) && path . startsWith ( appExtPath ) ) ; } public static boolean isPublicPath ( File file ) { if ( file == null ) { return false ; } try { return isPublicPath ( file . getCanonicalPath ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return false ; } public static boolean isPublicPath ( String filePath ) { if ( isSpace ( filePath ) ) { return false ; } return filePath . startsWith ( EXT_STORAGE_PATH ) && ! filePath . startsWith ( APP_EXT_STORAGE_PATH ) ; } private static boolean isSpace ( final String s ) { if ( s == null ) { return true ; } for ( int i = <NUM_LIT> , len = s . length ( ) ; i < len ; ++ i ) { if ( ! Character . isWhitespace ( s . charAt ( i ) ) ) { return false ; } } return true ; } public static void closeIOQuietly ( final Closeable ... closeables ) { if ( closeables == null ) { return ; } for ( Closeable closeable : closeables ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException ignored ) { } } } } public static AssetFileDescriptor openAssetFileDescriptor ( Uri uri ) throws FileNotFoundException { return getContentResolver ( ) . openAssetFileDescriptor ( uri , MODE_READ_ONLY ) ; } private static ContentResolver getContentResolver ( ) { return AppSpace . getContext ( ) . getContentResolver ( ) ; } public static String getExtStoragePath ( ) { return Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) ; } public static String getExtDownloadsPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) . getAbsolutePath ( ) ; } public static String getExtPicturesPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_PICTURES ) . getAbsolutePath ( ) ; } public static String getExtDCIMPath ( ) { return Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DCIM ) . getAbsolutePath ( ) ; } public static String getAppIntPath ( @ NonNull Context context ) { File appIntCacheFile = context . getCacheDir ( ) ; if ( appIntCacheFile != null ) { String appIntCachePath = appIntCacheFile . getAbsolutePath ( ) ; return getDirName ( appIntCachePath ) ; } return null ; } public static String getAppExtPath ( @ NonNull Context context ) { File appExtCacheFile = context . getExternalCacheDir ( ) ; if ( appExtCacheFile != null ) { String appExtCachePath = appExtCacheFile . getAbsolutePath ( ) ; return getDirName ( appExtCachePath ) ; } return null ; } public static String getDirName ( final String filePath ) { if ( isSpace ( filePath ) ) { return filePath ; } int lastSep = filePath . lastIndexOf ( File . separator ) ; return lastSep == - <NUM_LIT> ? \"<STR_LIT>\" : filePath . substring ( <NUM_LIT> , lastSep + <NUM_LIT> ) ; } }"}, {"input": "package in . hridayan . ashell . activities ; import android . os . Bundle ; import android . widget . ImageView ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . SettingsViewModel ; import in . hridayan . ashell . adapters . SettingsAdapter ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class SettingsActivity extends AppCompatActivity { private RecyclerView settingsList ; private List < SettingsItem > settingsData ; private SettingsAdapter adapter ; private int currentTheme ; private SettingsViewModel viewModel ; private AppBarLayout appBarLayout ; @ Override protected void onPause ( ) { super . onPause ( ) ; if ( settingsList != null ) { viewModel . setScrollPosition ( ( ( LinearLayoutManager ) settingsList . getLayoutManager ( ) ) . findFirstVisibleItemPosition ( ) ) ;", "output": "viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( settingsList ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_settings ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( SettingsViewModel . class ) ; setupRecyclerView ( ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; settingsList = findViewById ( R . id . settings_list ) ; settingsData = new ArrayList < > ( ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_amoled_theme , getString ( R . string . amoled_theme ) , getString ( R . string . des_amoled_theme ) , true , Preferences . getAmoledTheme ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_clear , getString ( R . string . ask_to_clean ) , getString ( R . string . des_ask_to_clean ) , true , Preferences . getClear ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_share , getString ( R . string . share_and_run ) , getString ( R . string . des_share_and_run ) , true , Preferences . getShareAndRun ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_auto_update , getString ( R . string . auto_update_check ) , getString ( R . string . des_auto_update_check ) , true , Preferences . getAutoUpdateCheck ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_mode , getString ( R . string . default_working_mode ) , getString ( R . string . des_default_working_mode ) , false , false ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_disable_keyboard , getString ( R . string . disable_softkey ) , getString ( R . string . des_disable_softkey ) , true , Preferences . getDisableSoftkey ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_warning , getString ( R . string . override_bookmarks_limit ) , getString ( R . string . des_override_bookmarks ) , true , Preferences . getOverrideBookmarks ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_scroll , getString ( R . string . smooth_scrolling ) , getString ( R . string . des_smooth_scroll ) , true , Preferences . getSmoothScroll ( this ) ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_cards , getString ( R . string . unhide_cards ) , getString ( R . string . des_unhide_cards ) , false , false ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_numbers , getString ( R . string . commands ) , getString ( R . string . des_examples ) , false , false ) ) ; settingsData . add ( new SettingsItem ( \"<STR_LIT>\" , R . drawable . ic_info , getString ( R . string . about ) , getString ( R . string . des_about ) , false , false ) ) ; adapter = new SettingsAdapter ( settingsData , this , currentTheme ) ; settingsList . setAdapter ( adapter ) ; settingsList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; } private void setupRecyclerView ( ) { settingsList = findViewById ( R . id . settings_list ) ; settingsList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; List < SettingsItem > settingsData = viewModel . getSettingsData ( ) ; int scrollPosition = viewModel . getScrollPosition ( ) ; adapter = new SettingsAdapter ( settingsData , this , currentTheme ) ; settingsList . setAdapter ( adapter ) ; settingsList . scrollToPosition ( scrollPosition ) ; } }"}, {"input": "package com . appspa . demo ; import android . app . Application ; import android . widget . Toast ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . utils . UpdateUtils ; import com . appspa . demo . http . OKHttpUpdateHttpService ; import com . zhy . http . okhttp . OkHttpUtils ; import java . util . concurrent . TimeUnit ; import okhttp3 . OkHttpClient ; public class App extends Application { @ Override public void onCreate ( ) { super . onCreate ( ) ; initOKHttpUtils ( ) ; initUpdate ( ) ; } private void initUpdate ( ) { AppSpace . get ( ) . debug ( true ) . isWifiOnly ( false ) . isGet ( true ) . isAutoMode ( false ) . param ( \"<STR_LIT>\" , UpdateUtils . getBaseApkMd5 ( this ) ) . param ( \"<STR_LIT>\" , UpdateUtils . getVersionCode ( this ) ) . param ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . setOnUpdateFailureListener ( new OnUpdateFailureListener ( ) { @ Override public void onFailure ( com . appspa . update . entity . UpdateError error ) { error . printStackTrace ( ) ; if ( error . getCode ( ) != UpdateError . ERROR . CHECK_NO_NEW_VERSION ) { Toast . makeText ( App . this , error . toString ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) . supportSilentInstall ( false ) . setIUpdateHttpService ( new OKHttpUpdateHttpService ( ) ) . init ( this ) ;", "output": "} private void initOKHttpUtils ( ) { OkHttpClient okHttpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , TimeUnit . MILLISECONDS ) . readTimeout ( <NUM_LIT> , TimeUnit . MILLISECONDS ) . build ( ) ; OkHttpUtils . initClient ( okHttpClient ) ; } }"}, {"input": "package com . appspa . update . proxy ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . service . OnFileDownloadListener ; public interface IUpdateProxy { @ Nullable Context getContext ( ) ; String getUrl ( ) ; IUpdateHttpService getIUpdateHttpService ( ) ; void update ( ) ;", "output": "void onBeforeCheck ( ) ; void checkVersion ( ) ; void onAfterCheck ( ) ; void findNewVersion ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy ) ; void noNewVersion ( Throwable throwable ) ; boolean isAsyncParser ( ) ; UpdateEntity parseJson ( @ NonNull String json ) throws Exception ; void parseJson ( @ NonNull String json , final IUpdateParseCallback callback ) throws Exception ; void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ; void backgroundDownload ( ) ; void cancelDownload ( ) ; void recycle ( ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import android . annotation . SuppressLint ; import android . graphics . Bitmap ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . segmentation . Segmentation ; import com . google . mlkit . vision . segmentation . Segmenter ; import com . google . mlkit . vision . segmentation . selfie . SelfieSegmenterOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Objects ; public class SelfieSegmentation { @ NonNull private final SelfieSegmentationPlugin plugin ; public SelfieSegmentation ( @ NonNull SelfieSegmentationPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ; Float threshold = options . getConfidence ( ) ; SelfieSegmenterOptions . Builder builder = new SelfieSegmenterOptions . Builder ( ) ; builder . setDetectorMode ( SelfieSegmenterOptions . SINGLE_IMAGE_MODE ) ; SelfieSegmenterOptions selfieSegmenterOptions = builder . build ( ) ; final Segmenter segmenter = Segmentation . getClient ( selfieSegmenterOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> segmenter . process ( inputImage ) . addOnSuccessListener ( segmentationMask -> { segmenter . close ( ) ; ByteBuffer mask = segmentationMask . getBuffer ( ) ; Bitmap bitmap = inputImage . getBitmapInternal ( ) ; Objects . requireNonNull ( bitmap ) . setHasAlpha ( true ) ; ByteBuffer pixels = ByteBuffer . allocateDirect ( bitmap . getAllocationByteCount ( ) ) ; bitmap . copyPixelsToBuffer ( pixels ) ; final boolean bigEndian = pixels . order ( ) == ByteOrder . BIG_ENDIAN ; final int ALPHA = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int RED = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int GREEN = bigEndian ? <NUM_LIT> : <NUM_LIT> ; final int BLUE = bigEndian ? <NUM_LIT> : <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < pixels . capacity ( ) > > <NUM_LIT> ; i ++ ) { float confidence = mask . getFloat ( ) ; if ( confidence >= threshold ) { byte red = pixels . get ( ( i << <NUM_LIT> ) + RED ) ; byte green = pixels . get ( ( i << <NUM_LIT> ) + GREEN ) ; byte blue = pixels . get ( ( i << <NUM_LIT> ) + BLUE ) ; pixels . put ( ( i << <NUM_LIT> ) + ALPHA , ( byte ) ( <NUM_LIT> ) ) ; pixels . put ( ( i << <NUM_LIT> ) + RED , ( byte ) ( red * confidence ) ) ; pixels . put ( ( i << <NUM_LIT> ) + GREEN , ( byte ) ( green * confidence ) ) ; pixels . put ( ( i << <NUM_LIT> ) + BLUE , ( byte ) ( blue * confidence ) ) ; } else { pixels . putInt ( i << <NUM_LIT> , <NUM_LIT> ) ; } } bitmap . copyPixelsFromBuffer ( pixels . rewind ( ) ) ; @ SuppressLint ( \"<STR_LIT>\" ) String timeStamp = new SimpleDateFormat ( \"<STR_LIT>\" ) . format ( new Date ( ) ) ; String imageFileName = \"<STR_LIT>\" + timeStamp + \"<STR_LIT>\" ; try { File image = File . createTempFile ( imageFileName , \"<STR_LIT>\" ) ;", "output": "OutputStream stream = new FileOutputStream ( image ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , stream ) ; stream . close ( ) ; ProcessImageResult result = new ProcessImageResult ( image . getAbsolutePath ( ) , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; callback . success ( result ) ; } catch ( Exception exception ) { callback . error ( exception ) ; } } ) . addOnCanceledListener ( ( ) -> { segmenter . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { segmenter . close ( ) ; callback . error ( exception ) ; } ) ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; public class CommentAddResult { public static final int CODE_SUCCESS = <NUM_LIT> ; public static final int CODE_DELETED = <NUM_LIT> ; public static final int CODE_CONTAIN_SENSITIVE = <NUM_LIT> ; public static final int CODE_NOT_THE_COMMENT = <NUM_LIT> ; @ JSONField ( name = \"<STR_LIT>\" ) public long rpid ; @ JSONField ( name = \"<STR_LIT>\" ) public String success_toast ; @ JSONField ( name = \"<STR_LIT>\" ) public int success_action ; public long root ; public long parent ; public BiliComment reply ;", "output": "}"}, {"input": "package com . appspa . demo ; import android . content . Context ; import androidx . test . InstrumentationRegistry ; import androidx . test . runner . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . assertEquals ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) { Context appContext = InstrumentationRegistry . getTargetContext ( ) ; assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ;", "output": "} }"}, {"input": "import java . io . BufferedWriter ; import java . util . logging . Logger ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { Log . v ( \"<STR_LIT>\" , \"<STR_LIT>\" + variable ) ; Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + password_secret_key + sec ) ; Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + IV ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + iv ) ; Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + variable ) ; Log . wtf ( \"<STR_LIT>\" , \"<STR_LIT>\" + variable ) ; System . out . print ( \"<STR_LIT>\" ) ; System . err . print ( \"<STR_LIT>\" ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( FileDescriptor . out ) , \"<STR_LIT>\" ) , <NUM_LIT> ) ; out . write ( \"<STR_LIT>\" ) ; out . write ( '<STR_LIT>' ) ; out . flush ( ) ; Logger x = new Logger ( ) ;", "output": "x . severe ( \"<STR_LIT>\" ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class RemoveDynamicReqObject { public RemoveDynamicReqObject ( String dyn_id_str ) { this . dyn_id_str = dyn_id_str ;", "output": "} public String dyn_id_str ; }"}, {"input": "package de . robv . android . xposed ; public interface IXposedHookZygoteInit extends IXposedMod {", "output": "void initZygote ( StartupParam startupParam ) throws Throwable ; final class StartupParam { StartupParam ( ) { } public String modulePath ; public boolean startsSystemServer ; } }"}, {"input": "package top . weixiansen574 . async ; import android . os . Handler ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class BackstageTask < T extends BackstageTask . BaseEventHandler > implements Runnable { private final T uiHandler ; public BackstageTask ( T uiHandler ) { this . uiHandler = uiHandler ; } protected abstract void onStart ( T eventHandlerProxy ) throws Throwable ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void run ( ) { T proxyInstance = ( T ) Proxy . newProxyInstance ( uiHandler . getClass ( ) . getClassLoader ( ) , uiHandler . getClass ( ) . getInterfaces ( ) , new SendToUiHandler ( uiHandler ) ) ; try { onStart ( proxyInstance ) ; TaskManger . postOnUiThread ( uiHandler :: onComplete ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; TaskManger . postOnUiThread ( ( ) -> uiHandler . onError ( e ) ) ; } } public void execute ( ) { TaskManger . execute ( this ) ; } public static class SendToUiHandler implements InvocationHandler {", "output": "Object evHandler ; public SendToUiHandler ( Object evHandler ) { this . evHandler = evHandler ; } @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) == Object . class ) { return method . invoke ( proxy , args ) ; } TaskManger . postOnUiThread ( ( ) -> { try { method . invoke ( evHandler , args ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } ) ; return null ; } } public interface BaseEventHandler { default void onError ( Throwable th ) { throw new RuntimeException ( th ) ; } default void onComplete ( ) { } } }"}, {"input": "package external . org . apache . commons . lang3 ; public class CharUtils { private static final String [ ] CHAR_STRING_ARRAY = new String [ <NUM_LIT> ] ; public static final char LF = '<STR_LIT>' ; public static final char CR = '<STR_LIT>' ; static { for ( char c = <NUM_LIT> ; c < CHAR_STRING_ARRAY . length ; c ++ ) { CHAR_STRING_ARRAY [ c ] = String . valueOf ( c ) ; } } public CharUtils ( ) { super ( ) ; } @ Deprecated public static Character toCharacterObject ( char ch ) { return Character . valueOf ( ch ) ; } public static Character toCharacterObject ( String str ) { if ( StringUtils . isEmpty ( str ) ) { return null ; } return Character . valueOf ( str . charAt ( <NUM_LIT> ) ) ; }", "output": "public static char toChar ( Character ch ) { if ( ch == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ch . charValue ( ) ; } public static char toChar ( Character ch , char defaultValue ) { if ( ch == null ) { return defaultValue ; } return ch . charValue ( ) ; } public static char toChar ( String str ) { if ( StringUtils . isEmpty ( str ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return str . charAt ( <NUM_LIT> ) ; } public static char toChar ( String str , char defaultValue ) { if ( StringUtils . isEmpty ( str ) ) { return defaultValue ; } return str . charAt ( <NUM_LIT> ) ; } public static int toIntValue ( char ch ) { if ( isAsciiNumeric ( ch ) == false ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + ch + \"<STR_LIT>\" ) ; } return ch - <NUM_LIT> ; } public static int toIntValue ( char ch , int defaultValue ) { if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - <NUM_LIT> ; } public static int toIntValue ( Character ch ) { if ( ch == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return toIntValue ( ch . charValue ( ) ) ; } public static int toIntValue ( Character ch , int defaultValue ) { if ( ch == null ) { return defaultValue ; } return toIntValue ( ch . charValue ( ) , defaultValue ) ; } public static String toString ( char ch ) { if ( ch < <NUM_LIT> ) { return CHAR_STRING_ARRAY [ ch ] ; } return new String ( new char [ ] { ch } ) ; } public static String toString ( Character ch ) { if ( ch == null ) { return null ; } return toString ( ch . charValue ( ) ) ; } public static String unicodeEscaped ( char ch ) { if ( ch < <NUM_LIT> ) { return \"<STR_LIT>\" + Integer . toHexString ( ch ) ; } else if ( ch < <NUM_LIT> ) { return \"<STR_LIT>\" + Integer . toHexString ( ch ) ; } else if ( ch < <NUM_LIT> ) { return \"<STR_LIT>\" + Integer . toHexString ( ch ) ; } return \"<STR_LIT>\" + Integer . toHexString ( ch ) ; } public static String unicodeEscaped ( Character ch ) { if ( ch == null ) { return null ; } return unicodeEscaped ( ch . charValue ( ) ) ; } public static boolean isAscii ( char ch ) { return ch < <NUM_LIT> ; } public static boolean isAsciiPrintable ( char ch ) { return ch >= <NUM_LIT> && ch < <NUM_LIT> ; } public static boolean isAsciiControl ( char ch ) { return ch < <NUM_LIT> || ch == <NUM_LIT> ; } public static boolean isAsciiAlpha ( char ch ) { return ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) ; } public static boolean isAsciiAlphaUpper ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiAlphaLower ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiNumeric ( char ch ) { return ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ; } public static boolean isAsciiAlphanumeric ( char ch ) { return ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) || ( ch >= '<STR_LIT>' && ch <= '<STR_LIT>' ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core . devkit ; import android . app . Application ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . content . res . Resources ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import java . util . stream . Collectors ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class UnobfuscatorCache { private final Application mApp ; private static UnobfuscatorCache mInstance ; private final SharedPreferences mShared ; private final Map < String , String > reverseResourceMap = new HashMap < > ( ) ; public UnobfuscatorCache ( Application app , XSharedPreferences shared ) { mApp = app ; try { mShared = mApp . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; long version = mShared . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; long currentVersion = mApp . getPackageManager ( ) . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) . getLongVersionCode ( ) ; long savedUpdateTime = mShared . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; long lastUpdateTime = shared . getLong ( \"<STR_LIT>\" , - <NUM_LIT> ) ; if ( version != currentVersion || savedUpdateTime != lastUpdateTime ) { mShared . edit ( ) . clear ( ) . commit ( ) ; mShared . edit ( ) . putLong ( \"<STR_LIT>\" , currentVersion ) . commit ( ) ; mShared . edit ( ) . putLong ( \"<STR_LIT>\" , lastUpdateTime ) . commit ( ) ; } initCacheStrings ( ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } } private void initCacheStrings ( ) { getOfuscateIDString ( \"<STR_LIT>\" ) ; getOfuscateIDString ( \"<STR_LIT>\" ) ; getOfuscateIDString ( \"<STR_LIT>\" ) ; getOfuscateIDString ( \"<STR_LIT>\" ) ; getOfuscateIDString ( \"<STR_LIT>\" ) ; } public static UnobfuscatorCache getInstance ( ) { return mInstance ; } public static void init ( Application mApp , XSharedPreferences pref ) { mInstance = new UnobfuscatorCache ( mApp , pref ) ; } private void initializeReverseResourceMap ( ) { int numThreads = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService executor = Executors . newFixedThreadPool ( numThreads ) ; try { var configuration = new Configuration ( mApp . getResources ( ) . getConfiguration ( ) ) ; configuration . setLocale ( Locale . ENGLISH ) ; var context = Utils . getApplication ( ) . createConfigurationContext ( configuration ) ; Resources resources = context . getResources ( ) ; int startId = <NUM_LIT> ; int endId = <NUM_LIT> ; int chunkSize = ( endId - startId + <NUM_LIT> ) / numThreads ; CountDownLatch latch = new CountDownLatch ( numThreads ) ; for ( int t = <NUM_LIT> ; t < numThreads ; t ++ ) { int threadStartId = startId + t * chunkSize ; int threadEndId = t == numThreads - <NUM_LIT> ? endId : threadStartId + chunkSize - <NUM_LIT> ; executor . submit ( ( ) -> { try { for ( int i = threadStartId ; i <= threadEndId ; i ++ ) { try { String resourceString = resources . getString ( i ) ; reverseResourceMap . put ( resourceString . toLowerCase ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , String . valueOf ( i ) ) ; }", "output": "catch ( Resources . NotFoundException ignored ) { } } } finally { latch . countDown ( ) ; } } ) ; } latch . await ( ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { executor . shutdown ( ) ; } } private String getMapIdString ( String search ) { if ( reverseResourceMap . isEmpty ( ) ) { initializeReverseResourceMap ( ) ; } search = search . toLowerCase ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return reverseResourceMap . get ( search ) ; } public int getOfuscateIDString ( String search ) { search = search . toLowerCase ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var id = mShared . getString ( search , null ) ; if ( id == null ) { id = getMapIdString ( search ) ; if ( id != null ) { mShared . edit ( ) . putString ( search , id ) . commit ( ) ; } } return id == null ? - <NUM_LIT> : Integer . parseInt ( id ) ; } public String getString ( String search ) { var id = getOfuscateIDString ( search ) ; return id == - <NUM_LIT> ? \"<STR_LIT>\" : mApp . getResources ( ) . getString ( id ) ; } public Field getField ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Field result = ( Field ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( \"<STR_LIT>\" ) ; saveField ( methodName , result ) ; return result ; } String [ ] ClassAndName = value . split ( \"<STR_LIT>\" ) ; Class < ? > cls = XposedHelpers . findClass ( ClassAndName [ <NUM_LIT> ] , loader ) ; return XposedHelpers . findField ( cls , ClassAndName [ <NUM_LIT> ] ) ; } public Method getMethod ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Method result = ( Method ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( \"<STR_LIT>\" ) ; saveMethod ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( \"<STR_LIT>\" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( \"<STR_LIT>\" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] , paramTypes ) ; } return XposedHelpers . findMethodExact ( cls , classAndName [ <NUM_LIT> ] ) ; } public Class < ? > getClass ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { Class < ? > result = ( Class < ? > ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( \"<STR_LIT>\" ) ; saveClass ( methodName , result ) ; return result ; } return XposedHelpers . findClass ( value , loader ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void saveField ( String key , Field field ) { String value = field . getDeclaringClass ( ) . getName ( ) + \"<STR_LIT>\" + field . getName ( ) ; mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void saveMethod ( String key , Method method ) { String value = method . getDeclaringClass ( ) . getName ( ) + \"<STR_LIT>\" + method . getName ( ) ; if ( method . getParameterTypes ( ) . length > <NUM_LIT> ) { value += \"<STR_LIT>\" + Arrays . stream ( method . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void saveClass ( String message , Class < ? > messageClass ) { mShared . edit ( ) . putString ( message , messageClass . getName ( ) ) . commit ( ) ; } private String getKeyName ( ) { AtomicReference < String > keyName = new AtomicReference < > ( \"<STR_LIT>\" ) ; Arrays . stream ( Thread . currentThread ( ) . getStackTrace ( ) ) . filter ( stackTraceElement -> stackTraceElement . getClassName ( ) . equals ( Unobfuscator . class . getName ( ) ) ) . findFirst ( ) . ifPresent ( stackTraceElement -> keyName . set ( stackTraceElement . getMethodName ( ) ) ) ; return keyName . get ( ) ; } public Constructor getConstructor ( ClassLoader loader , FunctionCall functionCall ) throws Exception { var methodName = getKeyName ( ) ; String value = mShared . getString ( methodName , null ) ; if ( value == null ) { var result = ( Constructor ) functionCall . call ( ) ; if ( result == null ) throw new Exception ( \"<STR_LIT>\" ) ; saveConstructor ( methodName , result ) ; return result ; } String [ ] classAndName = value . split ( \"<STR_LIT>\" ) ; Class < ? > cls = XposedHelpers . findClass ( classAndName [ <NUM_LIT> ] , loader ) ; if ( classAndName . length == <NUM_LIT> ) { String [ ] params = classAndName [ <NUM_LIT> ] . split ( \"<STR_LIT>\" ) ; Class < ? > [ ] paramTypes = Arrays . stream ( params ) . map ( param -> XposedHelpers . findClass ( param , loader ) ) . toArray ( Class < ? > [ ] :: new ) ; return XposedHelpers . findConstructorExact ( cls , paramTypes ) ; } return XposedHelpers . findConstructorExact ( cls ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private void saveConstructor ( String key , Constructor constructor ) { String value = constructor . getDeclaringClass ( ) . getName ( ) ; if ( constructor . getParameterTypes ( ) . length > <NUM_LIT> ) { value += \"<STR_LIT>\" + Arrays . stream ( constructor . getParameterTypes ( ) ) . map ( Class :: getName ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; } mShared . edit ( ) . putString ( key , value ) . commit ( ) ; } public interface FunctionCall { Object call ( ) throws Exception ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . LinearInterpolator ; public class LinearSmoothScroller extends RecyclerView . SmoothScroller { private static final boolean DEBUG = false ; private static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = <NUM_LIT> ; public static final int SNAP_TO_START = - <NUM_LIT> ; public static final int SNAP_TO_END = <NUM_LIT> ; public static final int SNAP_TO_ANY = <NUM_LIT> ; private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = <NUM_LIT> ; protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator ( ) ; protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) protected PointF mTargetVector ; private final DisplayMetrics mDisplayMetrics ; private boolean mHasCalculatedMillisPerPixel = false ; private float mMillisPerPixel ; protected int mInterimTargetDx = <NUM_LIT> , mInterimTargetDy = <NUM_LIT> ; @ SuppressLint ( \"<STR_LIT>\" ) public LinearSmoothScroller ( Context context ) { mDisplayMetrics = context . getResources ( ) . getDisplayMetrics ( ) ; } @ Override protected void onStart ( ) { } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { final int dx = calculateDxToMakeVisible ( targetView , getHorizontalSnapPreference ( ) ) ; final int dy = calculateDyToMakeVisible ( targetView , getVerticalSnapPreference ( ) ) ; final int distance = ( int ) Math . sqrt ( dx * dx + dy * dy ) ; final int time = calculateTimeForDeceleration ( distance ) ; if ( time > <NUM_LIT> ) { action . update ( - dx , - dy , time , mDecelerateInterpolator ) ;", "output": "} } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void onSeekTargetStep ( int dx , int dy , RecyclerView . State state , Action action ) { if ( getChildCount ( ) == <NUM_LIT> ) { stop ( ) ; return ; } if ( DEBUG && mTargetVector != null && ( mTargetVector . x * dx < <NUM_LIT> || mTargetVector . y * dy < <NUM_LIT> ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } mInterimTargetDx = clampApplyScroll ( mInterimTargetDx , dx ) ; mInterimTargetDy = clampApplyScroll ( mInterimTargetDy , dy ) ; if ( mInterimTargetDx == <NUM_LIT> && mInterimTargetDy == <NUM_LIT> ) { updateActionForInterimTarget ( action ) ; } } @ Override protected void onStop ( ) { mInterimTargetDx = mInterimTargetDy = <NUM_LIT> ; mTargetVector = null ; } @ SuppressLint ( \"<STR_LIT>\" ) protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } private float getSpeedPerPixel ( ) { if ( ! mHasCalculatedMillisPerPixel ) { mMillisPerPixel = calculateSpeedPerPixel ( mDisplayMetrics ) ; mHasCalculatedMillisPerPixel = true ; } return mMillisPerPixel ; } protected int calculateTimeForDeceleration ( int dx ) { return ( int ) Math . ceil ( calculateTimeForScrolling ( dx ) / <NUM_LIT> ) ; } protected int calculateTimeForScrolling ( int dx ) { return ( int ) Math . ceil ( Math . abs ( dx ) * getSpeedPerPixel ( ) ) ; } protected int getHorizontalSnapPreference ( ) { return mTargetVector == null || mTargetVector . x == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . x > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } protected int getVerticalSnapPreference ( ) { return mTargetVector == null || mTargetVector . y == <NUM_LIT> ? SNAP_TO_ANY : mTargetVector . y > <NUM_LIT> ? SNAP_TO_END : SNAP_TO_START ; } @ SuppressLint ( \"<STR_LIT>\" ) protected void updateActionForInterimTarget ( Action action ) { PointF scrollVector = computeScrollVectorForPosition ( getTargetPosition ( ) ) ; if ( scrollVector == null || ( scrollVector . x == <NUM_LIT> && scrollVector . y == <NUM_LIT> ) ) { final int target = getTargetPosition ( ) ; action . jumpTo ( target ) ; stop ( ) ; return ; } normalize ( scrollVector ) ; mTargetVector = scrollVector ; mInterimTargetDx = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . x ) ; mInterimTargetDy = ( int ) ( TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector . y ) ; final int time = calculateTimeForScrolling ( TARGET_SEEK_SCROLL_DISTANCE_PX ) ; action . update ( ( int ) ( mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , ( int ) ( time * TARGET_SEEK_EXTRA_SCROLL_RATIO ) , mLinearInterpolator ) ; } private int clampApplyScroll ( int tmpDt , int dt ) { final int before = tmpDt ; tmpDt -= dt ; if ( before * tmpDt <= <NUM_LIT> ) { return <NUM_LIT> ; } return tmpDt ; } public int calculateDtToFit ( int viewStart , int viewEnd , int boxStart , int boxEnd , int snapPreference ) { switch ( snapPreference ) { case SNAP_TO_START : return boxStart - viewStart ; case SNAP_TO_END : return boxEnd - viewEnd ; case SNAP_TO_ANY : final int dtStart = boxStart - viewStart ; if ( dtStart > <NUM_LIT> ) { return dtStart ; } final int dtEnd = boxEnd - viewEnd ; if ( dtEnd < <NUM_LIT> ) { return dtEnd ; } break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } return <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDyToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollVertically ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int top = layoutManager . getDecoratedTop ( view ) - params . topMargin ; final int bottom = layoutManager . getDecoratedBottom ( view ) + params . bottomMargin ; final int start = layoutManager . getPaddingTop ( ) ; final int end = layoutManager . getHeight ( ) - layoutManager . getPaddingBottom ( ) ; return calculateDtToFit ( top , bottom , start , end , snapPreference ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int calculateDxToMakeVisible ( View view , int snapPreference ) { final RecyclerView . LayoutManager layoutManager = getLayoutManager ( ) ; if ( layoutManager == null || ! layoutManager . canScrollHorizontally ( ) ) { return <NUM_LIT> ; } final RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) view . getLayoutParams ( ) ; final int left = layoutManager . getDecoratedLeft ( view ) - params . leftMargin ; final int right = layoutManager . getDecoratedRight ( view ) + params . rightMargin ; final int start = layoutManager . getPaddingLeft ( ) ; final int end = layoutManager . getWidth ( ) - layoutManager . getPaddingRight ( ) ; return calculateDtToFit ( left , right , start , end , snapPreference ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import android . app . Activity ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . UUID ; public class LiveUpdatePreferences { @ NonNull private final Context context ; @ NonNull private final SharedPreferences . Editor settingsEditor ; private final String channelKey = \"<STR_LIT>\" ; private final String deviceIdKey = \"<STR_LIT>\" ; private final String customIdKey = \"<STR_LIT>\" ; private final String lastVersionCodeKey = \"<STR_LIT>\" ; public LiveUpdatePreferences ( @ NonNull Context context ) { this . context = context ; this . settingsEditor = context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . edit ( ) ; } @ Nullable public String getChannel ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( channelKey , null ) ; } @ Nullable public String getCustomId ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( customIdKey , null ) ; } @ Nullable public String getDeviceIdForApp ( @ Nullable String appId ) { if ( appId == null ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( deviceIdKey , null ) ; } else { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getString ( deviceIdKey + \"<STR_LIT>\" + appId , null ) ; } } public int getLastVersionCode ( ) { return context . getSharedPreferences ( LiveUpdatePlugin . SHARED_PREFERENCES_NAME , Activity . MODE_PRIVATE ) . getInt ( lastVersionCodeKey , <NUM_LIT> ) ; } public void setChannel ( @ Nullable String channel ) { if ( channel == null ) { settingsEditor . remove ( channelKey ) ; } else { settingsEditor . putString ( channelKey , channel ) ; } settingsEditor . apply ( ) ; } public void setCustomId ( @ Nullable String customId ) { if ( customId == null ) { settingsEditor . remove ( customIdKey ) ; }", "output": "else { settingsEditor . putString ( customIdKey , customId ) ; } settingsEditor . apply ( ) ; } public void setDeviceIdForApp ( @ Nullable String appId , @ NonNull String deviceId ) { if ( appId == null ) { settingsEditor . putString ( deviceIdKey , deviceId ) ; } else { settingsEditor . putString ( deviceIdKey + \"<STR_LIT>\" + appId , deviceId ) ; } settingsEditor . apply ( ) ; } public void setLastVersionCode ( int lastVersionCode ) { settingsEditor . putInt ( lastVersionCodeKey , lastVersionCode ) ; settingsEditor . apply ( ) ; } }"}, {"input": "package com . norman . webviewup . lib ; public class WebViewReplaceException extends Exception { public WebViewReplaceException ( String message ) { super ( message ) ; }", "output": "public WebViewReplaceException ( String message , Throwable cause ) { super ( message , cause ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } }"}, {"input": "package com . appspa . update . service ; import java . io . File ; public interface OnFileDownloadListener { void onStart ( ) ; void onProgress ( float progress , long total ) ; boolean onCompleted ( File file ) ; void onError ( Throwable throwable ) ;", "output": "}"}, {"input": "package com . reactnative . keyboardinsets ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . RCTEventEmitter ; public class KeyboardStatusChangedEvent extends Event < KeyboardStatusChangedEvent > { private final int height ; private final boolean shown ; private final boolean transitioning ; public KeyboardStatusChangedEvent ( int viewTag , int height , boolean shown , boolean transitioning ) { super ( viewTag ) ; this . height = height ;", "output": "this . shown = shown ; this . transitioning = transitioning ; } @ Override public String getEventName ( ) { return \"<STR_LIT>\" ; } @ Override public void dispatch ( RCTEventEmitter rctEventEmitter ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( height ) ) ; map . putBoolean ( \"<STR_LIT>\" , transitioning ) ; map . putBoolean ( \"<STR_LIT>\" , shown ) ; rctEventEmitter . receiveEvent ( getViewTag ( ) , getEventName ( ) , map ) ; } }"}, {"input": "package external . org . apache . commons . lang3 . tuple ; import java . io . Serializable ; import java . util . Map ; import external . org . apache . commons . lang3 . ObjectUtils ; import external . org . apache . commons . lang3 . builder . CompareToBuilder ; public abstract class Pair < L , R > implements Map . Entry < L , R > , Comparable < Pair < L , R > > , Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static < L , R > Pair < L , R > of ( L left , R right ) { return new ImmutablePair < L , R > ( left , right ) ; } public abstract L getLeft ( ) ; public abstract R getRight ( ) ; public final L getKey ( ) { return getLeft ( ) ; } public R getValue ( ) { return getRight ( ) ; } public int compareTo ( Pair < L , R > other ) { return new CompareToBuilder ( ) . append ( getLeft ( ) , other . getLeft ( ) ) . append ( getRight ( ) , other . getRight ( ) ) . toComparison ( ) ; } @ Override public boolean equals ( Object obj ) {", "output": "if ( obj == this ) { return true ; } if ( obj instanceof Map . Entry < ? , ? > ) { Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) obj ; return ObjectUtils . equals ( getKey ( ) , other . getKey ( ) ) && ObjectUtils . equals ( getValue ( ) , other . getValue ( ) ) ; } return false ; } @ Override public int hashCode ( ) { return ( getKey ( ) == null ? <NUM_LIT> : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) == null ? <NUM_LIT> : getValue ( ) . hashCode ( ) ) ; } @ Override public String toString ( ) { return new StringBuilder ( ) . append ( '<STR_LIT>' ) . append ( getLeft ( ) ) . append ( '<STR_LIT>' ) . append ( getRight ( ) ) . append ( '<STR_LIT>' ) . toString ( ) ; } public String toString ( String format ) { return String . format ( format , getLeft ( ) , getRight ( ) ) ; } }"}, {"input": "package com . reactnative . nestedscroll ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import java . util . Map ; public class NestedScrollViewHeaderManager extends ReactViewManager { public final static String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new NestedScrollViewHeader ( context ) ; } @ ReactProp ( name = \"<STR_LIT>\" , defaultInt = NestedScrollViewHeader . INVALID_STICKY_HEIGHT ) public void setFixedHeight ( NestedScrollViewHeader view , int stickyHeight ) { view . setStickyHeight ( ( int ) PixelUtil . toPixelFromDIP ( stickyHeight ) ) ; } @ ReactProp ( name = \"<STR_LIT>\" , defaultInt = NestedScrollViewHeader . INVALID_STICKY_BEGIN_INDEX ) public void setStickyHeaderBeginIndex ( NestedScrollViewHeader view , int stickyHeaderBeginIndex ) { view . setStickyHeaderBeginIndex ( stickyHeaderBeginIndex ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( NestedViewHeaderScrollEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , NestedViewHeaderScrollEvent . JSEventName ) ) . build ( ) ; }", "output": "@ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof NestedScrollViewHeader ) { ( ( NestedScrollViewHeader ) view ) . setOnScrollChangeListener ( ( NestedScrollView . OnScrollChangeListener ) ( v , scrollX , scrollY , oldScrollX , oldScrollY ) -> { int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { NestedViewHeaderScrollEvent nestedViewHeaderScrollEvent = new NestedViewHeaderScrollEvent ( surfaceId , viewId , scrollY ) ; eventDispatcher . dispatchEvent ( nestedViewHeaderScrollEvent ) ; } } ) ; } } }"}, {"input": "import android . security . keystore . KeyGenParameterSpec . Builder ; import javax . crypto . Cipher ; public class TestCryptoAndroid { private void vuln_generateKey1 ( ) { KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , \"<STR_LIT>\" ) ; keyGenerator . initialize ( new KeyGenParameterSpec . Builder ( \"<STR_LIT>\" , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_ECB ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . build ( ) ) ; SecretKey key = keyGenerator . generateKey ( ) ; } private void vuln_generateKey2 ( ) { KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , \"<STR_LIT>\" ) ; keyGenerator . initialize ( new KeyGenParameterSpec . Builder ( \"<STR_LIT>\" , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_CBC ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_PKCS7 ) . build ( ) ) ; SecretKey key = keyGenerator . generateKey ( ) ; } private void good_generateKey ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_GCM ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_NONE ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; } private void vuln_generateKey3 ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_CBC ) . setEncryptionPaddings ( KeyProperties . ENCRYPTION_PADDING_PKCS7 ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; }", "output": "private void vuln_generateKey4 ( ) { final KeyGenerator keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , ANDROID_KEY_STORE ) ; final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec . Builder ( keyName , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT ) . setBlockModes ( KeyProperties . BLOCK_MODE_ECB ) . build ( ) ; keyGenerator . init ( keyGenParameterSpec ) ; secretKey = keyGenerator . generateKey ( ) ; } public String vuln_encrypt ( String toEncrypt ) throws NoSuchPaddingException , NoSuchAlgorithmException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { final Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; } public String good_encrypt ( String toEncrypt ) throws NoSuchPaddingException , NoSuchAlgorithmException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { final Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; } public static String vuln_decrypt ( String key , String data ) { DESKeySpec dks = new DESKeySpec ( key . getBytes ( ) ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( \"<STR_LIT>\" ) ; Key secretKey = keyFactory . generateSecret ( dks ) ; } }"}, {"input": "package org . woheller69 . weather . http ; import android . content . Context ; import android . util . Log ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . Response ; import com . android . volley . VolleyError ; import com . android . volley . toolbox . HurlStack ; import com . android . volley . toolbox . StringRequest ; import com . android . volley . toolbox . Volley ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . weather_api . IProcessHttpRequest ; import java . io . BufferedInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . security . KeyManagementException ; import java . security . KeyStore ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . Certificate ; import java . security . cert . CertificateException ; import java . security . cert . CertificateFactory ; import java . security . cert . X509Certificate ; import java . util . HashMap ; import java . util . Map ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLSocketFactory ; import javax . net . ssl . TrustManagerFactory ; public class VolleyHttpRequest implements IHttpRequest { private Context context ; private int cityId ; public VolleyHttpRequest ( Context context , int cityId ) { this . context = context ; this . cityId = cityId ; } @ Override public void make ( String URL , HttpRequestType method , final IProcessHttpRequest requestProcessor ) { RequestQueue queue = Volley . newRequestQueue ( context ) ; int requestMethod ; switch ( method ) { case POST : requestMethod = Request . Method . POST ; break ; case GET : requestMethod = Request . Method . GET ; break ; case PUT : requestMethod = Request . Method . PUT ; break ; case DELETE : requestMethod = Request . Method . DELETE ; break ; default : requestMethod = Request . Method . GET ; } StringRequest stringRequest = new StringRequest ( requestMethod , URL , new Response . Listener < String > ( ) { @ Override public void onResponse ( String response ) { requestProcessor . processSuccessScenario ( response , cityId ) ; } } , new Response . ErrorListener ( ) {", "output": "@ Override public void onErrorResponse ( VolleyError error ) { requestProcessor . processFailScenario ( error ) ; } } ) { @ Override public Map < String , String > getHeaders ( ) { Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( \"<STR_LIT>\" , BuildConfig . APPLICATION_ID + \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; return params ; } } ; queue . add ( stringRequest ) ; } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . recyclerview . widget . RecyclerView ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; public class RecyclerItemClickListener implements RecyclerView . OnItemTouchListener { private OnItemClickListener mListener ; public interface OnItemClickListener { void onItemClick ( View view , int position ) ; void onLongItemClick ( View view , int position ) ; } private GestureDetector mGestureDetector ; public RecyclerItemClickListener ( Context context , final RecyclerView recyclerView , OnItemClickListener listener ) { mListener = listener ; mGestureDetector = new GestureDetector ( context , new GestureDetector . SimpleOnGestureListener ( ) { @ Override public boolean onSingleTapUp ( MotionEvent e ) { return true ; } @ Override public void onLongPress ( MotionEvent e ) { View child = recyclerView . findChildViewUnder ( e . getX ( ) , e . getY ( ) ) ; if ( child != null && mListener != null ) { mListener . onLongItemClick ( child , recyclerView . getChildAdapterPosition ( child ) ) ; }", "output": "} } ) ; } @ Override public boolean onInterceptTouchEvent ( RecyclerView view , MotionEvent e ) { View childView = view . findChildViewUnder ( e . getX ( ) , e . getY ( ) ) ; if ( childView != null && mListener != null && mGestureDetector . onTouchEvent ( e ) ) { mListener . onItemClick ( childView , view . getChildAdapterPosition ( childView ) ) ; return true ; } return false ; } @ Override public void onTouchEvent ( RecyclerView view , MotionEvent motionEvent ) { } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } }"}, {"input": "package com . reactnative . overlay ; import static android . view . ViewGroup . LayoutParams . MATCH_PARENT ; import android . app . Activity ; import android . os . Bundle ; import android . view . Gravity ; import android . view . ViewGroup ; import android . view . Window ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . annotation . UiThread ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . bridge . ReadableMap ; @ UiThread public class Overlay { final Activity activity ; final String moduleName ; final ReactInstanceManager reactInstanceManager ; OverlayRootView rootView ; ViewGroup decorView ; public Overlay ( @ NonNull Activity activity , String moduleName , ReactInstanceManager reactInstanceManager ) { this . activity = activity ; this . moduleName = moduleName ; this . reactInstanceManager = reactInstanceManager ; } public void show ( ReadableMap props , ReadableMap options ) { OverlayRootView reactRootView = createReactRootView ( ) ; if ( options . hasKey ( \"<STR_LIT>\" ) ) { reactRootView . setShouldConsumeTouchEvent ( ! options . getBoolean ( \"<STR_LIT>\" ) ) ;", "output": "} this . rootView = reactRootView ; startReactApplication ( reactRootView , Arguments . toBundle ( props ) ) ; decorView = getDecorView ( ) ; if ( decorView != null ) { decorView . addView ( reactRootView ) ; } } public void hide ( ) { if ( decorView != null ) { decorView . removeView ( rootView ) ; decorView = null ; } unmountReactView ( ) ; } public void update ( ) { ViewGroup decorView = getDecorView ( ) ; if ( decorView != null && decorView != this . decorView ) { this . decorView . removeView ( rootView ) ; this . decorView = decorView ; decorView . addView ( rootView ) ; } } private void unmountReactView ( ) { ReactContext reactContext = reactInstanceManager . getCurrentReactContext ( ) ; if ( reactContext == null || ! reactContext . hasActiveCatalystInstance ( ) ) { return ; } if ( rootView != null ) { rootView . unmountReactApplication ( ) ; rootView = null ; } } private void startReactApplication ( OverlayRootView reactRootView , Bundle props ) { reactRootView . startReactApplication ( reactInstanceManager , moduleName , props ) ; } private OverlayRootView createReactRootView ( ) { OverlayRootView reactRootView = new OverlayRootView ( activity ) ; reactRootView . setLayoutParams ( new FrameLayout . LayoutParams ( MATCH_PARENT , MATCH_PARENT , Gravity . CENTER ) ) ; return reactRootView ; } private ViewGroup getDecorView ( ) { Window window = activity . getWindow ( ) ; if ( window == null ) { return null ; } return ( ViewGroup ) window . getDecorView ( ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . text . Html ; import android . util . Log ; import android . widget . TextView ; import java . io . IOException ; import java . io . InputStream ; public class HtmlAssetsImageGetter implements Html . ImageGetter { private final Context context ; public HtmlAssetsImageGetter ( Context context ) { this . context = context ; }", "output": "public HtmlAssetsImageGetter ( TextView textView ) { this . context = textView . getContext ( ) ; } @ Override public Drawable getDrawable ( String source ) { try { InputStream inputStream = context . getAssets ( ) . open ( source ) ; Drawable d = Drawable . createFromStream ( inputStream , null ) ; d . setBounds ( <NUM_LIT> , <NUM_LIT> , d . getIntrinsicWidth ( ) , d . getIntrinsicHeight ( ) ) ; return d ; } catch ( IOException e ) { Log . e ( HtmlTextView . TAG , \"<STR_LIT>\" + source ) ; return null ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetDeviceIdResult implements Result { @ NonNull private String deviceId ; public GetDeviceIdResult ( @ NonNull String deviceId ) { this . deviceId = deviceId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , deviceId == null ? JSONObject . NULL : deviceId ) ;", "output": "return result ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import android . os . Build ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Date ; import java . util . Locale ; public class Logger { private static final int MAX_LOG_FILES = <NUM_LIT> ; private static final String LOG_FILE_EXTENSION = \"<STR_LIT>\" ; private final File logDirectory ; private PrintWriter logWriter ; public Logger ( File logDirectory ) { this . logDirectory = logDirectory ; if ( ! logDirectory . exists ( ) ) { logDirectory . mkdirs ( ) ; } createNewLogFile ( ) ; }", "output": "private void createNewLogFile ( ) { String fileName = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) . format ( new Date ( ) ) + LOG_FILE_EXTENSION ; File logFile = new File ( logDirectory , fileName ) ; try { logFile . createNewFile ( ) ; logWriter = new PrintWriter ( new FileWriter ( logFile , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } deleteOldLogFiles ( ) ; } private void deleteOldLogFiles ( ) { File [ ] logFiles = logDirectory . listFiles ( ( dir , name ) -> name . endsWith ( LOG_FILE_EXTENSION ) ) ; if ( logFiles == null ) return ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Arrays . sort ( logFiles , Comparator . comparingLong ( File :: lastModified ) ) ; int numFilesToDelete = logFiles . length - MAX_LOG_FILES ; if ( numFilesToDelete > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < numFilesToDelete ; i ++ ) { logFiles [ i ] . delete ( ) ; } } } } public synchronized void log ( String message ) { if ( logWriter == null ) return ; logWriter . println ( message ) ; logWriter . flush ( ) ; } }"}, {"input": "package de . robv . android . xposed . callbacks ; import android . os . Bundle ; import java . io . Serializable ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XCallback implements Comparable < XCallback > { public final int priority ; @ Deprecated public XCallback ( ) { this . priority = PRIORITY_DEFAULT ; } public XCallback ( int priority ) { this . priority = priority ; } public static abstract class Param { public final Object [ ] callbacks ; private Bundle extra ; @ Deprecated protected Param ( ) { callbacks = null ; } protected Param ( CopyOnWriteSortedSet < ? extends XCallback > callbacks ) { this . callbacks = callbacks . getSnapshot ( ) ; } public synchronized Bundle getExtra ( ) { if ( extra == null ) extra = new Bundle ( ) ; return extra ; } public Object getObjectExtra ( String key ) { Serializable o = getExtra ( ) . getSerializable ( key ) ; if ( o instanceof SerializeWrapper ) return ( ( SerializeWrapper ) o ) . object ; return null ; } public void setObjectExtra ( String key , Object o ) { getExtra ( ) . putSerializable ( key , new SerializeWrapper ( o ) ) ; } private static class SerializeWrapper implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private final Object object ; public SerializeWrapper ( Object o ) { object = o ; } } } public static void callAll ( Param param ) { if ( param . callbacks == null ) throw new IllegalStateException ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < param . callbacks . length ; i ++ ) { try { ( ( XCallback ) param . callbacks [ i ] ) . call ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; } } } protected void call ( Param param ) throws Throwable { }", "output": "@ Override public int compareTo ( XCallback other ) { if ( this == other ) return <NUM_LIT> ; if ( other . priority != this . priority ) return other . priority - this . priority ; else if ( System . identityHashCode ( this ) < System . identityHashCode ( other ) ) return - <NUM_LIT> ; else return <NUM_LIT> ; } public static final int PRIORITY_DEFAULT = <NUM_LIT> ; public static final int PRIORITY_LOWEST = - <NUM_LIT> ; public static final int PRIORITY_HIGHEST = <NUM_LIT> ; }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import com . huawei . hms . mlsdk . asr . MLAsrConstants ; import com . huawei . hms . mlsdk . asr . MLAsrListener ; import com . huawei . hms . mlsdk . asr . MLAsrRecognizer ; import com . huawei . hms . mlsdk . common . MLApplication ; public class HmsAsrClient extends AsrClientBase { Context context = null ; MLAsrRecognizer hwAsrRecognizer = null ; IAsrCallback callback = null ; boolean autoStop = false ; public HmsAsrClient ( Context context ) { this . context = context ; MLApplication . getInstance ( ) . setApiKey ( context . getString ( R . string . hms_api_key ) ) ; hwAsrRecognizer = MLAsrRecognizer . createAsrRecognizer ( context ) ; hwAsrRecognizer . setAsrListener ( new MLAsrListener ( ) { @ Override public void onResults ( Bundle bundle ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + bundle . getString ( \"<STR_LIT>\" ) ) ; String result = bundle . getString ( \"<STR_LIT>\" ) ; callback . onResult ( result ) ; if ( autoStop && result == null ) callback . onAutoStop ( ) ; } @ Override public void onRecognizingResults ( Bundle bundle ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + bundle . getString ( \"<STR_LIT>\" ) ) ; callback . onResult ( bundle . getString ( \"<STR_LIT>\" ) ) ; } @ Override public void onError ( int code , String msg ) { msg = \"<STR_LIT>\" + code + \"<STR_LIT>\" + msg ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg ) ; if ( code == <NUM_LIT> || code == <NUM_LIT> ) msg += context . getString ( R . string . text_hms_asr_failed_error ) ; callback . onError ( msg ) ; } @ Override public void onStartListening ( ) { } @ Override public void onStartingOfSpeech ( ) { } @ Override public void onVoiceDataReceived ( byte [ ] bytes , float v , Bundle bundle ) { } @ Override public void onState ( int i , Bundle bundle ) { } } ) ; } @ Override public void startRecognize ( ) { if ( Build . CPU_ABI . contains ( \"<STR_LIT>\" ) ) {", "output": "callback . onError ( context . getString ( R . string . text_hms_asr_unsupported ) ) ; return ; } Intent hwAsrIntent = new Intent ( MLAsrConstants . ACTION_HMS_ASR_SPEECH ) ; hwAsrIntent . putExtra ( MLAsrConstants . LANGUAGE , \"<STR_LIT>\" ) ; hwAsrIntent . putExtra ( MLAsrConstants . FEATURE , MLAsrConstants . FEATURE_WORDFLUX ) ; hwAsrIntent . putExtra ( MLAsrConstants . VAD_START_MUTE_DURATION , <NUM_LIT> ) ; if ( autoStop ) hwAsrIntent . putExtra ( MLAsrConstants . VAD_END_MUTE_DURATION , <NUM_LIT> ) ; else hwAsrIntent . putExtra ( MLAsrConstants . VAD_END_MUTE_DURATION , <NUM_LIT> ) ; hwAsrIntent . putExtra ( MLAsrConstants . PUNCTUATION_ENABLE , true ) ; hwAsrRecognizer . startRecognizing ( hwAsrIntent ) ; } @ Override public void stopRecognize ( ) { hwAsrRecognizer . destroy ( ) ; } @ Override public void cancelRecognize ( ) { hwAsrRecognizer . destroy ( ) ; } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { hwAsrRecognizer . destroy ( ) ; } }"}, {"input": "package com . simon . harmonichackernews . linkpreview ; import android . content . Context ; import android . text . TextUtils ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . data . WikipediaInfo ; import com . simon . harmonichackernews . network . NetworkComponent ; import org . json . JSONObject ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Document ; import org . jsoup . nodes . Element ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class WikipediaGetter { public static boolean isValidWikipediaUrl ( String url ) { String regex = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( url ) ; return matcher . matches ( ) ; } public static void getInfo ( String wikipediaUrl , Context ctx , WikipediaGetter . GetterCallback callback ) { try { String title = wikipediaUrl . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; String apiUrl = \"<STR_LIT>\" + title ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , apiUrl , response -> { try { JSONObject jsonResponse = new JSONObject ( response ) ; JSONObject pages = jsonResponse . getJSONObject ( \"<STR_LIT>\" ) . getJSONObject ( \"<STR_LIT>\" ) ; String pageId = pages . keys ( ) . next ( ) ; String summary = pages . getJSONObject ( pageId ) . optString ( \"<STR_LIT>\" ) ; if ( ! TextUtils . isEmpty ( summary ) ) { Document doc = Jsoup . parse ( summary ) ; for ( Element ul : doc . select ( \"<STR_LIT>\" ) ) { if ( ! ul . hasText ( ) ) { ul . remove ( ) ; } } String cleanedHtml = doc . html ( ) ; WikipediaInfo wikiInfo = new WikipediaInfo ( ) ; wikiInfo . summary = cleanedHtml ; callback . onSuccess ( wikiInfo ) ; } else { callback . onFailure ( \"<STR_LIT>\" ) ; } } catch ( Exception e ) { callback . onFailure ( \"<STR_LIT>\" ) ; e . printStackTrace ( ) ; } } , error -> { error . printStackTrace ( ) ; callback . onFailure ( \"<STR_LIT>\" ) ; } ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( ctx ) ; queue . add ( stringRequest ) ; } catch ( Exception e ) { callback . onFailure ( \"<STR_LIT>\" ) ; } } public interface GetterCallback { void onSuccess ( WikipediaInfo wikiInfo ) ; void onFailure ( String reason ) ; }", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostDanmakuHook extends BaseHook { public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { AtomicLong currentOid = new AtomicLong ( ) ; AtomicLong currentAvid = new AtomicLong ( ) ; AtomicReference < String > currentContent = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , classLoader . loadClass ( \"<STR_LIT>\" ) , Context . class , String . class , classLoader . loadClass ( \"<STR_LIT>\" ) , int . class , String . class , String . class , String . class , String . class , Long . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ;", "output": "for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( \"<STR_LIT>\" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( \"<STR_LIT>\" ) . append ( param . args [ i ] . toString ( ) ) . append ( \"<STR_LIT>\" ) ; } else { sb . append ( i ) . append ( \"<STR_LIT>\" ) ; } currentContent . set ( ( String ) param . args [ <NUM_LIT> ] ) ; currentOid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; currentAvid . set ( Long . parseLong ( ( String ) param . args [ <NUM_LIT> ] ) ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , classLoader . loadClass ( \"<STR_LIT>\" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < param . args . length ; i ++ ) { if ( param . args [ i ] != null ) { sb . append ( i ) . append ( \"<STR_LIT>\" ) . append ( param . args [ i ] . getClass ( ) . getCanonicalName ( ) ) . append ( \"<STR_LIT>\" ) . append ( param . args [ i ] . toString ( ) ) . append ( \"<STR_LIT>\" ) ; } else { sb . append ( i ) . append ( \"<STR_LIT>\" ) ; } Class < ? > biliAccountsClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Field contextField = param . thisObject . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; contextField . setAccessible ( true ) ; Context context = ( Context ) contextField . get ( param . thisObject ) ; XposedBridge . log ( \"<STR_LIT>\" + context . toString ( ) ) ; Object biliAccounts = biliAccountsClass . getMethod ( \"<STR_LIT>\" , Context . class ) . invoke ( null , context ) ; String accessKey = ( String ) biliAccounts . getClass ( ) . getMethod ( \"<STR_LIT>\" ) . invoke ( biliAccounts ) ; XposedBridge . log ( \"<STR_LIT>\" + accessKey ) ; Object danmakuSendResponse = param . args [ <NUM_LIT> ] ; Method dmidMethod = danmakuSendResponse . getClass ( ) . getMethod ( \"<STR_LIT>\" ) ; long dmid = ( long ) dmidMethod . invoke ( danmakuSendResponse ) ; Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; intent . putExtra ( \"<STR_LIT>\" , ByXposedLaunchedActivity . TODO_CHECK_DANMAKU ) ; intent . putExtra ( \"<STR_LIT>\" , currentOid . get ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , dmid ) ; intent . putExtra ( \"<STR_LIT>\" , currentContent . get ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , accessKey ) ; intent . putExtra ( \"<STR_LIT>\" , currentAvid . get ( ) ) ; XposedBridge . log ( \"<STR_LIT>\" + intent . getExtras ( ) ) ; context . startActivity ( intent ) ; } XposedBridge . log ( sb . toString ( ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Stickers extends Feature { public Stickers ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var sendStickerMethod = Unobfuscator . loadSendStickerMethod ( classLoader ) ; XposedBridge . hookMethod ( sendStickerMethod , new XC_MethodHook ( ) { private Unhook unhooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { unhooked = XposedHelpers . findAndHookMethod ( View . class , \"<STR_LIT>\" , View . OnClickListener . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { View . OnClickListener mCaptureOnClickListener = ( View . OnClickListener ) param . args [ <NUM_LIT> ] ; if ( mCaptureOnClickListener == null ) return ; if ( ! ( param . thisObject instanceof ViewGroup ) ) return ; var view = ( View ) param . thisObject ; if ( view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) == null ) return ; param . args [ <NUM_LIT> ] = ( View . OnClickListener ) v -> {", "output": "var context = view . getContext ( ) ; var dialog = new AlertDialogWpp ( view . getContext ( ) ) ; dialog . setTitle ( context . getString ( ResId . string . send_sticker ) ) ; var stickerView = ( ImageView ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var padding = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( padding , padding , padding , padding ) ; var image = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; var params = new LinearLayout . LayoutParams ( size , size ) ; params . bottomMargin = padding ; image . setLayoutParams ( params ) ; image . setImageDrawable ( stickerView . getDrawable ( ) ) ; linearLayout . addView ( image ) ; TextView text = new TextView ( context ) ; text . setText ( context . getString ( ResId . string . do_you_want_to_send_sticker ) ) ; text . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; linearLayout . addView ( text ) ; dialog . setView ( linearLayout ) ; dialog . setPositiveButton ( context . getString ( ResId . string . send ) , ( dialog1 , which ) -> mCaptureOnClickListener . onClick ( view ) ) ; dialog . setNegativeButton ( context . getString ( ResId . string . cancel ) , null ) ; dialog . show ( ) ; } ; } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { unhooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . appspa . update . logs ; import androidx . annotation . NonNull ; import android . text . TextUtils ; import android . util . Log ; public final class UpdateLog { private UpdateLog ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public final static String DEFAULT_LOG_TAG = \"<STR_LIT>\" ; private final static int MAX_LOG_PRIORITY = <NUM_LIT> ; private final static int MIN_LOG_PRIORITY = <NUM_LIT> ; private static ILogger sILogger = new LogcatLogger ( ) ; private static String sTag = DEFAULT_LOG_TAG ; private static boolean sIsDebug = false ; private static int sLogPriority = MAX_LOG_PRIORITY ; public static void setLogger ( @ NonNull ILogger logger ) { sILogger = logger ; } public static void setTag ( String tag ) { sTag = tag ; } public static void setDebug ( boolean isDebug ) { sIsDebug = isDebug ; } public static void setPriority ( int priority ) { sLogPriority = priority ; } public static void debug ( boolean isDebug ) { if ( isDebug ) { debug ( DEFAULT_LOG_TAG ) ; } else { debug ( \"<STR_LIT>\" ) ; } } public static void debug ( String tag ) { if ( ! TextUtils . isEmpty ( tag ) ) { setDebug ( true ) ; setPriority ( MIN_LOG_PRIORITY ) ; setTag ( tag ) ; } else { setDebug ( false ) ; setPriority ( MAX_LOG_PRIORITY ) ; setTag ( \"<STR_LIT>\" ) ; } } public static void v ( String msg ) { if ( enableLog ( Log . VERBOSE ) ) { sILogger . log ( Log . VERBOSE , sTag , msg , null ) ; } } public static void vTag ( String tag , String msg ) { if ( enableLog ( Log . VERBOSE ) ) { sILogger . log ( Log . VERBOSE , tag , msg , null ) ; } }", "output": "public static void d ( String msg ) { if ( enableLog ( Log . DEBUG ) ) { sILogger . log ( Log . DEBUG , sTag , msg , null ) ; } } public static void dTag ( String tag , String msg ) { if ( enableLog ( Log . DEBUG ) ) { sILogger . log ( Log . DEBUG , tag , msg , null ) ; } } public static void i ( String msg ) { if ( enableLog ( Log . INFO ) ) { sILogger . log ( Log . INFO , sTag , msg , null ) ; } } public static void iTag ( String tag , String msg ) { if ( enableLog ( Log . INFO ) ) { sILogger . log ( Log . INFO , tag , msg , null ) ; } } public static void w ( String msg ) { if ( enableLog ( Log . WARN ) ) { sILogger . log ( Log . WARN , sTag , msg , null ) ; } } public static void wTag ( String tag , String msg ) { if ( enableLog ( Log . WARN ) ) { sILogger . log ( Log . WARN , tag , msg , null ) ; } } public static void e ( String msg ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , msg , null ) ; } } public static void eTag ( String tag , String msg ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , msg , null ) ; } } public static void e ( Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , null , t ) ; } } public static void eTag ( String tag , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , null , t ) ; } } public static void e ( String msg , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , sTag , msg , t ) ; } } public static void eTag ( String tag , String msg , Throwable t ) { if ( enableLog ( Log . ERROR ) ) { sILogger . log ( Log . ERROR , tag , msg , t ) ; } } public static void wtf ( String msg ) { if ( enableLog ( Log . ASSERT ) ) { sILogger . log ( Log . ASSERT , sTag , msg , null ) ; } } public static void wtfTag ( String tag , String msg ) { if ( enableLog ( Log . ASSERT ) ) { sILogger . log ( Log . ASSERT , tag , msg , null ) ; } } private static boolean enableLog ( int logPriority ) { return sILogger != null && sIsDebug && logPriority >= sLogPriority ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . Html . ImageGetter ; import androidx . annotation . Nullable ; public class HtmlFormatterBuilder { private String html ; private ImageGetter imageGetter ; private ClickableTableSpan clickableTableSpan ; private DrawTableLinkSpan drawTableLinkSpan ; private OnClickATagListener onClickATagListener ; private float indent = <NUM_LIT> ; private boolean removeTrailingWhiteSpace = true ; public String getHtml ( ) { return html ;", "output": "} public ImageGetter getImageGetter ( ) { return imageGetter ; } public ClickableTableSpan getClickableTableSpan ( ) { return clickableTableSpan ; } public DrawTableLinkSpan getDrawTableLinkSpan ( ) { return drawTableLinkSpan ; } public OnClickATagListener getOnClickATagListener ( ) { return onClickATagListener ; } public float getIndent ( ) { return indent ; } public boolean isRemoveTrailingWhiteSpace ( ) { return removeTrailingWhiteSpace ; } public HtmlFormatterBuilder setHtml ( @ Nullable final String html ) { this . html = html ; return this ; } public HtmlFormatterBuilder setImageGetter ( @ Nullable final ImageGetter imageGetter ) { this . imageGetter = imageGetter ; return this ; } public HtmlFormatterBuilder setClickableTableSpan ( @ Nullable final ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; return this ; } public HtmlFormatterBuilder setDrawTableLinkSpan ( @ Nullable final DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; return this ; } public void setOnClickATagListener ( OnClickATagListener onClickATagListener ) { this . onClickATagListener = onClickATagListener ; } public HtmlFormatterBuilder setIndent ( final float indent ) { this . indent = indent ; return this ; } public HtmlFormatterBuilder setRemoveTrailingWhiteSpace ( final boolean removeTrailingWhiteSpace ) { this . removeTrailingWhiteSpace = removeTrailingWhiteSpace ; return this ; } }"}, {"input": "package com . example . myuidemo ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import com . reactnativecommunity . webview . RNCNestedScrollWebViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class MyUiPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ;", "output": "} @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new RNCNestedScrollWebViewManager ( ) ) ; } }"}, {"input": "import androidx . biometric . BiometricPrompt ; import android . hardware . fingerprint . FingerprintManager ; import android . hardware . fingerprint . FingerprintManagerCompat ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test_vulnBiometricPrompt ( ) ; test_vulnFingerprintManager ( ) ; test_vulnFingerprintManagerCompat ( ) ; test_goodBiometricPrompt ( ) ; } private void test_vulnBiometricPrompt ( ) { biometricPrompt = new BiometricPrompt ( MainActivity . this , executor , new BiometricPrompt . AuthenticationCallback ( ) { @ Override public void onAuthenticationSucceeded ( @ NonNull BiometricPrompt . AuthenticationResult result ) { Toast . makeText ( MainActivity . this , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; setContentView ( R . layout . fingerprint_normal ) ; } @ Override public void onAuthenticationError ( int errorCode , @ NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; Toast . makeText ( MainActivity . this , errString , Toast . LENGTH_LONG ) . show ( ) ; MainActivity . this . finish ( ) ; } @ Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( MainActivity . this , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } public void Authentication ( FingerprintManager manager , FingerprintManager . CryptoObject cryptoObject ) {", "output": "CancellationSignal cancellationSignal = new CancellationSignal ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . USE_FINGERPRINT ) != PackageManager . PERMISSION_GRANTED ) { return ; } manager . authenticate ( cryptoObject , cancellationSignal , <NUM_LIT> , this , null ) ; } @ Override public void onAuthenticationFailed ( ) { this . update ( \"<STR_LIT>\" , false ) ; } @ Override public void onAuthenticationSucceeded ( FingerprintManager . AuthenticationResult result ) { this . update ( \"<STR_LIT>\" , true ) ; } public void update ( String e , Boolean success ) { TextView textView = ( TextView ) ( ( Activity ) context ) . findViewById ( R . id . textMsg ) ; textView . setText ( e ) ; if ( success ) { textView . setTextColor ( ContextCompat . getColor ( context , R . color . black ) ) ; } } private void test_vulnFingerprintManagerCompat ( ) { fingerprintManager . authenticate ( null , <NUM_LIT> , cancellationSignal , new FingerprintManagerCompat . AuthenticationCallback ( ) { @ Override public void onAuthenticationError ( int errMsgId , CharSequence errString ) { if ( ! selfCancelled ) { showFingerprintError ( errString ) ; } } @ Override public void onAuthenticationHelp ( int helpMsgId , CharSequence helpString ) { showFingerprintError ( helpString ) ; } @ Override public void onAuthenticationFailed ( ) { showFingerprintError ( LocaleController . getString ( \"<STR_LIT>\" , R . string . FingerprintNotRecognized ) ) ; } @ Override public void onAuthenticationSucceeded ( FingerprintManagerCompat . AuthenticationResult result ) { try { if ( fingerprintDialog . isShowing ( ) ) { fingerprintDialog . dismiss ( ) ; } } catch ( Exception e ) { FileLog . e ( \"<STR_LIT>\" , e ) ; } fingerprintDialog = null ; processDone ( true ) ; } } , null ) ; } private void test_goodBiometricPrompt ( ) { biometricPrompt = new BiometricPrompt ( MainActivity . this , executor , new BiometricPrompt . AuthenticationCallback ( ) { @ Override public void onAuthenticationSucceeded ( @ NonNull BiometricPrompt . AuthenticationResult result ) { if ( result . getCryptoObject ( ) != null && result . getCryptoObject ( ) . getCrypto ( ) != null ) { try { Cipher cipher = result . getCryptoObject ( ) . getCipher ( ) ; byte [ ] decrypted = cipher . doFinal ( encrypted ) ; } catch ( CipherException e ) { throw new RuntimeException ( ) ; } } else { } } @ Override public void onAuthenticationError ( int errorCode , @ NonNull CharSequence errString ) { super . onAuthenticationError ( errorCode , errString ) ; Toast . makeText ( MainActivity . this , errString , Toast . LENGTH_LONG ) . show ( ) ; MainActivity . this . finish ( ) ; } @ Override public void onAuthenticationFailed ( ) { super . onAuthenticationFailed ( ) ; Toast . makeText ( MainActivity . this , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . ClassType ; import com . norman . webviewup . lib . reflect . annotation . Constructor ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; import com . norman . webviewup . lib . reflect . annotation . ParameterName ; import com . norman . webviewup . lib . reflect . annotation . ParameterType ; import java . lang . annotation . Annotation ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . ConcurrentHashMap ; public class RuntimeAccess < T > { private final static Map < Class < ? > , Object > STATIC_ACCESS_MAP = new ConcurrentHashMap < > ( ) ; private volatile Object assessObject ; private final Class < T > buildClass ; private T proxy ; private boolean staticAccess ; public RuntimeAccess ( Class < T > buildClass ) { this . buildClass = buildClass ; } public RuntimeAccess ( Class < T > buildClass , Object obj ) { this . buildClass = buildClass ; this . assessObject = obj ; } public void setAssessObject ( Object assessObject ) { this . assessObject = assessObject ; } public static < T > T staticAccess ( Class < T > buildClass ) { Object access = STATIC_ACCESS_MAP . get ( buildClass ) ; if ( access != null ) { return ( T ) access ; } RuntimeAccess < T > runtimeAccess = new RuntimeAccess < > ( buildClass ) ; access = runtimeAccess . get ( ) ; STATIC_ACCESS_MAP . put ( buildClass , access ) ; return ( T ) access ; } public static < T > T objectAccess ( Class < T > buildClass , Object object ) { RuntimeAccess < T > runtimeAccess = new RuntimeAccess < > ( buildClass , object ) ; return runtimeAccess . get ( ) ; } boolean isStaticAccess ( ) { return staticAccess ; } public T get ( ) throws ReflectException { try { if ( proxy != null ) { return proxy ; } if ( ! buildClass . isInterface ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ClassType classTypeAnnotation = buildClass . getAnnotation ( ClassType . class ) ; ClassName classNameAnnotation = buildClass . getAnnotation ( ClassName . class ) ; Class < ? > annotationClass = null ; if ( classNameAnnotation != null ) { annotationClass = Class . forName ( classNameAnnotation . value ( ) ) ; } else if ( classTypeAnnotation != null ) { annotationClass = classTypeAnnotation . value ( ) ; } final Class < ? > reflectClass = annotationClass ; if ( reflectClass == null ) { throw new NullPointerException ( buildClass + \"<STR_LIT>\" + ClassType . class + \"<STR_LIT>\" + ClassName . class ) ; } ReflectProxy reflectProxy = new ReflectProxy ( buildClass ) ; boolean allStaticAnnotation = true ; for ( java . lang . reflect . Method method : buildClass . getMethods ( ) ) { Method methodAnnotation = method . getAnnotation ( Method . class ) ; Constructor constructorAnnotation = method . getAnnotation ( Constructor . class ) ; Field filedAnnotation = method . getAnnotation ( Field . class ) ; ReflectProxy . Invoke invoke = null ; if ( methodAnnotation != null ) { if ( methodAnnotation . type ( ) != Method . STATIC ) { allStaticAnnotation = false ; } invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { Class < ? > [ ] methodParameterTypes = findParameterTypes ( invokeContext ) ; String methodName = methodAnnotation . value ( ) ; if ( TextUtils . isEmpty ( methodName ) ) { methodName = invokeContext . getName ( ) ; } Object assessObj = checkAssessObject ( reflectClass ) ; ReflectMethod reflectMethod = new ReflectMethod ( reflectClass , methodName , methodParameterTypes ) ; if ( assessObj != null ) { reflectMethod = new ReflectMethod ( assessObj , methodName , methodParameterTypes ) ; } reflectMethod . setStaticType ( methodAnnotation . type ( ) ) ; Object result = reflectMethod . invoke ( invokeContext . args ) ; invokeContext . setResult ( result ) ; } } ; } else if ( constructorAnnotation != null ) { invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { Class < ? > [ ] constructorParameterTypes = findParameterTypes ( invokeContext ) ; ReflectConstructor reflectMethod = new ReflectConstructor ( reflectClass , constructorParameterTypes ) ; Object result = reflectMethod . newInstance ( invokeContext . args ) ; invokeContext . setResult ( result ) ; } } ; } else if ( filedAnnotation != null ) { if ( filedAnnotation . type ( ) != Field . STATIC ) { allStaticAnnotation = false ; } Class < ? > returnType = method . getReturnType ( ) ; if ( returnType == Void . TYPE && method . getParameterTypes ( ) . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "output": "invoke = new ReflectProxy . Invoke ( method . getName ( ) , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { String filedName = filedAnnotation . value ( ) ; if ( TextUtils . isEmpty ( filedName ) ) { filedName = invokeContext . getName ( ) ; } Object assessObj = checkAssessObject ( reflectClass ) ; ReflectField reflectField = new ReflectField ( reflectClass , filedName ) ; if ( assessObj != null ) { reflectField = new ReflectField ( assessObj , filedName ) ; } reflectField . setStaticType ( filedAnnotation . type ( ) ) ; Class < ? > returnType = method . getReturnType ( ) ; if ( returnType == Void . TYPE ) { reflectField . set ( invokeContext . args [ <NUM_LIT> ] ) ; invokeContext . setResult ( null ) ; } else { Object kkk = reflectField . get ( ) ; invokeContext . setResult ( kkk ) ; } } } ; } if ( invoke != null ) { reflectProxy . addInvoke ( invoke ) ; } } proxy = ( T ) reflectProxy . newProxyInstance ( ) ; staticAccess = allStaticAnnotation ; return proxy ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } private Object checkAssessObject ( Class < ? > reflectCls ) { Object obj = assessObject ; if ( obj != null && ! Objects . equals ( obj . getClass ( ) , reflectCls ) ) { throw new IllegalArgumentException ( reflectCls + \"<STR_LIT>\" + assessObject . getClass ( ) ) ; } return obj ; } @ NonNull private static Class < ? > [ ] findParameterTypes ( ReflectProxy . InvokeContext invokeContext ) { Annotation [ ] [ ] invokeAnnotations = invokeContext . getParameterAnnotations ( ) ; Class < ? > [ ] invokeTypes = invokeContext . getParameterTypes ( ) ; Class < ? > [ ] methodParameterTypes = new Class < ? > [ invokeTypes . length ] ; for ( int i = <NUM_LIT> ; i < methodParameterTypes . length ; i ++ ) { Annotation [ ] annotations = invokeAnnotations [ i ] ; ParameterName parameterNameAnnotation = null ; ParameterType parameterTypeAnnotation = null ; if ( annotations != null ) { for ( Annotation annotation : annotations ) { if ( annotation instanceof ParameterName ) { parameterNameAnnotation = ( ParameterName ) annotation ; break ; } else if ( annotation instanceof ParameterType ) { parameterTypeAnnotation = ( ParameterType ) annotation ; break ; } } } Class < ? > parameterClass = null ; if ( parameterNameAnnotation != null ) { String className = parameterNameAnnotation . value ( ) ; if ( ! TextUtils . isEmpty ( className ) ) { try { parameterClass = Class . forName ( className ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } else if ( parameterTypeAnnotation != null ) { parameterClass = parameterTypeAnnotation . value ( ) ; } if ( parameterClass == null ) { parameterClass = invokeTypes [ i ] ; } methodParameterTypes [ i ] = parameterClass ; } return methodParameterTypes ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; import java . util . Map ; public interface UploadResourceResultCallback { void success ( Map resultData ) ; void error ( String message ) ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; import android . app . DatePickerDialog ; import android . app . Dialog ; import android . app . TimePickerDialog ; import android . content . res . Configuration ; import android . text . format . DateFormat ; import android . widget . Button ; import android . widget . DatePicker ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; public class DatetimePicker { private final DatetimePickerPlugin plugin ; private final DatetimePickerConfig config ; public DatetimePicker ( DatetimePickerPlugin plugin , DatetimePickerConfig config ) { this . plugin = plugin ; this . config = config ; } public void presentDateTimePicker ( Date date , @ Nullable Date minDate , @ Nullable Date maxDate , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { PresentResultCallback dateResultCallback = new PresentResultCallback ( ) ; dateResultCallback . setSuccessListener ( selectedDate -> { PresentResultCallback timeResultCallback = new PresentResultCallback ( ) ; timeResultCallback . setSuccessListener ( ( Date selectedDateAndTime ) -> resultCallback . success ( selectedDateAndTime ) ) ; timeResultCallback . setCancelListener ( ( ) -> resultCallback . cancel ( ) ) ; timeResultCallback . setDismissListener ( ( ) -> resultCallback . dismiss ( ) ) ; presentTimePicker ( selectedDate , locale , cancelButtonText , doneButtonText , theme , timeResultCallback , androidDatePickerMode , androidTimePickerMode ) ; } ) ; dateResultCallback . setCancelListener ( ( ) -> resultCallback . cancel ( ) ) ; dateResultCallback . setDismissListener ( ( ) -> resultCallback . dismiss ( ) ) ; presentDatePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , dateResultCallback , androidDatePickerMode , androidTimePickerMode ) ; } public void presentDatePicker ( Date date , @ Nullable Date minDate , @ Nullable Date maxDate , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { if ( locale != null ) { this . updateLocaleConfiguration ( locale ) ; } Calendar calendar = this . createCalendarFromDate ( date ) ; final DatePickerDialog dialog = new DatePickerDialog ( plugin . getContext ( ) , getTheme ( theme , androidDatePickerMode , androidTimePickerMode ) , ( view , year , month , dayOfMonth ) -> { calendar . set ( year , month , dayOfMonth ) ; resultCallback . success ( calendar . getTime ( ) ) ; } , calendar . get ( Calendar . YEAR ) , calendar . get ( Calendar . MONTH ) , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; dialog . setOnDismissListener ( _dialog -> resultCallback . dismiss ( ) ) ; dialog . create ( ) ; Button doneButton = dialog . getButton ( Dialog . BUTTON_POSITIVE ) ; doneButton . setText ( doneButtonText ) ; Button cancelButton = dialog . getButton ( Dialog . BUTTON_NEGATIVE ) ; cancelButton . setText ( cancelButtonText ) ; cancelButton . setOnClickListener ( view -> { resultCallback . cancel ( ) ; dialog . dismiss ( ) ; } ) ; DatePicker picker = dialog . getDatePicker ( ) ; if ( minDate != null ) { picker . setMinDate ( minDate . getTime ( ) ) ; } if ( maxDate != null ) { picker . setMaxDate ( maxDate . getTime ( ) ) ; } dialog . show ( ) ; } public void presentTimePicker ( Date date , @ Nullable Locale locale , String cancelButtonText , String doneButtonText , @ Nullable String theme , final PresentResultCallback resultCallback , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { if ( locale != null ) { this . updateLocaleConfiguration ( locale ) ; } Calendar calendar = this . createCalendarFromDate ( date ) ; boolean is24HourView = DateFormat . is24HourFormat ( plugin . getContext ( ) ) ; if ( locale != null ) { is24HourView = DatetimePickerHelper . is24HourLocale ( locale ) ; } final TimePickerDialog dialog = new TimePickerDialog ( plugin . getContext ( ) , getTheme ( theme , androidDatePickerMode , androidTimePickerMode ) , ( view , hourOfDay , minute ) -> { calendar . set ( calendar . get ( Calendar . YEAR ) , calendar . get ( Calendar . MONTH ) , calendar . get ( Calendar . DAY_OF_MONTH ) , hourOfDay , minute ) ; resultCallback . success ( calendar . getTime ( ) ) ; } , calendar . get ( Calendar . HOUR_OF_DAY ) , calendar . get ( Calendar . MINUTE ) , is24HourView ) ; dialog . setOnDismissListener ( _dialog -> resultCallback . dismiss ( ) ) ;", "output": "dialog . create ( ) ; Button doneButton = dialog . getButton ( Dialog . BUTTON_POSITIVE ) ; doneButton . setText ( doneButtonText ) ; Button cancelButton = dialog . getButton ( Dialog . BUTTON_NEGATIVE ) ; cancelButton . setText ( cancelButtonText ) ; cancelButton . setOnClickListener ( view -> { resultCallback . cancel ( ) ; dialog . dismiss ( ) ; } ) ; dialog . show ( ) ; } private Calendar createCalendarFromDate ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } private int getTheme ( @ Nullable String unconvertedTheme , @ Nullable AndroidDatePickerMode androidDatePickerMode , @ Nullable AndroidTimePickerMode androidTimePickerMode ) { Theme theme = config . getTheme ( ) ; Theme overrideConfig = DatetimePickerHelper . convertStringToTheme ( unconvertedTheme ) ; if ( overrideConfig != null ) { theme = overrideConfig ; } if ( androidDatePickerMode != AndroidDatePickerMode . SPINNER && androidTimePickerMode != AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme ; case DARK : return R . style . MaterialDarkTheme ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme ; } } } } if ( androidDatePickerMode == AndroidDatePickerMode . SPINNER && androidTimePickerMode != AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_DatePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_DatePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_DatePickerStyleSpinner ; } } } } if ( androidDatePickerMode != AndroidDatePickerMode . SPINNER && androidTimePickerMode == AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_TimePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_TimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_TimePickerStyleSpinner ; } } } } if ( androidDatePickerMode == AndroidDatePickerMode . SPINNER && androidTimePickerMode == AndroidTimePickerMode . SPINNER ) { switch ( theme ) { case LIGHT : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; case DARK : return R . style . MaterialDarkTheme_DateTimePickerStyleSpinner ; case AUTO : { int nightModeFlags = plugin . getContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; switch ( nightModeFlags ) { case Configuration . UI_MODE_NIGHT_YES : return R . style . MaterialDarkTheme_DateTimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_NO : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; case Configuration . UI_MODE_NIGHT_UNDEFINED : return R . style . MaterialLightTheme_DateTimePickerStyleSpinner ; } } } } return R . style . MaterialLightTheme ; } private void updateLocaleConfiguration ( @ NonNull Locale locale ) { Configuration config = new Configuration ( ) ; config . locale = locale ; plugin . getContext ( ) . getResources ( ) . updateConfiguration ( config , plugin . getContext ( ) . getResources ( ) . getDisplayMetrics ( ) ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import androidx . annotation . NonNull ; import java . util . HashSet ; public class DelMessageStore extends SQLiteOpenHelper { private static DelMessageStore mInstance ; private DelMessageStore ( @ NonNull Context context ) { super ( context , \"<STR_LIT>\" , null , <NUM_LIT> ) ; } public static DelMessageStore getInstance ( Context ctx ) { synchronized ( DelMessageStore . class ) { if ( mInstance == null || ! mInstance . getWritableDatabase ( ) . isOpen ( ) ) { mInstance = new DelMessageStore ( ctx ) ; } } return mInstance ; } @ Override public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { if ( oldVersion < <NUM_LIT> ) { if ( ! checkColumnExists ( sqLiteDatabase , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) { sqLiteDatabase . execSQL ( \"<STR_LIT>\" ) ; } } } public void insertMessage ( String jid , String msgid , long timestamp ) { try ( SQLiteDatabase dbWrite = this . getWritableDatabase ( ) ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , jid ) ; values . put ( \"<STR_LIT>\" , msgid ) ; values . put ( \"<STR_LIT>\" , timestamp ) ;", "output": "dbWrite . insert ( \"<STR_LIT>\" , null , values ) ; } } public HashSet < String > getMessagesByJid ( String jid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; Cursor query = dbReader . query ( \"<STR_LIT>\" , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } , \"<STR_LIT>\" , new String [ ] { jid } , null , null , null ) ; HashSet < String > messages = new HashSet < > ( ) ; try { if ( query . moveToFirst ( ) ) { do { messages . add ( query . getString ( query . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ) ; } while ( query . moveToNext ( ) ) ; } } finally { query . close ( ) ; dbReader . close ( ) ; } return messages ; } @ Override public void onCreate ( SQLiteDatabase sqLiteDatabase ) { sqLiteDatabase . execSQL ( \"<STR_LIT>\" ) ; } public long getTimestampByMessageId ( String msgid ) { SQLiteDatabase dbReader = this . getReadableDatabase ( ) ; try ( dbReader ; Cursor query = dbReader . query ( \"<STR_LIT>\" , new String [ ] { \"<STR_LIT>\" } , \"<STR_LIT>\" , new String [ ] { msgid } , null , null , null ) ) { if ( query . moveToFirst ( ) ) { return query . getLong ( query . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; } return <NUM_LIT> ; } } private boolean checkColumnExists ( SQLiteDatabase db , String tableName , String columnName ) { try ( Cursor cursor = db . rawQuery ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" , null ) ) { if ( cursor != null ) { int nameIndex = cursor . getColumnIndex ( \"<STR_LIT>\" ) ; while ( cursor . moveToNext ( ) ) { String currentColumnName = cursor . getString ( nameIndex ) ; if ( columnName . equals ( currentColumnName ) ) { return true ; } } } } catch ( Exception ignored ) { } return false ; } }"}, {"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import external . org . apache . commons . lang3 . ArrayUtils ; public class HashCodeBuilder implements Builder < Integer > { private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static Set < IDKey > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry != null && registry . contains ( new IDKey ( value ) ) ; } private static void reflectionAppend ( Object object , Class < ? > clazz , HashCodeBuilder builder , boolean useTransients , String [ ] excludeFields ) { if ( isRegistered ( object ) ) { return ; } try { register ( object ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field field : fields ) { if ( ! ArrayUtils . contains ( excludeFields , field . getName ( ) ) && ( field . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( field . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) ) { try { Object fieldValue = field . get ( object ) ; builder . append ( fieldValue ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( \"<STR_LIT>\" ) ; } } } } finally { unregister ( object ) ; } } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object ) { return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object , boolean testTransients ) { return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass , String ... excludeFields ) { if ( object == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } HashCodeBuilder builder = new HashCodeBuilder ( initialNonZeroOddNumber , multiplierNonZeroOddNumber ) ; Class < ? > clazz = object . getClass ( ) ; reflectionAppend ( object , clazz , builder , testTransients , excludeFields ) ; while ( clazz . getSuperclass ( ) != null && clazz != reflectUpToClass ) { clazz = clazz . getSuperclass ( ) ; reflectionAppend ( object , clazz , builder , testTransients , excludeFields ) ; } return builder . toHashCode ( ) ; } public static int reflectionHashCode ( Object object , boolean testTransients ) { return reflectionHashCode ( <NUM_LIT> , <NUM_LIT> , object , testTransients , null ) ; } public static int reflectionHashCode ( Object object , Collection < String > excludeFields ) { return reflectionHashCode ( object , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static int reflectionHashCode ( Object object , String ... excludeFields ) { return reflectionHashCode ( <NUM_LIT> , <NUM_LIT> , object , false , null , excludeFields ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) == null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; if ( registry != null ) { registry . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { registry = getRegistry ( ) ; if ( registry != null && registry . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } private final int iConstant ; private int iTotal = <NUM_LIT> ; public HashCodeBuilder ( ) { iConstant = <NUM_LIT> ; iTotal = <NUM_LIT> ; } public HashCodeBuilder ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber ) { if ( initialNonZeroOddNumber == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( initialNonZeroOddNumber % <NUM_LIT> == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( multiplierNonZeroOddNumber == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( multiplierNonZeroOddNumber % <NUM_LIT> == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } iConstant = multiplierNonZeroOddNumber ; iTotal = initialNonZeroOddNumber ; } public HashCodeBuilder append ( boolean value ) { iTotal = iTotal * iConstant + ( value ? <NUM_LIT> : <NUM_LIT> ) ; return this ; } public HashCodeBuilder append ( boolean [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( boolean element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( byte value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( byte [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( byte element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( char value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( char [ ] array ) { if ( array == null ) {", "output": "iTotal = iTotal * iConstant ; } else { for ( char element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( double value ) { return append ( Double . doubleToLongBits ( value ) ) ; } public HashCodeBuilder append ( double [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( double element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( float value ) { iTotal = iTotal * iConstant + Float . floatToIntBits ( value ) ; return this ; } public HashCodeBuilder append ( float [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( float element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( int value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( int [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( int element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( long value ) { iTotal = iTotal * iConstant + ( ( int ) ( value ^ ( value > > <NUM_LIT> ) ) ) ; return this ; } public HashCodeBuilder append ( long [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( long element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( Object object ) { if ( object == null ) { iTotal = iTotal * iConstant ; } else { if ( object . getClass ( ) . isArray ( ) ) { if ( object instanceof long [ ] ) { append ( ( long [ ] ) object ) ; } else if ( object instanceof int [ ] ) { append ( ( int [ ] ) object ) ; } else if ( object instanceof short [ ] ) { append ( ( short [ ] ) object ) ; } else if ( object instanceof char [ ] ) { append ( ( char [ ] ) object ) ; } else if ( object instanceof byte [ ] ) { append ( ( byte [ ] ) object ) ; } else if ( object instanceof double [ ] ) { append ( ( double [ ] ) object ) ; } else if ( object instanceof float [ ] ) { append ( ( float [ ] ) object ) ; } else if ( object instanceof boolean [ ] ) { append ( ( boolean [ ] ) object ) ; } else { append ( ( Object [ ] ) object ) ; } } else { iTotal = iTotal * iConstant + object . hashCode ( ) ; } } return this ; } public HashCodeBuilder append ( Object [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( Object element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder append ( short value ) { iTotal = iTotal * iConstant + value ; return this ; } public HashCodeBuilder append ( short [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( short element : array ) { append ( element ) ; } } return this ; } public HashCodeBuilder appendSuper ( int superHashCode ) { iTotal = iTotal * iConstant + superHashCode ; return this ; } public int toHashCode ( ) { return iTotal ; } public Integer build ( ) { return Integer . valueOf ( toHashCode ( ) ) ; } @ Override public int hashCode ( ) { return toHashCode ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . utils ; import android . graphics . Color ; import java . util . HashMap ; public class IColors { public static HashMap < String , String > colors = new HashMap < > ( ) ; static { colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; colors . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static int parseColor ( String str ) { return Color . parseColor ( str ) ; } public static String toString ( int i ) { return \"<STR_LIT>\" + Integer . toHexString ( i ) ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . view . View ; import android . widget . Button ; import android . widget . CompoundButton ; import android . widget . ImageView ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import com . google . android . material . materialswitch . MaterialSwitch ; import com . simon . harmonichackernews . utils . ThemeUtils ; public class WelcomeActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_welcome ) ; ImageView favicon = findViewById ( R . id . story_meta_favicon ) ; TextView index = findViewById ( R . id . story_index ) ; TextView meta = findViewById ( R . id . story_meta ) ; Button materialDaynightButton = findViewById ( R . id . welcome_button_material_daynight ) ; Button materialDarkButton = findViewById ( R . id . welcome_button_material_dark ) ; Button materialLightButton = findViewById ( R . id . welcome_button_material_light ) ; Button darkButton = findViewById ( R . id . welcome_button_dark ) ; Button grayButton = findViewById ( R . id . welcome_button_gray ) ; Button blackButton = findViewById ( R . id . welcome_button_black ) ; Button lightButton = findViewById ( R . id . welcome_button_light ) ; Button whiteButton = findViewById ( R . id . welcome_button_white ) ; favicon . setImageResource ( R . drawable . quanta ) ; MaterialSwitch thumbnailSwitch = findViewById ( R . id . welcome_switch_thumbnails ) ; MaterialSwitch pointsSwitch = findViewById ( R . id . welcome_switch_points ) ; MaterialSwitch indexSwitch = findViewById ( R . id . welcome_switch_index ) ; thumbnailSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) {", "output": "@ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { favicon . setVisibility ( b ? View . VISIBLE : View . GONE ) ; setBooleanSetting ( compoundButton . getContext ( ) , \"<STR_LIT>\" , b ) ; } } ) ; indexSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { index . setVisibility ( b ? View . VISIBLE : View . GONE ) ; setBooleanSetting ( compoundButton . getContext ( ) , \"<STR_LIT>\" , b ) ; } } ) ; pointsSwitch . setOnCheckedChangeListener ( new CompoundButton . OnCheckedChangeListener ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onCheckedChanged ( CompoundButton compoundButton , boolean b ) { meta . setText ( ( b ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; setBooleanSetting ( compoundButton . getContext ( ) , \"<STR_LIT>\" , b ) ; } } ) ; View . OnClickListener buttonClickListener = new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { setSetting ( view . getContext ( ) , \"<STR_LIT>\" , ( String ) view . getTag ( ) ) ; restartActivity ( ) ; } } ; materialDaynightButton . setOnClickListener ( buttonClickListener ) ; materialDarkButton . setOnClickListener ( buttonClickListener ) ; materialLightButton . setOnClickListener ( buttonClickListener ) ; darkButton . setOnClickListener ( buttonClickListener ) ; grayButton . setOnClickListener ( buttonClickListener ) ; blackButton . setOnClickListener ( buttonClickListener ) ; lightButton . setOnClickListener ( buttonClickListener ) ; whiteButton . setOnClickListener ( buttonClickListener ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void setSetting ( Context ctx , String key , String newTheme ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; prefs . edit ( ) . putString ( key , newTheme ) . commit ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void setBooleanSetting ( Context ctx , String key , boolean newVal ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; prefs . edit ( ) . putBoolean ( key , newVal ) . commit ( ) ; } private void restartActivity ( ) { Intent intent = new Intent ( this , WelcomeActivity . class ) ; startActivity ( intent ) ; finish ( ) ; } public void done ( View view ) { startActivity ( new Intent ( this , MainActivity . class ) ) ; finish ( ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . managedconfigurations ; import android . content . RestrictionsManager ; import android . os . Bundle ; import com . getcapacitor . Bridge ; public class ManagedConfigurations { private RestrictionsManager myRestrictionsMgr ; private Bundle appRestrictions ; ManagedConfigurations ( Bridge bridge ) { myRestrictionsMgr = ( RestrictionsManager ) bridge . getActivity ( ) . getSystemService ( bridge . getContext ( ) . RESTRICTIONS_SERVICE ) ; this . refreshApplicationRestrictions ( ) ; } public void refreshApplicationRestrictions ( ) { appRestrictions = myRestrictionsMgr . getApplicationRestrictions ( ) ; } public String getString ( String key ) {", "output": "if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getString ( key ) ; } return null ; } public Integer getInteger ( String key ) { if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getInt ( key ) ; } return null ; } public Boolean getBoolean ( String key ) { if ( appRestrictions . containsKey ( key ) ) { return appRestrictions . getBoolean ( key ) ; } return null ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . view . View ; import androidx . annotation . Nullable ; public interface OnClickATagListener {", "output": "boolean onClick ( View widget , String spannedText , @ Nullable String href ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; import androidx . annotation . Nullable ; import java . util . Date ; public class PresentResultCallback { interface SuccessListener { void onSuccess ( Date date ) ; } interface CancelListener { void onCancel ( ) ; } interface DismissListener { void onDismiss ( ) ; } @ Nullable private SuccessListener successListener ; @ Nullable private CancelListener cancelListener ; @ Nullable private DismissListener dismissListener ; public void setSuccessListener ( @ Nullable SuccessListener listener ) { this . successListener = listener ; } public void setCancelListener ( @ Nullable CancelListener listener ) { this . cancelListener = listener ; } public void setDismissListener ( @ Nullable DismissListener listener ) { this . dismissListener = listener ; } public void success ( Date date ) { if ( successListener != null ) { successListener . onSuccess ( date ) ; } this . removeAllListener ( ) ; } public void cancel ( ) { if ( cancelListener != null ) { cancelListener . onCancel ( ) ; } this . removeAllListener ( ) ; } public void dismiss ( ) { if ( dismissListener != null ) { dismissListener . onDismiss ( ) ; } this . removeAllListener ( ) ; } private void removeAllListener ( ) { successListener = null ; cancelListener = null ; dismissListener = null ;", "output": "} }"}, {"input": "package io . capawesome . capacitorjs . plugins . filepicker ; public class FileResolution { public int height ; public int width ; public FileResolution ( int height , int width ) { this . height = height ; this . width = width ;", "output": "} }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import okhttp3 . OkHttpClient ; import okhttp3 . ResponseBody ; import retrofit2 . Response ; public class OkHttpUtil { private static OkHttpClient okHttpClient ; public static synchronized OkHttpClient getHttpClient ( ) { if ( okHttpClient == null ) { okHttpClient = new OkHttpClient . Builder ( ) . addInterceptor ( new LoggerInterceptor ( ) ) . build ( ) ; } return okHttpClient ; } public static void respNotNull ( GeneralResponse < ? > generalResponse ) throws IOException { if ( generalResponse == null ) { throw new IOException ( \"<STR_LIT>\" ) ; } } public static void respNotNull ( ResponseBody resp ) throws IOException { if ( resp == null ) {", "output": "throw new IOException ( \"<STR_LIT>\" ) ; } } public static < T > GeneralResponse < T > getBody ( Response < GeneralResponse < T > > response ) throws IOException { if ( response . isSuccessful ( ) ) { return response . body ( ) ; } else { throw new IOException ( \"<STR_LIT>\" + response . code ( ) ) ; } } }"}, {"input": "package com . skythinker . gptassistant ; public abstract class AsrClientBase { public interface IAsrCallback {", "output": "void onError ( String msg ) ; void onResult ( String result ) ; void onAutoStop ( ) ; } public abstract void startRecognize ( ) ; public abstract void stopRecognize ( ) ; public abstract void cancelRecognize ( ) ; public abstract void setCallback ( IAsrCallback callback ) ; public abstract void setParam ( String key , Object value ) ; public abstract void setEnableAutoStop ( boolean enable ) ; public abstract void destroy ( ) ; }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . animation . Animator ; import android . animation . AnimatorListenerAdapter ; import android . animation . TimeInterpolator ; import android . animation . ValueAnimator ; import android . annotation . SuppressLint ; import android . view . View ; import android . view . ViewPropertyAnimator ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import java . util . ArrayList ; import java . util . List ; public class DefaultItemAnimator extends SimpleItemAnimator { private static final boolean DEBUG = false ; private static TimeInterpolator sDefaultInterpolator ; private ArrayList < RecyclerView . ViewHolder > mPendingRemovals = new ArrayList < > ( ) ; private ArrayList < RecyclerView . ViewHolder > mPendingAdditions = new ArrayList < > ( ) ; private ArrayList < MoveInfo > mPendingMoves = new ArrayList < > ( ) ; private ArrayList < ChangeInfo > mPendingChanges = new ArrayList < > ( ) ; ArrayList < ArrayList < RecyclerView . ViewHolder > > mAdditionsList = new ArrayList < > ( ) ; ArrayList < ArrayList < MoveInfo > > mMovesList = new ArrayList < > ( ) ; ArrayList < ArrayList < ChangeInfo > > mChangesList = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mAddAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mMoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mRemoveAnimations = new ArrayList < > ( ) ; ArrayList < RecyclerView . ViewHolder > mChangeAnimations = new ArrayList < > ( ) ; private static class MoveInfo { public RecyclerView . ViewHolder holder ; public int fromX , fromY , toX , toY ; MoveInfo ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { this . holder = holder ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } } private static class ChangeInfo { public RecyclerView . ViewHolder oldHolder , newHolder ; public int fromX , fromY , toX , toY ; private ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder ) { this . oldHolder = oldHolder ; this . newHolder = newHolder ; } ChangeInfo ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromX , int fromY , int toX , int toY ) { this ( oldHolder , newHolder ) ; this . fromX = fromX ; this . fromY = fromY ; this . toX = toX ; this . toY = toY ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + newHolder + \"<STR_LIT>\" + fromX + \"<STR_LIT>\" + fromY + \"<STR_LIT>\" + toX + \"<STR_LIT>\" + toY + '<STR_LIT>' ; } } @ Override public void runPendingAnimations ( ) { boolean removalsPending = ! mPendingRemovals . isEmpty ( ) ; boolean movesPending = ! mPendingMoves . isEmpty ( ) ; boolean changesPending = ! mPendingChanges . isEmpty ( ) ; boolean additionsPending = ! mPendingAdditions . isEmpty ( ) ; if ( ! removalsPending && ! movesPending && ! additionsPending && ! changesPending ) { return ; } for ( RecyclerView . ViewHolder holder : mPendingRemovals ) { animateRemoveImpl ( holder ) ; } mPendingRemovals . clear ( ) ; if ( movesPending ) { final ArrayList < MoveInfo > moves = new ArrayList < > ( ) ; moves . addAll ( mPendingMoves ) ; mMovesList . add ( moves ) ; mPendingMoves . clear ( ) ; Runnable mover = new Runnable ( ) { @ Override public void run ( ) { for ( MoveInfo moveInfo : moves ) { animateMoveImpl ( moveInfo . holder , moveInfo . fromX , moveInfo . fromY , moveInfo . toX , moveInfo . toY ) ; } moves . clear ( ) ; mMovesList . remove ( moves ) ; } } ; if ( removalsPending ) { View view = moves . get ( <NUM_LIT> ) . holder . itemView ; ViewCompat . postOnAnimationDelayed ( view , mover , getRemoveDuration ( ) ) ; } else { mover . run ( ) ; } } if ( changesPending ) { final ArrayList < ChangeInfo > changes = new ArrayList < > ( ) ; changes . addAll ( mPendingChanges ) ; mChangesList . add ( changes ) ; mPendingChanges . clear ( ) ; Runnable changer = new Runnable ( ) { @ Override public void run ( ) { for ( ChangeInfo change : changes ) { animateChangeImpl ( change ) ; } changes . clear ( ) ; mChangesList . remove ( changes ) ; } } ; if ( removalsPending ) { RecyclerView . ViewHolder holder = changes . get ( <NUM_LIT> ) . oldHolder ; ViewCompat . postOnAnimationDelayed ( holder . itemView , changer , getRemoveDuration ( ) ) ; } else { changer . run ( ) ; } } if ( additionsPending ) { final ArrayList < RecyclerView . ViewHolder > additions = new ArrayList < > ( ) ; additions . addAll ( mPendingAdditions ) ; mAdditionsList . add ( additions ) ; mPendingAdditions . clear ( ) ; Runnable adder = new Runnable ( ) { @ Override public void run ( ) { for ( RecyclerView . ViewHolder holder : additions ) { animateAddImpl ( holder ) ; } additions . clear ( ) ; mAdditionsList . remove ( additions ) ; } } ; if ( removalsPending || movesPending || changesPending ) { long removeDuration = removalsPending ? getRemoveDuration ( ) : <NUM_LIT> ; long moveDuration = movesPending ? getMoveDuration ( ) : <NUM_LIT> ; long changeDuration = changesPending ? getChangeDuration ( ) : <NUM_LIT> ; long totalDelay = removeDuration + Math . max ( moveDuration , changeDuration ) ; View view = additions . get ( <NUM_LIT> ) . itemView ; ViewCompat . postOnAnimationDelayed ( view , adder , totalDelay ) ; } else { adder . run ( ) ; } } } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateRemove ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; mPendingRemovals . add ( holder ) ; return true ; } private void animateRemoveImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mRemoveAnimations . add ( holder ) ; animation . setDuration ( getRemoveDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchRemoveStarting ( holder ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( holder ) ; mRemoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateAdd ( final RecyclerView . ViewHolder holder ) { resetAnimation ( holder ) ; holder . itemView . setAlpha ( <NUM_LIT> ) ; mPendingAdditions . add ( holder ) ; return true ; } void animateAddImpl ( final RecyclerView . ViewHolder holder ) { final View view = holder . itemView ; final ViewPropertyAnimator animation = view . animate ( ) ; mAddAnimations . add ( holder ) ; animation . alpha ( <NUM_LIT> ) . setDuration ( getAddDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchAddStarting ( holder ) ; } @ Override public void onAnimationCancel ( Animator animator ) { view . setAlpha ( <NUM_LIT> ) ; } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchAddFinished ( holder ) ; mAddAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateMove ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; fromX += ( int ) holder . itemView . getTranslationX ( ) ; fromY += ( int ) holder . itemView . getTranslationY ( ) ; resetAnimation ( holder ) ; int deltaX = toX - fromX ; int deltaY = toY - fromY ; if ( deltaX == <NUM_LIT> && deltaY == <NUM_LIT> ) { dispatchMoveFinished ( holder ) ; return false ; } if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( - deltaX ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( - deltaY ) ; } mPendingMoves . add ( new MoveInfo ( holder , fromX , fromY , toX , toY ) ) ; return true ; } void animateMoveImpl ( final RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) { final View view = holder . itemView ; final int deltaX = toX - fromX ; final int deltaY = toY - fromY ; if ( deltaX != <NUM_LIT> ) { view . animate ( ) . translationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . animate ( ) . translationY ( <NUM_LIT> ) ; } final ViewPropertyAnimator animation = view . animate ( ) ; mMoveAnimations . add ( holder ) ; animation . setDuration ( getMoveDuration ( ) ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchMoveStarting ( holder ) ; }", "output": "@ Override public void onAnimationCancel ( Animator animator ) { if ( deltaX != <NUM_LIT> ) { view . setTranslationX ( <NUM_LIT> ) ; } if ( deltaY != <NUM_LIT> ) { view . setTranslationY ( <NUM_LIT> ) ; } } @ Override public void onAnimationEnd ( Animator animator ) { animation . setListener ( null ) ; dispatchMoveFinished ( holder ) ; mMoveAnimations . remove ( holder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) { if ( oldHolder == newHolder ) { return animateMove ( oldHolder , fromLeft , fromTop , toLeft , toTop ) ; } final float prevTranslationX = oldHolder . itemView . getTranslationX ( ) ; final float prevTranslationY = oldHolder . itemView . getTranslationY ( ) ; final float prevAlpha = oldHolder . itemView . getAlpha ( ) ; resetAnimation ( oldHolder ) ; int deltaX = ( int ) ( toLeft - fromLeft - prevTranslationX ) ; int deltaY = ( int ) ( toTop - fromTop - prevTranslationY ) ; oldHolder . itemView . setTranslationX ( prevTranslationX ) ; oldHolder . itemView . setTranslationY ( prevTranslationY ) ; oldHolder . itemView . setAlpha ( prevAlpha ) ; if ( newHolder != null ) { resetAnimation ( newHolder ) ; newHolder . itemView . setTranslationX ( - deltaX ) ; newHolder . itemView . setTranslationY ( - deltaY ) ; newHolder . itemView . setAlpha ( <NUM_LIT> ) ; } mPendingChanges . add ( new ChangeInfo ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ) ; return true ; } void animateChangeImpl ( final ChangeInfo changeInfo ) { final RecyclerView . ViewHolder holder = changeInfo . oldHolder ; final View view = holder == null ? null : holder . itemView ; final RecyclerView . ViewHolder newHolder = changeInfo . newHolder ; final View newView = newHolder != null ? newHolder . itemView : null ; if ( view != null ) { final ViewPropertyAnimator oldViewAnim = view . animate ( ) . setDuration ( getChangeDuration ( ) ) ; mChangeAnimations . add ( changeInfo . oldHolder ) ; oldViewAnim . translationX ( changeInfo . toX - changeInfo . fromX ) ; oldViewAnim . translationY ( changeInfo . toY - changeInfo . fromY ) ; oldViewAnim . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . oldHolder , true ) ; } @ Override public void onAnimationEnd ( Animator animator ) { oldViewAnim . setListener ( null ) ; view . setAlpha ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . oldHolder , true ) ; mChangeAnimations . remove ( changeInfo . oldHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } if ( newView != null ) { final ViewPropertyAnimator newViewAnimation = newView . animate ( ) ; mChangeAnimations . add ( changeInfo . newHolder ) ; newViewAnimation . translationX ( <NUM_LIT> ) . translationY ( <NUM_LIT> ) . setDuration ( getChangeDuration ( ) ) . alpha ( <NUM_LIT> ) . setListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationStart ( Animator animator ) { dispatchChangeStarting ( changeInfo . newHolder , false ) ; } @ Override public void onAnimationEnd ( Animator animator ) { newViewAnimation . setListener ( null ) ; newView . setAlpha ( <NUM_LIT> ) ; newView . setTranslationX ( <NUM_LIT> ) ; newView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( changeInfo . newHolder , false ) ; mChangeAnimations . remove ( changeInfo . newHolder ) ; dispatchFinishedWhenDone ( ) ; } } ) . start ( ) ; } } private void endChangeAnimation ( List < ChangeInfo > infoList , RecyclerView . ViewHolder item ) { for ( int i = infoList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ChangeInfo changeInfo = infoList . get ( i ) ; if ( endChangeAnimationIfNecessary ( changeInfo , item ) ) { if ( changeInfo . oldHolder == null && changeInfo . newHolder == null ) { infoList . remove ( changeInfo ) ; } } } } private void endChangeAnimationIfNecessary ( ChangeInfo changeInfo ) { if ( changeInfo . oldHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . oldHolder ) ; } if ( changeInfo . newHolder != null ) { endChangeAnimationIfNecessary ( changeInfo , changeInfo . newHolder ) ; } } private boolean endChangeAnimationIfNecessary ( ChangeInfo changeInfo , RecyclerView . ViewHolder item ) { boolean oldItem = false ; if ( changeInfo . newHolder == item ) { changeInfo . newHolder = null ; } else if ( changeInfo . oldHolder == item ) { changeInfo . oldHolder = null ; oldItem = true ; } else { return false ; } item . itemView . setAlpha ( <NUM_LIT> ) ; item . itemView . setTranslationX ( <NUM_LIT> ) ; item . itemView . setTranslationY ( <NUM_LIT> ) ; dispatchChangeFinished ( item , oldItem ) ; return true ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void endAnimation ( RecyclerView . ViewHolder item ) { final View view = item . itemView ; view . animate ( ) . cancel ( ) ; for ( int i = mPendingMoves . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo moveInfo = mPendingMoves . get ( i ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; mPendingMoves . remove ( i ) ; } } endChangeAnimation ( mPendingChanges , item ) ; if ( mPendingRemovals . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchRemoveFinished ( item ) ; } if ( mPendingAdditions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; } for ( int i = mChangesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; endChangeAnimation ( changes , item ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( i ) ; } } for ( int i = mMovesList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; for ( int j = moves . size ( ) - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; if ( moveInfo . holder == item ) { view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( i ) ; } break ; } } } for ( int i = mAdditionsList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; if ( additions . remove ( item ) ) { view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( i ) ; } } } if ( mRemoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mAddAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mChangeAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } if ( mMoveAnimations . remove ( item ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dispatchFinishedWhenDone ( ) ; } private void resetAnimation ( RecyclerView . ViewHolder holder ) { if ( sDefaultInterpolator == null ) { sDefaultInterpolator = new ValueAnimator ( ) . getInterpolator ( ) ; } holder . itemView . animate ( ) . setInterpolator ( sDefaultInterpolator ) ; endAnimation ( holder ) ; } @ Override public boolean isRunning ( ) { return ( ! mPendingAdditions . isEmpty ( ) || ! mPendingChanges . isEmpty ( ) || ! mPendingMoves . isEmpty ( ) || ! mPendingRemovals . isEmpty ( ) || ! mMoveAnimations . isEmpty ( ) || ! mRemoveAnimations . isEmpty ( ) || ! mAddAnimations . isEmpty ( ) || ! mChangeAnimations . isEmpty ( ) || ! mMovesList . isEmpty ( ) || ! mAdditionsList . isEmpty ( ) || ! mChangesList . isEmpty ( ) ) ; } void dispatchFinishedWhenDone ( ) { if ( ! isRunning ( ) ) { dispatchAnimationsFinished ( ) ; } } @ Override public void endAnimations ( ) { int count = mPendingMoves . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { MoveInfo item = mPendingMoves . get ( i ) ; View view = item . holder . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( item . holder ) ; mPendingMoves . remove ( i ) ; } count = mPendingRemovals . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingRemovals . get ( i ) ; dispatchRemoveFinished ( item ) ; mPendingRemovals . remove ( i ) ; } count = mPendingAdditions . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { RecyclerView . ViewHolder item = mPendingAdditions . get ( i ) ; item . itemView . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; mPendingAdditions . remove ( i ) ; } count = mPendingChanges . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { endChangeAnimationIfNecessary ( mPendingChanges . get ( i ) ) ; } mPendingChanges . clear ( ) ; if ( ! isRunning ( ) ) { return ; } int listCount = mMovesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < MoveInfo > moves = mMovesList . get ( i ) ; count = moves . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { MoveInfo moveInfo = moves . get ( j ) ; RecyclerView . ViewHolder item = moveInfo . holder ; View view = item . itemView ; view . setTranslationY ( <NUM_LIT> ) ; view . setTranslationX ( <NUM_LIT> ) ; dispatchMoveFinished ( moveInfo . holder ) ; moves . remove ( j ) ; if ( moves . isEmpty ( ) ) { mMovesList . remove ( moves ) ; } } } listCount = mAdditionsList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < RecyclerView . ViewHolder > additions = mAdditionsList . get ( i ) ; count = additions . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { RecyclerView . ViewHolder item = additions . get ( j ) ; View view = item . itemView ; view . setAlpha ( <NUM_LIT> ) ; dispatchAddFinished ( item ) ; additions . remove ( j ) ; if ( additions . isEmpty ( ) ) { mAdditionsList . remove ( additions ) ; } } } listCount = mChangesList . size ( ) ; for ( int i = listCount - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { ArrayList < ChangeInfo > changes = mChangesList . get ( i ) ; count = changes . size ( ) ; for ( int j = count - <NUM_LIT> ; j >= <NUM_LIT> ; j -- ) { endChangeAnimationIfNecessary ( changes . get ( j ) ) ; if ( changes . isEmpty ( ) ) { mChangesList . remove ( changes ) ; } } } cancelAll ( mRemoveAnimations ) ; cancelAll ( mMoveAnimations ) ; cancelAll ( mAddAnimations ) ; cancelAll ( mChangeAnimations ) ; dispatchAnimationsFinished ( ) ; } void cancelAll ( List < RecyclerView . ViewHolder > viewHolders ) { for ( int i = viewHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { viewHolders . get ( i ) . itemView . animate ( ) . cancel ( ) ; } } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull List < Object > payloads ) { return ! payloads . isEmpty ( ) || super . canReuseUpdatedViewHolder ( viewHolder , payloads ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . animation . DecelerateInterpolator ; import android . widget . Scroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SnapHelper extends RecyclerView . OnFlingListener { static final float MILLISECONDS_PER_INCH = <NUM_LIT> ; RecyclerView mRecyclerView ; private Scroller mGravityScroller ; private final RecyclerView . OnScrollListener mScrollListener = new RecyclerView . OnScrollListener ( ) { boolean mScrolled = false ; @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE && mScrolled ) { mScrolled = false ; snapToTargetExistingView ( ) ; } } @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { if ( dx != <NUM_LIT> || dy != <NUM_LIT> ) { mScrolled = true ; } } } ; @ Override public boolean onFling ( int velocityX , int velocityY ) { RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return false ; } RecyclerView . Adapter adapter = mRecyclerView . getAdapter ( ) ; if ( adapter == null ) { return false ; } int minFlingVelocity = mRecyclerView . getMinFlingVelocity ( ) ; return ( Math . abs ( velocityY ) > minFlingVelocity || Math . abs ( velocityX ) > minFlingVelocity ) && snapFromFling ( layoutManager , velocityX , velocityY ) ; } public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView == recyclerView ) { return ; } if ( mRecyclerView != null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView != null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } private void setupCallbacks ( ) throws IllegalStateException { if ( mRecyclerView . getOnFlingListener ( ) != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mRecyclerView . addOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( this ) ; } private void destroyCallbacks ( ) { mRecyclerView . removeOnScrollListener ( mScrollListener ) ; mRecyclerView . setOnFlingListener ( null ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public int [ ] calculateScrollDistance ( int velocityX , int velocityY ) { int [ ] outDist = new int [ <NUM_LIT> ] ; mGravityScroller . fling ( <NUM_LIT> , <NUM_LIT> , velocityX , velocityY , Integer . MIN_VALUE , Integer . MAX_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalX ( ) ; outDist [ <NUM_LIT> ] = mGravityScroller . getFinalY ( ) ; return outDist ; } private boolean snapFromFling ( @ NonNull RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return false ; } RecyclerView . SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller == null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition == RecyclerView . NO_POSITION ) { return false ;", "output": "} smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } void snapToTargetExistingView ( ) { if ( mRecyclerView == null ) { return ; } RecyclerView . LayoutManager layoutManager = mRecyclerView . getLayoutManager ( ) ; if ( layoutManager == null ) { return ; } View snapView = findSnapView ( layoutManager ) ; if ( snapView == null ) { return ; } int [ ] snapDistance = calculateDistanceToFinalSnap ( layoutManager , snapView ) ; if ( snapDistance [ <NUM_LIT> ] != <NUM_LIT> || snapDistance [ <NUM_LIT> ] != <NUM_LIT> ) { mRecyclerView . smoothScrollBy ( snapDistance [ <NUM_LIT> ] , snapDistance [ <NUM_LIT> ] ) ; } } @ Nullable protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { return createSnapScroller ( layoutManager ) ; } @ Nullable @ Deprecated protected LinearSmoothScroller createSnapScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( View targetView , RecyclerView . State state , Action action ) { if ( mRecyclerView == null ) { return ; } int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Nullable public abstract int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ Nullable @ SuppressLint ( \"<STR_LIT>\" ) public abstract View findSnapView ( RecyclerView . LayoutManager layoutManager ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . screenorientation ; import android . content . res . Configuration ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class ScreenOrientationPlugin extends Plugin { public static final String SCREEN_ORIENTATION_CHANGE_EVENT = \"<STR_LIT>\" ; private ScreenOrientation implementation ; @ Override public void load ( ) {", "output": "implementation = new ScreenOrientation ( getBridge ( ) ) ; implementation . setOrientationChangeListener ( this :: updateOrientation ) ; } @ Override public void handleOnConfigurationChanged ( Configuration newConfig ) { super . handleOnConfigurationChanged ( newConfig ) ; implementation . handleOnConfigurationChanged ( newConfig ) ; } @ PluginMethod public void lock ( PluginCall call ) { String orientationType = call . getString ( \"<STR_LIT>\" ) ; implementation . lock ( orientationType ) ; call . resolve ( ) ; } @ PluginMethod public void unlock ( PluginCall call ) { implementation . unlock ( ) ; call . resolve ( ) ; } @ PluginMethod public void getCurrentOrientation ( PluginCall call ) { JSObject ret = new JSObject ( ) ; String orientationType = implementation . getCurrentOrientationType ( ) ; ret . put ( \"<STR_LIT>\" , orientationType ) ; call . resolve ( ret ) ; } private void updateOrientation ( ) { JSObject ret = new JSObject ( ) ; String orientationType = implementation . getCurrentOrientationType ( ) ; ret . put ( \"<STR_LIT>\" , orientationType ) ; notifyListeners ( SCREEN_ORIENTATION_CHANGE_EVENT , ret ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . graphics . Bitmap ; import android . os . Handler ; import android . util . Log ; import android . view . View ; import android . webkit . RenderProcessGoneDetail ; import android . webkit . ValueCallback ; import android . webkit . WebResourceError ; import android . webkit . WebResourceRequest ; import android . webkit . WebSettings ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . LinearLayout ; import java . util . Arrays ; import java . util . List ; public class WebScraper { public interface Callback { void onLoadResult ( String result ) ; void onLoadFail ( String message ) ; } private class WebsiteRule { public String urlPattern = \"<STR_LIT>\" ; public String jsCode = \"<STR_LIT>\" ; public boolean desktopMode = false ; public int extraDelay = <NUM_LIT> ; public int timeout = <NUM_LIT> ; public WebsiteRule url ( String url ) { this . urlPattern = url ; return this ; } public WebsiteRule js ( String js ) { this . jsCode = js ; return this ; } public WebsiteRule desktopMode ( boolean desktopMode ) { this . desktopMode = desktopMode ; return this ; } public WebsiteRule extraDelay ( int extraDelay ) { this . extraDelay = extraDelay ; return this ; } public WebsiteRule timeout ( int timeout ) { this . timeout = timeout ; return this ; } } private class SearchListJsBuilder { private String outerSelector = \"<STR_LIT>\" ; private boolean outerAsInner = false ; private String innerSelector = \"<STR_LIT>\" ; private int innerIndex = <NUM_LIT> ; private String innerProperty = \"<STR_LIT>\" ; private int maxTextLength = Integer . MAX_VALUE ; private int maxLinkLength = Integer . MAX_VALUE ; public SearchListJsBuilder outerSelector ( String outerSelector ) { this . outerSelector = outerSelector ; return this ; } public SearchListJsBuilder outerAsInner ( boolean outerAsInner ) { this . outerAsInner = outerAsInner ; return this ; } public SearchListJsBuilder innerSelector ( String innerSelector ) { this . innerSelector = innerSelector ; return this ; } public SearchListJsBuilder innerIndex ( int innerIndex ) { this . innerIndex = innerIndex ; return this ; } public SearchListJsBuilder innerProperty ( String innerProperty ) { this . innerProperty = innerProperty ; return this ; } public SearchListJsBuilder maxTextLength ( int maxTextLength ) { this . maxTextLength = maxTextLength ; return this ; } public SearchListJsBuilder maxLinkLength ( int maxLinkLength ) { this . maxLinkLength = maxLinkLength ; return this ; } public String build ( ) { String js = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; return js . replaceAll ( \"<STR_LIT>\" , outerSelector ) . replaceAll ( \"<STR_LIT>\" , String . valueOf ( outerAsInner ) ) . replaceAll ( \"<STR_LIT>\" , innerSelector ) . replaceAll ( \"<STR_LIT>\" , String . valueOf ( innerIndex ) ) . replaceAll ( \"<STR_LIT>\" , innerProperty ) . replaceAll ( \"<STR_LIT>\" , String . valueOf ( maxTextLength ) ) . replaceAll ( \"<STR_LIT>\" , String . valueOf ( maxLinkLength ) ) ; } } List < WebsiteRule > websiteRules = Arrays . asList ( new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . innerSelector ( \"<STR_LIT>\" ) . innerProperty ( \"<STR_LIT>\" ) . maxLinkLength ( <NUM_LIT> ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . outerAsInner ( true ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . outerAsInner ( true ) . maxTextLength ( <NUM_LIT> ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . extraDelay ( <NUM_LIT> ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . desktopMode ( true ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) . url ( \"<STR_LIT>\" ) . extraDelay ( <NUM_LIT> ) . js ( new SearchListJsBuilder ( ) . outerSelector ( \"<STR_LIT>\" ) . build ( ) ) , new WebsiteRule ( ) ) ; Handler handler = null ; private WebView webView = null ; private WebViewClient webViewClient = null ; private String loadingUrl = \"<STR_LIT>\" ; private Callback callback = null ; private boolean isLoading = false ; private int jumpCount = <NUM_LIT> ; WebsiteRule websiteRule = null ; public WebScraper ( Context context , LinearLayout parentLayout ) { handler = new Handler ( context . getMainLooper ( ) ) ; webViewClient = new WebViewClient ( ) { private void endLoading ( ) { callback = null ; isLoading = false ; jumpCount = <NUM_LIT> ; loadingUrl = \"<STR_LIT>\" ; webView . stopLoading ( ) ; } @ Override public boolean shouldOverrideUrlLoading ( WebView view , WebResourceRequest request ) { String url = request . getUrl ( ) . toString ( ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + url ) ; if ( url . startsWith ( \"<STR_LIT>\" ) || url . startsWith ( \"<STR_LIT>\" ) || ! url . contains ( \"<STR_LIT>\" ) ) { view . loadUrl ( url ) ; jumpCount ++ ; loadingUrl = url ; } return true ; } @ Override public void onPageStarted ( WebView view , String url , Bitmap favicon ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; super . onPageStarted ( view , url , favicon ) ; } @ Override public void onPageFinished ( WebView view , String url ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + url ) ; if ( jumpCount == <NUM_LIT> || url . equals ( loadingUrl ) ) { handler . postDelayed ( ( ) -> { if ( callback != null ) { webView . evaluateJavascript ( websiteRule . jsCode , new ValueCallback < String > ( ) { @ Override public void onReceiveValue ( String responseText ) { responseText = responseText . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( responseText . length ( ) > GlobalDataHolder . getWebMaxCharCount ( ) ) responseText = responseText . substring ( <NUM_LIT> , GlobalDataHolder . getWebMaxCharCount ( ) ) ; if ( responseText . isEmpty ( ) ) responseText = \"<STR_LIT>\" ; if ( callback != null ) callback . onLoadResult ( responseText ) ; else Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; endLoading ( ) ; } } ) ; } } , websiteRule . extraDelay ) ; loadingUrl = \"<STR_LIT>\" ; } if ( jumpCount > <NUM_LIT> ) jumpCount -- ; super . onPageFinished ( view , url ) ; } @ Override public void onReceivedError ( WebView view , WebResourceRequest request , WebResourceError error ) { Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + error . getErrorCode ( ) + \"<STR_LIT>\" + error . getDescription ( ) ) ; super . onReceivedError ( view , request , error ) ; } @ Override public boolean onRenderProcessGone ( WebView view , RenderProcessGoneDetail detail ) { Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + detail ) ; if ( callback != null ) callback . onLoadFail ( detail . toString ( ) ) ; endLoading ( ) ; return true ; } } ; try { WebView . setWebContentsDebuggingEnabled ( true ) ; webView = new WebView ( context ) ; WebSettings webSettings = webView . getSettings ( ) ; webSettings . setJavaScriptEnabled ( true ) ; webView . setWebViewClient ( webViewClient ) ; parentLayout . addView ( webView , <NUM_LIT> ) ; webView . setVisibility ( View . INVISIBLE ) ; webView . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , <NUM_LIT> ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void load ( String url , Callback callback ) { if ( webView == null ) return ; if ( isLoading ) stopLoading ( ) ; isLoading = true ; this . callback = callback ; jumpCount = <NUM_LIT> ; loadingUrl = url ; for ( WebsiteRule rule : websiteRules ) { if ( url . matches ( rule . urlPattern ) ) { websiteRule = rule ; break ; } } if ( websiteRule . desktopMode ) webView . getSettings ( ) . setUserAgentString ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; else webView . getSettings ( ) . setUserAgentString ( null ) ; new Thread ( ( ) -> { int timeout = websiteRule . timeout ; int waitTime = <NUM_LIT> ; while ( waitTime < timeout && isLoading ) { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException ignored ) { } waitTime += <NUM_LIT> ; } if ( isLoading ) { handler . post ( ( ) -> { if ( callback != null ) callback . onLoadFail ( \"<STR_LIT>\" ) ; stopLoading ( ) ; } ) ; Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } } ) . start ( ) ; webView . loadUrl ( url ) ; } public void stopLoading ( ) { if ( webView == null ) return ; webView . stopLoading ( ) ; isLoading = false ; callback = null ; jumpCount = <NUM_LIT> ; loadingUrl = \"<STR_LIT>\" ; } public boolean isLoading ( ) { return isLoading ; } public void destroy ( ) { if ( webView == null ) return ; webView . destroy ( ) ; webView = null ; webViewClient = null ; callback = null ;", "output": "isLoading = false ; jumpCount = <NUM_LIT> ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . batteryoptimization ; import android . os . Build ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class BatteryOptimizationPlugin extends Plugin { public static final String ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE = \"<STR_LIT>\" ; public static final String ERROR_CODE_UNAVAILABLE = \"<STR_LIT>\" ; private BatteryOptimization implementation ; @ Override public void load ( ) { implementation = new BatteryOptimization ( this ) ; } @ PluginMethod public void isBatteryOptimizationEnabled ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , implementation . isBatteryOptimizationEnabled ( ) ) ; call . resolve ( ret ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openBatteryOptimizationSettings ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } implementation . openBatteryOptimizationSettings ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } }", "output": "@ PluginMethod public void requestIgnoreBatteryOptimization ( PluginCall call ) { try { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { call . reject ( ERROR_MESSAGE_POWER_MANAGER_UNAVAILABLE , ERROR_CODE_UNAVAILABLE ) ; return ; } implementation . requestIgnoreBatteryOptimization ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { call . reject ( exception . getMessage ( ) ) ; } } }"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) public @ interface Field { int STATIC = <NUM_LIT> ; int OBJECT = <NUM_LIT> ; int ANY = - <NUM_LIT> ; String value ( ) default \"<STR_LIT>\" ; int type ( ) default OBJECT ;", "output": "}"}, {"input": "package in . hridayan . ashell . adapters ; import android . graphics . Typeface ; import android . util . TypedValue ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . textview . MaterialTextView ; import java . util . List ; import in . hridayan . ashell . R ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Utils ; public class CommandsAdapter extends RecyclerView . Adapter < CommandsAdapter . ViewHolder > { private final List < CommandItems > data ; private static ClickListener mClickListener ; public CommandsAdapter ( List < CommandItems > data ) { this . data = data ; } @ NonNull @ Override public CommandsAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_commands , parent , false ) ; return new CommandsAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull CommandsAdapter . ViewHolder holder , int position ) { holder . mTitle . setText ( this . data . get ( position ) . getTitle ( ) ) ; if ( this . data . get ( position ) . getSummary ( ) != null ) { holder . mSummary . setText ( this . data . get ( position ) . getSummary ( ) ) ; } else { holder . mSummary . setVisibility ( View . GONE ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener { private final MaterialTextView mTitle , mSummary ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; } @ Override public void onClick ( View view ) { mClickListener . onItemClick ( this . mTitle . getText ( ) . toString ( ) , view ) ; } } public void setOnItemClickListener ( ClickListener clickListener ) {", "output": "CommandsAdapter . mClickListener = clickListener ; } public interface ClickListener { void onItemClick ( String command , View v ) ; } }"}, {"input": "package com . reactnative . bottomsheet ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class OffsetChangedEvent extends Event < OffsetChangedEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; private final int offset ; private final int minOffset ; private final int maxOffset ; public OffsetChangedEvent ( int surfaceId , int viewTag , int offset , int minOffset , int maxOffset ) { super ( surfaceId , viewTag ) ; this . offset = offset ; this . maxOffset = maxOffset ; this . minOffset = minOffset ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { double progress = Math . min ( ( offset - minOffset ) * <NUM_LIT> / ( maxOffset - minOffset ) , <NUM_LIT> ) ; WritableMap data = Arguments . createMap ( ) ; data . putDouble ( \"<STR_LIT>\" , progress ) ; data . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( offset ) ) ; data . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( minOffset ) ) ; data . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( maxOffset ) ) ; return data ; }", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHookByGlobal extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { Handler handler = new Handler ( ) ; AtomicReference < Context > currentContext = new AtomicReference < > ( ) ; AtomicReference < String > currentDynId = new AtomicReference < > ( ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( \"<STR_LIT>\" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( \"<STR_LIT>\" ) ; String dynamicId = fragment_args . getString ( \"<STR_LIT>\" ) ; if ( dynamicId == null ) { dynamicId = fragment_args . getString ( \"<STR_LIT>\" ) ; } XposedBridge . log ( \"<STR_LIT>\" + dynamicId ) ; currentDynId . set ( dynamicId ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( Activity . class , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( \"<STR_LIT>\" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; if ( arg == null ) { return ; } Object body = XposedHelpers . callMethod ( arg , \"<STR_LIT>\" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( \"<STR_LIT>\" ) ) { Object data = XposedHelpers . getObjectField ( body , \"<STR_LIT>\" ) ; if ( data != null && \"<STR_LIT>\" . equals ( data . getClass ( ) . getCanonicalName ( ) ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , \"<STR_LIT>\" ) ; Object content = XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( \"<STR_LIT>\" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( \"<STR_LIT>\" , ( String ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( type ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( ( Long ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , ( String ) XposedHelpers . getObjectField ( content , \"<STR_LIT>\" ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( \"<STR_LIT>\" , Utils . getBvidFormAvid ( oid ) ) ; } long ctime = XposedHelpers . getLongField ( reply , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , ctime ) ; intent . putExtra ( \"<STR_LIT>\" , currentDynId . get ( ) ) ; try { Field picturesField = content . getClass ( ) . getField ( \"<STR_LIT>\" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( \"<STR_LIT>\" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( \"<STR_LIT>\" ) ; } XposedBridge . log ( \"<STR_LIT>\" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } }", "output": ") ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import androidx . annotation . NonNull ; import java . lang . reflect . Array ; class TileList < T > { final int mTileSize ; private final SparseArray < Tile < T > > mTiles = new SparseArray < Tile < T > > ( <NUM_LIT> ) ; Tile < T > mLastAccessedTile ; public TileList ( int tileSize ) { mTileSize = tileSize ; } public T getItemAt ( int pos ) { if ( mLastAccessedTile == null || ! mLastAccessedTile . containsPosition ( pos ) ) { final int startPosition = pos - ( pos % mTileSize ) ; final int index = mTiles . indexOfKey ( startPosition ) ; if ( index < <NUM_LIT> ) { return null ; } mLastAccessedTile = mTiles . valueAt ( index ) ; } return mLastAccessedTile . getByPosition ( pos ) ; } public int size ( ) { return mTiles . size ( ) ; } public void clear ( ) { mTiles . clear ( ) ; } public Tile < T > getAtIndex ( int index ) { if ( index < <NUM_LIT> || index >= mTiles . size ( ) ) { return null ; } return mTiles . valueAt ( index ) ; } public Tile < T > addOrReplace ( Tile < T > newTile ) { final int index = mTiles . indexOfKey ( newTile . mStartPosition ) ; if ( index < <NUM_LIT> ) { mTiles . put ( newTile . mStartPosition , newTile ) ; return null ;", "output": "} Tile < T > oldTile = mTiles . valueAt ( index ) ; mTiles . setValueAt ( index , newTile ) ; if ( mLastAccessedTile == oldTile ) { mLastAccessedTile = newTile ; } return oldTile ; } public Tile < T > removeAtPos ( int startPosition ) { Tile < T > tile = mTiles . get ( startPosition ) ; if ( mLastAccessedTile == tile ) { mLastAccessedTile = null ; } mTiles . delete ( startPosition ) ; return tile ; } public static class Tile < T > { public final T [ ] mItems ; public int mStartPosition ; public int mItemCount ; Tile < T > mNext ; Tile ( @ NonNull Class < T > klass , int size ) { @ SuppressWarnings ( \"<STR_LIT>\" ) T [ ] items = ( T [ ] ) Array . newInstance ( klass , size ) ; mItems = items ; } boolean containsPosition ( int pos ) { return mStartPosition <= pos && pos < mStartPosition + mItemCount ; } T getByPosition ( int pos ) { return mItems [ pos - mStartPosition ] ; } } }"}, {"input": "package com . reactnative . nestedscroll ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class NestedViewHeaderScrollEvent extends Event < NestedViewHeaderScrollEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; private final float y ; public NestedViewHeaderScrollEvent ( int surfaceId , int viewTag , int offset ) { super ( surfaceId , viewTag ) ; this . y = PixelUtil . toDIPFromPixel ( offset ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap event = Arguments . createMap ( ) ;", "output": "WritableMap offset = Arguments . createMap ( ) ; offset . putDouble ( \"<STR_LIT>\" , y ) ; offset . putDouble ( \"<STR_LIT>\" , <NUM_LIT> ) ; event . putMap ( \"<STR_LIT>\" , offset ) ; return event ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . screenorientation ; import android . content . pm . ActivityInfo ; import android . content . res . Configuration ; import android . view . Surface ; import androidx . annotation . Nullable ; import com . getcapacitor . Bridge ; public class ScreenOrientation { interface ScreenOrientationChangeListener { void onScreenOrientationChanged ( ) ; } @ Nullable private ScreenOrientationChangeListener orientationChangeListener ; @ Nullable private int lastOrientationConfiguration ; private Bridge bridge ; ScreenOrientation ( Bridge bridge ) { this . bridge = bridge ; } public void handleOnConfigurationChanged ( Configuration newConfig ) { if ( newConfig . orientation == lastOrientationConfiguration ) { return ; } this . lastOrientationConfiguration = newConfig . orientation ;", "output": "if ( this . orientationChangeListener == null ) { return ; } this . orientationChangeListener . onScreenOrientationChanged ( ) ; } public void setOrientationChangeListener ( @ Nullable ScreenOrientationChangeListener listener ) { this . orientationChangeListener = listener ; } @ Nullable public ScreenOrientationChangeListener getOrientationChangeListener ( ) { return orientationChangeListener ; } public void lock ( String orientationType ) { switch ( orientationType ) { case ScreenOrientationType . LANDSCAPE : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_SENSOR_LANDSCAPE ) ; break ; case ScreenOrientationType . LANDSCAPE_PRIMARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_LANDSCAPE ) ; break ; case ScreenOrientationType . LANDSCAPE_SECONDARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE ) ; break ; case ScreenOrientationType . PORTRAIT : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_SENSOR_PORTRAIT ) ; break ; case ScreenOrientationType . PORTRAIT_PRIMARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; break ; case ScreenOrientationType . PORTRAIT_SECONDARY : bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_PORTRAIT ) ; break ; } } public void unlock ( ) { bridge . getActivity ( ) . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_USER ) ; } public String getCurrentOrientationType ( ) { int rotation = bridge . getActivity ( ) . getWindowManager ( ) . getDefaultDisplay ( ) . getRotation ( ) ; switch ( rotation ) { case Surface . ROTATION_90 : return ScreenOrientationType . LANDSCAPE_PRIMARY ; case Surface . ROTATION_180 : return ScreenOrientationType . PORTRAIT_SECONDARY ; case Surface . ROTATION_270 : return ScreenOrientationType . LANDSCAPE_SECONDARY ; default : return ScreenOrientationType . PORTRAIT_PRIMARY ; } } }"}, {"input": "package org . woheller69 . weather . activities ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . SharedPreferences ; import android . net . Uri ; import android . os . Bundle ; import android . os . Handler ; import androidx . appcompat . app . AlertDialog ; import androidx . preference . PreferenceManager ; import com . google . android . material . navigation . NavigationView ; import com . google . android . material . navigation . NavigationView . OnNavigationItemSelectedListener ; import androidx . appcompat . app . AppCompatDelegate ; import androidx . core . app . TaskStackBuilder ; import androidx . core . view . GravityCompat ; import androidx . drawerlayout . widget . DrawerLayout ; import androidx . appcompat . app . ActionBarDrawerToggle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import android . os . Looper ; import android . view . MenuItem ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import static java . lang . Boolean . TRUE ; public class NavigationActivity extends AppCompatActivity implements OnNavigationItemSelectedListener { static final int NAVDRAWER_LAUNCH_DELAY = <NUM_LIT> ; public static boolean isVisible = false ; private DrawerLayout mDrawerLayout ; private NavigationView mNavigationView ; private Handler mHandler ; protected SharedPreferences mSharedPreferences ; protected AppPreferencesManager prefManager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mSharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; mHandler = new Handler ( Looper . getMainLooper ( ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; if ( prefManager . showStarDialog ( this ) ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; alertDialogBuilder . setMessage ( R . string . dialog_StarOnGitHub ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( BuildConfig . GITHUB_URL ) ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) {", "output": "prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } ) ; alertDialogBuilder . setNeutralButton ( getString ( R . string . dialog_Later_button ) , null ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } } @ Override public void onBackPressed ( ) { DrawerLayout drawer = ( DrawerLayout ) findViewById ( R . id . drawer_layout ) ; if ( drawer . isDrawerOpen ( GravityCompat . START ) ) { drawer . closeDrawer ( GravityCompat . START ) ; } else { if ( getNavigationDrawerID ( ) != R . id . nav_weather ) { Intent intent = new Intent ( this , ForecastCityActivity . class ) ; startActivity ( intent ) ; } else { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_MAIN ) ; intent . addCategory ( Intent . CATEGORY_HOME ) ; startActivity ( intent ) ; } } } protected int getNavigationDrawerID ( ) { return <NUM_LIT> ; } @ Override public boolean onNavigationItemSelected ( MenuItem item ) { final int itemId = item . getItemId ( ) ; return goToNavigationItem ( itemId ) ; } protected boolean goToNavigationItem ( final int itemId ) { if ( itemId == getNavigationDrawerID ( ) ) { mDrawerLayout . closeDrawer ( GravityCompat . START ) ; return true ; } mHandler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { callDrawerItem ( itemId ) ; } } , NAVDRAWER_LAUNCH_DELAY ) ; mDrawerLayout . closeDrawer ( GravityCompat . START ) ; selectNavigationItem ( itemId ) ; return true ; } private void selectNavigationItem ( int itemId ) { for ( int i = <NUM_LIT> ; i < mNavigationView . getMenu ( ) . size ( ) ; i ++ ) { boolean b = itemId == mNavigationView . getMenu ( ) . getItem ( i ) . getItemId ( ) ; mNavigationView . getMenu ( ) . getItem ( i ) . setChecked ( b ) ; } } private void callDrawerItem ( final int itemId ) { Intent intent ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) == TRUE ) { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; } else { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; } if ( itemId == R . id . nav_weather ) { intent = new Intent ( this , ForecastCityActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_manage ) { intent = new Intent ( this , ManageLocationsActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_about ) { intent = new Intent ( this , AboutActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . nav_settings ) { intent = new Intent ( this , SettingsActivity . class ) ; startActivity ( intent ) ; } else if ( itemId == R . id . star_on_github ) { startActivity ( new Intent ( Intent . ACTION_VIEW , Uri . parse ( BuildConfig . GITHUB_URL ) ) ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ) ; prefManager . setAskForStar ( false ) ; } } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { super . onPostCreate ( savedInstanceState ) ; Toolbar toolbar = findViewById ( R . id . toolbar ) ; if ( getSupportActionBar ( ) == null ) { setSupportActionBar ( toolbar ) ; } mDrawerLayout = findViewById ( R . id . drawer_layout ) ; ActionBarDrawerToggle toggle = new ActionBarDrawerToggle ( this , mDrawerLayout , toolbar , R . string . navigation_drawer_open , R . string . navigation_drawer_close ) ; mDrawerLayout . addDrawerListener ( toggle ) ; toggle . syncState ( ) ; mNavigationView = findViewById ( R . id . nav_view ) ; mNavigationView . setNavigationItemSelectedListener ( this ) ; selectNavigationItem ( getNavigationDrawerID ( ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; isVisible = true ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) == TRUE ) { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ; } else { AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; isVisible = false ; } }"}, {"input": "package de . robv . android . xposed . services ; import java . io . InputStream ; public final class FileResult { public final byte [ ] content ; public final InputStream stream ; public final long size ; public final long mtime ; FileResult ( long size , long mtime ) { this . content = null ; this . stream = null ; this . size = size ; this . mtime = mtime ; } FileResult ( byte [ ] content , long size , long mtime ) { this . content = content ; this . stream = null ; this . size = size ; this . mtime = mtime ; } FileResult ( InputStream stream , long size , long mtime ) { this . content = null ; this . stream = stream ; this . size = size ; this . mtime = mtime ; } @ Override public String toString ( ) {", "output": "StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; if ( content != null ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( content . length ) ; sb . append ( \"<STR_LIT>\" ) ; } if ( stream != null ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( stream . toString ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } sb . append ( \"<STR_LIT>\" ) ; sb . append ( size ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( mtime ) ; sb . append ( \"<STR_LIT>\" ) ; return sb . toString ( ) ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . ClassType ; import com . norman . webviewup . lib . reflect . annotation . Method ; public abstract class RuntimeProxy { private final Object mProxyLock = new Object ( ) ; private final ThreadLocal < ReflectProxy . InvokeContext > mInvokeContextThreadLocal = new ThreadLocal < > ( ) ; private volatile Object target ; private Object proxy ; private ReflectProxy reflectProxy ; private final Class < ? > proxyClass ; public RuntimeProxy ( ) { this ( null ) ; } public RuntimeProxy ( Class < ? > proxyClass ) { this . proxyClass = proxyClass ; } public void setTarget ( Object target ) { synchronized ( mProxyLock ) { this . target = target ; if ( reflectProxy != null ) { reflectProxy . setTarget ( target ) ; } } } public Object get ( ) throws ReflectException { try { synchronized ( mProxyLock ) { if ( proxy != null ) { return proxy ; } Class < ? > reflectClass = proxyClass ; if ( reflectClass == null ) { ClassType classTypeAnnotation = getClass ( ) . getAnnotation ( ClassType . class ) ; ClassName classNameAnnotation = getClass ( ) . getAnnotation ( ClassName . class ) ; Class < ? > annotationClass = null ; if ( classNameAnnotation != null ) { annotationClass = Class . forName ( classNameAnnotation . value ( ) ) ; } else if ( classTypeAnnotation != null ) { annotationClass = classTypeAnnotation . value ( ) ; } reflectClass = annotationClass ; } ReflectProxy reflectProxy = new ReflectProxy ( reflectClass ) ; for ( Class < ? > clazz = getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { java . lang . reflect . Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( java . lang . reflect . Method method : methods ) { Method methodAnnotation = method . getAnnotation ( Method . class ) ; if ( methodAnnotation != null ) { String methodName = methodAnnotation . value ( ) ; if ( TextUtils . isEmpty ( methodName ) ) { methodName = method . getName ( ) ; } ReflectProxy . Invoke invoke = new ReflectProxy . Invoke ( methodName , method . getParameterTypes ( ) ) { @ Override protected void onInvoke ( ReflectProxy . InvokeContext invokeContext ) { try { if ( invokeContext . target == null ) return ; if ( ! method . isAccessible ( ) ) { method . setAccessible ( true ) ; } mInvokeContextThreadLocal . set ( invokeContext ) ; Object result = method . invoke ( RuntimeProxy . this , invokeContext . args ) ; invokeContext . setResult ( result ) ; } catch ( Throwable e ) { throw new ReflectException ( e ) ; } finally { mInvokeContextThreadLocal . set ( null ) ; } } } ; reflectProxy . addInvoke ( invoke , false ) ; } } } reflectProxy . setTarget ( target ) ; proxy = reflectProxy . newProxyInstance ( ) ; this . reflectProxy = reflectProxy ; return proxy ; } } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } protected Object invoke ( ) {", "output": "ReflectProxy . InvokeContext invokeContext = mInvokeContextThreadLocal . get ( ) ; if ( invokeContext == null ) { return null ; } return invokeContext . invoke ( ) ; } protected Object getTarget ( ) { ReflectProxy . InvokeContext invokeContext = mInvokeContextThreadLocal . get ( ) ; if ( invokeContext == null ) { return null ; } return invokeContext . target ; } }"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) @ Inherited public @ interface Method { int STATIC = <NUM_LIT> ; int OBJECT = <NUM_LIT> ;", "output": "int ANY = - <NUM_LIT> ; String value ( ) default \"<STR_LIT>\" ; int type ( ) default OBJECT ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class CommentArea { public static final String AREA_VIDEO = \"<STR_LIT>\" ; public static final String AREA_ARTICLE = \"<STR_LIT>\" ; public static final String AREA_DYNAMIC = \"<STR_LIT>\" ; public static final int AREA_TYPE_VIDEO = <NUM_LIT> ; public static final int AREA_TYPE_ARTICLE = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC11 = <NUM_LIT> ; public static final int AREA_TYPE_DYNAMIC17 = <NUM_LIT> ; public long oid ; public String sourceId ; public int type ; public CommentArea ( long oid , String sourceId , int type ) { this . oid = oid ; this . sourceId = sourceId ; this . type = type ; } public String getAreaTypeDesc ( ) { switch ( type ) {", "output": "case CommentArea . AREA_TYPE_VIDEO : return \"<STR_LIT>\" + type + \"<STR_LIT>\" ; case CommentArea . AREA_TYPE_ARTICLE : return \"<STR_LIT>\" + type + \"<STR_LIT>\" ; case CommentArea . AREA_TYPE_DYNAMIC11 : case CommentArea . AREA_TYPE_DYNAMIC17 : return \"<STR_LIT>\" + type + \"<STR_LIT>\" ; default : return String . valueOf ( type ) ; } } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oid + '<STR_LIT>' + \"<STR_LIT>\" + sourceId + '<STR_LIT>' + \"<STR_LIT>\" + type + '<STR_LIT>' + '<STR_LIT>' ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; class ReflectField { private final Object mFiledLock = new Object ( ) ; private String mName ; private String mClassName ; private Class < ? > mClass ; private Object mObject ; private Field mFiled ; private Field assessfield ; private int staticType ; public ReflectField ( Field field ) { this ( null , field ) ; } public ReflectField ( Object object , Field field ) { this . mFiled = field ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public ReflectField ( String className , String name ) { this . mName = name ; this . mClassName = className ;", "output": "} public ReflectField ( Class < ? > cls , String name ) { this . mName = name ; this . mClass = cls ; } public ReflectField ( Object object , String name ) { this . mName = name ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public void setStaticType ( int staticValue ) { this . staticType = staticValue ; } public void set ( Object value ) throws ReflectException { synchronized ( mFiledLock ) { prepareFiled ( ) ; try { assessfield . set ( mObject , value ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public Object get ( ) throws ReflectException { synchronized ( mFiledLock ) { prepareFiled ( ) ; try { return assessfield . get ( mObject ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareFiled ( ) throws ReflectException { synchronized ( mFiledLock ) { try { if ( assessfield != null ) { return ; } Field findFiled = mFiled ; if ( findFiled == null ) { String className = null ; String filedName = mName ; if ( ! TextUtils . isEmpty ( mName ) ) { int lastDotIndex = mName . lastIndexOf ( \"<STR_LIT>\" ) ; if ( lastDotIndex >= <NUM_LIT> && lastDotIndex < mName . length ( ) - <NUM_LIT> ) { className = mName . substring ( <NUM_LIT> , lastDotIndex ) ; filedName = mName . substring ( lastDotIndex + <NUM_LIT> ) ; } } if ( className != null ) { try { Class < ? > relfectClass = Class . forName ( className ) ; findFiled = findField ( relfectClass , filedName ) ; } catch ( Throwable ignore ) { } } if ( findFiled == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } findFiled = findField ( findClass , filedName ) ; } } if ( findFiled == null ) { throw new NoSuchFieldException ( \"<STR_LIT>\" + mName ) ; } int modifiers = findFiled . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findFiled . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findFiled . isAccessible ( ) ) { findFiled . setAccessible ( true ) ; } } if ( Modifier . isFinal ( modifiers ) ) { try { Field modifiersField = Field . class . getDeclaredField ( \"<STR_LIT>\" ) ; if ( ! modifiersField . isAccessible ( ) ) { modifiersField . setAccessible ( true ) ; } modifiersField . setInt ( findFiled , modifiers & ~ Modifier . FINAL ) ; } catch ( Throwable ignore ) { } try { Field modifiersField = Field . class . getDeclaredField ( \"<STR_LIT>\" ) ; if ( ! modifiersField . isAccessible ( ) ) { modifiersField . setAccessible ( true ) ; } modifiersField . setInt ( findFiled , modifiers & ~ Modifier . FINAL ) ; } catch ( Throwable ignore ) { } } assessfield = findFiled ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private Field findField ( Class < ? > findClass , String filedName ) { for ( Class < ? > clazz = findClass ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Field field = clazz . getDeclaredField ( filedName ) ; boolean staticModifiers = Modifier . isStatic ( field . getModifiers ( ) ) ; if ( ( staticType == <NUM_LIT> && staticModifiers ) || ( staticType == <NUM_LIT> && ! staticModifiers ) ) { continue ; } return field ; } catch ( Exception ignore ) { } } return null ; } }"}, {"input": "package in . hridayan . ashell . UI ; import android . app . Activity ; import android . content . Context ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewTreeObserver ; import android . view . WindowManager ; import android . view . inputmethod . InputMethodManager ; import com . google . android . material . textfield . TextInputEditText ; import in . hridayan . ashell . utils . Preferences ; public class KeyboardUtils { public interface KeyboardVisibilityListener { void onKeyboardVisibilityChanged ( boolean isVisible ) ; } public static void attachVisibilityListener ( Activity activity , final KeyboardVisibilityListener listener ) { final View contentView = activity . findViewById ( android . R . id . content ) ; contentView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new ViewTreeObserver . OnGlobalLayoutListener ( ) { private boolean wasOpened ; @ Override public void onGlobalLayout ( ) { Rect r = new Rect ( ) ; contentView . getWindowVisibleDisplayFrame ( r ) ; int screenHeight = contentView . getRootView ( ) . getHeight ( ) ; int heightDiff = screenHeight - ( r . bottom - r . top ) ; boolean isVisible = heightDiff > <NUM_LIT> ; if ( isVisible != wasOpened ) { wasOpened = isVisible ; listener . onKeyboardVisibilityChanged ( isVisible ) ; } } } ) ; } public static void disableKeyboard ( Context context , Activity activity , View view ) { InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; boolean disableSoftKey = Preferences . getDisableSoftkey ( context ) ; if ( disableSoftKey ) { if ( imm != null ) imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; activity . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM , WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM ) ; } else { activity . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_ALT_FOCUSABLE_IM ) ; } } public static void showKeyboard ( TextInputEditText editText , Context context ) { editText . requestFocus ( ) ; InputMethodManager imm = ( InputMethodManager ) context . getSystemService ( Context . INPUT_METHOD_SERVICE ) ;", "output": "imm . toggleSoftInput ( InputMethodManager . SHOW_FORCED , <NUM_LIT> ) ; } public static void closeKeyboard ( Activity activity , View v ) { InputMethodManager inputMethodManager = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; inputMethodManager . hideSoftInputFromWindow ( v . getWindowToken ( ) , <NUM_LIT> ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options ; public class SetZoomRatioOptions { private float zoomRatio ; public SetZoomRatioOptions ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public float getZoomRatio ( ) {", "output": "return zoomRatio ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import com . simon . harmonichackernews . data . Comment ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public class CommentSorter { public static void sort ( Context ctx , List < Comment > comments ) { String sortType = SettingsUtils . getPreferredCommentSorting ( ctx ) ; switch ( sortType ) { case \"<STR_LIT>\" : for ( int i = <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { comments . get ( i ) . totalReplies = numChildren ( comments , i ) ; } sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( - c1 . totalReplies , - c2 . totalReplies ) ; } } ) ; break ; case \"<STR_LIT>\" : sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( - c1 . time , - c2 . time ) ; } } ) ; break ; case \"<STR_LIT>\" : sortComments ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment c1 , Comment c2 ) { return Integer . compare ( c1 . time , c2 . time ) ; } } ) ; break ; } } private static void sortComments ( List < Comment > comments , Comparator < Comment > comparator ) { List < Comment > commentsWithChildren = populateChildComments ( comments ) ; sortCommentsRecursive ( commentsWithChildren , comparator ) ; setSortOrder ( commentsWithChildren ) ; comments . get ( <NUM_LIT> ) . sortOrder = - <NUM_LIT> ; Collections . sort ( comments , new Comparator < Comment > ( ) { @ Override public int compare ( Comment e1 , Comment e2 ) { return Integer . compare ( e1 . sortOrder , e2 . sortOrder ) ; } } ) ; } private static void sortCommentsRecursive ( List < Comment > commentsWithChildren , Comparator < Comment > comparator ) { Collections . sort ( commentsWithChildren , comparator ) ; for ( Comment c : commentsWithChildren ) { sortCommentsRecursive ( c . childComments , comparator ) ; } } private static List < Comment > populateChildComments ( List < Comment > comments ) { List < Comment > commentsWithChildren = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { Comment comment = comments . get ( i ) ; if ( comment . depth == <NUM_LIT> ) { commentsWithChildren . add ( comment ) ; populateChildComments ( comments , comment , i ) ; } } return commentsWithChildren ; } private static void populateChildComments ( List < Comment > comments , Comment comment , int startIndex ) { int targetDepth = comment . depth + <NUM_LIT> ; comment . childComments = new ArrayList < > ( ) ; for ( int i = startIndex + <NUM_LIT> ; i < comments . size ( ) && comments . get ( i ) . depth >= targetDepth ; i ++ ) { if ( comments . get ( i ) . depth == targetDepth ) { comment . childComments . add ( comments . get ( i ) ) ; populateChildComments ( comments , comments . get ( i ) , i ) ; } } } private static void setSortOrder ( List < Comment > commentsWithChildren ) { List < Comment > flatComments = new ArrayList < > ( ) ; flattenComments ( commentsWithChildren , flatComments ) ; for ( int i = <NUM_LIT> ; i < flatComments . size ( ) ; i ++ ) { flatComments . get ( i ) . sortOrder = i ; } } private static void flattenComments ( List < Comment > comments , List < Comment > flatComments ) { for ( Comment comment : comments ) { flatComments . add ( comment ) ; if ( comment . childComments != null ) { flattenComments ( comment . childComments , flatComments ) ; } } } private static int numChildren ( List < Comment > comments , int startIndex ) { int count = <NUM_LIT> ; int targetDepth = comments . get ( startIndex ) . depth ; for ( int i = startIndex + <NUM_LIT> ; i < comments . size ( ) ; i ++ ) { if ( comments . get ( i ) . depth == targetDepth ) { break ; } else { count ++ ; } } return count ; }", "output": "}"}, {"input": "package com . simon . harmonichackernews . data ; import com . simon . harmonichackernews . utils . Utils ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; public class Comment implements Serializable { public String by ; public int id ; public int parent ; public String text ; public int time ; public boolean expanded ; public int depth ; public int children ; public int totalReplies ; public boolean matchesSearch = true ; public List < Comment > childComments = new ArrayList < > ( ) ; public int sortOrder ; public Comment ( ) {", "output": "} public String getTimeFormatted ( ) { return Utils . getTimeAgo ( this . time ) ; } public int getTime ( ) { return this . time ; } }"}, {"input": "package org . woheller69 . weather . database ; import android . content . Context ; import java . util . Calendar ; import java . util . TimeZone ; public class CurrentWeatherData { private int id ; private int city_id ; private long timestamp ; private int weatherID ; private float temperatureCurrent ; private float humidity ; private float pressure ; private float windSpeed ; private float windDirection ; private float cloudiness ; private long timeSunrise ; private long timeSunset ; private int timeZoneSeconds ; private String Rain60min ; private String city_name ; public CurrentWeatherData ( ) { this . city_id = Integer . MIN_VALUE ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public long getTimestamp ( ) { return timestamp ;", "output": "} public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperatureCurrent ( ) { return temperatureCurrent ; } public void setTemperatureCurrent ( float temperatureCurrent ) { this . temperatureCurrent = temperatureCurrent ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getWindSpeed ( ) { return windSpeed ; } public void setWindSpeed ( float windSpeed ) { this . windSpeed = windSpeed ; } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getCloudiness ( ) { return cloudiness ; } public void setCloudiness ( float cloudiness ) { this . cloudiness = cloudiness ; } public boolean isDay ( Context context ) { Calendar timeStamp = Calendar . getInstance ( ) ; timeStamp . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; timeStamp . setTimeInMillis ( ( timestamp + timeZoneSeconds ) * <NUM_LIT> ) ; SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; if ( timeSunrise == <NUM_LIT> || timeSunset == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( city_id ) . getLatitude ( ) ) > <NUM_LIT> ) { return timeStamp . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && timeStamp . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { return timeStamp . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || timeStamp . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { return timestamp > timeSunrise && timestamp < timeSunset ; } } public long getTimeSunrise ( ) { return timeSunrise ; } public void setTimeSunrise ( long timeSunrise ) { this . timeSunrise = timeSunrise ; } public long getTimeSunset ( ) { return timeSunset ; } public void setTimeSunset ( long timeSunset ) { this . timeSunset = timeSunset ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public int getTimeZoneSeconds ( ) { return timeZoneSeconds ; } public void setTimeZoneSeconds ( int timeZoneSeconds ) { this . timeZoneSeconds = timeZoneSeconds ; } public String getRain60min ( ) { return Rain60min ; } public void setRain60min ( String Rain60min ) { this . Rain60min = Rain60min ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . backgroundtask ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class BackgroundTaskPlugin extends Plugin { private BackgroundTask implementation = new BackgroundTask ( ) ; @ PluginMethod ( returnType = PluginMethod . RETURN_CALLBACK ) public void beforeExit ( PluginCall call ) { String callbackId = call . getCallbackId ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , callbackId ) ; call . resolve ( ret ) ; }", "output": "@ PluginMethod public void finish ( PluginCall call ) { call . resolve ( ) ; } }"}, {"input": "package org . woheller69 . weather . widget ; import android . Manifest ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import android . util . Log ; import android . view . View ; import android . widget . RemoteViews ; import android . widget . Toast ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import java . util . Locale ; import java . util . TimeZone ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; public class WeatherWidget extends AppWidgetProvider { private static LocationListener locationListenerGPS ; private LocationManager locationManager ; public void updateAppWidget ( Context context , final int appWidgetId ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) updateLocation ( context , cityID , false ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( \"<STR_LIT>\" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateLocation ( final Context context , int cityID , boolean manual ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; List < CityToWatch > cities = db . getAllCitiesToWatch ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { LocationManager locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; Location locationGPS = locationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( locationGPS != null ) { CityToWatch city ; double lat = locationGPS . getLatitude ( ) ; double lon = locationGPS . getLongitude ( ) ; for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { if ( cities . get ( i ) . getCityId ( ) == cityID ) { city = cities . get ( i ) ; city . setLatitude ( ( float ) lat ) ; city . setLongitude ( ( float ) lon ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , lat , lon ) ) ; db . updateCityToWatch ( city ) ; break ; } } } else { if ( manual ) Toast . makeText ( context . getApplicationContext ( ) , R . string . error_no_position , Toast . LENGTH_SHORT ) . show ( ) ; } } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , CurrentWeatherData weatherData , List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; long time = weatherData . getTimestamp ( ) ; int zoneseconds = weatherData . getTimeZoneSeconds ( ) ; int [ ] forecastIDs = { R . id . widget_hour12 , R . id . widget_hour1 , R . id . widget_hour2 , R . id . widget_hour3 , R . id . widget_hour4 , R . id . widget_hour5 , R . id . widget_hour6 , R . id . widget_hour7 , R . id . widget_hour8 , R . id . widget_hour9 , R . id . widget_hour10 , R . id . widget_hour11 } ; int [ ] windIDs = { R . id . widget_windicon_hour12 , R . id . widget_windicon_hour1 , R . id . widget_windicon_hour2 , R . id . widget_windicon_hour3 , R . id . widget_windicon_hour4 , R . id . widget_windicon_hour5 , R . id . widget_windicon_hour6 , R . id . widget_windicon_hour7 , R . id . widget_windicon_hour8 , R . id . widget_windicon_hour9 , R . id . widget_windicon_hour10 , R . id . widget_windicon_hour11 } ; long updateTime = ( time + zoneseconds ) * <NUM_LIT> ; long riseTime = ( weatherData . getTimeSunrise ( ) + zoneseconds ) * <NUM_LIT> ; long setTime = ( weatherData . getTimeSunset ( ) + zoneseconds ) * <NUM_LIT> ; boolean isDay = weatherData . isDay ( context ) ; if ( ! dbHelper . hasQuarterHourly ( weatherData . getCity_id ( ) ) ) { HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( nowCast . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , \"<STR_LIT>\" + StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) + \"<STR_LIT>\" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = dbHelper . getQuarterHourlyForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } views . setViewVisibility ( R . id . widget_attribution , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . INVISIBLE ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_attribution , View . INVISIBLE ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( next . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , \"<STR_LIT>\" + StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) + \"<STR_LIT>\" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; } SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) views . setViewVisibility ( R . id . location_on , View . VISIBLE ) ; else views . setViewVisibility ( R . id . location_on , View . GONE ) ; views . setTextViewText ( R . id . widget_updatetime , String . format ( \"<STR_LIT>\" , StringFormatUtils . formatTimeWithoutZone ( context , updateTime ) ) ) ; views . setViewPadding ( R . id . widget_temperature , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; views . setTextViewText ( R . id . widget_max_Temp , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_min_Temp , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_city_name , city . getCityName ( ) ) ; if ( riseTime == zoneseconds * <NUM_LIT> || setTime == zoneseconds * <NUM_LIT> ) views . setTextViewText ( R . id . widget_sunrise_sunset , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; else { views . setTextViewText ( R . id . widget_sunrise_sunset , \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , riseTime ) + \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , setTime ) ) ; } if ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) == - <NUM_LIT> ) { views . setViewVisibility ( R . id . widget_UVindex , View . GONE ) ; } else { views . setViewVisibility ( R . id . widget_UVindex , View . VISIBLE ) ; views . setTextViewText ( R . id . widget_UVindex , \"<STR_LIT>\" ) ; views . setInt ( R . id . widget_UVindex , \"<STR_LIT>\" , StringFormatUtils . widgetColorUVindex ( context , Math . round ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) ) ) ) ; } for ( int i = <NUM_LIT> ; i < forecastIDs . length ; i ++ ) { views . setImageViewBitmap ( forecastIDs [ i ] , null ) ; views . setImageViewBitmap ( windIDs [ i ] , null ) ; } if ( hourlyforecasts != null && ! hourlyforecasts . isEmpty ( ) ) { List < HourlyForecast > templist = new ArrayList < > ( ) ; for ( HourlyForecast f : hourlyforecasts ) { if ( f . getForecastTime ( ) >= System . currentTimeMillis ( ) - ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) templist . add ( f ) ; } hourlyforecasts = templist ; for ( int i = <NUM_LIT> ; i < forecastIDs . length ; i ++ ) { Calendar forecastTime = Calendar . getInstance ( ) ; forecastTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; forecastTime . setTimeInMillis ( hourlyforecasts . get ( i ) . getLocalForecastTime ( context ) ) ; int hour = forecastTime . get ( Calendar . HOUR ) % <NUM_LIT> ; if ( weatherData . getTimeSunrise ( ) == <NUM_LIT> || weatherData . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( hourlyforecasts . get ( i ) . getCity_id ( ) ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && forecastTime . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || forecastTime . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { Calendar sunSetTime = Calendar . getInstance ( ) ; sunSetTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; sunSetTime . setTimeInMillis ( weatherData . getTimeSunset ( ) * <NUM_LIT> + weatherData . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunSetTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunSetTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; Calendar sunRiseTime = Calendar . getInstance ( ) ; sunRiseTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; sunRiseTime . setTimeInMillis ( weatherData . getTimeSunrise ( ) * <NUM_LIT> + weatherData . getTimeZoneSeconds ( ) * <NUM_LIT> ) ; sunRiseTime . set ( Calendar . DAY_OF_YEAR , forecastTime . get ( Calendar . DAY_OF_YEAR ) ) ; sunRiseTime . set ( Calendar . YEAR , forecastTime . get ( Calendar . YEAR ) ) ; isDay = forecastTime . after ( sunRiseTime ) && forecastTime . before ( sunSetTime ) ; } views . setImageViewResource ( forecastIDs [ hour ] , UiResourceProvider . getIconResourceForWeatherCategory ( hourlyforecasts . get ( i ) . getWeatherID ( ) , isDay ) ) ; views . setImageViewResource ( windIDs [ hour ] , StringFormatUtils . colorWindSpeedWidget ( hourlyforecasts . get ( i ) . getWindSpeed ( ) ) ) ; } } Intent intentUpdate = new Intent ( context , WeatherWidget . class ) ; intentUpdate . setAction ( AppWidgetManager . ACTION_APPWIDGET_UPDATE ) ; int [ ] idArray = new int [ ] { appWidgetId } ; intentUpdate . putExtra ( AppWidgetManager . EXTRA_APPWIDGET_IDS , idArray ) ; intentUpdate . putExtra ( \"<STR_LIT>\" , true ) ; PendingIntent pendingUpdate ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingUpdate = PendingIntent . getBroadcast ( context , appWidgetId , intentUpdate , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingUpdate = PendingIntent . getBroadcast ( context , appWidgetId , intentUpdate , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_update , pendingUpdate ) ; Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( \"<STR_LIT>\" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( final Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ;", "output": "PowerManager powerManager = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) && ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED && ! powerManager . isPowerSaveMode ( ) ) { if ( locationListenerGPS == null ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; locationListenerGPS = new LocationListener ( ) { @ Override public void onLocationChanged ( android . location . Location location ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int [ ] appWidgetIds = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } else { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( widgetCityID ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; List < HourlyForecast > hourlyforecasts = dbHelper . getForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int widgetID : widgetIDs ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts , hourlyforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getBooleanExtra ( \"<STR_LIT>\" , false ) ) { int cityID = getWidgetCityID ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) updateLocation ( context , cityID , true ) ; } super . onReceive ( context , intent ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces . Result ; public class GetMaxZoomRatioResult implements Result { private float zoomRatio ; public GetMaxZoomRatioResult ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , zoomRatio ) ; return result ;", "output": "} }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Dialog ; import android . content . Intent ; import android . net . Uri ; import android . os . BaseBundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallType extends Feature { private XC_MethodHook . Unhook hookBundleBoolean ; public CallType ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var intPreferences = Unobfuscator . loadGetIntPreferences ( classLoader ) ; XposedBridge . hookMethod ( intPreferences , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == \"<STR_LIT>\" ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var callConfirmationFragment = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var method = ReflectionUtils . findMethodUsingFilter ( callConfirmationFragment , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( android . os . Bundle . class ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { private boolean isVideoCall ; private String jid ; private Dialog newDialog ; private Unhook hookBundleString ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString = XposedHelpers . findAndHookMethod ( BaseBundle . class , \"<STR_LIT>\" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == \"<STR_LIT>\" ) { jid = ( String ) param . getResult ( ) ; } } } ) ; hookBundleBoolean = XposedHelpers . findAndHookMethod ( BaseBundle . class , \"<STR_LIT>\" , String . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == \"<STR_LIT>\" ) { isVideoCall = ( boolean ) param . getResult ( ) ; } } } ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { hookBundleString . unhook ( ) ; hookBundleBoolean . unhook ( ) ; if ( jid == null || isVideoCall ) return ; var origDialog = ( Dialog ) param . getResult ( ) ; var context = origDialog . getContext ( ) ; var mAlertDialog = new AlertDialogWpp ( origDialog . getContext ( ) ) ;", "output": "mAlertDialog . setTitle ( UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) ) ; mAlertDialog . setItems ( new String [ ] { context . getString ( ResId . string . phone_call ) , context . getString ( ResId . string . whatsapp_call ) } , ( dialog , which ) -> { newDialog . dismiss ( ) ; switch ( which ) { case <NUM_LIT> : var intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_DIAL ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" + WppCore . stripJID ( jid ) ) ) ; context . startActivity ( intent ) ; break ; case <NUM_LIT> : origDialog . show ( ) ; break ; } } ) ; newDialog = mAlertDialog . create ( ) ; param . setResult ( newDialog ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . view ; public class ProgressTimer { private final long TimeMs ; private final int max ; private final ProgressLister progressLister ; private boolean isStopped = false ; public ProgressTimer ( long timeMs , int max , ProgressLister progressLister ) { TimeMs = timeMs ; this . max = max ; this . progressLister = progressLister ; } public void start ( ) { long sleepSeg = TimeMs / max ; for ( int i = <NUM_LIT> ; i <= max && ! isStopped ; i ++ ) { try { Thread . sleep ( sleepSeg ) ; progressLister . onNewProgress ( i , sleepSeg ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } public void stop ( ) {", "output": "isStopped = true ; } public interface ProgressLister { void onNewProgress ( int progress , long sleepSeg ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class ExamplesViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) {", "output": "return isToolbarExpanded ; } public void setToolbarExpanded ( boolean toolbarExpanded ) { isToolbarExpanded = toolbarExpanded ; } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . core . content . ContextCompat ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . content . SharedPreferences ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import com . db . chart . Tools ; import com . db . chart . model . BarSet ; import com . db . chart . model . ChartSet ; import com . db . chart . model . LineSet ; import com . db . chart . view . AxisController ; import com . db . chart . view . BarChartView ; import com . db . chart . view . LineChartView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import java . util . TimeZone ; public class CityWeatherAdapter extends RecyclerView . Adapter < CityWeatherAdapter . ViewHolder > { private static final String TAG = \"<STR_LIT>\" ; private int [ ] dataSetTypes ; private List < HourlyForecast > courseDayList ; private List < WeekForecast > weekForecastList ; private Context context ; private ViewGroup mParent ; private RecyclerView mCourseOfDay ; private RecyclerView mWeekWeather ; private CurrentWeatherData currentWeatherDataList ; public static final int OVERVIEW = <NUM_LIT> ; public static final int DETAILS = <NUM_LIT> ; public static final int WEEK = <NUM_LIT> ; public static final int DAY = <NUM_LIT> ; public static final int CHART = <NUM_LIT> ; public static final int EMPTY = <NUM_LIT> ; public CityWeatherAdapter ( CurrentWeatherData currentWeatherDataList , int [ ] dataSetTypes , Context context ) { this . currentWeatherDataList = currentWeatherDataList ; this . dataSetTypes = dataSetTypes ; this . context = context ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; List < HourlyForecast > hourlyForecasts = database . getForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; List < WeekForecast > weekforecasts = database . getWeekForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; updateForecastData ( hourlyForecasts ) ; updateWeekForecastData ( weekforecasts ) ; } public void updateForecastData ( List < HourlyForecast > hourlyForecasts ) { if ( hourlyForecasts . isEmpty ( ) ) return ; courseDayList = new ArrayList < > ( ) ; long onehourago = System . currentTimeMillis ( ) - ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( f . getForecastTime ( ) >= onehourago ) { courseDayList . add ( f ) ; } } notifyDataSetChanged ( ) ; } public void updateWeekForecastData ( List < WeekForecast > forecasts ) { if ( forecasts . isEmpty ( ) ) return ; weekForecastList = forecasts ; notifyDataSetChanged ( ) ; } static class ViewHolder extends RecyclerView . ViewHolder { ViewHolder ( View v ) { super ( v ) ; } } public class OverViewHolder extends ViewHolder { TextView temperature ; ImageView weather ; ImageView windicon ;", "output": "TextView updatetime ; TextView sun ; TextView precipforecast ; OverViewHolder ( View v ) { super ( v ) ; this . temperature = v . findViewById ( R . id . card_overview_temperature ) ; this . weather = v . findViewById ( R . id . card_overview_weather_image ) ; this . sun = v . findViewById ( R . id . card_overview_sunrise_sunset ) ; this . windicon = v . findViewById ( R . id . card_overview_windicon ) ; this . updatetime = v . findViewById ( R . id . card_overview_update_time ) ; this . precipforecast = v . findViewById ( R . id . card_overview_precipitation_forecast ) ; } } public class DetailViewHolder extends ViewHolder { TextView humidity ; TextView pressure ; TextView windspeed ; TextView rain60min ; TextView rain60minLegend ; TextView time ; ImageView winddirection ; DetailViewHolder ( View v ) { super ( v ) ; this . humidity = v . findViewById ( R . id . card_details_humidity_value ) ; this . pressure = v . findViewById ( R . id . card_details_pressure_value ) ; this . windspeed = v . findViewById ( R . id . card_details_wind_speed_value ) ; this . rain60min = v . findViewById ( R . id . card_details_rain60min_value ) ; this . rain60minLegend = v . findViewById ( R . id . card_details_legend_rain60min ) ; this . winddirection = v . findViewById ( ( R . id . card_details_wind_direction_value ) ) ; this . time = v . findViewById ( R . id . card_details_title ) ; } } public class WeekViewHolder extends ViewHolder { RecyclerView recyclerView ; WeekViewHolder ( View v ) { super ( v ) ; recyclerView = v . findViewById ( R . id . recycler_view_week ) ; mWeekWeather = recyclerView ; } } public class DayViewHolder extends ViewHolder { RecyclerView recyclerView ; TextView recyclerViewHeader ; DayViewHolder ( View v ) { super ( v ) ; recyclerView = v . findViewById ( R . id . recycler_view_course_day ) ; mCourseOfDay = recyclerView ; recyclerViewHeader = v . findViewById ( R . id . recycler_view_header ) ; } } public class ChartViewHolder extends ViewHolder { TextView temperatureunit ; TextView precipitationunit ; LineChartView lineChartView ; BarChartView barChartView ; BarChartView barChartViewAxis ; ChartViewHolder ( View v ) { super ( v ) ; this . lineChartView = v . findViewById ( R . id . graph_temperature ) ; this . barChartView = v . findViewById ( R . id . graph_precipitation ) ; this . temperatureunit = v . findViewById ( R . id . graph_temperatureunit ) ; this . barChartViewAxis = v . findViewById ( R . id . graph_axis ) ; this . precipitationunit = v . findViewById ( R . id . graph_precipitationunit ) ; } } @ Override public ViewHolder onCreateViewHolder ( ViewGroup viewGroup , int viewType ) { View v ; mParent = viewGroup ; if ( viewType == OVERVIEW ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_overview , viewGroup , false ) ; return new OverViewHolder ( v ) ; } else if ( viewType == DETAILS ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_details , viewGroup , false ) ; return new DetailViewHolder ( v ) ; } else if ( viewType == WEEK ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_week , viewGroup , false ) ; return new WeekViewHolder ( v ) ; } else if ( viewType == DAY ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_day , viewGroup , false ) ; return new DayViewHolder ( v ) ; } else if ( viewType == CHART ) { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_chart , viewGroup , false ) ; return new ChartViewHolder ( v ) ; } else { v = LayoutInflater . from ( viewGroup . getContext ( ) ) . inflate ( R . layout . card_empty , viewGroup , false ) ; return new ViewHolder ( v ) ; } } @ Override public void onBindViewHolder ( ViewHolder viewHolder , final int position ) { boolean isDay = currentWeatherDataList . isDay ( context ) ; if ( viewHolder . getItemViewType ( ) == OVERVIEW ) { OverViewHolder holder = ( OverViewHolder ) viewHolder ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; int zoneseconds = currentWeatherDataList . getTimeZoneSeconds ( ) ; long riseTime = ( currentWeatherDataList . getTimeSunrise ( ) + zoneseconds ) * <NUM_LIT> ; long setTime = ( currentWeatherDataList . getTimeSunset ( ) + zoneseconds ) * <NUM_LIT> ; if ( riseTime == zoneseconds * <NUM_LIT> || setTime == zoneseconds * <NUM_LIT> ) holder . sun . setText ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; else { holder . sun . setText ( \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , riseTime ) + \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , setTime ) ) ; } long time = currentWeatherDataList . getTimestamp ( ) ; long updateTime = ( ( time + zoneseconds ) * <NUM_LIT> ) ; holder . updatetime . setText ( \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , updateTime ) + \"<STR_LIT>\" ) ; if ( ! database . hasQuarterHourly ( currentWeatherDataList . getCity_id ( ) ) ) { holder . precipforecast . setVisibility ( View . INVISIBLE ) ; HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = database . getForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; setImage ( nowCast . getWeatherID ( ) , holder . weather , isDay ) ; holder . temperature . setText ( StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = database . getQuarterHourlyForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } holder . precipforecast . setVisibility ( View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { holder . precipforecast . setText ( \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; holder . precipforecast . setVisibility ( View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { holder . precipforecast . setText ( \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; holder . precipforecast . setVisibility ( View . VISIBLE ) ; } } holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; setImage ( next . getWeatherID ( ) , holder . weather , isDay ) ; holder . temperature . setText ( StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) ) ; } } else if ( viewHolder . getItemViewType ( ) == DETAILS ) { } else if ( viewHolder . getItemViewType ( ) == WEEK ) { final WeekViewHolder holder = ( WeekViewHolder ) viewHolder ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context , LinearLayoutManager . HORIZONTAL , false ) ; holder . recyclerView . setLayoutManager ( layoutManager ) ; final WeekWeatherAdapter adapter = new WeekWeatherAdapter ( context , weekForecastList , currentWeatherDataList . getCity_id ( ) ) ; holder . recyclerView . setAdapter ( adapter ) ; holder . recyclerView . setFocusable ( false ) ; if ( mCourseOfDay != null ) { CourseOfDayAdapter dayadapter = ( CourseOfDayAdapter ) mCourseOfDay . getAdapter ( ) ; dayadapter . setWeekRecyclerView ( holder . recyclerView ) ; adapter . setCourseOfDayHeaderDate ( dayadapter . getCourseOfDayHeaderDate ( ) ) ; } holder . recyclerView . addOnItemTouchListener ( new RecyclerItemClickListener ( context , holder . recyclerView , new RecyclerItemClickListener . OnItemClickListener ( ) { @ Override public void onItemClick ( View view , int position ) { SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; List < WeekForecast > weekforecasts = database . getWeekForecastsByCityId ( currentWeatherDataList . getCity_id ( ) ) ; long time = weekforecasts . get ( position ) . getForecastTime ( ) ; time = time - <NUM_LIT> * <NUM_LIT> ; if ( mCourseOfDay != null ) { LinearLayoutManager llm = ( LinearLayoutManager ) mCourseOfDay . getLayoutManager ( ) ; assert llm != null ; int num = llm . findLastVisibleItemPosition ( ) - llm . findFirstVisibleItemPosition ( ) ; int i ; for ( i = <NUM_LIT> ; i < courseDayList . size ( ) ; i ++ ) { if ( courseDayList . get ( i ) . getForecastTime ( ) > time ) { Calendar HeaderTime = Calendar . getInstance ( ) ; HeaderTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; HeaderTime . setTimeInMillis ( courseDayList . get ( i ) . getLocalForecastTime ( context ) ) ; adapter . setCourseOfDayHeaderDate ( HeaderTime . getTime ( ) ) ; break ; } } if ( i < courseDayList . size ( ) ) { if ( i > llm . findFirstVisibleItemPosition ( ) ) { int min = Math . min ( i + num , courseDayList . size ( ) - <NUM_LIT> ) ; mCourseOfDay . getLayoutManager ( ) . scrollToPosition ( min ) ; } else { mCourseOfDay . getLayoutManager ( ) . scrollToPosition ( i ) ; } } } } public void onLongItemClick ( View view , int position ) { } } ) ) ; } else if ( viewHolder . getItemViewType ( ) == DAY ) { DayViewHolder holder = ( DayViewHolder ) viewHolder ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context , LinearLayoutManager . HORIZONTAL , false ) ; holder . recyclerView . setLayoutManager ( layoutManager ) ; CourseOfDayAdapter adapter = new CourseOfDayAdapter ( courseDayList , context , holder . recyclerViewHeader , holder . recyclerView ) ; holder . recyclerView . setAdapter ( adapter ) ; holder . recyclerView . setFocusable ( false ) ; } else if ( viewHolder . getItemViewType ( ) == CHART ) { ChartViewHolder holder = ( ChartViewHolder ) viewHolder ; if ( weekForecastList == null || weekForecastList . isEmpty ( ) ) return ; AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this . context ) ) ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( this . context ) ; float tmin = <NUM_LIT> ; float tmax = - <NUM_LIT> ; float pmax = <NUM_LIT> ; LineSet datasetmax = new LineSet ( ) ; LineSet datasetmin = new LineSet ( ) ; LineSet xaxis = new LineSet ( ) ; BarSet precipitationDataset = new BarSet ( ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; int zonemilliseconds = currentWeatherDataList . getTimeZoneSeconds ( ) * <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < weekForecastList . size ( ) ; i ++ ) { c . setTimeInMillis ( weekForecastList . get ( i ) . getForecastTime ( ) + zonemilliseconds ) ; int day = c . get ( Calendar . DAY_OF_WEEK ) ; float temp_max = weekForecastList . get ( i ) . getMaxTemperature ( ) ; float temp_min = weekForecastList . get ( i ) . getMinTemperature ( ) ; float precip = weekForecastList . get ( i ) . getPrecipitation ( ) ; String dayString = context . getResources ( ) . getString ( StringFormatUtils . getDayShort ( day ) ) ; if ( weekForecastList . size ( ) > <NUM_LIT> ) dayString = dayString . substring ( <NUM_LIT> , <NUM_LIT> ) ; if ( ( i == <NUM_LIT> ) || ( i == ( weekForecastList . size ( ) - <NUM_LIT> ) ) ) { precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; datasetmax . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_max ) ) ; datasetmin . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_min ) ) ; } else { precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; precipitationDataset . addBar ( dayString , prefManager . convertPrecipitationFromMM ( precip ) ) ; datasetmax . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_max ) ) ; datasetmin . addPoint ( dayString , prefManager . convertTemperatureFromCelsius ( temp_min ) ) ; } if ( prefManager . convertTemperatureFromCelsius ( temp_max ) > tmax ) tmax = prefManager . convertTemperatureFromCelsius ( temp_max ) ; if ( prefManager . convertTemperatureFromCelsius ( temp_min ) < tmin ) tmin = prefManager . convertTemperatureFromCelsius ( temp_min ) ; if ( prefManager . convertPrecipitationFromMM ( precip ) > pmax ) pmax = prefManager . convertPrecipitationFromMM ( precip ) ; } tmax ++ ; tmin -- ; int mid = Math . round ( ( tmin + tmax ) / <NUM_LIT> ) ; int step = Math . max ( <NUM_LIT> , ( int ) Math . ceil ( Math . abs ( tmax - tmin ) / <NUM_LIT> ) ) ; for ( int i = <NUM_LIT> ; i < weekForecastList . size ( ) ; i ++ ) { xaxis . addPoint ( \"<STR_LIT>\" , mid - <NUM_LIT> * step ) ; } ArrayList < ChartSet > temperature = new ArrayList < > ( ) ; temperature . add ( datasetmax ) ; temperature . add ( datasetmin ) ; temperature . add ( xaxis ) ; datasetmax . setColor ( ContextCompat . getColor ( context , R . color . red ) ) ; datasetmax . setThickness ( <NUM_LIT> ) ; datasetmax . setSmooth ( true ) ; datasetmax . setFill ( ContextCompat . getColor ( context , R . color . middlegrey ) ) ; datasetmin . setColor ( ContextCompat . getColor ( context , R . color . lightblue ) ) ; datasetmin . setThickness ( <NUM_LIT> ) ; datasetmin . setSmooth ( true ) ; datasetmin . setFill ( ContextCompat . getColor ( context , R . color . backgroundBlue ) ) ; xaxis . setThickness ( <NUM_LIT> ) ; xaxis . setColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; ArrayList < ChartSet > precipitation = new ArrayList < > ( ) ; precipitation . add ( precipitationDataset ) ; precipitationDataset . setColor ( ContextCompat . getColor ( context , R . color . blue ) ) ; precipitationDataset . setAlpha ( <NUM_LIT> ) ; holder . lineChartView . addData ( temperature ) ; holder . lineChartView . setAxisBorderValues ( mid - <NUM_LIT> * step , mid + <NUM_LIT> * step ) ; holder . lineChartView . setStep ( step ) ; holder . lineChartView . setXAxis ( false ) ; holder . lineChartView . setYAxis ( false ) ; holder . lineChartView . setYLabels ( AxisController . LabelPosition . INSIDE ) ; holder . lineChartView . setLabelsColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . lineChartView . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . lineChartView . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . lineChartView . setBorderSpacing ( Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . lineChartView . show ( ) ; int stepnum = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; step = ( int ) Math . ceil ( ( Math . max ( prefManager . convertPrecipitationFromMM ( <NUM_LIT> ) , pmax * <NUM_LIT> ) ) / stepnum ) ; holder . barChartView . addData ( precipitation ) ; holder . barChartView . setBarSpacing ( <NUM_LIT> ) ; holder . barChartView . setAxisBorderValues ( <NUM_LIT> , step * stepnum ) ; holder . barChartView . setXAxis ( false ) ; holder . barChartView . setYAxis ( false ) ; holder . barChartView . setYLabels ( AxisController . LabelPosition . NONE ) ; holder . barChartView . setLabelsColor ( <NUM_LIT> ) ; holder . barChartView . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartView . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartView . setBorderSpacing ( Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartView . show ( ) ; BarSet precipitationAxisData = new BarSet ( ) ; precipitationAxisData . addBar ( \"<STR_LIT>\" , <NUM_LIT> ) ; ArrayList < ChartSet > precipitationAxis = new ArrayList < > ( ) ; precipitationAxis . add ( precipitationAxisData ) ; precipitationAxisData . setColor ( <NUM_LIT> ) ; holder . barChartViewAxis . addData ( precipitationAxis ) ; holder . barChartViewAxis . setBarSpacing ( <NUM_LIT> ) ; holder . barChartViewAxis . setAxisBorderValues ( <NUM_LIT> , step * stepnum ) ; holder . barChartViewAxis . setStep ( step ) ; holder . barChartViewAxis . setXAxis ( false ) ; holder . barChartViewAxis . setYAxis ( false ) ; holder . barChartViewAxis . setYLabels ( AxisController . LabelPosition . OUTSIDE ) ; holder . barChartViewAxis . setLabelsColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartViewAxis . setAxisColor ( ContextCompat . getColor ( context , R . color . colorPrimaryDark ) ) ; holder . barChartViewAxis . setFontSize ( ( int ) Tools . fromDpToPx ( <NUM_LIT> ) ) ; holder . barChartViewAxis . show ( ) ; holder . temperatureunit . setText ( \"<STR_LIT>\" + prefManager . getTemperatureUnit ( ) + \"<STR_LIT>\" ) ; holder . precipitationunit . setText ( \"<STR_LIT>\" + prefManager . getPrecipitationUnit ( context ) + \"<STR_LIT>\" ) ; } } public void setImage ( int value , ImageView imageView , boolean isDay ) { imageView . setImageResource ( UiResourceProvider . getImageResourceForWeatherCategory ( value , isDay ) ) ; } @ Override public int getItemCount ( ) { return dataSetTypes . length ; } @ Override public int getItemViewType ( int position ) { return dataSetTypes [ position ] ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . view . ViewGroup ; import android . widget . AbsListView ; import android . widget . ListView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . adapter . IGStatusAdapter ; import com . wmods . wppenhacer . views . IGStatusView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatus extends Feature { public static ArrayList < Object > itens = new ArrayList < > ( ) ; private static final ArrayList < IGStatusView > mListStatusContainer = new ArrayList < > ( ) ; public IGStatus ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) {", "output": "super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) || Utils . getApplication ( ) . getPackageName ( ) . equals ( \"<STR_LIT>\" ) ) return ; var getViewConversationMethod = Unobfuscator . loadGetViewConversationMethod ( classLoader ) ; XposedBridge . hookMethod ( getViewConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) . isInstance ( param . thisObject ) ) return ; if ( XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) . isInstance ( param . thisObject ) ) return ; var view = ( ViewGroup ) param . getResult ( ) ; if ( view == null ) return ; var mainView = ( ListView ) view . findViewById ( android . R . id . list ) ; mainView . setNestedScrollingEnabled ( true ) ; var mStatusContainer = new IGStatusView ( WppCore . getCurrentActivity ( ) ) ; var layoutParams = new AbsListView . LayoutParams ( AbsListView . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; mStatusContainer . setLayoutParams ( layoutParams ) ; mainView . addHeaderView ( mStatusContainer ) ; mListStatusContainer . add ( mStatusContainer ) ; } } ) ; var clazz2 = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var onUpdateStatusChanged = Unobfuscator . loadOnUpdateStatusChanged ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onUpdateStatusChanged ) ) ; var statusInfoClass = Unobfuscator . loadStatusInfoClass ( classLoader ) ; logDebug ( statusInfoClass ) ; XposedBridge . hookAllConstructors ( clazz2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { itens . add ( <NUM_LIT> , null ) ; for ( var mStatusContainer : mListStatusContainer ) { IGStatusAdapter mStatusAdapter = new IGStatusAdapter ( WppCore . getCurrentActivity ( ) , statusInfoClass ) ; mStatusContainer . setAdapter ( mStatusAdapter ) ; mStatusContainer . updateList ( ) ; } } } ) ; var onStatusListUpdatesClass = Unobfuscator . loadStatusListUpdatesClass ( classLoader ) ; logDebug ( onStatusListUpdatesClass ) ; XposedBridge . hookAllConstructors ( onStatusListUpdatesClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list1 = ( List ) param . args [ <NUM_LIT> ] ; var list2 = ( List ) param . args [ <NUM_LIT> ] ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; var onGetInvokeField = Unobfuscator . loadGetInvokeField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( onGetInvokeField ) ) ; XposedBridge . hookMethod ( onUpdateStatusChanged , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var object = onGetInvokeField . get ( param . args [ <NUM_LIT> ] ) ; var method = ReflectionUtils . findMethodUsingFilter ( object . getClass ( ) , method1 -> method1 . getReturnType ( ) . equals ( Object . class ) ) ; var StatusListUpdates = ReflectionUtils . callMethod ( method , object ) ; if ( StatusListUpdates == null ) return ; var lists = ReflectionUtils . findAllFieldsUsingFilter ( StatusListUpdates . getClass ( ) , field -> field . getType ( ) . equals ( List . class ) ) ; if ( lists . length < <NUM_LIT> ) return ; var list1 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; var list2 = ( List ) lists [ <NUM_LIT> ] . get ( StatusListUpdates ) ; itens . clear ( ) ; itens . add ( <NUM_LIT> , null ) ; itens . addAll ( list1 ) ; itens . addAll ( list2 ) ; for ( var mStatusContainer : mListStatusContainer ) mStatusContainer . updateList ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . appspa . update . proxy ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . listener . IUpdateParseCallback ; public interface IUpdateParser { UpdateEntity parseJson ( String json ) throws Exception ;", "output": "void parseJson ( String json , final IUpdateParseCallback callback ) throws Exception ; boolean isAsyncParser ( ) ; }"}, {"input": "package org . woheller69 . weather . ui . updater ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . ArrayList ; import java . util . List ; public class ViewUpdater { private static List < IUpdateableCityUI > subscribers = new ArrayList < > ( ) ; public static void addSubscriber ( IUpdateableCityUI sub ) { if ( ! subscribers . contains ( sub ) ) { subscribers . add ( sub ) ; } } public static void removeSubscriber ( IUpdateableCityUI sub ) { subscribers . remove ( sub ) ; } public static void updateCurrentWeatherData ( CurrentWeatherData data ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) { sub . processNewCurrentWeatherData ( data ) ; } } public static void updateWeekForecasts ( List < WeekForecast > forecasts ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) {", "output": "sub . processNewWeekForecasts ( forecasts ) ; } } public static void updateForecasts ( List < HourlyForecast > hourlyForecasts ) { ArrayList < IUpdateableCityUI > subcopy = new ArrayList < > ( subscribers ) ; for ( IUpdateableCityUI sub : subcopy ) { sub . processNewForecasts ( hourlyForecasts ) ; } } }"}, {"input": "package com . simon . harmonichackernews . utils ; import java . util . HashMap ; import java . util . Map ; public class ArxivResolver { private static final Map < String , String > ARXIV_SUBJECTS = new HashMap < > ( ) ; static { ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ARXIV_SUBJECTS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String resolveSubject ( String abbreviation ) { return ARXIV_SUBJECTS . get ( abbreviation ) ; } public static boolean isArxivSubjet ( String abbr ) { return ARXIV_SUBJECTS . containsKey ( abbr ) ; } public static String resolveFull ( String category ) { return ArxivResolver . resolveSubject ( category ) + \"<STR_LIT>\" + category + \"<STR_LIT>\" ; } }"}, {"input": "package org . woheller69 . weather . activities ; import static java . lang . Boolean . TRUE ; import android . annotation . SuppressLint ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . os . Bundle ; import android . view . View ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . ImageButton ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class RainViewerActivity extends AppCompatActivity { private WebView webView ; private ImageButton btnPrev , btnNext , btnStartStop ; @ Override protected void onPause ( ) { super . onPause ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_rain_viewer ) ; float latitude = getIntent ( ) . getFloatExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; float longitude = getIntent ( ) . getFloatExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; int timezoneseconds = getIntent ( ) . getIntExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; int nightmode = <NUM_LIT> ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) == TRUE ) { int nightModeFlags = getApplicationContext ( ) . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; if ( nightModeFlags == Configuration . UI_MODE_NIGHT_YES ) nightmode = <NUM_LIT> ; } int hour12 = <NUM_LIT> ; if ( android . text . format . DateFormat . is24HourFormat ( this ) || sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { hour12 = <NUM_LIT> ; } webView = findViewById ( R . id . webView ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . getSettings ( ) . setUserAgentString ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; webView . loadUrl ( \"<STR_LIT>\" + latitude + \"<STR_LIT>\" + longitude + \"<STR_LIT>\" + nightmode + \"<STR_LIT>\" + hour12 + \"<STR_LIT>\" + timezoneseconds ) ; webView . setWebViewClient ( new WebViewClient ( ) { @ Override public void onPageFinished ( WebView view , String url ) { super . onPageFinished ( webView , url ) ; btnNext = findViewById ( R . id . rainviewer_next ) ; btnPrev = findViewById ( R . id . rainviewer_prev ) ; btnStartStop = findViewById ( R . id . rainviewer_startstop ) ; btnNext . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( \"<STR_LIT>\" ) ; } } ) ; btnPrev . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( \"<STR_LIT>\" ) ; } } ) ; btnStartStop . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { webView . loadUrl ( \"<STR_LIT>\" ) ; } } ) ; } } ) ;", "output": "Toolbar toolbar = findViewById ( R . id . toolbar ) ; if ( getSupportActionBar ( ) == null ) { setSupportActionBar ( toolbar ) ; } getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; getSupportActionBar ( ) . setDisplayShowHomeEnabled ( true ) ; } }"}, {"input": "package com . appspa . update . widget ; import java . io . File ; public interface IDownloadEventHandler { void handleStart ( ) ; void handleProgress ( float progress ) ; boolean handleCompleted ( File file ) ; void handleError ( Throwable throwable ) ;", "output": "}"}, {"input": "public class MyPreferences extends PreferenceActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } } public class OtherPreferences extends PreferenceActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override protected boolean isValidFragment ( String fragmentName ) {", "output": "return true ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . util . Log ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleItemAnimator extends RecyclerView . ItemAnimator { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; boolean mSupportsChangeAnimations = true ; @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean getSupportsChangeAnimations ( ) { return mSupportsChangeAnimations ; } public void setSupportsChangeAnimations ( boolean supportsChangeAnimations ) { mSupportsChangeAnimations = supportsChangeAnimations ; } @ Override public boolean canReuseUpdatedViewHolder ( @ NonNull RecyclerView . ViewHolder viewHolder ) { return ! mSupportsChangeAnimations || viewHolder . isInvalid ( ) ; } @ Override public boolean animateDisappearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ Nullable ItemHolderInfo postLayoutInfo ) { int oldLeft = preLayoutInfo . left ; int oldTop = preLayoutInfo . top ; View disappearingItemView = viewHolder . itemView ;", "output": "int newLeft = postLayoutInfo == null ? disappearingItemView . getLeft ( ) : postLayoutInfo . left ; int newTop = postLayoutInfo == null ? disappearingItemView . getTop ( ) : postLayoutInfo . top ; if ( ! viewHolder . isRemoved ( ) && ( oldLeft != newLeft || oldTop != newTop ) ) { disappearingItemView . layout ( newLeft , newTop , newLeft + disappearingItemView . getWidth ( ) , newTop + disappearingItemView . getHeight ( ) ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateMove ( viewHolder , oldLeft , oldTop , newLeft , newTop ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + disappearingItemView ) ; } return animateRemove ( viewHolder ) ; } } @ Override public boolean animateAppearance ( @ NonNull RecyclerView . ViewHolder viewHolder , @ Nullable ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo != null && ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } else { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder ) ; } return animateAdd ( viewHolder ) ; } } @ Override public boolean animatePersistence ( @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( preLayoutInfo . left != postLayoutInfo . left || preLayoutInfo . top != postLayoutInfo . top ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + viewHolder + \"<STR_LIT>\" + viewHolder . itemView ) ; } return animateMove ( viewHolder , preLayoutInfo . left , preLayoutInfo . top , postLayoutInfo . left , postLayoutInfo . top ) ; } dispatchMoveFinished ( viewHolder ) ; return false ; } @ Override public boolean animateChange ( @ NonNull RecyclerView . ViewHolder oldHolder , @ NonNull RecyclerView . ViewHolder newHolder , @ NonNull ItemHolderInfo preLayoutInfo , @ NonNull ItemHolderInfo postLayoutInfo ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + oldHolder + \"<STR_LIT>\" + oldHolder . itemView ) ; } final int fromLeft = preLayoutInfo . left ; final int fromTop = preLayoutInfo . top ; final int toLeft , toTop ; if ( newHolder . shouldIgnore ( ) ) { toLeft = preLayoutInfo . left ; toTop = preLayoutInfo . top ; } else { toLeft = postLayoutInfo . left ; toTop = postLayoutInfo . top ; } return animateChange ( oldHolder , newHolder , fromLeft , fromTop , toLeft , toTop ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateRemove ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateAdd ( RecyclerView . ViewHolder holder ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateMove ( RecyclerView . ViewHolder holder , int fromX , int fromY , int toX , int toY ) ; @ SuppressLint ( \"<STR_LIT>\" ) public abstract boolean animateChange ( RecyclerView . ViewHolder oldHolder , RecyclerView . ViewHolder newHolder , int fromLeft , int fromTop , int toLeft , int toTop ) ; @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveFinished ( RecyclerView . ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveFinished ( RecyclerView . ViewHolder item ) { onMoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddFinished ( RecyclerView . ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeFinished ( item , oldItem ) ; dispatchAnimationFinished ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchRemoveStarting ( RecyclerView . ViewHolder item ) { onRemoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchMoveStarting ( RecyclerView . ViewHolder item ) { onMoveStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchAddStarting ( RecyclerView . ViewHolder item ) { onAddStarting ( item ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public final void dispatchChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { onChangeStarting ( item , oldItem ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ SuppressWarnings ( \"<STR_LIT>\" ) public void onRemoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onRemoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( \"<STR_LIT>\" ) @ SuppressLint ( \"<STR_LIT>\" ) public void onAddStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onAddFinished ( RecyclerView . ViewHolder item ) { } @ SuppressWarnings ( \"<STR_LIT>\" ) @ SuppressLint ( \"<STR_LIT>\" ) public void onMoveStarting ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onMoveFinished ( RecyclerView . ViewHolder item ) { } @ SuppressLint ( \"<STR_LIT>\" ) @ SuppressWarnings ( \"<STR_LIT>\" ) public void onChangeStarting ( RecyclerView . ViewHolder item , boolean oldItem ) { } @ SuppressLint ( \"<STR_LIT>\" ) public void onChangeFinished ( RecyclerView . ViewHolder item , boolean oldItem ) { } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . database . Cursor ; public class GreatCursor { Cursor cursor ; public GreatCursor ( Cursor cursor ) { this . cursor = cursor ; } public int getInt ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getInt ( columnIndex ) ;", "output": "} else { throw new RuntimeException ( \"<STR_LIT>\" + columnName + \"<STR_LIT>\" ) ; } } public long getLong ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getLong ( columnIndex ) ; } else { throw new RuntimeException ( \"<STR_LIT>\" + columnName + \"<STR_LIT>\" ) ; } } public String getString ( String columnName ) { int columnIndex = cursor . getColumnIndex ( columnName ) ; if ( columnIndex >= - <NUM_LIT> ) { return cursor . getString ( columnIndex ) ; } else { throw new RuntimeException ( \"<STR_LIT>\" + columnName + \"<STR_LIT>\" ) ; } } public boolean moveToNext ( ) { return cursor . moveToNext ( ) ; } public void close ( ) { cursor . close ( ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import android . util . Log ; import java . io . IOException ; import java . util . Arrays ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . ForwardDynamicResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class SensitiveScannerTask extends BackstageTask < SensitiveScannerTask . EventHandler > { private final Comment mainComment ; private CommentArea commentAreaForTest ; private String dynamicIdToBeForward ; private final CommentManipulator commentManipulator ; private final Config config ; private final StatisticsDBOpenHelper helper ; public SensitiveScannerTask ( EventHandler handle , Comment mainComment , CommentArea yourCommentArea , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . commentAreaForTest = yourCommentArea ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } public SensitiveScannerTask ( EventHandler handle , Comment mainComment , String dynamicIdToBeForward , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper helper ) { super ( handle ) ; this . mainComment = mainComment ; this . dynamicIdToBeForward = dynamicIdToBeForward ; this . commentManipulator = commentManipulator ; this . config = config ; this . helper = helper ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { String commentText = mainComment . comment ; long waitTime = config . getWaitTime ( ) ; if ( dynamicIdToBeForward != null ) { commentAreaForTest = forwardDynamicToCreateNewCommentArea ( eventHandler ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_SENT , waitTime ) ; sleepAndSendProgress ( waitTime , eventHandler ) ; long fulltextRpid = commentManipulator . sendComment ( commentText , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) . rpid ; BiliComment foundComment = commentManipulator . findComment ( commentAreaForTest , fulltextRpid , <NUM_LIT> ) ; commentManipulator . deleteComment ( commentAreaForTest , fulltextRpid , false ) ; if ( foundComment != null ) { deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_COMMENT_FULL_TEXT_IS_NORMAL , commentAreaForTest ) ; return ; } int max = ( int ) ( Math . log ( ( double ) commentText . length ( ) / <NUM_LIT> ) / Math . log ( <NUM_LIT> ) ) ; int currProg = <NUM_LIT> ; Log . i ( \"<STR_LIT>\" , String . valueOf ( commentText . length ( ) ) ) ; Log . i ( \"<STR_LIT>\" , String . valueOf ( max ) ) ; String passText = \"<STR_LIT>\" ; String [ ] split = splitFromTheMiddle ( commentText ) ; SensitiveScanResult result = new SensitiveScanResult ( ) ; while ( split != null ) { System . out . println ( Arrays . toString ( split ) ) ; String [ ] finalSplit = split ; int normalPosition = passText . length ( ) ; int splitLeftPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; int splitRightPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT , normalPosition , splitLeftPosition , splitRightPosition , waitTime ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( passText + split [ <NUM_LIT> ] , <NUM_LIT> , <NUM_LIT> , commentAreaForTest , false ) ; long rpid = commentAddResult . rpid ; sleepAndSendProgress ( waitTime , eventHandler ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECKING_COMMENT , currProg , max ) ; if ( commentManipulator . findComment ( commentAreaForTest , rpid , <NUM_LIT> ) != null ) { result . normalPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; passText += split [ <NUM_LIT> ] ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ; } else { result . normalPosition = passText . length ( ) ; result . unusualPosition = passText . length ( ) + finalSplit [ <NUM_LIT> ] . length ( ) ; split = splitFromTheMiddle ( split [ <NUM_LIT> ] ) ;", "output": "} eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CHECK_RESULT , result ) ; commentManipulator . deleteComment ( commentAreaForTest , rpid , false ) ; System . out . println ( passText ) ; sleep ( <NUM_LIT> ) ; currProg ++ ; } helper . addSensitiveScanResultToHistoryComment ( mainComment . rpid , result ) ; deleteForwardedDynamic ( eventHandler , commentAreaForTest . sourceId ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_SCAN_COMPLETE ) ; } private CommentArea forwardDynamicToCreateNewCommentArea ( EventHandler eventHandler ) throws IOException , BiliBiliApiException { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_FORWARD_DYNAMIC ) ; ForwardDynamicResult forwardDynamicResult = commentManipulator . forwardDynamicUsingSubAccount ( dynamicIdToBeForward ) ; long dynRid = forwardDynamicResult . dyn_rid ; eventHandler . sendEventMessage ( EventHandler . WHAT_FORWARDED_DYNAMIC , dynRid ) ; sleepAndSendProgress ( <NUM_LIT> , eventHandler ) ; return new CommentArea ( dynRid , String . valueOf ( dynRid ) , CommentArea . AREA_TYPE_DYNAMIC17 ) ; } private void deleteForwardedDynamic ( EventHandler eventHandler , String dynamicId ) throws BiliBiliApiException , IOException { if ( dynamicIdToBeForward != null ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_DELETE_FORWARDED_DYNAMIC ) ; commentManipulator . deleteDynamicUsingSubAccount ( dynamicId ) ; } } public static String [ ] splitFromTheMiddle ( String input ) { if ( input . length ( ) >= <NUM_LIT> ) { return new String [ ] { input . substring ( <NUM_LIT> , input . length ( ) / <NUM_LIT> ) , input . substring ( input . length ( ) / <NUM_LIT> ) } ; } else { return null ; } } public void sleepAndSendProgress ( long time1 , EventHandler eventHandler ) { int time = ( int ) time1 ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , time ) ; int sleepSeg = <NUM_LIT> ; int sleepCount = time / sleepSeg ; for ( int i = <NUM_LIT> ; i <= sleepCount ; i ++ ) { sleep ( sleepSeg ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS , sleepSeg * i ) ; } eventHandler . sendEventMessage ( EventHandler . WHAT_NEW_SLEEP_PROGRESS_MAX , - <NUM_LIT> ) ; } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_COMMENT_FULL_TEXT_SENT = <NUM_LIT> ; public static final int WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT = <NUM_LIT> ; public static final int WHAT_ON_CHECKING_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CHECK_RESULT = <NUM_LIT> ; public static final int WHAT_COMMENT_FULL_TEXT_IS_NORMAL = <NUM_LIT> ; public static final int WHAT_ON_SCAN_COMPLETE = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS_MAX = <NUM_LIT> ; public static final int WHAT_NEW_SLEEP_PROGRESS = <NUM_LIT> ; public static final int WHAT_FORWARD_DYNAMIC = <NUM_LIT> ; public static final int WHAT_FORWARDED_DYNAMIC = <NUM_LIT> ; public static final int WHAT_DELETE_FORWARDED_DYNAMIC = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } }"}, {"input": "package android . os ; public class SELinux { public static final String getContext ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static final boolean isSELinuxEnabled ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ;", "output": "} public static final boolean isSELinuxEnforced ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . android . development ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . ContentValues ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . BroadcastReceiver ; import android . database . sqlite . SQLiteConstraintException ; import android . net . Uri ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Message ; import android . os . Process ; import android . os . StrictMode ; import android . provider . MediaStore ; import android . provider . MediaStore . Audio ; import android . text . Editable ; import android . text . TextWatcher ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . akanework . gramophone . R ; import org . akanework . gramophone . SdScanner ; import org . jaudiotagger . audio . AudioFile ; import org . jaudiotagger . audio . AudioFileIO ; import org . jaudiotagger . audio . exceptions . CannotReadException ; import org . jaudiotagger . audio . exceptions . CannotWriteException ; import org . jaudiotagger . audio . exceptions . InvalidAudioFrameException ; import org . jaudiotagger . audio . exceptions . ReadOnlyFileException ; import org . jaudiotagger . tag . FieldDataInvalidException ; import org . jaudiotagger . tag . FieldKey ; import org . jaudiotagger . tag . Tag ; import org . jaudiotagger . tag . TagException ; public class MediaScannerActivity extends Activity { private static final int BUFFER_SIZE = <NUM_LIT> ; ContentValues [ ] mValues = new ContentValues [ <NUM_LIT> ] ; Random mRandom = new Random ( ) ; Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; StringBuilder mBuilder = new StringBuilder ( ) ; private TextView mTitle ; private final BroadcastReceiver mReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } else if ( intent . getAction ( ) . equals ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ) { mTitle . setText ( \"<STR_LIT>\" + intent . getData ( ) . getPath ( ) ) ; } } } ; private int mNumToInsert = <NUM_LIT> ; private int mArtists ; private int mAlbums ; private int mSongs ; Runnable mDisplayUpdater = new Runnable ( ) { public void run ( ) { mTitle . setText ( \"<STR_LIT>\" + mArtists + \"<STR_LIT>\" + mAlbums + \"<STR_LIT>\" + mSongs + \"<STR_LIT>\" ) ; } } ; private ContentResolver mResolver ; private Uri mAudioUri ; private String [ ] elements = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Handler mInsertHandler = new Handler ( Looper . getMainLooper ( ) ) { @ Override public void handleMessage ( Message msg ) { if ( mNumToInsert -- > <NUM_LIT> ) { addAlbum ( ) ; runOnUiThread ( mDisplayUpdater ) ; if ( ! isFinishing ( ) ) { sendEmptyMessage ( <NUM_LIT> ) ; } } } } ; public MediaScannerActivity ( ) { } private static long copy ( InputStream source , OutputStream sink ) throws IOException { long nread = <NUM_LIT> ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > <NUM_LIT> ) { sink . write ( buf , <NUM_LIT> , n ) ; nread += n ; } return nread ; } @ Override public void onCreate ( Bundle icicle ) { StrictMode . setThreadPolicy ( StrictMode . ThreadPolicy . LAX ) ; StrictMode . setVmPolicy ( StrictMode . VmPolicy . LAX ) ; super . onCreate ( icicle ) ; setContentView ( R . layout . media_scanner_activity ) ; IntentFilter intentFilter = new IntentFilter ( Intent . ACTION_MEDIA_SCANNER_STARTED ) ; intentFilter . addAction ( Intent . ACTION_MEDIA_SCANNER_FINISHED ) ; intentFilter . addDataScheme ( \"<STR_LIT>\" ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { registerReceiver ( mReceiver , intentFilter , Context . RECEIVER_NOT_EXPORTED ) ; } else {", "output": "registerReceiver ( mReceiver , intentFilter ) ; } EditText t = ( EditText ) findViewById ( R . id . numsongs ) ; t . addTextChangedListener ( new TextWatcher ( ) { public void afterTextChanged ( Editable s ) { String text = s . toString ( ) ; try { mNumToInsert = Integer . parseInt ( text ) ; } catch ( NumberFormatException ex ) { mNumToInsert = <NUM_LIT> ; } setInsertButtonText ( ) ; } public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } ) ; mTitle = ( TextView ) findViewById ( R . id . title ) ; mResolver = getContentResolver ( ) ; mAudioUri = Audio . Media . EXTERNAL_CONTENT_URI ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] = new ContentValues ( ) ; } setInsertButtonText ( ) ; } @ Override public void onDestroy ( ) { unregisterReceiver ( mReceiver ) ; mInsertHandler . removeMessages ( <NUM_LIT> ) ; super . onDestroy ( ) ; Process . killProcess ( Process . myPid ( ) ) ; } private void setInsertButtonText ( ) { String label = getString ( R . string . insertbutton , mNumToInsert ) ; Button b = ( Button ) findViewById ( R . id . insertbutton ) ; b . setText ( label ) ; } public void insertItems ( View v ) { if ( mInsertHandler . hasMessages ( <NUM_LIT> ) ) { mInsertHandler . removeMessages ( <NUM_LIT> ) ; setInsertButtonText ( ) ; } else { mInsertHandler . sendEmptyMessage ( <NUM_LIT> ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void addAlbum ( ) { try { new File ( \"<STR_LIT>\" ) . mkdir ( ) ; InputStream bogusMp3 = getAssets ( ) . open ( \"<STR_LIT>\" ) ; bogusMp3 . mark ( <NUM_LIT> ) ; String albumArtist = \"<STR_LIT>\" ; String albumName = getRandomWord ( <NUM_LIT> ) ; int baseYear = <NUM_LIT> + mRandom . nextInt ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { mValues [ i ] . clear ( ) ; String artist = getRandomName ( ) ; final ContentValues map = mValues [ i ] ; map . put ( MediaStore . MediaColumns . DATA , \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; File file = new File ( \"<STR_LIT>\" + albumName + \"<STR_LIT>\" + artist + \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; try ( FileOutputStream f = new FileOutputStream ( file ) ) { copy ( bogusMp3 , f ) ; } bogusMp3 . reset ( ) ; bogusMp3 . mark ( <NUM_LIT> ) ; AudioFile f = AudioFileIO . read ( file ) ; Tag tag = f . getTag ( ) ; tag . setField ( FieldKey . TITLE , getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + getRandomWord ( <NUM_LIT> ) + \"<STR_LIT>\" + ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . ARTIST , artist ) ; tag . setField ( FieldKey . ALBUM_ARTIST , albumArtist ) ; tag . setField ( FieldKey . ALBUM , albumName ) ; tag . setField ( FieldKey . TRACK , String . valueOf ( i + <NUM_LIT> ) ) ; tag . setField ( FieldKey . YEAR , String . valueOf ( baseYear + mRandom . nextInt ( <NUM_LIT> ) ) ) ; f . commit ( ) ; } bogusMp3 . close ( ) ; mSongs += <NUM_LIT> ; mAlbums ++ ; mArtists += <NUM_LIT> ; } catch ( SQLiteConstraintException ex ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" , ex ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } catch ( CannotWriteException e ) { throw new RuntimeException ( e ) ; } catch ( CannotReadException e ) { throw new RuntimeException ( e ) ; } catch ( FieldDataInvalidException e ) { throw new RuntimeException ( e ) ; } catch ( TagException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidAudioFrameException e ) { throw new RuntimeException ( e ) ; } catch ( ReadOnlyFileException e ) { throw new RuntimeException ( e ) ; } } public void startScan ( View v ) { startActivity ( new Intent ( Intent . ACTION_RUN ) . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; finishAndRemoveTask ( ) ; } private String getRandomWord ( int len ) { int max = elements . length ; mBuilder . setLength ( <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { mBuilder . append ( elements [ mRandom . nextInt ( max ) ] ) ; } char c = mBuilder . charAt ( <NUM_LIT> ) ; c = Character . toUpperCase ( c ) ; mBuilder . setCharAt ( <NUM_LIT> , c ) ; return mBuilder . toString ( ) ; } private String getRandomName ( ) { boolean longfirst = mRandom . nextInt ( <NUM_LIT> ) < <NUM_LIT> ; String first = getRandomWord ( longfirst ? <NUM_LIT> : <NUM_LIT> ) ; String last = getRandomWord ( <NUM_LIT> ) ; switch ( mRandom . nextInt ( <NUM_LIT> ) ) { case <NUM_LIT> : if ( ! last . startsWith ( \"<STR_LIT>\" ) ) { last = \"<STR_LIT>\" + last ; } break ; case <NUM_LIT> : last = \"<STR_LIT>\" + last ; break ; case <NUM_LIT> : last = \"<STR_LIT>\" + last ; break ; } return first + \"<STR_LIT>\" + last ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . ListView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . widget . NestedScrollView ; import com . wmods . wppenhacer . adapter . MessageAdapter ; import com . wmods . wppenhacer . views . NoScrollListView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ShowEditMessage extends Feature { public ShowEditMessage ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var onStartMethod = Unobfuscator . loadAntiRevokeOnStartMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onStartMethod ) ) ; var onMessageEdit = Unobfuscator . loadMessageEditMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onMessageEdit ) ) ; var getEditMessage = Unobfuscator . loadGetEditMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getEditMessage ) ) ; var editMessageShowMethod = Unobfuscator . loadEditMessageShowMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( editMessageShowMethod ) ) ; var editMessageViewField = Unobfuscator . loadEditMessageViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( editMessageViewField ) ) ; XposedBridge . hookMethod ( onMessageEdit , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var editMessage = getEditMessage . invoke ( param . args [ <NUM_LIT> ] ) ; if ( editMessage == null ) return ; long timestamp = XposedHelpers . getLongField ( editMessage , \"<STR_LIT>\" ) ; if ( timestamp == <NUM_LIT> ) return ; var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; long id = fMessage . getRowId ( ) ; String newMessage = fMessage . getMessageStr ( ) ; if ( newMessage == null ) { var methods = ReflectionUtils . findAllMethodsUsingFilter ( param . args [ <NUM_LIT> ] . getClass ( ) , method -> method . getReturnType ( ) == String . class && ReflectionUtils . isOverridden ( method ) ) ; for ( var method : methods ) { newMessage = ( String ) method . invoke ( param . args [ <NUM_LIT> ] ) ; if ( newMessage != null ) break ; } if ( newMessage == null ) return ; } try { MessageHistory . getInstance ( ) . insertMessage ( id , newMessage , timestamp ) ; } catch ( Exception e ) { logDebug ( e ) ; } } } ) ; XposedBridge . hookMethod ( editMessageShowMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var textView = ( TextView ) editMessageViewField . get ( param . thisObject ) ; if ( textView != null && ! textView . getText ( ) . toString ( ) . contains ( \"<STR_LIT>\" ) ) { textView . getPaint ( ) . setUnderlineText ( true ) ; textView . append ( \"<STR_LIT>\" ) ; textView . setOnClickListener ( ( v ) -> { try { var messageObj = XposedHelpers . callMethod ( param . thisObject , \"<STR_LIT>\" ) ; var fMesage = new FMessageWpp ( messageObj ) ; long id = fMesage . getRowId ( ) ; var msg = new MessageHistory . MessageItem ( id , MessageStore . getInstance ( ) . getMessageById ( id ) , <NUM_LIT> ) ; var messages = MessageHistory . getInstance ( ) . getMessages ( id ) ; if ( messages == null ) { messages = new ArrayList < > ( ) ; } else { messages . add ( <NUM_LIT> , msg ) ; } showBottomDialog ( messages ) ; } catch ( Exception exception0 ) { logDebug ( exception0 ) ; } } ) ; } } } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void showBottomDialog ( ArrayList < MessageHistory . MessageItem > messages ) { Objects . requireNonNull ( WppCore . getCurrentConversation ( ) ) . runOnUiThread ( ( ) -> { var ctx = ( Context ) WppCore . getCurrentConversation ( ) ; var dialog = WppCore . createBottomDialog ( ctx ) ; NestedScrollView nestedScrollView0 = new NestedScrollView ( ctx , null ) ; nestedScrollView0 . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; nestedScrollView0 . setFillViewport ( true ) ; nestedScrollView0 . setFitsSystemWindows ( true ) ;", "output": "LinearLayout linearLayout = new LinearLayout ( ctx ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; LinearLayout . LayoutParams layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; linearLayout . setFitsSystemWindows ( true ) ; linearLayout . setMinimumHeight ( layoutParams . height = Utils . getApplication ( ) . getResources ( ) . getDisplayMetrics ( ) . heightPixels / <NUM_LIT> ) ; linearLayout . setLayoutParams ( layoutParams ) ; int dip = Utils . dipToPixels ( <NUM_LIT> ) ; linearLayout . setPadding ( dip , dip , dip , <NUM_LIT> ) ; var bg = DesignUtils . createDrawable ( \"<STR_LIT>\" , DesignUtils . getPrimarySurfaceColor ( ) ) ; linearLayout . setBackground ( bg ) ; TextView titleView = new TextView ( ctx ) ; LinearLayout . LayoutParams layoutParams1 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams1 . weight = <NUM_LIT> ; layoutParams1 . setMargins ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; titleView . setLayoutParams ( layoutParams1 ) ; titleView . setTextSize ( <NUM_LIT> ) ; titleView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; titleView . setTypeface ( null , Typeface . BOLD ) ; titleView . setText ( ResId . string . edited_history ) ; var adapter = new MessageAdapter ( ctx , messages ) ; ListView listView = new NoScrollListView ( ctx ) ; LinearLayout . LayoutParams layoutParams2 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ; layoutParams2 . weight = <NUM_LIT> ; listView . setLayoutParams ( layoutParams2 ) ; listView . setAdapter ( adapter ) ; ImageView imageView0 = new ImageView ( ctx ) ; LinearLayout . LayoutParams layoutParams4 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams4 . gravity = <NUM_LIT> ; layoutParams4 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; var bg2 = DesignUtils . createDrawable ( \"<STR_LIT>\" , Color . BLACK ) ; imageView0 . setBackground ( DesignUtils . alphaDrawable ( bg2 , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; imageView0 . setLayoutParams ( layoutParams4 ) ; Button okButton = new Button ( ctx ) ; LinearLayout . LayoutParams layoutParams3 = new LinearLayout . LayoutParams ( - <NUM_LIT> , - <NUM_LIT> ) ; layoutParams3 . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams3 . gravity = <NUM_LIT> ; okButton . setLayoutParams ( layoutParams3 ) ; okButton . setGravity ( <NUM_LIT> ) ; var drawable = DesignUtils . createDrawable ( \"<STR_LIT>\" , Color . BLACK ) ; okButton . setBackground ( DesignUtils . alphaDrawable ( drawable , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ) ; okButton . setText ( \"<STR_LIT>\" ) ; okButton . setOnClickListener ( ( View view ) -> dialog . dismissDialog ( ) ) ; linearLayout . addView ( imageView0 ) ; linearLayout . addView ( titleView ) ; linearLayout . addView ( listView ) ; linearLayout . addView ( okButton ) ; nestedScrollView0 . addView ( linearLayout ) ; dialog . setContentView ( nestedScrollView0 ) ; dialog . setCanceledOnTouchOutside ( true ) ; dialog . showDialog ( ) ; } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideSeen extends Feature { public HideSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method SendReadReceiptJobMethod = Unobfuscator . loadHideViewSendReadJob ( classLoader ) ; var sendJob = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( SendReadReceiptJobMethod ) ) ; var hideread = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var hideread_group = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var hidestatusview = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; XposedBridge . hookMethod ( SendReadReceiptJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! sendJob . isInstance ( param . thisObject ) ) return ; var srj = sendJob . cast ( param . thisObject ) ; var messageIds = XposedHelpers . getObjectField ( srj , \"<STR_LIT>\" ) ; var firstmessage = ( String ) Array . get ( messageIds , <NUM_LIT> ) ; if ( firstmessage != null && WppCore . getPrivBoolean ( firstmessage + \"<STR_LIT>\" , false ) ) { WppCore . removePrivKey ( firstmessage + \"<STR_LIT>\" ) ; return ; } var jid = ( String ) XposedHelpers . getObjectField ( srj , \"<STR_LIT>\" ) ; if ( jid == null ) return ; if ( WppCore . isGroup ( jid ) ) { if ( hideread_group ) param . setResult ( null ) ; } else if ( jid . startsWith ( \"<STR_LIT>\" ) ) { if ( hidestatusview ) param . setResult ( null ) ; }", "output": "else if ( hideread ) { param . setResult ( null ) ; } } } ) ; Method hideViewInChatMethod = Unobfuscator . loadHideViewInChatMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewInChatMethod ) ) ; Method hideViewMethod = Unobfuscator . loadHideViewMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( hideViewMethod ) ) ; XposedBridge . hookMethod ( hideViewMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! Unobfuscator . isCalledFromMethod ( hideViewInChatMethod ) ) return ; if ( param . args [ <NUM_LIT> ] == null || ! param . args [ <NUM_LIT> ] . equals ( \"<STR_LIT>\" ) ) return ; var jid = WppCore . getCurrentRawJID ( ) ; if ( WppCore . isGroup ( jid ) ) { if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) param . args [ <NUM_LIT> ] = null ; } else if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { param . args [ <NUM_LIT> ] = null ; } } } ) ; var methodPlayerViewJid = Unobfuscator . loadHideViewAudioMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPlayerViewJid ) ) ; XposedBridge . hookMethod ( methodPlayerViewJid , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) param . setResult ( true ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; import android . annotation . SuppressLint ; import android . content . SharedPreferences ; import android . content . res . XResources ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . os . Build ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . WppXposed ; import com . wmods . wppenhacer . xposed . core . WppCore ; import de . robv . android . xposed . XposedBridge ; public class DesignUtils { private static SharedPreferences mPrefs ; @ SuppressLint ( \"<STR_LIT>\" ) public static Drawable getDrawable ( int id ) { return Utils . getApplication ( ) . getDrawable ( id ) ; } @ Nullable public static Drawable getDrawableByName ( String name ) { var id = Utils . getID ( name , \"<STR_LIT>\" ) ; if ( id == <NUM_LIT> ) return null ; return DesignUtils . getDrawable ( id ) ; } @ Nullable public static Drawable getIconByName ( String name , boolean isTheme ) { var id = Utils . getID ( name , \"<STR_LIT>\" ) ; if ( id == <NUM_LIT> ) return null ; var icon = DesignUtils . getDrawable ( id ) ; if ( isTheme && icon != null ) { return DesignUtils . coloredDrawable ( icon , isNightMode ( ) ? Color . WHITE : Color . BLACK ) ; } return icon ; } @ NonNull public static Drawable coloredDrawable ( Drawable drawable , int color ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { drawable . setColorFilter ( new BlendModeColorFilter ( color , BlendMode . SRC_ATOP ) ) ; } else { drawable . setColorFilter ( color , PorterDuff . Mode . SRC_ATOP ) ; } return drawable ; } @ SuppressLint ( \"<STR_LIT>\" ) public static Drawable alphaDrawable ( Drawable drawable , int primaryTextColor , int i ) { Drawable coloredDrawable = DesignUtils . coloredDrawable ( drawable , primaryTextColor ) ; coloredDrawable . setAlpha ( i ) ; return coloredDrawable ; } @ NonNull public static Drawable createDrawable ( String type , int color ) { switch ( type ) { case \"<STR_LIT>\" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; var shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case \"<STR_LIT>\" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable selectorBg = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; selectorBg . getPaint ( ) . setColor ( color ) ; return selectorBg ; } case \"<STR_LIT>\" -> { var border = Utils . dipToPixels ( <NUM_LIT> ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new RoundRectShape ( new float [ ] { border , border , border , border , border , border , border , border } , null , null ) ) ; shapeDrawable . getPaint ( ) . setColor ( color ) ; return shapeDrawable ; } case \"<STR_LIT>\" -> { float radius = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] outerRadii = new float [ ] { radius , radius , radius , radius , radius , radius , radius , radius } ; RoundRectShape roundRectShape = new RoundRectShape ( outerRadii , null , null ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( roundRectShape ) ; Paint paint = shapeDrawable . getPaint ( ) ; paint . setColor ( Color . TRANSPARENT ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( Utils . dipToPixels ( <NUM_LIT> ) ) ; paint . setColor ( color ) ; int inset = Utils . dipToPixels ( <NUM_LIT> ) ; return new InsetDrawable ( shapeDrawable , inset , inset , inset , inset ) ; } } return new ColorDrawable ( Color . BLACK ) ; } public static int getPrimaryTextColor ( ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } public static int getUnSeenColor ( ) { var primaryColor = mPrefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( primaryColor == <NUM_LIT> || ! mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ) { return <NUM_LIT> ; } return primaryColor ; } public static int getPrimarySurfaceColor ( ) { var backgroundColor = mPrefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( backgroundColor == <NUM_LIT> || ! mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ) { return DesignUtils . isNightMode ( ) ? <NUM_LIT> : <NUM_LIT> ; } return backgroundColor ;", "output": "} public static void setReplacementDrawable ( String name , Drawable replacement ) { if ( WppXposed . ResParam == null ) return ; WppXposed . ResParam . res . setReplacement ( Utils . getApplication ( ) . getPackageName ( ) , \"<STR_LIT>\" , name , new XResources . DrawableLoader ( ) { @ Override public Drawable newDrawable ( XResources res , int id ) throws Throwable { return replacement ; } } ) ; } public static boolean isNightMode ( ) { return WppCore . getDefaultTheme ( ) == - <NUM_LIT> ? isNightModeBySystem ( ) : WppCore . getDefaultTheme ( ) == <NUM_LIT> ; } public static boolean isNightModeBySystem ( ) { return ( Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . uiMode & <NUM_LIT> ) == <NUM_LIT> ; } public static void setPrefs ( SharedPreferences mPrefs ) { DesignUtils . mPrefs = mPrefs ; } public static boolean isValidColor ( String primaryColor ) { try { Color . parseColor ( primaryColor ) ; return true ; } catch ( Exception e ) { return false ; } } public static String checkSystemColor ( String color ) { if ( DesignUtils . isValidColor ( color ) ) { return color ; } try { if ( color . startsWith ( \"<STR_LIT>\" ) ) { var idColor = color . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var colorRes = android . R . color . class . getField ( idColor ) . getInt ( null ) ; if ( colorRes != - <NUM_LIT> ) { return \"<STR_LIT>\" + Integer . toHexString ( ContextCompat . getColor ( Utils . getApplication ( ) , colorRes ) ) ; } } } catch ( Exception e ) { XposedBridge . log ( \"<STR_LIT>\" + e ) ; } return \"<STR_LIT>\" ; } }"}, {"input": "package in . hridayan . ashell . fragments ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . appcompat . widget . LinearLayoutCompat ; import androidx . fragment . app . Fragment ; import androidx . preference . PreferenceManager ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import rikka . shizuku . Shizuku ; public class StartFragment extends Fragment { public StartFragment ( ) { } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_start , container , false ) ; initViews ( view ) ; return view ; } private void initViews ( View view ) { LinearLayoutCompat mStartLayout = view . findViewById ( R . id . fragment_start ) ; MaterialButton mStartButton = view . findViewById ( R . id . start_button ) ; MaterialTextView mAboutText = view . findViewById ( R . id . about_text ) ; if ( Shizuku . pingBinder ( ) ) { Shizuku . requestPermission ( <NUM_LIT> ) ; } mStartLayout . setVisibility ( View . VISIBLE ) ; mAboutText . setText ( getString ( R . string . app_summary ) ) ; mStartButton . setOnClickListener ( v -> { PreferenceManager . getDefaultSharedPreferences ( requireContext ( ) ) . edit ( ) . putBoolean ( \"<STR_LIT>\" , false ) . apply ( ) ; getParentFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . fragment_container , new aShellFragment ( ) ) . commit ( ) ; } ) ; }", "output": "}"}, {"input": "package com . simon . harmonichackernews ; import android . os . Bundle ; import androidx . appcompat . app . AppCompatActivity ; import com . simon . harmonichackernews . utils . ThemeUtils ; public class SplitPlaceholderActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) {", "output": "super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_split_placeholder ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideTagForward extends Feature { public HideTagForward ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { Method method = Unobfuscator . loadForwardTagMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; Class < ? > forwardClass = Unobfuscator . loadForwardClassMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + forwardClass . getName ( ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var arg = ( int ) param . args [ <NUM_LIT> ] ; if ( arg == <NUM_LIT> ) { if ( Unobfuscator . isCalledFromClass ( forwardClass ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } }", "output": "} } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "public class WebAppInterface { Context mContext ; public void test1 ( ) { MSTG_ENV_008_JS_Interface jsInterface = new MSTG_ENV_008_JS_Interface ( this ) ; myWebView . addJavascriptInterface ( jsInterface , \"<STR_LIT>\" ) ; } } public class WebAppInterface extends WebView { Context mContext ; public void test2 ( ) { addJavascriptInterface ( new MSTG_ENV_008_JS_Interface ( this ) , \"<STR_LIT>\" ) ; } public void test3 ( ) {", "output": "this . addJavascriptInterface ( new MSTG_ENV_008_JS_Interface ( this ) , \"<STR_LIT>\" ) ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . RCTEventEmitter ; public class KeyboardPositionChangedEvent extends Event < KeyboardPositionChangedEvent > { private final int position ; public KeyboardPositionChangedEvent ( int viewId , int position ) { super ( viewId ) ; this . position = position ; }", "output": "@ Override public String getEventName ( ) { return \"<STR_LIT>\" ; } @ Override public void dispatch ( RCTEventEmitter rctEventEmitter ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( position ) ) ; rctEventEmitter . receiveEvent ( getViewTag ( ) , getEventName ( ) , map ) ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . app . Dialog ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . simon . harmonichackernews . utils . AccountUtils ; import com . simon . harmonichackernews . utils . ViewUtils ; public class LoginDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireActivity ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . login_dialog , null ) ; builder . setView ( rootView ) ; AlertDialog dialog = builder . create ( ) ; TextInputEditText usernameInput = rootView . findViewById ( R . id . login_dialog_username ) ; TextInputEditText passwordInput = rootView . findViewById ( R . id . login_dialog_password ) ; MaterialButton cancelButton = rootView . findViewById ( R . id . login_dialog_cancel ) ; MaterialButton saveButton = rootView . findViewById ( R . id . login_dialog_save ) ; Button infoButton = rootView . findViewById ( R . id . login_dialog_more_info ) ; LinearLayout infoContainer = rootView . findViewById ( R . id . login_dialog_info_container ) ; usernameInput . addTextChangedListener ( new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; } } ) ; passwordInput . addTextChangedListener ( new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; } } ) ;", "output": "boolean usernameHasText = ! TextUtils . isEmpty ( usernameInput . getText ( ) . toString ( ) ) ; boolean passwordHasText = ! TextUtils . isEmpty ( passwordInput . getText ( ) . toString ( ) ) ; saveButton . setEnabled ( usernameHasText && passwordHasText ) ; cancelButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { dismiss ( ) ; } } ) ; saveButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { AccountUtils . setAccountDetails ( getContext ( ) , usernameInput . getText ( ) . toString ( ) , passwordInput . getText ( ) . toString ( ) ) ; dismiss ( ) ; } } ) ; infoButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { infoButton . setVisibility ( View . GONE ) ; infoContainer . setVisibility ( View . VISIBLE ) ; } } ) ; return dialog ; } }"}, {"input": "package com . norman . webviewup . lib ; import android . content . Context ; import android . content . pm . ApplicationInfo ; import android . content . pm . PackageInfo ; import android . os . Build ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Looper ; import android . text . TextUtils ; import android . webkit . WebView ; import com . norman . webviewup . lib . hook . PackageManagerServiceHook ; import com . norman . webviewup . lib . hook . WebViewUpdateServiceHook ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . interfaces . IWebViewFactory ; import com . norman . webviewup . lib . service . interfaces . IWebViewUpdateService ; import com . norman . webviewup . lib . util . FileUtils ; public class WebViewReplace { private static PackageInfo SYSTEM_WEB_VIEW_PACKAGE_INFO ; private static PackageInfo REPLACE_WEB_VIEW_PACKAGE_INFO ; public synchronized static void replace ( Context context , String apkPath , String libsPath ) throws WebViewReplaceException { PackageManagerServiceHook managerHook = null ; WebViewUpdateServiceHook updateServiceHook = null ; try { if ( context == null ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } if ( ! FileUtils . existFile ( apkPath ) ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } if ( Looper . myLooper ( ) != Looper . getMainLooper ( ) ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } PackageInfo packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , <NUM_LIT> ) ; if ( packageInfo == null ) { throw new WebViewReplaceException ( apkPath + \"<STR_LIT>\" ) ; } int sdkVersion = Build . VERSION . SDK_INT ; ApplicationInfo applicationInfo = packageInfo . applicationInfo ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { if ( sdkVersion < applicationInfo . minSdkVersion ) { throw new WebViewReplaceException ( \"<STR_LIT>\" + sdkVersion + \"<STR_LIT>\" + applicationInfo . minSdkVersion + \"<STR_LIT>\" + apkPath ) ; } } managerHook = new PackageManagerServiceHook ( context , packageInfo . packageName , apkPath , libsPath ) ; updateServiceHook = new WebViewUpdateServiceHook ( context , packageInfo . packageName ) ; managerHook . hook ( ) ; updateServiceHook . hook ( ) ; if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } checkWebView ( context ) ; REPLACE_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } catch ( Throwable throwable ) { if ( throwable instanceof WebViewReplaceException ) { throw throwable ; } else { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = \"<STR_LIT>\" ; } throw new WebViewReplaceException ( message , throwable ) ; } } finally { try { if ( managerHook != null ) { managerHook . restore ( ) ; } if ( updateServiceHook != null ) { updateServiceHook . restore ( ) ; } } catch ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = \"<STR_LIT>\" ; } throw new WebViewReplaceException ( message , throwable ) ; } } } public synchronized static void replace ( Context context , PackageInfo packageInfo ) throws WebViewReplaceException { WebViewUpdateServiceHook updateServiceHook = null ; try { if ( context == null ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } if ( packageInfo == null ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } if ( Looper . myLooper ( ) != Looper . getMainLooper ( ) ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } updateServiceHook = new WebViewUpdateServiceHook ( context , packageInfo . packageName ) ; updateServiceHook . hook ( ) ; if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } checkWebView ( context ) ; REPLACE_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } catch ( Throwable throwable ) { if ( throwable instanceof WebViewReplaceException ) { throw throwable ; } else { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = \"<STR_LIT>\" ; } throw new WebViewReplaceException ( message , throwable ) ; } } finally { try { if ( updateServiceHook != null ) { updateServiceHook . restore ( ) ; } } catch ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( TextUtils . isEmpty ( message ) ) { message = \"<STR_LIT>\" ; } throw new WebViewReplaceException ( message , throwable ) ; } } } public synchronized static String getSystemWebViewPackageName ( ) { if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } return SYSTEM_WEB_VIEW_PACKAGE_INFO != null ? SYSTEM_WEB_VIEW_PACKAGE_INFO . packageName : null ; } public synchronized static String getSystemWebViewPackageVersion ( ) { if ( SYSTEM_WEB_VIEW_PACKAGE_INFO == null ) { SYSTEM_WEB_VIEW_PACKAGE_INFO = loadCurrentWebViewPackageInfo ( ) ; } return SYSTEM_WEB_VIEW_PACKAGE_INFO != null ? SYSTEM_WEB_VIEW_PACKAGE_INFO . versionName : null ; } public synchronized static String getReplaceWebViewPackageName ( ) { return REPLACE_WEB_VIEW_PACKAGE_INFO != null ? REPLACE_WEB_VIEW_PACKAGE_INFO . packageName : null ; } public synchronized static String getReplaceWebViewVersion ( ) { return REPLACE_WEB_VIEW_PACKAGE_INFO != null ? REPLACE_WEB_VIEW_PACKAGE_INFO . versionName : null ; } private static void checkWebView ( Context context ) throws WebViewReplaceException { IWebViewFactory webViewFactory = RuntimeAccess . staticAccess ( IWebViewFactory . class ) ; Object providerInstance = webViewFactory . getProviderInstance ( ) ; if ( providerInstance != null ) { throw new WebViewReplaceException ( \"<STR_LIT>\" ) ; } new WebView ( context ) ; } private static PackageInfo loadCurrentWebViewPackageInfo ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { try { return WebView . getCurrentWebViewPackage ( ) ; } catch ( Throwable ignore ) { } } try { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IBinder binder = serviceManager . getService ( IWebViewUpdateService . SERVICE ) ; IWebViewUpdateService service = RuntimeAccess . staticAccess ( IWebViewUpdateService . class ) ; IInterface iInterface = service . asInterface ( binder ) ; service = RuntimeAccess . objectAccess ( IWebViewUpdateService . class , iInterface ) ; return service . getCurrentWebViewPackage ( ) ;", "output": "} catch ( Throwable ignore ) { } return null ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . filepicker ; import android . database . Cursor ; import android . graphics . BitmapFactory ; import android . media . MediaMetadataRetriever ; import android . net . Uri ; import android . provider . DocumentsContract ; import android . provider . OpenableColumns ; import android . util . Base64 ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . Bridge ; import com . getcapacitor . Logger ; import java . io . ByteArrayOutputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public class FilePicker { public static final String TAG = \"<STR_LIT>\" ; private Bridge bridge ; FilePicker ( Bridge bridge ) { this . bridge = bridge ; } public String getPathFromUri ( @ NonNull Uri uri ) { return uri . toString ( ) ; } public String getNameFromUri ( @ NonNull Uri uri ) { String displayName = \"<STR_LIT>\" ; String [ ] projection = { OpenableColumns . DISPLAY_NAME } ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( projection [ <NUM_LIT> ] ) ; displayName = cursor . getString ( columnIdx ) ; cursor . close ( ) ; } if ( displayName == null || displayName . length ( ) < <NUM_LIT> ) { displayName = uri . getLastPathSegment ( ) ; } return displayName ; } public String getDataFromUri ( @ NonNull Uri uri ) { try { InputStream stream = bridge . getActivity ( ) . getContentResolver ( ) . openInputStream ( uri ) ; byte [ ] bytes = getBytesFromInputStream ( stream ) ; return Base64 . encodeToString ( bytes , Base64 . NO_WRAP ) ; } catch ( FileNotFoundException e ) { Logger . error ( TAG , \"<STR_LIT>\" , e ) ; } catch ( IOException e ) { Logger . error ( TAG , \"<STR_LIT>\" , e ) ; } return \"<STR_LIT>\" ; } @ Nullable public String getMimeTypeFromUri ( @ NonNull Uri uri ) { return bridge . getContext ( ) . getContentResolver ( ) . getType ( uri ) ; } @ Nullable public Long getModifiedAtFromUri ( @ NonNull Uri uri ) { try { long modifiedAt = <NUM_LIT> ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , null , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( DocumentsContract . Document . COLUMN_LAST_MODIFIED ) ; modifiedAt = cursor . getLong ( columnIdx ) ; cursor . close ( ) ; } return modifiedAt ; } catch ( Exception e ) { Logger . error ( TAG , \"<STR_LIT>\" , e ) ; return null ; } } public long getSizeFromUri ( @ NonNull Uri uri ) { long size = <NUM_LIT> ; String [ ] projection = { OpenableColumns . SIZE } ; Cursor cursor = bridge . getContext ( ) . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; if ( cursor != null ) { cursor . moveToFirst ( ) ; int columnIdx = cursor . getColumnIndex ( projection [ <NUM_LIT> ] ) ; size = cursor . getLong ( columnIdx ) ; cursor . close ( ) ; } return size ; } @ Nullable public Long getDurationFromUri ( @ NonNull Uri uri ) { if ( isVideoUri ( uri ) ) { MediaMetadataRetriever retriever = new MediaMetadataRetriever ( ) ; retriever . setDataSource ( bridge . getContext ( ) , uri ) ; String time = retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_DURATION ) ; long durationMs = Long . parseLong ( time ) ; try { retriever . release ( ) ; } catch ( Exception e ) { Logger . error ( TAG , \"<STR_LIT>\" , e ) ; } return durationMs / <NUM_LIT> ; } return null ; } @ Nullable public FileResolution getHeightAndWidthFromUri ( @ NonNull Uri uri ) { if ( isImageUri ( uri ) ) { BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; try { BitmapFactory . decodeStream ( bridge . getContext ( ) . getContentResolver ( ) . openInputStream ( uri ) , null , options ) ; return new FileResolution ( options . outHeight , options . outWidth ) ; } catch ( FileNotFoundException exception ) { exception . printStackTrace ( ) ; return null ; } } else if ( isVideoUri ( uri ) ) { MediaMetadataRetriever retriever = new MediaMetadataRetriever ( ) ; retriever . setDataSource ( bridge . getContext ( ) , uri ) ; int width = Integer . valueOf ( retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_VIDEO_WIDTH ) ) ; int height = Integer . valueOf ( retriever . extractMetadata ( MediaMetadataRetriever . METADATA_KEY_VIDEO_HEIGHT ) ) ; try { retriever . release ( ) ; } catch ( Exception e ) { Logger . error ( TAG , \"<STR_LIT>\" , e ) ; } return new FileResolution ( height , width ) ; } return null ; }", "output": "private boolean isImageUri ( Uri uri ) { String mimeType = getMimeTypeFromUri ( uri ) ; if ( mimeType == null ) { return false ; } return mimeType . startsWith ( \"<STR_LIT>\" ) ; } private boolean isVideoUri ( Uri uri ) { String mimeType = getMimeTypeFromUri ( uri ) ; if ( mimeType == null ) { return false ; } return mimeType . startsWith ( \"<STR_LIT>\" ) ; } private static byte [ ] getBytesFromInputStream ( InputStream is ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; for ( int len = is . read ( buffer ) ; len != - <NUM_LIT> ; len = is . read ( buffer ) ) { os . write ( buffer , <NUM_LIT> , len ) ; } return os . toByteArray ( ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public class SimpleWakeupListener implements IWakeupListener { private static final String TAG = \"<STR_LIT>\" ; @ Override public void onSuccess ( String word , WakeUpResult result ) { MyLogger . info ( TAG , \"<STR_LIT>\" + word ) ; } @ Override public void onStop ( ) { MyLogger . info ( TAG , \"<STR_LIT>\" ) ; } @ Override public void onError ( int errorCode , String errorMessge , WakeUpResult result ) {", "output": "MyLogger . info ( TAG , \"<STR_LIT>\" + errorCode + \"<STR_LIT>\" + errorMessge + \"<STR_LIT>\" + result . getOrigalJson ( ) ) ; } @ Override public void onASrAudio ( byte [ ] data , int offset , int length ) { MyLogger . error ( TAG , \"<STR_LIT>\" + data . length ) ; } }"}, {"input": "package com . appspa . update . utils ; import android . annotation . SuppressLint ; import android . app . ActivityManager ; import android . content . ActivityNotFoundException ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . graphics . Bitmap ; import android . graphics . Canvas ; import android . graphics . PixelFormat ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . net . ConnectivityManager ; import android . net . NetworkInfo ; import android . os . Environment ; import android . os . Looper ; import android . text . TextUtils ; import android . util . DisplayMetrics ; import androidx . annotation . NonNull ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . R ; import com . appspa . update . AppSpace ; import com . appspa . update . _AppSpace ; import com . appspa . update . logs . UpdateLog ; import java . io . File ; import java . util . List ; public final class UpdateUtils { private static final String IGNORE_VERSION = \"<STR_LIT>\" ; private static final String PREFS_FILE = \"<STR_LIT>\" ; private static final String KEY_SPA = \"<STR_LIT>\" ; private UpdateUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static void processUpdateEntity ( UpdateEntity updateEntity , @ NonNull String result , @ NonNull IUpdateProxy updateProxy ) throws Exception { if ( updateEntity != null ) { if ( updateEntity . isHasUpdate ( ) ) { if ( updateEntity . isIgnorable ( ) && UpdateUtils . isIgnoreVersion ( updateProxy . getContext ( ) , updateEntity . getVersionName ( ) ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_IGNORED_VERSION ) ; } else if ( TextUtils . isEmpty ( updateEntity . getCacheDir ( ) ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_APK_CACHE_DIR_EMPTY ) ; } else { updateProxy . findNewVersion ( updateEntity , updateProxy ) ; } } else { updateProxy . noNewVersion ( null ) ; } } else { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , \"<STR_LIT>\" + result ) ; } } public static < T > T requireNonNull ( final T object , final String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; } public static boolean checkWifi ( ) { ConnectivityManager connectivity = ( ConnectivityManager ) AppSpace . getContext ( ) . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( connectivity == null ) { return false ; } NetworkInfo info = connectivity . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) && info . getType ( ) == ConnectivityManager . TYPE_WIFI ; } public static boolean checkNetwork ( ) { ConnectivityManager connectivity = ( ConnectivityManager ) AppSpace . getContext ( ) . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( connectivity == null ) { return false ; } NetworkInfo info = connectivity . getActiveNetworkInfo ( ) ; return info != null && info . isConnected ( ) ; } public static int getVersionCode ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . versionCode : - <NUM_LIT> ; } public static String getBaseApkMd5 ( Context context ) { String baseApkSource = ApkUtils . getSourceApkPath ( context , context . getPackageName ( ) ) ; return _AppSpace . encryptFile ( FileUtils . getFileByPath ( baseApkSource ) ) ; } public static String getVersionName ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . versionName : \"<STR_LIT>\" ; } public static int compareVersionName ( @ NonNull String versionName1 , @ NonNull String versionName2 ) { if ( versionName1 . equals ( versionName2 ) ) { return <NUM_LIT> ; } String [ ] versionArray1 = versionName1 . split ( \"<STR_LIT>\" ) ; String [ ] versionArray2 = versionName2 . split ( \"<STR_LIT>\" ) ; int idx = <NUM_LIT> ; int minLength = Math . min ( versionArray1 . length , versionArray2 . length ) ; int diff = <NUM_LIT> ; while ( idx < minLength && ( diff = versionArray1 [ idx ] . length ( ) - versionArray2 [ idx ] . length ( ) ) == <NUM_LIT> && ( diff = versionArray1 [ idx ] . compareTo ( versionArray2 [ idx ] ) ) == <NUM_LIT> ) { ++ idx ; } diff = ( diff != <NUM_LIT> ) ? diff : versionArray1 . length - versionArray2 . length ; return diff ; } public static int dip2px ( int dip , Context context ) { return ( int ) ( dip * getDensity ( context ) + <NUM_LIT> ) ; } private static float getDensity ( Context context ) { return getDisplayMetrics ( context ) . density ; } private static DisplayMetrics getDisplayMetrics ( Context context ) { return context . getResources ( ) . getDisplayMetrics ( ) ; } public static Bitmap drawable2Bitmap ( final Drawable drawable ) { if ( drawable instanceof BitmapDrawable ) { BitmapDrawable bitmapDrawable = ( BitmapDrawable ) drawable ; if ( bitmapDrawable . getBitmap ( ) != null ) { return bitmapDrawable . getBitmap ( ) ; } } Bitmap bitmap ; if ( drawable . getIntrinsicWidth ( ) <= <NUM_LIT> || drawable . getIntrinsicHeight ( ) <= <NUM_LIT> ) { bitmap = Bitmap . createBitmap ( <NUM_LIT> , <NUM_LIT> , drawable . getOpacity ( ) != PixelFormat . OPAQUE ? Bitmap . Config . ARGB_8888 : Bitmap . Config . RGB_565 ) ; } else { bitmap = Bitmap . createBitmap ( drawable . getIntrinsicWidth ( ) , drawable . getIntrinsicHeight ( ) , drawable . getOpacity ( ) != PixelFormat . OPAQUE ? Bitmap . Config . ARGB_8888 : Bitmap . Config . RGB_565 ) ; } Canvas canvas = new Canvas ( bitmap ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , canvas . getWidth ( ) , canvas . getHeight ( ) ) ; drawable . draw ( canvas ) ; return bitmap ; } private static SharedPreferences getSP ( Context context ) { return context . getSharedPreferences ( PREFS_FILE , Context . MODE_PRIVATE ) ; } public static void saveIgnoreVersion ( Context context , String newVersion ) { getSP ( context ) . edit ( ) . putString ( IGNORE_VERSION , newVersion ) . apply ( ) ; } public static boolean isIgnoreVersion ( Context context , String newVersion ) { return getSP ( context ) . getString ( IGNORE_VERSION , \"<STR_LIT>\" ) . equals ( newVersion ) ; } @ NonNull public static String getDisplayUpdateInfo ( Context context , @ NonNull UpdateEntity updateEntity ) { String targetSize = byte2FitMemorySize ( updateEntity . getCurDownloadEntity ( ) . getSize ( ) ) ; final String updateContent = updateEntity . getUpdateContent ( ) ; String updateInfo = \"<STR_LIT>\" ; if ( ! TextUtils . isEmpty ( targetSize ) ) { updateInfo = context . getString ( R . string . space_lab_new_version_size ) + targetSize + \"<STR_LIT>\" ; } if ( ! TextUtils . isEmpty ( updateContent ) ) { updateInfo += updateContent ;", "output": "} return updateInfo ; } @ SuppressLint ( \"<STR_LIT>\" ) private static String byte2FitMemorySize ( final long byteNum ) { if ( byteNum <= <NUM_LIT> ) { return \"<STR_LIT>\" ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , ( double ) byteNum ) ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , ( double ) byteNum / <NUM_LIT> ) ; } else if ( byteNum < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , ( double ) byteNum / <NUM_LIT> ) ; } else { return String . format ( \"<STR_LIT>\" , ( double ) byteNum / <NUM_LIT> ) ; } } public static boolean isApkDownloaded ( UpdateEntity updateEntity ) { File appFile = getApkFileByUpdateEntity ( updateEntity ) ; String md5 = updateEntity . getCurDownloadEntity ( ) . getWholeMd5 ( ) ; return ! TextUtils . isEmpty ( md5 ) && FileUtils . isFileExists ( appFile ) && _AppSpace . isFileValid ( md5 , appFile ) ; } public static File getApkFileByUpdateEntity ( UpdateEntity updateEntity ) { String appName = getFileNameByDownloadUrl ( updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ) ; if ( appName != null && appName . endsWith ( \"<STR_LIT>\" ) ) { appName = appName . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return new File ( updateEntity . getCacheDir ( ) . concat ( File . separator + updateEntity . getVersionName ( ) ) . concat ( File . separator + appName ) ) ; } @ NonNull public static String getFileNameByDownloadUrl ( String downloadUrl ) { if ( TextUtils . isEmpty ( downloadUrl ) ) { return \"<STR_LIT>\" + System . currentTimeMillis ( ) + \"<STR_LIT>\" ; } else { String appName = downloadUrl . substring ( downloadUrl . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; return appName ; } } public static String getDiskCacheDir ( Context context , String uniqueName ) { String cachePath ; if ( isSDCardEnable ( ) && context . getExternalCacheDir ( ) != null ) { cachePath = context . getExternalCacheDir ( ) . getPath ( ) ; } else { cachePath = context . getCacheDir ( ) . getPath ( ) ; } return cachePath + File . separator + uniqueName ; } public static File getDefaultDiskCacheDir ( ) { return FileUtils . getFileByPath ( getDefaultDiskCacheDirPath ( ) ) ; } public static boolean isPrivateApkCacheDir ( @ NonNull UpdateEntity updateEntity ) { return FileUtils . isPrivatePath ( AppSpace . getContext ( ) , updateEntity . getCacheDir ( ) ) ; } public static String getDefaultDiskCacheDirPath ( ) { return UpdateUtils . getDiskCacheDir ( AppSpace . getContext ( ) , KEY_SPA ) ; } private static boolean isSDCardEnable ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) || ! Environment . isExternalStorageRemovable ( ) ; } private static PackageInfo getPackageInfo ( Context context ) { try { return context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return null ; } public static String getAppName ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . applicationInfo . loadLabel ( context . getPackageManager ( ) ) . toString ( ) : \"<STR_LIT>\" ; } public static Drawable getAppIcon ( Context context ) { PackageInfo packageInfo = getPackageInfo ( context ) ; return packageInfo != null ? packageInfo . applicationInfo . loadIcon ( context . getPackageManager ( ) ) : null ; } public static boolean isAppOnForeground ( Context context ) { ActivityManager activityManager = ( ActivityManager ) context . getSystemService ( Context . ACTIVITY_SERVICE ) ; String packageName = context . getPackageName ( ) ; List < ActivityManager . RunningAppProcessInfo > appProcesses = activityManager . getRunningAppProcesses ( ) ; if ( appProcesses == null ) { return false ; } for ( ActivityManager . RunningAppProcessInfo appProcess : appProcesses ) { if ( appProcess . processName . equals ( packageName ) && appProcess . importance == ActivityManager . RunningAppProcessInfo . IMPORTANCE_FOREGROUND ) { return true ; } } return false ; } public static boolean isMainThread ( ) { return Looper . getMainLooper ( ) == Looper . myLooper ( ) ; } public static boolean startActivity ( final Intent intent ) { if ( intent == null ) { UpdateLog . e ( \"<STR_LIT>\" ) ; return false ; } if ( AppSpace . getContext ( ) . getPackageManager ( ) . resolveActivity ( intent , PackageManager . MATCH_DEFAULT_ONLY ) != null ) { try { intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; AppSpace . getContext ( ) . startActivity ( intent ) ; return true ; } catch ( ActivityNotFoundException e ) { e . printStackTrace ( ) ; UpdateLog . e ( e ) ; } } else { UpdateLog . e ( \"<STR_LIT>\" + ( intent . getComponent ( ) != null ? intent . getComponent ( ) . getClassName ( ) : intent . getAction ( ) ) + \"<STR_LIT>\" ) ; } return false ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . graphics . Rect ; import android . text . Layout ; import android . text . Spanned ; import android . text . TextPaint ; import android . text . style . ClickableSpan ; import android . text . style . LeadingMarginSpan ; import android . util . Log ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import org . commonmark . node . FencedCodeBlock ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import io . noties . markwon . AbstractMarkwonPlugin ; import io . noties . markwon . Markwon ; import io . noties . markwon . MarkwonConfiguration ; import io . noties . markwon . MarkwonSpansFactory ; import io . noties . markwon . ext . latex . JLatexMathPlugin ; import io . noties . markwon . ext . tables . TableAwareMovementMethod ; import io . noties . markwon . ext . tables . TablePlugin ; import io . noties . markwon . image . ImageSize ; import io . noties . markwon . image . ImageSizeResolverDef ; import io . noties . markwon . image . ImagesPlugin ; import io . noties . markwon . inlineparser . MarkwonInlineParserPlugin ; import io . noties . markwon . linkify . LinkifyPlugin ; import io . noties . markwon . movement . MovementMethodPlugin ; import io . noties . markwon . syntax . Prism4jThemeDefault ; import io . noties . markwon . syntax . SyntaxHighlightPlugin ; import io . noties . markwon . utils . LeadingMarginUtils ; import io . noties . prism4j . Prism4j ; public class MarkdownRenderer { private final Context context ; private final Markwon markwon ; class ClickToCopySpan extends ClickableSpan { @ Override public void onClick ( @ NonNull View widget ) { if ( widget instanceof TextView ) { Spanned spanned = ( Spanned ) ( ( TextView ) widget ) . getText ( ) ; int start = spanned . getSpanStart ( this ) ; int end = spanned . getSpanEnd ( this ) ; String text = spanned . subSequence ( start , end ) . toString ( ) . trim ( ) ; GlobalUtils . copyToClipboard ( context , text ) ; GlobalUtils . showToast ( context , context . getString ( R . string . toast_code_clipboard ) , false ) ; } } @ Override public void updateDrawState ( @ NonNull TextPaint ds ) { } } class CopyIconSpan implements LeadingMarginSpan { @ Override public int getLeadingMargin ( boolean first ) { return <NUM_LIT> ; } @ Override public void drawLeadingMargin ( @ NonNull Canvas canvas , @ NonNull Paint p , int x , int dir , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , boolean first , @ NonNull Layout layout ) { if ( ! LeadingMarginUtils . selfStart ( start , text , this ) ) return ; int save = canvas . save ( ) ; try { Paint paint = new Paint ( ) ; String textToDraw = context . getString ( R . string . text_copy_code_notice ) ; paint . setTextSize ( GlobalUtils . dpToPx ( context , <NUM_LIT> ) ) ; paint . setColor ( <NUM_LIT> ) ;", "output": "Rect bounds = new Rect ( ) ; paint . getTextBounds ( textToDraw , <NUM_LIT> , textToDraw . length ( ) , bounds ) ; int y = top + bounds . height ( ) + GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; int x1 = layout . getWidth ( ) - bounds . width ( ) - GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; if ( layout . getWidth ( ) > bounds . width ( ) + GlobalUtils . dpToPx ( context , <NUM_LIT> ) ) canvas . drawText ( textToDraw , x1 , y , paint ) ; } finally { canvas . restoreToCount ( save ) ; } } } public MarkdownRenderer ( Context context ) { this . context = context ; markwon = Markwon . builder ( context ) . usePlugin ( SyntaxHighlightPlugin . create ( new Prism4j ( new GrammarLocatorDef ( ) ) , Prism4jThemeDefault . create ( <NUM_LIT> ) ) ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ Override public void configureSpansFactory ( @ NonNull MarkwonSpansFactory . Builder builder ) { builder . appendFactory ( FencedCodeBlock . class , ( configuration , props ) -> new ClickToCopySpan ( ) ) ; } } ) . usePlugin ( JLatexMathPlugin . create ( <NUM_LIT> , builder -> builder . inlinesEnabled ( true ) ) ) . usePlugin ( ImagesPlugin . create ( ) ) . usePlugin ( MarkwonInlineParserPlugin . create ( ) ) . usePlugin ( LinkifyPlugin . create ( ) ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ NonNull @ Override public String processMarkdown ( @ NonNull String markdown ) { List < String > sepList = new ArrayList < > ( Arrays . asList ( markdown . split ( \"<STR_LIT>\" , - <NUM_LIT> ) ) ) ; for ( int i = <NUM_LIT> ; i < sepList . size ( ) ; i += <NUM_LIT> ) { String regexDollar = \"<STR_LIT>\" ; String regexBrackets = \"<STR_LIT>\" ; String regexParentheses = \"<STR_LIT>\" ; String latexReplacement = \"<STR_LIT>\" ; String regexImage = \"<STR_LIT>\" ; String imageReplacement = \"<STR_LIT>\" ; sepList . set ( i , sepList . get ( i ) . replaceAll ( regexDollar , latexReplacement ) . replaceAll ( regexBrackets , latexReplacement ) . replaceAll ( regexParentheses , latexReplacement ) . replaceAll ( regexImage , imageReplacement ) ) ; } return String . join ( \"<STR_LIT>\" , sepList ) ; } } ) . usePlugin ( new AbstractMarkwonPlugin ( ) { @ Override public void configureConfiguration ( @ NonNull MarkwonConfiguration . Builder builder ) { builder . imageSizeResolver ( new ImageSizeResolverDef ( ) { @ NonNull @ Override protected Rect resolveImageSize ( @ Nullable ImageSize imageSize , @ NonNull Rect imageBounds , int canvasWidth , float textSize ) { int maxSize = GlobalUtils . dpToPx ( context , <NUM_LIT> ) ; if ( imageBounds . width ( ) > maxSize || imageBounds . height ( ) > maxSize ) { float ratio = Math . min ( ( float ) maxSize / imageBounds . width ( ) , ( float ) maxSize / imageBounds . height ( ) ) ; imageBounds . right = imageBounds . left + ( int ) ( imageBounds . width ( ) * ratio ) ; imageBounds . bottom = imageBounds . top + ( int ) ( imageBounds . height ( ) * ratio ) ; } return imageBounds ; } } ) ; } } ) . build ( ) ; } public void render ( TextView textView , String markdown ) { if ( textView != null && markdown != null ) { try { markwon . setMarkdown ( textView , markdown ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } }"}, {"input": "package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; public class TaskManger { private static volatile Handler mainThreadHandler ; private static Handler getUiThreadHandler ( ) { if ( mainThreadHandler == null ) { synchronized ( TaskManger . class ) { if ( mainThreadHandler == null ) { mainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; } } } return mainThreadHandler ; } public static void postOnUiThread ( Runnable runnable ) {", "output": "getUiThreadHandler ( ) . post ( runnable ) ; } private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; public static void start ( Runnable runnable ) { executorService . execute ( runnable ) ; } public static void execute ( BackstageTask < ? > backstageTask ) { start ( backstageTask ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . content . Context ; import android . database . Cursor ; import android . graphics . Color ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . HKDF ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Locale ; import java . util . Objects ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import javax . crypto . Cipher ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okio . BufferedSink ; import okio . Okio ; public class MediaPreview extends Feature { private static final String HTML_LOADING = \"<STR_LIT>\" ; private static final String HTML_VIDEO = \"<STR_LIT>\" ; private static final String HTML_IMAGE = \"<STR_LIT>\" ; private File filePath ; private AlertDialog dialog ; static HashMap < String , byte [ ] > MEDIA_KEYS = new HashMap < > ( ) ; static { MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; MEDIA_KEYS . put ( \"<STR_LIT>\" , \"<STR_LIT>\" . getBytes ( ) ) ; } public MediaPreview ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , true ) ) return ; var getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; var videoViewContainerClass = Unobfuscator . loadVideoViewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( videoViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; var surface = ( ViewGroup ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var controlFrame = surface . getChildAt ( <NUM_LIT> ) ; surface . removeViewAt ( <NUM_LIT> ) ; var linearLayout = new LinearLayout ( context ) ; surface . addView ( linearLayout ) ; linearLayout . addView ( controlFrame ) ; var prevBtn = new ImageView ( context ) ; var layoutParams = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ;", "output": "layoutParams . gravity = Gravity . CENTER ; prevBtn . setLayoutParams ( layoutParams ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , \"<STR_LIT>\" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( \"<STR_LIT>\" ) ) ; } ) ; } } ) ; var imageViewContainerClass = Unobfuscator . loadImageVewContainerClass ( classLoader ) ; XposedBridge . hookAllConstructors ( imageViewContainerClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ViewGroup mediaContainer = view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; ViewGroup controlFrame = view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; LinearLayout linearLayout = new LinearLayout ( context ) ; linearLayout . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . WRAP_CONTENT , FrameLayout . LayoutParams . WRAP_CONTENT , Gravity . CENTER ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setBackground ( DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ) ; mediaContainer . removeView ( controlFrame ) ; linearLayout . addView ( controlFrame ) ; mediaContainer . addView ( linearLayout ) ; var prevBtn = new ImageView ( context ) ; var layoutParams2 = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutParams2 . gravity = Gravity . CENTER ; layoutParams2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; prevBtn . setLayoutParams ( layoutParams2 ) ; var drawable = context . getDrawable ( ResId . drawable . preview_eye ) ; drawable . setTint ( Color . WHITE ) ; prevBtn . setImageDrawable ( drawable ) ; prevBtn . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; prevBtn . setBackground ( DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ) ; prevBtn . setScaleType ( ImageView . ScaleType . FIT_CENTER ) ; linearLayout . addView ( prevBtn ) ; prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; controlFrame . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( ( ) -> { if ( prevBtn . getVisibility ( ) != controlFrame . getVisibility ( ) ) prevBtn . setVisibility ( controlFrame . getVisibility ( ) ) ; } ) ; prevBtn . setOnClickListener ( ( v ) -> { var objmessage = XposedHelpers . callMethod ( param . thisObject , \"<STR_LIT>\" ) ; var id = ( long ) ReflectionUtils . getField ( getFieldIdMessage , objmessage ) ; var userJid = WppCore . getCurrentRawJID ( ) ; startPlayer ( id , context , userJid != null && userJid . contains ( \"<STR_LIT>\" ) ) ; } ) ; } } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void startPlayer ( long id , Context context , boolean isNewsletter ) { var executor = Executors . newSingleThreadExecutor ( ) ; try { Cursor cursor0 = MessageStore . getInstance ( ) . getDatabase ( ) . rawQuery ( String . format ( Locale . ENGLISH , \"<STR_LIT>\" , id ) , null ) ; if ( cursor0 != null && cursor0 . getCount ( ) > <NUM_LIT> ) { cursor0 . moveToFirst ( ) ; AtomicReference < String > url = new AtomicReference < > ( cursor0 . getString ( <NUM_LIT> ) ) ; String mine_type = cursor0 . getString ( <NUM_LIT> ) ; String media_key = cursor0 . getString ( <NUM_LIT> ) ; String direct_path = cursor0 . getString ( <NUM_LIT> ) ; cursor0 . close ( ) ; if ( isNewsletter ) { url . set ( \"<STR_LIT>\" + direct_path ) ; } var alertDialog = new AlertDialog . Builder ( context ) ; FrameLayout frameLayout = new FrameLayout ( context ) ; var webView = new WebView ( context ) ; webView . getSettings ( ) . setAllowFileAccess ( true ) ; webView . getSettings ( ) . setSupportZoom ( true ) ; webView . getSettings ( ) . setBuiltInZoomControls ( true ) ; webView . getSettings ( ) . setDisplayZoomControls ( false ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; webView . loadDataWithBaseURL ( null , HTML_LOADING . replace ( \"<STR_LIT>\" , context . getString ( ResId . string . loading ) ) , \"<STR_LIT>\" , \"<STR_LIT>\" , null ) ; frameLayout . addView ( webView ) ; alertDialog . setView ( frameLayout ) ; alertDialog . setOnDismissListener ( dialog1 -> { if ( filePath != null && filePath . exists ( ) ) { filePath . delete ( ) ; } if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } ) ; dialog = alertDialog . create ( ) ; dialog . show ( ) ; executor . execute ( ( ) -> decodeMedia ( url . get ( ) , media_key , mine_type , executor , webView , isNewsletter ) ) ; } } catch ( Exception e ) { logDebug ( e ) ; Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) dialog . dismiss ( ) ; if ( ! executor . isShutdown ( ) ) executor . shutdownNow ( ) ; } } private void decodeMedia ( String url , String mediaKey , String mimeType , ExecutorService executor , WebView webView , boolean isNewsletter ) { try { String fileExtension = mimeType . startsWith ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; filePath = new File ( Utils . getApplication ( ) . getCacheDir ( ) , \"<STR_LIT>\" + fileExtension ) ; byte [ ] encryptedData = Objects . requireNonNull ( new OkHttpClient . Builder ( ) . addInterceptor ( chain -> chain . proceed ( chain . request ( ) . newBuilder ( ) . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . build ( ) ) ) . build ( ) . newCall ( new Request . Builder ( ) . url ( url ) . build ( ) ) . execute ( ) . body ( ) ) . source ( ) . readByteArray ( ) ; if ( filePath . exists ( ) ) { filePath . delete ( ) ; } byte [ ] decryptedData = isNewsletter ? encryptedData : decryptMedia ( encryptedData , mediaKey , mimeType ) ; assert decryptedData != null ; try ( BufferedSink bufferedSink = Okio . buffer ( Okio . sink ( filePath ) ) ) { bufferedSink . write ( decryptedData ) ; } webView . post ( ( ) -> { String fileUrl = \"<STR_LIT>\" + filePath . getAbsolutePath ( ) ; if ( mimeType . contains ( \"<STR_LIT>\" ) ) { webView . loadDataWithBaseURL ( null , HTML_IMAGE . replace ( \"<STR_LIT>\" , fileUrl ) , \"<STR_LIT>\" , \"<STR_LIT>\" , null ) ; } else { webView . loadDataWithBaseURL ( null , HTML_VIDEO . replace ( \"<STR_LIT>\" , fileUrl ) , \"<STR_LIT>\" , \"<STR_LIT>\" , null ) ; } } ) ; } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; if ( dialog != null && dialog . isShowing ( ) ) { dialog . dismiss ( ) ; } } finally { if ( ! executor . isShutdown ( ) ) { executor . shutdownNow ( ) ; } } } private byte [ ] decryptMedia ( byte [ ] encryptedData , String mediaKey , String mimeType ) throws Exception { if ( mediaKey . length ( ) % <NUM_LIT> != <NUM_LIT> || mediaKey . length ( ) != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } byte [ ] keyBytes = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i += <NUM_LIT> ) { keyBytes [ i / <NUM_LIT> ] = ( byte ) ( ( Character . digit ( mediaKey . charAt ( i ) , <NUM_LIT> ) << <NUM_LIT> ) + Character . digit ( mediaKey . charAt ( i + <NUM_LIT> ) , <NUM_LIT> ) ) ; } byte [ ] typeKey = MEDIA_KEYS . getOrDefault ( mimeType , MEDIA_KEYS . get ( \"<STR_LIT>\" ) ) ; byte [ ] derivedKey = HKDF . createFor ( <NUM_LIT> ) . deriveSecrets ( keyBytes , typeKey , <NUM_LIT> ) ; byte [ ] iv = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; byte [ ] aesKey = Arrays . copyOfRange ( derivedKey , <NUM_LIT> , <NUM_LIT> ) ; Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( aesKey , \"<STR_LIT>\" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( Arrays . copyOfRange ( encryptedData , <NUM_LIT> , encryptedData . length - <NUM_LIT> ) ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package de . robv . android . xposed . services ; import android . os . IBinder ; import android . os . Parcel ; import android . os . RemoteException ; import android . os . ServiceManager ; import java . io . IOException ; public final class BinderService extends BaseService { public static final int TARGET_APP = <NUM_LIT> ; public static final int TARGET_SYSTEM = <NUM_LIT> ; public static BinderService getService ( int target ) { if ( target < <NUM_LIT> || target > sServices . length ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + target ) ; } synchronized ( sServices ) { if ( sServices [ target ] == null ) { sServices [ target ] = new BinderService ( target ) ; } return sServices [ target ] ; } } @ Override public boolean checkFileAccess ( String filename , int mode ) { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; data . writeInt ( mode ) ; try { mRemote . transact ( ACCESS_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; return false ; } reply . readException ( ) ; int result = reply . readInt ( ) ; reply . recycle ( ) ; data . recycle ( ) ; return result == <NUM_LIT> ; } @ Override public FileResult statFile ( String filename ) throws IOException { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; try { mRemote . transact ( STAT_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; throw new IOException ( e ) ; } reply . readException ( ) ; int errno = reply . readInt ( ) ; if ( errno != <NUM_LIT> ) throwCommonIOException ( errno , null , filename , \"<STR_LIT>\" ) ; long size = reply . readLong ( ) ; long time = reply . readLong ( ) ; reply . recycle ( ) ; data . recycle ( ) ; return new FileResult ( size , time ) ; } @ Override public byte [ ] readFile ( String filename ) throws IOException { return readFile ( filename , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) . content ; } @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { return readFile ( filename , <NUM_LIT> , <NUM_LIT> , previousSize , previousTime ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { ensureAbsolutePath ( filename ) ; Parcel data = Parcel . obtain ( ) ; Parcel reply = Parcel . obtain ( ) ; data . writeInterfaceToken ( INTERFACE_TOKEN ) ; data . writeString ( filename ) ; data . writeInt ( offset ) ; data . writeInt ( length ) ; data . writeLong ( previousSize ) ; data . writeLong ( previousTime ) ; try { mRemote . transact ( READ_FILE_TRANSACTION , data , reply , <NUM_LIT> ) ; } catch ( RemoteException e ) { data . recycle ( ) ; reply . recycle ( ) ; throw new IOException ( e ) ; } reply . readException ( ) ; int errno = reply . readInt ( ) ; String errorMsg = reply . readString ( ) ; long size = reply . readLong ( ) ; long time = reply . readLong ( ) ; byte [ ] content = reply . createByteArray ( ) ; reply . recycle ( ) ; data . recycle ( ) ; switch ( errno ) { case <NUM_LIT> : return new FileResult ( content , size , time ) ; case <NUM_LIT> : if ( errorMsg != null ) { IllegalArgumentException iae = new IllegalArgumentException ( errorMsg ) ; if ( offset == <NUM_LIT> && length == <NUM_LIT> ) throw new IOException ( iae ) ; else throw iae ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + offset + \"<STR_LIT>\" + length + \"<STR_LIT>\" + filename + \"<STR_LIT>\" + size ) ; } default : throwCommonIOException ( errno , errorMsg , filename , \"<STR_LIT>\" ) ;", "output": "throw new IllegalStateException ( ) ; } } private static final String INTERFACE_TOKEN = \"<STR_LIT>\" ; private static final int ACCESS_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final int STAT_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final int READ_FILE_TRANSACTION = IBinder . FIRST_CALL_TRANSACTION + <NUM_LIT> ; private static final String [ ] SERVICE_NAMES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final BinderService [ ] sServices = new BinderService [ <NUM_LIT> ] ; private final IBinder mRemote ; private BinderService ( int target ) { IBinder binder = ServiceManager . getService ( SERVICE_NAMES [ target ] ) ; if ( binder == null ) throw new IllegalStateException ( \"<STR_LIT>\" + SERVICE_NAMES [ target ] + \"<STR_LIT>\" ) ; this . mRemote = binder ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; import androidx . annotation . NonNull ; public interface NonEmptyResultCallback < T extends Result > extends ResultCallback { void success ( @ NonNull T result ) ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Context ; import android . net . Uri ; import androidx . activity . result . ActivityResultCallback ; import java . io . IOException ; import java . io . OutputStream ; import icu . freedomIntrovert . async . TaskManger ; public abstract class ActivityResultCallbackForSaveDoc < T extends ActivityResult > implements ActivityResultCallback < T > { public ActivityResultCallbackForSaveDoc ( Context context ) { this . context = context ; }", "output": "Context context ; @ Override public void onActivityResult ( T result ) { if ( result . intent == null ) { onVoidResult ( ) ; return ; } Uri data = result . intent . getData ( ) ; if ( data == null ) { onVoidResult ( ) ; return ; } onHasResult ( ) ; TaskManger . start ( ( ) -> { try { OutputStream outputStream = context . getContentResolver ( ) . openOutputStream ( data ) ; if ( outputStream != null ) { onOpenOutputStream ( outputStream , result ) ; } else { onNullOutputStream ( ) ; } } catch ( IOException e ) { onIOException ( e ) ; } } ) ; } protected void onHasResult ( ) { } ; protected abstract void onOpenOutputStream ( OutputStream outputStream , T result ) throws IOException ; protected abstract void onNullOutputStream ( ) ; protected void onVoidResult ( ) { } ; protected abstract void onIOException ( Exception e ) ; }"}, {"input": "package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class GeneralFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_general , rootKey ) ;", "output": "} }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import android . content . DialogInterface ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public class RemoteBookmarkAdapter extends BookmarkAdapter { private final IIServiceFileSelectAdapter adapter ; private final List < BookMark > bookMarks ; private final ConfigDB db ; public RemoteBookmarkAdapter ( Context context , DialogInterface dialog , IIServiceFileSelectAdapter adapter , ConfigDB db ) { super ( context , dialog ) ; this . db = db ;", "output": "this . bookMarks = db . getAllRemoteBookmark ( ) ; this . adapter = adapter ; } @ Override protected boolean onDelete ( BookMark bookMark ) { boolean success = db . removeRemoteBookmark ( bookMark . id ) > <NUM_LIT> ; if ( success ) { bookMarks . remove ( bookMark ) ; } return success ; } @ Override protected BookMark getItem ( int position ) { return bookMarks . get ( position ) ; } @ Override protected void onItemClick ( BookMark bookMark ) { adapter . cd ( bookMark . path ) ; } @ Override public int getItemCount ( ) { return bookMarks . size ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core . db ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XposedBridge ; public class MessageStore { private static MessageStore mInstance ; private SQLiteDatabase sqLiteDatabase ; private MessageStore ( ) { var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var dbFile = new File ( dataDir , \"<STR_LIT>\" ) ; if ( ! dbFile . exists ( ) ) return ; sqLiteDatabase = SQLiteDatabase . openDatabase ( dbFile . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READWRITE ) ; } public static MessageStore getInstance ( ) { synchronized ( MessageStore . class ) { if ( mInstance == null || mInstance . sqLiteDatabase == null || ! mInstance . sqLiteDatabase . isOpen ( ) ) { mInstance = new MessageStore ( ) ; } } return mInstance ; } public String getMessageById ( long id ) { if ( sqLiteDatabase == null ) return \"<STR_LIT>\" ; String message = \"<STR_LIT>\" ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { \"<STR_LIT>\" } ; String selection = \"<STR_LIT>\" ; String [ ] selectionArgs = new String [ ] { String . valueOf ( id ) } ; cursor = sqLiteDatabase . query ( \"<STR_LIT>\" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return message ; } public String getOriginalMessageKey ( long id ) { if ( sqLiteDatabase == null ) return \"<STR_LIT>\" ; String message = \"<STR_LIT>\" ; try ( Cursor cursor = sqLiteDatabase . rawQuery ( \"<STR_LIT>\" + id + \"<STR_LIT>\" , null ) ) { if ( cursor . moveToFirst ( ) ) { message = cursor . getString ( <NUM_LIT> ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } return message ; } public List < String > getAudioListByMessageList ( List < String > messageList ) { if ( sqLiteDatabase == null ) return new ArrayList < > ( ) ; List < String > list = new ArrayList < > ( ) ; Cursor cursor = null ; try { String sql = \"<STR_LIT>\" ; sql += String . join ( \"<STR_LIT>\" , messageList . stream ( ) . map ( m -> \"<STR_LIT>\" + m + \"<STR_LIT>\" ) . toArray ( String [ ] :: new ) ) ; sql += \"<STR_LIT>\" ; cursor = sqLiteDatabase . rawQuery ( sql , null ) ; if ( cursor . moveToFirst ( ) ) { do { int type = cursor . getInt ( <NUM_LIT> ) ; if ( type == <NUM_LIT> ) { list . add ( cursor . getString ( <NUM_LIT> ) ) ; } } while ( cursor . moveToNext ( ) ) ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return list ; } public synchronized void executeSQL ( String sql ) { try { if ( sqLiteDatabase == null ) return ; sqLiteDatabase . execSQL ( sql ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } public void storeMessageRead ( String messageId ) { if ( sqLiteDatabase == null ) return ; XposedBridge . log ( \"<STR_LIT>\" + messageId ) ; sqLiteDatabase . execSQL ( \"<STR_LIT>\" + messageId + \"<STR_LIT>\" ) ; } public boolean isReadMessageStatus ( String messageId ) { if ( sqLiteDatabase == null ) return false ; boolean result = false ; Cursor cursor = null ; try { String [ ] columns = new String [ ] { \"<STR_LIT>\" } ; String selection = \"<STR_LIT>\" ; String [ ] selectionArgs = new String [ ] { messageId } ; cursor = sqLiteDatabase . query ( \"<STR_LIT>\" , columns , selection , selectionArgs , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { result = cursor . getInt ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) == <NUM_LIT> ; } } catch ( Exception e ) { XposedBridge . log ( e ) ; } finally { if ( cursor != null ) cursor . close ( ) ; } return result ;", "output": "} public SQLiteDatabase getDatabase ( ) { return sqLiteDatabase ; } }"}, {"input": "package com . norman . webviewup . lib . util ; public class VersionUtils { public static int compareVersion ( String version1 , String version2 ) { if ( version1 == null || version2 == null ) { return <NUM_LIT> ; } String [ ] versionArray1 = version1 . split ( \"<STR_LIT>\" ) ; String [ ] versionArray2 = version2 . split ( \"<STR_LIT>\" ) ; int idx = <NUM_LIT> ; int minLength = Math . min ( versionArray1 . length , versionArray2 . length ) ; int diff = <NUM_LIT> ; while ( idx < minLength && ( diff = versionArray1 [ idx ] . length ( ) - versionArray2 [ idx ] . length ( ) ) == <NUM_LIT> && ( diff = versionArray1 [ idx ] . compareTo ( versionArray2 [ idx ] ) ) == <NUM_LIT> ) { ++ idx ;", "output": "} diff = ( diff != <NUM_LIT> ) ? diff : versionArray1 . length - versionArray2 . length ; return diff ; } }"}, {"input": "package com . norman . webviewup . lib ; import android . content . Context ; import androidx . test . platform . app . InstrumentationRegistry ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ;", "output": "} }"}, {"input": "package com . wmods . wppenhacer . xposed . core . components ; import android . content . ContextWrapper ; import android . content . SharedPreferences ; import androidx . annotation . Nullable ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; public class SharedPreferencesWrapper implements SharedPreferences { private final static HashSet < SPrefHook > prefHook = new HashSet < > ( ) ; private final SharedPreferences mPreferences ; public SharedPreferencesWrapper ( SharedPreferences sharedPreferences ) { mPreferences = sharedPreferences ; } @ Override public Map < String , ? > getAll ( ) { return mPreferences . getAll ( ) ; } @ Nullable @ Override public String getString ( String s , @ Nullable String s1 ) { var value = mPreferences . getString ( s , s1 ) ; return ( String ) hookValue ( s , value ) ; } @ Nullable @ Override public Set < String > getStringSet ( String s , @ Nullable Set < String > set ) { var value = mPreferences . getStringSet ( s , set ) ; return ( Set < String > ) hookValue ( s , value ) ; } @ Override public int getInt ( String s , int i ) { var value = mPreferences . getInt ( s , i ) ; return ( int ) hookValue ( s , value ) ; } @ Override public long getLong ( String s , long l ) { var value = mPreferences . getLong ( s , l ) ; return ( long ) hookValue ( s , value ) ; } @ Override public float getFloat ( String s , float v ) { var value = mPreferences . getFloat ( s , v ) ; return ( float ) hookValue ( s , value ) ; } @ Override public boolean getBoolean ( String s , boolean b ) { var value = mPreferences . getBoolean ( s , b ) ; return ( boolean ) hookValue ( s , value ) ; } @ Override public boolean contains ( String s ) { return mPreferences . contains ( s ) ; } @ Override public Editor edit ( ) { return mPreferences . edit ( ) ; } @ Override public void registerOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . registerOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; }", "output": "@ Override public void unregisterOnSharedPreferenceChangeListener ( OnSharedPreferenceChangeListener onSharedPreferenceChangeListener ) { mPreferences . unregisterOnSharedPreferenceChangeListener ( onSharedPreferenceChangeListener ) ; } public static void hookInit ( ClassLoader classLoader ) { XposedHelpers . findAndHookMethod ( ContextWrapper . class . getName ( ) , classLoader , \"<STR_LIT>\" , String . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pref = ( SharedPreferences ) param . getResult ( ) ; if ( pref instanceof SharedPreferencesWrapper ) return ; param . setResult ( new SharedPreferencesWrapper ( pref ) ) ; } } ) ; } public static void addHook ( SPrefHook hook ) { prefHook . add ( hook ) ; } private Object hookValue ( String key , Object value ) { for ( SPrefHook hook : prefHook ) { value = hook . hookValue ( key , value ) ; } return value ; } public interface SPrefHook { @ Nullable Object hookValue ( String key , Object value ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . annotation . JSONField ; import org . jetbrains . annotations . Nullable ; import kotlin . jvm . JvmField ; public abstract class BaseResponse { @ JvmField public int code ; @ JvmField @ Nullable public String message ; @ JvmField public int ttl ; @ JSONField ( deserialize = false , serialize = false ) public boolean isSuccess ( ) { return this . code == <NUM_LIT> ; } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + code + \"<STR_LIT>\" + message + '<STR_LIT>' + \"<STR_LIT>\" + ttl + '<STR_LIT>' ; }", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces ; import com . getcapacitor . JSObject ; public interface Result { JSObject toJSObject ( ) ;", "output": "}"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; public interface ItemTouchHelperAdapter { void onItemDismiss ( int position ) ; void onItemMove ( int fromPosition , int toPosition ) ;", "output": "}"}, {"input": "package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . GradientDrawable ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . View ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . SeekBar ; import android . widget . TextView ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; public class SimpleColorPickerDialog extends AlertDialogWpp { private final OnColorSelectedListener listener ; private int selectedColor = Color . BLACK ; private boolean isUpdating = false ; public SimpleColorPickerDialog ( Context context , OnColorSelectedListener listener ) { super ( context ) ; this . listener = listener ; } @ Override public Dialog create ( ) { setTitle ( getContext ( ) . getString ( ResId . string . select_a_color ) ) ; LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; final SeekBar redSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar greenSeekBar = new SeekBar ( getContext ( ) ) ; final SeekBar blueSeekBar = new SeekBar ( getContext ( ) ) ; redSeekBar . setMax ( <NUM_LIT> ) ; greenSeekBar . setMax ( <NUM_LIT> ) ; blueSeekBar . setMax ( <NUM_LIT> ) ; layout . addView ( createSeekBarLayout ( \"<STR_LIT>\" , redSeekBar ) ) ; layout . addView ( createSeekBarLayout ( \"<STR_LIT>\" , greenSeekBar ) ) ; layout . addView ( createSeekBarLayout ( \"<STR_LIT>\" , blueSeekBar ) ) ; final View colorPreview = new View ( getContext ( ) ) ; colorPreview . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( selectedColor ) ; borderDrawable . setStroke ( <NUM_LIT> , DesignUtils . getPrimaryTextColor ( ) ) ; colorPreview . setBackground ( borderDrawable ) ; layout . addView ( colorPreview ) ; final EditText hexInput = new EditText ( getContext ( ) ) ; hexInput . setHint ( \"<STR_LIT>\" ) ; layout . addView ( hexInput ) ; redSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; greenSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) {", "output": "isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; blueSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! isUpdating ) { isUpdating = true ; updateColorPreview ( borderDrawable , redSeekBar , greenSeekBar , blueSeekBar , hexInput ) ; isUpdating = false ; } } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { } } ) ; hexInput . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { if ( ! isUpdating && s . length ( ) == <NUM_LIT> && s . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { try { isUpdating = true ; selectedColor = Color . parseColor ( s . toString ( ) ) ; borderDrawable . setColor ( selectedColor ) ; redSeekBar . setProgress ( Color . red ( selectedColor ) ) ; greenSeekBar . setProgress ( Color . green ( selectedColor ) ) ; blueSeekBar . setProgress ( Color . blue ( selectedColor ) ) ; isUpdating = false ; } catch ( IllegalArgumentException e ) { } } } @ Override public void afterTextChanged ( Editable s ) { } } ) ; setPositiveButton ( \"<STR_LIT>\" , ( dialogInterface , i ) -> { if ( listener != null ) { listener . onColorSelected ( selectedColor ) ; } dismiss ( ) ; } ) ; setNegativeButton ( getContext ( ) . getString ( ResId . string . cancel ) , ( dialogInterface , i ) -> { dismiss ( ) ; } ) ; setView ( layout ) ; return super . create ( ) ; } private void updateColorPreview ( GradientDrawable borderDrawable , SeekBar redSeekBar , SeekBar greenSeekBar , SeekBar blueSeekBar , EditText hexInput ) { int red = redSeekBar . getProgress ( ) ; int green = greenSeekBar . getProgress ( ) ; int blue = blueSeekBar . getProgress ( ) ; selectedColor = Color . rgb ( red , green , blue ) ; borderDrawable . setColor ( selectedColor ) ; hexInput . setText ( String . format ( \"<STR_LIT>\" , red , green , blue ) ) ; } private LinearLayout createSeekBarLayout ( String label , SeekBar seekBar ) { LinearLayout layout = new LinearLayout ( getContext ( ) ) ; layout . setOrientation ( LinearLayout . VERTICAL ) ; layout . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; TextView labelView = new TextView ( getContext ( ) ) ; labelView . setText ( label ) ; labelView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; layout . addView ( labelView ) ; layout . addView ( seekBar ) ; return layout ; } public interface OnColorSelectedListener { void onColorSelected ( int color ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import androidx . annotation . Nullable ; import org . xml . sax . Attributes ; public interface WrapperTagHandler {", "output": "boolean handleTag ( boolean opening , String tag , Editable output , @ Nullable Attributes attributes ) ; }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . drawable . Drawable ; import androidx . core . content . ContextCompat ; import androidx . recyclerview . widget . RecyclerView ; import android . util . Log ; import android . view . View ; import org . woheller69 . weather . R ; public class SimpleDividerItemDecoration extends RecyclerView . ItemDecoration { private Drawable mDivider ; public SimpleDividerItemDecoration ( Context context ) { mDivider = ContextCompat . getDrawable ( context , R . drawable . recycle_view_line_divider ) ; } @ Override public void onDrawOver ( Canvas c , RecyclerView parent , RecyclerView . State state ) { int left = parent . getPaddingLeft ( ) ; int right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount - <NUM_LIT> ; i ++ ) { View child = parent . getChildAt ( i ) ; RecyclerView . LayoutParams params = ( RecyclerView . LayoutParams ) child . getLayoutParams ( ) ; int top = child . getBottom ( ) + params . bottomMargin ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + top ) ; int bottom = top + mDivider . getIntrinsicHeight ( ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + top ) ;", "output": "mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( c ) ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import androidx . annotation . Nullable ; import java . util . List ; public class CommentPage { public Page page ; public List < BiliComment > replies ; @ Nullable public List < BiliComment > top_replies ; public static class Page { public int num ; public int size ; public int count ; public int acount ;", "output": "} }"}, {"input": "package org . woheller69 . weather . activities ; import android . content . Intent ; import android . os . Bundle ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . firststart . TutorialActivity ; import org . woheller69 . weather . preferences . AppPreferencesManager ; public class SplashActivity extends AppCompatActivity { private AppPreferencesManager prefManager ; @ Override protected void onCreate ( Bundle savedInstanceState ) {", "output": "super . onCreate ( savedInstanceState ) ; prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; if ( prefManager . isFirstTimeLaunch ( this ) ) { Intent mainIntent = new Intent ( SplashActivity . this , TutorialActivity . class ) ; SplashActivity . this . startActivity ( mainIntent ) ; } else { Intent mainIntent = new Intent ( SplashActivity . this , ForecastCityActivity . class ) ; SplashActivity . this . startActivity ( mainIntent ) ; } SplashActivity . this . finish ( ) ; } }"}, {"input": "package in . hridayan . ashell . utils ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . preference . PreferenceManager ; public class Preferences { public static final String buildGradleUrl = \"<STR_LIT>\" ; private static final String PREF_AMOLED_THEME = \"<STR_LIT>\" , PREF_COUNTER_PREFIX = \"<STR_LIT>\" , PREF_PINNED_PREFIX = \"<STR_LIT>\" , PREF_CLEAR = \"<STR_LIT>\" , PREF_SHARE_AND_RUN = \"<STR_LIT>\" , PREF_DISABLE_SOFTKEY = \"<STR_LIT>\" , PREF_OVERRIDE_BOOKMARKS = \"<STR_LIT>\" , PREF_SMOOTH_SCROLL = \"<STR_LIT>\" , PREF_SAVED_VERSION_CODE = \"<STR_LIT>\" , PREF_SORTING_OPTION = \"<STR_LIT>\" , PREF_SORTING_EXAMPLES = \"<STR_LIT>\" , PREF_CURRENT_FRAGMENT = \"<STR_LIT>\" , PREF_DEFAULT_WORKING_MODE = \"<STR_LIT>\" , PREF_SPECIFIC_CARD_VISIBILITY = \"<STR_LIT>\" , PREF_AUTO_UPDATE_CHECK = \"<STR_LIT>\" ; public static final int SORT_A_TO_Z = <NUM_LIT> , SORT_Z_TO_A = <NUM_LIT> , SORT_MOST_USED = <NUM_LIT> , SORT_OLDEST = <NUM_LIT> , SORT_NEWEST = <NUM_LIT> , SORT_LEAST_USED = <NUM_LIT> , LOCAL_FRAGMENT = <NUM_LIT> , OTG_FRAGMENT = <NUM_LIT> , MODE_LOCAL_ADB = <NUM_LIT> , MODE_OTG = <NUM_LIT> , MODE_REMEMBER_LAST_MODE = <NUM_LIT> , MAX_BOOKMARKS_LIMIT = <NUM_LIT> , UPDATE_AVAILABLE = <NUM_LIT> , UPDATE_NOT_AVAILABLE = <NUM_LIT> , CONNECTION_ERROR = <NUM_LIT> ; private static SharedPreferences getSharedPreferences ( Context context ) { return PreferenceManager . getDefaultSharedPreferences ( context ) ; } public static boolean getAmoledTheme ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_AMOLED_THEME , false ) ; } public static void setAmoledTheme ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_AMOLED_THEME , value ) . apply ( ) ; } public static boolean getClear ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_CLEAR , true ) ; } public static void setClear ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_CLEAR , value ) . apply ( ) ; } public static boolean getShareAndRun ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_SHARE_AND_RUN , false ) ; } public static void setShareAndRun ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_SHARE_AND_RUN , value ) . apply ( ) ; } public static boolean getDisableSoftkey ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_DISABLE_SOFTKEY , false ) ; } public static void setDisableSoftkey ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_DISABLE_SOFTKEY , value ) . apply ( ) ; } public static boolean getOverrideBookmarks ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_OVERRIDE_BOOKMARKS , false ) ; } public static void setOverrideBookmarks ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_OVERRIDE_BOOKMARKS , value ) . apply ( ) ; } public static boolean getSmoothScroll ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_SMOOTH_SCROLL , true ) ; } public static void setSmoothScroll ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_SMOOTH_SCROLL , value ) . apply ( ) ; } public static boolean getAutoUpdateCheck ( Context context ) { return getSharedPreferences ( context ) . getBoolean ( PREF_AUTO_UPDATE_CHECK , true ) ; } public static void setAutoUpdateCheck ( Context context , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( PREF_AUTO_UPDATE_CHECK , value ) . apply ( ) ; } public static int getSavedVersionCode ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_SAVED_VERSION_CODE , <NUM_LIT> ) ; } public static void setSavedVersionCode ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SAVED_VERSION_CODE , value ) . apply ( ) ; } public static int getSortingOption ( Context context ) {", "output": "return getSharedPreferences ( context ) . getInt ( PREF_SORTING_OPTION , SORT_A_TO_Z ) ; } public static void setSortingOption ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SORTING_OPTION , value ) . apply ( ) ; } public static int getSortingExamples ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_SORTING_EXAMPLES , SORT_A_TO_Z ) ; } public static void setSortingExamples ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_SORTING_EXAMPLES , value ) . apply ( ) ; } public static void setWorkingMode ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_DEFAULT_WORKING_MODE , value ) . apply ( ) ; } public static int getWorkingMode ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_DEFAULT_WORKING_MODE , MODE_LOCAL_ADB ) ; } public static int getCurrentFragment ( Context context ) { return getSharedPreferences ( context ) . getInt ( PREF_CURRENT_FRAGMENT , LOCAL_FRAGMENT ) ; } public static void setCurrentFragment ( Context context , int value ) { getSharedPreferences ( context ) . edit ( ) . putInt ( PREF_CURRENT_FRAGMENT , value ) . apply ( ) ; } public static int getUseCounter ( Context context , String title ) { return getSharedPreferences ( context ) . getInt ( getCounterKey ( title ) , <NUM_LIT> ) ; } public static void setUseCounter ( Context context , String title , int counter ) { getSharedPreferences ( context ) . edit ( ) . putInt ( getCounterKey ( title ) , counter ) . apply ( ) ; } public static boolean getPinned ( Context context , String title ) { return getSharedPreferences ( context ) . getBoolean ( getPinnedKey ( title ) , false ) ; } public static void setPinned ( Context context , String title , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( getPinnedKey ( title ) , value ) . apply ( ) ; } public static boolean getSpecificCardVisibility ( Context context , String title ) { return getSharedPreferences ( context ) . getBoolean ( getCardKey ( title ) , true ) ; } public static void setSpecificCardVisibility ( Context context , String title , boolean value ) { getSharedPreferences ( context ) . edit ( ) . putBoolean ( getCardKey ( title ) , value ) . apply ( ) ; } private static String getCounterKey ( String title ) { return PREF_COUNTER_PREFIX + title ; } private static String getPinnedKey ( String title ) { return PREF_PINNED_PREFIX + title ; } private static String getCardKey ( String title ) { return PREF_SPECIFIC_CARD_VISIBILITY + title ; } }"}, {"input": "import android . content . Intent ; class A extends Activity { static void method ( ) { Intent i = getIntent ( ) ; db . query ( \"<STR_LIT>\" + i . getData ( ) ) ;", "output": "} @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; if ( intent . getStringExtra ( \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) { db . query ( \"<STR_LIT>\" + this . getActivity ( ) . getIntent ( ) . getDataString ( ) ) ; myMethod ( ) ; } } } public class MyBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String data = intent . getStringExtra ( \"<STR_LIT>\" ) ; db . query ( \"<STR_LIT>\" + data ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + data ) ; } }"}, {"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . Comparator ; import external . org . apache . commons . lang3 . ArrayUtils ; public class CompareToBuilder implements Builder < Integer > { private int comparison ; public CompareToBuilder ( ) { super ( ) ; comparison = <NUM_LIT> ; } public static int reflectionCompare ( Object lhs , Object rhs ) { return reflectionCompare ( lhs , rhs , false , null ) ; } public static int reflectionCompare ( Object lhs , Object rhs , boolean compareTransients ) { return reflectionCompare ( lhs , rhs , compareTransients , null ) ; } public static int reflectionCompare ( Object lhs , Object rhs , Collection < String > excludeFields ) { return reflectionCompare ( lhs , rhs , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static int reflectionCompare ( Object lhs , Object rhs , String ... excludeFields ) { return reflectionCompare ( lhs , rhs , false , null , excludeFields ) ; } public static int reflectionCompare ( Object lhs , Object rhs , boolean compareTransients , Class < ? > reflectUpToClass , String ... excludeFields ) { if ( lhs == rhs ) { return <NUM_LIT> ; } if ( lhs == null || rhs == null ) { throw new NullPointerException ( ) ; } Class < ? > lhsClazz = lhs . getClass ( ) ; if ( ! lhsClazz . isInstance ( rhs ) ) { throw new ClassCastException ( ) ; } CompareToBuilder compareToBuilder = new CompareToBuilder ( ) ; reflectionAppend ( lhs , rhs , lhsClazz , compareToBuilder , compareTransients , excludeFields ) ; while ( lhsClazz . getSuperclass ( ) != null && lhsClazz != reflectUpToClass ) { lhsClazz = lhsClazz . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , lhsClazz , compareToBuilder , compareTransients , excludeFields ) ; } return compareToBuilder . toComparison ( ) ; } private static void reflectionAppend ( Object lhs , Object rhs , Class < ? > clazz , CompareToBuilder builder , boolean useTransients , String [ ] excludeFields ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = <NUM_LIT> ; i < fields . length && builder . comparison == <NUM_LIT> ; i ++ ) { Field f = fields [ i ] ; if ( ! ArrayUtils . contains ( excludeFields , f . getName ( ) ) && ( f . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( f . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( \"<STR_LIT>\" ) ; } } } } public CompareToBuilder appendSuper ( int superCompareTo ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = superCompareTo ; return this ; } public CompareToBuilder append ( Object lhs , Object rhs ) { return append ( lhs , rhs , null ) ; } public CompareToBuilder append ( Object lhs , Object rhs , Comparator < ? > comparator ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . getClass ( ) . isArray ( ) ) { if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs , comparator ) ; } } else { if ( comparator == null ) { @ SuppressWarnings ( \"<STR_LIT>\" ) final Comparable < Object > comparable = ( Comparable < Object > ) lhs ; comparison = comparable . compareTo ( rhs ) ; } else { @ SuppressWarnings ( \"<STR_LIT>\" ) final Comparator < Object > comparator2 = ( Comparator < Object > ) comparator ; comparison = comparator2 . compare ( lhs , rhs ) ; } } return this ; } public CompareToBuilder append ( long lhs , long rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( int lhs , int rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( short lhs , short rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( char lhs , char rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( byte lhs , byte rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = ( ( lhs < rhs ) ? - <NUM_LIT> : ( ( lhs > rhs ) ? <NUM_LIT> : <NUM_LIT> ) ) ; return this ; } public CompareToBuilder append ( double lhs , double rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = Double . compare ( lhs , rhs ) ; return this ; } public CompareToBuilder append ( float lhs , float rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } comparison = Float . compare ( lhs , rhs ) ; return this ; } public CompareToBuilder append ( boolean lhs , boolean rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == false ) { comparison = - <NUM_LIT> ; } else { comparison = + <NUM_LIT> ; } return this ; } public CompareToBuilder append ( Object [ ] lhs , Object [ ] rhs ) { return append ( lhs , rhs , null ) ; } public CompareToBuilder append ( Object [ ] lhs , Object [ ] rhs , Comparator < ? > comparator ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] , comparator ) ; } return this ; } public CompareToBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ;", "output": "return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( char [ ] lhs , char [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( byte [ ] lhs , byte [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( double [ ] lhs , double [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( float [ ] lhs , float [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public CompareToBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( comparison != <NUM_LIT> ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null ) { comparison = - <NUM_LIT> ; return this ; } if ( rhs == null ) { comparison = + <NUM_LIT> ; return this ; } if ( lhs . length != rhs . length ) { comparison = ( lhs . length < rhs . length ) ? - <NUM_LIT> : + <NUM_LIT> ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && comparison == <NUM_LIT> ; i ++ ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public int toComparison ( ) { return comparison ; } public Integer build ( ) { return Integer . valueOf ( toComparison ( ) ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . appupdate ; import static android . app . Activity . RESULT_CANCELED ; import static android . app . Activity . RESULT_OK ; import static com . google . android . play . core . install . model . ActivityResult . RESULT_IN_APP_UPDATE_FAILED ; import android . content . ActivityNotFoundException ; import android . content . Intent ; import android . content . IntentSender ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . net . Uri ; import android . os . Build ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . android . gms . common . ConnectionResult ; import com . google . android . gms . common . GoogleApiAvailability ; import com . google . android . gms . tasks . Task ; import com . google . android . play . core . appupdate . AppUpdateInfo ; import com . google . android . play . core . appupdate . AppUpdateManager ; import com . google . android . play . core . appupdate . AppUpdateManagerFactory ; import com . google . android . play . core . install . InstallStateUpdatedListener ; import com . google . android . play . core . install . model . AppUpdateType ; import com . google . android . play . core . install . model . InstallStatus ; import com . google . android . play . core . install . model . UpdateAvailability ; @ CapacitorPlugin ( name = \"<STR_LIT>\" , requestCodes = { AppUpdatePlugin . REQUEST_IMMEDIATE_UPDATE , AppUpdatePlugin . REQUEST_FLEXIBLE_UPDATE } ) public class AppUpdatePlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_GET_APP_INFO_FAILED = \"<STR_LIT>\" ; public static final int UPDATE_OK = <NUM_LIT> ; public static final int UPDATE_CANCELED = <NUM_LIT> ; public static final int UPDATE_FAILED = <NUM_LIT> ; public static final int UPDATE_NOT_AVAILABLE = <NUM_LIT> ; public static final int UPDATE_NOT_ALLOWED = <NUM_LIT> ; public static final int UPDATE_INFO_MISSING = <NUM_LIT> ; public static final int REQUEST_IMMEDIATE_UPDATE = <NUM_LIT> ; public static final int REQUEST_FLEXIBLE_UPDATE = <NUM_LIT> ; public static final String ERROR_GOOGLE_PLAY_SERVICES_UNAVAILABLE = \"<STR_LIT>\" ; private AppUpdateManager appUpdateManager ; private AppUpdateInfo appUpdateInfo ; private InstallStateUpdatedListener listener ; private PluginCall savedPluginCall ; public void load ( ) { this . appUpdateManager = AppUpdateManagerFactory . create ( this . getContext ( ) ) ; } @ PluginMethod public void getAppUpdateInfo ( PluginCall call ) { try { boolean isGooglePlayServicesAvailable = this . isGooglePlayServicesAvailable ( ) ; if ( ! isGooglePlayServicesAvailable ) { call . reject ( ERROR_GOOGLE_PLAY_SERVICES_UNAVAILABLE ) ; return ; } Task < AppUpdateInfo > appUpdateInfoTask = this . appUpdateManager . getAppUpdateInfo ( ) ; appUpdateInfoTask . addOnSuccessListener ( appUpdateInfo -> { this . appUpdateInfo = appUpdateInfo ; PackageInfo pInfo ; try { pInfo = this . getPackageInfo ( ) ; } catch ( PackageManager . NameNotFoundException e ) { call . reject ( ERROR_GET_APP_INFO_FAILED ) ; return ; } JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , pInfo . versionName ) ; ret . put ( \"<STR_LIT>\" , String . valueOf ( pInfo . versionCode ) ) ; ret . put ( \"<STR_LIT>\" , String . valueOf ( appUpdateInfo . availableVersionCode ( ) ) ) ; ret . put ( \"<STR_LIT>\" , appUpdateInfo . updateAvailability ( ) ) ; ret . put ( \"<STR_LIT>\" , appUpdateInfo . updatePriority ( ) ) ; ret . put ( \"<STR_LIT>\" , appUpdateInfo . isUpdateTypeAllowed ( AppUpdateType . IMMEDIATE ) ) ; ret . put ( \"<STR_LIT>\" , appUpdateInfo . isUpdateTypeAllowed ( AppUpdateType . FLEXIBLE ) ) ; Integer clientVersionStalenessDays = appUpdateInfo . clientVersionStalenessDays ( ) ; if ( clientVersionStalenessDays != null ) { ret . put ( \"<STR_LIT>\" , clientVersionStalenessDays ) ; } ret . put ( \"<STR_LIT>\" , appUpdateInfo . installStatus ( ) ) ; call . resolve ( ret ) ; } ) ; appUpdateInfoTask . addOnFailureListener ( failure -> { String message = failure . getMessage ( ) ; call . reject ( message ) ; } ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void openAppStore ( PluginCall call ) { try { String packageName = this . getContext ( ) . getPackageName ( ) ; Intent launchIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( \"<STR_LIT>\" + packageName ) ) ; try { this . getBridge ( ) . getActivity ( ) . startActivity ( launchIntent ) ; } catch ( ActivityNotFoundException ex ) { launchIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( \"<STR_LIT>\" + packageName ) ) ; this . getBridge ( ) . getActivity ( ) . startActivity ( launchIntent ) ; } call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void performImmediateUpdate ( PluginCall call ) { try { boolean ready = this . readyForUpdate ( call , AppUpdateType . IMMEDIATE ) ; if ( ! ready ) { return ; } savedPluginCall = call ; try { this . appUpdateManager . startUpdateFlowForResult ( this . appUpdateInfo , AppUpdateType . IMMEDIATE , getActivity ( ) , AppUpdatePlugin . REQUEST_IMMEDIATE_UPDATE ) ; } catch ( IntentSender . SendIntentException e ) { call . reject ( e . getMessage ( ) ) ; } } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void startFlexibleUpdate ( PluginCall call ) { try { boolean ready = this . readyForUpdate ( call , AppUpdateType . FLEXIBLE ) ; if ( ! ready ) { return ; } savedPluginCall = call ; this . listener = state -> { int installStatus = state . installStatus ( ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , installStatus ) ; if ( installStatus == InstallStatus . DOWNLOADING ) { ret . put ( \"<STR_LIT>\" , state . bytesDownloaded ( ) ) ; ret . put ( \"<STR_LIT>\" , state . totalBytesToDownload ( ) ) ; } notifyListeners ( \"<STR_LIT>\" , ret ) ; } ; this . appUpdateManager . registerListener ( this . listener ) ; this . appUpdateManager . startUpdateFlowForResult ( this . appUpdateInfo , AppUpdateType . FLEXIBLE , getActivity ( ) , AppUpdatePlugin . REQUEST_FLEXIBLE_UPDATE ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ PluginMethod public void completeFlexibleUpdate ( PluginCall call ) { try { this . unregisterListener ( ) ; this . appUpdateManager . completeUpdate ( ) ; call . resolve ( ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; call . reject ( exception . getMessage ( ) ) ; } } @ Override protected void handleOnActivityResult ( int requestCode , int resultCode , Intent data ) { try { super . handleOnActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK && requestCode == REQUEST_FLEXIBLE_UPDATE ) { this . unregisterListener ( ) ; } this . appUpdateInfo = null ; if ( savedPluginCall == null ) { return ; } JSObject ret = new JSObject ( ) ; if ( resultCode == RESULT_OK ) { ret . put ( \"<STR_LIT>\" , UPDATE_OK ) ; } else if ( resultCode == RESULT_CANCELED ) { ret . put ( \"<STR_LIT>\" , UPDATE_CANCELED ) ; } else if ( resultCode == RESULT_IN_APP_UPDATE_FAILED ) { ret . put ( \"<STR_LIT>\" , UPDATE_FAILED ) ; } savedPluginCall . resolve ( ret ) ; } catch ( Exception exception ) {", "output": "Logger . error ( TAG , exception . getMessage ( ) , exception ) ; if ( savedPluginCall == null ) { return ; } savedPluginCall . reject ( exception . getMessage ( ) ) ; } } private boolean isGooglePlayServicesAvailable ( ) { GoogleApiAvailability googleApiAvailability = GoogleApiAvailability . getInstance ( ) ; int resultCode = googleApiAvailability . isGooglePlayServicesAvailable ( bridge . getContext ( ) ) ; return resultCode == ConnectionResult . SUCCESS ; } private PackageInfo getPackageInfo ( ) throws PackageManager . NameNotFoundException { String packageName = this . getContext ( ) . getPackageName ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { return this . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , PackageManager . PackageInfoFlags . of ( <NUM_LIT> ) ) ; } else { return this . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , <NUM_LIT> ) ; } } private boolean readyForUpdate ( PluginCall call , int appUpdateType ) { JSObject ret = new JSObject ( ) ; if ( this . appUpdateInfo == null ) { ret . put ( \"<STR_LIT>\" , UPDATE_INFO_MISSING ) ; call . resolve ( ret ) ; return false ; } if ( this . appUpdateInfo . updateAvailability ( ) != UpdateAvailability . UPDATE_AVAILABLE ) { ret . put ( \"<STR_LIT>\" , UPDATE_NOT_AVAILABLE ) ; call . resolve ( ret ) ; return false ; } if ( ! this . appUpdateInfo . isUpdateTypeAllowed ( appUpdateType ) ) { ret . put ( \"<STR_LIT>\" , UPDATE_NOT_ALLOWED ) ; call . resolve ( ret ) ; return false ; } return true ; } private void unregisterListener ( ) { if ( this . listener == null || this . appUpdateManager == null ) { return ; } this . appUpdateManager . unregisterListener ( this . listener ) ; this . listener = null ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface IsGoogleBarodeScannerModuleAvailableResultCallback {", "output": "void success ( boolean isAvailable ) ; void error ( Exception exception ) ; }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . text . Html ; import android . text . Spannable ; import android . text . Spanned ; import android . text . style . QuoteSpan ; import android . util . AttributeSet ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RawRes ; import java . io . InputStream ; import java . util . Scanner ; public class HtmlTextView extends JellyBeanSpanFixTextView { public static final String TAG = \"<STR_LIT>\" ; public static final boolean DEBUG = false ; public int blockQuoteBackgroundColor = getResources ( ) . getColor ( android . R . color . white ) ; public int blockQuoteStripColor = getResources ( ) . getColor ( android . R . color . black ) ; public float blockQuoteStripWidth = <NUM_LIT> ; public float blockQuoteGap = <NUM_LIT> ; @ Nullable private ClickableTableSpan clickableTableSpan ; @ Nullable private DrawTableLinkSpan drawTableLinkSpan ; @ Nullable private OnClickATagListener onClickATagListener ; private float indent = <NUM_LIT> ; private boolean removeTrailingWhiteSpace = true ; public HtmlTextView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } public HtmlTextView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public HtmlTextView ( Context context ) { super ( context ) ; } public void setHtml ( @ RawRes int resId ) { setHtml ( resId , null ) ; } public void setHtml ( @ NonNull String html ) { setHtml ( html , null ) ; } public void setHtml ( @ RawRes int resId , @ Nullable Html . ImageGetter imageGetter ) { InputStream inputStreamText = getContext ( ) . getResources ( ) . openRawResource ( resId ) ; setHtml ( convertStreamToString ( inputStreamText ) , imageGetter ) ; } public void setHtml ( @ NonNull String html , @ Nullable Html . ImageGetter imageGetter ) { Spanned styledText = HtmlFormatter . formatHtml ( html , imageGetter , clickableTableSpan , drawTableLinkSpan , new HtmlFormatter . TagClickListenerProvider ( ) { @ Override public OnClickATagListener provideTagClickListener ( ) { return onClickATagListener ; } } , indent , removeTrailingWhiteSpace ) ; replaceQuoteSpans ( styledText ) ; setText ( styledText ) ; setMovementMethod ( LocalLinkMovementMethod . getInstance ( ) ) ; } public void setRemoveTrailingWhiteSpace ( boolean removeTrailingWhiteSpace ) { this . removeTrailingWhiteSpace = removeTrailingWhiteSpace ; } public void setClickableTableSpan ( @ Nullable ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; } public void setDrawTableLinkSpan ( @ Nullable DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; } public void setOnClickATagListener ( @ Nullable OnClickATagListener onClickATagListener ) {", "output": "this . onClickATagListener = onClickATagListener ; } public void setListIndentPx ( float px ) { this . indent = px ; } @ NonNull private static String convertStreamToString ( @ NonNull InputStream is ) { Scanner s = new Scanner ( is ) . useDelimiter ( \"<STR_LIT>\" ) ; return s . hasNext ( ) ? s . next ( ) : \"<STR_LIT>\" ; } private void replaceQuoteSpans ( Spanned spanned ) { Spannable spannable = ( Spannable ) spanned ; QuoteSpan [ ] quoteSpans = spannable . getSpans ( <NUM_LIT> , spannable . length ( ) - <NUM_LIT> , QuoteSpan . class ) ; for ( QuoteSpan quoteSpan : quoteSpans ) { int start = spannable . getSpanStart ( quoteSpan ) ; int end = spannable . getSpanEnd ( quoteSpan ) ; int flags = spannable . getSpanFlags ( quoteSpan ) ; spannable . removeSpan ( quoteSpan ) ; spannable . setSpan ( new DesignQuoteSpan ( blockQuoteBackgroundColor , blockQuoteStripColor , blockQuoteStripWidth , blockQuoteGap ) , start , end , flags ) ; } } }"}, {"input": "package com . cgutman . adblib ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . Socket ; public class TcpChannel implements AdbChannel { private Socket socket ; private InputStream inputStream ; private OutputStream outputStream ; @ Override public void readx ( byte [ ] buffer , int length ) throws IOException { int dataRead = <NUM_LIT> ; do { int bytesRead = inputStream . read ( buffer , dataRead , length - dataRead ) ; if ( bytesRead < <NUM_LIT> ) throw new IOException ( \"<STR_LIT>\" ) ; else dataRead += bytesRead ; } while ( dataRead < length ) ; } private void writex ( byte [ ] buffer ) throws IOException { outputStream . write ( buffer ) ; outputStream . flush ( ) ; } @ Override public void writex ( AdbMessage message ) throws IOException { writex ( message . getMessage ( ) ) ; if ( message . getPayload ( ) != null ) { writex ( message . getPayload ( ) ) ; }", "output": "} @ Override public void close ( ) throws IOException { socket . close ( ) ; } public TcpChannel ( Socket socket ) { try { socket . setTcpNoDelay ( true ) ; this . socket = socket ; this . inputStream = socket . getInputStream ( ) ; this . outputStream = socket . getOutputStream ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }"}, {"input": "package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableType ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import com . reactnative . pulltorefresh . event . OffsetChangedEvent ; import com . reactnative . pulltorefresh . event . RefreshEvent ; import com . reactnative . pulltorefresh . event . StateChangedEvent ; import java . util . Map ; public class PullToRefreshHeaderManager extends ReactViewManager { public final static String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new PullToRefreshHeader ( context ) ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new PullToRefreshHeaderShadowNode ( ) ; } @ Override public Class < ? extends LayoutShadowNode > getShadowNodeClass ( ) { return PullToRefreshHeaderShadowNode . class ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setRefreshing ( PullToRefreshHeader pullToRefreshHeader , boolean refreshing ) { pullToRefreshHeader . setRefreshing ( refreshing ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( RefreshEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , RefreshEvent . JSEventName ) ) . put ( StateChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ Override public void receiveCommand ( ReactViewGroup root , String commandId , @ Nullable ReadableArray args ) { if ( root instanceof PullToRefreshHeader ) { PullToRefreshHeader header = ( PullToRefreshHeader ) root ; if ( \"<STR_LIT>\" . equals ( commandId ) ) { if ( args != null && args . getType ( <NUM_LIT> ) == ReadableType . Boolean ) { header . setRefreshing ( args . getBoolean ( <NUM_LIT> ) ) ; } } } } @ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof PullToRefreshHeader ) { PullToRefreshHeader pullToRefreshHeader = ( ( PullToRefreshHeader ) view ) ; int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; pullToRefreshHeader . setOnRefreshHeaderChangeListener ( new OnRefreshChangeListener ( ) { @ Override public void onRefresh ( ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new RefreshEvent ( surfaceId , viewId ) ) ; } } } @ Override public void onOffsetChange ( int offset ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new OffsetChangedEvent ( surfaceId , viewId , offset ) ) ; } } } @ Override public void onStateChanged ( PullToRefreshState state ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new StateChangedEvent ( surfaceId , viewId , state ) ) ; } } } } ) ; }", "output": "} }"}, {"input": "package org . woheller69 . weather . widget ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . widget . RemoteViews ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . util . Calendar ; import java . util . List ; import java . util . TimeZone ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; public class WeatherWidget5day extends AppWidgetProvider { public void updateAppWidget ( Context context , final int appWidgetId ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( \"<STR_LIT>\" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , List < WeekForecast > weekforecasts ) { int cityId = getWidgetCityID ( context ) ; SQLiteHelper database = SQLiteHelper . getInstance ( context . getApplicationContext ( ) ) ; int zonemilliseconds = database . getCurrentWeatherByCityId ( cityId ) . getTimeZoneSeconds ( ) * <NUM_LIT> ; CurrentWeatherData currentWeather = database . getCurrentWeatherByCityId ( cityId ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; int [ ] forecastData = new int [ <NUM_LIT> ] ; boolean [ ] isDay = new boolean [ <NUM_LIT> ] ; String [ ] weekday = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { c . setTimeInMillis ( weekforecasts . get ( i ) . getForecastTime ( ) + zonemilliseconds ) ; if ( currentWeather . getTimeSunrise ( ) == <NUM_LIT> || currentWeather . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( database . getCityToWatch ( cityId ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay [ i ] = c . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && c . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else { isDay [ i ] = c . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || c . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { isDay [ i ] = true ; } int day = c . get ( Calendar . DAY_OF_WEEK ) ; weekday [ i ] = context . getResources ( ) . getString ( StringFormatUtils . getDayShort ( day ) ) ; forecastData [ i ] = weekforecasts . get ( i ) . getWeatherID ( ) ; } views . setImageViewResource ( R . id . widget_5day_image1 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image2 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image3 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image4 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setImageViewResource ( R . id . widget_5day_image5 , UiResourceProvider . getIconResourceForWeatherCategory ( forecastData [ <NUM_LIT> ] , isDay [ <NUM_LIT> ] ) ) ; views . setTextViewText ( R . id . widget_5day_day1 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day2 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day3 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day4 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_day5 , weekday [ <NUM_LIT> ] ) ; views . setTextViewText ( R . id . widget_5day_temp_max1 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max2 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max3 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max4 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_max5 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMaxTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min1 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min2 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min3 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min4 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setTextViewText ( R . id . widget_5day_temp_min5 , StringFormatUtils . formatTemperature ( context , weekforecasts . get ( <NUM_LIT> ) . getMinTemperature ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind1 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind2 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind3 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind4 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; views . setImageViewResource ( R . id . widget_5day_wind5 , StringFormatUtils . colorWindSpeedWidget ( weekforecasts . get ( <NUM_LIT> ) . getWind_speed ( ) ) ) ; Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( \"<STR_LIT>\" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget5day_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget5day . class ) ) ; for ( int widgetID : widgetIDs ) {", "output": "RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget_5day ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherWidget5day . updateView ( context , appWidgetManager , views , widgetID , city , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { } }"}, {"input": "package com . simon . harmonichackernews . network ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import android . widget . Toast ; import androidx . appcompat . app . AlertDialog ; import androidx . core . util . Pair ; import androidx . fragment . app . FragmentManager ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . utils . AccountUtils ; import com . simon . harmonichackernews . utils . EncryptedSharedPreferencesHelper ; import com . simon . harmonichackernews . utils . Utils ; import org . jetbrains . annotations . NotNull ; import java . io . IOException ; import java . util . Objects ; import kotlin . Triple ; import okhttp3 . Call ; import okhttp3 . Callback ; import okhttp3 . FormBody ; import okhttp3 . HttpUrl ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; public class UserActions { private static final String BASE_WEB_URL = \"<STR_LIT>\" ; private static final String LOGIN_PATH = \"<STR_LIT>\" ; private static final String VOTE_PATH = \"<STR_LIT>\" ; private static final String COMMENT_PATH = \"<STR_LIT>\" ; private static final String SUBMIT_PATH = \"<STR_LIT>\" ; private static final String ITEM_PATH = \"<STR_LIT>\" ; private static final String SUBMIT_POST_PATH = \"<STR_LIT>\" ; private static final String LOGIN_PARAM_ACCT = \"<STR_LIT>\" ; private static final String LOGIN_PARAM_PW = \"<STR_LIT>\" ; private static final String LOGIN_PARAM_CREATING = \"<STR_LIT>\" ; private static final String LOGIN_PARAM_GOTO = \"<STR_LIT>\" ; private static final String ITEM_PARAM_ID = \"<STR_LIT>\" ; private static final String VOTE_PARAM_ID = \"<STR_LIT>\" ; private static final String VOTE_PARAM_HOW = \"<STR_LIT>\" ; private static final String COMMENT_PARAM_PARENT = \"<STR_LIT>\" ; private static final String COMMENT_PARAM_TEXT = \"<STR_LIT>\" ; private static final String SUBMIT_PARAM_TITLE = \"<STR_LIT>\" ; private static final String SUBMIT_PARAM_URL = \"<STR_LIT>\" ; private static final String SUBMIT_PARAM_TEXT = \"<STR_LIT>\" ; private static final String SUBMIT_PARAM_FNID = \"<STR_LIT>\" ; private static final String SUBMIT_PARAM_FNOP = \"<STR_LIT>\" ; private static final String VOTE_DIR_UP = \"<STR_LIT>\" ; private static final String VOTE_DIR_DOWN = \"<STR_LIT>\" ; private static final String VOTE_DIR_UN = \"<STR_LIT>\" ; private static final String DEFAULT_REDIRECT = \"<STR_LIT>\" ; private static final String CREATING_TRUE = \"<STR_LIT>\" ; private static final String DEFAULT_FNOP = \"<STR_LIT>\" ; private static final String DEFAULT_SUBMIT_REDIRECT = \"<STR_LIT>\" ; private static final String REGEX_INPUT = \"<STR_LIT>\" ; private static final String REGEX_VALUE = \"<STR_LIT>\" ; private static final String REGEX_CREATE_ERROR_BODY = \"<STR_LIT>\" ; private static final String HEADER_LOCATION = \"<STR_LIT>\" ; private static final String HEADER_COOKIE = \"<STR_LIT>\" ; private static final String HEADER_SET_COOKIE = \"<STR_LIT>\" ; public static void voteWithDir ( Context ctx , int id , FragmentManager fm , String dir ) { UserActions . vote ( String . valueOf ( id ) , dir , ctx , fm , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { String message = \"<STR_LIT>\" ; switch ( dir ) { case VOTE_DIR_UP : message = \"<STR_LIT>\" ; break ; case VOTE_DIR_DOWN : message = \"<STR_LIT>\" ; break ; case VOTE_DIR_UN : message = \"<STR_LIT>\" ; break ; } Toast . makeText ( ctx , message , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onFailure ( String summary , String response ) { UserActions . showFailureDetailDialog ( ctx , summary , response ) ; Toast . makeText ( ctx , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } public static void upvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_UP ) ; } public static void downvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_DOWN ) ; } public static void unvote ( Context ctx , int id , FragmentManager fm ) { voteWithDir ( ctx , id , fm , VOTE_DIR_UN ) ; } public static void vote ( String itemId , String direction , Context ctx , FragmentManager fm , ActionCallback cb ) { Utils . log ( \"<STR_LIT>\" ) ; Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , fm , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( VOTE_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( VOTE_PARAM_ID , itemId ) . add ( VOTE_PARAM_HOW , direction ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void comment ( String itemId , String text , Context ctx , ActionCallback cb ) { Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , null , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( COMMENT_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( COMMENT_PARAM_PARENT , itemId ) . add ( COMMENT_PARAM_TEXT , text ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void submit ( String title , String text , String url , Context ctx , ActionCallback cb ) { Utils . log ( \"<STR_LIT>\" ) ; Triple < String , String , Integer > account = AccountUtils . getAccountDetails ( ctx ) ; if ( AccountUtils . handlePossibleError ( account , null , ctx ) ) { return ; } Request request = new Request . Builder ( ) . url ( Objects . requireNonNull ( HttpUrl . parse ( BASE_WEB_URL ) ) . newBuilder ( ) . addPathSegment ( SUBMIT_PATH ) . build ( ) ) . post ( new FormBody . Builder ( ) . add ( LOGIN_PARAM_ACCT , account . getFirst ( ) ) . add ( LOGIN_PARAM_PW , account . getSecond ( ) ) . add ( SUBMIT_PARAM_TITLE , title ) . add ( SUBMIT_PARAM_TEXT , text ) . add ( SUBMIT_PARAM_URL , url ) . build ( ) ) . build ( ) ; executeRequest ( ctx , request , cb ) ; } public static void executeRequest ( Context ctx , Request request , ActionCallback cb ) { OkHttpClient client = NetworkComponent . getOkHttpClientInstance ( ) ; client . newCall ( request ) . enqueue ( new Callback ( ) { final Handler mainHandler = new Handler ( ctx . getMainLooper ( ) ) ; @ Override public void onResponse ( @ NotNull Call call , @ NotNull Response response ) { mainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { if ( ! response . isSuccessful ( ) ) { cb . onFailure ( \"<STR_LIT>\" , response . toString ( ) ) ; return ; } try { String responseBody = response . body ( ) . string ( ) ; if ( responseBody . contains ( \"<STR_LIT>\" ) ) { cb . onFailure ( \"<STR_LIT>\" , responseBody ) ; return ; } if ( responseBody . contains ( \"<STR_LIT>\" ) ) { AccountUtils . deleteAccountDetails ( ctx ) ; cb . onFailure ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ; } if ( responseBody . contains ( \"<STR_LIT>\" ) ) { cb . onFailure ( \"<STR_LIT>\" , responseBody ) ; return ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } cb . onSuccess ( response ) ; } } ) ; } @ Override public void onFailure ( @ NotNull Call call , @ NotNull IOException e ) { mainHandler . post ( new Runnable ( ) { @ Override public void run ( ) { cb . onFailure ( \"<STR_LIT>\" , null ) ; } } ) ;", "output": "} } ) ; } public static void showFailureDetailDialog ( Context ctx , String summary , String response ) { try { AlertDialog dialog = new MaterialAlertDialogBuilder ( ctx ) . setTitle ( summary ) . setMessage ( response ) . setNegativeButton ( \"<STR_LIT>\" , null ) . create ( ) ; dialog . show ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public interface ActionCallback { void onSuccess ( Response response ) ; void onFailure ( String summary , String response ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . ItemTouchHelper ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . TextView ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import com . google . android . material . internal . TextWatcherAdapter ; import com . skythinker . gptassistant . ChatManager . Conversation ; import com . skythinker . gptassistant . ChatManager . ChatMessage ; public class HistoryActivity extends Activity { static private class HistoryListAdapter extends RecyclerView . Adapter < HistoryListAdapter . ViewHolder > { HistoryActivity historyActivity ; public HistoryListAdapter ( HistoryActivity historyActivity ) { this . historyActivity = historyActivity ; } @ Override public ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . history_list_item , parent , false ) ; return new HistoryListAdapter . ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ViewHolder holder , int position ) { Conversation conversation = historyActivity . chatManager . getConversationAtPosition ( position , historyActivity . searchKeyword ) ; holder . tvTitle . setText ( conversation . title ) ; holder . tvDetail . setText ( \"<STR_LIT>\" ) ; for ( ChatMessage message : conversation . messages ) { if ( message . role == ChatMessage . ChatRole . ASSISTANT && message . functionName == null ) { holder . tvDetail . setText ( message . contentText . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; break ; } } LocalDateTime now = LocalDateTime . now ( ) ; if ( now . getYear ( ) == conversation . time . getYear ( ) && now . getMonthValue ( ) == conversation . time . getMonthValue ( ) && now . getDayOfMonth ( ) == conversation . time . getDayOfMonth ( ) ) holder . tvTime . setText ( conversation . time . format ( DateTimeFormatter . ofPattern ( \"<STR_LIT>\" ) ) ) ; else holder . tvTime . setText ( conversation . time . format ( DateTimeFormatter . ofPattern ( \"<STR_LIT>\" ) ) ) ; } @ Override public int getItemCount ( ) { return ( int ) historyActivity . chatManager . getConversationCount ( historyActivity . searchKeyword ) ; } class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvDetail , tvTime ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_history_item_title ) ; tvDetail = itemView . findViewById ( R . id . tv_history_item_detail ) ; tvTime = itemView . findViewById ( R . id . tv_history_item_time ) ; llOuter = itemView . findViewById ( R . id . ll_history_item_outer ) ; llOuter . setOnClickListener ( ( view ) -> { Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , historyActivity . chatManager . getConversationAtPosition ( getAdapterPosition ( ) , historyActivity . searchKeyword ) . id ) ; historyActivity . setResult ( RESULT_OK , intent ) ; historyActivity . finish ( ) ; } ) ; } } } private ChatManager chatManager ; private RecyclerView rvHistoryList ; private HistoryListAdapter historyListAdapter ; private String searchKeyword = null ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_history ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; chatManager = new ChatManager ( this ) ; chatManager . removeEmptyConversations ( ) ; rvHistoryList = findViewById ( R . id . rv_history_list ) ; rvHistoryList . setLayoutManager ( new LinearLayoutManager ( this ) ) ; historyListAdapter = new HistoryListAdapter ( this ) ; rvHistoryList . setAdapter ( historyListAdapter ) ; new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( <NUM_LIT> , ItemTouchHelper . LEFT ) { @ Override public boolean onMove ( @ NonNull RecyclerView recyclerView , @ NonNull RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ViewHolder target ) { return false ; } @ Override public void onSwiped ( @ NonNull RecyclerView . ViewHolder viewHolder , int direction ) { int position = viewHolder . getAdapterPosition ( ) ; chatManager . removeConversation ( chatManager . getConversationAtPosition ( position , searchKeyword ) . id ) ; historyListAdapter . notifyItemRemoved ( position ) ; } } ) . attachToRecyclerView ( rvHistoryList ) ; ( ( EditText ) findViewById ( R . id . et_history_search ) ) . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable editable ) { searchKeyword = editable . toString ( ) ; if ( searchKeyword . length ( ) == <NUM_LIT> ) searchKeyword = null ; historyListAdapter . notifyDataSetChanged ( ) ; } } ) ; ( findViewById ( R . id . bt_history_back ) ) . setOnClickListener ( ( view ) -> { finish ( ) ; } ) ;", "output": "( findViewById ( R . id . bt_history_clear_all ) ) . setOnClickListener ( ( view ) -> { new ConfirmDialog ( this ) . setContent ( getString ( R . string . dialog_clear_history ) ) . setOnConfirmListener ( ( ) -> { chatManager . removeAllConversations ( ) ; historyListAdapter . notifyDataSetChanged ( ) ; } ) . show ( ) ; } ) ; } @ Override protected void onDestroy ( ) { chatManager . destroy ( ) ; super . onDestroy ( ) ; } @ Override public void finish ( ) { super . finish ( ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; } }"}, {"input": "package com . norman . webviewup . lib . source ; import android . content . Context ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . File ; import java . io . IOException ; public class UpgradeFileSource extends UpgradePathSource { public UpgradeFileSource ( Context context , File file ) { super ( context , file . getPath ( ) ) ; } @ Override protected void onPrepare ( Object params ) { new Thread ( new Runnable ( ) {", "output": "@ Override public void run ( ) { if ( ! FileUtils . existFile ( getApkPath ( ) ) ) { error ( new IOException ( \"<STR_LIT>\" + getApkPath ( ) ) ) ; } else { success ( ) ; } } } ) . start ( ) ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import java . lang . reflect . InvocationTargetException ; public class ReflectException extends RuntimeException { public ReflectException ( String message , Throwable cause ) { super ( message , getCause ( cause ) ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } public ReflectException ( Throwable cause ) { super ( getCause ( cause ) ) ; setStackTrace ( cause . getStackTrace ( ) ) ; } public ReflectException ( String message ) { super ( message ) ; } private static Throwable getCause ( Throwable throwable ) { if ( throwable instanceof InvocationTargetException ) {", "output": "InvocationTargetException invocationTargetException = ( InvocationTargetException ) throwable ; Throwable cause = invocationTargetException . getCause ( ) ; if ( cause != null ) { return cause ; } else { return invocationTargetException ; } } return throwable instanceof ReflectException ? throwable . getCause ( ) : throwable ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . graphics . Typeface ; import android . util . TypedValue ; import android . widget . TextView ; import androidx . core . content . res . ResourcesCompat ; import com . simon . harmonichackernews . R ; public class FontUtils { public static Typeface activeRegular ; public static Typeface activeBold ; public static String font ; public static void init ( Context ctx ) { font = SettingsUtils . getPreferredFont ( ctx ) ; switch ( font ) { case \"<STR_LIT>\" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . product_sans ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . product_sans_bold ) ; break ; case \"<STR_LIT>\" : activeRegular = Typeface . create ( \"<STR_LIT>\" , Typeface . NORMAL ) ; activeBold = Typeface . create ( \"<STR_LIT>\" , Typeface . BOLD ) ; break ; case \"<STR_LIT>\" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . verdana ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . verdana_bold ) ; break ; case \"<STR_LIT>\" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . jetbrains_mono ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . jetbrains_mono_bold ) ; break ; case \"<STR_LIT>\" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . georgia ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . georgia_bold ) ;", "output": "break ; case \"<STR_LIT>\" : activeRegular = ResourcesCompat . getFont ( ctx , R . font . roboto_slab ) ; activeBold = ResourcesCompat . getFont ( ctx , R . font . roboto_slab_bold ) ; break ; } } public static void setTypeface ( TextView textView , boolean bold , float size ) { setTypeface ( textView , bold , size , size , size , size , size , size ) ; } public static void setMultipleTypefaces ( boolean bold , float prodSize , float sansSize , float verdanaSize , float jetbrainsmonoSize , float georgiaSize , float robotoSlabSize , TextView ... textViews ) { for ( TextView textView : textViews ) { FontUtils . setTypeface ( textView , bold , prodSize , sansSize , verdanaSize , jetbrainsmonoSize , georgiaSize , robotoSlabSize ) ; } } public static void setTypeface ( TextView textView , boolean bold , float prodSize , float sansSize , float verdanaSize , float jetbrainsmonoSize , float georgiaSize , float robotoSlabSize ) { if ( activeRegular == null ) { init ( textView . getContext ( ) ) ; } textView . setTypeface ( bold ? activeBold : activeRegular ) ; switch ( font ) { case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , prodSize ) ; break ; case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , sansSize ) ; break ; case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , verdanaSize ) ; break ; case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , jetbrainsmonoSize ) ; break ; case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , georgiaSize ) ; break ; case \"<STR_LIT>\" : textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , robotoSlabSize ) ; break ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; public abstract class OnExitListener { public void onNewCommentRpid ( long rpid ) { } public void onCommentStatusUpdated ( long rpid ) {", "output": "} public void exit ( ) { } }"}, {"input": "package org . woheller69 . weather . widget ; import static androidx . core . app . JobIntentService . enqueueWork ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import static org . woheller69 . weather . services . UpdateDataService . SKIP_UPDATE_INTERVAL ; import static java . lang . Boolean . TRUE ; import android . Manifest ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import android . util . Log ; import android . view . View ; import android . widget . RemoteViews ; import android . widget . Toast ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ForecastCityActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . services . UpdateDataService ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . List ; import java . util . Locale ; import java . util . TimeZone ; public class WeatherDigitalClockWidget extends AppWidgetProvider { private static LocationListener locationListenerGPS ; private LocationManager locationManager ; public void updateAppWidget ( Context context , final int appWidgetId ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { int cityID = getWidgetCityID ( context ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) updateLocation ( context , cityID , false ) ; Intent intent = new Intent ( context , UpdateDataService . class ) ; intent . setAction ( UpdateDataService . UPDATE_SINGLE_ACTION ) ; intent . putExtra ( \"<STR_LIT>\" , cityID ) ; intent . putExtra ( SKIP_UPDATE_INTERVAL , true ) ; enqueueWork ( context , UpdateDataService . class , <NUM_LIT> , intent ) ; } } public static void updateLocation ( final Context context , int cityID , boolean manual ) { SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; List < CityToWatch > cities = db . getAllCitiesToWatch ( ) ; if ( ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { LocationManager locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; Location locationGPS = locationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( locationGPS != null ) { CityToWatch city ; double lat = locationGPS . getLatitude ( ) ; double lon = locationGPS . getLongitude ( ) ; for ( int i = <NUM_LIT> ; i < cities . size ( ) ; i ++ ) { if ( cities . get ( i ) . getCityId ( ) == cityID ) { city = cities . get ( i ) ; city . setLatitude ( ( float ) lat ) ; city . setLongitude ( ( float ) lon ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , lat , lon ) ) ; db . updateCityToWatch ( city ) ; break ; } } } else {", "output": "if ( manual ) Toast . makeText ( context . getApplicationContext ( ) , R . string . error_no_position , Toast . LENGTH_SHORT ) . show ( ) ; } } } public static void updateView ( Context context , AppWidgetManager appWidgetManager , RemoteViews views , int appWidgetId , CityToWatch city , CurrentWeatherData weatherData , List < WeekForecast > weekforecasts ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) views . setCharSequence ( R . id . textClockTime , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; else views . setCharSequence ( R . id . textClockTime , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; DateFormat df = DateFormat . getDateInstance ( DateFormat . LONG ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; String pattern = ( ( SimpleDateFormat ) df ) . toPattern ( ) ; views . setCharSequence ( R . id . textClockDate , \"<STR_LIT>\" , pattern ) ; views . setCharSequence ( R . id . textClockDate , \"<STR_LIT>\" , pattern ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) views . setViewVisibility ( R . id . location_on , View . VISIBLE ) ; else views . setViewVisibility ( R . id . location_on , View . INVISIBLE ) ; views . setTextViewText ( R . id . widget_city_name , city . getCityName ( ) ) ; views . setTextViewText ( R . id . widget_UVindex , \"<STR_LIT>\" ) ; views . setInt ( R . id . widget_UVindex , \"<STR_LIT>\" , StringFormatUtils . widgetColorUVindex ( context , Math . round ( weekforecasts . get ( <NUM_LIT> ) . getUv_index ( ) ) ) ) ; boolean isDay = weatherData . isDay ( context ) ; if ( ! dbHelper . hasQuarterHourly ( weatherData . getCity_id ( ) ) ) { HourlyForecast nowCast = new HourlyForecast ( ) ; List < HourlyForecast > hourlyForecasts = dbHelper . getForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( HourlyForecast f : hourlyForecasts ) { if ( Math . abs ( f . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { nowCast = f ; break ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( nowCast . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , \"<STR_LIT>\" + StringFormatUtils . formatTemperature ( context , nowCast . getTemperature ( ) ) + \"<STR_LIT>\" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( nowCast . getWindSpeed ( ) ) ) ; views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; } else { QuarterHourlyForecast next = new QuarterHourlyForecast ( ) ; List < QuarterHourlyForecast > quarterHourlyForecasts = dbHelper . getQuarterHourlyForecastsByCityId ( weatherData . getCity_id ( ) ) ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) ) { next = f ; break ; } } views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . INVISIBLE ) ; if ( next . getPrecipitation ( ) > <NUM_LIT> ) { QuarterHourlyForecast nextWithoutPrecipitation = null ; int count = <NUM_LIT> ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) == <NUM_LIT> ) { if ( count == <NUM_LIT> ) nextWithoutPrecipitation = f ; count ++ ; if ( count >= <NUM_LIT> ) break ; } else count = <NUM_LIT> ; } if ( nextWithoutPrecipitation != null && ( nextWithoutPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextWithoutPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } else { QuarterHourlyForecast nextPrecipitation = null ; for ( QuarterHourlyForecast f : quarterHourlyForecasts ) { if ( f . getForecastTime ( ) > System . currentTimeMillis ( ) && f . getPrecipitation ( ) > <NUM_LIT> ) { nextPrecipitation = f ; break ; } } if ( nextPrecipitation != null && ( nextPrecipitation . getForecastTime ( ) - System . currentTimeMillis ( ) ) <= <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { views . setTextViewText ( R . id . widget_precipitation_forecast , \"<STR_LIT>\" + StringFormatUtils . formatTimeWithoutZone ( context , nextPrecipitation . getLocalForecastTime ( context ) - <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ; views . setViewVisibility ( R . id . widget_precipitation_forecast , View . VISIBLE ) ; } } views . setImageViewResource ( R . id . widget_image_view , UiResourceProvider . getIconResourceForWeatherCategory ( next . getWeatherID ( ) , isDay ) ) ; views . setTextViewText ( R . id . widget_temperature , \"<STR_LIT>\" + StringFormatUtils . formatTemperature ( context , next . getTemperature ( ) ) + \"<STR_LIT>\" ) ; views . setImageViewResource ( R . id . widget_windicon , StringFormatUtils . colorWindSpeedWidget ( next . getWindSpeed ( ) ) ) ; } Intent intent2 = new Intent ( context , ForecastCityActivity . class ) ; intent2 . putExtra ( \"<STR_LIT>\" , getWidgetCityID ( context ) ) ; PendingIntent pendingIntent ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT | PendingIntent . FLAG_IMMUTABLE ) ; } else { pendingIntent = PendingIntent . getActivity ( context , appWidgetId , intent2 , PendingIntent . FLAG_UPDATE_CURRENT ) ; } views . setOnClickPendingIntent ( R . id . widget_digital_clock_layout , pendingIntent ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } @ Override public void onAppWidgetOptionsChanged ( Context context , AppWidgetManager appWidgetManager , int appWidgetId , Bundle newOptions ) { super . onAppWidgetOptionsChanged ( context , appWidgetManager , appWidgetId , newOptions ) ; } @ Override public void onUpdate ( final Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; PowerManager powerManager = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) && ActivityCompat . checkSelfPermission ( context , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED && ! powerManager . isPowerSaveMode ( ) ) { if ( locationListenerGPS == null ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; locationListenerGPS = new LocationListener ( ) { @ Override public void onLocationChanged ( Location location ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int [ ] appWidgetIds = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } else { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } for ( int appWidgetId : appWidgetIds ) { updateAppWidget ( context , appWidgetId ) ; } } @ Override public void onDeleted ( Context context , int [ ] appWidgetIds ) { } @ Override public void onEnabled ( Context context ) { SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; int widgetCityID = getWidgetCityID ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( widgetCityID ) ; List < WeekForecast > weekforecasts = dbHelper . getWeekForecastsByCityId ( widgetCityID ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int widgetID : widgetIDs ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_digital_clock_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( widgetCityID ) ; WeatherDigitalClockWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } @ Override public void onDisabled ( Context context ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( locationManager == null ) locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; locationListenerGPS = null ; } @ Override public void onReceive ( Context context , Intent intent ) { if ( intent . getBooleanExtra ( \"<STR_LIT>\" , false ) ) { int cityID = getWidgetCityID ( context ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context . getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) && ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) updateLocation ( context , cityID , true ) ; } super . onReceive ( context , intent ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . style . ClickableSpan ; public abstract class ClickableTableSpan extends ClickableSpan { protected String tableHtml ; public abstract ClickableTableSpan newInstance ( ) ; public void setTableHtml ( String tableHtml ) { this . tableHtml = tableHtml ; } public String getTableHtml ( ) {", "output": "return tableHtml ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . downgrade ; import static de . robv . android . xposed . XposedBridge . hookAllMethods ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . os . Build ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . lang . reflect . Field ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class Patch { public static void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam , XSharedPreferences prefs ) throws Throwable { if ( ! ( \"<STR_LIT>\" . equals ( lpparam . packageName ) ) || ! ( lpparam . processName . equals ( \"<STR_LIT>\" ) ) ) return ; XC_MethodHook hookDowngrade = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ; if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( null ) ; } } ; XC_MethodHook hookDowngrade2 = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pkg = ( String ) XposedHelpers . callMethod ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ;", "output": "if ( Objects . equals ( pkg , FeatureLoader . PACKAGE_WPP ) || Objects . equals ( pkg , FeatureLoader . PACKAGE_BUSINESS ) ) param . setResult ( true ) ; } } ; switch ( Build . VERSION . SDK_INT ) { case Build . VERSION_CODES . UPSIDE_DOWN_CAKE : findAndHookMethod ( \"<STR_LIT>\" , lpparam . classLoader , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , hookDowngrade ) ; break ; case Build . VERSION_CODES . TIRAMISU : var checkDowngrade = XposedHelpers . findMethodExactIfExists ( \"<STR_LIT>\" , lpparam . classLoader , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( checkDowngrade != null ) { XposedBridge . hookMethod ( checkDowngrade , hookDowngrade ) ; } break ; case Build . VERSION_CODES . S_V2 : case Build . VERSION_CODES . S : case Build . VERSION_CODES . R : var pmService = XposedHelpers . findClassIfExists ( \"<STR_LIT>\" , lpparam . classLoader ) ; if ( pmService != null ) { var checkDowngrade1 = XposedHelpers . findMethodExactIfExists ( pmService , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( checkDowngrade1 != null ) { XposedBridge . hookMethod ( checkDowngrade1 , hookDowngrade ) ; } var flymeCheckDowngrade = XposedHelpers . findMethodExactIfExists ( pmService , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( flymeCheckDowngrade != null ) XposedBridge . hookMethod ( flymeCheckDowngrade , hookDowngrade2 ) ; } break ; case Build . VERSION_CODES . Q : case Build . VERSION_CODES . P : Class < ? > packageClazz = XposedHelpers . findClass ( \"<STR_LIT>\" , lpparam . classLoader ) ; hookAllMethods ( XposedHelpers . findClass ( \"<STR_LIT>\" , lpparam . classLoader ) , \"<STR_LIT>\" , new XC_MethodHook ( ) { public void beforeHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object packageInfoLite = methodHookParam . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( packageInfoLite , \"<STR_LIT>\" ) ; if ( packageName == FeatureLoader . PACKAGE_WPP || packageName == FeatureLoader . PACKAGE_BUSINESS ) { Field field = packageClazz . getField ( \"<STR_LIT>\" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; field = packageClazz . getField ( \"<STR_LIT>\" ) ; field . setAccessible ( true ) ; field . set ( packageInfoLite , <NUM_LIT> ) ; } } } ) ; break ; default : XposedBridge . log ( \"<STR_LIT>\" + Build . VERSION . SDK_INT ) ; break ; } } }"}, {"input": "package com . reactnative . keyboardinsets ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . WindowInsetsAnimationCompat ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . common . logging . FLog ; import com . facebook . react . uimanager . ThemedReactContext ; import java . util . List ; public class KeyboardInsetsCallback extends WindowInsetsAnimationCompat . Callback implements OnApplyWindowInsetsListener { private final KeyboardInsetsView view ; private final KeyboardAutoHandler autoHandler ; private final KeyboardManualHandler manualHandler ; public KeyboardInsetsCallback ( KeyboardInsetsView view , ThemedReactContext reactContext ) { super ( WindowInsetsAnimationCompat . Callback . DISPATCH_MODE_CONTINUE_ON_SUBTREE ) ; this . view = view ; this . autoHandler = new KeyboardAutoHandler ( view , reactContext ) ; this . manualHandler = new KeyboardManualHandler ( view , reactContext ) ; } public View focusView ; private boolean transitioning ; private int keyboardHeight ; @ Override public void onPrepare ( @ NonNull WindowInsetsAnimationCompat animation ) { transitioning = true ; } @ NonNull @ Override public WindowInsetsAnimationCompat . BoundsCompat onStart ( @ NonNull WindowInsetsAnimationCompat animation , @ NonNull WindowInsetsAnimationCompat . BoundsCompat bounds ) { if ( SystemUI . isImeVisible ( view ) ) { focusView = view . findFocus ( ) ; } if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return super . onStart ( animation , bounds ) ; } if ( SystemUI . isImeVisible ( view ) ) { keyboardHeight = SystemUI . imeHeight ( view ) ; } FLog . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( view . isAutoMode ( ) ) { autoHandler . onStart ( focusView , keyboardHeight ) ; } else { manualHandler . onStart ( focusView , keyboardHeight ) ; } return super . onStart ( animation , bounds ) ; } @ Override public void onEnd ( @ NonNull WindowInsetsAnimationCompat animation ) { super . onEnd ( animation ) ; transitioning = false ; if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return ; } if ( ! SystemUI . isImeVisible ( view ) ) { focusView = null ; } FLog . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( view . isAutoMode ( ) ) { autoHandler . onEnd ( focusView , keyboardHeight ) ; } else { manualHandler . onEnd ( focusView , keyboardHeight ) ; } } @ NonNull @ Override public WindowInsetsCompat onProgress ( @ NonNull WindowInsetsCompat insets , @ NonNull List < WindowInsetsAnimationCompat > runningAnimations ) { if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return insets ; } handleKeyboardTransition ( insets ) ; return WindowInsetsCompat . CONSUMED ; } @ Override public WindowInsetsCompat onApplyWindowInsets ( View v , WindowInsetsCompat insets ) { if ( transitioning ) { return insets ; } if ( focusView == null ) { focusView = view . findFocus ( ) ; } if ( ! shouldHandleKeyboardTransition ( focusView ) ) { return insets ; } Insets imeInsets = insets . getInsets ( WindowInsetsCompat . Type . ime ( ) ) ; FLog . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + imeInsets ) ; if ( SystemUI . isImeVisible ( view ) ) { keyboardHeight = SystemUI . imeHeight ( view ) ; } if ( view . isAutoMode ( ) ) { View focusView = view . findFocus ( ) ; if ( focusView != null && focusView != this . focusView ) { KeyboardInsetsView insetsView = findClosestKeyboardInsetsView ( focusView ) ; if ( insetsView != view ) { focusView = null ; } } this . focusView = focusView ; autoHandler . onApplyWindowInsets ( insets , focusView , keyboardHeight ) ; } else { manualHandler . onApplyWindowInsets ( insets , focusView , keyboardHeight ) ; } return insets ; } private void handleKeyboardTransition ( WindowInsetsCompat insets ) { if ( view . isAutoMode ( ) ) {", "output": "autoHandler . handleKeyboardTransition ( insets , focusView ) ; } else { manualHandler . handleKeyboardTransition ( insets , focusView ) ; } } private boolean shouldHandleKeyboardTransition ( View focus ) { if ( focus != null ) { KeyboardInsetsView insetsView = findClosestKeyboardInsetsView ( focus ) ; return insetsView == view ; } return false ; } private static KeyboardInsetsView findClosestKeyboardInsetsView ( View focus ) { ViewParent viewParent = focus . getParent ( ) ; if ( viewParent instanceof KeyboardInsetsView ) { return ( KeyboardInsetsView ) viewParent ; } if ( viewParent instanceof View ) { return findClosestKeyboardInsetsView ( ( View ) viewParent ) ; } return null ; } }"}, {"input": "package com . appspa . update . entity ; import android . content . Context ; import android . text . TextUtils ; import android . util . SparseArray ; import com . appspa . update . R ; public class UpdateError extends Throwable { private final int mCode ; public UpdateError ( int code ) { this ( code , null ) ; } public UpdateError ( int code , String message ) { super ( make ( code , message ) ) ; mCode = code ; } public UpdateError ( Throwable e ) { super ( e ) ;", "output": "mCode = ERROR . UPDATE_UNKNOWN ; } public int getCode ( ) { return mCode ; } @ Override public String toString ( ) { return getMessage ( ) ; } private static String make ( int code , String message ) { String m = sMessages . get ( code ) ; if ( TextUtils . isEmpty ( m ) ) { return \"<STR_LIT>\" ; } if ( TextUtils . isEmpty ( message ) || message . equals ( \"<STR_LIT>\" ) ) { return m ; } return m + \"<STR_LIT>\" + message + \"<STR_LIT>\" ; } public String getDetailMsg ( ) { return \"<STR_LIT>\" + mCode + \"<STR_LIT>\" + getMessage ( ) ; } public final static class ERROR { public static final int CHECK_NET_REQUEST = <NUM_LIT> ; public static final int CHECK_NO_WIFI = CHECK_NET_REQUEST + <NUM_LIT> ; public static final int CHECK_NO_NETWORK = CHECK_NO_WIFI + <NUM_LIT> ; public static final int CHECK_UPDATING = CHECK_NO_NETWORK + <NUM_LIT> ; public static final int CHECK_NO_NEW_VERSION = CHECK_UPDATING + <NUM_LIT> ; public static final int CHECK_JSON_EMPTY = CHECK_NO_NEW_VERSION + <NUM_LIT> ; public static final int CHECK_PARSE = CHECK_JSON_EMPTY + <NUM_LIT> ; public static final int CHECK_IGNORED_VERSION = CHECK_PARSE + <NUM_LIT> ; public static final int CHECK_APK_CACHE_DIR_EMPTY = CHECK_IGNORED_VERSION + <NUM_LIT> ; public static final int PROMPT_UNKNOWN = <NUM_LIT> ; public static final int PROMPT_ACTIVITY_DESTROY = PROMPT_UNKNOWN + <NUM_LIT> ; public static final int DOWNLOAD_FAILED = <NUM_LIT> ; public static final int DOWNLOAD_PERMISSION_DENIED = DOWNLOAD_FAILED + <NUM_LIT> ; public static final int INSTALL_FAILED = <NUM_LIT> ; public static final int FAIL_OLD_MD5 = <NUM_LIT> ; public static final int FAIL_GEN_MD5 = <NUM_LIT> ; public static final int FAIL_PATCH = <NUM_LIT> ; public static final int FAIL_GET_SOURCE = <NUM_LIT> ; public static final int UPDATE_UNKNOWN = <NUM_LIT> ; } private static final SparseArray < String > sMessages = new SparseArray < > ( ) ; public static void init ( Context context ) { sMessages . append ( ERROR . CHECK_NET_REQUEST , context . getString ( R . string . space_error_check_net_request ) ) ; sMessages . append ( ERROR . CHECK_NO_WIFI , context . getString ( R . string . space_error_check_no_wifi ) ) ; sMessages . append ( ERROR . CHECK_NO_NETWORK , context . getString ( R . string . space_error_check_no_network ) ) ; sMessages . append ( ERROR . CHECK_UPDATING , context . getString ( R . string . space_error_check_updating ) ) ; sMessages . append ( ERROR . CHECK_NO_NEW_VERSION , context . getString ( R . string . space_error_check_no_new_version ) ) ; sMessages . append ( ERROR . CHECK_JSON_EMPTY , context . getString ( R . string . space_error_check_json_empty ) ) ; sMessages . append ( ERROR . CHECK_PARSE , context . getString ( R . string . space_error_check_parse ) ) ; sMessages . append ( ERROR . CHECK_IGNORED_VERSION , context . getString ( R . string . space_error_check_ignored_version ) ) ; sMessages . append ( ERROR . CHECK_APK_CACHE_DIR_EMPTY , context . getString ( R . string . space_error_check_apk_cache_dir_empty ) ) ; sMessages . append ( ERROR . PROMPT_UNKNOWN , context . getString ( R . string . space_error_prompt_unknown ) ) ; sMessages . append ( ERROR . PROMPT_ACTIVITY_DESTROY , context . getString ( R . string . space_error_prompt_activity_destroy ) ) ; sMessages . append ( ERROR . DOWNLOAD_FAILED , context . getString ( R . string . space_error_download_failed ) ) ; sMessages . append ( ERROR . DOWNLOAD_PERMISSION_DENIED , context . getString ( R . string . space_error_download_permission_denied ) ) ; sMessages . append ( ERROR . INSTALL_FAILED , context . getString ( R . string . space_error_install_failed ) ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . Context ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import androidx . core . content . ContextCompat ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . TreeSet ; import javax . net . ssl . HttpsURLConnection ; public class AutoCheck { public static final boolean isOnlineLited = false ; private LinkedHashMap < String , Check > checks ; private Context context ; private Handler handler ; private boolean hasError ; private boolean enableOffline ; private boolean isFinished = false ; private String name ; private static final String TAG = \"<STR_LIT>\" ; public AutoCheck ( Context context , final Handler handler , boolean enableOffline ) { this . context = context ; checks = new LinkedHashMap < > ( ) ; this . handler = handler ; this . enableOffline = enableOffline ; } public void checkAsr ( final Map < String , Object > params ) { Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { AutoCheck obj = checkAsrInternal ( params ) ; name = \"<STR_LIT>\" ; synchronized ( obj ) { isFinished = true ; Message msg = handler . obtainMessage ( <NUM_LIT> , obj ) ; handler . sendMessage ( msg ) ; } } } ) ; t . start ( ) ; } public String obtainErrorMessage ( ) { PrintConfig config = new PrintConfig ( ) ; return formatString ( config ) ; } public String obtainDebugMessage ( ) { PrintConfig config = new PrintConfig ( ) ; config . withInfo = true ; return formatString ( config ) ; } public String obtainAllMessage ( ) { PrintConfig config = new PrintConfig ( ) ; config . withLog = true ; config . withInfo = true ; config . withLogOnSuccess = true ; return formatString ( config ) ; } private String formatString ( PrintConfig config ) { StringBuilder sb = new StringBuilder ( ) ; hasError = false ; for ( HashMap . Entry < String , Check > entry : checks . entrySet ( ) ) { Check check = entry . getValue ( ) ; String testName = entry . getKey ( ) ; if ( check . hasError ( ) ) { if ( ! hasError ) { hasError = true ; } sb . append ( \"<STR_LIT>\" ) . append ( testName ) . append ( \"<STR_LIT>\" ) . append ( check . getErrorMessage ( ) ) . append ( \"<STR_LIT>\" ) ; Log . e ( \"<STR_LIT>\" , sb . toString ( ) ) ; if ( check . hasFix ( ) ) { sb . append ( \"<STR_LIT>\" ) . append ( testName ) . append ( \"<STR_LIT>\" ) . append ( check . getFixMessage ( ) ) . append ( \"<STR_LIT>\" ) ; } } else if ( config . withEachCheckInfo ) { sb . append ( \"<STR_LIT>\" ) . append ( testName ) . append ( \"<STR_LIT>\" ) . append ( \"<STR_LIT>\" ) ; } if ( config . withInfo && check . hasInfo ( ) ) { sb . append ( \"<STR_LIT>\" ) . append ( testName ) . append ( \"<STR_LIT>\" ) . append ( check . getInfoMessage ( ) ) . append ( \"<STR_LIT>\" ) ; } if ( config . withLog && ( config . withLogOnSuccess || hasError ) && check . hasLog ( ) ) { sb . append ( \"<STR_LIT>\" + check . getLogMessage ( ) ) . append ( \"<STR_LIT>\" ) ; } } if ( ! hasError ) { sb . append ( \"<STR_LIT>\" + name + \"<STR_LIT>\" ) ; } return sb . toString ( ) ; } private AutoCheck checkAsrInternal ( Map < String , Object > params ) { commonSetting ( params ) ; checks . put ( \"<STR_LIT>\" , new FileCheck ( context , params , SpeechConstant . IN_FILE ) ) ; checks . put ( \"<STR_LIT>\" , new FileCheck ( context , params , SpeechConstant . ASR_OFFLINE_ENGINE_GRAMMER_FILE_PATH ) ) ; for ( Map . Entry < String , Check > e : checks . entrySet ( ) ) { Check check = e . getValue ( ) ; check . check ( ) ; if ( check . hasError ( ) ) { break ; } } return this ; } private void commonSetting ( Map < String , Object > params ) { checks . put ( \"<STR_LIT>\" , new PermissionCheck ( context ) ) ; checks . put ( \"<STR_LIT>\" , new JniCheck ( context ) ) ; AppInfoCheck infoCheck = null ; try { infoCheck = new AppInfoCheck ( context , params ) ; checks . put ( \"<STR_LIT>\" , infoCheck ) ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; Log . e ( TAG , \"<STR_LIT>\" , e ) ; return ; } if ( enableOffline ) { checks . put ( \"<STR_LIT>\" , new ApplicationIdCheck ( context , infoCheck . appId ) ) ; } } private static class PrintConfig { public boolean withEachCheckInfo = false ; public boolean withInfo = false ; public boolean withLog = false ; public boolean withLogOnSuccess = false ; } private static class PermissionCheck extends Check { private Context context ; public PermissionCheck ( Context context ) { this . context = context ; } @ Override public void check ( ) { String [ ] permissions = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( context , perm ) ) { toApplyList . add ( perm ) ; } } if ( ! toApplyList . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" + toApplyList ; fixMessage = \"<STR_LIT>\" ; } } } private static class JniCheck extends Check { private Context context ; private String [ ] soNames ; public JniCheck ( Context context ) { this . context = context ; if ( isOnlineLited ) { soNames = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } ; } else { soNames = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; } } @ Override public void check ( ) { String path = context . getApplicationInfo ( ) . nativeLibraryDir ; appendLogMessage ( \"<STR_LIT>\" + path ) ; File [ ] files = new File ( path ) . listFiles ( ) ; TreeSet < String > set = new TreeSet < > ( ) ; if ( files != null ) { for ( File file : files ) { set . add ( file . getName ( ) ) ; } } for ( String name : soNames ) { if ( ! set . contains ( name ) ) { errorMessage = \"<STR_LIT>\" + path + \"<STR_LIT>\" + name + \"<STR_LIT>\" + set . toString ( ) ; fixMessage = \"<STR_LIT>\" + \"<STR_LIT>\" ; break ; } } } } private static class AppInfoCheck extends Check { private String appId ; private String appKey ; private String secretKey ; public AppInfoCheck ( Context context , Map < String , Object > params ) throws PackageManager . NameNotFoundException { if ( params . get ( SpeechConstant . APP_ID ) != null ) { appId = params . get ( SpeechConstant . APP_ID ) . toString ( ) ; } if ( params . get ( SpeechConstant . APP_KEY ) != null ) { appKey = params . get ( SpeechConstant . APP_KEY ) . toString ( ) ; } if ( params . get ( SpeechConstant . SECRET ) != null ) { secretKey = params . get ( SpeechConstant . SECRET ) . toString ( ) ; } } public void check ( ) { do { appendLogMessage ( \"<STR_LIT>\" + appId + \"<STR_LIT>\" + appKey + \"<STR_LIT>\" + secretKey ) ; if ( appId == null || appId . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" ; fixMessage = \"<STR_LIT>\" ; break ; } if ( appKey == null || appKey . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" ; fixMessage = \"<STR_LIT>\" ; break ; } if ( secretKey == null || secretKey . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" ; fixMessage = \"<STR_LIT>\" ; break ; } try { checkOnline ( ) ; } catch ( UnknownHostException e ) { infoMessage = \"<STR_LIT>\" + e . getMessage ( ) ; } catch ( Exception e ) { errorMessage = e . getClass ( ) . getCanonicalName ( ) + \"<STR_LIT>\" + e . getMessage ( ) ; fixMessage = \"<STR_LIT>\" ; } } while ( false ) ; } public void checkOnline ( ) throws Exception { String urlpath = \"<STR_LIT>\" + appKey + \"<STR_LIT>\" + secretKey + \"<STR_LIT>\" ; Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + urlpath ) ; URL url = new URL ( urlpath ) ; HttpsURLConnection conn = ( HttpsURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> ) ; InputStream is = conn . getInputStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; StringBuilder result = new StringBuilder ( ) ; String line = \"<STR_LIT>\" ; do { line = reader . readLine ( ) ; if ( line != null ) { result . append ( line ) ; } } while ( line != null ) ; String res = result . toString ( ) ; if ( ! res . contains ( \"<STR_LIT>\" ) ) { errorMessage = \"<STR_LIT>\" + appId + \"<STR_LIT>\" ; fixMessage = \"<STR_LIT>\" ; return ; } appendLogMessage ( \"<STR_LIT>\" + res ) ; JSONObject jsonObject = new JSONObject ( res ) ; String error = jsonObject . optString ( \"<STR_LIT>\" ) ; if ( error != null && ! error . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" + \"<STR_LIT>\" + error + \"<STR_LIT>\" + result ; fixMessage = \"<STR_LIT>\" ; return ; } String token = jsonObject . getString ( \"<STR_LIT>\" ) ; if ( token == null || ! token . endsWith ( \"<STR_LIT>\" + appId ) ) { errorMessage = \"<STR_LIT>\" + appId + \"<STR_LIT>\" + token ; fixMessage = \"<STR_LIT>\" ; } } } private static class ApplicationIdCheck extends Check { private String appId ; private Context context ; public ApplicationIdCheck ( Context context , String appId ) { this . appId = appId ; this . context = context ; } @ Override public void check ( ) { infoMessage = \"<STR_LIT>\" + appId + \"<STR_LIT>\" + getApplicationId ( ) ; } private String getApplicationId ( ) { return context . getPackageName ( ) ; } } private static class FileCheck extends Check { private Map < String , Object > params ; private String key ; private Context context ; private boolean allowRes = false ; private boolean allowAssets = true ; public FileCheck ( Context context , Map < String , Object > params , String key ) { this . context = context ; this . params = params ; this . key = key ; if ( key . equals ( SpeechConstant . IN_FILE ) ) { allowRes = true ; allowAssets = false ; } } @ Override public void check ( ) { if ( ! params . containsKey ( key ) ) { return ; } String value = params . get ( key ) . toString ( ) ; if ( allowAssets ) { int len = \"<STR_LIT>\" . length ( ) ; int totalLen = len + \"<STR_LIT>\" . length ( ) ; if ( value . startsWith ( \"<STR_LIT>\" ) ) { String filename = value . substring ( totalLen ) ; if ( ! \"<STR_LIT>\" . equals ( value . substring ( len , totalLen ) ) || filename . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" + key + \"<STR_LIT>\" + value ; fixMessage = \"<STR_LIT>\" + \"<STR_LIT>\" ; } try { context . getAssets ( ) . open ( filename ) ; } catch ( IOException e ) { errorMessage = \"<STR_LIT>\" + filename ; fixMessage = \"<STR_LIT>\" ; e . printStackTrace ( ) ; } appendLogMessage ( \"<STR_LIT>\" + filename ) ; } } if ( allowRes ) { int len = \"<STR_LIT>\" . length ( ) ; int totalLen = len + \"<STR_LIT>\" . length ( ) ; if ( value . startsWith ( \"<STR_LIT>\" ) ) { String filename = value . substring ( totalLen ) ; if ( ! \"<STR_LIT>\" . equals ( value . substring ( len , totalLen ) ) || filename . isEmpty ( ) ) { errorMessage = \"<STR_LIT>\" + key + \"<STR_LIT>\" + value ; fixMessage = \"<STR_LIT>\" + \"<STR_LIT>\" ; } InputStream is = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ; if ( is == null ) { errorMessage = \"<STR_LIT>\" + filename ; fixMessage = \"<STR_LIT>\" ; } else { try { is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }", "output": "appendLogMessage ( \"<STR_LIT>\" + filename ) ; } } if ( value . startsWith ( \"<STR_LIT>\" ) ) { if ( ! new File ( value ) . canRead ( ) ) { errorMessage = \"<STR_LIT>\" + value ; fixMessage = \"<STR_LIT>\" ; } appendLogMessage ( \"<STR_LIT>\" + value ) ; } } } private abstract static class Check { protected String errorMessage = null ; protected String fixMessage = null ; protected String infoMessage = null ; protected StringBuilder logMessage ; public Check ( ) { logMessage = new StringBuilder ( ) ; } public abstract void check ( ) ; public boolean hasError ( ) { return errorMessage != null ; } public boolean hasFix ( ) { return fixMessage != null ; } public boolean hasInfo ( ) { return infoMessage != null ; } public boolean hasLog ( ) { return ! logMessage . toString ( ) . isEmpty ( ) ; } public void appendLogMessage ( String message ) { logMessage . append ( message + \"<STR_LIT>\" ) ; } public String getErrorMessage ( ) { return errorMessage ; } public String getFixMessage ( ) { return fixMessage ; } public String getInfoMessage ( ) { return infoMessage ; } public String getLogMessage ( ) { return logMessage . toString ( ) ; } } }"}, {"input": "package org . woheller69 . weather . weather_api . open_meteo ; import android . appwidget . AppWidgetManager ; import android . content . ComponentName ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Handler ; import android . widget . RemoteViews ; import android . widget . Toast ; import com . android . volley . VolleyError ; import org . json . JSONException ; import org . json . JSONObject ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . NavigationActivity ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . weather_api . IDataExtractor ; import org . woheller69 . weather . weather_api . IProcessHttpRequest ; import org . woheller69 . weather . widget . WeatherDigitalClockWidget ; import org . woheller69 . weather . widget . WeatherWidget ; import org . woheller69 . weather . widget . WeatherWidget5day ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion . WeatherCategories ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class ProcessOMweatherAPIRequest implements IProcessHttpRequest { private final String DEBUG_TAG = \"<STR_LIT>\" ; private Context context ; private SQLiteHelper dbHelper ; public ProcessOMweatherAPIRequest ( Context context ) { this . context = context ; this . dbHelper = SQLiteHelper . getInstance ( context ) ; } @ Override public void processSuccessScenario ( String response , int cityId ) { IDataExtractor extractor = new OMDataExtractor ( context ) ; try { JSONObject json = new JSONObject ( response ) ; List < WeekForecast > weekforecasts = new ArrayList < > ( ) ; weekforecasts = extractor . extractWeekForecast ( json . getString ( \"<STR_LIT>\" ) ) ; if ( weekforecasts != null && ! weekforecasts . isEmpty ( ) ) { for ( WeekForecast weekForecast : weekforecasts ) { weekForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } String rain60min = context . getResources ( ) . getString ( R . string . error_no_rain60min_data ) ; CurrentWeatherData weatherData = extractor . extractCurrentWeather ( json . getString ( \"<STR_LIT>\" ) ) ; if ( weatherData == null ) { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; }", "output": "else { weatherData . setCity_id ( cityId ) ; weatherData . setRain60min ( rain60min ) ; weatherData . setTimeSunrise ( weekforecasts . get ( <NUM_LIT> ) . getTimeSunrise ( ) ) ; weatherData . setTimeSunset ( weekforecasts . get ( <NUM_LIT> ) . getTimeSunset ( ) ) ; weatherData . setTimeZoneSeconds ( json . getInt ( \"<STR_LIT>\" ) ) ; CurrentWeatherData current = dbHelper . getCurrentWeatherByCityId ( cityId ) ; if ( current != null && current . getCity_id ( ) == cityId ) { dbHelper . updateCurrentWeather ( weatherData ) ; } else { dbHelper . addCurrentWeather ( weatherData ) ; } } List < HourlyForecast > hourlyforecasts = new ArrayList < > ( ) ; hourlyforecasts = extractor . extractHourlyForecast ( json . getString ( \"<STR_LIT>\" ) ) ; if ( hourlyforecasts != null && ! hourlyforecasts . isEmpty ( ) ) { for ( HourlyForecast hourlyForecast : hourlyforecasts ) { hourlyForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } dbHelper . replaceForecasts ( hourlyforecasts ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { weekforecasts = reanalyzeWeekIDs ( weekforecasts , hourlyforecasts ) ; } dbHelper . replaceWeekForecasts ( weekforecasts ) ; if ( json . has ( \"<STR_LIT>\" ) ) { List < QuarterHourlyForecast > quarterHourlyForecasts = new ArrayList < > ( ) ; quarterHourlyForecasts = extractor . extractQuarterHourlyForecast ( json . getString ( \"<STR_LIT>\" ) ) ; if ( quarterHourlyForecasts != null && ! quarterHourlyForecasts . isEmpty ( ) ) { for ( QuarterHourlyForecast quarterHourlyForecast : quarterHourlyForecasts ) { quarterHourlyForecast . setCity_id ( cityId ) ; } } else { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; return ; } dbHelper . replaceQuarterHourlyForecasts ( quarterHourlyForecasts ) ; } possiblyUpdateWidgets ( cityId , weatherData , weekforecasts , hourlyforecasts ) ; ViewUpdater . updateCurrentWeatherData ( weatherData ) ; ViewUpdater . updateWeekForecasts ( weekforecasts ) ; ViewUpdater . updateForecasts ( hourlyforecasts ) ; } catch ( JSONException e ) { final String ERROR_MSG = context . getResources ( ) . getString ( R . string . error_convert_to_json ) ; if ( NavigationActivity . isVisible ) Toast . makeText ( context , ERROR_MSG , Toast . LENGTH_LONG ) . show ( ) ; } } private List < WeekForecast > reanalyzeWeekIDs ( List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { Map < Integer , Integer > mappingTable = new HashMap < > ( ) ; mappingTable . put ( WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) , WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MIST . getNumVal ( ) , WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MODERATE_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . HEAVY_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . FREEZING_RAIN . getNumVal ( ) , WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . LIGHT_SNOW . getNumVal ( ) , WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . MODERATE_SNOW . getNumVal ( ) , WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) ; mappingTable . put ( WeatherCategories . HEAVY_SNOW . getNumVal ( ) , WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) ; Map < Integer , Integer > sunTable = new HashMap < > ( ) ; sunTable . put ( WeatherCategories . CLEAR_SKY . getNumVal ( ) , <NUM_LIT> ) ; sunTable . put ( WeatherCategories . FEW_CLOUDS . getNumVal ( ) , <NUM_LIT> ) ; sunTable . put ( WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) , <NUM_LIT> ) ; for ( WeekForecast weekForecast : weekforecasts ) { Integer ID = weekForecast . getWeatherID ( ) ; if ( mappingTable . containsKey ( ID ) ) { int totalCount = <NUM_LIT> ; int sunCount = <NUM_LIT> ; long sunrise = weekForecast . getTimeSunrise ( ) * <NUM_LIT> ; long sunset = weekForecast . getTimeSunset ( ) * <NUM_LIT> ; for ( HourlyForecast hourlyForecast : hourlyforecasts ) { if ( hourlyForecast . getForecastTime ( ) >= sunrise && hourlyForecast . getForecastTime ( ) <= sunset ) { totalCount ++ ; if ( sunTable . containsKey ( hourlyForecast . getWeatherID ( ) ) ) sunCount ++ ; } } if ( totalCount > <NUM_LIT> && ( float ) sunCount / totalCount > <NUM_LIT> ) weekForecast . setWeatherID ( mappingTable . get ( ID ) ) ; } } return weekforecasts ; } @ Override public void processFailScenario ( final VolleyError error ) { Handler h = new Handler ( this . context . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { if ( NavigationActivity . isVisible ) Toast . makeText ( context , context . getResources ( ) . getString ( R . string . error_fetch_forecast ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } private void possiblyUpdateWidgets ( int cityID , CurrentWeatherData currentWeather , List < WeekForecast > weekforecasts , List < HourlyForecast > hourlyforecasts ) { int widgetCityID = getWidgetCityID ( context ) ; int [ ] widgetIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget . class ) ) ; for ( int widgetID : widgetIDs ) { if ( cityID == widgetCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts , hourlyforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } int widgetDigitalClockCityID = getWidgetCityID ( context ) ; int [ ] widgetDigitalClockIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherDigitalClockWidget . class ) ) ; for ( int widgetID : widgetDigitalClockIDs ) { if ( cityID == widgetDigitalClockCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_digital_clock_widget ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherDigitalClockWidget . updateView ( context , appWidgetManager , views , widgetID , city , currentWeather , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } int widget5dayCityID = getWidgetCityID ( context ) ; int [ ] widget5dayIDs = AppWidgetManager . getInstance ( context ) . getAppWidgetIds ( new ComponentName ( context , WeatherWidget5day . class ) ) ; for ( int widgetID : widget5dayIDs ) { if ( cityID == widget5dayCityID ) { RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . weather_widget_5day ) ; AppWidgetManager appWidgetManager = AppWidgetManager . getInstance ( context ) ; CityToWatch city = dbHelper . getCityToWatch ( cityID ) ; WeatherWidget5day . updateView ( context , appWidgetManager , views , widgetID , city , weekforecasts ) ; appWidgetManager . updateAppWidget ( widgetID , views ) ; } } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; public interface DownloadModelResultCallback {", "output": "void success ( ) ; void error ( Exception exception ) ; }"}, {"input": "package com . reactnative . nestedscroll ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ReactShadowNode ; public class NestedScrollViewShadowNode extends LayoutShadowNode { private final static String TAG = \"<STR_LIT>\" ; @ Override public void setLocalData ( Object data ) { if ( data instanceof NestedScrollViewLocalData ) { NestedScrollViewLocalData nestedScrollViewLocalData = ( ( NestedScrollViewLocalData ) data ) ; ReactShadowNode < ? > parent = getChildAt ( <NUM_LIT> ) ; float parentNodeH = nestedScrollViewLocalData . headerNodeH + nestedScrollViewLocalData . contentNodeH ; setNodeHeight ( parent , parentNodeH ) ; for ( int i = <NUM_LIT> , count = parent . getChildCount ( ) ;", "output": "i < count ; i ++ ) { ReactShadowNode < ? > shadowNode = parent . getChildAt ( i ) ; if ( NestedScrollViewHeaderManager . REACT_CLASS . equals ( ( shadowNode . getViewClass ( ) ) ) ) { continue ; } float childNodeH = nestedScrollViewLocalData . contentNodeH ; setNodeHeight ( shadowNode , childNodeH ) ; } } } void setNodeHeight ( ReactShadowNode < ? > shadowNode , float h ) { shadowNode . setStyleMinHeight ( h ) ; shadowNode . setStyleMaxHeight ( h ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class HistoryCommentFragment extends Fragment { private View rootView ; private RecyclerView recyclerView ; private HistoryCommentAdapter adapter ; public HistoryCommentFragment ( ) { } public HistoryCommentFragment ( HistoryCommentAdapter adapter ) { this . adapter = adapter ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }", "output": "@ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_history_comment , container , false ) ; recyclerView = rootView . findViewById ( R . id . rv_history_comments ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( getContext ( ) ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; return rootView ; } }"}, {"input": "package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import android . content . res . ColorStateList ; import android . graphics . Bitmap ; import android . graphics . NinePatch ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . DrawableContainer ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . InsetDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . NinePatchDrawable ; import android . graphics . drawable . RippleDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . StateListDrawable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class DrawableColors { private static final HashMap < Bitmap , Integer > ninePatchs = new HashMap < > ( ) ; public static void replaceColor ( Drawable drawable , HashMap < String , String > colors ) { if ( DesignUtils . isNightMode ( ) ) { colors . remove ( \"<STR_LIT>\" ) ; } if ( drawable instanceof StateListDrawable stateListDrawable ) { var count = StateListDrawableCompact . getStateCount ( stateListDrawable ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var stateDrawable = StateListDrawableCompact . getStateDrawable ( stateListDrawable , i ) ; if ( stateDrawable != null ) replaceColor ( stateDrawable , colors ) ; } } else if ( drawable instanceof DrawableContainer drawableContainer ) { var containerState = drawableContainer . getConstantState ( ) ; var drawables = ( Drawable [ ] ) XposedHelpers . getObjectField ( containerState , \"<STR_LIT>\" ) ; for ( var drawable1 : drawables ) { replaceColor ( drawable1 , colors ) ; } } else if ( drawable instanceof LayerDrawable layerDrawable ) { var layerState = layerDrawable . getConstantState ( ) ; var mChildren = ( Object [ ] ) XposedHelpers . getObjectField ( layerState , \"<STR_LIT>\" ) ; for ( var childDrawable : mChildren ) { if ( childDrawable != null ) { var drawable1 = ( Drawable ) XposedHelpers . getObjectField ( childDrawable , \"<STR_LIT>\" ) ; replaceColor ( drawable1 , colors ) ; } } } else if ( drawable instanceof GradientDrawable gradientDrawable ) { var gradientColors = gradientDrawable . getColors ( ) ; if ( gradientColors != null ) { for ( var i = <NUM_LIT> ; i < gradientColors . length ; i ++ ) { var gradientColor = IColors . toString ( gradientColors [ i ] ) ; var newColor = colors . get ( gradientColor ) ; if ( newColor != null ) { gradientColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! gradientColor . startsWith ( \"<STR_LIT>\" ) && ! gradientColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = gradientColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( gradientColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) gradientColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } gradientDrawable . setColors ( gradientColors ) ; } } else if ( drawable instanceof InsetDrawable insetDrawable ) { replaceColor ( insetDrawable . getDrawable ( ) , colors ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { var color = getNinePatchDrawableColor ( ninePatchDrawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { ninePatchDrawable . setTintList ( ColorStateList . valueOf ( parseColor ( newColor ) ) ) ; } } else { if ( drawable == null ) return ; var color = getColor ( drawable ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } else { if ( ! sColor . startsWith ( \"<STR_LIT>\" ) && ! sColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { drawable . setColorFilter ( new PorterDuffColorFilter ( parseColor ( sColorSub + newColor ) , PorterDuff . Mode . SRC_IN ) ) ; } } } } } public static int getColor ( Drawable drawable ) { if ( drawable == null ) return <NUM_LIT> ; int color = <NUM_LIT> ; if ( drawable instanceof ColorDrawable colorDrawable ) { color = getColorDrawableColor ( colorDrawable ) ; } else if ( drawable instanceof ShapeDrawable shapeDrawable ) { color = getShapeDrawableColor ( shapeDrawable ) ; } else if ( drawable instanceof RippleDrawable rippleDrawable ) { color = getRippleDrawableColor ( rippleDrawable ) ; } else if ( drawable instanceof NinePatchDrawable ninePatchDrawable ) { color = getNinePatchDrawableColor ( ninePatchDrawable ) ; } else if ( drawable instanceof InsetDrawable insetDrawable ) { color = getInsetDrawableColor ( insetDrawable ) ; } return color ; } private static int getInsetDrawableColor ( InsetDrawable insetDrawable ) { var mDrawable = ( Drawable ) XposedHelpers . getObjectField ( insetDrawable , \"<STR_LIT>\" ) ; return getColor ( mDrawable ) ; } public static int getNinePatchDrawableColor ( NinePatchDrawable ninePatchDrawable ) { var state = ninePatchDrawable . getConstantState ( ) ; var ninePatch = ( NinePatch ) XposedHelpers . getObjectField ( state , \"<STR_LIT>\" ) ; var bitmap = ninePatch . getBitmap ( ) ; var corSalva = ninePatchs . get ( bitmap ) ; if ( corSalva != null ) return corSalva ; HashMap < Integer , Integer > contagemCores = new HashMap < > ( ) ; int corMaisFrequente = <NUM_LIT> ; int contagemMaxima = <NUM_LIT> ; for ( int x = <NUM_LIT> ; x < bitmap . getWidth ( ) ; x ++ ) { for ( int y = <NUM_LIT> ; y < bitmap . getHeight ( ) ; y ++ ) { int cor = bitmap . getPixel ( x , y ) ; int contagemAtual = contagemCores . getOrDefault ( cor , <NUM_LIT> ) + <NUM_LIT> ; contagemCores . put ( cor , contagemAtual ) ; if ( contagemAtual > contagemMaxima ) { corMaisFrequente = cor ; contagemMaxima = contagemAtual ; } } } ninePatchs . put ( bitmap , corMaisFrequente ) ; return corMaisFrequente ; } private static int getRippleDrawableColor ( RippleDrawable rippleDrawable ) { var state = rippleDrawable . getConstantState ( ) ; var rippleStateClass = XposedHelpers . findClass ( \"<STR_LIT>\" , loader1 ) ; try { return XposedHelpers . getIntField ( state , \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; return <NUM_LIT> ; } } public static int getColorDrawableColor ( ColorDrawable colorDrawable ) { return colorDrawable . getColor ( ) ;", "output": "} public static int getShapeDrawableColor ( ShapeDrawable shapeDrawable ) { return shapeDrawable . getPaint ( ) . getColor ( ) ; } }"}, {"input": "package de . robv . android . xposed . callbacks ; import de . robv . android . xposed . IXposedHookZygoteInit ; public interface IXUnhook < T > { T getCallback ( ) ; void unhook ( ) ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XposedBridge ; public class HookStater { public int appVersionCode ; public ClassLoader classLoader ; public HookStater ( int appVersionCode , ClassLoader classLoader ) { this . appVersionCode = appVersionCode ; this . classLoader = classLoader ; } public void startHook ( BaseHook baseHook ) { try { baseHook . startHook ( appVersionCode , classLoader ) ; } catch ( Throwable throwable ) { XposedBridge . log ( baseHook . getClass ( ) . getSimpleName ( ) + \"<STR_LIT>\" + throwable ) ;", "output": "} } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicBoolean ; class MessageThreadUtil < T > implements ThreadUtil < T > { @ Override public MainThreadCallback < T > getMainThreadProxy ( final MainThreadCallback < T > callback ) { return new MainThreadCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; final private Handler mMainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; static final int UPDATE_ITEM_COUNT = <NUM_LIT> ; static final int ADD_TILE = <NUM_LIT> ; static final int REMOVE_TILE = <NUM_LIT> ; @ Override public void updateItemCount ( int generation , int itemCount ) { sendMessage ( SyncQueueItem . obtainMessage ( UPDATE_ITEM_COUNT , generation , itemCount ) ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( ADD_TILE , generation , tile ) ) ; } @ Override public void removeTile ( int generation , int position ) { sendMessage ( SyncQueueItem . obtainMessage ( REMOVE_TILE , generation , position ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; mMainThreadHandler . post ( mMainThreadRunnable ) ; } private Runnable mMainThreadRunnable = new Runnable ( ) { @ Override public void run ( ) { SyncQueueItem msg = mQueue . next ( ) ; while ( msg != null ) { switch ( msg . what ) { case UPDATE_ITEM_COUNT : callback . updateItemCount ( msg . arg1 , msg . arg2 ) ; break ; case ADD_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . addTile ( msg . arg1 , tile ) ; break ; case REMOVE_TILE : callback . removeTile ( msg . arg1 , msg . arg2 ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } msg = mQueue . next ( ) ; } } } ; } ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public BackgroundCallback < T > getBackgroundProxy ( final BackgroundCallback < T > callback ) { return new BackgroundCallback < T > ( ) { final MessageQueue mQueue = new MessageQueue ( ) ; private final Executor mExecutor = android . os . AsyncTask . THREAD_POOL_EXECUTOR ; AtomicBoolean mBackgroundRunning = new AtomicBoolean ( false ) ; static final int REFRESH = <NUM_LIT> ; static final int UPDATE_RANGE = <NUM_LIT> ; static final int LOAD_TILE = <NUM_LIT> ; static final int RECYCLE_TILE = <NUM_LIT> ; @ Override public void refresh ( int generation ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( REFRESH , generation , null ) ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { sendMessageAtFrontOfQueue ( SyncQueueItem . obtainMessage ( UPDATE_RANGE , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint , null ) ) ; } @ Override public void loadTile ( int position , int scrollHint ) { sendMessage ( SyncQueueItem . obtainMessage ( LOAD_TILE , position , scrollHint ) ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { sendMessage ( SyncQueueItem . obtainMessage ( RECYCLE_TILE , <NUM_LIT> , tile ) ) ; } private void sendMessage ( SyncQueueItem msg ) { mQueue . sendMessage ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void sendMessageAtFrontOfQueue ( SyncQueueItem msg ) { mQueue . sendMessageAtFrontOfQueue ( msg ) ; maybeExecuteBackgroundRunnable ( ) ; } private void maybeExecuteBackgroundRunnable ( ) { if ( mBackgroundRunning . compareAndSet ( false , true ) ) { mExecutor . execute ( mBackgroundRunnable ) ; } } private Runnable mBackgroundRunnable = new Runnable ( ) { @ Override public void run ( ) { while ( true ) { SyncQueueItem msg = mQueue . next ( ) ; if ( msg == null ) { break ; } switch ( msg . what ) { case REFRESH : mQueue . removeMessages ( REFRESH ) ; callback . refresh ( msg . arg1 ) ; break ; case UPDATE_RANGE : mQueue . removeMessages ( UPDATE_RANGE ) ; mQueue . removeMessages ( LOAD_TILE ) ; callback . updateRange ( msg . arg1 , msg . arg2 , msg . arg3 , msg . arg4 , msg . arg5 ) ; break ; case LOAD_TILE : callback . loadTile ( msg . arg1 , msg . arg2 ) ; break ; case RECYCLE_TILE : @ SuppressWarnings ( \"<STR_LIT>\" ) TileList . Tile < T > tile = ( TileList . Tile < T > ) msg . data ; callback . recycleTile ( tile ) ; break ; default : Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + msg . what ) ; } } mBackgroundRunning . set ( false ) ; } } ; } ; } static class SyncQueueItem { private static SyncQueueItem sPool ; private static final Object sPoolLock = new Object ( ) ; SyncQueueItem next ; public int what ; public int arg1 ; public int arg2 ; public int arg3 ; public int arg4 ; public int arg5 ; public Object data ; void recycle ( ) { next = null ; what = arg1 = arg2 = arg3 = arg4 = arg5 = <NUM_LIT> ; data = null ; synchronized ( sPoolLock ) { if ( sPool != null ) { next = sPool ; } sPool = this ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 , int arg3 , int arg4 , int arg5 , Object data ) { synchronized ( sPoolLock ) { final SyncQueueItem item ; if ( sPool == null ) { item = new SyncQueueItem ( ) ; } else { item = sPool ; sPool = sPool . next ; item . next = null ; } item . what = what ; item . arg1 = arg1 ; item . arg2 = arg2 ; item . arg3 = arg3 ; item . arg4 = arg4 ; item . arg5 = arg5 ; item . data = data ; return item ; } } static SyncQueueItem obtainMessage ( int what , int arg1 , int arg2 ) { return obtainMessage ( what , arg1 , arg2 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , null ) ; } static SyncQueueItem obtainMessage ( int what , int arg1 , Object data ) { return obtainMessage ( what , arg1 , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , data ) ; } } static class MessageQueue { private SyncQueueItem mRoot ; private final Object mLock = new Object ( ) ; SyncQueueItem next ( ) { synchronized ( mLock ) { if ( mRoot == null ) { return null ; } final SyncQueueItem next = mRoot ; mRoot = mRoot . next ; return next ; } } void sendMessageAtFrontOfQueue ( SyncQueueItem item ) { synchronized ( mLock ) { item . next = mRoot ; mRoot = item ; } } void sendMessage ( SyncQueueItem item ) { synchronized ( mLock ) {", "output": "if ( mRoot == null ) { mRoot = item ; return ; } SyncQueueItem last = mRoot ; while ( last . next != null ) { last = last . next ; } last . next = item ; } } void removeMessages ( int what ) { synchronized ( mLock ) { while ( mRoot != null && mRoot . what == what ) { SyncQueueItem item = mRoot ; mRoot = mRoot . next ; item . recycle ( ) ; } if ( mRoot != null ) { SyncQueueItem prev = mRoot ; SyncQueueItem item = prev . next ; while ( item != null ) { SyncQueueItem next = item . next ; if ( item . what == what ) { prev . next = next ; item . recycle ( ) ; } else { prev = item ; } item = next ; } } } } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . DialogInterface ; public class VoidDialogInterfaceOnClickListener implements DialogInterface . OnClickListener { @ Override public void onClick ( DialogInterface dialog , int which ) { }", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . SharedPreferences ; public class XConfig { public static final String PREF_NAME = \"<STR_LIT>\" ; private final SharedPreferences sp ; protected XConfig ( SharedPreferences sharedPreferences ) { this . sp = sharedPreferences ; } public void setHookPictureSelectEnable ( boolean enable ) { sp . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getHookPictureSelectIsEnable ( ) { return sp . getBoolean ( \"<STR_LIT>\" , true ) ;", "output": "} }"}, {"input": "package external . org . apache . commons . lang3 ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . regex . Pattern ; public class Validate { private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_MATCHES_PATTERN_EX = \"<STR_LIT>\" ; private static final String DEFAULT_IS_NULL_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_IS_TRUE_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_VALID_STATE_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = \"<STR_LIT>\" ; private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = \"<STR_LIT>\" ; public Validate ( ) { super ( ) ; } public static void isTrue ( boolean expression , String message , long value ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Long . valueOf ( value ) ) ) ; } } public static void isTrue ( boolean expression , String message , double value ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Double . valueOf ( value ) ) ) ; } } public static void isTrue ( boolean expression , String message , Object ... values ) { if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isTrue ( boolean expression ) { if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } } public static < T > T notNull ( T object ) { return notNull ( object , DEFAULT_IS_NULL_EX_MESSAGE ) ; } public static < T > T notNull ( T object , String message , Object ... values ) { if ( object == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } return object ; } public static < T > T [ ] notEmpty ( T [ ] array , String message , Object ... values ) { if ( array == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( array . length == <NUM_LIT> ) {", "output": "throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return array ; } public static < T > T [ ] notEmpty ( T [ ] array ) { return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE ) ; } public static < T extends Collection < ? > > T notEmpty ( T collection , String message , Object ... values ) { if ( collection == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( collection . isEmpty ( ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return collection ; } public static < T extends Collection < ? > > T notEmpty ( T collection ) { return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE ) ; } public static < T extends Map < ? , ? > > T notEmpty ( T map , String message , Object ... values ) { if ( map == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( map . isEmpty ( ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return map ; } public static < T extends Map < ? , ? > > T notEmpty ( T map ) { return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE ) ; } public static < T extends CharSequence > T notEmpty ( T chars , String message , Object ... values ) { if ( chars == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( chars . length ( ) == <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T notEmpty ( T chars ) { return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE ) ; } public static < T extends CharSequence > T notBlank ( T chars , String message , Object ... values ) { if ( chars == null ) { throw new NullPointerException ( String . format ( message , values ) ) ; } if ( StringUtils . isBlank ( chars ) ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T notBlank ( T chars ) { return notBlank ( chars , DEFAULT_NOT_BLANK_EX_MESSAGE ) ; } public static < T > T [ ] noNullElements ( T [ ] array , String message , Object ... values ) { Validate . notNull ( array ) ; for ( int i = <NUM_LIT> ; i < array . length ; i ++ ) { if ( array [ i ] == null ) { Object [ ] values2 = ArrayUtils . add ( values , Integer . valueOf ( i ) ) ; throw new IllegalArgumentException ( String . format ( message , values2 ) ) ; } } return array ; } public static < T > T [ ] noNullElements ( T [ ] array ) { return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE ) ; } public static < T extends Iterable < ? > > T noNullElements ( T iterable , String message , Object ... values ) { Validate . notNull ( iterable ) ; int i = <NUM_LIT> ; for ( Iterator < ? > it = iterable . iterator ( ) ; it . hasNext ( ) ; i ++ ) { if ( it . next ( ) == null ) { Object [ ] values2 = ArrayUtils . addAll ( values , Integer . valueOf ( i ) ) ; throw new IllegalArgumentException ( String . format ( message , values2 ) ) ; } } return iterable ; } public static < T extends Iterable < ? > > T noNullElements ( T iterable ) { return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE ) ; } public static < T > T [ ] validIndex ( T [ ] array , int index , String message , Object ... values ) { Validate . notNull ( array ) ; if ( index < <NUM_LIT> || index >= array . length ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return array ; } public static < T > T [ ] validIndex ( T [ ] array , int index ) { return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static < T extends Collection < ? > > T validIndex ( T collection , int index , String message , Object ... values ) { Validate . notNull ( collection ) ; if ( index < <NUM_LIT> || index >= collection . size ( ) ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return collection ; } public static < T extends Collection < ? > > T validIndex ( T collection , int index ) { return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static < T extends CharSequence > T validIndex ( T chars , int index , String message , Object ... values ) { Validate . notNull ( chars ) ; if ( index < <NUM_LIT> || index >= chars . length ( ) ) { throw new IndexOutOfBoundsException ( String . format ( message , values ) ) ; } return chars ; } public static < T extends CharSequence > T validIndex ( T chars , int index ) { return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE , Integer . valueOf ( index ) ) ; } public static void validState ( boolean expression ) { if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } } public static void validState ( boolean expression , String message , Object ... values ) { if ( expression == false ) { throw new IllegalStateException ( String . format ( message , values ) ) ; } } public static void matchesPattern ( CharSequence input , String pattern ) { if ( Pattern . matches ( pattern , input ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_MATCHES_PATTERN_EX , input , pattern ) ) ; } } public static void matchesPattern ( CharSequence input , String pattern , String message , Object ... values ) { if ( Pattern . matches ( pattern , input ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static < T > void inclusiveBetween ( T start , T end , Comparable < T > value ) { if ( value . compareTo ( start ) < <NUM_LIT> || value . compareTo ( end ) > <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE , value , start , end ) ) ; } } public static < T > void inclusiveBetween ( T start , T end , Comparable < T > value , String message , Object ... values ) { if ( value . compareTo ( start ) < <NUM_LIT> || value . compareTo ( end ) > <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static < T > void exclusiveBetween ( T start , T end , Comparable < T > value ) { if ( value . compareTo ( start ) <= <NUM_LIT> || value . compareTo ( end ) >= <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE , value , start , end ) ) ; } } public static < T > void exclusiveBetween ( T start , T end , Comparable < T > value , String message , Object ... values ) { if ( value . compareTo ( start ) <= <NUM_LIT> || value . compareTo ( end ) >= <NUM_LIT> ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isInstanceOf ( Class < ? > type , Object obj ) { if ( type . isInstance ( obj ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_IS_INSTANCE_OF_EX_MESSAGE , type . getName ( ) , obj == null ? \"<STR_LIT>\" : obj . getClass ( ) . getName ( ) ) ) ; } } public static void isInstanceOf ( Class < ? > type , Object obj , String message , Object ... values ) { if ( type . isInstance ( obj ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } public static void isAssignableFrom ( Class < ? > superType , Class < ? > type ) { if ( superType . isAssignableFrom ( type ) == false ) { throw new IllegalArgumentException ( String . format ( DEFAULT_IS_ASSIGNABLE_EX_MESSAGE , type == null ? \"<STR_LIT>\" : type . getName ( ) , superType . getName ( ) ) ) ; } } public static void isAssignableFrom ( Class < ? > superType , Class < ? > type , String message , Object ... values ) { if ( superType . isAssignableFrom ( type ) == false ) { throw new IllegalArgumentException ( String . format ( message , values ) ) ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . os . Handler ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class Tasker extends Feature { private static FMessageWpp fMessage ; private static boolean taskerEnabled ; public Tasker ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { taskerEnabled = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( ! taskerEnabled ) return ; hookReceiveMessage ( ) ; registerSenderMessage ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private void registerSenderMessage ( ) { IntentFilter filter = new IntentFilter ( \"<STR_LIT>\" ) ; ContextCompat . registerReceiver ( Utils . getApplication ( ) , new SenderMessageBroadcastReceiver ( ) , filter , ContextCompat . RECEIVER_EXPORTED ) ; } public synchronized static void sendTaskerEvent ( String name , String number , String event ) { if ( ! taskerEnabled ) return ; Intent intent = new Intent ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , name ) ; intent . putExtra ( \"<STR_LIT>\" , number ) ; intent . putExtra ( \"<STR_LIT>\" , event ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } public void hookReceiveMessage ( ) throws Throwable { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; XposedBridge . hookMethod ( method2 , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; } } ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args [ <NUM_LIT> ] == \"<STR_LIT>\" || param . args [ <NUM_LIT> ] == null || fMessage == null ) return ; var userJid = fMessage . getKey ( ) . remoteJid ; var rawJid = WppCore . getRawString ( userJid ) ; var name = WppCore . getContactName ( userJid ) ; var number = WppCore . stripJID ( rawJid ) ; var msg = fMessage . getMessageStr ( ) ; if ( TextUtils . isEmpty ( msg ) || TextUtils . isEmpty ( number ) || rawJid . startsWith ( \"<STR_LIT>\" ) ) return ; new Handler ( Utils . getApplication ( ) . getMainLooper ( ) ) . post ( ( ) -> { Intent intent = new Intent ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , number ) ; intent . putExtra ( \"<STR_LIT>\" , name ) ; intent . putExtra ( \"<STR_LIT>\" , msg ) ; Utils . getApplication ( ) . sendBroadcast ( intent ) ; } ) ; } } ) ; } public static class SenderMessageBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { XposedBridge . log ( \"<STR_LIT>\" ) ; var number = intent . getStringExtra ( \"<STR_LIT>\" ) ; if ( number == null ) {", "output": "number = String . valueOf ( intent . getLongExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ) ; number = Objects . equals ( number , \"<STR_LIT>\" ) ? null : number ; } var message = intent . getStringExtra ( \"<STR_LIT>\" ) ; if ( number == null || message == null ) return ; number = number . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; WppCore . sendMessage ( number , message ) ; } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; public interface ServerInfo { int PORT_CONTROLLER = <NUM_LIT> ; int PORT_USB = <NUM_LIT> ; int PORT_WIFI = <NUM_LIT> ; int \u9177\u5b89\u98de\u673a\u676f = <NUM_LIT> ; int \u6668\u949f\u9171\u64cd\u98de\u673a\u676f = <NUM_LIT> ;", "output": "}"}, {"input": "package com . simon . harmonichackernews . network ; import android . content . Context ; import android . widget . ImageView ; import androidx . core . content . ContextCompat ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . utils . Utils ; import com . squareup . picasso . Picasso ; import java . util . Objects ; public class FaviconLoader { public static void loadFavicon ( String url , ImageView into , Context ctx , String faviconProvider ) { try { String host = Utils . getDomainName ( url ) ; int faviconSize = Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ; Picasso . get ( ) . load ( getFaviconUrl ( host , faviconProvider ) ) . resize ( faviconSize , faviconSize ) . onlyScaleDown ( ) . placeholder ( Objects . requireNonNull ( ContextCompat . getDrawable ( ctx , R . drawable . ic_action_web ) ) ) . into ( into ) ; } catch ( Exception ignored ) { } ; } private static String getFaviconUrl ( String host , String faviconProvider ) { switch ( faviconProvider ) { case \"<STR_LIT>\" : return \"<STR_LIT>\" + host ; case \"<STR_LIT>\" : return \"<STR_LIT>\" + host + \"<STR_LIT>\" ; case \"<STR_LIT>\" : return \"<STR_LIT>\" + host + \"<STR_LIT>\" ;", "output": "default : return \"<STR_LIT>\" + host + \"<STR_LIT>\" ; } } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . graphics . Canvas ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . fluidrecyclerview . R ; class ItemTouchUIUtilImpl implements ItemTouchUIUtil { static final ItemTouchUIUtil INSTANCE = new ItemTouchUIUtilImpl ( ) ;", "output": "@ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( isCurrentlyActive ) { Object originalElevation = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( originalElevation == null ) { originalElevation = ViewCompat . getElevation ( view ) ; float newElevation = <NUM_LIT> + findMaxElevation ( recyclerView , view ) ; ViewCompat . setElevation ( view , newElevation ) ; view . setTag ( R . id . item_touch_helper_previous_elevation , originalElevation ) ; } } } view . setTranslationX ( dX ) ; view . setTranslationY ( dY ) ; } private static float findMaxElevation ( RecyclerView recyclerView , View itemView ) { final int childCount = recyclerView . getChildCount ( ) ; float max = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = recyclerView . getChildAt ( i ) ; if ( child == itemView ) { continue ; } final float elevation = ViewCompat . getElevation ( child ) ; if ( elevation > max ) { max = elevation ; } } return max ; } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView recyclerView , @ NonNull View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) { } @ Override public void clearView ( @ NonNull View view ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { final Object tag = view . getTag ( R . id . item_touch_helper_previous_elevation ) ; if ( tag instanceof Float ) { ViewCompat . setElevation ( view , ( Float ) tag ) ; } view . setTag ( R . id . item_touch_helper_previous_elevation , null ) ; } view . setTranslationX ( <NUM_LIT> ) ; view . setTranslationY ( <NUM_LIT> ) ; } @ Override public void onSelected ( @ NonNull View view ) { } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . Closeable ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . net . BindException ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . LinkedBlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferredBytesInfo ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferJob ; import top . weixiansen574 . hybridfilexfer . core . threads . ReceiveThread ; import top . weixiansen574 . hybridfilexfer . core . threads . SendThread ; import top . weixiansen574 . hybridfilexfer . core . threads . TransferThread ; public class FileTransferServer implements ServerInfo , TransferThread . OnExceptionListener { JobPublisher jobPublisher ; Socket socket ; DataInputStream dis ; DataOutputStream dos ; SendThread usbSendThread ; ReceiveThread usbReceiveThread ; SendThread wifiSendThread ; ReceiveThread wifiReceiveThread ; public final BlockingDeque < FileTransferEvent > fileTransferEvents ; ServerSocket controllerSocket ; ServerSocket usbServerSocket ; ServerSocket wifiServerSocket ; public FileTransferServer ( ) { fileTransferEvents = new LinkedBlockingDeque < > ( ) ; } public void startServer ( ) throws IOException { this . jobPublisher = new JobPublisher ( ) ; controllerSocket = new ServerSocket ( ServerInfo . PORT_CONTROLLER ) ; socket = controllerSocket . accept ( ) ; this . dis = new DataInputStream ( socket . getInputStream ( ) ) ; this . dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; short identifier = dis . readShort ( ) ; switch ( identifier ) { case ControllerIdentifiers . GET_WLAN_ADDRESS : handleGetWifiAddress ( ) ; waitPCConnect ( ) ; break ; } } private void handleGetWifiAddress ( ) throws IOException { try { Enumeration < NetworkInterface > networkInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( networkInterfaces . hasMoreElements ( ) ) { NetworkInterface networkInterface = networkInterfaces . nextElement ( ) ; Enumeration < InetAddress > inetAddresses = networkInterface . getInetAddresses ( ) ; while ( inetAddresses . hasMoreElements ( ) ) { InetAddress inetAddress = inetAddresses . nextElement ( ) ; if ( ! inetAddress . isLoopbackAddress ( ) && inetAddress instanceof Inet4Address ) { String interfaceName = networkInterface . getName ( ) ; if ( interfaceName . contains ( \"<STR_LIT>\" ) ) { System . out . println ( \"<STR_LIT>\" + networkInterface . getName ( ) ) ; System . out . println ( \"<STR_LIT>\" + inetAddress . getHostAddress ( ) ) ; dos . write ( inetAddress . getAddress ( ) ) ; return ; } } } } dos . write ( new byte [ <NUM_LIT> ] ) ; } catch ( SocketException ex ) { ex . printStackTrace ( ) ; } } private void waitPCConnect ( ) throws IOException { usbServerSocket = new ServerSocket ( ServerInfo . PORT_USB ) ; wifiServerSocket = new ServerSocket ( ServerInfo . PORT_WIFI ) ; Socket usbSocket = usbServerSocket . accept ( ) ; System . out . println ( \"<STR_LIT>\" ) ; Socket wifiSocket = wifiServerSocket . accept ( ) ; System . out . println ( \"<STR_LIT>\" ) ; usbSendThread = new SendThread ( fileTransferEvents , SendThread . DEVICE_USB , jobPublisher , usbSocket . getOutputStream ( ) ) ; usbSendThread . setOnExceptionListener ( this ) ; usbSendThread . setName ( \"<STR_LIT>\" ) ; usbSendThread . start ( ) ; usbReceiveThread = new ReceiveThread ( fileTransferEvents , ReceiveThread . DEVICE_USB , usbSocket . getInputStream ( ) ) ; usbReceiveThread . setOnExceptionListener ( this ) ; usbReceiveThread . setName ( \"<STR_LIT>\" ) ; usbReceiveThread . start ( ) ; wifiSendThread = new SendThread ( fileTransferEvents , SendThread . DEVICE_WIFI , jobPublisher , wifiSocket . getOutputStream ( ) ) ;", "output": "wifiSendThread . setOnExceptionListener ( this ) ; wifiSendThread . setName ( \"<STR_LIT>\" ) ; wifiSendThread . start ( ) ; wifiReceiveThread = new ReceiveThread ( fileTransferEvents , ReceiveThread . DEVICE_WIFI , wifiSocket . getInputStream ( ) ) ; wifiReceiveThread . setName ( \"<STR_LIT>\" ) ; wifiReceiveThread . setOnExceptionListener ( this ) ; wifiReceiveThread . start ( ) ; } public ArrayList < RemoteFile > listClientFiles ( String path ) throws IOException { dos . writeShort ( ControllerIdentifiers . LIST_FILES ) ; dos . writeUTF ( path ) ; int listSize = dis . readInt ( ) ; ArrayList < RemoteFile > remoteFiles = new ArrayList < > ( listSize ) ; for ( int i = <NUM_LIT> ; i < listSize ; i ++ ) { RemoteFile remoteFile = new RemoteFile ( dis . readUTF ( ) , dis . readUTF ( ) , dis . readLong ( ) , dis . readLong ( ) , dis . readBoolean ( ) ) ; remoteFiles . add ( remoteFile ) ; } return remoteFiles ; } public void transferToMe ( List < String > files , String remoteDir , String localDir ) throws IOException { dos . writeShort ( ControllerIdentifiers . TRANSPORT_FILES ) ; dos . writeUTF ( localDir ) ; dos . writeUTF ( remoteDir ) ; dos . writeInt ( files . size ( ) ) ; for ( String file : files ) { dos . writeUTF ( file ) ; } } public void transferToClient ( List < File > files , File localDir , String remoteDir ) { jobPublisher . addJob ( new TransferJob ( localDir , remoteDir , files ) ) ; } public FileTransferEvent getNextTransferEvent ( ) throws InterruptedException { return fileTransferEvents . take ( ) ; } public TransferredBytesInfo getTransferredBytesInfo ( ) { return new TransferredBytesInfo ( usbReceiveThread . getAndResetTransferredBytes ( ) , usbSendThread . getAndResetTransferredBytes ( ) , wifiReceiveThread . getAndResetTransferredBytes ( ) , wifiSendThread . getAndResetTransferredBytes ( ) ) ; } public void stopServer ( ) { if ( socket != null ) { try { sendShutdownToClientAndClose ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( usbSendThread != null ) { usbSendThread . shutdown ( ) ; } if ( wifiSendThread != null ) { wifiSendThread . shutdown ( ) ; } if ( usbSendThread != null ) { joinNoException ( usbSendThread ) ; System . out . println ( \"<STR_LIT>\" ) ; } if ( wifiSendThread != null ) { joinNoException ( wifiReceiveThread ) ; System . out . println ( \"<STR_LIT>\" ) ; } if ( usbReceiveThread != null ) { joinNoException ( usbReceiveThread ) ; System . out . println ( \"<STR_LIT>\" ) ; } if ( wifiReceiveThread != null ) { joinNoException ( wifiReceiveThread ) ; System . out . println ( \"<STR_LIT>\" ) ; } if ( controllerSocket != null ) { closeNoException ( controllerSocket ) ; } if ( usbServerSocket != null ) { closeNoException ( usbServerSocket ) ; } if ( wifiServerSocket != null ) { closeNoException ( wifiServerSocket ) ; } System . out . println ( \"<STR_LIT>\" ) ; } private void sendShutdownToClientAndClose ( ) throws IOException { dos . writeShort ( ControllerIdentifiers . SHUTDOWN ) ; dos . close ( ) ; } private void closeNoException ( Closeable closeable ) { try { closeable . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void joinNoException ( Thread thread ) { try { thread . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } @ Override public void onException ( Exception e ) { System . exit ( - <NUM_LIT> ) ; } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import android . os . IInterface ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( \"<STR_LIT>\" ) public interface IPackageManager { String SERVICE = \"<STR_LIT>\" ;", "output": "@ Method ( value = \"<STR_LIT>\" , type = Method . STATIC ) IInterface asInterface ( android . os . IBinder obj ) ; }"}, {"input": "package top . weixiansen574 . hybridfilexfer . async ; import static top . weixiansen574 . hybridfilexfer . Utils . sortFiles ; import java . util . List ; import top . weixiansen574 . async . BackstageTask ; import top . weixiansen574 . hybridfilexfer . IIServiceFileSelectAdapter ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class CDTask extends BackstageTask < CDTask . EventHandle > { IIServiceFileSelectAdapter adapter ; String path ; public CDTask ( EventHandle handle , IIServiceFileSelectAdapter adapter , String path ) { super ( handle ) ; this . adapter = adapter ; this . path = path ; } @ Override protected void onStart ( EventHandle eventHandler ) throws Throwable {", "output": "List < ParcelableRemoteFile > files = adapter . listTargetFiles ( path ) ; if ( files == null ) { eventHandler . onPermissionDenied ( ) ; } else { sortFiles ( files ) ; eventHandler . onSuccess ( files , path ) ; } } public interface EventHandle extends BaseEventHandler { void onSuccess ( List < ParcelableRemoteFile > files , String path ) ; void onPermissionDenied ( ) ; } }"}, {"input": "package com . reactnative . bottomsheet ; import static com . reactnative . bottomsheet . BottomSheetState . COLLAPSED ; import static com . reactnative . bottomsheet . BottomSheetState . DRAGGING ; import static com . reactnative . bottomsheet . BottomSheetState . EXPANDED ; import static com . reactnative . bottomsheet . BottomSheetState . HIDDEN ; import static com . reactnative . bottomsheet . BottomSheetState . SETTLING ; import static java . lang . Math . max ; import android . annotation . SuppressLint ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewTreeObserver ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . core . math . MathUtils ; import androidx . core . util . Pools ; import androidx . core . view . NestedScrollingParent ; import androidx . core . view . NestedScrollingParentHelper ; import androidx . core . view . ViewCompat ; import androidx . customview . widget . ViewDragHelper ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . ReactPointerEventsView ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . events . Event ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . uimanager . events . NativeGestureUtil ; import com . facebook . react . views . view . ReactViewGroup ; import java . lang . ref . WeakReference ; @ SuppressLint ( \"<STR_LIT>\" ) public class BottomSheet extends ReactViewGroup implements NestedScrollingParent , ReactPointerEventsView { private static final String TAG = \"<STR_LIT>\" ; private final ReactContext reactContext ; public BottomSheet ( ThemedReactContext reactContext ) { super ( reactContext ) ; this . reactContext = reactContext ; this . nestedScrollingParentHelper = new NestedScrollingParentHelper ( this ) ; } private BottomSheetState state = COLLAPSED ; private SettleRunnable settleRunnable = null ; private boolean draggable ; private int peekHeight ; private int expandedOffset ; private int collapsedOffset ; private View contentView ; @ Nullable private WeakReference < View > nestedScrollingChildRef ; private boolean touchingScrollingChild ; @ Nullable private ViewDragHelper viewDragHelper ; private final NestedScrollingParentHelper nestedScrollingParentHelper ; private boolean ignoreEvents ; private int lastNestedScrollDy ; private VelocityTracker velocityTracker ; private int activePointerId ; private int initialY ; private int contentHeight = - <NUM_LIT> ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { if ( viewDragHelper == null ) { viewDragHelper = ViewDragHelper . create ( this , dragCallback ) ; } viewDragHelper . abort ( ) ; if ( settleRunnable != null && settleRunnable . isPosted ) { settleRunnable . run ( ) ; } layoutChild ( ) ; } private void layoutChild ( ) { int count = getChildCount ( ) ; if ( count == <NUM_LIT> ) { View child = getChildAt ( <NUM_LIT> ) ; if ( contentView == null ) { contentView = child ; } contentHeight = contentView . getHeight ( ) ; calculateOffset ( ) ; getViewTreeObserver ( ) . removeOnPreDrawListener ( preDrawListener ) ; int top = contentView . getTop ( ) ; if ( state == COLLAPSED ) { child . offsetTopAndBottom ( collapsedOffset - top ) ; } else if ( state == EXPANDED ) { child . offsetTopAndBottom ( expandedOffset - top ) ; } else if ( state == HIDDEN ) { child . offsetTopAndBottom ( getHeight ( ) - top ) ; } getViewTreeObserver ( ) . addOnPreDrawListener ( preDrawListener ) ; dispatchOnSlide ( child . getTop ( ) ) ; } } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; getViewTreeObserver ( ) . removeOnPreDrawListener ( preDrawListener ) ; } ViewTreeObserver . OnPreDrawListener preDrawListener = new ViewTreeObserver . OnPreDrawListener ( ) { @ Override public boolean onPreDraw ( ) { if ( contentHeight != - <NUM_LIT> && contentHeight != contentView . getHeight ( ) ) { layoutChild ( ) ; } return true ; } } ; private void calculateOffset ( ) { expandedOffset = Math . max ( <NUM_LIT> , getHeight ( ) - contentView . getHeight ( ) ) ; collapsedOffset = Math . max ( getHeight ( ) - peekHeight , expandedOffset ) ; } public void setPeekHeight ( int peekHeight ) { this . peekHeight = max ( peekHeight , <NUM_LIT> ) ; if ( contentView != null ) { calculateOffset ( ) ; if ( state == COLLAPSED ) { settleToState ( contentView , state ) ; } } } public void setDraggable ( boolean draggable ) { this . draggable = draggable ; } public void setState ( BottomSheetState state ) { if ( state == this . state ) { return ; } if ( contentView == null ) { if ( state == COLLAPSED || state == EXPANDED || state == HIDDEN ) { this . state = state ; } return ; } settleToState ( contentView , state ) ; } @ Nullable @ VisibleForTesting View findScrollingChild ( View view ) { if ( ViewCompat . isNestedScrollingEnabled ( view ) ) { if ( ! view . canScrollHorizontally ( <NUM_LIT> ) && ! view . canScrollHorizontally ( - <NUM_LIT> ) && ( view . canScrollVertically ( - <NUM_LIT> ) || view . canScrollVertically ( <NUM_LIT> ) ) ) { return view ; } } if ( view instanceof ViewGroup ) { ViewGroup group = ( ViewGroup ) view ; for ( int i = <NUM_LIT> , count = group . getChildCount ( ) ; i < count ; i ++ ) { View child = group . getChildAt ( i ) ; if ( child . getVisibility ( ) == VISIBLE ) { View scrollingChild = findScrollingChild ( child ) ; if ( scrollingChild != null ) { return scrollingChild ; } } } } return null ; } public PointerEvents getPointerEvents ( ) { return PointerEvents . BOX_NONE ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { if ( shouldInterceptTouchEvent ( event ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , event ) ; return true ; } return false ; } private boolean shouldInterceptTouchEvent ( MotionEvent event ) { if ( ! draggable ) { return false ; } int action = event . getActionMasked ( ) ; if ( action == MotionEvent . ACTION_DOWN ) { reset ( ) ; } if ( velocityTracker == null ) { velocityTracker = VelocityTracker . obtain ( ) ; } velocityTracker . addMovement ( event ) ; switch ( action ) { case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : touchingScrollingChild = false ; activePointerId = MotionEvent . INVALID_POINTER_ID ; if ( ignoreEvents ) { ignoreEvents = false ; return false ; } break ; case MotionEvent . ACTION_DOWN : nestedScrollingChildRef = new WeakReference < > ( findScrollingChild ( contentView ) ) ; int initialX = ( int ) event . getX ( ) ; initialY = ( int ) event . getY ( ) ; if ( state != SETTLING ) { View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ;", "output": "if ( scroll != null && isPointInChildBounds ( scroll , initialX , initialY ) ) { activePointerId = event . getPointerId ( event . getActionIndex ( ) ) ; touchingScrollingChild = true ; } } ignoreEvents = activePointerId == MotionEvent . INVALID_POINTER_ID && ! isPointInChildBounds ( contentView , initialX , initialY ) ; break ; default : } if ( ! ignoreEvents && viewDragHelper != null && viewDragHelper . shouldInterceptTouchEvent ( event ) ) { return true ; } View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; return action == MotionEvent . ACTION_MOVE && scroll != null && ! ignoreEvents && state != DRAGGING && ! isPointInChildBounds ( scroll , ( int ) event . getX ( ) , ( int ) event . getY ( ) ) && viewDragHelper != null && Math . abs ( initialY - event . getY ( ) ) > viewDragHelper . getTouchSlop ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { if ( ! draggable ) { return false ; } int action = event . getActionMasked ( ) ; if ( state == DRAGGING && action == MotionEvent . ACTION_DOWN ) { return true ; } if ( viewDragHelper != null ) { viewDragHelper . processTouchEvent ( event ) ; } if ( action == MotionEvent . ACTION_DOWN ) { reset ( ) ; } if ( velocityTracker == null ) { velocityTracker = VelocityTracker . obtain ( ) ; } velocityTracker . addMovement ( event ) ; if ( viewDragHelper != null && action == MotionEvent . ACTION_MOVE && ! ignoreEvents ) { if ( Math . abs ( initialY - event . getY ( ) ) > viewDragHelper . getTouchSlop ( ) ) { viewDragHelper . captureChildView ( contentView , event . getPointerId ( event . getActionIndex ( ) ) ) ; } } return ! ignoreEvents ; } @ Override public boolean onStartNestedScroll ( @ NonNull View child , @ NonNull View target , int nestedScrollAxes ) { return ( nestedScrollAxes & ViewCompat . SCROLL_AXIS_VERTICAL ) != <NUM_LIT> ; } @ Override public void onNestedScrollAccepted ( @ NonNull View child , @ NonNull View target , int axes ) { lastNestedScrollDy = <NUM_LIT> ; nestedScrollingParentHelper . onNestedScrollAccepted ( child , target , axes ) ; } @ Override public void onNestedPreScroll ( @ NonNull View target , int dx , int dy , @ NonNull int [ ] consumed ) { View scrollingChild = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; if ( target != scrollingChild ) { return ; } View child = contentView ; int currentTop = child . getTop ( ) ; int newTop = currentTop - dy ; if ( dy > <NUM_LIT> ) { if ( newTop < expandedOffset ) { consumed [ <NUM_LIT> ] = currentTop - expandedOffset ; ViewCompat . offsetTopAndBottom ( child , - consumed [ <NUM_LIT> ] ) ; setStateInternal ( EXPANDED ) ; } else { consumed [ <NUM_LIT> ] = dy ; ViewCompat . offsetTopAndBottom ( child , - dy ) ; setStateInternal ( DRAGGING ) ; } } else if ( dy < <NUM_LIT> ) { if ( ! target . canScrollVertically ( - <NUM_LIT> ) ) { if ( newTop <= collapsedOffset ) { consumed [ <NUM_LIT> ] = dy ; ViewCompat . offsetTopAndBottom ( child , - dy ) ; setStateInternal ( DRAGGING ) ; } else { consumed [ <NUM_LIT> ] = currentTop - collapsedOffset ; ViewCompat . offsetTopAndBottom ( child , - consumed [ <NUM_LIT> ] ) ; setStateInternal ( COLLAPSED ) ; } } } if ( currentTop != child . getTop ( ) ) { dispatchOnSlide ( child . getTop ( ) ) ; } lastNestedScrollDy = dy ; } @ Override public int getNestedScrollAxes ( ) { return nestedScrollingParentHelper . getNestedScrollAxes ( ) ; } @ Override public void onStopNestedScroll ( @ NonNull View target ) { nestedScrollingParentHelper . onStopNestedScroll ( target ) ; View child = contentView ; if ( child . getTop ( ) == expandedOffset ) { setStateInternal ( EXPANDED ) ; return ; } if ( nestedScrollingChildRef == null || target != nestedScrollingChildRef . get ( ) ) { return ; } int top ; BottomSheetState targetState ; if ( lastNestedScrollDy > <NUM_LIT> ) { top = expandedOffset ; targetState = EXPANDED ; } else if ( lastNestedScrollDy == <NUM_LIT> ) { int currentTop = child . getTop ( ) ; if ( Math . abs ( currentTop - collapsedOffset ) < Math . abs ( currentTop - expandedOffset ) ) { top = collapsedOffset ; targetState = COLLAPSED ; } else { top = expandedOffset ; targetState = EXPANDED ; } } else { top = collapsedOffset ; targetState = COLLAPSED ; } startSettlingAnimation ( child , targetState , top , false ) ; } @ Override public void onNestedScroll ( @ NonNull View target , int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed ) { } @ Override public boolean onNestedPreFling ( @ NonNull View target , float velocityX , float velocityY ) { if ( nestedScrollingChildRef != null ) { return target == nestedScrollingChildRef . get ( ) && ( state != EXPANDED ) ; } else { return false ; } } @ Override public boolean onNestedFling ( @ NonNull View target , float velocityX , float velocityY , boolean consumed ) { return false ; } private void reset ( ) { activePointerId = ViewDragHelper . INVALID_POINTER ; if ( velocityTracker != null ) { velocityTracker . recycle ( ) ; velocityTracker = null ; } } private static final Pools . Pool < Rect > sRectPool = new Pools . SynchronizedPool < > ( <NUM_LIT> ) ; private static Rect acquireTempRect ( ) { Rect rect = sRectPool . acquire ( ) ; if ( rect == null ) { rect = new Rect ( ) ; } return rect ; } private static void releaseTempRect ( @ NonNull Rect rect ) { rect . setEmpty ( ) ; sRectPool . release ( rect ) ; } public boolean isPointInChildBounds ( @ NonNull View child , int x , int y ) { final Rect r = acquireTempRect ( ) ; child . getDrawingRect ( r ) ; offsetDescendantRectToMyCoords ( child , r ) ; try { return r . contains ( x , y ) ; } finally { releaseTempRect ( r ) ; } } private final ViewDragHelper . Callback dragCallback = new ViewDragHelper . Callback ( ) { @ Override public boolean tryCaptureView ( @ NonNull View child , int pointerId ) { if ( state == DRAGGING ) { return false ; } if ( touchingScrollingChild ) { return false ; } if ( state == EXPANDED && activePointerId == pointerId ) { View scroll = nestedScrollingChildRef != null ? nestedScrollingChildRef . get ( ) : null ; if ( scroll != null && scroll . canScrollVertically ( - <NUM_LIT> ) ) { return false ; } } return contentView == child ; } @ Override public void onViewPositionChanged ( @ NonNull View changedView , int left , int top , int dx , int dy ) { dispatchOnSlide ( top ) ; } @ Override public void onViewDragStateChanged ( int state ) { if ( state == ViewDragHelper . STATE_DRAGGING ) { setStateInternal ( DRAGGING ) ; } } @ Override public void onViewReleased ( @ NonNull View releasedChild , float xvel , float yvel ) { int top ; BottomSheetState targetState ; if ( yvel < <NUM_LIT> ) { top = expandedOffset ; targetState = EXPANDED ; } else if ( yvel == <NUM_LIT> || Math . abs ( xvel ) > Math . abs ( yvel ) ) { int currentTop = releasedChild . getTop ( ) ; if ( Math . abs ( currentTop - collapsedOffset ) < Math . abs ( currentTop - expandedOffset ) ) { top = collapsedOffset ; targetState = COLLAPSED ; } else { top = expandedOffset ; targetState = EXPANDED ; } } else { top = collapsedOffset ; targetState = COLLAPSED ; } startSettlingAnimation ( releasedChild , targetState , top , true ) ; } @ Override public int clampViewPositionVertical ( @ NonNull View child , int top , int dy ) { return MathUtils . clamp ( top , expandedOffset , collapsedOffset ) ; } @ Override public int clampViewPositionHorizontal ( @ NonNull View child , int left , int dx ) { return child . getLeft ( ) ; } @ Override public int getViewVerticalDragRange ( @ NonNull View child ) { return collapsedOffset ; } } ; void dispatchOnSlide ( int top ) { if ( contentView != null ) { sentEvent ( new OffsetChangedEvent ( UIManagerHelper . getSurfaceId ( reactContext ) , getId ( ) , top , expandedOffset , collapsedOffset ) ) ; } } void settleToState ( @ NonNull View child , BottomSheetState state ) { int top ; if ( state == COLLAPSED ) { top = collapsedOffset ; } else if ( state == EXPANDED ) { top = expandedOffset ; } else if ( state == HIDDEN ) { top = getHeight ( ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + state ) ; } startSettlingAnimation ( child , state , top , false ) ; } void startSettlingAnimation ( View child , BottomSheetState state , int top , boolean settleFromViewDragHelper ) { boolean startedSettling = viewDragHelper != null && ( settleFromViewDragHelper ? viewDragHelper . settleCapturedViewAt ( child . getLeft ( ) , top ) : viewDragHelper . smoothSlideViewTo ( child , child . getLeft ( ) , top ) ) ; if ( startedSettling ) { setStateInternal ( SETTLING ) ; if ( settleRunnable == null ) { settleRunnable = new SettleRunnable ( child , state ) ; } if ( ! settleRunnable . isPosted ) { settleRunnable . targetState = state ; ViewCompat . postOnAnimation ( child , settleRunnable ) ; settleRunnable . isPosted = true ; } else { settleRunnable . targetState = state ; } } else { setStateInternal ( state ) ; } } void setStateInternal ( BottomSheetState state ) { if ( this . state == state ) { return ; } this . state = state ; if ( state == COLLAPSED || state == EXPANDED || state == HIDDEN ) { sentEvent ( new StateChangedEvent ( UIManagerHelper . getSurfaceId ( reactContext ) , getId ( ) , state . name ( ) . toLowerCase ( ) ) ) ; } } private class SettleRunnable implements Runnable { private final View view ; private boolean isPosted ; BottomSheetState targetState ; SettleRunnable ( View view , BottomSheetState targetState ) { this . view = view ; this . targetState = targetState ; } @ Override public void run ( ) { if ( viewDragHelper != null && viewDragHelper . continueSettling ( true ) ) { ViewCompat . postOnAnimation ( view , this ) ; } else { setStateInternal ( targetState ) ; } this . isPosted = false ; } } void sentEvent ( Event < ? > event ) { int viewId = getId ( ) ; EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( event ) ; } } }"}, {"input": "package androidx . fluidviewpager2 . adapter ; import android . os . Parcelable ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . fluidviewpager2 . widget . ViewPager2 ; public interface StatefulAdapter { @ NonNull Parcelable saveState ( ) ; void restoreState ( @ NonNull Parcelable savedState ) ;", "output": "}"}, {"input": "package org . woheller69 . weather . activities ; import static java . lang . Boolean . TRUE ; import android . Manifest ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . location . LocationListener ; import android . location . LocationManager ; import android . os . Bundle ; import androidx . appcompat . app . AlertDialog ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceManager ; import com . google . android . material . tabs . TabLayout ; import com . google . android . material . tabs . TabLayoutMediator ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager2 . widget . ViewPager2 ; import android . util . Log ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . animation . AlphaAnimation ; import android . view . animation . Animation ; import android . view . animation . LinearInterpolator ; import android . view . animation . RotateAnimation ; import android . widget . TextView ; import android . widget . Toast ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . database . WeekForecast ; import org . woheller69 . weather . ui . updater . IUpdateableCityUI ; import org . woheller69 . weather . ui . updater . ViewUpdater ; import org . woheller69 . weather . ui . viewPager . WeatherPagerAdapter ; import static org . woheller69 . weather . database . SQLiteHelper . getWidgetCityID ; import java . lang . reflect . Field ; import java . util . List ; import java . util . Locale ; public class ForecastCityActivity extends NavigationActivity implements IUpdateableCityUI { private WeatherPagerAdapter pagerAdapter ; private static LocationListener locationListenerGPS ; private LocationManager locationManager ; private static MenuItem updateLocationButton ; private static MenuItem refreshActionButton ; private MenuItem rainviewerButton ; private int cityId = - <NUM_LIT> ; private ViewPager2 viewPager2 ; private TabLayout tabLayout ; private TextView noCityText ; private static Boolean isRefreshing = false ; Context context ; @ Override protected void onPause ( ) { super . onPause ( ) ; ViewUpdater . removeSubscriber ( this ) ; ViewUpdater . removeSubscriber ( pagerAdapter ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { viewPager2 . setVisibility ( View . GONE ) ; noCityText . setVisibility ( View . VISIBLE ) ; } else { noCityText . setVisibility ( View . GONE ) ; viewPager2 . setVisibility ( View . VISIBLE ) ; pagerAdapter . loadCities ( ) ; viewPager2 . setAdapter ( pagerAdapter ) ; TabLayoutMediator tabLayoutMediator = new TabLayoutMediator ( tabLayout , viewPager2 , false , false , ( tab , position ) -> tab . setText ( pagerAdapter . getPageTitle ( position ) ) ) ; tabLayoutMediator . attach ( ) ; } ViewUpdater . addSubscriber ( this ) ; ViewUpdater . addSubscriber ( pagerAdapter ) ; if ( pagerAdapter . getItemCount ( ) > <NUM_LIT> ) { if ( pagerAdapter . getPosForCityID ( cityId ) == - <NUM_LIT> ) cityId = pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ; if ( viewPager2 . getCurrentItem ( ) != pagerAdapter . getPosForCityID ( cityId ) ) viewPager2 . setCurrentItem ( pagerAdapter . getPosForCityID ( cityId ) , false ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; context = this ; setContentView ( R . layout . activity_forecast_city ) ; initResources ( ) ; viewPager2 . registerOnPageChangeCallback ( new ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; SQLiteHelper database = SQLiteHelper . getInstance ( getApplicationContext ( ) . getApplicationContext ( ) ) ; CurrentWeatherData currentWeather = database . getCurrentWeatherByCityId ( pagerAdapter . getCityIDForPos ( position ) ) ; long timestamp = currentWeather . getTimestamp ( ) ; long systemTime = System . currentTimeMillis ( ) / <NUM_LIT> ; long updateInterval = ( long ) ( Float . parseFloat ( prefManager . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) * <NUM_LIT> * <NUM_LIT> ) ; if ( timestamp + updateInterval - systemTime <= <NUM_LIT> ) { if ( pagerAdapter . getCityIDForPos ( position ) != getWidgetCityID ( context ) || locationListenerGPS == null ) { WeatherPagerAdapter . refreshSingleData ( getApplicationContext ( ) , true , pagerAdapter . getCityIDForPos ( position ) ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } viewPager2 . post ( ( ) -> { pagerAdapter . notifyItemChanged ( position ) ; } ) ; cityId = pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ; } } ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; setIntent ( intent ) ; if ( intent . hasExtra ( \"<STR_LIT>\" ) ) { cityId = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; if ( pagerAdapter . getItemCount ( ) > <NUM_LIT> ) viewPager2 . setCurrentItem ( pagerAdapter . getPosForCityID ( cityId ) , false ) ; } } private void initResources ( ) { viewPager2 = findViewById ( R . id . viewPager2 ) ; viewPager2 . setUserInputEnabled ( false ) ; tabLayout = findViewById ( R . id . tab_layout ) ; pagerAdapter = new WeatherPagerAdapter ( this , getSupportFragmentManager ( ) , getLifecycle ( ) ) ; noCityText = findViewById ( R . id . noCitySelectedText ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_weather ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . activity_forecast_city , menu ) ; final Menu m = menu ; SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; updateLocationButton = menu . findItem ( R . id . menu_update_location ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) == TRUE && ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { updateLocationButton . setVisible ( true ) ; updateLocationButton . setActionView ( R . layout . menu_update_location_view ) ; updateLocationButton . getActionView ( ) . clearAnimation ( ) ; if ( locationListenerGPS != null ) { removeLocationListener ( ) ; if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { locationListenerGPS = getNewLocationListener ( ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { startUpdateLocatationAnimation ( ) ; } } } updateLocationButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( updateLocationButton . getItemId ( ) , <NUM_LIT> ) ) ; } else { removeLocationListener ( ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { updateLocationButton . getActionView ( ) . clearAnimation ( ) ; } SharedPreferences . Editor editor = prefManager . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , false ) ; editor . apply ( ) ; } refreshActionButton = menu . findItem ( R . id . menu_refresh ) ; refreshActionButton . setActionView ( R . layout . menu_refresh_action_view ) ; refreshActionButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( refreshActionButton . getItemId ( ) , <NUM_LIT> ) ) ; if ( isRefreshing ) startRefreshAnimation ( ) ; rainviewerButton = menu . findItem ( R . id . menu_rainviewer ) ; rainviewerButton . setActionView ( R . layout . menu_rainviewer_view ) ; rainviewerButton . getActionView ( ) . setOnClickListener ( v -> m . performIdentifierAction ( rainviewerButton . getItemId ( ) , <NUM_LIT> ) ) ; return true ; } @ Override public boolean onOptionsItemSelected ( final MenuItem item ) { int id = item . getItemId ( ) ; SQLiteHelper db = SQLiteHelper . getInstance ( this ) ; if ( id == R . id . menu_rainviewer ) { SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( ! prefManager . getBoolean ( \"<STR_LIT>\" , false ) ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; alertDialogBuilder . setMessage ( R . string . nonFreeNet ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { startActivity ( new Intent ( context , SettingsActivity . class ) ) ; } } ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } else { if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { Intent intent = new Intent ( this , RainViewerActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , pagerAdapter . getLatForPos ( ( viewPager2 . getCurrentItem ( ) ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , pagerAdapter . getLonForPos ( ( viewPager2 . getCurrentItem ( ) ) ) ) ; CurrentWeatherData currentWeather = db . getCurrentWeatherByCityId ( pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , currentWeather . getTimeZoneSeconds ( ) ) ; startActivity ( intent ) ; } } } else if ( id == R . id . menu_refresh ) { if ( ! db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { WeatherPagerAdapter . refreshSingleData ( getApplicationContext ( ) , true , pagerAdapter . getCityIDForPos ( viewPager2 . getCurrentItem ( ) ) ) ; ForecastCityActivity . startRefreshAnimation ( ) ; } } else if ( id == R . id . menu_update_location ) { locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( ! locationManager . isProviderEnabled ( LocationManager . GPS_PROVIDER ) ) { Toast . makeText ( this , R . string . error_no_gps , Toast . LENGTH_LONG ) . show ( ) ; } else { if ( db . getAllCitiesToWatch ( ) . isEmpty ( ) ) { CityToWatch newCity = new CityToWatch ( db . getMaxRank ( ) + <NUM_LIT> , - <NUM_LIT> , - <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , \"<STR_LIT>\" ) ; cityId = ( int ) db . addCityToWatch ( newCity ) ; initResources ( ) ; noCityText . setVisibility ( View . GONE ) ; viewPager2 . setVisibility ( View . VISIBLE ) ; viewPager2 . setAdapter ( pagerAdapter ) ; TabLayoutMediator tabLayoutMediator = new TabLayoutMediator ( tabLayout , viewPager2 , false , false , ( tab , position ) -> tab . setText ( pagerAdapter . getPageTitle ( position ) ) ) ; tabLayoutMediator . attach ( ) ; } SharedPreferences prefManager = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; if ( prefManager . getBoolean ( \"<STR_LIT>\" , true ) == TRUE && ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_COARSE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) { if ( locationListenerGPS == null ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; locationListenerGPS = getNewLocationListener ( ) ; ForecastCityActivity . startUpdateLocatationAnimation ( ) ; locationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , <NUM_LIT> , <NUM_LIT> , locationListenerGPS ) ; } } } } return super . onOptionsItemSelected ( item ) ; } @ Override protected void onPostResume ( ) { super . onPostResume ( ) ; } @ Override public void processNewCurrentWeatherData ( CurrentWeatherData data ) { stopRefreshAnimation ( ) ; } @ Override public void processNewWeekForecasts ( List < WeekForecast > forecasts ) { stopRefreshAnimation ( ) ; } @ Override public void processNewForecasts ( List < HourlyForecast > hourlyForecasts ) { stopRefreshAnimation ( ) ; } public static void stopRefreshAnimation ( ) { if ( refreshActionButton != null && refreshActionButton . getActionView ( ) != null ) { refreshActionButton . getActionView ( ) . clearAnimation ( ) ; } isRefreshing = false ; } public static void startRefreshAnimation ( ) { isRefreshing = true ; if ( refreshActionButton != null && refreshActionButton . getActionView ( ) != null ) { RotateAnimation rotate = new RotateAnimation ( <NUM_LIT> , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> , Animation . RELATIVE_TO_SELF , <NUM_LIT> ) ; rotate . setDuration ( <NUM_LIT> ) ; rotate . setRepeatCount ( <NUM_LIT> ) ; rotate . setInterpolator ( new LinearInterpolator ( ) ) ; rotate . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) { refreshActionButton . getActionView ( ) . setActivated ( false ) ; refreshActionButton . getActionView ( ) . setEnabled ( false ) ; refreshActionButton . getActionView ( ) . setClickable ( false ) ; } @ Override public void onAnimationEnd ( Animation animation ) { refreshActionButton . getActionView ( ) . setActivated ( true ) ; refreshActionButton . getActionView ( ) . setEnabled ( true ) ; refreshActionButton . getActionView ( ) . setClickable ( true ) ; isRefreshing = false ; } @ Override public void onAnimationRepeat ( Animation animation ) { } } ) ; refreshActionButton . getActionView ( ) . startAnimation ( rotate ) ; } } public static void startUpdateLocatationAnimation ( ) { { if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { Animation blink = new AlphaAnimation ( <NUM_LIT> , <NUM_LIT> ) ; blink . setDuration ( <NUM_LIT> ) ; blink . setRepeatCount ( Animation . INFINITE ) ; blink . setInterpolator ( new LinearInterpolator ( ) ) ; blink . setRepeatMode ( Animation . REVERSE ) ; blink . setAnimationListener ( new Animation . AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) { updateLocationButton . getActionView ( ) . setActivated ( false ) ; updateLocationButton . getActionView ( ) . setEnabled ( false ) ; updateLocationButton . getActionView ( ) . setClickable ( false ) ; } @ Override public void onAnimationEnd ( Animation animation ) { updateLocationButton . getActionView ( ) . setActivated ( true ) ;", "output": "updateLocationButton . getActionView ( ) . setEnabled ( true ) ; updateLocationButton . getActionView ( ) . setClickable ( true ) ; } @ Override public void onAnimationRepeat ( Animation animation ) { } } ) ; updateLocationButton . getActionView ( ) . startAnimation ( blink ) ; } } } private void reduceViewpager2DragSensitivity ( ViewPager2 viewPager , int sensitivity ) { try { Field ff = ViewPager2 . class . getDeclaredField ( \"<STR_LIT>\" ) ; ff . setAccessible ( true ) ; RecyclerView recyclerView = ( RecyclerView ) ff . get ( viewPager ) ; Field touchSlopField = RecyclerView . class . getDeclaredField ( \"<STR_LIT>\" ) ; touchSlopField . setAccessible ( true ) ; int touchSlop = ( int ) touchSlopField . get ( recyclerView ) ; touchSlopField . set ( recyclerView , touchSlop * sensitivity ) ; } catch ( NoSuchFieldException | IllegalAccessException e ) { e . printStackTrace ( ) ; } } private LocationListener getNewLocationListener ( ) { return new LocationListener ( ) { @ Override public void onLocationChanged ( android . location . Location location ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; SQLiteHelper db = SQLiteHelper . getInstance ( context ) ; CityToWatch city = db . getCityToWatch ( getWidgetCityID ( context ) ) ; city . setLatitude ( ( float ) location . getLatitude ( ) ) ; city . setLongitude ( ( float ) location . getLongitude ( ) ) ; city . setCityName ( String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , location . getLatitude ( ) , location . getLongitude ( ) ) ) ; db . updateCityToWatch ( city ) ; db . deleteWeekForecastsByCityId ( getWidgetCityID ( context ) ) ; db . deleteCurrentWeatherByCityId ( getWidgetCityID ( context ) ) ; db . deleteForecastsByCityId ( getWidgetCityID ( context ) ) ; db . deleteQuarterHourlyForecastsByCityId ( getWidgetCityID ( context ) ) ; pagerAdapter . loadCities ( ) ; viewPager2 . setAdapter ( pagerAdapter ) ; tabLayout . getTabAt ( <NUM_LIT> ) . setText ( city . getCityName ( ) ) ; removeLocationListener ( ) ; if ( updateLocationButton != null && updateLocationButton . getActionView ( ) != null ) { updateLocationButton . getActionView ( ) . clearAnimation ( ) ; } } @ Deprecated @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onProviderDisabled ( String provider ) { } } ; } private void removeLocationListener ( ) { if ( locationListenerGPS != null ) { locationManager = ( LocationManager ) context . getSystemService ( Context . LOCATION_SERVICE ) ; if ( locationListenerGPS != null ) locationManager . removeUpdates ( locationListenerGPS ) ; } locationListenerGPS = null ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DebugUtils { public static void debugFields ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( \"<STR_LIT>\" + cls . getName ( ) ) ; for ( var field : cls . getDeclaredFields ( ) ) { try { field . setAccessible ( true ) ; var name = field . getName ( ) ; var value = field . get ( thisObject ) ; if ( value != null && value . getClass ( ) . isArray ( ) ) { value = Arrays . toString ( ( Object [ ] ) value ) ; } XposedBridge . log ( \"<STR_LIT>\" + name + \"<STR_LIT>\" + value ) ; } catch ( Exception ignored ) { } } } public static void debugAllMethods ( String className , String methodName , boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { XposedBridge . hookAllMethods ( XposedHelpers . findClass ( className , Utils . getApplication ( ) . getClassLoader ( ) ) , methodName , getDebugMethodHook ( printMethods , printFields , printArgs , printTrace ) ) ; } public static XC_MethodHook getDebugMethodHook ( boolean printMethods , boolean printFields , boolean printArgs , boolean printTrace ) { return new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { XposedBridge . log ( \"<STR_LIT>\" ) ; XposedBridge . log ( \"<STR_LIT>\" + param . method . getDeclaringClass ( ) . getName ( ) + \"<STR_LIT>\" + param . method . getName ( ) + \"<STR_LIT>\" + param . thisObject ) ; if ( printArgs ) { debugArgs ( param . args ) ; XposedBridge . log ( \"<STR_LIT>\" + ( param . getResult ( ) == null ? null : param . getResult ( ) . getClass ( ) . getName ( ) ) + \"<STR_LIT>\" + param . getResult ( ) ) ; } if ( printFields ) { debugFields ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printMethods ) { debugMethods ( param . thisObject == null ? param . method . getDeclaringClass ( ) : param . thisObject . getClass ( ) , param . thisObject ) ; } if ( printTrace ) {", "output": "for ( var trace : Thread . currentThread ( ) . getStackTrace ( ) ) { XposedBridge . log ( \"<STR_LIT>\" + trace . toString ( ) ) ; } } XposedBridge . log ( \"<STR_LIT>\" ) ; } } ; } public static void debugArgs ( Object [ ] args ) { for ( var i = <NUM_LIT> ; i < args . length ; i ++ ) { XposedBridge . log ( \"<STR_LIT>\" + i + \"<STR_LIT>\" + ( args [ i ] == null ? null : args [ i ] . getClass ( ) . getName ( ) ) + \"<STR_LIT>\" + args [ i ] ) ; } } public static void debugMethods ( Class < ? > cls , Object thisObject ) { XposedBridge . log ( \"<STR_LIT>\" + cls . getName ( ) ) ; for ( var method : cls . getDeclaredMethods ( ) ) { if ( method . getParameterCount ( ) > <NUM_LIT> ) continue ; try { method . setAccessible ( true ) ; XposedBridge . log ( \"<STR_LIT>\" + method . getName ( ) + \"<STR_LIT>\" + method . invoke ( thisObject ) ) ; } catch ( Exception ignored ) { } } } }"}, {"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . app . ActivityThread ; import android . app . AndroidAppHelper ; import android . app . Application ; import android . app . LoadedApk ; import android . content . ComponentName ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . content . res . XResources ; import android . os . Build ; import android . os . Environment ; import android . os . IBinder ; import android . os . Process ; import android . util . Log ; import android . widget . Toast ; import com . android . internal . os . ZygoteInit ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . lang . ref . WeakReference ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import dalvik . system . DexFile ; import dalvik . system . PathClassLoader ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import de . robv . android . xposed . callbacks . XCallback ; import de . robv . android . xposed . services . BaseService ; import static de . robv . android . xposed . XposedBridge . hookAllConstructors ; import static de . robv . android . xposed . XposedBridge . hookAllMethods ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . closeSilently ; import static de . robv . android . xposed . XposedHelpers . fileContains ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import static de . robv . android . xposed . XposedHelpers . findClass ; import static de . robv . android . xposed . XposedHelpers . findFieldIfExists ; import static de . robv . android . xposed . XposedHelpers . getBooleanField ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import static de . robv . android . xposed . XposedHelpers . getOverriddenMethods ; import static de . robv . android . xposed . XposedHelpers . getParameterIndexByType ; import static de . robv . android . xposed . XposedHelpers . setObjectField ; import static de . robv . android . xposed . XposedHelpers . setStaticBooleanField ; import static de . robv . android . xposed . XposedHelpers . setStaticLongField ; import static de . robv . android . xposed . XposedHelpers . setStaticObjectField ; final class XposedInit { private static final String TAG = XposedBridge . TAG ; private static final boolean startsSystemServer = true ; private static final String INSTALLER_PACKAGE_NAME = \"<STR_LIT>\" ; @ SuppressLint ( \"<STR_LIT>\" ) private static final String BASE_DIR = Build . VERSION . SDK_INT >= <NUM_LIT> ? \"<STR_LIT>\" + INSTALLER_PACKAGE_NAME + \"<STR_LIT>\" : \"<STR_LIT>\" + INSTALLER_PACKAGE_NAME + \"<STR_LIT>\" ; private static final String INSTANT_RUN_CLASS = \"<STR_LIT>\" ; private static boolean disableResources = false ; private static final String [ ] XRESOURCES_CONFLICTING_PACKAGES = { \"<STR_LIT>\" } ; private XposedInit ( ) { } static void initForZygote ( ) throws Throwable { if ( needsToCloseFilesForFork ( ) ) { XC_MethodHook callback = new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { } } ; Class < ? > zygote = findClass ( \"<STR_LIT>\" , null ) ; hookAllMethods ( zygote , \"<STR_LIT>\" , callback ) ; hookAllMethods ( zygote , \"<STR_LIT>\" , callback ) ; } final HashSet < String > loadedPackagesInProcess = new HashSet < > ( <NUM_LIT> ) ; findAndHookMethod ( ActivityThread . class , \"<STR_LIT>\" , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { ActivityThread activityThread = ( ActivityThread ) param . thisObject ; ApplicationInfo appInfo = ( ApplicationInfo ) getObjectField ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ; String reportedPackageName = appInfo . packageName . equals ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : appInfo . packageName ; SELinuxHelper . initForProcess ( reportedPackageName ) ; ComponentName instrumentationName = ( ComponentName ) getObjectField ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ; if ( instrumentationName != null ) { Log . w ( TAG , \"<STR_LIT>\" + reportedPackageName ) ; XposedBridge . disableHooks = true ; return ; } CompatibilityInfo compatInfo = ( CompatibilityInfo ) getObjectField ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ; if ( appInfo . sourceDir == null ) return ; setObjectField ( activityThread , \"<STR_LIT>\" , param . args [ <NUM_LIT> ] ) ; loadedPackagesInProcess . add ( reportedPackageName ) ; LoadedApk loadedApk = activityThread . getPackageInfoNoCheck ( appInfo , compatInfo ) ; XResources . setPackageNameForResDir ( appInfo . packageName , loadedApk . getResDir ( ) ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = reportedPackageName ; lpparam . processName = ( String ) getObjectField ( param . args [ <NUM_LIT> ] , \"<STR_LIT>\" ) ; lpparam . classLoader = loadedApk . getClassLoader ( ) ; lpparam . appInfo = appInfo ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; if ( reportedPackageName . equals ( INSTALLER_PACKAGE_NAME ) ) hookXposedInstaller ( lpparam . classLoader ) ; } } ) ; if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { findAndHookMethod ( \"<STR_LIT>\" , null , Build . VERSION . SDK_INT < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { SELinuxHelper . initForProcess ( \"<STR_LIT>\" ) ; loadedPackagesInProcess . add ( \"<STR_LIT>\" ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = \"<STR_LIT>\" ; lpparam . processName = \"<STR_LIT>\" ; lpparam . classLoader = XposedBridge . BOOTCLASSLOADER ; lpparam . appInfo = null ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; } } ) ; } else if ( startsSystemServer ) { findAndHookMethod ( ActivityThread . class , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { final ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; findAndHookMethod ( \"<STR_LIT>\" , cl , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { SELinuxHelper . initForProcess ( \"<STR_LIT>\" ) ; loadedPackagesInProcess . add ( \"<STR_LIT>\" ) ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = \"<STR_LIT>\" ; lpparam . processName = \"<STR_LIT>\" ; lpparam . classLoader = cl ; lpparam . appInfo = null ; lpparam . isFirstApplication = true ; XC_LoadPackage . callAll ( lpparam ) ; try { findAndHookMethod ( \"<STR_LIT>\" , cl , \"<STR_LIT>\" , XC_MethodReplacement . returnConstant ( false ) ) ; } catch ( XposedHelpers . ClassNotFoundError | NoSuchMethodError ignored ) { } try { String className = \"<STR_LIT>\" + ( Build . VERSION . SDK_INT >= <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; findAndHookMethod ( className , cl , \"<STR_LIT>\" , String . class , XC_MethodReplacement . returnConstant ( true ) ) ; } catch ( XposedHelpers . ClassNotFoundError | NoSuchMethodError ignored ) { } } } ) ; } } ) ; } hookAllConstructors ( LoadedApk . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { LoadedApk loadedApk = ( LoadedApk ) param . thisObject ; String packageName = loadedApk . getPackageName ( ) ; XResources . setPackageNameForResDir ( packageName , loadedApk . getResDir ( ) ) ; if ( packageName . equals ( \"<STR_LIT>\" ) || ! loadedPackagesInProcess . add ( packageName ) ) return ; if ( ! getBooleanField ( loadedApk , \"<STR_LIT>\" ) ) return ; XC_LoadPackage . LoadPackageParam lpparam = new XC_LoadPackage . LoadPackageParam ( XposedBridge . sLoadedPackageCallbacks ) ; lpparam . packageName = packageName ; lpparam . processName = AndroidAppHelper . currentProcessName ( ) ; lpparam . classLoader = loadedApk . getClassLoader ( ) ; lpparam . appInfo = loadedApk . getApplicationInfo ( ) ; lpparam . isFirstApplication = false ; XC_LoadPackage . callAll ( lpparam ) ;", "output": "} } ) ; findAndHookMethod ( \"<STR_LIT>\" , null , \"<STR_LIT>\" , ApplicationInfo . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { ApplicationInfo app = ( ApplicationInfo ) param . args [ <NUM_LIT> ] ; XResources . setPackageNameForResDir ( app . packageName , app . uid == Process . myUid ( ) ? app . sourceDir : app . publicSourceDir ) ; } } ) ; if ( findFieldIfExists ( ZygoteInit . class , \"<STR_LIT>\" ) != null ) { setStaticLongField ( ZygoteInit . class , \"<STR_LIT>\" , XposedBridge . BOOT_START_TIME ) ; } if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Class < ? > zygote = findClass ( \"<STR_LIT>\" , null ) ; try { setStaticBooleanField ( zygote , \"<STR_LIT>\" , false ) ; } catch ( NoSuchFieldError ignored ) { } } } static void hookResources ( ) throws Throwable { if ( SELinuxHelper . getAppDataFileService ( ) . checkFileExists ( BASE_DIR + \"<STR_LIT>\" ) ) { Log . w ( TAG , \"<STR_LIT>\" + BASE_DIR + \"<STR_LIT>\" ) ; disableResources = true ; return ; } final Class < ? > classGTLR ; final Class < ? > classResKey ; final ThreadLocal < Object > latestResKey = new ThreadLocal < > ( ) ; if ( Build . VERSION . SDK_INT <= <NUM_LIT> ) { classGTLR = ActivityThread . class ; classResKey = Class . forName ( \"<STR_LIT>\" ) ; } else { classGTLR = Class . forName ( \"<STR_LIT>\" ) ; classResKey = Class . forName ( \"<STR_LIT>\" ) ; } XResources . init ( latestResKey ) ; } private static boolean needsToCloseFilesForFork ( ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { return true ; } else if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { return false ; } File lib = new File ( Environment . getRootDirectory ( ) , \"<STR_LIT>\" ) ; try { return fileContains ( lib , \"<STR_LIT>\" ) ; } catch ( IOException e ) { Log . e ( TAG , \"<STR_LIT>\" + lib + \"<STR_LIT>\" ) ; return true ; } } private static void hookXposedInstaller ( ClassLoader classLoader ) { try { findAndHookMethod ( INSTALLER_PACKAGE_NAME + \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , XC_MethodReplacement . returnConstant ( XposedBridge . getXposedVersion ( ) ) ) ; findAndHookMethod ( INSTALLER_PACKAGE_NAME + \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Application application = ( Application ) param . thisObject ; Resources res = application . getResources ( ) ; if ( res . getIdentifier ( \"<STR_LIT>\" , \"<STR_LIT>\" , INSTALLER_PACKAGE_NAME ) == <NUM_LIT> ) { Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Toast . makeText ( application , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } } } ) ; } catch ( Throwable t ) { Log . e ( TAG , \"<STR_LIT>\" , t ) ; } } static void loadModules ( ) throws IOException { final String filename = BASE_DIR + \"<STR_LIT>\" ; BaseService service = SELinuxHelper . getAppDataFileService ( ) ; if ( ! service . checkFileExists ( filename ) ) { Log . e ( TAG , \"<STR_LIT>\" + filename + \"<STR_LIT>\" ) ; return ; } ClassLoader topClassLoader = XposedBridge . BOOTCLASSLOADER ; ClassLoader parent ; while ( ( parent = topClassLoader . getParent ( ) ) != null ) { topClassLoader = parent ; } InputStream stream = service . getFileInputStream ( filename ) ; BufferedReader apks = new BufferedReader ( new InputStreamReader ( stream ) ) ; String apk ; while ( ( apk = apks . readLine ( ) ) != null ) { loadModule ( apk , topClassLoader ) ; } apks . close ( ) ; } private static void loadModule ( String apk , ClassLoader topClassLoader ) { Log . i ( TAG , \"<STR_LIT>\" + apk ) ; if ( ! new File ( apk ) . exists ( ) ) { Log . e ( TAG , \"<STR_LIT>\" ) ; return ; } DexFile dexFile ; try { dexFile = new DexFile ( apk ) ; } catch ( IOException e ) { Log . e ( TAG , \"<STR_LIT>\" , e ) ; return ; } if ( dexFile . loadClass ( INSTANT_RUN_CLASS , topClassLoader ) != null ) { Log . e ( TAG , \"<STR_LIT>\" ) ; closeSilently ( dexFile ) ; return ; } if ( dexFile . loadClass ( XposedBridge . class . getName ( ) , topClassLoader ) != null ) { Log . e ( TAG , \"<STR_LIT>\" ) ; Log . e ( TAG , \"<STR_LIT>\" ) ; Log . e ( TAG , \"<STR_LIT>\" ) ; Log . e ( TAG , \"<STR_LIT>\" ) ; closeSilently ( dexFile ) ; return ; } closeSilently ( dexFile ) ; ZipFile zipFile = null ; InputStream is ; try { zipFile = new ZipFile ( apk ) ; ZipEntry zipEntry = zipFile . getEntry ( \"<STR_LIT>\" ) ; if ( zipEntry == null ) { Log . e ( TAG , \"<STR_LIT>\" ) ; closeSilently ( zipFile ) ; return ; } is = zipFile . getInputStream ( zipEntry ) ; } catch ( IOException e ) { Log . e ( TAG , \"<STR_LIT>\" , e ) ; closeSilently ( zipFile ) ; return ; } ClassLoader mcl = new PathClassLoader ( apk , XposedBridge . BOOTCLASSLOADER ) ; BufferedReader moduleClassesReader = new BufferedReader ( new InputStreamReader ( is ) ) ; try { String moduleClassName ; while ( ( moduleClassName = moduleClassesReader . readLine ( ) ) != null ) { moduleClassName = moduleClassName . trim ( ) ; if ( moduleClassName . isEmpty ( ) || moduleClassName . startsWith ( \"<STR_LIT>\" ) ) continue ; try { Log . i ( TAG , \"<STR_LIT>\" + moduleClassName ) ; Class < ? > moduleClass = mcl . loadClass ( moduleClassName ) ; if ( ! IXposedMod . class . isAssignableFrom ( moduleClass ) ) { Log . e ( TAG , \"<STR_LIT>\" ) ; continue ; } else if ( disableResources && IXposedHookInitPackageResources . class . isAssignableFrom ( moduleClass ) ) { Log . e ( TAG , \"<STR_LIT>\" ) ; continue ; } final Object moduleInstance = moduleClass . newInstance ( ) ; if ( XposedBridge . isZygote ) { if ( moduleInstance instanceof IXposedHookZygoteInit ) { IXposedHookZygoteInit . StartupParam param = new IXposedHookZygoteInit . StartupParam ( ) ; param . modulePath = apk ; param . startsSystemServer = startsSystemServer ; ( ( IXposedHookZygoteInit ) moduleInstance ) . initZygote ( param ) ; } if ( moduleInstance instanceof IXposedHookLoadPackage ) XposedBridge . hookLoadPackage ( new IXposedHookLoadPackage . Wrapper ( ( IXposedHookLoadPackage ) moduleInstance ) ) ; if ( moduleInstance instanceof IXposedHookInitPackageResources ) XposedBridge . hookInitPackageResources ( new IXposedHookInitPackageResources . Wrapper ( ( IXposedHookInitPackageResources ) moduleInstance ) ) ; } else { if ( moduleInstance instanceof IXposedHookCmdInit ) { IXposedHookCmdInit . StartupParam param = new IXposedHookCmdInit . StartupParam ( ) ; param . modulePath = apk ; param . startClassName = \"<STR_LIT>\" ; ( ( IXposedHookCmdInit ) moduleInstance ) . initCmdApp ( param ) ; } } } catch ( Throwable t ) { Log . e ( TAG , \"<STR_LIT>\" + moduleClassName , t ) ; } } } catch ( IOException e ) { Log . e ( TAG , \"<STR_LIT>\" + apk , e ) ; } finally { closeSilently ( is ) ; closeSilently ( zipFile ) ; } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; import java . io . IOException ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . Socket ; import java . net . UnknownHostException ; import top . weixiansen574 . hybridfilexfer . core . threads . ClientControllerThread ; import top . weixiansen574 . hybridfilexfer . core . threads . ReceiveThread ; public class FileTransferClient implements ServerInfo { ClientControllerThread controllerThread ; public void startUp ( ) { controllerThread = new ClientControllerThread ( ) ;", "output": "controllerThread . start ( ) ; } }"}, {"input": "package com . appspa . update ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fragment . app . FragmentActivity ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . proxy . impl . DefaultUpdatePrompter ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . utils . UpdateUtils ; import java . lang . ref . WeakReference ; import java . util . Map ; import java . util . TreeMap ; public class UpdateManager implements IUpdateProxy { private IUpdateProxy mUpdateProxy ; private UpdateEntity mUpdateEntity ; private final WeakReference < Context > mContext ; private final String mUpdateUrl ; private final Map < String , Object > mParams ; private final String mCacheDir ; private final boolean mIsWifiOnly ; private final boolean mIsGet ; private final boolean mIsAutoMode ; private IUpdateHttpService mIUpdateHttpService ; private final IUpdateChecker mIUpdateChecker ; private final IUpdateParser mIUpdateParser ; private IUpdateDownloader mIUpdateDownloader ; private OnFileDownloadListener mOnFileDownloadListener ; private final IUpdatePrompter mIUpdatePrompter ; private final PromptEntity mPromptEntity ; private UpdateManager ( Builder builder ) { mContext = new WeakReference < > ( builder . context ) ; mUpdateUrl = builder . updateUrl ; mParams = builder . params ; mCacheDir = builder . apkCacheDir ; mIsWifiOnly = builder . isWifiOnly ; mIsGet = builder . isGet ; mIsAutoMode = builder . isAutoMode ; mIUpdateHttpService = builder . updateHttpService ;", "output": "mIUpdateChecker = builder . updateChecker ; mIUpdateParser = builder . updateParser ; mIUpdateDownloader = builder . updateDownLoader ; mOnFileDownloadListener = builder . onFileDownloadListener ; mIUpdatePrompter = builder . updatePrompter ; mPromptEntity = builder . promptEntity ; } public UpdateManager setIUpdateProxy ( IUpdateProxy updateProxy ) { mUpdateProxy = updateProxy ; return this ; } @ Nullable @ Override public Context getContext ( ) { return mContext . get ( ) ; } @ Override public String getUrl ( ) { return mUpdateUrl ; } @ Override public IUpdateHttpService getIUpdateHttpService ( ) { return mIUpdateHttpService ; } @ Override public void update ( ) { UpdateLog . d ( \"<STR_LIT>\" + this ) ; if ( mUpdateProxy != null ) { mUpdateProxy . update ( ) ; } else { doUpdate ( ) ; } } private void doUpdate ( ) { onBeforeCheck ( ) ; doCheck ( ) ; } private void doCheck ( ) { if ( mIsWifiOnly ) { if ( UpdateUtils . checkWifi ( ) ) { checkVersion ( ) ; } else { onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_WIFI ) ; } } else { if ( UpdateUtils . checkNetwork ( ) ) { checkVersion ( ) ; } else { onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_NETWORK ) ; } } } @ Override public void onBeforeCheck ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . onBeforeCheck ( ) ; } else { mIUpdateChecker . onBeforeCheck ( ) ; } } @ Override public void checkVersion ( ) { UpdateLog . d ( \"<STR_LIT>\" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . checkVersion ( ) ; } else { if ( TextUtils . isEmpty ( mUpdateUrl ) ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } mIUpdateChecker . checkVersion ( mIsGet , mUpdateUrl , mParams , this ) ; } } @ Override public void onAfterCheck ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . onAfterCheck ( ) ; } else { mIUpdateChecker . onAfterCheck ( ) ; } } @ Override public boolean isAsyncParser ( ) { if ( mUpdateProxy != null ) { return mUpdateProxy . isAsyncParser ( ) ; } else { return mIUpdateParser . isAsyncParser ( ) ; } } @ Override public UpdateEntity parseJson ( @ NonNull String json ) throws Exception { UpdateLog . i ( \"<STR_LIT>\" + json ) ; if ( mUpdateProxy != null ) { mUpdateEntity = mUpdateProxy . parseJson ( json ) ; } else { mUpdateEntity = mIUpdateParser . parseJson ( json ) ; } mUpdateEntity = refreshParams ( mUpdateEntity ) ; return mUpdateEntity ; } @ Override public void parseJson ( @ NonNull String json , final IUpdateParseCallback callback ) throws Exception { UpdateLog . i ( \"<STR_LIT>\" + json ) ; if ( mUpdateProxy != null ) { mUpdateProxy . parseJson ( json , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; callback . onParseResult ( updateEntity ) ; } } ) ; } else { mIUpdateParser . parseJson ( json , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; callback . onParseResult ( updateEntity ) ; } } ) ; } } private UpdateEntity refreshParams ( UpdateEntity updateEntity ) { if ( updateEntity != null ) { updateEntity . setCacheDir ( mCacheDir ) ; updateEntity . setIsAutoMode ( mIsAutoMode ) ; updateEntity . setIUpdateHttpService ( mIUpdateHttpService ) ; } return updateEntity ; } @ Override public void findNewVersion ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy ) { UpdateLog . i ( \"<STR_LIT>\" + updateEntity ) ; if ( updateEntity . isSilent ( ) ) { if ( ! UpdateUtils . isApkDownloaded ( updateEntity ) ) { startDownload ( updateEntity , mOnFileDownloadListener ) ; } else { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } } else { if ( mUpdateProxy != null ) { mUpdateProxy . findNewVersion ( updateEntity , updateProxy ) ; } else { if ( mIUpdatePrompter instanceof DefaultUpdatePrompter ) { Context context = getContext ( ) ; if ( context instanceof FragmentActivity && ( ( FragmentActivity ) context ) . isFinishing ( ) ) { _AppSpace . onUpdateError ( UpdateError . ERROR . PROMPT_ACTIVITY_DESTROY ) ; } else { mIUpdatePrompter . showPrompt ( updateEntity , updateProxy , mPromptEntity ) ; } } else { mIUpdatePrompter . showPrompt ( updateEntity , updateProxy , mPromptEntity ) ; } } } } @ Override public void noNewVersion ( Throwable throwable ) { UpdateLog . i ( throwable != null ? \"<STR_LIT>\" + throwable . getMessage ( ) : \"<STR_LIT>\" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . noNewVersion ( throwable ) ; } else { mIUpdateChecker . noNewVersion ( throwable ) ; } } @ Override public void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { UpdateLog . i ( \"<STR_LIT>\" + updateEntity ) ; updateEntity . setIUpdateHttpService ( mIUpdateHttpService ) ; if ( mUpdateProxy != null ) { mUpdateProxy . startDownload ( updateEntity , downloadListener ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . startDownload ( updateEntity , downloadListener ) ; } } } @ Override public void backgroundDownload ( ) { UpdateLog . i ( \"<STR_LIT>\" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . backgroundDownload ( ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . backgroundDownload ( ) ; } } } @ Override public void cancelDownload ( ) { UpdateLog . d ( \"<STR_LIT>\" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . cancelDownload ( ) ; } else { if ( mIUpdateDownloader != null ) { mIUpdateDownloader . cancelDownload ( ) ; } } } @ Override public void recycle ( ) { UpdateLog . d ( \"<STR_LIT>\" ) ; if ( mUpdateProxy != null ) { mUpdateProxy . recycle ( ) ; mUpdateProxy = null ; } if ( mParams != null ) { mParams . clear ( ) ; } mIUpdateHttpService = null ; mIUpdateDownloader = null ; mOnFileDownloadListener = null ; } public void download ( String downloadUrl , @ Nullable OnFileDownloadListener downloadListener ) { UpdateEntity updateEntity = new UpdateEntity ( ) ; updateEntity . getCurDownloadEntity ( ) . setDownloadUrl ( downloadUrl ) ; startDownload ( refreshParams ( updateEntity ) , downloadListener ) ; } public void update ( UpdateEntity updateEntity ) { mUpdateEntity = refreshParams ( updateEntity ) ; try { UpdateUtils . processUpdateEntity ( mUpdateEntity , \"<STR_LIT>\" , this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static class Builder { Context context ; String updateUrl ; Map < String , Object > params ; IUpdateHttpService updateHttpService ; IUpdateParser updateParser ; boolean isGet ; boolean isWifiOnly ; boolean isAutoMode ; IUpdateChecker updateChecker ; PromptEntity promptEntity ; IUpdatePrompter updatePrompter ; IUpdateDownloader updateDownLoader ; OnFileDownloadListener onFileDownloadListener ; String apkCacheDir ; Builder ( @ NonNull Context context ) { this . context = context ; params = new TreeMap < > ( ) ; if ( _AppSpace . getParams ( ) != null ) { params . putAll ( _AppSpace . getParams ( ) ) ; } promptEntity = new PromptEntity ( ) ; updateHttpService = _AppSpace . getIUpdateHttpService ( ) ; updateChecker = _AppSpace . getIUpdateChecker ( ) ; updateParser = _AppSpace . getIUpdateParser ( ) ; updatePrompter = _AppSpace . getIUpdatePrompter ( ) ; updateDownLoader = _AppSpace . getIUpdateDownLoader ( ) ; isGet = _AppSpace . isGet ( ) ; isWifiOnly = _AppSpace . isWifiOnly ( ) ; isAutoMode = _AppSpace . isAutoMode ( ) ; apkCacheDir = _AppSpace . getApkCacheDir ( ) ; } public Builder updateUrl ( @ NonNull String updateUrl ) { this . updateUrl = updateUrl ; return this ; } public Builder params ( @ NonNull Map < String , Object > params ) { this . params . putAll ( params ) ; return this ; } public Builder param ( @ NonNull String key , @ NonNull Object value ) { this . params . put ( key , value ) ; return this ; } public Builder updateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { this . updateHttpService = updateHttpService ; return this ; } public Builder apkCacheDir ( @ NonNull String apkCacheDir ) { this . apkCacheDir = apkCacheDir ; return this ; } public Builder isGet ( boolean isGet ) { this . isGet = isGet ; return this ; } public Builder isAutoMode ( boolean isAutoMode ) { this . isAutoMode = isAutoMode ; return this ; } public Builder isWifiOnly ( boolean isWifiOnly ) { this . isWifiOnly = isWifiOnly ; return this ; } public Builder updateChecker ( @ NonNull IUpdateChecker updateChecker ) { this . updateChecker = updateChecker ; return this ; } public Builder updateParser ( @ NonNull IUpdateParser updateParser ) { this . updateParser = updateParser ; return this ; } public Builder updatePrompter ( @ NonNull IUpdatePrompter updatePrompter ) { this . updatePrompter = updatePrompter ; return this ; } public Builder setOnFileDownloadListener ( OnFileDownloadListener onFileDownloadListener ) { this . onFileDownloadListener = onFileDownloadListener ; return this ; } @ Deprecated public Builder themeColor ( @ ColorInt int themeColor ) { promptEntity . setThemeColor ( themeColor ) ; return this ; } public Builder promptThemeColor ( @ ColorInt int themeColor ) { promptEntity . setThemeColor ( themeColor ) ; return this ; } @ Deprecated public Builder topResId ( @ DrawableRes int topResId ) { promptEntity . setTopResId ( topResId ) ; return this ; } public Builder promptTopResId ( @ DrawableRes int topResId ) { promptEntity . setTopResId ( topResId ) ; return this ; } public Builder promptTopDrawable ( Drawable topDrawable ) { if ( topDrawable != null ) { String tag = _AppSpace . saveTopDrawable ( topDrawable ) ; promptEntity . setTopDrawableTag ( tag ) ; } return this ; } public Builder promptTopBitmap ( Bitmap topBitmap ) { if ( topBitmap != null ) { String tag = _AppSpace . saveTopDrawable ( new BitmapDrawable ( context . getResources ( ) , topBitmap ) ) ; promptEntity . setTopDrawableTag ( tag ) ; } return this ; } public Builder promptButtonTextColor ( @ ColorInt int buttonTextColor ) { promptEntity . setButtonTextColor ( buttonTextColor ) ; return this ; } public Builder supportBackgroundUpdate ( boolean supportBackgroundUpdate ) { promptEntity . setSupportBackgroundUpdate ( supportBackgroundUpdate ) ; return this ; } public Builder promptWidthRatio ( float widthRatio ) { promptEntity . setWidthRatio ( widthRatio ) ; return this ; } public Builder promptHeightRatio ( float heightRatio ) { promptEntity . setHeightRatio ( heightRatio ) ; return this ; } public Builder promptIgnoreDownloadError ( boolean ignoreDownloadError ) { promptEntity . setIgnoreDownloadError ( ignoreDownloadError ) ; return this ; } public Builder promptStyle ( @ NonNull PromptEntity promptEntity ) { this . promptEntity = promptEntity ; return this ; } public Builder updateDownLoader ( @ NonNull IUpdateDownloader updateDownLoader ) { this . updateDownLoader = updateDownLoader ; return this ; } public UpdateManager build ( ) { UpdateUtils . requireNonNull ( this . context , \"<STR_LIT>\" ) ; UpdateUtils . requireNonNull ( this . updateHttpService , \"<STR_LIT>\" ) ; if ( TextUtils . isEmpty ( apkCacheDir ) ) { apkCacheDir = UpdateUtils . getDefaultDiskCacheDirPath ( ) ; } return new UpdateManager ( this ) ; } public void update ( ) { build ( ) . update ( ) ; } public void update ( IUpdateProxy updateProxy ) { build ( ) . setIUpdateProxy ( updateProxy ) . update ( ) ; } } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + mUpdateUrl + '<STR_LIT>' + \"<STR_LIT>\" + mParams + \"<STR_LIT>\" + mCacheDir + '<STR_LIT>' + \"<STR_LIT>\" + mIsWifiOnly + \"<STR_LIT>\" + mIsGet + \"<STR_LIT>\" + mIsAutoMode + '<STR_LIT>' ; } }"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . PARAMETER ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { PARAMETER } ) public @ interface ParameterType {", "output": "Class < ? > value ( ) ; }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . Canvas ; import android . view . View ; public interface ItemTouchUIUtil { @ SuppressLint ( \"<STR_LIT>\" ) void onDraw ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( \"<STR_LIT>\" ) void onDrawOver ( Canvas c , RecyclerView recyclerView , View view , float dX , float dY , int actionState , boolean isCurrentlyActive ) ; @ SuppressLint ( \"<STR_LIT>\" ) void clearView ( View view ) ; @ SuppressLint ( \"<STR_LIT>\" ) void onSelected ( View view ) ;", "output": "}"}, {"input": "package external . org . apache . commons . lang3 ; import java . io . Serializable ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Map ; import java . util . TreeSet ; import external . org . apache . commons . lang3 . exception . CloneFailedException ; import external . org . apache . commons . lang3 . mutable . MutableInt ; public class ObjectUtils { public static final Null NULL = new Null ( ) ; public ObjectUtils ( ) { super ( ) ; } public static < T > T defaultIfNull ( T object , T defaultValue ) { return object != null ? object : defaultValue ; } public static < T > T firstNonNull ( T ... values ) { if ( values != null ) { for ( T val : values ) { if ( val != null ) { return val ; } } } return null ; } public static boolean equals ( Object object1 , Object object2 ) { if ( object1 == object2 ) { return true ; } if ( object1 == null || object2 == null ) { return false ; } return object1 . equals ( object2 ) ; } public static boolean notEqual ( Object object1 , Object object2 ) { return ObjectUtils . equals ( object1 , object2 ) == false ; } public static int hashCode ( Object obj ) { return obj == null ? <NUM_LIT> : obj . hashCode ( ) ; } public static int hashCodeMulti ( Object ... objects ) { int hash = <NUM_LIT> ; if ( objects != null ) { for ( Object object : objects ) { hash = hash * <NUM_LIT> + ObjectUtils . hashCode ( object ) ; } } return hash ; } public static String identityToString ( Object object ) { if ( object == null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; identityToString ( buffer , object ) ; return buffer . toString ( ) ; }", "output": "public static void identityToString ( StringBuffer buffer , Object object ) { if ( object == null ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } buffer . append ( object . getClass ( ) . getName ( ) ) . append ( '<STR_LIT>' ) . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; } public static String toString ( Object obj ) { return obj == null ? \"<STR_LIT>\" : obj . toString ( ) ; } public static String toString ( Object obj , String nullStr ) { return obj == null ? nullStr : obj . toString ( ) ; } public static < T extends Comparable < ? super T > > T min ( T ... values ) { T result = null ; if ( values != null ) { for ( T value : values ) { if ( compare ( value , result , true ) < <NUM_LIT> ) { result = value ; } } } return result ; } public static < T extends Comparable < ? super T > > T max ( T ... values ) { T result = null ; if ( values != null ) { for ( T value : values ) { if ( compare ( value , result , false ) > <NUM_LIT> ) { result = value ; } } } return result ; } public static < T extends Comparable < ? super T > > int compare ( T c1 , T c2 ) { return compare ( c1 , c2 , false ) ; } public static < T extends Comparable < ? super T > > int compare ( T c1 , T c2 , boolean nullGreater ) { if ( c1 == c2 ) { return <NUM_LIT> ; } else if ( c1 == null ) { return nullGreater ? <NUM_LIT> : - <NUM_LIT> ; } else if ( c2 == null ) { return nullGreater ? - <NUM_LIT> : <NUM_LIT> ; } return c1 . compareTo ( c2 ) ; } public static < T extends Comparable < ? super T > > T median ( T ... items ) { Validate . notEmpty ( items ) ; Validate . noNullElements ( items ) ; TreeSet < T > sort = new TreeSet < T > ( ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - <NUM_LIT> ) / <NUM_LIT> ] ; return result ; } public static < T > T median ( Comparator < T > comparator , T ... items ) { Validate . notEmpty ( items , \"<STR_LIT>\" ) ; Validate . noNullElements ( items ) ; Validate . notNull ( comparator , \"<STR_LIT>\" ) ; TreeSet < T > sort = new TreeSet < T > ( comparator ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - <NUM_LIT> ) / <NUM_LIT> ] ; return result ; } public static < T > T mode ( T ... items ) { if ( ArrayUtils . isNotEmpty ( items ) ) { HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( items . length ) ; for ( T t : items ) { MutableInt count = occurrences . get ( t ) ; if ( count == null ) { occurrences . put ( t , new MutableInt ( <NUM_LIT> ) ) ; } else { count . increment ( ) ; } } T result = null ; int max = <NUM_LIT> ; for ( Map . Entry < T , MutableInt > e : occurrences . entrySet ( ) ) { int cmp = e . getValue ( ) . intValue ( ) ; if ( cmp == max ) { result = null ; } else if ( cmp > max ) { max = cmp ; result = e . getKey ( ) ; } } return result ; } return null ; } public static < T > T clone ( final T obj ) { if ( obj instanceof Cloneable ) { final Object result ; if ( obj . getClass ( ) . isArray ( ) ) { final Class < ? > componentType = obj . getClass ( ) . getComponentType ( ) ; if ( ! componentType . isPrimitive ( ) ) { result = ( ( Object [ ] ) obj ) . clone ( ) ; } else { int length = Array . getLength ( obj ) ; result = Array . newInstance ( componentType , length ) ; while ( length -- > <NUM_LIT> ) { Array . set ( result , length , Array . get ( obj , length ) ) ; } } } else { try { final Method clone = obj . getClass ( ) . getMethod ( \"<STR_LIT>\" ) ; result = clone . invoke ( obj ) ; } catch ( final NoSuchMethodException e ) { throw new CloneFailedException ( \"<STR_LIT>\" + obj . getClass ( ) . getName ( ) + \"<STR_LIT>\" , e ) ; } catch ( final IllegalAccessException e ) { throw new CloneFailedException ( \"<STR_LIT>\" + obj . getClass ( ) . getName ( ) , e ) ; } catch ( final InvocationTargetException e ) { throw new CloneFailedException ( \"<STR_LIT>\" + obj . getClass ( ) . getName ( ) , e . getCause ( ) ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) final T checked = ( T ) result ; return checked ; } return null ; } public static < T > T cloneIfPossible ( final T obj ) { final T clone = clone ( obj ) ; return clone == null ? obj : clone ; } public static class Null implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; Null ( ) { super ( ) ; } private Object readResolve ( ) { return ObjectUtils . NULL ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import com . baidu . aip . asrwakeup3 . core . R ; import com . baidu . aip . asrwakeup3 . core . inputstream . InFileStream ; import com . baidu . aip . asrwakeup3 . core . util . AuthUtil ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . ArrayList ; import java . util . Map ; import java . util . TreeMap ; public class ActivityMiniWakeUp extends AppCompatActivity implements EventListener { protected TextView txtLog ; protected TextView txtResult ; protected Button btn ; protected Button stopBtn ; private static String DESC_TEXT = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private EventManager wakeup ; private boolean logTime = true ; private void start ( ) { txtLog . setText ( \"<STR_LIT>\" ) ; Map < String , Object > params = AuthUtil . getParam ( ) ; params . put ( SpeechConstant . ACCEPT_AUDIO_VOLUME , false ) ; params . put ( SpeechConstant . WP_WORDS_FILE , \"<STR_LIT>\" ) ; InFileStream . setContext ( this ) ; String json = null ; json = new JSONObject ( params ) . toString ( ) ; wakeup . send ( SpeechConstant . WAKEUP_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; printLog ( \"<STR_LIT>\" + json ) ; } private void stop ( ) { wakeup . send ( SpeechConstant . WAKEUP_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . common_mini ) ; initView ( ) ; initPermission ( ) ; wakeup = EventManagerFactory . create ( this , \"<STR_LIT>\" ) ; wakeup . registerListener ( this ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { start ( ) ; } } ) ; stopBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { stop ( ) ; } } ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; wakeup . send ( SpeechConstant . WAKEUP_STOP , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String logTxt = \"<STR_LIT>\" + name ; if ( params != null && ! params . isEmpty ( ) ) { logTxt += \"<STR_LIT>\" + params ; } else if ( data != null ) { logTxt += \"<STR_LIT>\" + data . length ; } printLog ( logTxt ) ; } private void printLog ( String text ) { if ( logTime ) { text += \"<STR_LIT>\" + System . currentTimeMillis ( ) ; } text += \"<STR_LIT>\" ; Log . i ( getClass ( ) . getName ( ) , text ) ; txtLog . append ( text + \"<STR_LIT>\" ) ; } private void initView ( ) { txtResult = ( TextView ) findViewById ( R . id . txtResult ) ; txtLog = ( TextView ) findViewById ( R . id . txtLog ) ; btn = ( Button ) findViewById ( R . id . btn ) ;", "output": "stopBtn = ( Button ) findViewById ( R . id . btn_stop ) ; txtLog . setText ( DESC_TEXT + \"<STR_LIT>\" ) ; } private void initPermission ( ) { String [ ] permissions = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String [ ] tmpList = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { } }"}, {"input": "package org . woheller69 . weather . weather_api . open_meteo ; import android . content . Context ; import org . woheller69 . weather . http . HttpRequestType ; import org . woheller69 . weather . http . IHttpRequest ; import org . woheller69 . weather . http . VolleyHttpRequest ; import org . woheller69 . weather . weather_api . IHttpRequestForWeatherAPI ; public class OMHttpRequestForWeatherAPI extends OMHttpRequest implements IHttpRequestForWeatherAPI { private final Context context ; public OMHttpRequestForWeatherAPI ( Context context ) { this . context = context ; } @ Override public void perform ( float lat , float lon , int cityId ) {", "output": "IHttpRequest httpRequest = new VolleyHttpRequest ( context , cityId ) ; final String URL = getUrlForQueryingOMweatherAPI ( context , lat , lon ) ; httpRequest . make ( URL , HttpRequestType . GET , new ProcessOMweatherAPIRequest ( context ) ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . graphics . Color ; import android . os . Build ; import android . view . Window ; import androidx . activity . ComponentActivity ; import androidx . activity . EdgeToEdge ; import androidx . core . view . WindowCompat ; import androidx . core . view . WindowInsetsControllerCompat ; import androidx . preference . PreferenceManager ; import com . simon . harmonichackernews . R ; import java . util . Calendar ; import java . util . concurrent . TimeUnit ; public class ThemeUtils { private static final int defaultLightScrim = Color . argb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private static final int defaultDarkScrim = Color . argb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; public static void setupTheme ( ComponentActivity activity ) { setupTheme ( activity , false , true ) ; } public static void setupTheme ( ComponentActivity activity , boolean swipeBack ) { setupTheme ( activity , swipeBack , true ) ; } public static void setupTheme ( ComponentActivity activity , boolean swipeBack , boolean specialFlags ) { String theme = getPreferredTheme ( activity ) ; switch ( theme ) { case \"<STR_LIT>\" : if ( Build . VERSION . SDK_INT < <NUM_LIT> ) { if ( ! swipeBack ) { activity . setTheme ( R . style . AppThemeMaterialDayNight ) ; } } else { if ( swipeBack ) { activity . setTheme ( R . style . ThemeSwipeBackNoActionBarMaterialDayNight ) ; } } break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarMaterialDark : R . style . AppThemeMaterialDark ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarAmoledDark : R . style . AppThemeAmoledDark ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarGray : R . style . AppThemeGray ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarLight : R . style . AppThemeLight ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarMaterialLight : R . style . AppThemeMaterialLight ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . ThemeSwipeBackNoActionBarWhite : R . style . AppThemeWhite ) ; break ; case \"<STR_LIT>\" : activity . setTheme ( swipeBack ? R . style . Theme_Swipe_Back_NoActionBar : R . style . AppTheme ) ; break ; } Window window = activity . getWindow ( ) ; WindowInsetsControllerCompat insetsController = WindowCompat . getInsetsController ( window , window . getDecorView ( ) ) ; insetsController . setAppearanceLightStatusBars ( ! isDarkMode ( activity ) ) ; insetsController . setAppearanceLightNavigationBars ( ! isDarkMode ( activity ) ) ; if ( specialFlags ) { WindowCompat . setDecorFitsSystemWindows ( window , false ) ; } if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q ) { int navBarColor ; if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { navBarColor = defaultDarkScrim ; } else { navBarColor = isDarkMode ( activity ) ? defaultDarkScrim : defaultLightScrim ; } window . setNavigationBarColor ( navBarColor ) ; } if ( SettingsUtils . shouldUseTransparentStatusBar ( activity ) ) { window . setStatusBarColor ( Color . TRANSPARENT ) ; } } public static boolean isDarkMode ( Context ctx , String theme ) { if ( theme . equals ( \"<STR_LIT>\" ) ) { return uiModeNight ( ctx ) ; } return theme . equals ( \"<STR_LIT>\" ) || theme . equals ( \"<STR_LIT>\" ) || theme . equals ( \"<STR_LIT>\" ) || theme . equals ( \"<STR_LIT>\" ) ; } public static boolean isDarkMode ( Context ctx ) { String theme = getPreferredTheme ( ctx ) ; return isDarkMode ( ctx , theme ) ; } public static boolean uiModeNight ( Context ctx ) { int currentNightMode = ctx . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; return currentNightMode == Configuration . UI_MODE_NIGHT_YES ; } public static int getBackgroundColorResource ( Context ctx ) { String theme = getPreferredTheme ( ctx ) ; switch ( theme ) { case \"<STR_LIT>\" : return android . R . color . black ; case \"<STR_LIT>\" : return R . color . grayBackground ; case \"<STR_LIT>\" : return R . color . lightBackground ; case \"<STR_LIT>\" : return R . color . whiteBackground ; case \"<STR_LIT>\" : return R . color . material_you_neutral_900 ; case \"<STR_LIT>\" : return R . color . material_you_neutral_50 ; case \"<STR_LIT>\" : return uiModeNight ( ctx ) ? R . color . material_you_neutral_900 : R . color . material_you_neutral_50 ; case \"<STR_LIT>\" : return R . color . background ; default : return R . color . background ; } } public static String getPreferredTheme ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; if ( SettingsUtils . shouldUseSpecialNighttimeTheme ( ctx ) ) { Calendar currentCalendar = Calendar . getInstance ( ) ; int [ ] nighttimeHours = Utils . getNighttimeHours ( ctx ) ; long startTime = TimeUnit . HOURS . toMinutes ( nighttimeHours [ <NUM_LIT> ] ) + nighttimeHours [ <NUM_LIT> ] ; long endTime = TimeUnit . HOURS . toMinutes ( nighttimeHours [ <NUM_LIT> ] ) + nighttimeHours [ <NUM_LIT> ] ; long currentTime = TimeUnit . HOURS . toMinutes ( currentCalendar . get ( Calendar . HOUR_OF_DAY ) ) + currentCalendar . get ( Calendar . MINUTE ) ; if ( Utils . isTimeBetweenTwoTimes ( startTime , endTime , currentTime ) ) { return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "} } return prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import androidx . recyclerview . widget . RecyclerView ; import androidx . recyclerview . widget . ItemTouchHelper ; public class SimpleItemTouchHelperCallback extends ItemTouchHelper . Callback { private final ItemTouchHelperAdapter adapter ; public SimpleItemTouchHelperCallback ( ItemTouchHelperAdapter adapter ) { this . adapter = adapter ; }", "output": "@ Override public boolean isLongPressDragEnabled ( ) { return true ; } @ Override public boolean isItemViewSwipeEnabled ( ) { return true ; } @ Override public int getMovementFlags ( RecyclerView recyclerView , RecyclerView . ViewHolder viewHolder ) { int dragFlags = ItemTouchHelper . UP | ItemTouchHelper . DOWN ; int swipeFlags = ItemTouchHelper . START | ItemTouchHelper . END ; return makeMovementFlags ( dragFlags , swipeFlags ) ; } @ Override public boolean onMove ( RecyclerView recyclerView , RecyclerView . ViewHolder viewHolder , RecyclerView . ViewHolder target ) { adapter . onItemMove ( viewHolder . getBindingAdapterPosition ( ) , target . getBindingAdapterPosition ( ) ) ; return true ; } @ Override public void onSwiped ( RecyclerView . ViewHolder viewHolder , int direction ) { adapter . onItemDismiss ( viewHolder . getBindingAdapterPosition ( ) ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . text . Html ; import android . util . Log ; import androidx . annotation . NonNull ; public class HtmlResImageGetter implements Html . ImageGetter { private Context context ; public HtmlResImageGetter ( @ NonNull Context context ) { this . context = context ; } public Drawable getDrawable ( String source ) {", "output": "int id = context . getResources ( ) . getIdentifier ( source , \"<STR_LIT>\" , context . getPackageName ( ) ) ; if ( id == <NUM_LIT> ) { id = context . getResources ( ) . getIdentifier ( source , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } if ( id == <NUM_LIT> ) { Log . e ( HtmlTextView . TAG , \"<STR_LIT>\" + source ) ; return null ; } else { Drawable d = context . getResources ( ) . getDrawable ( id ) ; d . setBounds ( <NUM_LIT> , <NUM_LIT> , d . getIntrinsicWidth ( ) , d . getIntrinsicHeight ( ) ) ; return d ; } } }"}, {"input": "package com . appspa . update ; import android . content . Context ; import android . graphics . drawable . Drawable ; import android . os . Handler ; import android . os . Looper ; import android . text . TextUtils ; import android . util . LruCache ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . impl . DefaultFileEncryptor ; import com . appspa . update . utils . ApkUtils ; import com . appspa . update . listener . impl . DefaultInstallListener ; import com . appspa . update . listener . impl . DefaultUpdateFailureListener ; import com . appspa . update . utils . PatchUtils ; import java . io . File ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; public final class _AppSpace { private static final Map < String , Boolean > sCheckMap = new ConcurrentHashMap < > ( ) ; private static final Map < String , Boolean > sPrompterMap = new ConcurrentHashMap < > ( ) ; private static final Map < String , Runnable > sWaitRunnableMap = new ConcurrentHashMap < > ( ) ; private static final LruCache < String , Drawable > sTopDrawableCache = new LruCache < > ( <NUM_LIT> ) ; private static final Handler sMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; private static final long CHECK_TIMEOUT = <NUM_LIT> * <NUM_LIT> ; public static void setCheckUrlStatus ( final String url , boolean isChecking ) { if ( TextUtils . isEmpty ( url ) ) { return ; } sCheckMap . put ( url , isChecking ) ; Runnable waitRunnable = sWaitRunnableMap . get ( url ) ; if ( waitRunnable != null ) { sMainHandler . removeCallbacks ( waitRunnable ) ; sWaitRunnableMap . remove ( url ) ; } if ( isChecking ) { Runnable newRunnable = new Runnable ( ) { @ Override public void run ( ) { sWaitRunnableMap . remove ( url ) ; sCheckMap . put ( url , false ) ; } } ; sMainHandler . postDelayed ( newRunnable , CHECK_TIMEOUT ) ; sWaitRunnableMap . put ( url , newRunnable ) ; } } public static boolean getCheckUrlStatus ( String url ) { Boolean checkStatus = sCheckMap . get ( url ) ; return checkStatus != null && checkStatus ; } public static void setIsPrompterShow ( String url , boolean isShow ) { if ( TextUtils . isEmpty ( url ) ) { return ; } sPrompterMap . put ( url , isShow ) ; } public static boolean isPrompterShow ( String url ) { Boolean isShow = sPrompterMap . get ( url ) ; return isShow != null && isShow ; } public static String saveTopDrawable ( Drawable drawable ) { String tag = UUID . randomUUID ( ) . toString ( ) ; sTopDrawableCache . put ( tag , drawable ) ; return tag ; } public static Drawable getTopDrawable ( String drawableTag ) { if ( TextUtils . isEmpty ( drawableTag ) ) { return null ; } return sTopDrawableCache . get ( drawableTag ) ; } public static Map < String , Object > getParams ( ) { return AppSpace . get ( ) . mParams ;", "output": "} public static IUpdateHttpService getIUpdateHttpService ( ) { return AppSpace . get ( ) . mUpdateHttpService ; } public static IUpdateChecker getIUpdateChecker ( ) { return AppSpace . get ( ) . mUpdateChecker ; } public static IUpdateParser getIUpdateParser ( ) { return AppSpace . get ( ) . mUpdateParser ; } public static IUpdatePrompter getIUpdatePrompter ( ) { return AppSpace . get ( ) . mUpdatePrompter ; } public static IUpdateDownloader getIUpdateDownLoader ( ) { return AppSpace . get ( ) . mUpdateDownloader ; } public static boolean isGet ( ) { return AppSpace . get ( ) . mIsGet ; } public static boolean isWifiOnly ( ) { return AppSpace . get ( ) . mIsWifiOnly ; } public static boolean isAutoMode ( ) { return AppSpace . get ( ) . mIsAutoMode ; } public static String getApkCacheDir ( ) { return AppSpace . get ( ) . mApkCacheDir ; } public static String encryptFile ( File file ) { if ( AppSpace . get ( ) . mFileEncryptor == null ) { AppSpace . get ( ) . mFileEncryptor = new DefaultFileEncryptor ( ) ; } return AppSpace . get ( ) . mFileEncryptor . encryptFile ( file ) ; } public static boolean isFileValid ( String encrypt , File file ) { if ( AppSpace . get ( ) . mFileEncryptor == null ) { AppSpace . get ( ) . mFileEncryptor = new DefaultFileEncryptor ( ) ; } return AppSpace . get ( ) . mFileEncryptor . isFileValid ( encrypt , file ) ; } public static OnInstallListener getOnInstallListener ( ) { return AppSpace . get ( ) . mOnInstallListener ; } public static void startInstallApk ( @ NonNull Context context , @ NonNull File apkFile ) { startInstallApk ( context , apkFile , new DownloadEntity ( ) ) ; } public static void startInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) { UpdateLog . d ( \"<STR_LIT>\" + apkFile . getAbsolutePath ( ) + \"<STR_LIT>\" + downloadEntity ) ; if ( onInstallApk ( context , apkFile , downloadEntity ) ) { onApkInstallSuccess ( ) ; } else { onUpdateError ( UpdateError . ERROR . INSTALL_FAILED ) ; } } private static boolean onInstallApk ( Context context , File apkFile , DownloadEntity downloadEntity ) { if ( AppSpace . get ( ) . mOnInstallListener == null ) { AppSpace . get ( ) . mOnInstallListener = new DefaultInstallListener ( ) ; } return AppSpace . get ( ) . mOnInstallListener . onInstallApk ( context , apkFile , downloadEntity ) ; } private static void onApkInstallSuccess ( ) { if ( AppSpace . get ( ) . mOnInstallListener == null ) { AppSpace . get ( ) . mOnInstallListener = new DefaultInstallListener ( ) ; } AppSpace . get ( ) . mOnInstallListener . onInstallApkSuccess ( ) ; } public static OnUpdateFailureListener getOnUpdateFailureListener ( ) { return AppSpace . get ( ) . mOnUpdateFailureListener ; } public static void onUpdateError ( int errorCode ) { onUpdateError ( new UpdateError ( errorCode ) ) ; } public static void onUpdateError ( int errorCode , String message ) { onUpdateError ( new UpdateError ( errorCode , message ) ) ; } public static void onUpdateError ( @ NonNull UpdateError updateError ) { if ( AppSpace . get ( ) . mOnUpdateFailureListener == null ) { AppSpace . get ( ) . mOnUpdateFailureListener = new DefaultUpdateFailureListener ( ) ; } AppSpace . get ( ) . mOnUpdateFailureListener . onFailure ( updateError ) ; } }"}, {"input": "package com . reactnative . wheelpicker . wheel ; public interface WheelAdapter < T > { int getItemsCount ( ) ; T getItem ( int index ) ; int indexOf ( T o ) ;", "output": "}"}, {"input": "package com . wmods . wppenhacer . ui . fragments . base ; import android . view . View ; import android . widget . Toast ; import androidx . annotation . IdRes ; import androidx . annotation . StringRes ; import androidx . appcompat . widget . Toolbar ; import androidx . core . view . MenuProvider ; import androidx . fragment . app . Fragment ; import androidx . navigation . NavController ; import androidx . navigation . NavDirections ; import androidx . navigation . fragment . NavHostFragment ; import com . google . android . material . snackbar . Snackbar ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . R ; import java . util . concurrent . Callable ; import java . util . concurrent . Future ; import java . util . concurrent . FutureTask ; public class BaseFragment extends Fragment { public void navigateUp ( ) { getNavController ( ) . navigateUp ( ) ; } public NavController getNavController ( ) { return NavHostFragment . findNavController ( this ) ; } public boolean safeNavigate ( @ IdRes int resId ) { try { getNavController ( ) . navigate ( resId ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public boolean safeNavigate ( NavDirections direction ) { try { getNavController ( ) . navigate ( direction ) ; return true ; } catch ( IllegalArgumentException ignored ) { return false ; } } public void setupToolbar ( Toolbar toolbar , View tipsView , int title ) { setupToolbar ( toolbar , tipsView , getString ( title ) , - <NUM_LIT> ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , int title , int menu ) { setupToolbar ( toolbar , tipsView , getString ( title ) , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu ) { setupToolbar ( toolbar , tipsView , title , menu , null ) ; } public void setupToolbar ( Toolbar toolbar , View tipsView , String title , int menu , View . OnClickListener navigationOnClickListener ) { toolbar . setNavigationOnClickListener ( navigationOnClickListener == null ? ( v -> navigateUp ( ) ) : navigationOnClickListener ) ; toolbar . setNavigationIcon ( R . drawable . ic_baseline_arrow_back_24 ) ; toolbar . setTitle ( title ) ; toolbar . setTooltipText ( title ) ; if ( tipsView != null ) tipsView . setTooltipText ( title ) ; if ( menu != - <NUM_LIT> ) { toolbar . inflateMenu ( menu ) ; if ( this instanceof MenuProvider self ) { toolbar . setOnMenuItemClickListener ( self :: onMenuItemSelected ) ; self . onPrepareMenu ( toolbar . getMenu ( ) ) ; } } } public void runAsync ( Runnable runnable ) { App . getExecutorService ( ) . submit ( runnable ) ; } public < T > Future < T > runAsync ( Callable < T > callable ) { return App . getExecutorService ( ) . submit ( callable ) ; } public void runOnUiThread ( Runnable runnable ) { App . getMainHandler ( ) . post ( runnable ) ; } public < T > Future < T > runOnUiThread ( Callable < T > callable ) { var task = new FutureTask < > ( callable ) ; runOnUiThread ( task ) ; return task ;", "output": "} public void showHint ( @ StringRes int res , boolean lengthShort , @ StringRes int actionRes , View . OnClickListener action ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , App . getInstance ( ) . getString ( actionRes ) , action ) ; } public void showHint ( @ StringRes int res , boolean lengthShort ) { showHint ( App . getInstance ( ) . getString ( res ) , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort ) { showHint ( str , lengthShort , null , null ) ; } public void showHint ( CharSequence str , boolean lengthShort , CharSequence actionStr , View . OnClickListener action ) { var container = getView ( ) ; if ( isResumed ( ) && container != null ) { var snackbar = Snackbar . make ( container , str , lengthShort ? Snackbar . LENGTH_SHORT : Snackbar . LENGTH_LONG ) ; if ( actionStr != null && action != null ) snackbar . setAction ( actionStr , action ) ; snackbar . show ( ) ; return ; } runOnUiThread ( ( ) -> { try { Toast . makeText ( App . getInstance ( ) , str , lengthShort ? Toast . LENGTH_SHORT : Toast . LENGTH_LONG ) . show ( ) ; } catch ( Throwable ignored ) { } } ) ; } }"}, {"input": "package external . org . apache . commons . lang3 . builder ; import external . org . apache . commons . lang3 . ObjectUtils ; public class ToStringBuilder implements Builder < String > { private static volatile ToStringStyle defaultStyle = ToStringStyle . DEFAULT_STYLE ; public static ToStringStyle getDefaultStyle ( ) { return defaultStyle ; } public static void setDefaultStyle ( ToStringStyle style ) { if ( style == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } defaultStyle = style ; } public static String reflectionToString ( Object object ) { return ReflectionToStringBuilder . toString ( object ) ; } public static String reflectionToString ( Object object , ToStringStyle style ) { return ReflectionToStringBuilder . toString ( object , style ) ; } public static String reflectionToString ( Object object , ToStringStyle style , boolean outputTransients ) { return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , null ) ; } public static < T > String reflectionToString ( T object , ToStringStyle style , boolean outputTransients , Class < ? super T > reflectUpToClass ) { return ReflectionToStringBuilder . toString ( object , style , outputTransients , false , reflectUpToClass ) ; } private final StringBuffer buffer ; private final Object object ; private final ToStringStyle style ; public ToStringBuilder ( Object object ) { this ( object , null , null ) ; } public ToStringBuilder ( Object object , ToStringStyle style ) { this ( object , style , null ) ; } public ToStringBuilder ( Object object , ToStringStyle style , StringBuffer buffer ) { if ( style == null ) { style = getDefaultStyle ( ) ; } if ( buffer == null ) { buffer = new StringBuffer ( <NUM_LIT> ) ; } this . buffer = buffer ; this . style = style ; this . object = object ; style . appendStart ( buffer , object ) ; } public ToStringBuilder append ( boolean value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( boolean [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( byte value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( byte [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( char value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( char [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( double value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( double [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( float value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( float [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( int value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( int [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( long value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( long [ ] array ) { style . append ( buffer , null , array , null ) ; return this ;", "output": "} public ToStringBuilder append ( Object obj ) { style . append ( buffer , null , obj , null ) ; return this ; } public ToStringBuilder append ( Object [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( short value ) { style . append ( buffer , null , value ) ; return this ; } public ToStringBuilder append ( short [ ] array ) { style . append ( buffer , null , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , boolean [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , byte value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , byte [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , byte [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , char value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , char [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , char [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , double value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , double [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , double [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , float value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , float [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , float [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , int value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , int [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , int [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , long value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , long [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , long [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , Object obj ) { style . append ( buffer , fieldName , obj , null ) ; return this ; } public ToStringBuilder append ( String fieldName , Object obj , boolean fullDetail ) { style . append ( buffer , fieldName , obj , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , Object [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , Object [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder append ( String fieldName , short value ) { style . append ( buffer , fieldName , value ) ; return this ; } public ToStringBuilder append ( String fieldName , short [ ] array ) { style . append ( buffer , fieldName , array , null ) ; return this ; } public ToStringBuilder append ( String fieldName , short [ ] array , boolean fullDetail ) { style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; } public ToStringBuilder appendAsObjectToString ( Object object ) { ObjectUtils . identityToString ( this . getStringBuffer ( ) , object ) ; return this ; } public ToStringBuilder appendSuper ( String superToString ) { if ( superToString != null ) { style . appendSuper ( buffer , superToString ) ; } return this ; } public ToStringBuilder appendToString ( String toString ) { if ( toString != null ) { style . appendToString ( buffer , toString ) ; } return this ; } public Object getObject ( ) { return object ; } public StringBuffer getStringBuffer ( ) { return buffer ; } public ToStringStyle getStyle ( ) { return style ; } @ Override public String toString ( ) { if ( this . getObject ( ) == null ) { this . getStringBuffer ( ) . append ( this . getStyle ( ) . getNullText ( ) ) ; } else { style . appendEnd ( this . getStringBuffer ( ) , this . getObject ( ) ) ; } return this . getStringBuffer ( ) . toString ( ) ; } public String build ( ) { return toString ( ) ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import android . text . Html ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class WrapperContentHandler implements ContentHandler , Html . TagHandler { private ContentHandler mContentHandler ; private WrapperTagHandler mTagHandler ; private Editable mSpannableStringBuilder ; public WrapperContentHandler ( WrapperTagHandler tagHandler ) { this . mTagHandler = tagHandler ; } @ Override public void handleTag ( boolean opening , String tag , Editable output , XMLReader xmlReader ) { if ( mContentHandler == null ) { mSpannableStringBuilder = output ; mContentHandler = xmlReader . getContentHandler ( ) ; xmlReader . setContentHandler ( this ) ; } } @ Override public void setDocumentLocator ( Locator locator ) { mContentHandler . setDocumentLocator ( locator ) ; } @ Override public void startDocument ( ) throws SAXException { mContentHandler . startDocument ( ) ; } @ Override public void endDocument ( ) throws SAXException { mContentHandler . endDocument ( ) ; }", "output": "@ Override public void startPrefixMapping ( String prefix , String uri ) throws SAXException { mContentHandler . startPrefixMapping ( prefix , uri ) ; } @ Override public void endPrefixMapping ( String prefix ) throws SAXException { mContentHandler . endPrefixMapping ( prefix ) ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { if ( ! mTagHandler . handleTag ( true , localName , mSpannableStringBuilder , attributes ) ) { mContentHandler . startElement ( uri , localName , qName , attributes ) ; } } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( ! mTagHandler . handleTag ( false , localName , mSpannableStringBuilder , null ) ) { mContentHandler . endElement ( uri , localName , qName ) ; } } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { mContentHandler . characters ( ch , start , length ) ; } @ Override public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { mContentHandler . ignorableWhitespace ( ch , start , length ) ; } @ Override public void processingInstruction ( String target , String data ) throws SAXException { mContentHandler . processingInstruction ( target , data ) ; } @ Override public void skippedEntity ( String name ) throws SAXException { mContentHandler . skippedEntity ( name ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class AreaMartialLawCheckTask extends CommentOperateTask < AreaMartialLawCheckTask . EventHandler > { private final CommentUtil commentUtil ; private final boolean isDeputyAccount ; public AreaMartialLawCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentUtil commentUtil , boolean isDeputyAccount ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . commentUtil = commentUtil ; this . isDeputyAccount = isDeputyAccount ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; String randomComment = commentUtil . getRandomComment ( commentArea ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( randomComment , <NUM_LIT> , <NUM_LIT> , commentArea , isDeputyAccount ) ; eventHandler . sendEventMessage ( new EventMessage ( EventHandler . WHAT_ON_TEST_COMMENT_SENT , randomComment ) ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( commentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_MARTIAL_LAW ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_AREA_OK ) ; }", "output": "else { if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_MARTIAL_LAW ) ; statisticsDB . insertMartialLawCommentArea ( commentManipulator . getMartialLawCommentArea ( commentArea , testCommentRpid , isDeputyAccount ) ) ; } commentManipulator . deleteComment ( commentArea , testCommentRpid , isDeputyAccount ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_MARTIAL_LAW ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_TEST_COMMENT_SENT = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_AREA_OK = <NUM_LIT> ; public static final int WHAT_THEN_MARTIAL_LAW = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class LocalFileSelectAdapter extends IIServiceFileSelectAdapter { public LocalFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView , service ) ; currentDir = \"<STR_LIT>\" ; cd ( currentDir ) ; } @ Override public List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException { ArrayList < ParcelableRemoteFile > files = new ArrayList < > ( ) ; int size = service . listLocalFiles ( path ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { files . addAll ( service . pollLocalFiles ( ) ) ;", "output": "} return files ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class LayoutState { static final int LAYOUT_START = - <NUM_LIT> ; static final int LAYOUT_END = <NUM_LIT> ; static final int INVALID_LAYOUT = Integer . MIN_VALUE ; static final int ITEM_DIRECTION_HEAD = - <NUM_LIT> ; static final int ITEM_DIRECTION_TAIL = <NUM_LIT> ; boolean mRecycle = true ; int mAvailable ; int mCurrentPosition ; int mItemDirection ; int mLayoutDirection ; int mStartLine = <NUM_LIT> ; int mEndLine = <NUM_LIT> ; boolean mStopInFocusable ; boolean mInfinite ; boolean hasMore ( RecyclerView . State state ) { return mCurrentPosition >= <NUM_LIT> && mCurrentPosition < state . getItemCount ( ) ;", "output": "} View next ( RecyclerView . Recycler recycler ) { final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition += mItemDirection ; return view ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + mAvailable + \"<STR_LIT>\" + mCurrentPosition + \"<STR_LIT>\" + mItemDirection + \"<STR_LIT>\" + mLayoutDirection + \"<STR_LIT>\" + mStartLine + \"<STR_LIT>\" + mEndLine + '<STR_LIT>' ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . TextView ; public class ConfirmDialog { Dialog dialog ; View dialogView ; public ConfirmDialog ( Context context ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; LayoutInflater inflater = LayoutInflater . from ( context ) ; dialogView = inflater . inflate ( R . layout . confirm_dialog , null ) ; dialog = builder . create ( ) ; setOnConfirmListener ( ( ) -> { } ) ; setOnCancelListener ( ( ) -> { } ) ; } public void show ( ) { dialog . show ( ) ; dialog . getWindow ( ) . setContentView ( dialogView ) ;", "output": "} public void dismiss ( ) { dialog . dismiss ( ) ; } public View getContentView ( ) { return dialogView ; } public ConfirmDialog setOnConfirmListener ( Runnable listener ) { ( dialogView . findViewById ( R . id . cv_dialog_ok ) ) . setOnClickListener ( v -> { listener . run ( ) ; dialog . dismiss ( ) ; } ) ; return this ; } public ConfirmDialog setOnCancelListener ( Runnable listener ) { ( dialogView . findViewById ( R . id . cv_dialog_cancel ) ) . setOnClickListener ( v -> { listener . run ( ) ; dialog . dismiss ( ) ; } ) ; return this ; } public ConfirmDialog setContent ( String content ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_content ) ) . setText ( content ) ; return this ; } public ConfirmDialog setContentAlignment ( int alignment ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_content ) ) . setTextAlignment ( alignment ) ; return this ; } public ConfirmDialog setTitle ( String title ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_title ) ) . setText ( title ) ; return this ; } public ConfirmDialog setOkText ( String text ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_ok ) ) . setText ( text ) ; return this ; } public ConfirmDialog setCancelText ( String text ) { ( ( TextView ) dialogView . findViewById ( R . id . tv_dialog_cancel ) ) . setText ( text ) ; return this ; } public ConfirmDialog setOkButtonVisibility ( int visibility ) { ( dialogView . findViewById ( R . id . cv_dialog_ok ) ) . setVisibility ( visibility ) ; return this ; } public ConfirmDialog setCancelButtonVisibility ( int visibility ) { ( dialogView . findViewById ( R . id . cv_dialog_cancel ) ) . setVisibility ( visibility ) ; return this ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetBundlesResult implements Result { @ NonNull private String [ ] bundleIds ; public GetBundlesResult ( @ NonNull String [ ] bundleIds ) { this . bundleIds = bundleIds ; } public JSObject toJSObject ( ) {", "output": "JSArray bundleIdsResult = new JSArray ( ) ; for ( String bundleId : bundleIds ) { bundleIdsResult . put ( bundleId ) ; } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , bundleIdsResult ) ; return result ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async ; import androidx . annotation . NonNull ; import org . jetbrains . annotations . Nullable ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; public class BiliBiliApiException extends Exception { public final int code ; public final String message ; public final String tipsMessage ; public BiliBiliApiException ( int code , String message , @ Nullable String tipsMessage ) { this . code = code ; this . message = message ; this . tipsMessage = tipsMessage ; } public BiliBiliApiException ( GeneralResponse < ? > response , @ Nullable String tipsMessage ) { super ( String . format ( \"<STR_LIT>\" , tipsMessage , response . code , response . message ) ) ; this . code = response . code ; this . message = response . message ; this . tipsMessage = tipsMessage ; } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + code + \"<STR_LIT>\" + message + '<STR_LIT>' + '<STR_LIT>' ;", "output": "} }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . text . Layout ; import android . text . style . LeadingMarginSpan ; import android . text . style . LineBackgroundSpan ; import androidx . annotation . NonNull ; public class DesignQuoteSpan implements LeadingMarginSpan , LineBackgroundSpan { private int backgroundColor , stripColor ; private float stripeWidth , gap ; DesignQuoteSpan ( int backgroundColor , int stripColor , float stripWidth , float gap ) { this . backgroundColor = backgroundColor ; this . stripColor = stripColor ;", "output": "this . stripeWidth = stripWidth ; this . gap = gap ; } @ Override public int getLeadingMargin ( boolean first ) { return ( int ) ( stripeWidth + gap ) ; } @ Override public void drawLeadingMargin ( Canvas c , Paint p , int x , int dir , int top , int baseline , int bottom , CharSequence text , int start , int end , boolean first , Layout layout ) { Paint . Style style = p . getStyle ( ) ; int paintColor = p . getColor ( ) ; p . setStyle ( Paint . Style . FILL ) ; p . setColor ( stripColor ) ; c . drawRect ( ( float ) x , ( float ) top , x + dir * stripeWidth , ( float ) bottom , p ) ; p . setStyle ( style ) ; p . setColor ( paintColor ) ; } @ Override public void drawBackground ( @ NonNull Canvas canvas , @ NonNull Paint paint , int left , int right , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , int lineNumber ) { int paintColor = paint . getColor ( ) ; paint . setColor ( backgroundColor ) ; canvas . drawRect ( ( float ) left , ( float ) top , ( float ) right , ( float ) bottom , paint ) ; paint . setColor ( paintColor ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . media . AudioManager ; import android . util . Log ; public class HeadsetReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( AudioManager . ACTION_HEADSET_PLUG ) ) { int state = intent . getIntExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; String name = intent . getStringExtra ( \"<STR_LIT>\" ) ; int hasMicrophone = intent . getIntExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; if ( state == <NUM_LIT> ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + name ) ; }", "output": "else if ( state == <NUM_LIT> ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + name ) ; if ( hasMicrophone == <NUM_LIT> ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + name + \"<STR_LIT>\" ) ; } } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + state ) ; } AndroidAudioManager . getInstance ( context ) . routeAudioToEarPiece ( ) ; } else if ( action . equals ( AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidAudioManager . getInstance ( context ) . routeAudioToEarPiece ( ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + action ) ; } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . util . concurrent . BlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . bean . DevicesInterface ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public abstract class TransferThread extends Thread implements DevicesInterface { protected long transferredBytes ; protected final BlockingDeque < FileTransferEvent > events ; public final int device ; protected OnExceptionListener onExceptionListener ; public TransferThread ( BlockingDeque < FileTransferEvent > events , int device ) { this . events = events ; this . device = device ; } public long getAndResetTransferredBytes ( ) { long bytes = transferredBytes ; transferredBytes = <NUM_LIT> ; return bytes ; } protected void addEvent ( int state , String desc ) { if ( events != null ) { events . add ( new FileTransferEvent ( state , device , desc ) ) ; } } public void setOnExceptionListener ( OnExceptionListener onExceptionListener ) { this . onExceptionListener = onExceptionListener ; } public interface OnExceptionListener {", "output": "void onException ( Exception e ) ; } }"}, {"input": "package com . simon . harmonichackernews . data ; public class PollOption { public boolean loaded ; public String text ; public int points ; public int id ;", "output": "}"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . recyclerview . widget . RecyclerView ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . database . SQLiteHelper ; import java . util . Collections ; import java . util . List ; public class RecyclerOverviewListAdapter extends RecyclerView . Adapter < ItemViewHolder > implements ItemTouchHelperAdapter { private Context context ; private final List < CityToWatch > cities ; SQLiteHelper database ; public RecyclerOverviewListAdapter ( Context context , List < CityToWatch > cities ) { this . context = context ; this . cities = cities ; this . database = SQLiteHelper . getInstance ( context ) ; } @ Override public ItemViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . list_item_city_list , parent , false ) ; return new ItemViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ItemViewHolder holder , int position ) { holder . getTvInformation ( ) . setText ( cities . get ( position ) . getCityName ( ) ) ; } @ Override public int getItemCount ( ) { return cities . size ( ) ; } @ Override public void onItemDismiss ( int position ) { CityToWatch city = cities . get ( position ) ; database . deleteCityToWatch ( city ) ; cities . remove ( position ) ; notifyItemRemoved ( position ) ; } @ Override public void onItemMove ( int fromPosition , int toPosition ) { CityToWatch fromCityToWatch = cities . get ( fromPosition ) ; int fromRank = fromCityToWatch . getRank ( ) ; CityToWatch toCityToWatch = cities . get ( toPosition ) ; int toRank = toCityToWatch . getRank ( ) ; fromCityToWatch . setRank ( toRank ) ; toCityToWatch . setRank ( fromRank ) ; database . updateCityToWatch ( fromCityToWatch ) ; database . updateCityToWatch ( toCityToWatch ) ; Collections . swap ( cities , fromPosition , toPosition ) ; notifyItemMoved ( fromPosition , toPosition ) ; } public String getCityName ( int position ) { CityToWatch cityToWatch = cities . get ( position ) ;", "output": "return cityToWatch . getCityName ( ) ; } public void renameCity ( int position , String s ) { CityToWatch cityToWatch = cities . get ( position ) ; cityToWatch . setCityName ( s ) ; database . updateCityToWatch ( cityToWatch ) ; notifyItemChanged ( position ) ; } }"}, {"input": "package external . org . apache . commons . lang3 ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String PACKAGE_SEPARATOR = String . valueOf ( PACKAGE_SEPARATOR_CHAR ) ; public static final char INNER_CLASS_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String INNER_CLASS_SEPARATOR = String . valueOf ( INNER_CLASS_SEPARATOR_CHAR ) ; private static final Map < Class < ? > , Class < ? > > primitiveWrapperMap = new HashMap < Class < ? > , Class < ? > > ( ) ; static { primitiveWrapperMap . put ( Boolean . TYPE , Boolean . class ) ; primitiveWrapperMap . put ( Byte . TYPE , Byte . class ) ; primitiveWrapperMap . put ( Character . TYPE , Character . class ) ; primitiveWrapperMap . put ( Short . TYPE , Short . class ) ; primitiveWrapperMap . put ( Integer . TYPE , Integer . class ) ; primitiveWrapperMap . put ( Long . TYPE , Long . class ) ; primitiveWrapperMap . put ( Double . TYPE , Double . class ) ; primitiveWrapperMap . put ( Float . TYPE , Float . class ) ; primitiveWrapperMap . put ( Void . TYPE , Void . TYPE ) ; } private static final Map < Class < ? > , Class < ? > > wrapperPrimitiveMap = new HashMap < Class < ? > , Class < ? > > ( ) ; static { for ( Class < ? > primitiveClass : primitiveWrapperMap . keySet ( ) ) { Class < ? > wrapperClass = primitiveWrapperMap . get ( primitiveClass ) ; if ( ! primitiveClass . equals ( wrapperClass ) ) { wrapperPrimitiveMap . put ( wrapperClass , primitiveClass ) ; } } } private static final Map < String , String > abbreviationMap = new HashMap < String , String > ( ) ; private static final Map < String , String > reverseAbbreviationMap = new HashMap < String , String > ( ) ; private static void addAbbreviation ( String primitive , String abbreviation ) { abbreviationMap . put ( primitive , abbreviation ) ; reverseAbbreviationMap . put ( abbreviation , primitive ) ; } static { addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; addAbbreviation ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public ClassUtils ( ) { super ( ) ; } public static String getShortClassName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } public static String getShortClassName ( String className ) { if ( className == null ) { return StringUtils . EMPTY ; } if ( className . length ( ) == <NUM_LIT> ) { return StringUtils . EMPTY ; } StringBuilder arrayPrefix = new StringBuilder ( ) ; if ( className . startsWith ( \"<STR_LIT>\" ) ) { while ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; arrayPrefix . append ( \"<STR_LIT>\" ) ; } if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' && className . charAt ( className . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> , className . length ( ) - <NUM_LIT> ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( INNER_CLASS_SEPARATOR_CHAR , lastDotIdx == - <NUM_LIT> ? <NUM_LIT> : lastDotIdx + <NUM_LIT> ) ; String out = className . substring ( lastDotIdx + <NUM_LIT> ) ; if ( innerIdx != - <NUM_LIT> ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } public static String getSimpleName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return cls . getSimpleName ( ) ; } public static String getSimpleName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getSimpleName ( object . getClass ( ) ) ; } public static String getPackageName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } public static String getPackageName ( String className ) { if ( className == null || className . length ( ) == <NUM_LIT> ) { return StringUtils . EMPTY ; } while ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; } if ( className . charAt ( <NUM_LIT> ) == '<STR_LIT>' && className . charAt ( className . length ( ) - <NUM_LIT> ) == '<STR_LIT>' ) { className = className . substring ( <NUM_LIT> ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i == - <NUM_LIT> ) { return StringUtils . EMPTY ; } return className . substring ( <NUM_LIT> , i ) ; } public static List < Class < ? > > getAllSuperclasses ( Class < ? > cls ) { if ( cls == null ) { return null ; } List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; Class < ? > superclass = cls . getSuperclass ( ) ; while ( superclass != null ) { classes . add ( superclass ) ; superclass = superclass . getSuperclass ( ) ; } return classes ; } public static List < Class < ? > > getAllInterfaces ( Class < ? > cls ) { if ( cls == null ) { return null ; } LinkedHashSet < Class < ? > > interfacesFound = new LinkedHashSet < Class < ? > > ( ) ; getAllInterfaces ( cls , interfacesFound ) ; return new ArrayList < Class < ? > > ( interfacesFound ) ; } private static void getAllInterfaces ( Class < ? > cls , HashSet < Class < ? > > interfacesFound ) { while ( cls != null ) { Class < ? > [ ] interfaces = cls . getInterfaces ( ) ; for ( Class < ? > i : interfaces ) { if ( interfacesFound . add ( i ) ) { getAllInterfaces ( i , interfacesFound ) ; } } cls = cls . getSuperclass ( ) ; } } public static List < Class < ? > > convertClassNamesToClasses ( List < String > classNames ) { if ( classNames == null ) { return null ; } List < Class < ? > > classes = new ArrayList < Class < ? > > ( classNames . size ( ) ) ; for ( String className : classNames ) { try { classes . add ( Class . forName ( className ) ) ; } catch ( Exception ex ) { classes . add ( null ) ; } } return classes ; } public static List < String > convertClassesToClassNames ( List < Class < ? > > classes ) { if ( classes == null ) { return null ; } List < String > classNames = new ArrayList < String > ( classes . size ( ) ) ; for ( Class < ? > cls : classes ) { if ( cls == null ) { classNames . add ( null ) ; } else { classNames . add ( cls . getName ( ) ) ; } } return classNames ; } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > ... toClassArray ) { return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_5 ) ) ; } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( ArrayUtils . isSameLength ( classArray , toClassArray ) == false ) { return false ; } if ( classArray == null ) { classArray = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = ArrayUtils . EMPTY_CLASS_ARRAY ; } for ( int i = <NUM_LIT> ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { return false ; } } return true ; } public static boolean isPrimitiveOrWrapper ( Class < ? > type ) { if ( type == null ) { return false ; } return type . isPrimitive ( ) || isPrimitiveWrapper ( type ) ; } public static boolean isPrimitiveWrapper ( Class < ? > type ) { return wrapperPrimitiveMap . containsKey ( type ) ; } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass ) { return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_5 ) ) ; } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass , boolean autoboxing ) { if ( toClass == null ) { return false ; } if ( cls == null ) { return ! toClass . isPrimitive ( ) ; } if ( autoboxing ) { if ( cls . isPrimitive ( ) && ! toClass . isPrimitive ( ) ) { cls = primitiveToWrapper ( cls ) ; if ( cls == null ) { return false ; } } if ( toClass . isPrimitive ( ) && ! cls . isPrimitive ( ) ) { cls = wrapperToPrimitive ( cls ) ; if ( cls == null ) { return false ; } } } if ( cls . equals ( toClass ) ) { return true ; } if ( cls . isPrimitive ( ) ) { if ( toClass . isPrimitive ( ) == false ) { return false ; } if ( Integer . TYPE . equals ( cls ) ) { return Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Long . TYPE . equals ( cls ) ) { return Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Boolean . TYPE . equals ( cls ) ) { return false ; } if ( Double . TYPE . equals ( cls ) ) { return false ; } if ( Float . TYPE . equals ( cls ) ) { return Double . TYPE . equals ( toClass ) ; } if ( Character . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Short . TYPE . equals ( cls ) ) { return Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } if ( Byte . TYPE . equals ( cls ) ) { return Short . TYPE . equals ( toClass ) || Integer . TYPE . equals ( toClass ) || Long . TYPE . equals ( toClass ) || Float . TYPE . equals ( toClass ) || Double . TYPE . equals ( toClass ) ; } return false ; } return toClass . isAssignableFrom ( cls ) ; } public static Class < ? > primitiveToWrapper ( Class < ? > cls ) { Class < ? > convertedClass = cls ; if ( cls != null && cls . isPrimitive ( ) ) { convertedClass = primitiveWrapperMap . get ( cls ) ; } return convertedClass ; } public static Class < ? > [ ] primitivesToWrappers ( Class < ? > ... classes ) { if ( classes == null ) { return null ; } if ( classes . length == <NUM_LIT> ) { return classes ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { convertedClasses [ i ] = primitiveToWrapper ( classes [ i ] ) ; } return convertedClasses ; } public static Class < ? > wrapperToPrimitive ( Class < ? > cls ) { return wrapperPrimitiveMap . get ( cls ) ; } public static Class < ? > [ ] wrappersToPrimitives ( Class < ? > ... classes ) { if ( classes == null ) { return null ; } if ( classes . length == <NUM_LIT> ) { return classes ; } Class < ? > [ ] convertedClasses = new Class [ classes . length ] ; for ( int i = <NUM_LIT> ; i < classes . length ; i ++ ) { convertedClasses [ i ] = wrapperToPrimitive ( classes [ i ] ) ; } return convertedClasses ; } public static boolean isInnerClass ( Class < ? > cls ) { return cls != null && cls . getEnclosingClass ( ) != null ; } public static Class < ? > getClass ( ClassLoader classLoader , String className , boolean initialize ) throws ClassNotFoundException { try { Class < ? > clazz ; if ( abbreviationMap . containsKey ( className ) ) { String clsName = \"<STR_LIT>\" + abbreviationMap . get ( className ) ; clazz = Class . forName ( clsName , initialize , classLoader ) . getComponentType ( ) ; } else { clazz = Class . forName ( toCanonicalName ( className ) , initialize , classLoader ) ; } return clazz ; } catch ( ClassNotFoundException ex ) { int lastDotIndex = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( lastDotIndex != - <NUM_LIT> ) { try { return getClass ( classLoader , className . substring ( <NUM_LIT> , lastDotIndex ) + INNER_CLASS_SEPARATOR_CHAR + className . substring ( lastDotIndex + <NUM_LIT> ) , initialize ) ; } catch ( ClassNotFoundException ex2 ) { } } throw ex ; } } public static Class < ? > getClass ( ClassLoader classLoader , String className ) throws ClassNotFoundException { return getClass ( classLoader , className , true ) ; } public static Class < ? > getClass ( String className ) throws ClassNotFoundException { return getClass ( className , true ) ; } public static Class < ? > getClass ( String className , boolean initialize ) throws ClassNotFoundException { ClassLoader contextCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader loader = contextCL == null ? ClassUtils . class . getClassLoader ( ) : contextCL ; return getClass ( loader , className , initialize ) ; } public static Method getPublicMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) throws SecurityException , NoSuchMethodException { Method declaredMethod = cls . getMethod ( methodName , parameterTypes ) ; if ( Modifier . isPublic ( declaredMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { return declaredMethod ; } List < Class < ? > > candidateClasses = new ArrayList < Class < ? > > ( ) ; candidateClasses . addAll ( getAllInterfaces ( cls ) ) ; candidateClasses . addAll ( getAllSuperclasses ( cls ) ) ; for ( Class < ? > candidateClass : candidateClasses ) { if ( ! Modifier . isPublic ( candidateClass . getModifiers ( ) ) ) { continue ; } Method candidateMethod ; try { candidateMethod = candidateClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException ex ) { continue ; } if ( Modifier . isPublic ( candidateMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { return candidateMethod ; } } throw new NoSuchMethodException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ArrayUtils . toString ( parameterTypes ) ) ; } private static String toCanonicalName ( String className ) { className = StringUtils . deleteWhitespace ( className ) ; if ( className == null ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } else if ( className . endsWith ( \"<STR_LIT>\" ) ) { StringBuilder classNameBuffer = new StringBuilder ( ) ; while ( className . endsWith ( \"<STR_LIT>\" ) ) { className = className . substring ( <NUM_LIT> , className . length ( ) - <NUM_LIT> ) ; classNameBuffer . append ( \"<STR_LIT>\" ) ; } String abbreviation = abbreviationMap . get ( className ) ; if ( abbreviation != null ) { classNameBuffer . append ( abbreviation ) ; } else { classNameBuffer . append ( \"<STR_LIT>\" ) . append ( className ) . append ( \"<STR_LIT>\" ) ; } className = classNameBuffer . toString ( ) ; } return className ; } public static Class < ? > [ ] toClass ( Object ... array ) { if ( array == null ) { return null ; } else if ( array . length == <NUM_LIT> ) { return ArrayUtils . EMPTY_CLASS_ARRAY ; } Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = <NUM_LIT> ; i < array . length ; i ++ ) { classes [ i ] = array [ i ] == null ? null : array [ i ] . getClass ( ) ; } return classes ; } public static String getShortCanonicalName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getShortCanonicalName ( object . getClass ( ) . getName ( ) ) ; } public static String getShortCanonicalName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } public static String getShortCanonicalName ( String canonicalName ) { return ClassUtils . getShortClassName ( getCanonicalName ( canonicalName ) ) ; } public static String getPackageCanonicalName ( Object object , String valueIfNull ) { if ( object == null ) { return valueIfNull ; } return getPackageCanonicalName ( object . getClass ( ) . getName ( ) ) ; } public static String getPackageCanonicalName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } public static String getPackageCanonicalName ( String canonicalName ) { return ClassUtils . getPackageName ( getCanonicalName ( canonicalName ) ) ; } private static String getCanonicalName ( String className ) { className = StringUtils . deleteWhitespace ( className ) ; if ( className == null ) { return null ; } else { int dim = <NUM_LIT> ; while ( className . startsWith ( \"<STR_LIT>\" ) ) { dim ++ ; className = className . substring ( <NUM_LIT> ) ; } if ( dim < <NUM_LIT> ) { return className ; } else { if ( className . startsWith ( \"<STR_LIT>\" ) ) { className = className . substring ( <NUM_LIT> , className . endsWith ( \"<STR_LIT>\" ) ? className . length ( ) - <NUM_LIT> : className . length ( ) ) ; }", "output": "else { if ( className . length ( ) > <NUM_LIT> ) { className = reverseAbbreviationMap . get ( className . substring ( <NUM_LIT> , <NUM_LIT> ) ) ; } } StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ; for ( int i = <NUM_LIT> ; i < dim ; i ++ ) { canonicalClassNameBuffer . append ( \"<STR_LIT>\" ) ; } return canonicalClassNameBuffer . toString ( ) ; } } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . interfaces . Result ; public class GetZoomRatioResult implements Result { private float zoomRatio ; public GetZoomRatioResult ( float zoomRatio ) { this . zoomRatio = zoomRatio ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , zoomRatio ) ; return result ; }", "output": "}"}, {"input": "package external . org . apache . commons . lang3 . tuple ; public final class ImmutablePair < L , R > extends Pair < L , R > { private static final long serialVersionUID = <NUM_LIT> ; public final L left ; public final R right ; public static < L , R > ImmutablePair < L , R > of ( L left , R right ) { return new ImmutablePair < L , R > ( left , right ) ; } public ImmutablePair ( L left , R right ) { super ( ) ; this . left = left ; this . right = right ; } @ Override public L getLeft ( ) { return left ; } @ Override public R getRight ( ) { return right ; } public R setValue ( R value ) { throw new UnsupportedOperationException ( ) ;", "output": "} }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import com . baidu . aip . asrwakeup3 . core . recog . listener . IRecogListener ; import com . baidu . aip . asrwakeup3 . core . recog . listener . RecogEventAdapter ; import java . util . Map ; public class MyRecognizer { private EventManager asr ; private EventListener eventListener ; private static boolean isOfflineEngineLoaded = false ; private static volatile boolean isInited = false ; private static final String TAG = \"<STR_LIT>\" ; public MyRecognizer ( Context context , IRecogListener recogListener ) { this ( context , new RecogEventAdapter ( recogListener ) ) ; } public MyRecognizer ( Context context , EventListener eventListener ) { if ( isInited ) { MyLogger . error ( TAG , \"<STR_LIT>\" ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } isInited = true ; this . eventListener = eventListener ; asr = EventManagerFactory . create ( context , \"<STR_LIT>\" ) ; asr . registerListener ( eventListener ) ; } public void loadOfflineEngine ( Map < String , Object > params ) { String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + \"<STR_LIT>\" , \"<STR_LIT>\" + json ) ; asr . send ( SpeechConstant . ASR_KWS_LOAD_ENGINE , json , null , <NUM_LIT> , <NUM_LIT> ) ; isOfflineEngineLoaded = true ; } public void start ( Map < String , Object > params ) { if ( ! isInited ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + \"<STR_LIT>\" , \"<STR_LIT>\" + json ) ; asr . send ( SpeechConstant . ASR_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; } public void stop ( ) { MyLogger . info ( TAG , \"<STR_LIT>\" ) ; if ( ! isInited ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } asr . send ( SpeechConstant . ASR_STOP , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; } public void cancel ( ) { MyLogger . info ( TAG , \"<STR_LIT>\" ) ; if ( ! isInited ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } asr . send ( SpeechConstant . ASR_CANCEL , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; } public void release ( ) { if ( asr == null ) { return ; } cancel ( ) ; if ( isOfflineEngineLoaded ) { asr . send ( SpeechConstant . ASR_KWS_UNLOAD_ENGINE , null , null , <NUM_LIT> , <NUM_LIT> ) ; isOfflineEngineLoaded = false ; } asr . unregisterListener ( eventListener ) ; asr = null ;", "output": "isInited = false ; } public void setEventListener ( IRecogListener recogListener ) { if ( ! isInited ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } this . eventListener = new RecogEventAdapter ( recogListener ) ; asr . registerListener ( eventListener ) ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . ColorStateList ; import android . content . res . TypedArray ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import androidx . annotation . AttrRes ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . drawable . DrawableCompat ; class Utils { @ ColorInt public static int getColorFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) { ColorStateList colorStateList = getColorStateListFromAttrRes ( attrRes , context ) ; return colorStateList != null ? colorStateList . getDefaultColor ( ) : <NUM_LIT> ; } @ Nullable public static ColorStateList getColorStateListFromAttrRes ( @ AttrRes int attrRes , @ NonNull Context context ) {", "output": "TypedArray a = context . obtainStyledAttributes ( new int [ ] { attrRes } ) ; int resId ; try { resId = a . getResourceId ( <NUM_LIT> , <NUM_LIT> ) ; if ( resId != <NUM_LIT> ) { return AppCompatResources . getColorStateList ( context , resId ) ; } return a . getColorStateList ( <NUM_LIT> ) ; } finally { a . recycle ( ) ; } } @ Nullable public static Drawable getGradientDrawableWithTintAttr ( @ DrawableRes int drawableRes , @ AttrRes int tintAttrRes , @ NonNull Context context ) { Drawable drawable = AppCompatResources . getDrawable ( context , drawableRes ) ; if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . LOLLIPOP_MR1 && drawable instanceof GradientDrawable ) { drawable = DrawableCompat . wrap ( drawable ) ; drawable . setTintList ( getColorStateListFromAttrRes ( tintAttrRes , context ) ) ; } return drawable ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . foregroundservice ; import android . app . Notification ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . os . IBinder ; import androidx . annotation . Nullable ; import com . getcapacitor . Logger ; import java . util . ArrayList ; public class AndroidForegroundService extends Service { @ Nullable @ Override public IBinder onBind ( Intent intent ) { return null ; } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { try { Bundle extras = intent . getExtras ( ) ; Bundle notificationBundle = extras . getBundle ( \"<STR_LIT>\" ) ; String body = notificationBundle . getString ( \"<STR_LIT>\" ) ; int id = notificationBundle . getInt ( \"<STR_LIT>\" ) ; int icon = notificationBundle . getInt ( \"<STR_LIT>\" ) ; String title = notificationBundle . getString ( \"<STR_LIT>\" ) ; ArrayList < Bundle > buttonsBundle = notificationBundle . getParcelableArrayList ( \"<STR_LIT>\" ) ; PendingIntent contentIntent = buildContentIntent ( id ) ; Notification . Builder builder ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { builder = new Notification . Builder ( getApplicationContext ( ) , ForegroundService . DEFAULT_NOTIFICATION_CHANNEL_ID ) ; } else { builder = new Notification . Builder ( getApplicationContext ( ) ) ; } builder . setContentTitle ( title ) . setContentText ( body ) . setContentIntent ( contentIntent ) . setOngoing ( true ) . setSmallIcon ( icon ) . setPriority ( Notification . PRIORITY_HIGH ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { Notification . Action [ ] actions = convertBundlesToNotificationActions ( buttonsBundle . toArray ( new Bundle [ buttonsBundle . size ( ) ] ) ) ; builder . setActions ( actions ) ; } Notification notification = builder . build ( ) ; startForeground ( id , notification ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; } return START_STICKY ; } private PendingIntent buildContentIntent ( int id ) { String packageName = getApplicationContext ( ) . getPackageName ( ) ; Intent intent = getApplicationContext ( ) . getPackageManager ( ) . getLaunchIntentForPackage ( packageName ) ; int pendingIntentFlags ; if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . S ) { pendingIntentFlags = PendingIntent . FLAG_CANCEL_CURRENT | PendingIntent . FLAG_MUTABLE ; } else { pendingIntentFlags = PendingIntent . FLAG_CANCEL_CURRENT ; } return PendingIntent . getActivity ( getApplicationContext ( ) , id , intent , pendingIntentFlags ) ; }", "output": "private Notification . Action [ ] convertBundlesToNotificationActions ( Bundle [ ] bundles ) { Notification . Action [ ] actions = new Notification . Action [ bundles . length ] ; for ( int i = <NUM_LIT> ; i < bundles . length ; i ++ ) { String title = bundles [ i ] . getString ( \"<STR_LIT>\" ) ; int id = bundles [ i ] . getInt ( \"<STR_LIT>\" ) ; Intent intent = new Intent ( this , NotificationActionBroadcastReceiver . class ) ; intent . putExtra ( \"<STR_LIT>\" , id ) ; PendingIntent pendingIntent = PendingIntent . getBroadcast ( this , id , intent , PendingIntent . FLAG_IMMUTABLE | PendingIntent . FLAG_CANCEL_CURRENT ) ; Notification . Action action = new Notification . Action ( <NUM_LIT> , title , pendingIntent ) ; actions [ i ] = action ; } return actions ; } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . Editable ; import android . text . Html ; import android . text . Layout ; import android . text . Spannable ; import android . text . Spanned ; import android . text . style . AlignmentSpan ; import android . text . style . BulletSpan ; import android . text . style . LeadingMarginSpan ; import android . text . style . StrikethroughSpan ; import android . text . style . TypefaceSpan ; import android . text . style . URLSpan ; import android . util . Log ; import android . view . View ; import androidx . annotation . Nullable ; import java . util . Stack ; import org . xml . sax . Attributes ; public class HtmlTagHandler implements WrapperTagHandler { public static final String UNORDERED_LIST = \"<STR_LIT>\" ; public static final String ORDERED_LIST = \"<STR_LIT>\" ; public static final String LIST_ITEM = \"<STR_LIT>\" ; public static final String A_ITEM = \"<STR_LIT>\" ; public static final String PLACEHOLDER_ITEM = \"<STR_LIT>\" ; public HtmlTagHandler ( ) { } String overrideTags ( @ Nullable String html ) { if ( html == null ) return null ; html = \"<STR_LIT>\" + PLACEHOLDER_ITEM + \"<STR_LIT>\" + PLACEHOLDER_ITEM + \"<STR_LIT>\" + html ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + UNORDERED_LIST ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + UNORDERED_LIST + \"<STR_LIT>\" ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + ORDERED_LIST ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + ORDERED_LIST + \"<STR_LIT>\" ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + LIST_ITEM ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + LIST_ITEM + \"<STR_LIT>\" ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + A_ITEM ) ; html = html . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + A_ITEM + \"<STR_LIT>\" ) ; return html ; } Stack < String > lists = new Stack < > ( ) ; Stack < Integer > olNextIndex = new Stack < > ( ) ; StringBuilder tableHtmlBuilder = new StringBuilder ( ) ; int tableTagLevel = <NUM_LIT> ; private static int userGivenIndent = - <NUM_LIT> ; private static final int defaultIndent = <NUM_LIT> ; private static final int defaultListItemIndent = defaultIndent * <NUM_LIT> ; private static final BulletSpan defaultBullet = new BulletSpan ( defaultIndent ) ; private ClickableTableSpan clickableTableSpan ; private DrawTableLinkSpan drawTableLinkSpan ; private HtmlFormatter . TagClickListenerProvider onClickATagListenerProvider ; private static class Ul { } private static class Ol { } private static class A { private String text ; private String href ; private A ( String text , String href ) { this . text = text ; this . href = href ; } } private static class Code { } private static class Center { } private static class Strike { } private static class Table { } private static class Tr { } private static class Th { } private static class Td { } @ Override public boolean handleTag ( boolean opening , String tag , Editable output , Attributes attributes ) { if ( opening ) { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + output . toString ( ) ) ; } if ( tag . equalsIgnoreCase ( UNORDERED_LIST ) ) { lists . push ( tag ) ; } else if ( tag . equalsIgnoreCase ( ORDERED_LIST ) ) { lists . push ( tag ) ; olNextIndex . push ( <NUM_LIT> ) ; } else if ( tag . equalsIgnoreCase ( LIST_ITEM ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( \"<STR_LIT>\" ) ; } if ( ! lists . isEmpty ( ) ) { String parentList = lists . peek ( ) ; if ( parentList . equalsIgnoreCase ( ORDERED_LIST ) ) { start ( output , new Ol ( ) ) ; olNextIndex . push ( olNextIndex . pop ( ) + <NUM_LIT> ) ; } else if ( parentList . equalsIgnoreCase ( UNORDERED_LIST ) ) { start ( output , new Ul ( ) ) ; } } } else if ( tag . equalsIgnoreCase ( A_ITEM ) ) { final String href = attributes != null ? attributes . getValue ( \"<STR_LIT>\" ) : null ; start ( output , new A ( output . toString ( ) , href ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Code ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Center ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) || tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Strike ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Table ( ) ) ; if ( tableTagLevel == <NUM_LIT> ) { tableHtmlBuilder = new StringBuilder ( ) ; output . append ( \"<STR_LIT>\" ) ; } tableTagLevel ++ ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Tr ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Th ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { start ( output , new Td ( ) ) ; } else { return false ; } } else { if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + output . toString ( ) ) ; } if ( tag . equalsIgnoreCase ( UNORDERED_LIST ) ) { lists . pop ( ) ; } else if ( tag . equalsIgnoreCase ( ORDERED_LIST ) ) { lists . pop ( ) ; olNextIndex . pop ( ) ; } else if ( tag . equalsIgnoreCase ( LIST_ITEM ) ) { if ( ! lists . isEmpty ( ) ) { int listItemIndent = ( userGivenIndent > - <NUM_LIT> ) ? ( userGivenIndent * <NUM_LIT> ) : defaultListItemIndent ; if ( lists . peek ( ) . equalsIgnoreCase ( UNORDERED_LIST ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( \"<STR_LIT>\" ) ; } int indent = ( userGivenIndent > - <NUM_LIT> ) ? userGivenIndent : defaultIndent ; BulletSpan bullet = ( userGivenIndent > - <NUM_LIT> ) ? new BulletSpan ( userGivenIndent ) : defaultBullet ; if ( lists . size ( ) > <NUM_LIT> ) { indent = indent - bullet . getLeadingMargin ( true ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent -= ( lists . size ( ) - <NUM_LIT> ) * listItemIndent ; } } BulletSpan newBullet = new BulletSpan ( indent ) ; end ( output , Ul . class , false , new LeadingMarginSpan . Standard ( listItemIndent * ( lists . size ( ) - <NUM_LIT> ) ) , newBullet ) ; } else if ( lists . peek ( ) . equalsIgnoreCase ( ORDERED_LIST ) ) { if ( output . length ( ) > <NUM_LIT> && output . charAt ( output . length ( ) - <NUM_LIT> ) != '<STR_LIT>' ) { output . append ( \"<STR_LIT>\" ) ; } int indent = ( userGivenIndent > - <NUM_LIT> ) ? userGivenIndent : defaultIndent ; NumberSpan span = new NumberSpan ( indent , olNextIndex . lastElement ( ) - <NUM_LIT> ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent = indent - span . getLeadingMargin ( true ) ; if ( lists . size ( ) > <NUM_LIT> ) { indent -= ( lists . size ( ) - <NUM_LIT> ) * listItemIndent ; } } NumberSpan numberSpan = new NumberSpan ( indent , olNextIndex . lastElement ( ) - <NUM_LIT> ) ; end ( output , Ol . class , false , new LeadingMarginSpan . Standard ( listItemIndent * ( lists . size ( ) - <NUM_LIT> ) ) , numberSpan ) ; } } } else if ( tag . equalsIgnoreCase ( A_ITEM ) ) { final Object a = getLast ( output , A . class ) ; final int spanStart = output . getSpanStart ( a ) ; final int spanEnd = output . length ( ) ; final String href = a instanceof A ? ( ( A ) a ) . href : null ; final String spannedText = output . subSequence ( spanStart , spanEnd ) . toString ( ) ; end ( output , A . class , false , new URLSpan ( href ) { @ Override public void onClick ( View widget ) { if ( onClickATagListenerProvider != null && widget != null ) { OnClickATagListener tagClickListener = onClickATagListenerProvider . provideTagClickListener ( ) ; if ( tagClickListener != null ) { boolean clickConsumed = tagClickListener . onClick ( widget , spannedText , getURL ( ) ) ; if ( ! clickConsumed ) { super . onClick ( widget ) ; } } } } } ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Code . class , false , new TypefaceSpan ( \"<STR_LIT>\" ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Center . class , true , new AlignmentSpan . Standard ( Layout . Alignment . ALIGN_CENTER ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) || tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Strike . class , false , new StrikethroughSpan ( ) ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { tableTagLevel -- ; if ( tableTagLevel == <NUM_LIT> ) { final String tableHtml = tableHtmlBuilder . toString ( ) ; ClickableTableSpan myClickableTableSpan = null ; if ( clickableTableSpan != null ) { myClickableTableSpan = clickableTableSpan . newInstance ( ) ; myClickableTableSpan . setTableHtml ( tableHtml ) ; } DrawTableLinkSpan myDrawTableLinkSpan = null ; if ( drawTableLinkSpan != null ) { myDrawTableLinkSpan = drawTableLinkSpan . newInstance ( ) ; } end ( output , Table . class , false , myDrawTableLinkSpan , myClickableTableSpan ) ; } else { end ( output , Table . class , false ) ; } } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Tr . class , false ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Th . class , false ) ; } else if ( tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { end ( output , Td . class , false ) ; } else { return false ; } } storeTableTags ( opening , tag ) ; return true ; } private void storeTableTags ( boolean opening , String tag ) { if ( tableTagLevel > <NUM_LIT> || tag . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { tableHtmlBuilder . append ( \"<STR_LIT>\" ) ; if ( ! opening ) { tableHtmlBuilder . append ( \"<STR_LIT>\" ) ; } tableHtmlBuilder . append ( tag . toLowerCase ( ) ) . append ( \"<STR_LIT>\" ) ; } } private void start ( Editable output , Object mark ) { int len = output . length ( ) ; output . setSpan ( mark , len , len , Spannable . SPAN_MARK_MARK ) ; if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + len ) ; } } private void end ( Editable output , Class kind , boolean paragraphStyle , Object ... replaces ) { Object obj = getLast ( output , kind ) ; int where = output . getSpanStart ( obj ) ; int len = output . length ( ) ; if ( tableTagLevel > <NUM_LIT> ) { final CharSequence extractedSpanText = extractSpanText ( output , kind ) ; tableHtmlBuilder . append ( extractedSpanText ) ; } output . removeSpan ( obj ) ;", "output": "if ( where != len ) { int thisLen = len ; if ( paragraphStyle ) { output . append ( \"<STR_LIT>\" ) ; thisLen ++ ; } for ( Object replace : replaces ) { output . setSpan ( replace , where , thisLen , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; } if ( HtmlTextView . DEBUG ) { Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + where ) ; Log . d ( HtmlTextView . TAG , \"<STR_LIT>\" + thisLen ) ; } } } private CharSequence extractSpanText ( Editable output , Class kind ) { final Object obj = getLast ( output , kind ) ; final int where = output . getSpanStart ( obj ) ; final int len = output . length ( ) ; final CharSequence extractedSpanText = output . subSequence ( where , len ) ; output . delete ( where , len ) ; return extractedSpanText ; } private static Object getLast ( Editable text , Class kind ) { Object [ ] objs = text . getSpans ( <NUM_LIT> , text . length ( ) , kind ) ; if ( objs . length == <NUM_LIT> ) { return null ; } else { for ( int i = objs . length ; i > <NUM_LIT> ; i -- ) { if ( text . getSpanFlags ( objs [ i - <NUM_LIT> ] ) == Spannable . SPAN_MARK_MARK ) { return objs [ i - <NUM_LIT> ] ; } } return null ; } } public void setListIndentPx ( float px ) { userGivenIndent = Math . round ( px ) ; } public void setClickableTableSpan ( ClickableTableSpan clickableTableSpan ) { this . clickableTableSpan = clickableTableSpan ; } public void setDrawTableLinkSpan ( DrawTableLinkSpan drawTableLinkSpan ) { this . drawTableLinkSpan = drawTableLinkSpan ; } public void setOnClickATagListenerProvider ( HtmlFormatter . TagClickListenerProvider onClickATagListenerProvider ) { this . onClickATagListenerProvider = onClickATagListenerProvider ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . accessibilityservice . AccessibilityService ; import android . app . ActivityManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Intent ; import android . media . AudioManager ; import android . os . Handler ; import android . os . Vibrator ; import android . util . Log ; import android . view . KeyEvent ; import android . view . accessibility . AccessibilityEvent ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; import java . util . List ; public class MyAccessbilityService extends AccessibilityService { private static boolean isConnected = false ; private Handler handler = new Handler ( ) ; private int keyDownTime = <NUM_LIT> , keyUpTime = <NUM_LIT> ; private boolean isWaitingConfirm = false ; private int pressCount = <NUM_LIT> ; private boolean isPressing = false ; private boolean isBaned = false ; private boolean isInStartDelay = false ; AudioManager audioManager ; Vibrator vibrator ; final private int longPressTime = <NUM_LIT> ; final private int maxConfirmTime = <NUM_LIT> ; final private int banCancelInterval = <NUM_LIT> ; public MyAccessbilityService ( ) { } @ Override public void onAccessibilityEvent ( AccessibilityEvent accessibilityEvent ) { } @ Override public void onInterrupt ( ) { } @ Override protected boolean onKeyEvent ( KeyEvent event ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + event . toString ( ) ) ; if ( event . getKeyCode ( ) != KeyEvent . KEYCODE_VOLUME_DOWN ) { return super . onKeyEvent ( event ) ; } int eventTime = ( int ) event . getEventTime ( ) ; int eventAction = event . getAction ( ) ; if ( isBaned ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { keyDownTime = eventTime ; if ( eventTime - keyUpTime < banCancelInterval ) { return super . onKeyEvent ( event ) ; } else { isBaned = false ; } } else if ( eventAction == KeyEvent . ACTION_UP ) { keyUpTime = eventTime ; return super . onKeyEvent ( event ) ; } } if ( pressCount == <NUM_LIT> ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { keyDownTime = eventTime ; isPressing = true ; handler . postDelayed ( ( ) -> { if ( isPressing ) { if ( ! MainActivity . isAlive ( ) || ! MainActivity . isRunning ( ) ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; isInStartDelay = true ; handler . postDelayed ( ( ) -> { if ( isInStartDelay ) { Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } } , <NUM_LIT> ) ; } else { Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } vibrator . vibrate ( <NUM_LIT> ) ; } } , longPressTime ) ; return true ; } else if ( eventAction == KeyEvent . ACTION_UP ) { keyUpTime = eventTime ; isPressing = false ; isInStartDelay = false ; if ( eventTime - keyDownTime < longPressTime ) { isBaned = true ; audioManager . adjustVolume ( AudioManager . ADJUST_LOWER , AudioManager . FLAG_SHOW_UI ) ; return true ; } else { pressCount ++ ; Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; isWaitingConfirm = true ; handler . postDelayed ( ( ) -> { if ( isWaitingConfirm ) { pressCount = <NUM_LIT> ; } } , maxConfirmTime ) ; return true ; } } } else if ( pressCount == <NUM_LIT> ) { if ( eventAction == KeyEvent . ACTION_DOWN ) { isWaitingConfirm = false ; keyDownTime = eventTime ; if ( eventTime - keyUpTime < maxConfirmTime ) { Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return true ; } else { return super . onKeyEvent ( event ) ; } } else if ( eventAction == KeyEvent . ACTION_UP ) { if ( keyDownTime - keyUpTime < maxConfirmTime ) { keyUpTime = eventTime ; pressCount = <NUM_LIT> ; return true ; } else { keyUpTime = eventTime ; pressCount = <NUM_LIT> ; return super . onKeyEvent ( event ) ; }", "output": "} } return super . onKeyEvent ( event ) ; } @ Override protected void onServiceConnected ( ) { super . onServiceConnected ( ) ; isConnected = true ; audioManager = ( AudioManager ) getSystemService ( AUDIO_SERVICE ) ; vibrator = ( Vibrator ) getSystemService ( Service . VIBRATOR_SERVICE ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; isConnected = false ; } public static boolean isConnected ( ) { return isConnected ; } }"}, {"input": "package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . card . MaterialCardView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . Category ; import in . hridayan . ashell . activities . ChangelogActivity ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; public class AboutAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { private static final int CATEGORY = <NUM_LIT> ; private static final int CATEGORY_LEAD_DEV_ITEM = <NUM_LIT> ; private static final int CATEGORY_CONTRIBUTORS_ITEM = <NUM_LIT> ; private static final int CATEGORY_APP_ITEM = <NUM_LIT> ; private AdapterListener mListener ; private List < Object > items ; private Context context ; public AboutAdapter ( List < Object > items , Context context ) { this . items = items ; this . context = context ; } public interface AdapterListener { void onCheckUpdate ( ) ; } public void setAdapterListener ( AdapterListener listener ) { mListener = listener ; } @ Override public int getItemViewType ( int position ) { Object item = items . get ( position ) ; if ( item instanceof Category ) { return CATEGORY ; } else if ( item instanceof Category . LeadDeveloperItem ) { return CATEGORY_LEAD_DEV_ITEM ; } else if ( item instanceof Category . ContributorsItem ) { return CATEGORY_CONTRIBUTORS_ITEM ; } else if ( item instanceof Category . AppItem ) { return CATEGORY_APP_ITEM ; } return - <NUM_LIT> ; } @ NonNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; switch ( viewType ) { case CATEGORY : View categoryView = inflater . inflate ( R . layout . category_about , parent , false ) ; return new CategoryViewHolder ( categoryView ) ; case CATEGORY_LEAD_DEV_ITEM : View leadDevItemView = inflater . inflate ( R . layout . category_lead_dev , parent , false ) ; return new LeadDeveloperItemViewHolder ( leadDevItemView ) ; case CATEGORY_CONTRIBUTORS_ITEM : View contributorsItemView = inflater . inflate ( R . layout . category_contributors , parent , false ) ; return new contributorsItemViewHolder ( contributorsItemView ) ; case CATEGORY_APP_ITEM : View appItemView = inflater . inflate ( R . layout . category_app , parent , false ) ; return new AppItemViewHolder ( appItemView ) ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position ) { Object item = items . get ( position ) ; if ( holder instanceof CategoryViewHolder ) { Category category = ( Category ) item ; CategoryViewHolder categoryViewHolder = ( CategoryViewHolder ) holder ; categoryViewHolder . categoryTextView . setText ( category . getName ( ) ) ; } else if ( holder instanceof LeadDeveloperItemViewHolder ) { Category . LeadDeveloperItem categoryAItem = ( Category . LeadDeveloperItem ) item ; LeadDeveloperItemViewHolder viewHolder = ( LeadDeveloperItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( categoryAItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( categoryAItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( categoryAItem . getDescription ( ) ) ; Map < View , String > buttonUrlMap = new HashMap < > ( ) ; buttonUrlMap . put ( viewHolder . mXButton , \"<STR_LIT>\" ) ; buttonUrlMap . put ( viewHolder . mGithubButton , \"<STR_LIT>\" ) ; buttonUrlMap . put ( viewHolder . mMailButton , \"<STR_LIT>\" ) ; buttonUrlMap . put ( viewHolder . mSupportButton , \"<STR_LIT>\" ) ; for ( Map . Entry < View , String > entry : buttonUrlMap . entrySet ( ) ) { entry . getKey ( ) . setOnClickListener ( v -> Utils . openUrl ( context , entry . getValue ( ) ) ) ; } } else if ( holder instanceof contributorsItemViewHolder ) { Category . ContributorsItem ContributorsItem = ( Category . ContributorsItem ) item ; contributorsItemViewHolder viewHolder = ( contributorsItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( ContributorsItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( ContributorsItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( ContributorsItem . getDescription ( ) ) ; View . OnClickListener clickListener = v -> { Map < String , String > idUrlMap = new HashMap < > ( ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String id = ContributorsItem . getId ( ) ; String url = idUrlMap . get ( id ) ; if ( url != null ) { Utils . openUrl ( context , url ) ; } } ; viewHolder . buttonView . setOnClickListener ( clickListener ) ; viewHolder . categoryContributorsLayout . setOnClickListener ( v -> { } ) ; viewHolder . categoryContributorsLayout . setStrokeWidth ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? <NUM_LIT> : <NUM_LIT> ) ; } else if ( holder instanceof AppItemViewHolder ) { Category . AppItem categoryCItem = ( Category . AppItem ) item ; AppItemViewHolder viewHolder = ( AppItemViewHolder ) holder ; viewHolder . imageView . setImageResource ( categoryCItem . getImageResource ( ) ) ; viewHolder . titleTextView . setText ( categoryCItem . getTitle ( ) ) ; viewHolder . descriptionTextView . setText ( categoryCItem . getDescription ( ) ) ; View . OnClickListener clickListener = v -> { Map < String , String > idUrlMap = new HashMap < > ( ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; idUrlMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String id = categoryCItem . getId ( ) ; String url = idUrlMap . get ( id ) ; if ( url != null ) { Utils . openUrl ( context , url ) ; } Intent intent ; switch ( id ) { case \"<STR_LIT>\" : intent = new Intent ( context , ChangelogActivity . class ) ; break ; default : return ; } context . startActivity ( intent ) ; } ; if ( categoryCItem . getId ( ) . equals ( \"<STR_LIT>\" ) ) { viewHolder . button . setVisibility ( View . VISIBLE ) ; viewHolder . button . setOnClickListener ( v -> { if ( mListener != null ) { mListener . onCheckUpdate ( ) ; } } ) ; } else { viewHolder . button . setVisibility ( View . GONE ) ; } viewHolder . categoryAppLayout . setOnClickListener ( clickListener ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == items . size ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; viewHolder . itemView . setLayoutParams ( layoutParams ) ;", "output": "} } @ Override public int getItemCount ( ) { return items . size ( ) ; } private static class CategoryViewHolder extends RecyclerView . ViewHolder { TextView categoryTextView ; public CategoryViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; categoryTextView = itemView . findViewById ( R . id . category_text_view ) ; } } private static class LeadDeveloperItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; Button mMailButton , mXButton , mGithubButton , mSupportButton ; public LeadDeveloperItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; mMailButton = itemView . findViewById ( R . id . mail ) ; mGithubButton = itemView . findViewById ( R . id . github ) ; mXButton = itemView . findViewById ( R . id . x ) ; mSupportButton = itemView . findViewById ( R . id . support ) ; } } private static class contributorsItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; Button buttonView ; MaterialCardView categoryContributorsLayout ; public contributorsItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; buttonView = itemView . findViewById ( R . id . github_handle ) ; categoryContributorsLayout = itemView . findViewById ( R . id . category_contributors_layout ) ; } } private static class AppItemViewHolder extends RecyclerView . ViewHolder { ImageView imageView ; TextView titleTextView , descriptionTextView ; LinearLayout categoryAppLayout ; MaterialButton button ; public AppItemViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; imageView = itemView . findViewById ( R . id . image_view ) ; titleTextView = itemView . findViewById ( R . id . title_text_view ) ; descriptionTextView = itemView . findViewById ( R . id . description_text_view ) ; button = itemView . findViewById ( R . id . button ) ; categoryAppLayout = itemView . findViewById ( R . id . category_app_layout ) ; } } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . GridLayoutManager ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; class RecyclerViewHelper implements FastScroller . ViewHelper { @ NonNull private final RecyclerView mView ; @ Nullable private final PopupTextProvider mPopupTextProvider ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public RecyclerViewHelper ( @ NonNull RecyclerView view , @ Nullable PopupTextProvider popupTextProvider ) { mView = view ; mPopupTextProvider = popupTextProvider ; } @ Override public void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) { mView . addItemDecoration ( new RecyclerView . ItemDecoration ( ) { @ Override public void onDraw ( @ NonNull Canvas canvas , @ NonNull RecyclerView parent , @ NonNull RecyclerView . State state ) { onPreDraw . run ( ) ; } } ) ; } @ Override public void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) { mView . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { onScrollChanged . run ( ) ; } } ) ; } @ Override public void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) { mView . addOnItemTouchListener ( new RecyclerView . SimpleOnItemTouchListener ( ) { @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { return onTouchEvent . test ( event ) ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { onTouchEvent . test ( event ) ; } } ) ; } @ Override public int getScrollRange ( ) { int itemCount = getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; if ( itemHeight == <NUM_LIT> ) { return <NUM_LIT> ; } return mView . getPaddingTop ( ) + itemCount * itemHeight + mView . getPaddingBottom ( ) ; } @ Override public int getScrollOffset ( ) { int firstItemPosition = getFirstItemPosition ( ) ; if ( firstItemPosition == RecyclerView . NO_POSITION ) { return <NUM_LIT> ; } int itemHeight = getItemHeight ( ) ; int firstItemTop = getFirstItemOffset ( ) ; return mView . getPaddingTop ( ) + firstItemPosition * itemHeight - firstItemTop ; } @ Override public void scrollTo ( int offset ) { mView . stopScroll ( ) ; offset -= mView . getPaddingTop ( ) ; int itemHeight = getItemHeight ( ) ; int firstItemPosition = Math . max ( <NUM_LIT> , offset / itemHeight ) ; int firstItemTop = firstItemPosition * itemHeight - offset ; scrollToPositionWithOffset ( firstItemPosition , firstItemTop ) ; } @ Nullable @ Override public CharSequence getPopupText ( ) { PopupTextProvider popupTextProvider = mPopupTextProvider ; if ( popupTextProvider == null ) { RecyclerView . Adapter < ? > adapter = mView . getAdapter ( ) ; if ( adapter instanceof PopupTextProvider ) { popupTextProvider = ( PopupTextProvider ) adapter ; } } if ( popupTextProvider == null ) { return null ; } int position = getFirstItemAdapterPosition ( ) ; if ( position == RecyclerView . NO_POSITION ) { return null ; } return popupTextProvider . getPopupText ( mView , position ) ; } private int getItemCount ( ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return <NUM_LIT> ; } int itemCount = linearLayoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return <NUM_LIT> ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; itemCount = ( itemCount - <NUM_LIT> ) / gridLayoutManager . getSpanCount ( ) + <NUM_LIT> ; } return itemCount ; } private int getItemHeight ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . height ( ) ; } private int getFirstItemPosition ( ) { int position = getFirstItemAdapterPosition ( ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position /= gridLayoutManager . getSpanCount ( ) ; } return position ; } private int getFirstItemAdapterPosition ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return RecyclerView . NO_POSITION ; } return linearLayoutManager . getPosition ( itemView ) ; } private int getFirstItemOffset ( ) { if ( mView . getChildCount ( ) == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } View itemView = mView . getChildAt ( <NUM_LIT> ) ; mView . getDecoratedBoundsWithMargins ( itemView , mTempRect ) ; return mTempRect . top ; } private void scrollToPositionWithOffset ( int position , int offset ) { LinearLayoutManager linearLayoutManager = getVerticalLinearLayoutManager ( ) ; if ( linearLayoutManager == null ) { return ; } if ( linearLayoutManager instanceof GridLayoutManager ) { GridLayoutManager gridLayoutManager = ( GridLayoutManager ) linearLayoutManager ; position *= gridLayoutManager . getSpanCount ( ) ; }", "output": "offset -= mView . getPaddingTop ( ) ; linearLayoutManager . scrollToPositionWithOffset ( position , offset ) ; } @ Nullable private LinearLayoutManager getVerticalLinearLayoutManager ( ) { RecyclerView . LayoutManager layoutManager = mView . getLayoutManager ( ) ; if ( ! ( layoutManager instanceof LinearLayoutManager ) ) { return null ; } LinearLayoutManager linearLayoutManager = ( LinearLayoutManager ) layoutManager ; if ( linearLayoutManager . getOrientation ( ) != RecyclerView . VERTICAL ) { return null ; } return linearLayoutManager ; } }"}, {"input": "package com . reactnativecommunity . webview ; import static com . reactnativecommunity . webview . RNCWebViewManager . REACT_CLASS ; import com . facebook . react . module . annotations . ReactModule ; import com . facebook . react . uimanager . ThemedReactContext ; @ ReactModule ( name = REACT_CLASS ) public class RNCNestedScrollWebViewManager extends RNCWebViewManager { @ Override protected RNCWebView createRNCWebViewInstance ( ThemedReactContext reactContext ) { return new RNCNestedScrollWebView ( reactContext ) ;", "output": "} @ Override public boolean canOverrideExistingModule ( ) { return true ; } }"}, {"input": "package com . wmods . wppenhacer . activities ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . ActivityAboutBinding ; public class AboutActivity extends AppCompatActivity { private ActivityAboutBinding binding ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; binding = ActivityAboutBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; binding . btnTelegram . setOnClickListener ( v -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" ) ) ; startActivity ( intent ) ; } ) ; binding . btnGithub . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" ) ) ; startActivity ( intent ) ; } ) ; binding . btnDonate . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . setAction ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" ) ) ; startActivity ( intent ) ; } ) ; }", "output": "}"}, {"input": "package me . zhanghai . android . fastscroll ; import androidx . annotation . NonNull ; public interface ViewHelperProvider { @ NonNull FastScroller . ViewHelper getViewHelper ( ) ;", "output": "}"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . recog . IStatus ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public class StatusRecogListener implements IRecogListener , IStatus { private static final String TAG = \"<STR_LIT>\" ; protected int status = STATUS_NONE ; @ Override public void onAsrReady ( ) { status = STATUS_READY ; } @ Override public void onAsrBegin ( ) { status = STATUS_SPEAKING ; } @ Override public void onAsrEnd ( ) { status = STATUS_RECOGNITION ; } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrFinish ( RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { status = STATUS_FINISHED ; } @ Override public void onAsrLongFinish ( ) { status = STATUS_LONG_SPEECH_FINISHED ; }", "output": "@ Override public void onAsrVolume ( int volumePercent , int volume ) { Log . i ( TAG , \"<STR_LIT>\" + volumePercent + \"<STR_LIT>\" + volume ) ; } @ Override public void onAsrAudio ( byte [ ] data , int offset , int length ) { if ( offset != <NUM_LIT> || data . length != length ) { byte [ ] actualData = new byte [ length ] ; System . arraycopy ( data , <NUM_LIT> , actualData , <NUM_LIT> , length ) ; data = actualData ; } Log . i ( TAG , \"<STR_LIT>\" + data . length ) ; } @ Override public void onAsrExit ( ) { status = STATUS_NONE ; } @ Override public void onAsrOnlineNluResult ( String nluResult ) { status = STATUS_FINISHED ; } @ Override public void onOfflineLoaded ( ) { } @ Override public void onOfflineUnLoaded ( ) { } }"}, {"input": "package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . IUpdateParseCallback ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateProxy ; import com . appspa . update . service . DownloadService ; import com . appspa . update . utils . UpdateUtils ; import java . util . Map ; public class DefaultUpdateChecker implements IUpdateChecker { @ Override public void onBeforeCheck ( ) { } @ Override public void checkVersion ( boolean isGet , @ NonNull final String url , @ NonNull Map < String , Object > params , final @ NonNull IUpdateProxy updateProxy ) { if ( DownloadService . isRunning ( ) || _AppSpace . getCheckUrlStatus ( url ) || _AppSpace . isPrompterShow ( url ) ) { updateProxy . onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_UPDATING ) ; return ; } _AppSpace . setCheckUrlStatus ( url , true ) ; if ( isGet ) { updateProxy . getIUpdateHttpService ( ) . asyncGet ( url , params , new IUpdateHttpService . Callback ( ) { @ Override public void onSuccess ( String result ) { onCheckSuccess ( url , result , updateProxy ) ; } @ Override public void onError ( Throwable error ) { onCheckError ( url , updateProxy , error ) ; } } ) ; } else { updateProxy . getIUpdateHttpService ( ) . asyncPost ( url , params , new IUpdateHttpService . Callback ( ) { @ Override public void onSuccess ( String result ) { onCheckSuccess ( url , result , updateProxy ) ; } @ Override public void onError ( Throwable error ) { onCheckError ( url , updateProxy , error ) ; } } ) ;", "output": "} } @ Override public void onAfterCheck ( ) { } private void onCheckSuccess ( String url , String result , @ NonNull IUpdateProxy updateProxy ) { _AppSpace . setCheckUrlStatus ( url , false ) ; updateProxy . onAfterCheck ( ) ; if ( ! TextUtils . isEmpty ( result ) ) { processCheckResult ( result , updateProxy ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_JSON_EMPTY ) ; } } private void onCheckError ( String url , @ NonNull IUpdateProxy updateProxy , Throwable error ) { _AppSpace . setCheckUrlStatus ( url , false ) ; updateProxy . onAfterCheck ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NET_REQUEST , error . getMessage ( ) ) ; } @ Override public void processCheckResult ( final @ NonNull String result , final @ NonNull IUpdateProxy updateProxy ) { try { if ( updateProxy . isAsyncParser ( ) ) { updateProxy . parseJson ( result , new IUpdateParseCallback ( ) { @ Override public void onParseResult ( UpdateEntity updateEntity ) { try { UpdateUtils . processUpdateEntity ( updateEntity , result , updateProxy ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , e . getMessage ( ) ) ; } } } ) ; } else { UpdateUtils . processUpdateEntity ( updateProxy . parseJson ( result ) , result , updateProxy ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_PARSE , e . getMessage ( ) ) ; } } @ Override public void noNewVersion ( Throwable throwable ) { _AppSpace . onUpdateError ( UpdateError . ERROR . CHECK_NO_NEW_VERSION , throwable != null ? throwable . getMessage ( ) : null ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . RestrictTo ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; public final class AsyncDifferConfig < T > { @ Nullable private final Executor mMainThreadExecutor ; @ NonNull private final Executor mBackgroundThreadExecutor ; @ NonNull private final DiffUtil . ItemCallback < T > mDiffCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) AsyncDifferConfig ( @ Nullable Executor mainThreadExecutor , @ NonNull Executor backgroundThreadExecutor , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mMainThreadExecutor = mainThreadExecutor ; mBackgroundThreadExecutor = backgroundThreadExecutor ; mDiffCallback = diffCallback ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ Nullable public Executor getMainThreadExecutor ( ) { return mMainThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public Executor getBackgroundThreadExecutor ( ) { return mBackgroundThreadExecutor ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ NonNull public DiffUtil . ItemCallback < T > getDiffCallback ( ) { return mDiffCallback ; } public static final class Builder < T > { @ Nullable private Executor mMainThreadExecutor ; private Executor mBackgroundThreadExecutor ; private final DiffUtil . ItemCallback < T > mDiffCallback ; public Builder ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffCallback = diffCallback ; } @ RestrictTo ( RestrictTo . Scope . LIBRARY ) @ NonNull public Builder < T > setMainThreadExecutor ( @ Nullable Executor executor ) { mMainThreadExecutor = executor ; return this ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ NonNull public Builder < T > setBackgroundThreadExecutor ( @ Nullable Executor executor ) { mBackgroundThreadExecutor = executor ; return this ; } @ NonNull public AsyncDifferConfig < T > build ( ) { if ( mBackgroundThreadExecutor == null ) { synchronized ( sExecutorLock ) { if ( sDiffExecutor == null ) { sDiffExecutor = Executors . newFixedThreadPool ( <NUM_LIT> ) ; } } mBackgroundThreadExecutor = sDiffExecutor ; } return new AsyncDifferConfig < > ( mMainThreadExecutor , mBackgroundThreadExecutor , mDiffCallback ) ; } private static final Object sExecutorLock = new Object ( ) ;", "output": "private static Executor sDiffExecutor = null ; } }"}, {"input": "package com . appspa . demo ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ;", "output": "} }"}, {"input": "package com . norman . webviewup . lib . service . proxy ; import android . content . ComponentName ; import android . content . pm . PackageInfo ; import com . norman . webviewup . lib . reflect . RuntimeProxy ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( \"<STR_LIT>\" ) public abstract class PackageManagerProxy extends RuntimeProxy { public PackageManagerProxy ( ) { super ( ) ; } @ Method ( \"<STR_LIT>\" ) protected abstract PackageInfo getPackageInfo ( String packageName , long flags , int userId ) ; @ Method ( \"<STR_LIT>\" ) protected abstract PackageInfo getPackageInfo ( String packageName , int flags , int userId ) ; @ Method ( \"<STR_LIT>\" ) protected abstract PackageInfo getPackageInfo ( String packageName , int flags ) ; @ Method ( \"<STR_LIT>\" ) protected abstract int getComponentEnabledSetting ( ComponentName componentName , int userId ) ; @ Method ( \"<STR_LIT>\" ) protected abstract int getComponentEnabledSetting ( ComponentName componentName ) ;", "output": "@ Method ( \"<STR_LIT>\" ) protected abstract String getInstallerPackageName ( String packageName ) ; @ Method ( \"<STR_LIT>\" ) protected abstract android . os . IBinder asBinder ( ) ; }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . wakeup ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . listener . IWakeupListener ; import com . baidu . speech . EventListener ; import com . baidu . speech . asr . SpeechConstant ; public class WakeupEventAdapter implements EventListener { private IWakeupListener listener ; public WakeupEventAdapter ( IWakeupListener listener ) { this . listener = listener ; } private static final String TAG = \"<STR_LIT>\" ; @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { MyLogger . info ( TAG , \"<STR_LIT>\" + name + \"<STR_LIT>\" + params ) ; if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_SUCCESS . equals ( name ) ) { WakeUpResult result = WakeUpResult . parseJson ( name , params ) ; int errorCode = result . getErrorCode ( ) ; if ( result . hasError ( ) ) { listener . onError ( errorCode , \"<STR_LIT>\" , result ) ; } else { String word = result . getWord ( ) ; listener . onSuccess ( word , result ) ; } } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_ERROR . equals ( name ) ) { WakeUpResult result = WakeUpResult . parseJson ( name , params ) ; int errorCode = result . getErrorCode ( ) ; if ( result . hasError ( ) ) { listener . onError ( errorCode , \"<STR_LIT>\" , result ) ;", "output": "} } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_STOPED . equals ( name ) ) { listener . onStop ( ) ; } else if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_AUDIO . equals ( name ) ) { listener . onASrAudio ( data , offset , length ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . photoeditor ; import android . app . Activity ; import android . content . Intent ; import androidx . activity . result . ActivityResult ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class PhotoEditorPlugin extends Plugin { public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_EDIT_PHOTO_FAILED = \"<STR_LIT>\" ; public static final String ERROR_EDIT_PHOTO_CANCELED = \"<STR_LIT>\" ; private PhotoEditor implementation ; @ Override public void load ( ) { implementation = new PhotoEditor ( getBridge ( ) ) ; } @ PluginMethod public void editPhoto ( PluginCall call ) { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ;", "output": "} Intent intent = implementation . createEditPhotoIntent ( path ) ; if ( intent == null ) { call . reject ( ERROR_EDIT_PHOTO_FAILED ) ; return ; } startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; } @ ActivityCallback private void handleEditPhotoResult ( PluginCall call , ActivityResult result ) { if ( call == null ) { return ; } int resultCode = result . getResultCode ( ) ; switch ( resultCode ) { case Activity . RESULT_OK : call . resolve ( ) ; break ; case Activity . RESULT_CANCELED : call . reject ( ERROR_EDIT_PHOTO_CANCELED ) ; break ; default : call . reject ( ERROR_EDIT_PHOTO_FAILED ) ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . xposed . features . customization . SeparateGroup . tabs ; import android . os . Bundle ; import android . view . MenuItem ; import android . view . View ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . ArrayList ; import java . util . List ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class HideTabs extends Feature { private Object mTabPagerInstance ; public HideTabs ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var hidetabs = prefs . getStringSet ( \"<STR_LIT>\" , null ) ; var igstatus = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( hidetabs == null || hidetabs . isEmpty ( ) ) return ; var home = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var hideTabsList = hidetabs . stream ( ) . map ( Integer :: valueOf ) . collect ( Collectors . toList ( ) ) ; var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var ListField = Unobfuscator . getFieldByType ( home , List . class ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var list = ( List < Integer > ) XposedHelpers . getStaticObjectField ( home , ListField . getName ( ) ) ; for ( var item : hideTabsList ) { if ( item != SeparateGroup . STATUS || ! igstatus ) { list . remove ( item ) ; } } } } ) ; var OnTabItemAddMethod = Unobfuscator . loadOnTabItemAddMethod ( classLoader ) ; XposedBridge . hookMethod ( OnTabItemAddMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menuItem = ( MenuItem ) param . getResult ( ) ; var menuItemId = menuItem . getItemId ( ) ; if ( hideTabsList . contains ( menuItemId ) ) { menuItem . setVisible ( false ) ; } } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; logDebug ( loadTabFrameClass ) ; XposedBridge . hookAllMethods ( FrameLayout . class , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; if ( tabs != null ) { var arr = new ArrayList < > ( tabs ) ; arr . removeAll ( hideTabsList ) ; if ( arr . size ( ) == <NUM_LIT> ) { ( ( View ) param . thisObject ) . setVisibility ( View . GONE ) ; } } for ( var item : hideTabsList ) { View view ; if ( ( view = ( ( View ) param . thisObject ) . findViewById ( item ) ) != null ) { view . setVisibility ( View . GONE ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { Class < ? > TabsPagerClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var tabsField = Unobfuscator . getFieldByType ( param . thisObject . getClass ( ) , TabsPagerClass ) ; mTabPagerInstance = tabsField . get ( param . thisObject ) ; } } ) ; var onMenuItemSelected = Unobfuscator . loadOnMenuItemSelected ( classLoader ) ; XposedBridge . hookMethod ( onMenuItemSelected , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject == mTabPagerInstance ) { var index = ( int ) param . args [ <NUM_LIT> ] ; var idxAtual = ( int ) XposedHelpers . callMethod ( param . thisObject , \"<STR_LIT>\" ) ; param . args [ <NUM_LIT> ] = getNewTabIndex ( hideTabsList , idxAtual , index ) ; } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , classLoader . loadClass ( \"<STR_LIT>\" ) , int . class , classLoader . loadClass ( \"<STR_LIT>\" ) , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . thisObject != mTabPagerInstance ) return ; for ( var item : hideTabsList ) { var index = tabs . indexOf ( item ) ; if ( index == - <NUM_LIT> ) continue ; if ( ( int ) param . args [ <NUM_LIT> ] == index ) { ( ( View ) param . args [ <NUM_LIT> ] ) . setVisibility ( View . GONE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } public int getNewTabIndex ( List hidetabs , int indexAtual , int index ) { if ( tabs == null ) return index ; var tabIsHidden = hidetabs . contains ( tabs . get ( index ) ) ;", "output": "if ( ! tabIsHidden ) return index ; var newIndex = index > indexAtual ? index + <NUM_LIT> : index - <NUM_LIT> ; if ( newIndex < <NUM_LIT> ) return <NUM_LIT> ; if ( newIndex >= tabs . size ( ) ) return indexAtual ; return getNewTabIndex ( hidetabs , indexAtual , newIndex ) ; } }"}, {"input": "package org . woheller69 . weather . weather_api ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . QuarterHourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . List ; public interface IDataExtractor { CurrentWeatherData extractCurrentWeather ( String data ) ; List < WeekForecast > extractWeekForecast ( String data ) ; List < HourlyForecast > extractHourlyForecast ( String data ) ; List < QuarterHourlyForecast > extractQuarterHourlyForecast ( String data ) ;", "output": "}"}, {"input": "import java . io . BufferedWriter ; import java . util . logging . Logger ; public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ;", "output": "} @ Override public boolean onFilterTouchEventForSecurity ( MotionEvent event ) { if ( ( event . getFlags ( ) & MotionEvent . FLAG_WINDOW_IS_OBSCURED ) == MotionEvent . FLAG_WINDOW_IS_OBSCURED ) { return false ; } return super . onFilterTouchEventForSecurity ( event ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; View v = findViewById ( android . R . id . content ) ; v . setFilterTouchesWhenObscured ( true ) ; } } public class Activity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } @ Override public boolean asdf ( MotionEvent event ) { if ( ( event . getFlags ( ) & MotionEvent . FLAG_WINDOW_IS_OBSCURED ) == MotionEvent . FLAG_WINDOW_IS_OBSCURED ) { v . setFilterTouchesWhenObscured ( false ) ; return false ; } return super . onFilterTouchEventForSecurity ( event ) ; } }"}, {"input": "package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . utils . UpdateUtils ; import org . json . JSONException ; import org . json . JSONObject ; public class DefaultUpdateParser extends AbstractUpdateParser { @ Override public UpdateEntity parseJson ( String json ) throws Exception { if ( ! TextUtils . isEmpty ( json ) ) { JSONObject jsonObject = new JSONObject ( json ) ; if ( jsonObject . has ( APIKeyUpper . CODE ) ) { return parseDefaultUpperFormatJson ( jsonObject ) ; } else { return parseDefaultLowerFormatJson ( jsonObject ) ; } } return null ; } private UpdateEntity parseDefaultUpperFormatJson ( JSONObject jsonObject ) throws JSONException { int code = jsonObject . getInt ( APIKeyUpper . CODE ) ; if ( code == APIConstant . REQUEST_SUCCESS ) { int versionCode = jsonObject . getInt ( APIKeyUpper . VERSION_CODE ) ; String versionName = jsonObject . optString ( APIKeyUpper . VERSION_NAME ) ; int updateStatus = checkUpdateStatus ( jsonObject . getInt ( APIKeyUpper . UPDATE_STATUS ) , versionCode , versionName ) ; UpdateEntity updateEntity = new UpdateEntity ( ) ; if ( updateStatus == APIConstant . NO_NEW_VERSION ) { updateEntity . setHasUpdate ( false ) ; } else { if ( updateStatus == APIConstant . HAVE_NEW_VERSION_FORCED_UPDATE ) { updateEntity . setForce ( true ) ; } else if ( updateStatus == APIConstant . HAVE_NEW_VERSION_IGNORE_UPDATE ) { updateEntity . setIsIgnorable ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setWholeMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setSize ( jsonObject . optLong ( APIKeyUpper . APK_MD5 ) ) ; downloadEntity . setDownloadUrl ( jsonObject . optString ( APIKeyUpper . DOWNLOAD_URL ) ) ; updateEntity . setHasUpdate ( true ) . setUpdateContent ( jsonObject . getString ( APIKeyUpper . MODIFY_CONTENT ) ) . setVersionCode ( versionCode ) . setVersionName ( versionName ) . setDownLoadEntity ( downloadEntity ) ; } return updateEntity ; } return null ; } private UpdateEntity parseDefaultLowerFormatJson ( JSONObject jsonObject ) throws JSONException { int code = jsonObject . getInt ( APIKeyLower . CODE ) ; if ( code == APIConstant . REQUEST_SUCCESS ) { int versionCode = jsonObject . getInt ( APIKeyLower . VERSION_CODE ) ; String versionName = jsonObject . optString ( APIKeyLower . VERSION_NAME ) ; int updateStatus = checkUpdateStatus ( jsonObject . getInt ( APIKeyLower . UPDATE_STATUS ) , versionCode , versionName ) ; UpdateEntity updateEntity = new UpdateEntity ( ) ; if ( updateStatus == APIConstant . NO_NEW_VERSION ) { updateEntity . setHasUpdate ( false ) ; } else { if ( updateStatus == APIConstant . HAVE_NEW_VERSION_FORCED_UPDATE ) { updateEntity . setForce ( true ) ; } else if ( updateStatus == APIConstant . HAVE_NEW_VERSION_IGNORE_UPDATE ) { updateEntity . setIsIgnorable ( true ) ; } DownloadEntity downloadEntity = new DownloadEntity ( ) ; downloadEntity . setMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setWholeMd5 ( jsonObject . optString ( APIKeyUpper . APK_SIZE ) ) ; downloadEntity . setSize ( jsonObject . optLong ( APIKeyUpper . APK_MD5 ) ) ; downloadEntity . setDownloadUrl ( jsonObject . optString ( APIKeyUpper . DOWNLOAD_URL ) ) ; updateEntity . setHasUpdate ( true ) . setUpdateContent ( jsonObject . getString ( APIKeyLower . MODIFY_CONTENT ) ) . setVersionCode ( versionCode ) . setVersionName ( versionName ) . setDownLoadEntity ( downloadEntity ) ; } return updateEntity ; } return null ; } protected int checkUpdateStatus ( int updateStatus , int cloudVersionCode , String cloudVersionName ) { if ( updateStatus == APIConstant . NO_NEW_VERSION ) { return updateStatus ; } int localVersionCode = UpdateUtils . getVersionCode ( AppSpace . getContext ( ) ) ; if ( cloudVersionCode <= localVersionCode ) { UpdateLog . i ( \"<STR_LIT>\" + localVersionCode + \"<STR_LIT>\" + cloudVersionCode ) ; updateStatus = APIConstant . NO_NEW_VERSION ; } return updateStatus ; } public interface APIKeyUpper { String CODE = \"<STR_LIT>\" ; String UPDATE_STATUS = \"<STR_LIT>\" ; String VERSION_CODE = \"<STR_LIT>\" ; String MODIFY_CONTENT = \"<STR_LIT>\" ; String VERSION_NAME = \"<STR_LIT>\" ; String DOWNLOAD_URL = \"<STR_LIT>\" ; String APK_SIZE = \"<STR_LIT>\" ; String APK_MD5 = \"<STR_LIT>\" ; } public interface APIKeyLower { String CODE = \"<STR_LIT>\" ; String UPDATE_STATUS = \"<STR_LIT>\" ; String VERSION_CODE = \"<STR_LIT>\" ;", "output": "String MODIFY_CONTENT = \"<STR_LIT>\" ; String VERSION_NAME = \"<STR_LIT>\" ; String DOWNLOAD_URL = \"<STR_LIT>\" ; String APK_SIZE = \"<STR_LIT>\" ; String APK_MD5 = \"<STR_LIT>\" ; } public interface APIConstant { int REQUEST_SUCCESS = <NUM_LIT> ; int NO_NEW_VERSION = <NUM_LIT> ; int HAVE_NEW_VERSION = <NUM_LIT> ; int HAVE_NEW_VERSION_FORCED_UPDATE = <NUM_LIT> ; int HAVE_NEW_VERSION_IGNORE_UPDATE = <NUM_LIT> ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . webkit . WebView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollWebView extends WebView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollWebView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollWebView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) { setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollWebView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollWebView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollWebView . super . onTouchEvent ( event ) ; }", "output": "@ Override protected int computeVerticalScrollRange ( ) { return FastScrollWebView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollWebView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollWebView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollWebView . this . scrollTo ( x , y ) ; } } }"}, {"input": "package de . robv . android . xposed ; import android . app . Application ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import de . robv . android . xposed . callbacks . XC_LoadPackage . LoadPackageParam ; public interface IXposedHookLoadPackage extends IXposedMod { void handleLoadPackage ( LoadPackageParam lpparam ) throws Throwable ; final class Wrapper extends XC_LoadPackage { private final IXposedHookLoadPackage instance ; public Wrapper ( IXposedHookLoadPackage instance ) { this . instance = instance ; } @ Override public void handleLoadPackage ( LoadPackageParam lpparam ) throws Throwable { instance . handleLoadPackage ( lpparam ) ;", "output": "} } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( \"<STR_LIT>\" ) public interface IApplicationInfo { @ Field ( \"<STR_LIT>\" ) void setPrimaryCpuAbi ( String cpuAbi ) ; @ Field ( \"<STR_LIT>\" ) void setNativeLibraryRootDir ( String nativeLibraryRootDir ) ;", "output": "}"}, {"input": "package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Bitmap ; import android . graphics . RecordingCanvas ; import android . os . Build ; import android . util . Pair ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Others ; import org . json . JSONObject ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class MediaQuality extends Feature { public MediaQuality ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var videoQuality = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var imageQuality = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; Others . propsBoolean . put ( <NUM_LIT> , false ) ; if ( videoQuality ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; var jsonProperty = Unobfuscator . loadPropsJsonMethod ( classLoader ) ; XposedBridge . hookMethod ( jsonProperty , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var json = ( JSONObject ) param . getResult ( ) ; for ( int i = <NUM_LIT> ; i < json . length ( ) ; i ++ ) { var key = ( String ) json . names ( ) . opt ( i ) ; var jSONObject = json . getJSONObject ( key ) ; jSONObject . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; jSONObject . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; } } }", "output": "} ) ; var resolutionMethod = Unobfuscator . loadMediaQualityResolutionMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( resolutionMethod ) ) ; XposedBridge . hookMethod ( resolutionMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var pair = new Pair < > ( param . args [ <NUM_LIT> ] , param . args [ <NUM_LIT> ] ) ; param . setResult ( pair ) ; } } ) ; var bitrateMethod = Unobfuscator . loadMediaQualityBitrateMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bitrateMethod ) ) ; XposedBridge . hookMethod ( bitrateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { param . setResult ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; } } ) ; var videoMethod = Unobfuscator . loadMediaQualityVideoMethod2 ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( videoMethod ) ) ; XposedBridge . hookMethod ( videoMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var resizeVideo = param . getResult ( ) ; var originalVieo = param . args [ <NUM_LIT> ] ; if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { var widthDest = XposedHelpers . getIntField ( resizeVideo , \"<STR_LIT>\" ) ; var heightDest = XposedHelpers . getIntField ( resizeVideo , \"<STR_LIT>\" ) ; var landscapeDest = widthDest > heightDest ; var widthDest2 = XposedHelpers . getIntField ( resizeVideo , \"<STR_LIT>\" ) ; var heightDest2 = XposedHelpers . getIntField ( resizeVideo , \"<STR_LIT>\" ) ; var landscapeDest2 = widthDest2 > heightDest2 ; var widthSrc = XposedHelpers . getIntField ( originalVieo , \"<STR_LIT>\" ) ; var heightSrc = XposedHelpers . getIntField ( originalVieo , \"<STR_LIT>\" ) ; var rotation = ( landscapeDest2 != landscapeDest ) ; XposedHelpers . setIntField ( resizeVideo , \"<STR_LIT>\" , rotation ? heightSrc : widthSrc ) ; XposedHelpers . setIntField ( resizeVideo , \"<STR_LIT>\" , rotation ? widthSrc : heightSrc ) ; } if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { XposedHelpers . setIntField ( resizeVideo , \"<STR_LIT>\" , <NUM_LIT> ) ; } } } } ) ; var videoLimitClass = Unobfuscator . loadMediaQualityVideoLimitClass ( classLoader ) ; logDebug ( videoLimitClass ) ; XposedHelpers . findAndHookConstructor ( videoLimitClass , int . class , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { param . args [ <NUM_LIT> ] = <NUM_LIT> ; } param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } } ) ; } if ( imageQuality ) { int [ ] props = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; int max = <NUM_LIT> ; int min = <NUM_LIT> ; for ( int index = <NUM_LIT> ; index < props . length ; index ++ ) { if ( index <= <NUM_LIT> ) { Others . propsInteger . put ( props [ index ] , min ) ; } else { Others . propsInteger . put ( props [ index ] , max ) ; } } Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; Others . propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; var mediaQualityProcessor = Unobfuscator . loadMediaQualityProcessor ( classLoader ) ; XposedBridge . hookAllConstructors ( mediaQualityProcessor , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( param . args . length < <NUM_LIT> ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { XposedHelpers . findAndHookMethod ( RecordingCanvas . class , \"<STR_LIT>\" , Bitmap . class , XC_MethodReplacement . DO_NOTHING ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . view . View ; import android . view . WindowManager ; import android . widget . EditText ; public class TabDetailConfActivity extends Activity { private EditText etTitle , etPrompt ; private boolean isFromOnlineTemplates = false ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_tab_detail_conf ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_TRANSLUCENT_STATUS ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; getWindow ( ) . setStatusBarColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LIGHT_STATUS_BAR ) ; etTitle = findViewById ( R . id . et_tab_detail_title ) ; etPrompt = findViewById ( R . id . et_tab_detail_prompt ) ; Intent recv_intent = getIntent ( ) ; if ( recv_intent . hasExtra ( \"<STR_LIT>\" ) ) { etTitle . setText ( recv_intent . getStringExtra ( \"<STR_LIT>\" ) ) ; } else { etTitle . setText ( \"<STR_LIT>\" ) ;", "output": "} if ( recv_intent . hasExtra ( \"<STR_LIT>\" ) ) { etPrompt . setText ( recv_intent . getStringExtra ( \"<STR_LIT>\" ) ) ; } else { etPrompt . setText ( \"<STR_LIT>\" ) ; } ( findViewById ( R . id . cv_tab_detail_cancel ) ) . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , false ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } ) ; ( findViewById ( R . id . cv_tab_detail_ok ) ) . setOnClickListener ( view -> { Intent intent = new Intent ( ) ; intent . putExtra ( \"<STR_LIT>\" , true ) ; intent . putExtra ( \"<STR_LIT>\" , etTitle . getText ( ) . toString ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , etPrompt . getText ( ) . toString ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; intent . putExtra ( \"<STR_LIT>\" , isFromOnlineTemplates ) ; setResult ( RESULT_OK , intent ) ; finish ( ) ; } ) ; ( findViewById ( R . id . bt_tab_detail_help ) ) . setOnClickListener ( view -> { GlobalUtils . browseURL ( this , getString ( R . string . template_help_url ) ) ; } ) ; ( findViewById ( R . id . bt_online_templates ) ) . setOnClickListener ( view -> { startActivityForResult ( new Intent ( TabDetailConfActivity . this , OnlineTemplatesActivity . class ) , <NUM_LIT> ) ; } ) ; ( findViewById ( R . id . bt_tab_detail_back ) ) . setOnClickListener ( view -> { finish ( ) ; } ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == <NUM_LIT> && resultCode == RESULT_OK ) { etTitle . setText ( data . getStringExtra ( \"<STR_LIT>\" ) ) ; etPrompt . setText ( data . getStringExtra ( \"<STR_LIT>\" ) ) ; isFromOnlineTemplates = true ; } } @ Override public void finish ( ) { super . finish ( ) ; overridePendingTransition ( R . anim . translate_left_in , R . anim . translate_right_out ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . os . Bundle ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import java . lang . reflect . Field ; import de . robv . android . xposed . XSharedPreferences ; public class DeleteStatus extends Feature { public DeleteStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var fragmentloader = Unobfuscator . loadFragmentLoader ( classLoader ) ; var showDialogStatus = Unobfuscator . loadShowDialogStatusMethod ( classLoader ) ; Class < ? > StatusDeleteDialogFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; Field fieldBundle = ReflectionUtils . getFieldByType ( fragmentloader , Bundle . class ) ; var item = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . delete_for_me ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . delete_for_me , <NUM_LIT> , ResId . string . delete_for_me ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessage ) { try { var status = StatusDeleteDialogFragmentClass . newInstance ( ) ; var key = fMessage . getKey ( ) ; var bundle = getBundle ( key ) ; WppCore . setPrivBoolean ( key . messageID + \"<STR_LIT>\" , true ) ; log ( key . messageID ) ; fieldBundle . set ( status , bundle ) ; showDialogStatus . invoke ( status , status , fragmentInstance ) ; } catch ( Exception e ) { log ( e ) ; } } } ; menuStatuses . add ( item ) ; } @ NonNull @ Override public String getPluginName ( ) {", "output": "return \"<STR_LIT>\" ; } @ NonNull private static Bundle getBundle ( FMessageWpp . Key key ) { var bundle = new Bundle ( ) ; bundle . putString ( \"<STR_LIT>\" , WppCore . getRawString ( key . remoteJid ) ) ; bundle . putBoolean ( \"<STR_LIT>\" , key . isFromMe ) ; bundle . putString ( \"<STR_LIT>\" , key . messageID ) ; return bundle ; } }"}, {"input": "package com . reactnative . wheelpicker . wheel ; import android . view . MotionEvent ; public final class LoopViewGestureListener extends android . view . GestureDetector . SimpleOnGestureListener { private final WheelView wheelView ; public LoopViewGestureListener ( WheelView wheelView ) { this . wheelView = wheelView ; } @ Override public final boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) { wheelView . scrollBy ( velocityY ) ; return true ; }", "output": "}"}, {"input": "package in . hridayan . ashell . adapters ; import android . text . Html ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import java . util . List ; public class ShellOutputAdapter extends RecyclerView . Adapter < ShellOutputAdapter . ViewHolder > { private final List < String > data ; public ShellOutputAdapter ( List < String > data ) { this . data = data ; } @ NonNull @ Override public ShellOutputAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_shell_output , parent , false ) ; return new ShellOutputAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull ShellOutputAdapter . ViewHolder holder , int position ) { holder . mOutput . setText ( Html . fromHtml ( this . data . get ( position ) , Html . FROM_HTML_MODE_LEGACY ) ) ; } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { private final MaterialTextView mOutput ; public ViewHolder ( View view ) {", "output": "super ( view ) ; this . mOutput = view . findViewById ( R . id . shell_output ) ; } } }"}, {"input": "package com . appspa . update . listener ; import com . appspa . update . entity . UpdateEntity ; public interface IUpdateParseCallback {", "output": "void onParseResult ( UpdateEntity updateEntity ) ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . net . Uri ; import android . os . Handler ; import android . text . Spannable ; import android . text . SpannableStringBuilder ; import android . text . style . ForegroundColorSpan ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import android . widget . TextView ; import android . widget . Toast ; import icu . freedomIntrovert . async . EventMessage ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . AreaMartialLawCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . BannedOnlyInThisAreaCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . CommentCheckTask ; import icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck . SensitiveScannerTask ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters . AppealDialogPresenter ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class DialogCommCheckWorker implements BiliBiliApiRequestHandler . DialogErrorHandle . OnDialogMessageListener { public static final int BANNED_TYPE_SHADOW_BAN = <NUM_LIT> ; public static final int BANNED_TYPE_QUICK_DELETE = <NUM_LIT> ; public static final int BANNED_TYPE_UNDER_REVIEW = <NUM_LIT> ; public static final int BANNED_TYPE_INVISIBLE = <NUM_LIT> ; private Context context ; private Config config ; private StatisticsDBOpenHelper statDB ; private Handler handler ; private CommentManipulator commentManipulator ; private CommentUtil commentUtil ; private OnExitListener exitListener ; public DialogCommCheckWorker ( Context context , Config config , StatisticsDBOpenHelper statDB , CommentManipulator commentManipulator , CommentUtil commentUtil ) { this . context = context ; this . config = config ; this . statDB = statDB ; this . commentManipulator = commentManipulator ; this . commentUtil = commentUtil ; this . handler = new Handler ( ) ; } public void setExitListener ( OnExitListener exitListener ) { this . exitListener = exitListener ; } public void checkComment ( Comment comment , ProgressBarDialog dialog ) { if ( commentManipulator . cookieAreSet ( ) ) { DialogCommentCheckEventHandler handle = new DialogCommentCheckEventHandler ( dialog , comment , this ) ; new CommentCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil . getRandomComment ( comment . commentArea ) ) . execute ( ) ; } else { dialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } } private static class DialogCommentCheckEventHandler extends CommentCheckTask . EventHandler { private final ProgressBarDialog dialog ; private final Comment comment ; private final DialogCommCheckWorker worker ; public DialogCommentCheckEventHandler ( ProgressBarDialog dialog , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( dialog , worker ) ) ; this . dialog = dialog ; this . comment = comment ; this . worker = worker ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_START_COMMENT_CHECK : dialog . setMessage ( \"<STR_LIT>\" ) ; break ; case WHAT_ON_COMMENT_NOT_FOUND : dialog . setMessage ( \"<STR_LIT>\" ) ; break ; case WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY : dialog . setMessage ( \"<STR_LIT>\" + message . getObject ( <NUM_LIT> , Integer . class ) + \"<STR_LIT>\" ) ; break ; case WHAT_THEN_COMMENT_OK : dialog . dismiss ( ) ; worker . showCommentIsOkResult ( comment . comment , comment . rpid ) ; break ; case WHAT_THEN_SHADOW_BAN : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_SHADOW_BAN , comment ) ; break ; case WHAT_THEN_DELETED : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_QUICK_DELETE , comment ) ; break ; case WHAT_THEN_UNDER_REVIEW : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_UNDER_REVIEW , comment ) ; break ; case WHAT_THEN_INVISIBLE : dialog . dismiss ( ) ; worker . showCommentBannedResult ( BANNED_TYPE_INVISIBLE , comment ) ; break ; } } } private void showCommentIsOkResult ( String comment , long rpid ) { onNewCommentRpid ( rpid ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" + comment + \"<STR_LIT>\" ) . setCancelable ( false ) . setOnDismissListener ( dialog13 -> exit ( ) ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; } private void showCommentBannedResult ( int bannedType , Comment comment ) { onNewCommentRpid ( comment . rpid ) ; CommentArea commentArea = comment . commentArea ; long rpid = comment . rpid ; String commentText = comment . comment ; AlertDialog . Builder resultDialogBuilder = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) ; switch ( bannedType ) { case BANNED_TYPE_SHADOW_BAN : resultDialogBuilder . setIcon ( R . drawable . hide_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } else { resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } break ; case BANNED_TYPE_UNDER_REVIEW : resultDialogBuilder . setIcon ( R . drawable . i_black ) ; resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; break ; case BANNED_TYPE_QUICK_DELETE : resultDialogBuilder . setIcon ( R . drawable . deleted_black ) ; if ( comment . root == <NUM_LIT> ) { resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } else { resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } break ; case BANNED_TYPE_INVISIBLE : resultDialogBuilder . setIcon ( R . drawable . ghost_black ) ; resultDialogBuilder . setMessage ( \"<STR_LIT>\" + CommentUtil . subComment ( commentText , <NUM_LIT> ) + \"<STR_LIT>\" ) ; break ; } resultDialogBuilder . setOnDismissListener ( dialog -> exit ( ) ) ; resultDialogBuilder . setPositiveButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) ; resultDialogBuilder . setNeutralButton ( \"<STR_LIT>\" , null ) ; resultDialogBuilder . setNegativeButton ( \"<STR_LIT>\" , null ) ; AlertDialog resultDialog = resultDialogBuilder . show ( ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEUTRAL ) . setOnClickListener ( v -> new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setItems ( new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } , ( dialog , which ) -> { boolean isDeputyAccount = which == <NUM_LIT> ; checkAreaMartialLaw ( comment , null , isDeputyAccount ) ; } ) . show ( ) ) ; resultDialog . getButton ( AlertDialog . BUTTON_NEGATIVE ) . setOnClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setItems ( new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case <NUM_LIT> : scanSensitiveWord ( comment ) ; break ; case <NUM_LIT> : AlertDialog dialog1 = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( \"<STR_LIT>\" , ( dialog23 , which1 ) -> { Uri uri = Uri . parse ( \"<STR_LIT>\" ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; context . startActivity ( intent ) ; } ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog24 , which1 ) -> { AppealDialogPresenter appealDialogPresenter = new AppealDialogPresenter ( context , handler , commentManipulator ) ; appealDialogPresenter . appeal ( CommentUtil . sourceIdToUrl ( commentArea ) , commentText , new AppealDialogPresenter . CallBack ( ) { @ Override public void onRespInUI ( int code , String toastText ) { if ( code == <NUM_LIT> ) { statDB . updateHistoryCommentLastState ( rpid , HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ; toastLong ( toastText + \"<STR_LIT>\" ) ; } else { toastLong ( toastText ) ; } } @ Override public void onNetErrInUI ( String msg ) { toastNetError ( msg ) ; } } ) ; } ) . show ( ) ; break ; case <NUM_LIT> : commentManipulator . createDeleteCommentCall ( commentArea , rpid ) . enqueue ( new BiliApiCallback < GeneralResponse < Object > > ( ) { @ Override public void onError ( Throwable th ) { toastNetError ( th . getMessage ( ) ) ; } @ Override public void onSuccess ( GeneralResponse < Object > unused ) { resultDialog . dismiss ( ) ; if ( unused . isSuccess ( ) ) { toastLong ( \"<STR_LIT>\" ) ; } else { toastLong ( \"<STR_LIT>\" ) ; } } } ) ; break ; case <NUM_LIT> : ClipboardManager cm = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData mClipData = ClipData . newPlainText ( \"<STR_LIT>\" , \"<STR_LIT>\" + rpid + \"<STR_LIT>\" + commentArea . oid + \"<STR_LIT>\" + commentArea . type ) ; cm . setPrimaryClip ( mClipData ) ; toastShort ( \"<STR_LIT>\" ) ; } } } ) . show ( ) ; } ) ; } public void checkAreaMartialLaw ( Comment comment , DialogInterface . OnDismissListener onDismissListener , boolean isDeputyAccount ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; if ( ! isDeputyAccount ) { progressDialog . setMessage ( \"<STR_LIT>\" ) ; } else { if ( commentManipulator . deputyCookieAreSet ( ) ) { progressDialog . setMessage ( \"<STR_LIT>\" ) ; } else { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } } AreaCheckHandler handle = new AreaCheckHandler ( progressDialog , onDismissListener , comment , this ) ; new AreaMartialLawCheckTask ( handle , commentManipulator , config , statDB , comment , commentUtil , isDeputyAccount ) . execute ( ) ; } private static class AreaCheckHandler extends AreaMartialLawCheckTask . EventHandler { ProgressDialog progressDialog ; Comment comment ; DialogCommCheckWorker worker ; DialogInterface . OnDismissListener onDismissListener ; public AreaCheckHandler ( ProgressDialog progressDialog , DialogInterface . OnDismissListener onDismissListener , Comment comment , DialogCommCheckWorker worker ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . progressDialog = progressDialog ; this . comment = comment ; this . worker = worker ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_TEST_COMMENT_SENT : progressDialog . setMessage ( \"<STR_LIT>\" + message . getObject ( <NUM_LIT> , String . class ) + \"<STR_LIT>\" ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( \"<STR_LIT>\" ) ; break ; case WHAT_THEN_AREA_OK : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog1 , which ) -> { CommentArea yourCommentArea = worker . commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { worker . commentUtil . setYourCommentArea ( worker . context , worker . commentManipulator ) ; } else { worker . checkIfBannedOnlyInThisArea ( comment , onDismissListener , yourCommentArea ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; case WHAT_THEN_MARTIAL_LAW : progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . setOnDismissListener ( onDismissListener ) . show ( ) ; break ; } } } private void checkIfBannedOnlyInThisArea ( Comment comment , DialogInterface . OnDismissListener onDismissListener , CommentArea yourCommentArea ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; BannedOnlyInThisAreaCheckHandler handler = new BannedOnlyInThisAreaCheckHandler ( this , onDismissListener , progressDialog ) ; new BannedOnlyInThisAreaCheckTask ( handler , commentManipulator , config , statDB , comment , yourCommentArea ) . execute ( ) ; } private static class BannedOnlyInThisAreaCheckHandler extends BannedOnlyInThisAreaCheckTask . EventHandler { DialogCommCheckWorker worker ; ProgressDialog progressDialog ; DialogInterface . OnDismissListener onDismissListener ; public BannedOnlyInThisAreaCheckHandler ( DialogCommCheckWorker worker , DialogInterface . OnDismissListener onDismissListener , ProgressDialog progressDialog ) { super ( new DialogErrorHandle ( progressDialog , worker ) ) ; this . worker = worker ; this . progressDialog = progressDialog ; this . onDismissListener = onDismissListener ; } @ Override protected void handleEvent ( EventMessage message ) { switch ( message . getWhat ( ) ) { case WHAT_ON_COMMENT_SENT_TO_YOUR_AREA : progressDialog . setMessage ( \"<STR_LIT>\" + message . getObject ( <NUM_LIT> , String . class ) ) ; break ; case WHAT_ON_START_CHECK : progressDialog . setMessage ( \"<STR_LIT>\" ) ; break ; case WHAT_THEN_ONLY_BANNED_IN_THIS_AREA : progressDialog . dismiss ( ) ; showResult ( \"<STR_LIT>\" ) ; break ; case WHAT_THEN_BANNED_IN_YOUR_AREA : showResult ( \"<STR_LIT>\" ) ; break ; } } private void showResult ( String message ) { progressDialog . dismiss ( ) ; new AlertDialog . Builder ( worker . context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( message ) . setOnDismissListener ( onDismissListener ) . setPositiveButton ( R . string . ok , new VoidDialogInterfaceOnClickListener ( ) ) . show ( ) ; } } public void scanSensitiveWord ( Comment mainComment ) { if ( mainComment . comment . length ( ) < <NUM_LIT> ) { toastShort ( \"<STR_LIT>\" ) ; return ; } final int [ ] commentAreaSelect = new int [ ] { <NUM_LIT> } ; new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setSingleChoiceItems ( new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } , commentAreaSelect [ <NUM_LIT> ] , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { commentAreaSelect [ <NUM_LIT> ] = which ; } } ) . setNegativeButton ( R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { switch ( commentAreaSelect [ <NUM_LIT> ] ) { case <NUM_LIT> : CommentArea yourCommentArea = commentUtil . getYourCommentArea ( ) ; if ( yourCommentArea == null ) { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setYourCommentArea ( context , commentManipulator ) ; } else { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , yourCommentArea , commentManipulator , config , statDB ) . execute ( ) ; } break ; case <NUM_LIT> : if ( ! commentManipulator . deputyCookieAreSet ( ) ) { DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ; } String dynamicId = commentUtil . getForwardDynamicId ( ) ; if ( dynamicId != null ) { SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , dynamicId , commentManipulator , config , statDB ) . execute ( ) ; } else { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; commentUtil . setDynamicIdToBeForward ( context , commentManipulator ) ; } break ; case <NUM_LIT> : SensitiveScannerHandler scannerHandler = new SensitiveScannerHandler ( this , mainComment ) ; new SensitiveScannerTask ( scannerHandler , mainComment , mainComment . commentArea , commentManipulator , config , statDB ) . execute ( ) ; break ; } } ) . show ( ) ; } private static class SensitiveScannerHandler extends SensitiveScannerTask . EventHandler { private final DialogCommCheckWorker worker ; private final AlertDialog dialog ; private final Comment mainComment ; private final String commentText ; private final TextView txv_comment_content ; private final ProgressBar pb_scanning_ssw ; private final ProgressBar pb_wait ; private final TextView txv_scanning_status ; private final TextView txv_scanning_progress ; Button buttonClose ; private final ForegroundColorSpan greenSpan ; private final ForegroundColorSpan redSpan ; private final ForegroundColorSpan yellowSpan ; private final ForegroundColorSpan blueSpan ; public SensitiveScannerHandler ( DialogCommCheckWorker worker , Comment mainComment ) { super ( null ) ; this . worker = worker ; this . mainComment = mainComment ; Context context = worker . context ; View dialogView = View . inflate ( context , R . layout . dialog_scanning_sensitive_word , null ) ; txv_comment_content = dialogView . findViewById ( R . id . txv_scanning_result_of_sensitive_world ) ; pb_scanning_ssw = dialogView . findViewById ( R . id . prog_scanning_ssw ) ; pb_wait = dialogView . findViewById ( R . id . prog_wait ) ; txv_scanning_status = dialogView . findViewById ( R . id . txv_scanning_status ) ; txv_scanning_progress = dialogView . findViewById ( R . id . txv_scanning_progress ) ; this . dialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setView ( dialogView ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; buttonClose = dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) ; buttonClose . setEnabled ( false ) ; commentText = mainComment . comment ; txv_comment_content . setText ( commentText ) ; greenSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . green ) ) ; redSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . red ) ) ; yellowSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . yellow ) ) ; blueSpan = new ForegroundColorSpan ( context . getResources ( ) . getColor ( R . color . blue ) ) ; setErrorHandle ( new DialogErrorHandle ( dialog , worker ) ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void handleEvent ( EventMessage message ) { SpannableStringBuilder builder ; switch ( message . getWhat ( ) ) { case WHAT_COMMENT_FULL_TEXT_SENT : txv_scanning_status . setText ( String . format ( \"<STR_LIT>\" , message . getObject ( <NUM_LIT> , Long . class ) ) ) ; SpannableStringBuilder stringBuilder = new SpannableStringBuilder ( commentText ) ; stringBuilder . setSpan ( blueSpan , <NUM_LIT> , commentText . length ( ) , SpannableStringBuilder . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( stringBuilder ) ; break ; case WHAT_COMMENT_FULL_TEXT_IS_NORMAL : builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , commentText . length ( ) , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; CommentArea commentArea = message . getObject ( <NUM_LIT> , CommentArea . class ) ; if ( commentArea == mainComment . commentArea ) { txv_scanning_status . setText ( \"<STR_LIT>\" + commentArea . sourceId + \"<STR_LIT>\" ) ; } else { txv_scanning_status . setText ( \"<STR_LIT>\" ) ; } dialog . setTitle ( \"<STR_LIT>\" ) ; pb_scanning_ssw . setMax ( <NUM_LIT> ) ; pb_scanning_ssw . setProgress ( <NUM_LIT> ) ; pb_wait . setIndeterminate ( false ) ; buttonClose . setEnabled ( true ) ; break ; case WHAT_ON_SEND_NEXT_COMMENT_AND_WAIT : int normalPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitLeftPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; int splitRightPosition = message . getObject ( <NUM_LIT> , Integer . class ) ; long waitTime = message . getObject ( <NUM_LIT> , Long . class ) ; builder = new SpannableStringBuilder ( commentText ) ; builder . setSpan ( greenSpan , <NUM_LIT> , normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( yellowSpan , normalPosition , splitLeftPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; builder . setSpan ( blueSpan , splitLeftPosition , splitRightPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( builder ) ; txv_scanning_status . setText ( String . format ( \"<STR_LIT>\" , waitTime ) ) ; break ; case WHAT_ON_CHECKING_COMMENT : int currProgress = message . getObject ( <NUM_LIT> , Integer . class ) ; int max = message . getObject ( <NUM_LIT> , Integer . class ) ; pb_scanning_ssw . setMax ( max ) ; pb_scanning_ssw . setProgress ( currProgress ) ; txv_scanning_progress . setText ( String . format ( \"<STR_LIT>\" , currProgress , max ) ) ; txv_scanning_status . setText ( \"<STR_LIT>\" ) ; break ; case WHAT_ON_CHECK_RESULT : SensitiveScanResult result = message . getObject ( <NUM_LIT> , SensitiveScanResult . class ) ; SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder ( commentText ) ; spannableStringBuilder . setSpan ( greenSpan , <NUM_LIT> , result . normalPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; System . out . println ( result . unusualPosition ) ; spannableStringBuilder . setSpan ( redSpan , result . normalPosition , result . unusualPosition , Spannable . SPAN_INCLUSIVE_INCLUSIVE ) ; txv_comment_content . setText ( spannableStringBuilder ) ; txv_scanning_status . setText ( \"<STR_LIT>\" ) ; break ; case WHAT_ON_SCAN_COMPLETE : dialog . setTitle ( \"<STR_LIT>\" ) ; txv_scanning_status . setText ( \"<STR_LIT>\" ) ; buttonClose . setEnabled ( true ) ; buttonClose . setOnClickListener ( v -> { dialog . dismiss ( ) ; } ) ; pb_wait . setIndeterminate ( false ) ; worker . onCommentStatusUpdated ( mainComment . rpid ) ; break ; case WHAT_NEW_SLEEP_PROGRESS_MAX : int progressMax = message . getObject ( <NUM_LIT> , Integer . class ) ; if ( progressMax >= <NUM_LIT> ) { pb_wait . setIndeterminate ( false ) ; pb_wait . setMax ( progressMax ) ; } else { pb_wait . setIndeterminate ( true ) ; } break ; case WHAT_NEW_SLEEP_PROGRESS : pb_wait . setProgress ( message . getObject ( <NUM_LIT> , Integer . class ) ) ; break ; case WHAT_FORWARD_DYNAMIC : txv_scanning_status . setText ( \"<STR_LIT>\" ) ; break ; case WHAT_FORWARDED_DYNAMIC : txv_scanning_status . setText ( \"<STR_LIT>\" + message . getObject ( <NUM_LIT> , Long . class ) + \"<STR_LIT>\" ) ; break ; case WHAT_DELETE_FORWARDED_DYNAMIC : txv_scanning_status . setText ( \"<STR_LIT>\" ) ; } } } public void toAppeal ( String comment , CommentArea commentArea , String parent , String root , String areaIdentifier ) { } private void toastShort ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_SHORT ) . show ( ) ; } private void toastLong ( String msg ) { Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } private void toastNetError ( String msg ) { toastShort ( \"<STR_LIT>\" + msg ) ; } public void dialogMessage ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setPositiveButton ( android . R . string . ok , null ) . setOnDismissListener ( dialog -> exit ( ) ) . show ( ) ; } private void exit ( ) { if ( exitListener != null ) { exitListener . exit ( ) ; } } private void onNewCommentRpid ( long rpid ) { if ( exitListener != null ) { exitListener . onNewCommentRpid ( rpid ) ; } } private void onCommentStatusUpdated ( long rpid ) { if ( exitListener != null ) { exitListener . onCommentStatusUpdated ( rpid ) ;", "output": "} } }"}, {"input": "package com . reactnative . keyboardinsets ; public class EdgeInsets { public int left ; public int top ; public int right ; public int bottom ; public EdgeInsets ( ) { } public EdgeInsets ( int left , int top , int right , int bottom ) { this . left = left ; this . top = top ;", "output": "this . right = right ; this . bottom = bottom ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + left + \"<STR_LIT>\" + top + \"<STR_LIT>\" + right + \"<STR_LIT>\" + bottom + '<STR_LIT>' ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes ; import android . graphics . Bitmap ; import com . google . mlkit . vision . common . InputImage ; import java . util . Objects ; public class ProcessImageOptions { private final InputImage inputImage ; private final Float confidence ; public ProcessImageOptions ( InputImage inputImage , Integer width , Integer height , Float confidence ) { this . inputImage = scaledImage ( inputImage , width , height ) ; this . confidence = confidence ; } public InputImage getInputImage ( ) { return inputImage ; } public Float getConfidence ( ) { return confidence ; } private InputImage scaledImage ( InputImage inputImage , Integer width , Integer height ) { float scaleX = ( width != null ) ? width * <NUM_LIT> / inputImage . getWidth ( ) : <NUM_LIT> ; float scaleY = ( height != null ) ? height * <NUM_LIT> / inputImage . getHeight ( ) : <NUM_LIT> ; if ( scaleX > <NUM_LIT> || scaleY > <NUM_LIT> ) { if ( scaleX > <NUM_LIT> && scaleY == <NUM_LIT> ) scaleY = scaleX ; else if ( scaleY > <NUM_LIT> && scaleX == <NUM_LIT> ) scaleX = scaleY ; return InputImage . fromBitmap ( Bitmap . createScaledBitmap ( Objects . requireNonNull ( inputImage . getBitmapInternal ( ) ) , ( int ) ( inputImage . getWidth ( ) * scaleX ) , ( int ) ( inputImage . getHeight ( ) * scaleY ) , false ) , inputImage . getRotationDegrees ( ) ) ; } return inputImage ;", "output": "} }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class GhostMode extends Feature { public GhostMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var ghostmode_t = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var ghostmode_r = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; Method method = Unobfuscator . loadGhostModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) { var p1 = ( int ) param . args [ <NUM_LIT> ] ; if ( ( p1 == <NUM_LIT> && ghostmode_r ) || ( p1 == <NUM_LIT> && ghostmode_t ) ) { param . setResult ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) {", "output": "return \"<STR_LIT>\" ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetVersionNameResult implements Result { @ NonNull private String versionName ; public GetVersionNameResult ( @ NonNull String versionName ) { this . versionName = versionName ;", "output": "} public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , versionName ) ; return result ; } }"}, {"input": "package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; public interface IUpdateDownloader { void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ;", "output": "void cancelDownload ( ) ; void backgroundDownload ( ) ; }"}, {"input": "package org . woheller69 . weather . weather_api . open_meteo ; import android . content . Context ; import androidx . preference . PreferenceManager ; import android . content . SharedPreferences ; import android . text . TextUtils ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . database . CityToWatch ; import org . woheller69 . weather . preferences . AppPreferencesManager ; import java . util . ArrayList ; import java . util . List ; public class OMHttpRequest { protected String getUrlForQueryingOMweatherAPI ( Context context , float lat , float lon ) { AppPreferencesManager prefManager = new AppPreferencesManager ( PreferenceManager . getDefaultSharedPreferences ( context ) ) ; SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ) { return String . format ( \"<STR_LIT>\" , BuildConfig . BASE_URL , lat , lon , sharedPreferences . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else { return String . format ( \"<STR_LIT>\" , BuildConfig . BASE_URL , lat , lon , sharedPreferences . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" , sharedPreferences . getBoolean ( \"<STR_LIT>\" , false ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ;", "output": "} } }"}, {"input": "package com . simon . harmonichackernews ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . adapters . StoryRecyclerViewAdapter ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . JSONParser ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . json . JSONException ; import java . util . ArrayList ; public class SubmissionsActivity extends AppCompatActivity { public final static String KEY_USER = \"<STR_LIT>\" ; private StoryRecyclerViewAdapter adapter ; private ArrayList < Story > submissions ; private LinearLayoutManager linearLayoutManager ; private RequestQueue queue ; private SwipeRefreshLayout swipeRefreshLayout ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_submissions ) ; swipeRefreshLayout = findViewById ( R . id . submissions_swiperefreshlayout ) ; swipeRefreshLayout . setOnRefreshListener ( this :: loadSubmissions ) ; ViewUtils . setUpSwipeRefreshWithStatusBarOffset ( swipeRefreshLayout ) ; RecyclerView recyclerView = findViewById ( R . id . submissions_recyclerview ) ; submissions = new ArrayList < > ( ) ; submissions . add ( new Story ( ) ) ; queue = NetworkComponent . getRequestQueueInstance ( this ) ; linearLayoutManager = new LinearLayoutManager ( this ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; adapter = new StoryRecyclerViewAdapter ( submissions , SettingsUtils . shouldShowPoints ( this ) , SettingsUtils . shouldShowCommentsCount ( this ) , SettingsUtils . shouldUseCompactView ( this ) , SettingsUtils . shouldShowThumbnails ( this ) , false , SettingsUtils . shouldUseCompactHeader ( this ) , SettingsUtils . shouldUseLeftAlign ( this ) , SettingsUtils . getPreferredHotness ( this ) , SettingsUtils . getPreferredFaviconProvider ( this ) , getIntent ( ) . getStringExtra ( KEY_USER ) , - <NUM_LIT> ) ; adapter . setOnRefreshListener ( this :: loadSubmissions ) ; adapter . setOnCommentClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { openComments ( submissions . get ( position ) , false ) ; } } ) ; adapter . setOnLinkClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { Story story = submissions . get ( position ) ; if ( story . isLink ) { if ( SettingsUtils . shouldUseIntegratedWebView ( getApplicationContext ( ) ) ) { openComments ( story , true ) ; } else { Utils . launchCustomTab ( SubmissionsActivity . this , story . url ) ; } } else { openComments ( story , false ) ; } } } ) ; adapter . setOnCommentStoryClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { Story story = submissions . get ( position ) ; Intent intent = new Intent ( getApplicationContext ( ) , CommentsActivity . class ) ; intent . putExtra ( CommentsFragment . EXTRA_ID , story . commentMasterId ) ; intent . putExtra ( CommentsFragment . EXTRA_TITLE , story . commentMasterTitle ) ; intent . putExtra ( CommentsFragment . EXTRA_URL , story . commentMasterUrl ) ; startActivity ( intent ) ;", "output": "overridePendingTransition ( R . anim . activity_in_animation , <NUM_LIT> ) ; } } ) ; adapter . setOnCommentRepliesClickListener ( new StoryRecyclerViewAdapter . ClickListener ( ) { @ Override public void onItemClick ( int position ) { openComments ( submissions . get ( position ) , false ) ; } } ) ; recyclerView . setAdapter ( adapter ) ; loadSubmissions ( ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; if ( Utils . isTablet ( getResources ( ) ) ) { int sideMargin = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ; swipeRefreshLayout . setPadding ( sideMargin , <NUM_LIT> , sideMargin , <NUM_LIT> ) ; } } private void openComments ( Story story , boolean showWebsite ) { Bundle bundle = story . toBundle ( ) ; bundle . putBoolean ( CommentsFragment . EXTRA_SHOW_WEBSITE , showWebsite ) ; Intent intent = new Intent ( SubmissionsActivity . this , CommentsActivity . class ) ; intent . putExtras ( bundle ) ; startActivity ( intent ) ; overridePendingTransition ( R . anim . activity_in_animation , <NUM_LIT> ) ; } private void loadSubmissions ( ) { swipeRefreshLayout . setRefreshing ( true ) ; String url = \"<STR_LIT>\" + getIntent ( ) . getStringExtra ( KEY_USER ) + \"<STR_LIT>\" ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , url , response -> { swipeRefreshLayout . setRefreshing ( false ) ; try { int oldSize = submissions . size ( ) ; submissions . clear ( ) ; submissions . add ( new Story ( ) ) ; adapter . notifyItemRangeRemoved ( <NUM_LIT> , oldSize + <NUM_LIT> ) ; submissions . addAll ( JSONParser . algoliaJsonToStories ( response ) ) ; adapter . loadingFailed = false ; adapter . loadingFailedServerError = false ; adapter . notifyItemRangeInserted ( <NUM_LIT> , submissions . size ( ) ) ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } , error -> { if ( error . networkResponse != null && error . networkResponse . statusCode == <NUM_LIT> ) { adapter . loadingFailedServerError = true ; } error . printStackTrace ( ) ; swipeRefreshLayout . setRefreshing ( false ) ; adapter . loadingFailed = true ; adapter . notifyItemChanged ( <NUM_LIT> ) ; } ) ; queue . add ( stringRequest ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class ChangelogViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) { return isToolbarExpanded ;", "output": "} public void setToolbarExpanded ( boolean toolbarExpanded ) { isToolbarExpanded = toolbarExpanded ; } }"}, {"input": "package com . reactnative . pulltorefresh ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import java . util . HashMap ; public class PullToRefreshManager extends ViewGroupManager < PullToRefresh > { public final static String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected PullToRefresh createViewInstance ( @ NonNull ThemedReactContext reactContext ) {", "output": "PullToRefresh pullToRefresh = new PullToRefresh ( reactContext ) ; pullToRefresh . setEnableOverScrollBounce ( false ) ; pullToRefresh . setEnableOverScrollDrag ( true ) ; pullToRefresh . setEnableRefresh ( false ) ; pullToRefresh . setEnableLoadMore ( false ) ; return pullToRefresh ; } HashMap < Integer , View > reactChildMap = new HashMap < > ( ) ; @ Override public void addView ( PullToRefresh parent , View child , int index ) { if ( child instanceof PullToRefreshHeader ) { parent . setEnableRefresh ( true ) ; parent . setRefreshHeader ( ( RefreshHeader ) child ) ; if ( parent . isLaidOut ( ) ) { ( ( PullToRefreshHeader ) child ) . onInitialized ( parent . getRefreshKernel ( ) , <NUM_LIT> , <NUM_LIT> ) ; } } else if ( child instanceof PullToRefreshFooter ) { parent . setEnableLoadMore ( true ) ; parent . setRefreshFooter ( ( RefreshFooter ) child ) ; if ( parent . isLaidOut ( ) ) { ( ( PullToRefreshFooter ) child ) . onInitialized ( parent . getRefreshKernel ( ) , <NUM_LIT> , <NUM_LIT> ) ; } } else { parent . setRefreshContent ( child ) ; } reactChildMap . put ( index , child ) ; } @ Override public void removeViewAt ( PullToRefresh parent , int index ) { View child = reactChildMap . get ( index ) ; for ( int i = <NUM_LIT> ; i < parent . getChildCount ( ) ; i ++ ) { if ( child == parent . getChildAt ( i ) ) { if ( child instanceof PullToRefreshHeader ) { parent . setEnableRefresh ( false ) ; parent . setOnRefreshListener ( null ) ; } else if ( child instanceof PullToRefreshFooter ) { parent . setEnableLoadMore ( false ) ; parent . setOnLoadMoreListener ( null ) ; } super . removeViewAt ( parent , i ) ; break ; } } reactChildMap . remove ( index ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setOverflow ( PullToRefresh view , @ Nullable String overflow ) { view . setOverflow ( overflow ) ; } @ Override public boolean needsCustomLayoutForChildren ( ) { return true ; } }"}, {"input": "package com . appspa . update . proxy . impl ; import android . content . ComponentName ; import android . content . Intent ; import android . content . ServiceConnection ; import android . net . Uri ; import android . os . IBinder ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . AppSpace ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . service . DownloadService ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . utils . UpdateUtils ; public class DefaultUpdateDownloader implements IUpdateDownloader { private DownloadService . DownloadBinder mDownloadBinder ; private ServiceConnection mServiceConnection ; private boolean mIsBound ; @ Override public void startDownload ( final @ NonNull UpdateEntity updateEntity , final @ Nullable OnFileDownloadListener downloadListener ) { if ( isDownloadUrl ( updateEntity ) ) { startDownloadService ( updateEntity , downloadListener ) ; } else { startOpenHtml ( updateEntity , downloadListener ) ; } } protected boolean isDownloadUrl ( @ NonNull UpdateEntity updateEntity ) { return ! isStaticHtmlUrl ( updateEntity ) ; } protected boolean isStaticHtmlUrl ( @ NonNull UpdateEntity updateEntity ) { String downloadUrl = updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ; if ( TextUtils . isEmpty ( downloadUrl ) ) { return false ; } String urlContent = downloadUrl . substring ( downloadUrl . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; return urlContent . contains ( \"<STR_LIT>\" ) || urlContent . contains ( \"<STR_LIT>\" ) ; } protected void startDownloadService ( @ NonNull final UpdateEntity updateEntity , @ Nullable final OnFileDownloadListener downloadListener ) { DownloadService . bindService ( mServiceConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { mIsBound = true ; startDownload ( ( DownloadService . DownloadBinder ) service , updateEntity , downloadListener ) ; } @ Override public void onServiceDisconnected ( ComponentName name ) { mIsBound = false ; } } ) ; } protected void startOpenHtml ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { Intent intent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( updateEntity . getCurDownloadEntity ( ) . getDownloadUrl ( ) ) ) ; boolean result = UpdateUtils . startActivity ( intent ) ; if ( downloadListener != null ) { if ( result ) { if ( ! updateEntity . isForce ( ) ) { downloadListener . onCompleted ( null ) ; } } else { downloadListener . onError ( null ) ; } } } private void startDownload ( DownloadService . DownloadBinder binder , @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { mDownloadBinder = binder ; mDownloadBinder . start ( updateEntity , downloadListener ) ; } @ Override public void cancelDownload ( ) { if ( mDownloadBinder != null ) { mDownloadBinder . stop ( \"<STR_LIT>\" ) ; }", "output": "if ( mIsBound && mServiceConnection != null ) { AppSpace . getContext ( ) . unbindService ( mServiceConnection ) ; mIsBound = false ; } } @ Override public void backgroundDownload ( ) { if ( mDownloadBinder != null ) { mDownloadBinder . showNotification ( ) ; } } }"}, {"input": "public class A { private void encrypt ( String a , String c ) { byte three = one ^ two ; byte [ ] b = xorArrayBytes ( operador1 , operador2 ) ; } private void test ( String a , String c ) { byte three = one ^ two ; byte [ ] b = xorArrayBytes ( operador1 , operador2 ) ; }", "output": "}"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . content . ContentValues ; import android . os . Bundle ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class ChatLimit extends Feature { public ChatLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var antiDisappearing = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var revokeallmessages = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var chatLimitDeleteMethod = Unobfuscator . loadChatLimitDeleteMethod ( classLoader ) ; var chatLimitDelete2Method = Unobfuscator . loadChatLimitDelete2Method ( classLoader ) ; var epUpdateMethod = Unobfuscator . loadEphemeralInsertdb ( classLoader ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { MessageStore . getInstance ( ) . executeSQL ( \"<STR_LIT>\" ) ; }", "output": "} } ) ; XposedBridge . hookMethod ( epUpdateMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( antiDisappearing ) { var contentValues = ( ContentValues ) param . getResult ( ) ; contentValues . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; } } } ) ; XposedBridge . hookMethod ( chatLimitDeleteMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Unobfuscator . isCalledFromMethod ( chatLimitDelete2Method ) && revokeallmessages ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; var seeMoreMethod = Unobfuscator . loadSeeMoreMethod ( classLoader ) ; XposedBridge . hookMethod ( seeMoreMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; param . args [ <NUM_LIT> ] = <NUM_LIT> ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package org . woheller69 . weather . ui ; import org . woheller69 . weather . R ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion . WeatherCategories ; public class UiResourceProvider { private UiResourceProvider ( ) { } public static int getIconResourceForWeatherCategory ( int categoryNumber , boolean isDay ) { if ( categoryNumber == WeatherCategories . CLEAR_SKY . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_00d ; } else { return R . drawable . wmo_icon_00n ; } } else if ( categoryNumber == WeatherCategories . FEW_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_01d ; } else { return R . drawable . wmo_icon_01n ; } } else if ( categoryNumber == WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_02d ; } else { return R . drawable . wmo_icon_02n ; } } else if ( categoryNumber == WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_03d ; } else { return R . drawable . wmo_icon_03n ; } } else if ( categoryNumber == WeatherCategories . MIST . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_45d ; } else { return R . drawable . wmo_icon_45n ; } } else if ( categoryNumber == WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_53d ; } else { return R . drawable . wmo_icon_53n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_57d ; } else { return R . drawable . wmo_icon_57n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_61d ; } else { return R . drawable . wmo_icon_61n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_63d ; } else { return R . drawable . wmo_icon_63n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_65d ; } else { return R . drawable . wmo_icon_65n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_80d ; } else { return R . drawable . wmo_icon_80n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_81d ; } else { return R . drawable . wmo_icon_81n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_71d ; } else { return R . drawable . wmo_icon_71n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_73d ; } else { return R . drawable . wmo_icon_73n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_75d ; } else { return R . drawable . wmo_icon_75n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_66d ;", "output": "} else { return R . drawable . wmo_icon_66n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_67d ; } else { return R . drawable . wmo_icon_67n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_85d ; } else { return R . drawable . wmo_icon_85n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_86d ; } else { return R . drawable . wmo_icon_86n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_84d ; } else { return R . drawable . wmo_icon_84n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_95d ; } else { return R . drawable . wmo_icon_95n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_icon_96d ; } else { return R . drawable . wmo_icon_96n ; } } else { return R . drawable . wmo_icon_error ; } } public static int getImageResourceForWeatherCategory ( int categoryNumber , boolean isDay ) { if ( categoryNumber == WeatherCategories . CLEAR_SKY . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_00d ; } else { return R . drawable . wmo_image_00n ; } } else if ( categoryNumber == WeatherCategories . FEW_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_01d ; } else { return R . drawable . wmo_image_01n ; } } else if ( categoryNumber == WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_02d ; } else { return R . drawable . wmo_image_02n ; } } else if ( categoryNumber == WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_03d ; } else { return R . drawable . wmo_image_03n ; } } else if ( categoryNumber == WeatherCategories . MIST . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_45d ; } else { return R . drawable . wmo_image_45n ; } } else if ( categoryNumber == WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_53d ; } else { return R . drawable . wmo_image_53n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_57d ; } else { return R . drawable . wmo_image_57n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_61d ; } else { return R . drawable . wmo_image_61n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_63d ; } else { return R . drawable . wmo_image_63n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_65d ; } else { return R . drawable . wmo_image_65n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_80d ; } else { return R . drawable . wmo_image_80n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_81d ; } else { return R . drawable . wmo_image_81n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_71d ; } else { return R . drawable . wmo_image_71n ; } } else if ( categoryNumber == WeatherCategories . MODERATE_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_73d ; } else { return R . drawable . wmo_image_73n ; } } else if ( categoryNumber == WeatherCategories . HEAVY_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_75d ; } else { return R . drawable . wmo_image_75n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_66d ; } else { return R . drawable . wmo_image_66n ; } } else if ( categoryNumber == WeatherCategories . FREEZING_RAIN . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_67d ; } else { return R . drawable . wmo_image_67n ; } } else if ( categoryNumber == WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_85d ; } else { return R . drawable . wmo_image_85n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_86d ; } else { return R . drawable . wmo_image_86n ; } } else if ( categoryNumber == WeatherCategories . SHOWER_RAIN_SNOW . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_84d ; } else { return R . drawable . wmo_image_84n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_95d ; } else { return R . drawable . wmo_image_95n ; } } else if ( categoryNumber == WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ) { if ( isDay ) { return R . drawable . wmo_image_96d ; } else { return R . drawable . wmo_image_96n ; } } else { return R . drawable . wmo_image_error ; } } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . collection . LongSparseArray ; interface StableIdStorage { @ NonNull StableIdLookup createStableIdLookup ( ) ; interface StableIdLookup { long localToGlobal ( long localId ) ; } class NoStableIdStorage implements StableIdStorage { private final StableIdLookup mNoIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return RecyclerView . NO_ID ; } } ; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mNoIdLookup ; } } class SharedPoolStableIdStorage implements StableIdStorage { private final StableIdLookup mSameIdLookup = new StableIdLookup ( ) { @ Override public long localToGlobal ( long localId ) { return localId ; } }", "output": "; @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return mSameIdLookup ; } } class IsolatedStableIdStorage implements StableIdStorage { long mNextStableId = <NUM_LIT> ; long obtainId ( ) { return mNextStableId ++ ; } @ NonNull @ Override public StableIdLookup createStableIdLookup ( ) { return new WrapperStableIdLookup ( ) ; } class WrapperStableIdLookup implements StableIdLookup { private final LongSparseArray < Long > mLocalToGlobalLookup = new LongSparseArray < > ( ) ; @ Override public long localToGlobal ( long localId ) { Long globalId = mLocalToGlobalLookup . get ( localId ) ; if ( globalId == null ) { globalId = obtainId ( ) ; mLocalToGlobalLookup . put ( localId , globalId ) ; } return globalId ; } } } }"}, {"input": "package com . wmods . wppenhacer . xposed . core . components ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FMessageWpp { public static Class < ? > TYPE ; private static boolean initialized ; private static Method userJidMethod ; private static Field keyMessage ; private static Field getFieldIdMessage ; private static Method deviceJidMethod ; private static Method messageMethod ; private static Method messageWithMediaMethod ; private final Object fmessage ; public FMessageWpp ( Object fMessage ) { if ( fMessage == null ) throw new RuntimeException ( \"<STR_LIT>\" ) ; this . fmessage = fMessage ; try { init ( fMessage . getClass ( ) . getClassLoader ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void init ( ClassLoader classLoader ) throws Exception { if ( initialized ) return ; initialized = true ; TYPE = Unobfuscator . loadFMessageClass ( classLoader ) ; var userJidClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; userJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == userJidClass ) ; keyMessage = Unobfuscator . loadMessageKeyField ( classLoader ) ; messageMethod = Unobfuscator . loadNewMessageMethod ( classLoader ) ; messageWithMediaMethod = Unobfuscator . loadNewMessageWithMediaMethod ( classLoader ) ; getFieldIdMessage = Unobfuscator . loadSetEditMessageField ( classLoader ) ; deviceJidMethod = ReflectionUtils . findMethodUsingFilter ( TYPE , method -> method . getReturnType ( ) . equals ( XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ) ) ; } public Object getUserJid ( ) { try { return userJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getDeviceJid ( ) { try { return deviceJidMethod . invoke ( fmessage ) ; } catch ( Exception e ) {", "output": "XposedBridge . log ( e ) ; } return null ; } public long getRowId ( ) { try { return getFieldIdMessage . getLong ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return <NUM_LIT> ; } public Key getKey ( ) { try { return new Key ( keyMessage . get ( fmessage ) ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public Object getObject ( ) { return fmessage ; } public String getMessageStr ( ) { try { var message = ( String ) messageMethod . invoke ( fmessage ) ; if ( message != null ) return message ; return ( String ) messageWithMediaMethod . invoke ( fmessage ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; return null ; } } public static class Key { public final Object thisObject ; public final String messageID ; public final boolean isFromMe ; public final Object remoteJid ; public Key ( Object key ) { this . thisObject = key ; this . messageID = ( String ) XposedHelpers . getObjectField ( key , \"<STR_LIT>\" ) ; this . isFromMe = XposedHelpers . getBooleanField ( key , \"<STR_LIT>\" ) ; this . remoteJid = XposedHelpers . getObjectField ( key , \"<STR_LIT>\" ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . util . bluetooth ; import android . bluetooth . BluetoothAdapter ; import android . bluetooth . BluetoothDevice ; import android . bluetooth . BluetoothHeadset ; import android . bluetooth . BluetoothProfile ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . media . AudioManager ; import android . util . Log ; import java . util . List ; import static android . media . AudioManager . STREAM_VOICE_CALL ; public class AndroidAudioManager { private static volatile AndroidAudioManager instance ; private BluetoothAdapter mBluetoothAdapter ; private AudioManager mAudioManager ; private boolean mIsBluetoothHeadsetConnected ; private boolean mIsBluetoothHeadsetScoConnected ; private BluetoothReceiver mBluetoothReceiver ; private HeadsetReceiver mHeadsetReceiver ; private boolean mAudioFocused ; private Context mContext ; private BluetoothHeadset mBluetoothHeadset ; private AndroidAudioManager ( Context context ) { mAudioManager = ( ( AudioManager ) context . getSystemService ( Context . AUDIO_SERVICE ) ) ; this . mContext = context . getApplicationContext ( ) ; } public AudioManager getAudioManager ( ) { return mAudioManager ; } public static AndroidAudioManager getInstance ( Context context ) { if ( instance == null ) { synchronized ( AndroidAudioManager . class ) { if ( instance == null ) { instance = new AndroidAudioManager ( context ) ; } } } return instance ; } public void startBluetooth ( ) { mBluetoothAdapter = BluetoothAdapter . getDefaultAdapter ( ) ; if ( mBluetoothAdapter != null ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( mAudioManager . isBluetoothScoAvailableOffCall ( ) ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } if ( mBluetoothAdapter . isEnabled ( ) ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; mBluetoothReceiver = new BluetoothReceiver ( ) ; mIsBluetoothHeadsetConnected = false ; mIsBluetoothHeadsetScoConnected = false ; BluetoothProfile . ServiceListener bluetoothServiceListener = new BluetoothProfile . ServiceListener ( ) { public void onServiceConnected ( int profile , BluetoothProfile proxy ) { if ( profile == BluetoothProfile . HEADSET ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; mBluetoothHeadset = ( BluetoothHeadset ) proxy ; List < BluetoothDevice > devices = mBluetoothHeadset . getConnectedDevices ( ) ; if ( devices . size ( ) > <NUM_LIT> ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bluetoothHeadetConnectionChanged ( true ) ; } Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; IntentFilter filter = new IntentFilter ( ) ; filter . addAction ( BluetoothHeadset . ACTION_AUDIO_STATE_CHANGED ) ; filter . addAction ( BluetoothHeadset . ACTION_CONNECTION_STATE_CHANGED ) ; filter . addAction ( AudioManager . ACTION_SCO_AUDIO_STATE_UPDATED ) ; filter . addAction ( BluetoothHeadset . ACTION_VENDOR_SPECIFIC_HEADSET_EVENT ) ; Intent sticky = mContext . registerReceiver ( mBluetoothReceiver , filter ) ; int state = sticky . getIntExtra ( AudioManager . EXTRA_SCO_AUDIO_STATE , AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) ; if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bluetoothHeadetScoConnectionChanged ( true ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_DISCONNECTED ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bluetoothHeadetScoConnectionChanged ( false ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_CONNECTING ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else if ( state == AudioManager . SCO_AUDIO_STATE_ERROR ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + \"<STR_LIT>\" + state ) ; } } } public void onServiceDisconnected ( int profile ) { if ( profile == BluetoothProfile . HEADSET ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; mBluetoothHeadset = null ; mIsBluetoothHeadsetConnected = false ; mIsBluetoothHeadsetScoConnected = false ; } } } ; mBluetoothAdapter . getProfileProxy ( mContext , bluetoothServiceListener , BluetoothProfile . HEADSET ) ; } } } public synchronized void bluetoothHeadetConnectionChanged ( boolean connected ) { mIsBluetoothHeadsetConnected = connected ; mAudioManager . setBluetoothScoOn ( connected ) ; mAudioManager . startBluetoothSco ( ) ; routeAudioToBluetooth ( ) ; } public synchronized boolean isBluetoothHeadsetConnected ( ) { return mIsBluetoothHeadsetConnected ; } public synchronized void bluetoothHeadetScoConnectionChanged ( boolean connected ) { mIsBluetoothHeadsetScoConnected = connected ; } public synchronized boolean isUsingBluetoothAudioRoute ( ) { return mIsBluetoothHeadsetScoConnected ; } public synchronized void routeAudioToBluetooth ( ) { if ( ! isBluetoothHeadsetConnected ( ) ) { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ; } if ( mAudioManager . getMode ( ) != AudioManager . MODE_IN_COMMUNICATION ) { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; mAudioManager . setMode ( AudioManager . MODE_IN_COMMUNICATION ) ; requestAudioFocus ( STREAM_VOICE_CALL ) ; } changeBluetoothSco ( true ) ; } private void requestAudioFocus ( int stream ) { if ( ! mAudioFocused ) { int res = mAudioManager . requestAudioFocus ( null , stream , AudioManager . AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + ( res == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ) ; if ( res == AudioManager . AUDIOFOCUS_REQUEST_GRANTED ) { mAudioFocused = true ; } } } private synchronized void changeBluetoothSco ( final boolean enable ) { if ( enable && mIsBluetoothHeadsetScoConnected ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ; } else if ( ! enable && ! mIsBluetoothHeadsetScoConnected ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ; } new Thread ( ) { @ Override public void run ( ) { boolean resultAcknoledged ; int retries = <NUM_LIT> ; do { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { Log . e ( \"<STR_LIT>\" , e . getMessage ( ) , e ) ; } synchronized ( AndroidAudioManager . this ) { if ( enable ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + retries ) ; mAudioManager . startBluetoothSco ( ) ; } else { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + retries ) ; mAudioManager . stopBluetoothSco ( ) ; } resultAcknoledged = isUsingBluetoothAudioRoute ( ) == enable ; retries ++ ; } } while ( ! resultAcknoledged && retries < <NUM_LIT> ) ; } } . start ( ) ; } public void destroy ( ) { if ( mBluetoothAdapter != null && mBluetoothHeadset != null ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; mBluetoothAdapter . closeProfileProxy ( BluetoothProfile . HEADSET , mBluetoothHeadset ) ; } Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( mBluetoothReceiver != null ) { mContext . unregisterReceiver ( mBluetoothReceiver ) ; } synchronized ( AndroidAudioManager . class ) { mContext = null ; instance = null ; } } public void startSimpleBluetooth ( ) { mAudioManager . setBluetoothScoOn ( true ) ; mAudioManager . startBluetoothSco ( ) ; } public void destorySimpleBluetooth ( ) { mAudioManager . setBluetoothScoOn ( false ) ; mAudioManager . stopBluetoothSco ( ) ; } public void enableHeadsetReceiver ( ) { mHeadsetReceiver = new HeadsetReceiver ( ) ; Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; mContext . registerReceiver ( mHeadsetReceiver , new IntentFilter ( AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) ; mContext . registerReceiver ( mHeadsetReceiver , new IntentFilter ( AudioManager . ACTION_HEADSET_PLUG ) ) ; } public void routeAudioToEarPiece ( ) { routeAudioToSpeakerHelper ( false ) ; } public void routeAudioToSpeakerHelper ( boolean speakerOn ) { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" + ( speakerOn ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ) ;", "output": "if ( mIsBluetoothHeadsetScoConnected ) { Log . w ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; changeBluetoothSco ( false ) ; } mAudioManager . setSpeakerphoneOn ( speakerOn ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import org . junit . Test ; import static org . junit . Assert . * ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; }", "output": "}"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . util . SparseBooleanArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . UiThread ; import androidx . annotation . WorkerThread ; public class AsyncListUtil < T > { static final String TAG = \"<STR_LIT>\" ; static final boolean DEBUG = false ; final Class < T > mTClass ; final int mTileSize ; final DataCallback < T > mDataCallback ; final ViewCallback mViewCallback ; final TileList < T > mTileList ; final ThreadUtil . MainThreadCallback < T > mMainThreadProxy ; final ThreadUtil . BackgroundCallback < T > mBackgroundProxy ; final int [ ] mTmpRange = new int [ <NUM_LIT> ] ; final int [ ] mPrevRange = new int [ <NUM_LIT> ] ; final int [ ] mTmpRangeExtended = new int [ <NUM_LIT> ] ; boolean mAllowScrollHints ; private int mScrollHint = ViewCallback . HINT_SCROLL_NONE ; int mItemCount = <NUM_LIT> ; int mDisplayedGeneration = <NUM_LIT> ; int mRequestedGeneration = mDisplayedGeneration ; final SparseIntArray mMissingPositions = new SparseIntArray ( ) ; void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } public AsyncListUtil ( @ NonNull Class < T > klass , int tileSize , @ NonNull DataCallback < T > dataCallback , @ NonNull ViewCallback viewCallback ) { mTClass = klass ; mTileSize = tileSize ; mDataCallback = dataCallback ; mViewCallback = viewCallback ; mTileList = new TileList < T > ( mTileSize ) ; ThreadUtil < T > threadUtil = new MessageThreadUtil < T > ( ) ; mMainThreadProxy = threadUtil . getMainThreadProxy ( mMainThreadCallback ) ; mBackgroundProxy = threadUtil . getBackgroundProxy ( mBackgroundCallback ) ; refresh ( ) ; } private boolean isRefreshPending ( ) { return mRequestedGeneration != mDisplayedGeneration ; } public void onRangeChanged ( ) { if ( isRefreshPending ( ) ) { return ; } updateRange ( ) ; mAllowScrollHints = true ; } public void refresh ( ) { mMissingPositions . clear ( ) ; mBackgroundProxy . refresh ( ++ mRequestedGeneration ) ; } @ Nullable public T getItem ( int position ) { if ( position < <NUM_LIT> || position >= mItemCount ) { throw new IndexOutOfBoundsException ( position + \"<STR_LIT>\" + mItemCount ) ; } T item = mTileList . getItemAt ( position ) ; if ( item == null && ! isRefreshPending ( ) ) { mMissingPositions . put ( position , <NUM_LIT> ) ; } return item ; } public int getItemCount ( ) { return mItemCount ; } void updateRange ( ) { mViewCallback . getItemRangeInto ( mTmpRange ) ; if ( mTmpRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] || mTmpRange [ <NUM_LIT> ] < <NUM_LIT> ) { return ; } if ( mTmpRange [ <NUM_LIT> ] >= mItemCount ) { return ; } if ( ! mAllowScrollHints ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] || mPrevRange [ <NUM_LIT> ] > mTmpRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_NONE ; } else if ( mTmpRange [ <NUM_LIT> ] < mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_DESC ; } else if ( mTmpRange [ <NUM_LIT> ] > mPrevRange [ <NUM_LIT> ] ) { mScrollHint = ViewCallback . HINT_SCROLL_ASC ; } mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mPrevRange [ <NUM_LIT> ] = mTmpRange [ <NUM_LIT> ] ; mViewCallback . extendRangeInto ( mTmpRange , mTmpRangeExtended , mScrollHint ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . min ( mTmpRange [ <NUM_LIT> ] , Math . max ( mTmpRangeExtended [ <NUM_LIT> ] , <NUM_LIT> ) ) ; mTmpRangeExtended [ <NUM_LIT> ] = Math . max ( mTmpRange [ <NUM_LIT> ] , Math . min ( mTmpRangeExtended [ <NUM_LIT> ] , mItemCount - <NUM_LIT> ) ) ; mBackgroundProxy . updateRange ( mTmpRange [ <NUM_LIT> ] , mTmpRange [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mTmpRangeExtended [ <NUM_LIT> ] , mScrollHint ) ; } private final ThreadUtil . MainThreadCallback < T > mMainThreadCallback = new ThreadUtil . MainThreadCallback < T > ( ) { @ Override public void updateItemCount ( int generation , int itemCount ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , itemCount , generation ) ; } if ( ! isRequestedGeneration ( generation ) ) { return ; } mItemCount = itemCount ; mViewCallback . onDataRefresh ( ) ; mDisplayedGeneration = mRequestedGeneration ; recycleAllTiles ( ) ; mAllowScrollHints = false ; updateRange ( ) ; } @ Override public void addTile ( int generation , TileList . Tile < T > tile ) { if ( ! isRequestedGeneration ( generation ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mBackgroundProxy . recycleTile ( tile ) ; return ; } TileList . Tile < T > duplicate = mTileList . addOrReplace ( tile ) ; if ( duplicate != null ) { Log . e ( TAG , \"<STR_LIT>\" + duplicate . mStartPosition ) ; mBackgroundProxy . recycleTile ( duplicate ) ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , generation , tile . mStartPosition , mTileList . size ( ) ) ; } int endPosition = tile . mStartPosition + tile . mItemCount ; int index = <NUM_LIT> ; while ( index < mMissingPositions . size ( ) ) { final int position = mMissingPositions . keyAt ( index ) ; if ( tile . mStartPosition <= position && position < endPosition ) { mMissingPositions . removeAt ( index ) ; mViewCallback . onItemLoaded ( position ) ; } else { index ++ ; } } } @ Override public void removeTile ( int generation , int position ) { if ( ! isRequestedGeneration ( generation ) ) { return ; } TileList . Tile < T > tile = mTileList . removeAtPos ( position ) ; if ( tile == null ) { Log . e ( TAG , \"<STR_LIT>\" + position ) ; return ; } if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mTileList . size ( ) ) ; } mBackgroundProxy . recycleTile ( tile ) ; } private void recycleAllTiles ( ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , mTileList . size ( ) ) ; } for ( int i = <NUM_LIT> ; i < mTileList . size ( ) ; i ++ ) { mBackgroundProxy . recycleTile ( mTileList . getAtIndex ( i ) ) ; } mTileList . clear ( ) ; } private boolean isRequestedGeneration ( int generation ) {", "output": "return generation == mRequestedGeneration ; } } ; private final ThreadUtil . BackgroundCallback < T > mBackgroundCallback = new ThreadUtil . BackgroundCallback < T > ( ) { private TileList . Tile < T > mRecycledRoot ; final SparseBooleanArray mLoadedTiles = new SparseBooleanArray ( ) ; private int mGeneration ; private int mItemCount ; private int mFirstRequiredTileStart ; private int mLastRequiredTileStart ; @ Override public void refresh ( int generation ) { mGeneration = generation ; mLoadedTiles . clear ( ) ; mItemCount = mDataCallback . refreshData ( ) ; mMainThreadProxy . updateItemCount ( mGeneration , mItemCount ) ; } @ Override public void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , rangeStart , rangeEnd , extRangeStart , extRangeEnd , scrollHint ) ; } if ( rangeStart > rangeEnd ) { return ; } final int firstVisibleTileStart = getTileStart ( rangeStart ) ; final int lastVisibleTileStart = getTileStart ( rangeEnd ) ; mFirstRequiredTileStart = getTileStart ( extRangeStart ) ; mLastRequiredTileStart = getTileStart ( extRangeEnd ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , mFirstRequiredTileStart , mLastRequiredTileStart ) ; } if ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) { requestTiles ( mFirstRequiredTileStart , lastVisibleTileStart , scrollHint , true ) ; requestTiles ( lastVisibleTileStart + mTileSize , mLastRequiredTileStart , scrollHint , false ) ; } else { requestTiles ( firstVisibleTileStart , mLastRequiredTileStart , scrollHint , false ) ; requestTiles ( mFirstRequiredTileStart , firstVisibleTileStart - mTileSize , scrollHint , true ) ; } } private int getTileStart ( int position ) { return position - position % mTileSize ; } private void requestTiles ( int firstTileStart , int lastTileStart , int scrollHint , boolean backwards ) { for ( int i = firstTileStart ; i <= lastTileStart ; i += mTileSize ) { int tileStart = backwards ? ( lastTileStart + firstTileStart - i ) : i ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tileStart ) ; } mBackgroundProxy . loadTile ( tileStart , scrollHint ) ; } } @ Override public void loadTile ( int position , int scrollHint ) { if ( isTileLoaded ( position ) ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , position ) ; } return ; } TileList . Tile < T > tile = acquireTile ( ) ; tile . mStartPosition = position ; tile . mItemCount = Math . min ( mTileSize , mItemCount - tile . mStartPosition ) ; mDataCallback . fillData ( tile . mItems , tile . mStartPosition , tile . mItemCount ) ; flushTileCache ( scrollHint ) ; addTile ( tile ) ; } @ Override public void recycleTile ( TileList . Tile < T > tile ) { if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition ) ; } mDataCallback . recycleData ( tile . mItems , tile . mItemCount ) ; tile . mNext = mRecycledRoot ; mRecycledRoot = tile ; } private TileList . Tile < T > acquireTile ( ) { if ( mRecycledRoot != null ) { TileList . Tile < T > result = mRecycledRoot ; mRecycledRoot = mRecycledRoot . mNext ; return result ; } return new TileList . Tile < T > ( mTClass , mTileSize ) ; } private boolean isTileLoaded ( int position ) { return mLoadedTiles . get ( position ) ; } private void addTile ( TileList . Tile < T > tile ) { mLoadedTiles . put ( tile . mStartPosition , true ) ; mMainThreadProxy . addTile ( mGeneration , tile ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , tile . mStartPosition , mLoadedTiles . size ( ) ) ; } } private void removeTile ( int position ) { mLoadedTiles . delete ( position ) ; mMainThreadProxy . removeTile ( mGeneration , position ) ; if ( DEBUG ) { log ( \"<STR_LIT>\" , position , mLoadedTiles . size ( ) ) ; } } private void flushTileCache ( int scrollHint ) { final int cacheSizeLimit = mDataCallback . getMaxCachedTiles ( ) ; while ( mLoadedTiles . size ( ) >= cacheSizeLimit ) { int firstLoadedTileStart = mLoadedTiles . keyAt ( <NUM_LIT> ) ; int lastLoadedTileStart = mLoadedTiles . keyAt ( mLoadedTiles . size ( ) - <NUM_LIT> ) ; int startMargin = mFirstRequiredTileStart - firstLoadedTileStart ; int endMargin = lastLoadedTileStart - mLastRequiredTileStart ; if ( startMargin > <NUM_LIT> && ( startMargin >= endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_ASC ) ) ) { removeTile ( firstLoadedTileStart ) ; } else if ( endMargin > <NUM_LIT> && ( startMargin < endMargin || ( scrollHint == ViewCallback . HINT_SCROLL_DESC ) ) ) { removeTile ( lastLoadedTileStart ) ; } else { return ; } } } private void log ( String s , Object ... args ) { Log . d ( TAG , \"<STR_LIT>\" + String . format ( s , args ) ) ; } } ; public static abstract class DataCallback < T > { @ WorkerThread public abstract int refreshData ( ) ; @ WorkerThread public abstract void fillData ( @ NonNull T [ ] data , int startPosition , int itemCount ) ; @ WorkerThread public void recycleData ( @ NonNull T [ ] data , int itemCount ) { } @ WorkerThread public int getMaxCachedTiles ( ) { return <NUM_LIT> ; } } public static abstract class ViewCallback { public static final int HINT_SCROLL_NONE = <NUM_LIT> ; public static final int HINT_SCROLL_DESC = <NUM_LIT> ; public static final int HINT_SCROLL_ASC = <NUM_LIT> ; @ UiThread public abstract void getItemRangeInto ( @ NonNull int [ ] outRange ) ; @ UiThread public void extendRangeInto ( @ NonNull int [ ] range , @ NonNull int [ ] outRange , int scrollHint ) { final int fullRange = range [ <NUM_LIT> ] - range [ <NUM_LIT> ] + <NUM_LIT> ; final int halfRange = fullRange / <NUM_LIT> ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] - ( scrollHint == HINT_SCROLL_DESC ? fullRange : halfRange ) ; outRange [ <NUM_LIT> ] = range [ <NUM_LIT> ] + ( scrollHint == HINT_SCROLL_ASC ? fullRange : halfRange ) ; } @ UiThread public abstract void onDataRefresh ( ) ; @ UiThread public abstract void onItemLoaded ( int position ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . app . Activity ; import androidx . annotation . OptIn ; import androidx . window . embedding . SplitAttributes . SplitType ; import androidx . window . embedding . SplitController ; import androidx . window . embedding . SplitInfo ; import androidx . window . java . embedding . SplitControllerCallbackAdapter ; import com . gw . swipeback . SwipeBackLayout ; import java . util . List ; @ OptIn ( markerClass = androidx . window . core . ExperimentalWindowApi . class ) public class SplitChangeHandler { private final SplitControllerCallbackAdapter splitCallbackAdapter ; private final SwipeBackLayout layout ; private boolean isWithinSplit = false ; public SplitChangeHandler ( Activity activity , SwipeBackLayout swipeBackLayout ) { this . splitCallbackAdapter = new SplitControllerCallbackAdapter ( SplitController . getInstance ( activity ) ) ; this . layout = swipeBackLayout ; splitCallbackAdapter . addSplitListener ( activity , Runnable :: run , this :: onSplitListUpdate ) ; } private void onSplitListUpdate ( List < SplitInfo > splitInfoList ) { for ( SplitInfo split : splitInfoList ) { if ( ! split . getSplitAttributes ( ) . getSplitType ( ) . equals ( SplitType . SPLIT_TYPE_EXPAND ) ) { isWithinSplit = true ; break ; } isWithinSplit = false ; } layout . setMaskAlpha ( isWithinSplit ? <NUM_LIT> : <NUM_LIT> ) ; } public boolean isWithinSplit ( ) { return isWithinSplit ; } public void teardown ( ) { splitCallbackAdapter . removeSplitListener ( this :: onSplitListUpdate ) ; }", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; import com . google . mlkit . nl . translate . TranslateRemoteModel ; import java . util . Set ; public interface GetDownloadedModelsResultCallback { void success ( Set < TranslateRemoteModel > models ) ;", "output": "void error ( Exception exception ) ; }"}, {"input": "public class MainActivity extends AppCompatActivity { private void test ( ) { ClipboardManager clipboard = ( ClipboardManager ) getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; clipboard . setPrimaryClip ( clip ) ; }", "output": "}"}, {"input": "package org . woheller69 . weather . ui . util ; import android . content . Context ; import android . widget . ArrayAdapter ; import android . widget . Filter ; import android . widget . Filterable ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import org . woheller69 . weather . database . City ; import java . util . ArrayList ; import java . util . List ; public class AutoSuggestAdapter extends ArrayAdapter < String > implements Filterable { private final List < String > mlistData ; private final List < City > mlistCity ; public AutoSuggestAdapter ( @ NonNull Context context , int resource ) { super ( context , resource ) ; mlistData = new ArrayList < > ( ) ;", "output": "mlistCity = new ArrayList < > ( ) ; } public void setData ( List < String > list , List < City > cityList ) { mlistData . clear ( ) ; mlistCity . clear ( ) ; mlistData . addAll ( list ) ; mlistCity . addAll ( cityList ) ; } @ Override public int getCount ( ) { return mlistData . size ( ) ; } @ Nullable @ Override public String getItem ( int position ) { return mlistData . get ( position ) ; } public City getObject ( int position ) { return mlistCity . get ( position ) ; } @ NonNull @ Override public Filter getFilter ( ) { Filter dataFilter = new Filter ( ) { @ Override protected FilterResults performFiltering ( CharSequence constraint ) { FilterResults filterResults = new FilterResults ( ) ; if ( constraint != null ) { filterResults . values = mlistData ; filterResults . count = mlistData . size ( ) ; } return filterResults ; } @ Override protected void publishResults ( CharSequence constraint , FilterResults results ) { if ( results != null && ( results . count > <NUM_LIT> ) ) { notifyDataSetChanged ( ) ; } else { notifyDataSetInvalidated ( ) ; } } } ; return dataFilter ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; public interface InstallGoogleBarcodeScannerModuleResultCallback { void success ( ) ; void error ( Exception exception ) ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . FaceDetector ; import com . google . mlkit . vision . face . FaceDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes . ProcessImageResult ; public class FaceDetection { @ NonNull private final FaceDetectionPlugin plugin ; public FaceDetection ( @ NonNull FaceDetectionPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ; int performanceMode = options . getPerformanceMode ( ) ; int landmarkMode = options . getLandmarkMode ( ) ; int contourMode = options . getContourMode ( ) ; int classificationMode = options . getClassificationMode ( ) ; float minFaceSize = options . getMinFaceSize ( ) ; boolean enableTracking = options . isTrackingEnabled ( ) ; FaceDetectorOptions . Builder builder = new FaceDetectorOptions . Builder ( ) ; builder . setPerformanceMode ( performanceMode ) ; builder . setLandmarkMode ( landmarkMode ) ; builder . setContourMode ( contourMode ) ; builder . setClassificationMode ( classificationMode ) ; builder . setMinFaceSize ( minFaceSize ) ; if ( enableTracking ) { builder . enableTracking ( ) ; } FaceDetectorOptions faceDetectorOptions = builder . build ( ) ; final FaceDetector faceDetector = com . google . mlkit . vision . face . FaceDetection . getClient ( faceDetectorOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> { faceDetector . process ( inputImage ) . addOnSuccessListener ( faces -> { faceDetector . close ( ) ;", "output": "ProcessImageResult result = new ProcessImageResult ( faces ) ; callback . success ( result ) ; } ) . addOnCanceledListener ( ( ) -> { faceDetector . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { faceDetector . close ( ) ; callback . error ( exception ) ; } ) ; } ) ; } }"}, {"input": "package de . robv . android . xposed . callbacks ; import android . content . res . XResources ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_InitPackageResources extends XCallback implements IXposedHookInitPackageResources { @ SuppressWarnings ( \"<STR_LIT>\" ) public XC_InitPackageResources ( ) { super ( ) ; } public XC_InitPackageResources ( int priority ) { super ( priority ) ; } public static final class InitPackageResourcesParam extends XCallback . Param { public InitPackageResourcesParam ( CopyOnWriteSortedSet < XC_InitPackageResources > callbacks ) {", "output": "super ( callbacks ) ; } public String packageName ; public XResources res ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof InitPackageResourcesParam ) handleInitPackageResources ( ( InitPackageResourcesParam ) param ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetBundleResult implements Result { @ Nullable private String bundleId ; public GetBundleResult ( @ Nullable String bundleId ) { this . bundleId = bundleId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ;", "output": "result . put ( \"<STR_LIT>\" , bundleId == null ? JSONObject . NULL : bundleId ) ; return result ; } }"}, {"input": "package android . content . res ; import android . graphics . Movie ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import java . io . InputStream ; public class Resources { @ SuppressWarnings ( \"<STR_LIT>\" ) public static class NotFoundException extends RuntimeException { public NotFoundException ( ) { } public NotFoundException ( String name ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } } public final class Theme { } public Resources ( AssetManager assets , DisplayMetrics metrics , Configuration config ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static Resources getSystem ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public XmlResourceParser getAnimation ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public final AssetManager getAssets ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public boolean getBoolean ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getColor ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public ColorStateList getColorStateList ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Configuration getConfiguration ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getDimension ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getDimensionPixelOffset ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getDimensionPixelSize ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public DisplayMetrics getDisplayMetrics ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawable ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawable ( int id , Theme theme ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawable ( int id , Theme theme , boolean supportComposedIcons ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawableForDensity ( int id , int density ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawableForDensity ( int id , int density , Theme theme ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawableForDensity ( int id , int density , Theme theme , boolean supportComposedIcons ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getFloat ( int id ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getFraction ( int id , int base , int pbase ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getIdentifier ( String name , String defType , String defPackage ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int [ ] getIntArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getInteger ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public XmlResourceParser getLayout ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Movie getMovie ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getQuantityString ( int id , int quantity ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getQuantityString ( int id , int quantity , Object ... formatArgs ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence getQuantityText ( int id , int quantity ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getResourceEntryName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getResourceName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ;", "output": "} public String getResourcePackageName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getResourceTypeName ( int resid ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getString ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getString ( int id , Object ... formatArgs ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String [ ] getStringArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence getText ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence getText ( int id , CharSequence def ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence [ ] getTextArray ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public void getValue ( int id , TypedValue outValue , boolean resolveRefs ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public XmlResourceParser getXml ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public InputStream openRawResource ( int id ) throws NotFoundException { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public TypedArray obtainTypedArray ( int id ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ConcatAdapter . Config . StableIdMode . NO_STABLE_IDS ; import android . util . Pair ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ConcatAdapter extends Adapter < ViewHolder > { static final String TAG = \"<STR_LIT>\" ; private final ConcatAdapterController mController ; @ SafeVarargs public ConcatAdapter ( @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( Config . DEFAULT , adapters ) ; } @ SafeVarargs public ConcatAdapter ( @ NonNull Config config , @ NonNull Adapter < ? extends ViewHolder > ... adapters ) { this ( config , Arrays . asList ( adapters ) ) ; } public ConcatAdapter ( @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { this ( Config . DEFAULT , adapters ) ; } public ConcatAdapter ( @ NonNull Config config , @ NonNull List < ? extends Adapter < ? extends ViewHolder > > adapters ) { mController = new ConcatAdapterController ( this , config ) ; for ( Adapter < ? extends ViewHolder > adapter : adapters ) { addAdapter ( adapter ) ; } super . setHasStableIds ( mController . hasStableIds ( ) ) ; } public boolean addAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } public boolean addAdapter ( int index , @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . addAdapter ( index , ( Adapter < ViewHolder > ) adapter ) ; } public boolean removeAdapter ( @ NonNull Adapter < ? extends ViewHolder > adapter ) { return mController . removeAdapter ( ( Adapter < ViewHolder > ) adapter ) ; } @ Override public int getItemViewType ( int position ) { return mController . getItemViewType ( position ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return mController . onCreateViewHolder ( parent , viewType ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { mController . onBindViewHolder ( holder , position ) ; } @ Override public void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void setStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public long getItemId ( int position ) { return mController . getItemId ( position ) ; } void internalSetStateRestorationPolicy ( @ NonNull StateRestorationPolicy strategy ) { super . setStateRestorationPolicy ( strategy ) ; } @ Override public int getItemCount ( ) { return mController . getTotalCount ( ) ;", "output": "} @ Override public boolean onFailedToRecycleView ( @ NonNull ViewHolder holder ) { return mController . onFailedToRecycleView ( holder ) ; } @ Override public void onViewAttachedToWindow ( @ NonNull ViewHolder holder ) { mController . onViewAttachedToWindow ( holder ) ; } @ Override public void onViewDetachedFromWindow ( @ NonNull ViewHolder holder ) { mController . onViewDetachedFromWindow ( holder ) ; } @ Override public void onViewRecycled ( @ NonNull ViewHolder holder ) { mController . onViewRecycled ( holder ) ; } @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onAttachedToRecyclerView ( recyclerView ) ; } @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mController . onDetachedFromRecyclerView ( recyclerView ) ; } @ NonNull public List < ? extends Adapter < ? extends ViewHolder > > getAdapters ( ) { return Collections . unmodifiableList ( mController . getCopyOfAdapters ( ) ) ; } @ Override public int findRelativeAdapterPositionIn ( @ NonNull Adapter < ? extends ViewHolder > adapter , @ NonNull ViewHolder viewHolder , int localPosition ) { return mController . getLocalAdapterPosition ( adapter , viewHolder , localPosition ) ; } @ NonNull public Pair < Adapter < ? extends ViewHolder > , Integer > getWrappedAdapterAndPosition ( int globalPosition ) { return mController . getWrappedAdapterAndPosition ( globalPosition ) ; } public static final class Config { public final boolean isolateViewTypes ; @ NonNull public final StableIdMode stableIdMode ; @ NonNull public static final Config DEFAULT = new Config ( true , NO_STABLE_IDS ) ; Config ( boolean isolateViewTypes , @ NonNull StableIdMode stableIdMode ) { this . isolateViewTypes = isolateViewTypes ; this . stableIdMode = stableIdMode ; } public enum StableIdMode { NO_STABLE_IDS , ISOLATED_STABLE_IDS , SHARED_STABLE_IDS } public static final class Builder { private boolean mIsolateViewTypes = DEFAULT . isolateViewTypes ; private StableIdMode mStableIdMode = DEFAULT . stableIdMode ; @ NonNull public Builder setIsolateViewTypes ( boolean isolateViewTypes ) { mIsolateViewTypes = isolateViewTypes ; return this ; } @ NonNull public Builder setStableIdMode ( @ NonNull StableIdMode stableIdMode ) { mStableIdMode = stableIdMode ; return this ; } @ NonNull public Config build ( ) { return new Config ( mIsolateViewTypes , mStableIdMode ) ; } } } }"}, {"input": "package in . hridayan . ashell . activities ; import android . os . Bundle ; import android . widget . ImageView ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . ChangelogViewModel ; import in . hridayan . ashell . adapters . ChangelogAdapter ; import in . hridayan . ashell . utils . ChangelogItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class ChangelogActivity extends AppCompatActivity { private ChangelogViewModel viewModel ; private AppBarLayout appBarLayout ; private RecyclerView recyclerViewChangelogs ; private final String [ ] versionNames = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; int position = Utils . recyclerViewPosition ( recyclerViewChangelogs ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( position == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_changelog ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; viewModel = new ViewModelProvider ( this ) . get ( ChangelogViewModel . class ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; recyclerViewChangelogs = findViewById ( R . id . recycler_view_changelogs ) ; List < ChangelogItem > changelogItems = new ArrayList < > ( ) ; for ( String versionName : versionNames ) { changelogItems . add ( new ChangelogItem ( getString ( R . string . version ) + \"<STR_LIT>\" + versionName , Utils . loadChangelogText ( versionName , this ) ) ) ; }", "output": "ChangelogAdapter adapter = new ChangelogAdapter ( changelogItems , this ) ; recyclerViewChangelogs . setAdapter ( adapter ) ; recyclerViewChangelogs . setLayoutManager ( new LinearLayoutManager ( this ) ) ; } }"}, {"input": "package com . android . internal . util ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; public class XmlUtils { @ SuppressWarnings ( \"<STR_LIT>\" ) public static final HashMap readMapXml ( InputStream in ) throws XmlPullParserException , IOException {", "output": "throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import androidx . annotation . NonNull ; import androidx . startup . Initializer ; import androidx . window . embedding . RuleController ; import androidx . window . embedding . SplitController ; import androidx . window . embedding . SplitController . SplitSupportStatus ; import com . simon . harmonichackernews . R ; import java . util . Collections ; import java . util . List ; public class FoldableSplitInitializer implements Initializer < RuleController > { private static RuleController ruleController ; @ NonNull @ Override public RuleController create ( @ NonNull Context context ) { ruleController = RuleController . getInstance ( context ) ; if ( ! isSplitSupported ( context ) ) { return ruleController ; } setFoldableSupport ( context , SettingsUtils . shouldEnableFoldableSupport ( context ) ) ; return ruleController ; } @ NonNull @ Override public List < Class < ? extends Initializer < ? > > > dependencies ( ) { return Collections . emptyList ( ) ; } private void setFoldableSupport ( Context context , boolean enabled ) { if ( enabled ) { ruleController . setRules ( RuleController . parseRules ( context , R . xml . main_split_config ) ) ; }", "output": "else { ruleController . clearRules ( ) ; } } public static boolean isSplitSupported ( Context context ) { return SplitController . getInstance ( context ) . getSplitSupportStatus ( ) . equals ( SplitSupportStatus . SPLIT_AVAILABLE ) ; } }"}, {"input": "package org . woheller69 . weather . database ; import android . content . Context ; public class HourlyForecast { public static final float NO_RAIN_VALUE = <NUM_LIT> ; private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float humidity ; private float pressure ; private float windSpeed ; private float windDirection ; private float precipitation ; public HourlyForecast ( ) { } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getWindSpeed ( ) { return windSpeed ; }", "output": "public void setWindSpeed ( float speed ) { this . windSpeed = speed ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; } public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } }"}, {"input": "package com . example . myuidemo ; import android . app . Application ; import com . facebook . common . logging . FLog ; import com . facebook . react . PackageList ; import com . facebook . react . ReactApplication ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . ReactPackage ; import com . facebook . soloader . SoLoader ; import com . reactnative . hybridnavigation . ReactBridgeManager ; import java . util . List ; public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost ( this ) { @ Override public boolean getUseDeveloperSupport ( ) { return BuildConfig . DEBUG ; } @ Override protected List < ReactPackage > getPackages ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) List < ReactPackage > packages = new PackageList ( this ) . getPackages ( ) ; packages . add ( new MyUiPackage ( ) ) ; return packages ; } @ Override protected String getJSMainModuleName ( ) { return \"<STR_LIT>\" ; } } ; @ Override public ReactNativeHost getReactNativeHost ( ) { return mReactNativeHost ; }", "output": "@ Override public void onCreate ( ) { super . onCreate ( ) ; SoLoader . init ( this , false ) ; ReactBridgeManager bridgeManager = ReactBridgeManager . get ( ) ; bridgeManager . install ( getReactNativeHost ( ) ) ; FLog . setMinimumLoggingLevel ( FLog . INFO ) ; } }"}, {"input": "package org . woheller69 . weather . dialogs ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . res . Resources ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . text . Editable ; import android . text . InputType ; import android . text . TextUtils ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . view . inputmethod . InputMethodManager ; import android . webkit . WebView ; import android . widget . AdapterView ; import android . widget . AutoCompleteTextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . os . ConfigurationCompat ; import androidx . fragment . app . DialogFragment ; import com . android . volley . Response ; import com . android . volley . VolleyError ; import org . json . JSONArray ; import org . json . JSONObject ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; import org . woheller69 . weather . activities . ManageLocationsActivity ; import org . woheller69 . weather . database . City ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . util . geocodingApiCall ; import org . woheller69 . weather . ui . util . AutoSuggestAdapter ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; public class AddLocationDialogOmGeocodingAPI extends DialogFragment { Activity activity ; View rootView ; SQLiteHelper database ; private WebView webview ; private AutoCompleteTextView autoCompleteTextView ; City selectedCity ; private static final int TRIGGER_AUTO_COMPLETE = <NUM_LIT> ; private static final long AUTO_COMPLETE_DELAY = <NUM_LIT> ; private static final int TRIGGER_HIDE_KEYBOARD = <NUM_LIT> ; private static final long HIDE_KEYBOARD_DELAY = <NUM_LIT> ; private Handler handler ; private AutoSuggestAdapter autoSuggestAdapter ; String url = \"<STR_LIT>\" ; String lang = \"<STR_LIT>\" ; public AddLocationDialogOmGeocodingAPI ( ) { setRetainInstance ( true ) ; } @ Override public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; if ( context instanceof Activity ) { this . activity = ( Activity ) context ; } } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( savedInstanceState != null ) dismiss ( ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; if ( selectedCity != null && webview != null ) webview . loadUrl ( \"<STR_LIT>\" + selectedCity . getLatitude ( ) + \"<STR_LIT>\" + selectedCity . getLongitude ( ) ) ; } @ NonNull @ SuppressLint ( \"<STR_LIT>\" ) @ Override public Dialog onCreateDialog ( Bundle savedInstanceState ) { Locale locale = ConfigurationCompat . getLocales ( Resources . getSystem ( ) . getConfiguration ( ) ) . get ( <NUM_LIT> ) ; if ( locale != null ) lang = locale . getLanguage ( ) ; LayoutInflater inflater = activity . getLayoutInflater ( ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( activity ) ; View view = inflater . inflate ( R . layout . dialog_add_location , null ) ; rootView = view ; builder . setView ( view ) ; builder . setTitle ( activity . getString ( R . string . dialog_add_label ) ) ; this . database = SQLiteHelper . getInstance ( activity ) ; webview = rootView . findViewById ( R . id . webViewAddLocation ) ; webview . getSettings ( ) . setJavaScriptEnabled ( true ) ; webview . getSettings ( ) . setUserAgentString ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" + BuildConfig . VERSION_NAME ) ; webview . setBackgroundColor ( <NUM_LIT> ) ; webview . setBackgroundResource ( R . drawable . map_back ) ; autoCompleteTextView = ( AutoCompleteTextView ) rootView . findViewById ( R . id . autoCompleteTvAddDialog ) ; autoSuggestAdapter = new AutoSuggestAdapter ( requireContext ( ) , R . layout . list_item_autocomplete ) ; autoCompleteTextView . setThreshold ( <NUM_LIT> ) ; autoCompleteTextView . setInputType ( InputType . TYPE_TEXT_FLAG_NO_SUGGESTIONS ) ; autoCompleteTextView . setAdapter ( autoSuggestAdapter ) ; autoCompleteTextView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { selectedCity = autoSuggestAdapter . getObject ( position ) ; final InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( rootView . getWindowToken ( ) , <NUM_LIT> ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; webview . loadUrl ( \"<STR_LIT>\" + selectedCity . getLatitude ( ) + \"<STR_LIT>\" + selectedCity . getLongitude ( ) ) ; } } ) ; autoCompleteTextView . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { handler . removeMessages ( TRIGGER_AUTO_COMPLETE ) ; handler . sendEmptyMessageDelayed ( TRIGGER_AUTO_COMPLETE , AUTO_COMPLETE_DELAY ) ; handler . removeMessages ( TRIGGER_HIDE_KEYBOARD ) ; handler . sendEmptyMessageDelayed ( TRIGGER_HIDE_KEYBOARD , HIDE_KEYBOARD_DELAY ) ; } @ Override public void afterTextChanged ( Editable s ) { } } ) ; handler = new Handler ( Looper . getMainLooper ( ) , msg -> { if ( msg . what == TRIGGER_AUTO_COMPLETE ) { if ( ! TextUtils . isEmpty ( autoCompleteTextView . getText ( ) ) ) { try { makeApiCall ( URLEncoder . encode ( autoCompleteTextView . getText ( ) . toString ( ) , StandardCharsets . UTF_8 . name ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } } } else if ( msg . what == TRIGGER_HIDE_KEYBOARD ) { final InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( rootView . getWindowToken ( ) , <NUM_LIT> ) ; } return false ; } ) ; builder . setPositiveButton ( activity . getString ( R . string . dialog_add_add_button ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { performDone ( ) ; } } ) ; builder . setNegativeButton ( activity . getString ( R . string . dialog_add_close_button ) , null ) ; return builder . create ( ) ; } private void makeApiCall ( String text ) { geocodingApiCall . make ( getContext ( ) , text , url , lang , new Response . Listener < String > ( ) { @ Override public void onResponse ( String response ) { List < String > stringList = new ArrayList < > ( ) ; List < City > cityList = new ArrayList < > ( ) ; try { JSONObject responseObject = new JSONObject ( response ) ; JSONArray array = responseObject . getJSONArray ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < array . length ( ) ; i ++ ) { City city = new City ( ) ; String citystring = \"<STR_LIT>\" ; JSONObject jsonFeatures = array . getJSONObject ( i ) ; String name = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) { name = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + name ; } String countrycode = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) {", "output": "countrycode = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + \"<STR_LIT>\" + countrycode ; } String admin1 = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) { admin1 = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + \"<STR_LIT>\" + admin1 ; } String admin2 = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) { admin2 = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + \"<STR_LIT>\" + admin2 ; } String admin3 = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) { admin3 = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + \"<STR_LIT>\" + admin3 ; } String admin4 = \"<STR_LIT>\" ; if ( jsonFeatures . has ( \"<STR_LIT>\" ) ) { admin4 = jsonFeatures . getString ( \"<STR_LIT>\" ) ; citystring = citystring + \"<STR_LIT>\" + admin4 ; } city . setCityName ( name ) ; city . setCountryCode ( countrycode ) ; city . setLatitude ( ( float ) jsonFeatures . getDouble ( \"<STR_LIT>\" ) ) ; city . setLongitude ( ( float ) jsonFeatures . getDouble ( \"<STR_LIT>\" ) ) ; cityList . add ( city ) ; stringList . add ( citystring ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } autoSuggestAdapter . setData ( stringList , cityList ) ; autoSuggestAdapter . notifyDataSetChanged ( ) ; } } , new Response . ErrorListener ( ) { @ Override public void onErrorResponse ( VolleyError error ) { Handler h = new Handler ( activity . getMainLooper ( ) ) ; h . post ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( activity , error . toString ( ) , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } } ) ; } private void performDone ( ) { if ( selectedCity == null ) { Toast . makeText ( activity , R . string . dialog_add_no_city_found , Toast . LENGTH_SHORT ) . show ( ) ; } else { ( ( ManageLocationsActivity ) activity ) . addCityToList ( selectedCity ) ; dismiss ( ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog ; public interface IStatus { int STATUS_NONE = <NUM_LIT> ; int STATUS_READY = <NUM_LIT> ; int STATUS_SPEAKING = <NUM_LIT> ; int STATUS_RECOGNITION = <NUM_LIT> ; int STATUS_FINISHED = <NUM_LIT> ; int STATUS_LONG_SPEECH_FINISHED = <NUM_LIT> ; int STATUS_STOPPED = <NUM_LIT> ; int STATUS_WAITING_READY = <NUM_LIT> ; int WHAT_MESSAGE_STATUS = <NUM_LIT> ;", "output": "int STATUS_WAKEUP_SUCCESS = <NUM_LIT> ; int STATUS_WAKEUP_EXIT = <NUM_LIT> ; }"}, {"input": "public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { SharedPreferences sp = getContext ( ) . getSharedPreferences ( OLD_PREFS_NAME , <NUM_LIT> ) ; int a = <NUM_LIT> ; String s = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public void test2 ( ) { FileOutputStream fos = openFileOutput ( FILENAME , <NUM_LIT> ) ; fos . write ( string . getBytes ( ) ) ; fos . close ( ) ; } public void test3 ( ) { File temp = File . createTempFile ( \"<STR_LIT>\" , null ) ; FileOutputStream transfer = new FileOutputStream ( temp ) ; transfer . write ( memory . getBuffer ( ) , <NUM_LIT> , memory . getCount ( ) ) ; transfer . flush ( ) ; } public void test4 ( ) { File file = new File ( context . getFilesDir ( ) , \"<STR_LIT>\" ) ; EncryptedFile encryptedFile = EncryptedFile . Builder ( context , file , masterKey , EncryptedFile . FileEncryptionScheme . AES256_GCM_HKDF_4KB ) . build ( ) ; FileOutputStream encryptedOutputStream = encryptedFile . openFileOutput ( ) ; FileInputStream encryptedInputStream = encryptedFile . openFileInput ( ) ; } public void test5 ( ) { MasterKey masterKey = new MasterKey . Builder ( context ) . setKeyScheme ( MasterKey . KeyScheme . AES256_GCM ) . build ( ) ; SharedPreferences sharedPreferences = EncryptedSharedPreferences . create ( context , \"<STR_LIT>\" , masterKey , EncryptedSharedPreferences . PrefKeyEncryptionScheme . AES256_SIV , EncryptedSharedPreferences . PrefValueEncryptionScheme . AES256_GCM ) ; SharedPreferences . Editor editor = sharedPreferences . edit ( ) ; } public void test6 ( ) { File outFile = new File ( ctx . getExternalFilesDir ( null ) , filename ) ; } public void test7 ( ) { SQLiteDatabase database = dbHelper . getWritableDatabase ( ) ; ContentValues testValues = new ContentValues ( ) ; testValues . put ( WaitlistContract . WaitlistEntry . COLUMN_GUEST_NAME , \"<STR_LIT>\" ) ; testValues . put ( WaitlistContract . WaitlistEntry . COLUMN_PARTY_SIZE , <NUM_LIT> ) ; long firstRowId = database . insert ( WaitlistContract . WaitlistEntry . TABLE_NAME , null , testValues ) ;", "output": "Cursor c = database . rawQuery ( \"<STR_LIT>\" , tableColumns , whereClause , whereArgs , null , null , orderBy ) ; } public void test8 ( ) { SharedPreferences sharedPref = context . getSharedPreferences ( getString ( R . string . preference_file_key ) , <NUM_LIT> ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public class BannedOnlyInThisAreaCheckTask extends CommentOperateTask < BannedOnlyInThisAreaCheckTask . EventHandler > { CommentArea yourCommentArea ; public BannedOnlyInThisAreaCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , CommentArea yourCommentArea ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . yourCommentArea = yourCommentArea ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_COMMENT_SENT_TO_YOUR_AREA , yourCommentArea . sourceId ) ; CommentAddResult commentAddResult = commentManipulator . sendComment ( comment . comment , <NUM_LIT> , <NUM_LIT> , yourCommentArea , false ) ; long testCommentRpid = commentAddResult . rpid ; sleep ( config . getWaitTime ( ) ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_CHECK ) ; if ( commentManipulator . findComment ( yourCommentArea , testCommentRpid , <NUM_LIT> ) != null ) { commentManipulator . deleteComment ( comment . commentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_ONLY_BANNED_IN_THIS_AREA ) ; } else { commentManipulator . deleteComment ( yourCommentArea , testCommentRpid , false ) ; if ( config . getRecordeHistoryIsEnable ( ) ) { statisticsDB . updateCheckedArea ( comment . rpid , HistoryComment . CHECKED_NOT_ONLY_BANNED_IN_THIS_AREA ) ; } eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_BANNED_IN_YOUR_AREA ) ; } } public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_COMMENT_SENT_TO_YOUR_AREA = <NUM_LIT> ; public static final int WHAT_ON_START_CHECK = <NUM_LIT> ; public static final int WHAT_THEN_ONLY_BANNED_IN_THIS_AREA = <NUM_LIT> ; public static final int WHAT_THEN_BANNED_IN_YOUR_AREA = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; }", "output": "} }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public final class AdapterListUpdateCallback implements ListUpdateCallback { @ NonNull private final RecyclerView . Adapter mAdapter ; public AdapterListUpdateCallback ( @ NonNull RecyclerView . Adapter adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) {", "output": "mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; public interface ProcessImageResultCallback { void success ( ProcessImageResult result ) ;", "output": "void cancel ( ) ; void error ( Exception exception ) ; }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . util . AttributeSet ; import android . view . MotionEvent ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixOnItemTouchListenerRecyclerView extends RecyclerView { @ NonNull private final OnItemTouchDispatcher mOnItemTouchDispatcher = new OnItemTouchDispatcher ( ) ; public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context ) { super ( context ) ; init ( ) ;", "output": "} public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FixOnItemTouchListenerRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { super . addOnItemTouchListener ( mOnItemTouchDispatcher ) ; } @ Override public void addOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . addListener ( listener ) ; } @ Override public void removeOnItemTouchListener ( @ NonNull OnItemTouchListener listener ) { mOnItemTouchDispatcher . removeListener ( listener ) ; } private static class OnItemTouchDispatcher implements OnItemTouchListener { @ NonNull private final List < OnItemTouchListener > mListeners = new ArrayList < > ( ) ; @ NonNull private final Set < OnItemTouchListener > mTrackingListeners = new LinkedHashSet < > ( ) ; @ Nullable private OnItemTouchListener mInterceptingListener ; public void addListener ( @ NonNull OnItemTouchListener listener ) { mListeners . add ( listener ) ; } public void removeListener ( @ NonNull OnItemTouchListener listener ) { mListeners . remove ( listener ) ; mTrackingListeners . remove ( listener ) ; if ( mInterceptingListener == listener ) { mInterceptingListener = null ; } } @ Override public boolean onInterceptTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { int action = event . getAction ( ) ; for ( OnItemTouchListener listener : mListeners ) { boolean intercepted = listener . onInterceptTouchEvent ( recyclerView , event ) ; if ( action == MotionEvent . ACTION_CANCEL ) { mTrackingListeners . remove ( listener ) ; continue ; } if ( intercepted ) { mTrackingListeners . remove ( listener ) ; event . setAction ( MotionEvent . ACTION_CANCEL ) ; for ( OnItemTouchListener trackingListener : mTrackingListeners ) { trackingListener . onInterceptTouchEvent ( recyclerView , event ) ; } event . setAction ( action ) ; mTrackingListeners . clear ( ) ; mInterceptingListener = listener ; return true ; } else { mTrackingListeners . add ( listener ) ; } } return false ; } @ Override public void onTouchEvent ( @ NonNull RecyclerView recyclerView , @ NonNull MotionEvent event ) { if ( mInterceptingListener == null ) { return ; } mInterceptingListener . onTouchEvent ( recyclerView , event ) ; int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mInterceptingListener = null ; } } @ Override public void onRequestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { for ( OnItemTouchListener listener : mListeners ) { listener . onRequestDisallowInterceptTouchEvent ( disallowIntercept ) ; } } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . fileopener ; import android . content . ContentResolver ; import android . content . Intent ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . FileProvider ; import androidx . documentfile . provider . DocumentFile ; import java . io . File ; public class FileOpener { private FileOpenerPlugin plugin ; FileOpener ( FileOpenerPlugin plugin ) { this . plugin = plugin ; } public Intent createIntent ( @ NonNull Uri uri , @ Nullable String mimeType ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; if ( mimeType == null || mimeType . trim ( ) . equals ( \"<STR_LIT>\" ) ) { intent . setDataAndNormalize ( uri ) ; } else { intent . setDataAndTypeAndNormalize ( uri , mimeType ) ;", "output": "} intent . setFlags ( Intent . FLAG_GRANT_READ_URI_PERMISSION ) ; return intent ; } public boolean isFileExists ( @ NonNull Uri uri ) { DocumentFile document = DocumentFile . fromSingleUri ( plugin . getContext ( ) , uri ) ; return document . exists ( ) ; } public Uri getUriByPath ( @ NonNull String path ) { Uri uri = Uri . parse ( path ) ; if ( uri . getScheme ( ) != null && uri . getScheme ( ) . equals ( ContentResolver . SCHEME_CONTENT ) ) { return uri ; } else if ( uri . getScheme ( ) == null || uri . getScheme ( ) . equals ( ContentResolver . SCHEME_FILE ) ) { return FileProvider . getUriForFile ( plugin . getActivity ( ) , plugin . getContext ( ) . getPackageName ( ) + \"<STR_LIT>\" , new File ( uri . getPath ( ) ) ) ; } else { return FileProvider . getUriForFile ( plugin . getActivity ( ) , plugin . getContext ( ) . getPackageName ( ) + \"<STR_LIT>\" , new File ( path ) ) ; } } }"}, {"input": "public class Test { String pincard ; public void test ( ) { String pwdVar = \"<STR_LIT>\" ; builder . getBuilder ( ) . setContentTitle ( this . pincard ) ; builder2 . setContentText ( pwdVar ) ; }", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; public class TransferIdentifiers { public static final short END_POINT = - <NUM_LIT> ; public static final short FILE = <NUM_LIT> ; public static final short FOLDER = <NUM_LIT> ; public static final short FILE_SLICE = <NUM_LIT> ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; public interface TranslateResultCallback { void success ( String text ) ; void error ( Exception exception ) ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . presenters ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import android . view . View ; import android . widget . EditText ; import com . alibaba . fastjson . JSONObject ; import java . io . IOException ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; public class AppealDialogPresenter { Context context ; Handler handler ; CommentManipulator commentManipulator ; public AppealDialogPresenter ( Context context , Handler handler , CommentManipulator commentManipulator ) { this . context = context ; this . handler = handler ; this . commentManipulator = commentManipulator ; } public void appeal ( String areaIdentifier , String comment , CallBack callBack ) { View dialogView = View . inflate ( context , R . layout . dialog_appeal_comment , null ) ; EditText edt_appeal_area_location = dialogView . findViewById ( R . id . edt_appeal_area_location ) ; EditText edt_reason = dialogView . findViewById ( R . id . edt_reason ) ; edt_appeal_area_location . setText ( areaIdentifier ) ; edt_reason . setText ( \"<STR_LIT>\" + CommentUtil . subComment ( comment , <NUM_LIT> ) ) ; AlertDialog editAppealInfoDialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setView ( dialogView ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; editAppealInfoDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( edt_appeal_area_location . getText ( ) . toString ( ) . equals ( \"<STR_LIT>\" ) ) { edt_appeal_area_location . setError ( \"<STR_LIT>\" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) < <NUM_LIT> ) { edt_reason . setError ( \"<STR_LIT>\" ) ; } else if ( edt_reason . getText ( ) . toString ( ) . length ( ) > <NUM_LIT> ) { edt_reason . setError ( \"<STR_LIT>\" ) ; } else { new Thread ( ( ) -> { try { JSONObject appealRespJson = commentManipulator . appealComment ( edt_appeal_area_location . getText ( ) . toString ( ) , edt_reason . getText ( ) . toString ( ) ) ; int code = appealRespJson . getInteger ( \"<STR_LIT>\" ) ; String respMsg ; if ( code == <NUM_LIT> ) { respMsg = appealRespJson . getJSONObject ( \"<STR_LIT>\" ) . getString ( \"<STR_LIT>\" ) ; } else { respMsg = appealRespJson . getString ( \"<STR_LIT>\" ) ; } handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ; callBack . onRespInUI ( code , respMsg ) ; } ) ; } catch ( IOException e ) { handler . post ( ( ) -> { editAppealInfoDialog . dismiss ( ) ;", "output": "callBack . onNetErrInUI ( e . getMessage ( ) ) ; } ) ; } } ) . start ( ) ; } } } ) ; } public interface CallBack { public void onRespInUI ( int code , String toastText ) ; public void onNetErrInUI ( String msg ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . core ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . SharedPreferences ; import android . database . sqlite . SQLiteDatabase ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . BottomDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class WppCore { static final HashSet < ActivityChangeState > listenerChat = new HashSet < > ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) static Activity mCurrentActivity ; static LinkedHashSet < Activity > activities = new LinkedHashSet < > ( ) ; private static Class < ? > mGenJidClass ; private static Method mGenJidMethod ; private static Class bottomDialog ; private static Field convChatField ; private static Field chatJidField ; private static SharedPreferences privPrefs ; private static Object mStartUpConfig ; private static Object mActionUser ; private static SQLiteDatabase mWaDatabase ; public static void Initialize ( ClassLoader loader ) throws Exception { privPrefs = Utils . getApplication ( ) . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; var mSendReadClass = XposedHelpers . findClass ( \"<STR_LIT>\" , loader ) ; var subClass = ReflectionUtils . findConstructorUsingFilter ( mSendReadClass , ( constructor ) -> constructor . getParameterCount ( ) == <NUM_LIT> ) . getParameterTypes ( ) [ <NUM_LIT> ] ; mGenJidClass = ReflectionUtils . findFieldUsingFilter ( subClass , ( field ) -> Modifier . isStatic ( field . getModifiers ( ) ) ) . getType ( ) ; mGenJidMethod = ReflectionUtils . findMethodUsingFilter ( mGenJidClass , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && ! Modifier . isStatic ( method . getModifiers ( ) ) ) ; bottomDialog = Unobfuscator . loadDialogViewClass ( loader ) ; convChatField = Unobfuscator . loadAntiRevokeConvChatField ( loader ) ; chatJidField = Unobfuscator . loadAntiRevokeChatJidField ( loader ) ; var startPrefsConfig = Unobfuscator . loadStartPrefsConfig ( loader ) ; XposedBridge . hookMethod ( startPrefsConfig , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mStartUpConfig = param . thisObject ; } } ) ; var actionUser = Unobfuscator . loadActionUser ( loader ) ; XposedBridge . hookAllConstructors ( actionUser , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mActionUser = param . thisObject ; } } ) ; loadWADatabase ( ) ; } public static void sendMessage ( String number , String message ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilterIfExists ( mActionUser . getClass ( ) , ( method ) -> List . class . isAssignableFrom ( method . getReturnType ( ) ) && ReflectionUtils . findIndexOfType ( method . getParameterTypes ( ) , String . class ) != - <NUM_LIT> ) ; if ( senderMethod != null ) { var userJid = createUserJid ( number + \"<STR_LIT>\" ) ; if ( userJid == null ) { Utils . showToast ( \"<STR_LIT>\" , Toast . LENGTH_SHORT ) ; return ; } var newObject = new Object [ senderMethod . getParameterCount ( ) ] ; for ( int i = <NUM_LIT> ; i < newObject . length ; i ++ ) { var param = senderMethod . getParameterTypes ( ) [ i ] ; newObject [ i ] = Utils . getDefaultValue ( param ) ; } var index = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , String . class ) ; newObject [ index ] = message ; var index2 = ReflectionUtils . findIndexOfType ( senderMethod . getParameterTypes ( ) , List . class ) ; newObject [ index2 ] = Collections . singletonList ( userJid ) ; senderMethod . invoke ( mActionUser , newObject ) ; Utils . showToast ( \"<STR_LIT>\" + number , Toast . LENGTH_SHORT ) ; } } catch ( Exception e ) { Utils . showToast ( \"<STR_LIT>\" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void sendReaction ( String s , Object objMessage ) { try { var senderMethod = ReflectionUtils . findMethodUsingFilter ( mActionUser . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && Arrays . equals ( method . getParameterTypes ( ) , new Class [ ] { FMessageWpp . TYPE , String . class , boolean . class } ) ) ; senderMethod . invoke ( mActionUser , objMessage , s , ! TextUtils . isEmpty ( s ) ) ; } catch ( Exception e ) { Utils . showToast ( \"<STR_LIT>\" + e . getMessage ( ) , Toast . LENGTH_SHORT ) ; XposedBridge . log ( e ) ; } } public static void loadWADatabase ( ) { if ( mWaDatabase != null ) return ; var dataDir = Utils . getApplication ( ) . getFilesDir ( ) . getParentFile ( ) ; var database = new File ( dataDir , \"<STR_LIT>\" ) ; if ( database . exists ( ) ) { mWaDatabase = SQLiteDatabase . openDatabase ( database . getAbsolutePath ( ) , null , SQLiteDatabase . OPEN_READONLY ) ; } } public static Activity getCurrentActivity ( ) { return mCurrentActivity ; } public static int getDefaultTheme ( ) { if ( mStartUpConfig != null ) { var result = ReflectionUtils . findMethodUsingFilterIfExists ( mStartUpConfig . getClass ( ) , ( method ) -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; if ( result != null ) { var value = ReflectionUtils . callMethod ( result , mStartUpConfig ) ; if ( value != null ) return ( int ) value ; } } var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; return startup_prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; } @ NonNull public static String getContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return \"<STR_LIT>\" ; String name = getSContactName ( userJid , false ) ; if ( ! TextUtils . isEmpty ( name ) ) return name ; return getWppContactName ( userJid ) ; } @ NonNull public static String getSContactName ( Object userJid , boolean saveOnly ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return \"<STR_LIT>\" ; String selection ; if ( saveOnly ) { selection = \"<STR_LIT>\" ; } else { selection = \"<STR_LIT>\" ; } String name = null ; var rawJid = getRawString ( userJid ) ; var cursor = mWaDatabase . query ( \"<STR_LIT>\" , new String [ ] { \"<STR_LIT>\" } , selection , new String [ ] { rawJid } , null , null , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { name = cursor . getString ( <NUM_LIT> ) ; cursor . close ( ) ; } return name == null ? \"<STR_LIT>\" : name ; } @ NonNull public static String getWppContactName ( Object userJid ) { loadWADatabase ( ) ; if ( mWaDatabase == null || userJid == null ) return \"<STR_LIT>\" ; String name = null ; var rawJid = getRawString ( userJid ) ; var cursor2 = mWaDatabase . query ( \"<STR_LIT>\" , new String [ ] { \"<STR_LIT>\" }", "output": ", \"<STR_LIT>\" , new String [ ] { rawJid } , null , null , null ) ; if ( cursor2 != null && cursor2 . moveToFirst ( ) ) { name = cursor2 . getString ( <NUM_LIT> ) ; cursor2 . close ( ) ; } return name == null ? \"<STR_LIT>\" : name ; } public static Object createUserJid ( String rawjid ) { var genInstance = XposedHelpers . newInstance ( mGenJidClass ) ; try { return mGenJidMethod . invoke ( genInstance , rawjid ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } return null ; } public static String getRawString ( Object userjid ) { if ( userjid == null ) return null ; return ( String ) XposedHelpers . callMethod ( userjid , \"<STR_LIT>\" ) ; } public static boolean isGroup ( String str ) { if ( str == null ) return false ; return str . contains ( \"<STR_LIT>\" ) || str . contains ( \"<STR_LIT>\" ) || ( ! str . contains ( \"<STR_LIT>\" ) && str . length ( ) > <NUM_LIT> ) ; } public static String getCurrentRawJID ( ) { var conversation = getCurrentConversation ( ) ; if ( conversation == null ) return null ; var chatField = XposedHelpers . getObjectField ( conversation , convChatField . getName ( ) ) ; var chatJidObj = XposedHelpers . getObjectField ( chatField , chatJidField . getName ( ) ) ; return getRawString ( chatJidObj ) ; } public static String stripJID ( String str ) { try { return ( str . contains ( \"<STR_LIT>\" ) || str . contains ( \"<STR_LIT>\" ) || str . contains ( \"<STR_LIT>\" ) ) ? str . substring ( <NUM_LIT> , str . indexOf ( \"<STR_LIT>\" ) ) : str ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; return str ; } } public static Drawable getContactPhotoDrawable ( String jid ) { var file = getContactPhotoFile ( jid ) ; if ( file == null ) return null ; return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; } public static File getContactPhotoFile ( String jid ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + \"<STR_LIT>\" ; File file = new File ( datafolder + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + stripJID ( jid ) + \"<STR_LIT>\" ) ; if ( ! file . exists ( ) ) file = new File ( datafolder + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + jid + \"<STR_LIT>\" ) ; if ( file . exists ( ) ) return file ; return null ; } public static String getMyName ( ) { var startup_prefs = Utils . getApplication ( ) . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; return startup_prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static SharedPreferences getMainPrefs ( ) { return Utils . getApplication ( ) . getSharedPreferences ( Utils . getApplication ( ) . getPackageName ( ) + \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; } public static String getMyBio ( ) { var mainPrefs = getMainPrefs ( ) ; return mainPrefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static Drawable getMyPhoto ( ) { String datafolder = Utils . getApplication ( ) . getCacheDir ( ) . getParent ( ) + \"<STR_LIT>\" ; File file = new File ( datafolder + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; if ( file . exists ( ) ) return Drawable . createFromPath ( file . getAbsolutePath ( ) ) ; return null ; } public static BottomDialogWpp createBottomDialog ( Context context ) { return new BottomDialogWpp ( ( Dialog ) XposedHelpers . newInstance ( bottomDialog , context , <NUM_LIT> ) ) ; } @ Nullable public static Activity getCurrentConversation ( ) { if ( mCurrentActivity == null ) return null ; Class < ? > conversation = XposedHelpers . findClass ( \"<STR_LIT>\" , mCurrentActivity . getClassLoader ( ) ) ; if ( conversation . isInstance ( mCurrentActivity ) ) return mCurrentActivity ; return null ; } @ SuppressLint ( \"<STR_LIT>\" ) public static void setPrivString ( String key , String value ) { privPrefs . edit ( ) . putString ( key , value ) . commit ( ) ; } public static String getPrivString ( String key , String defaultValue ) { return privPrefs . getString ( key , defaultValue ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public static void removePrivKey ( String s ) { if ( s != null && privPrefs . contains ( s ) ) privPrefs . edit ( ) . remove ( s ) . commit ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public static void setPrivBoolean ( String key , boolean value ) { privPrefs . edit ( ) . putBoolean ( key , value ) . commit ( ) ; } public static boolean getPrivBoolean ( String key , boolean defaultValue ) { return privPrefs . getBoolean ( key , defaultValue ) ; } public static void addListenerChat ( ActivityChangeState listener ) { listenerChat . add ( listener ) ; } public interface ActivityChangeState { void onChange ( Object object , ChangeType type ) ; enum ChangeType { START , END , RESUME , PAUSE } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class GetCustomIdResult implements Result { @ Nullable private String customId ; public GetCustomIdResult ( @ Nullable String customId ) { this . customId = customId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , customId == null ? JSONObject . NULL : customId ) ; return result ; }", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . bean ; import java . io . File ; import top . weixiansen574 . hybridfilexfer . core . Utils ; public class FileTransferJob { public final File localDir ; public final String remoteDir ; public final File targetFile ; public final boolean isSlice ; public final long startRange ; public final long endRange ; public FileTransferJob ( File localDir , String remoteDir , File target ) { this . localDir = localDir ; this . remoteDir = remoteDir ; this . targetFile = target ; this . isSlice = false ; this . startRange = <NUM_LIT> ; this . endRange = <NUM_LIT> ; } public FileTransferJob ( File localDir , String remoteDir , File target , long startRange , long endRange ) { this . localDir = localDir ; this . remoteDir = remoteDir ; this . targetFile = target ; this . startRange = startRange ; this . endRange = endRange ; this . isSlice = true ; } public FileTransferJob ( FileTransferJob oldJob , long startRange , long endRange ) { this . localDir = oldJob . localDir ; this . remoteDir = oldJob . remoteDir ; this . targetFile = oldJob . targetFile ; this . startRange = startRange ; this . endRange = endRange ; this . isSlice = true ; } public String toRemotePath ( ) { if ( localDir == null || targetFile == null || remoteDir == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "output": "String localDirPath = localDir . getAbsolutePath ( ) ; String targetPath = targetFile . getAbsolutePath ( ) ; String remotePath = Utils . replaceBackslashToSlash ( remoteDir ) ; if ( ! localDirPath . endsWith ( File . separator ) ) { localDirPath += File . separator ; } String relativePath = targetPath . startsWith ( localDirPath ) ? targetPath . substring ( localDirPath . length ( ) ) : targetPath ; relativePath = processFileNamesAccordingToTheSystem ( relativePath ) ; return remotePath + ( remotePath . endsWith ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + relativePath ; } public String processFileNamesAccordingToTheSystem ( String path ) { if ( File . separator . equals ( \"<STR_LIT>\" ) ) { path = Utils . replaceColon ( path ) ; path = Utils . replaceBackslashToUnderline ( path ) ; } else { path = Utils . replaceBackslashToSlash ( path ) ; } return path ; } public long getTotalSize ( ) { return targetFile . length ( ) ; } }"}, {"input": "package com . appspa . demo ; public final class Constants { public static final String DEFAULT_UPDATE_URL = \"<STR_LIT>\" ; public static final String FORCED_UPDATE_URL = \"<STR_LIT>\" ; public static final String CUSTOM_UPDATE_URL = \"<STR_LIT>\" ; public static final String IGNORE_UPDATE_URL = \"<STR_LIT>\" ; public static final String XUPDATE_DEMO_DOWNLOAD_URL = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; public abstract class FileSelectAdapter < T > extends RecyclerView . Adapter < FileSelectAdapter . ViewHolder > { public final Toolbar fileSelectToolbar ; private SelectModeListener selectModeListener ; private final View . OnTouchListener onTouchListener ; protected HashSet < T > selectedItems ; private OnConfirmFileSelectionListener onConfirmFileSelectionListener ; protected Activity context ; private int lastSelectedCount = <NUM_LIT> ; private final FrameLayout frameLayout ; private final View listInView ; private final View loadingView ; public FileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView ) { this . fileSelectToolbar = fileSelectToolbar ; this . context = context ; this . onTouchListener = onTouchListener ; this . frameLayout = frameLayout ; this . listInView = listInView ; selectedItems = new HashSet < > ( ) ; loadingView = View . inflate ( context , R . layout . loading_files , null ) ; fileSelectToolbar . getMenu ( ) . findItem ( R . id . select_all ) . setOnMenuItemClickListener ( item -> { selectAll ( ) ; return true ; } ) ; fileSelectToolbar . setNavigationOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { cancelSelect ( ) ; } } ) ; } public void setSelectModeListener ( SelectModeListener selectModeListener ) { this . selectModeListener = selectModeListener ; } public void setOnToTransferListener ( OnConfirmFileSelectionListener onConfirmFileSelectionListener ) { this . onConfirmFileSelectionListener = onConfirmFileSelectionListener ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_file , parent , false ) , onTouchListener ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { T item = getItem ( position ) ; View itemView = holder . itemView ; holder . fileName . setText ( getFileName ( item ) ) ; holder . dateTime . setText ( Utils . formatDateTime ( getFileDate ( item ) ) ) ; if ( isDir ( item ) ) { holder . fileSize . setText ( \"<STR_LIT>\" ) ; } else { holder . fileSize . setText ( Utils . formatFileSize ( getFileSize ( item ) ) ) ; } if ( selectedItems . contains ( item ) ) { itemView . setBackgroundColor ( context . getColor ( R . color . blue_background_light ) ) ; holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . baseline_check_circle_24 ) ) ; } else { itemView . setBackgroundColor ( context . getColor ( R . color . background ) ) ; if ( isDir ( item ) ) { holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . folder ) ) ; } else { holder . fileIcon . setImageDrawable ( context . getDrawable ( R . drawable . file ) ) ; } } itemView . setOnLongClickListener ( v -> { if ( ! isSelectMode ( ) ) { if ( ! selectedItems . contains ( item ) ) { addSelectItem ( item ) ; } else { removeSelectItem ( item ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; } else { if ( selectedItems . contains ( item ) ) { onConfirmFileSelection ( selectedItems ) ; } } return true ; } ) ; itemView . setOnClickListener ( v -> { if ( isSelectMode ( ) ) { if ( ! selectedItems . contains ( item ) ) { addSelectItem ( item ) ; } else { removeSelectItem ( item ) ; } notifyItemChanged ( holder . getAdapterPosition ( ) ) ; } else if ( isDir ( item ) ) { cd ( getPath ( item ) ) ; } } ) ; } private void addSelectItem ( T item ) { selectedItems . add ( item ) ; updateSelectedCount ( ) ; } private void removeSelectItem ( T item ) { selectedItems . remove ( item ) ; updateSelectedCount ( ) ; } private void updateSelectedCount ( ) { int size = selectedItems . size ( ) ; fileSelectToolbar . setTitle ( \"<STR_LIT>\" + size + \"<STR_LIT>\" ) ; if ( selectModeListener != null ) { if ( selectedItems . isEmpty ( ) ) { selectModeListener . onSelectModeChanged ( false ) ; } else if ( lastSelectedCount == <NUM_LIT> ) { selectModeListener . onSelectModeChanged ( true ) ; } } lastSelectedCount = size ; } protected abstract String getFileName ( T item ) ; protected abstract String getPath ( T item ) ; protected abstract boolean isDir ( T item ) ; protected abstract T getItem ( int position ) ; protected abstract long getFileDate ( T item ) ; protected abstract long getFileSize ( T item ) ; protected abstract List < T > getAllItems ( ) ; protected abstract void cd ( String path ) ; protected void onConfirmFileSelection ( HashSet < T > selectedItems ) { List < String > files = new ArrayList < > ( ) ; for ( T item : selectedItems ) { files . add ( getPath ( item ) ) ; } onConfirmFileSelectionListener . onConfirmFileSelection ( files , getCurrentDir ( ) ) ; } ; public abstract String getCurrentDir ( ) ; public abstract void cdParent ( ) ; public boolean isSelectMode ( ) { return ! selectedItems . isEmpty ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public void selectAll ( ) { selectedItems . clear ( ) ; selectedItems . addAll ( getAllItems ( ) ) ; updateSelectedCount ( ) ; notifyDataSetChanged ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public void cancelSelect ( ) { selectedItems . clear ( ) ; updateSelectedCount ( ) ; notifyDataSetChanged ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder {", "output": "ImageView fileIcon ; TextView fileName , dateTime , fileSize ; public ViewHolder ( @ NonNull View itemView , View . OnTouchListener onTouchListener ) { super ( itemView ) ; fileIcon = itemView . findViewById ( R . id . file_icon ) ; fileName = itemView . findViewById ( R . id . file_name ) ; dateTime = itemView . findViewById ( R . id . date_time ) ; fileSize = itemView . findViewById ( R . id . file_size ) ; itemView . setOnTouchListener ( onTouchListener ) ; } } interface SelectModeListener { void onSelectModeChanged ( boolean isSelectMode ) ; } interface OnConfirmFileSelectionListener { void onConfirmFileSelection ( List < String > selectedItems , String dir ) ; } public void enterLoadingState ( ) { frameLayout . removeView ( listInView ) ; frameLayout . addView ( loadingView ) ; } public void exitLoadingState ( ) { frameLayout . removeView ( loadingView ) ; frameLayout . addView ( listInView ) ; } }"}, {"input": "package external . org . apache . commons . lang3 . builder ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . tuple . Pair ; public class EqualsBuilder implements Builder < Boolean > { private static final ThreadLocal < Set < Pair < IDKey , IDKey > > > REGISTRY = new ThreadLocal < Set < Pair < IDKey , IDKey > > > ( ) ; static Set < Pair < IDKey , IDKey > > getRegistry ( ) { return REGISTRY . get ( ) ; } static Pair < IDKey , IDKey > getRegisterPair ( Object lhs , Object rhs ) { IDKey left = new IDKey ( lhs ) ; IDKey right = new IDKey ( rhs ) ; return Pair . of ( left , right ) ; } static boolean isRegistered ( Object lhs , Object rhs ) { Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft ( ) , pair . getRight ( ) ) ; return registry != null && ( registry . contains ( pair ) || registry . contains ( swappedPair ) ) ; } static void register ( Object lhs , Object rhs ) { synchronized ( EqualsBuilder . class ) { if ( getRegistry ( ) == null ) { REGISTRY . set ( new HashSet < Pair < IDKey , IDKey > > ( ) ) ; } } Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; registry . add ( pair ) ; } static void unregister ( Object lhs , Object rhs ) { Set < Pair < IDKey , IDKey > > registry = getRegistry ( ) ; if ( registry != null ) { Pair < IDKey , IDKey > pair = getRegisterPair ( lhs , rhs ) ; registry . remove ( pair ) ; synchronized ( EqualsBuilder . class ) { registry = getRegistry ( ) ; if ( registry != null && registry . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } private boolean isEquals = true ; public EqualsBuilder ( ) { } public static boolean reflectionEquals ( Object lhs , Object rhs , Collection < String > excludeFields ) { return reflectionEquals ( lhs , rhs , ReflectionToStringBuilder . toNoNullStringArray ( excludeFields ) ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , String ... excludeFields ) { return reflectionEquals ( lhs , rhs , false , null , excludeFields ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients ) { return reflectionEquals ( lhs , rhs , testTransients , null ) ; } public static boolean reflectionEquals ( Object lhs , Object rhs , boolean testTransients , Class < ? > reflectUpToClass , String ... excludeFields ) { if ( lhs == rhs ) { return true ; } if ( lhs == null || rhs == null ) { return false ; } Class < ? > lhsClass = lhs . getClass ( ) ; Class < ? > rhsClass = rhs . getClass ( ) ; Class < ? > testClass ; if ( lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; if ( ! rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; } } else if ( rhsClass . isInstance ( lhs ) ) { testClass = rhsClass ; if ( ! lhsClass . isInstance ( rhs ) ) { testClass = lhsClass ; } } else { return false ; } EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; try { reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; while ( testClass . getSuperclass ( ) != null && testClass != reflectUpToClass ) { testClass = testClass . getSuperclass ( ) ; reflectionAppend ( lhs , rhs , testClass , equalsBuilder , testTransients , excludeFields ) ; } } catch ( IllegalArgumentException e ) { return false ; } return equalsBuilder . isEquals ( ) ; } private static void reflectionAppend ( Object lhs , Object rhs , Class < ? > clazz , EqualsBuilder builder , boolean useTransients , String [ ] excludeFields ) { if ( isRegistered ( lhs , rhs ) ) { return ; } try { register ( lhs , rhs ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( int i = <NUM_LIT> ; i < fields . length && builder . isEquals ; i ++ ) { Field f = fields [ i ] ; if ( ! ArrayUtils . contains ( excludeFields , f . getName ( ) ) && ( f . getName ( ) . indexOf ( '<STR_LIT>' ) == - <NUM_LIT> ) && ( useTransients || ! Modifier . isTransient ( f . getModifiers ( ) ) ) && ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) ) { try { builder . append ( f . get ( lhs ) , f . get ( rhs ) ) ; } catch ( IllegalAccessException e ) { throw new InternalError ( \"<STR_LIT>\" ) ; } } } } finally { unregister ( lhs , rhs ) ; } } public EqualsBuilder appendSuper ( boolean superEquals ) { if ( isEquals == false ) { return this ; } isEquals = superEquals ; return this ; } public EqualsBuilder append ( Object lhs , Object rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } Class < ? > lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) != rhs . getClass ( ) ) { this . setEquals ( false ) ; } else if ( lhs instanceof long [ ] ) { append ( ( long [ ] ) lhs , ( long [ ] ) rhs ) ; } else if ( lhs instanceof int [ ] ) { append ( ( int [ ] ) lhs , ( int [ ] ) rhs ) ; } else if ( lhs instanceof short [ ] ) { append ( ( short [ ] ) lhs , ( short [ ] ) rhs ) ; } else if ( lhs instanceof char [ ] ) { append ( ( char [ ] ) lhs , ( char [ ] ) rhs ) ; } else if ( lhs instanceof byte [ ] ) { append ( ( byte [ ] ) lhs , ( byte [ ] ) rhs ) ; } else if ( lhs instanceof double [ ] ) { append ( ( double [ ] ) lhs , ( double [ ] ) rhs ) ; } else if ( lhs instanceof float [ ] ) { append ( ( float [ ] ) lhs , ( float [ ] ) rhs ) ; } else if ( lhs instanceof boolean [ ] ) { append ( ( boolean [ ] ) lhs , ( boolean [ ] ) rhs ) ; } else { append ( ( Object [ ] ) lhs , ( Object [ ] ) rhs ) ; } return this ; } public EqualsBuilder append ( long lhs , long rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( int lhs , int rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( short lhs , short rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( char lhs , char rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( byte lhs , byte rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( double lhs , double rhs ) { if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; } public EqualsBuilder append ( float lhs , float rhs ) { if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; } public EqualsBuilder append ( boolean lhs , boolean rhs ) { if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; } public EqualsBuilder append ( Object [ ] lhs , Object [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) {", "output": "this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( long [ ] lhs , long [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( int [ ] lhs , int [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( short [ ] lhs , short [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( char [ ] lhs , char [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( byte [ ] lhs , byte [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( double [ ] lhs , double [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( float [ ] lhs , float [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public EqualsBuilder append ( boolean [ ] lhs , boolean [ ] rhs ) { if ( isEquals == false ) { return this ; } if ( lhs == rhs ) { return this ; } if ( lhs == null || rhs == null ) { this . setEquals ( false ) ; return this ; } if ( lhs . length != rhs . length ) { this . setEquals ( false ) ; return this ; } for ( int i = <NUM_LIT> ; i < lhs . length && isEquals ; ++ i ) { append ( lhs [ i ] , rhs [ i ] ) ; } return this ; } public boolean isEquals ( ) { return this . isEquals ; } public Boolean build ( ) { return Boolean . valueOf ( isEquals ( ) ) ; } protected void setEquals ( boolean isEquals ) { this . isEquals = isEquals ; } public void reset ( ) { this . isEquals = true ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . Point ; import android . media . Image ; import android . net . Uri ; import android . provider . Settings ; import android . view . Display ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . camera . core . Camera ; import androidx . camera . core . CameraSelector ; import androidx . camera . core . ImageAnalysis ; import androidx . camera . core . ImageProxy ; import androidx . camera . core . Preview ; import androidx . camera . lifecycle . ProcessCameraProvider ; import androidx . camera . view . PreviewView ; import androidx . core . content . ContextCompat ; import androidx . lifecycle . LifecycleOwner ; import com . getcapacitor . PermissionState ; import com . getcapacitor . PluginCall ; import com . google . android . gms . common . moduleinstall . InstallStatusListener ; import com . google . android . gms . common . moduleinstall . ModuleInstall ; import com . google . android . gms . common . moduleinstall . ModuleInstallClient ; import com . google . android . gms . common . moduleinstall . ModuleInstallRequest ; import com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . mlkit . vision . barcode . BarcodeScannerOptions ; import com . google . mlkit . vision . barcode . BarcodeScanning ; import com . google . mlkit . vision . barcode . common . Barcode ; import com . google . mlkit . vision . codescanner . GmsBarcodeScanner ; import com . google . mlkit . vision . codescanner . GmsBarcodeScannerOptions ; import com . google . mlkit . vision . codescanner . GmsBarcodeScanning ; import com . google . mlkit . vision . common . InputImage ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . options . SetZoomRatioOptions ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMaxZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetMinZoomRatioResult ; import io . capawesome . capacitorjs . plugins . mlkit . barcodescanning . classes . results . GetZoomRatioResult ; public class BarcodeScanner implements ImageAnalysis . Analyzer { @ NonNull private final BarcodeScannerPlugin plugin ; private final Point displaySize ; @ Nullable private com . google . mlkit . vision . barcode . BarcodeScanner barcodeScannerInstance ; @ Nullable private Camera camera ; @ Nullable private ProcessCameraProvider processCameraProvider ; @ Nullable private PreviewView previewView ; @ Nullable private ScanSettings scanSettings ; @ Nullable private ModuleInstallProgressListener moduleInstallProgressListener ; private boolean isTorchEnabled = false ; public BarcodeScanner ( BarcodeScannerPlugin plugin ) { this . plugin = plugin ; this . displaySize = this . getDisplaySize ( ) ; } public void startScan ( ScanSettings scanSettings , StartScanResultCallback callback ) { stopScan ( ) ; hideWebViewBackground ( ) ; this . scanSettings = scanSettings ; BarcodeScannerOptions options = buildBarcodeScannerOptions ( scanSettings ) ; barcodeScannerInstance = BarcodeScanning . getClient ( options ) ; ImageAnalysis imageAnalysis = new ImageAnalysis . Builder ( ) . setBackpressureStrategy ( ImageAnalysis . STRATEGY_KEEP_ONLY_LATEST ) . build ( ) ; imageAnalysis . setAnalyzer ( ContextCompat . getMainExecutor ( plugin . getContext ( ) ) , this ) ; ListenableFuture < ProcessCameraProvider > cameraProviderFuture = ProcessCameraProvider . getInstance ( plugin . getContext ( ) ) ; cameraProviderFuture . addListener ( ( ) -> { try { processCameraProvider = cameraProviderFuture . get ( ) ; CameraSelector cameraSelector = new CameraSelector . Builder ( ) . requireLensFacing ( this . scanSettings . lensFacing ) . build ( ) ; previewView = plugin . getActivity ( ) . findViewById ( R . id . preview_view ) ; previewView . setScaleType ( PreviewView . ScaleType . FILL_CENTER ) ; Preview preview = new Preview . Builder ( ) . build ( ) ; preview . setSurfaceProvider ( previewView . getSurfaceProvider ( ) ) ; camera = processCameraProvider . bindToLifecycle ( ( LifecycleOwner ) plugin . getContext ( ) , cameraSelector , preview , imageAnalysis ) ; callback . success ( ) ; } catch ( Exception exception ) { callback . error ( exception ) ; } } , ContextCompat . getMainExecutor ( plugin . getContext ( ) ) ) ; } public void stopScan ( ) { showWebViewBackground ( ) ; disableTorch ( ) ; if ( processCameraProvider != null ) { processCameraProvider . unbindAll ( ) ; } processCameraProvider = null ; camera = null ; barcodeScannerInstance = null ; scanSettings = null ; } public void readBarcodesFromImage ( String path , ScanSettings scanSettings , ReadBarcodesFromImageResultCallback callback ) throws Exception { InputImage inputImage ; try { inputImage = InputImage . fromFilePath ( plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { throw new Exception ( BarcodeScannerPlugin . ERROR_LOAD_IMAGE_FAILED ) ; } BarcodeScannerOptions options = buildBarcodeScannerOptions ( scanSettings ) ; com . google . mlkit . vision . barcode . BarcodeScanner barcodeScannerInstance = BarcodeScanning . getClient ( options ) ; barcodeScannerInstance . process ( inputImage ) . addOnSuccessListener ( barcodes -> { callback . success ( barcodes ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void scan ( ScanSettings scanSettings , ScanResultCallback callback ) { GmsBarcodeScannerOptions options = buildGmsBarcodeScannerOptions ( scanSettings ) ; GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) , options ) ; scanner . startScan ( ) . addOnSuccessListener ( barcode -> { callback . success ( barcode ) ; } ) . addOnCanceledListener ( ( ) -> { callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void isGoogleBarcodeScannerModuleAvailable ( IsGoogleBarodeScannerModuleAvailableResultCallback callback ) { GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) ) ; ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . areModulesAvailable ( scanner ) . addOnSuccessListener ( response -> { boolean isAvailable = response . areModulesAvailable ( ) ; callback . success ( isAvailable ) ; } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public void installGoogleBarcodeScannerModule ( InstallGoogleBarcodeScannerModuleResultCallback callback ) { GmsBarcodeScanner scanner = GmsBarcodeScanning . getClient ( plugin . getContext ( ) ) ; InstallStatusListener listener = new ModuleInstallProgressListener ( this ) ; ModuleInstallRequest moduleInstallRequest = ModuleInstallRequest . newBuilder ( ) . addApi ( scanner ) . setListener ( listener ) . build ( ) ; ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . installModules ( moduleInstallRequest ) . addOnSuccessListener ( moduleInstallResponse -> { if ( moduleInstallResponse . areModulesAlreadyInstalled ( ) ) { callback . error ( new Exception ( BarcodeScannerPlugin . ERROR_GOOGLE_BARCODE_SCANNER_MODULE_ALREADY_INSTALLED ) ) ; } else { callback . success ( ) ; } } ) . addOnFailureListener ( exception -> { callback . error ( exception ) ; } ) ; } public boolean isSupported ( ) { return plugin . getContext ( ) . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_CAMERA_ANY ) ; } public void enableTorch ( ) { if ( camera == null ) { return ; }", "output": "camera . getCameraControl ( ) . enableTorch ( true ) ; isTorchEnabled = true ; } public void disableTorch ( ) { if ( camera == null ) { return ; } camera . getCameraControl ( ) . enableTorch ( false ) ; isTorchEnabled = false ; } public void toggleTorch ( ) { if ( isTorchEnabled ) { disableTorch ( ) ; } else { enableTorch ( ) ; } } public boolean isTorchEnabled ( ) { return isTorchEnabled ; } public boolean isTorchAvailable ( ) { return plugin . getContext ( ) . getPackageManager ( ) . hasSystemFeature ( PackageManager . FEATURE_CAMERA_FLASH ) ; } public void setZoomRatio ( SetZoomRatioOptions options ) { float zoomRatio = options . getZoomRatio ( ) ; if ( camera == null ) { return ; } camera . getCameraControl ( ) . setZoomRatio ( zoomRatio ) ; } @ Nullable public GetZoomRatioResult getZoomRatio ( ) { if ( camera == null ) { return null ; } float zoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getZoomRatio ( ) ; return new GetZoomRatioResult ( zoomRatio ) ; } @ Nullable public GetMinZoomRatioResult getMinZoomRatio ( ) { if ( camera == null ) { return null ; } float minZoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getMinZoomRatio ( ) ; return new GetMinZoomRatioResult ( minZoomRatio ) ; } @ Nullable public GetMaxZoomRatioResult getMaxZoomRatio ( ) { if ( camera == null ) { return null ; } float maxZoomRatio = camera . getCameraInfo ( ) . getZoomState ( ) . getValue ( ) . getMaxZoomRatio ( ) ; return new GetMaxZoomRatioResult ( maxZoomRatio ) ; } public void openSettings ( PluginCall call ) { Uri uri = Uri . fromParts ( \"<STR_LIT>\" , plugin . getAppId ( ) , null ) ; Intent intent = new Intent ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS , uri ) ; plugin . startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; } public PermissionState getCameraPermission ( ) { return plugin . getPermissionState ( BarcodeScannerPlugin . CAMERA ) ; } public void requestCameraPermission ( PluginCall call ) { plugin . requestPermissionForAlias ( BarcodeScannerPlugin . CAMERA , call , \"<STR_LIT>\" ) ; } public boolean requestCameraPermissionIfNotDetermined ( PluginCall call ) throws Exception { PermissionState state = getCameraPermission ( ) ; if ( state == PermissionState . GRANTED ) { return true ; } else if ( state == PermissionState . DENIED ) { throw new Exception ( BarcodeScannerPlugin . ERROR_PERMISSION_DENIED ) ; } else { requestCameraPermission ( call ) ; return false ; } } public boolean isCameraActive ( ) { return camera != null ; } @ Override public void analyze ( @ NonNull ImageProxy imageProxy ) { @ SuppressLint ( \"<STR_LIT>\" ) Image image = imageProxy . getImage ( ) ; if ( image == null || barcodeScannerInstance == null ) { return ; } InputImage inputImage = InputImage . fromMediaImage ( image , imageProxy . getImageInfo ( ) . getRotationDegrees ( ) ) ; Point imageSize = new Point ( inputImage . getWidth ( ) , inputImage . getHeight ( ) ) ; barcodeScannerInstance . process ( inputImage ) . addOnSuccessListener ( barcodes -> { if ( scanSettings == null ) { return ; } for ( Barcode barcode : barcodes ) { handleScannedBarcode ( barcode , imageSize ) ; } } ) . addOnFailureListener ( exception -> { handleScanError ( exception ) ; } ) . addOnCompleteListener ( task -> { imageProxy . close ( ) ; image . close ( ) ; } ) ; } public void handleGoogleBarcodeScannerModuleInstallProgress ( @ ModuleInstallStatusUpdate . InstallState int state , @ Nullable Integer progress ) { plugin . notifyGoogleBarcodeScannerModuleInstallProgressListener ( state , progress ) ; boolean isTerminateState = ModuleInstallProgressListener . isTerminateState ( state ) ; if ( isTerminateState && moduleInstallProgressListener != null ) { ModuleInstallClient moduleInstallClient = ModuleInstall . getClient ( plugin . getContext ( ) ) ; moduleInstallClient . unregisterListener ( moduleInstallProgressListener ) ; moduleInstallProgressListener = null ; } } private Point getDisplaySize ( ) { WindowManager wm = ( WindowManager ) plugin . getContext ( ) . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = wm . getDefaultDisplay ( ) ; Point size = new Point ( ) ; display . getRealSize ( size ) ; return size ; } private void hideWebViewBackground ( ) { plugin . getBridge ( ) . getWebView ( ) . setBackgroundColor ( Color . TRANSPARENT ) ; } private void showWebViewBackground ( ) { plugin . getBridge ( ) . getWebView ( ) . setBackgroundColor ( Color . WHITE ) ; } private void handleScannedBarcode ( Barcode barcode , Point imageSize ) { plugin . notifyBarcodeScannedListener ( barcode , imageSize ) ; } private void handleScanError ( Exception exception ) { plugin . notifyScanErrorListener ( exception . getMessage ( ) ) ; } private BarcodeScannerOptions buildBarcodeScannerOptions ( ScanSettings scanSettings ) { int [ ] formats = scanSettings . formats . length == <NUM_LIT> ? new int [ ] { Barcode . FORMAT_ALL_FORMATS } : scanSettings . formats ; BarcodeScannerOptions options = new BarcodeScannerOptions . Builder ( ) . setBarcodeFormats ( formats [ <NUM_LIT> ] , formats ) . build ( ) ; return options ; } private GmsBarcodeScannerOptions buildGmsBarcodeScannerOptions ( ScanSettings scanSettings ) { int [ ] formats = scanSettings . formats . length == <NUM_LIT> ? new int [ ] { Barcode . FORMAT_ALL_FORMATS } : scanSettings . formats ; GmsBarcodeScannerOptions options = new GmsBarcodeScannerOptions . Builder ( ) . setBarcodeFormats ( formats [ <NUM_LIT> ] , formats ) . build ( ) ; return options ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog . listener ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; import java . util . ArrayList ; public class ChainRecogListener implements IRecogListener { private ArrayList < IRecogListener > listeners ; public ChainRecogListener ( ) { listeners = new ArrayList < IRecogListener > ( ) ; } public void addListener ( IRecogListener listener ) { listeners . add ( listener ) ; } @ Override public void onAsrReady ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrReady ( ) ; } } @ Override public void onAsrBegin ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrBegin ( ) ;", "output": "} } @ Override public void onAsrEnd ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrEnd ( ) ; } } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrPartialResult ( results , recogResult ) ; } } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinalResult ( results , recogResult ) ; } } @ Override public void onAsrFinish ( RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinish ( recogResult ) ; } } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrFinishError ( errorCode , subErrorCode , descMessage , recogResult ) ; } } @ Override public void onAsrLongFinish ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrLongFinish ( ) ; } } @ Override public void onAsrVolume ( int volumePercent , int volume ) { for ( IRecogListener listener : listeners ) { listener . onAsrVolume ( volumePercent , volume ) ; } } @ Override public void onAsrAudio ( byte [ ] data , int offset , int length ) { for ( IRecogListener listener : listeners ) { listener . onAsrAudio ( data , offset , length ) ; } } @ Override public void onAsrExit ( ) { for ( IRecogListener listener : listeners ) { listener . onAsrExit ( ) ; } } @ Override public void onAsrOnlineNluResult ( String nluResult ) { for ( IRecogListener listener : listeners ) { listener . onAsrOnlineNluResult ( nluResult ) ; } } @ Override public void onOfflineLoaded ( ) { for ( IRecogListener listener : listeners ) { listener . onOfflineLoaded ( ) ; } } @ Override public void onOfflineUnLoaded ( ) { for ( IRecogListener listener : listeners ) { listener . onOfflineUnLoaded ( ) ; } } }"}, {"input": "package com . getcapacitor . android ; import static org . junit . Assert . * ; import android . content . Context ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import androidx . test . platform . app . InstrumentationRegistry ; import org . junit . Test ; import org . junit . runner . RunWith ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) throws Exception { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ; }", "output": "}"}, {"input": "package com . baidu . aip . asrwakeup3 . core . mini ; import android . Manifest ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import com . baidu . aip . asrwakeup3 . core . R ; import com . baidu . aip . asrwakeup3 . core . util . AuthUtil ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . Map ; public class ActivityMiniRecog extends AppCompatActivity implements EventListener { protected TextView txtLog ; protected TextView txtResult ; protected Button btn ; protected Button stopBtn ; private static String DESC_TEXT = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private EventManager asr ; private boolean logTime = true ; protected boolean enableOffline = false ; private void start ( ) { txtLog . setText ( \"<STR_LIT>\" ) ; Map < String , Object > params = AuthUtil . getParam ( ) ; String event = null ; event = SpeechConstant . ASR_START ; if ( enableOffline ) { params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; } params . put ( SpeechConstant . ACCEPT_AUDIO_VOLUME , false ) ; ( new AutoCheck ( getApplicationContext ( ) , new Handler ( ) { public void handleMessage ( Message msg ) { if ( msg . what == <NUM_LIT> ) { AutoCheck autoCheck = ( AutoCheck ) msg . obj ; synchronized ( autoCheck ) { String message = autoCheck . obtainErrorMessage ( ) ; txtLog . append ( message + \"<STR_LIT>\" ) ; ; } } } } , enableOffline ) ) . checkAsr ( params ) ; String json = null ; json = new JSONObject ( params ) . toString ( ) ; asr . send ( event , json , null , <NUM_LIT> , <NUM_LIT> ) ; printLog ( \"<STR_LIT>\" + json ) ; } private void stop ( ) { printLog ( \"<STR_LIT>\" ) ; asr . send ( SpeechConstant . ASR_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } private void loadOfflineEngine ( ) { Map < String , Object > params = new LinkedHashMap < String , Object > ( ) ; params . put ( SpeechConstant . DECODER , <NUM_LIT> ) ; params . put ( SpeechConstant . ASR_OFFLINE_ENGINE_GRAMMER_FILE_PATH , \"<STR_LIT>\" ) ; asr . send ( SpeechConstant . ASR_KWS_LOAD_ENGINE , new JSONObject ( params ) . toString ( ) , null , <NUM_LIT> , <NUM_LIT> ) ; } private void unloadOfflineEngine ( ) { asr . send ( SpeechConstant . ASR_KWS_UNLOAD_ENGINE , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . common_mini ) ; initView ( ) ; initPermission ( ) ; asr = EventManagerFactory . create ( this , \"<STR_LIT>\" ) ; asr . registerListener ( this ) ; btn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { start ( ) ; } } ) ; stopBtn . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { stop ( ) ; } } ) ; if ( enableOffline ) { loadOfflineEngine ( ) ; } } @ Override protected void onPause ( ) { super . onPause ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; asr . send ( SpeechConstant . ASR_CANCEL , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; if ( enableOffline ) { unloadOfflineEngine ( ) ; } asr . unregisterListener ( this ) ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String logTxt = \"<STR_LIT>\" + name ; if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { if ( params == null || params . isEmpty ( ) ) { return ; } if ( params . contains ( \"<STR_LIT>\" ) ) { if ( length > <NUM_LIT> && data . length > <NUM_LIT> ) { logTxt += \"<STR_LIT>\" + new String ( data , offset , length ) ; } } else if ( params . contains ( \"<STR_LIT>\" ) ) { logTxt += \"<STR_LIT>\" + params ; } else if ( params . contains ( \"<STR_LIT>\" ) ) { logTxt += \"<STR_LIT>\" + params ; } else { logTxt += \"<STR_LIT>\" + params ; if ( data != null ) { logTxt += \"<STR_LIT>\" + data . length ; } } } else { if ( params != null && ! params . isEmpty ( ) ) { logTxt += \"<STR_LIT>\" + params ; } if ( data != null ) { logTxt += \"<STR_LIT>\" + data . length ; } } printLog ( logTxt ) ;", "output": "} private void printLog ( String text ) { if ( logTime ) { text += \"<STR_LIT>\" + System . currentTimeMillis ( ) ; } text += \"<STR_LIT>\" ; Log . i ( getClass ( ) . getName ( ) , text ) ; txtLog . append ( text + \"<STR_LIT>\" ) ; } private void initView ( ) { txtResult = ( TextView ) findViewById ( R . id . txtResult ) ; txtLog = ( TextView ) findViewById ( R . id . txtLog ) ; btn = ( Button ) findViewById ( R . id . btn ) ; stopBtn = ( Button ) findViewById ( R . id . btn_stop ) ; txtLog . setText ( DESC_TEXT + \"<STR_LIT>\" ) ; } private void initPermission ( ) { String permissions [ ] = { Manifest . permission . RECORD_AUDIO , Manifest . permission . ACCESS_NETWORK_STATE , Manifest . permission . INTERNET , Manifest . permission . WRITE_EXTERNAL_STORAGE } ; ArrayList < String > toApplyList = new ArrayList < String > ( ) ; for ( String perm : permissions ) { if ( PackageManager . PERMISSION_GRANTED != ContextCompat . checkSelfPermission ( this , perm ) ) { toApplyList . add ( perm ) ; } } String tmpList [ ] = new String [ toApplyList . size ( ) ] ; if ( ! toApplyList . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , toApplyList . toArray ( tmpList ) , <NUM_LIT> ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { } }"}, {"input": "package android . content . res ; import android . graphics . drawable . Drawable ; public class TypedArray { TypedArray ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } protected TypedArray ( Resources resources , int [ ] data , int [ ] indices , int len ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public boolean getBoolean ( int index , boolean defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ;", "output": "} public int getColor ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public ColorStateList getColorStateList ( int index ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getDimension ( int index , float defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getDimensionPixelOffset ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getDimensionPixelSize ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Drawable getDrawable ( int index ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getFloat ( int index , float defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public float getFraction ( int index , int base , int pbase , float defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getInt ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getInteger ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getLayoutDimension ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getLayoutDimension ( int index , String name ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public int getResourceId ( int index , int defValue ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public Resources getResources ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getString ( int index ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence getText ( int index ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public CharSequence [ ] getTextArray ( int index ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public void recycle ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "public class InnerClassReferenceLeakActivity extends AppCompatActivity { private static LeakyClass leakyClass ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; new LeakyClass ( this ) . redirectToSecondScreen ( ) ; leakyClass = new LeakyClass ( this ) ; leakyClass . redirectToSecondScreen ( ) ; } private class LeakyClass { private Activity activity ; public LeakyClass ( Activity activity ) { this . activity = activity ; } public void redirectToSecondScreen ( ) { this . activity . startActivity ( new Intent ( activity , SecondActivity . class ) ) ; } }", "output": "} public class T { public class C { private void set ( Activity a ) { int b = <NUM_LIT> ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; public class InHookXConfig extends XConfig { public static final InHookXConfig config = new InHookXConfig ( new XSharedPreferences ( BuildConfig . APPLICATION_ID , PREF_NAME ) ) ; protected InHookXConfig ( XSharedPreferences sharedPreferences ) { super ( sharedPreferences ) ; XposedBridge . log ( sharedPreferences . getFile ( ) . toString ( ) ) ; } public static InHookXConfig getInstance ( ) {", "output": "return config ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . core . util . Consumer ; public class PopupStyles { private PopupStyles ( ) { } public static Consumer < TextView > DEFAULT = popupView -> { Resources resources = popupView . getResources ( ) ; int minimumSize = resources . getDimensionPixelSize ( R . dimen . afs_popup_min_size ) ; popupView . setMinimumWidth ( minimumSize ) ; popupView . setMinimumHeight ( minimumSize ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . RIGHT | Gravity . CENTER_VERTICAL ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new AutoMirrorDrawable ( Utils . getGradientDrawableWithTintAttr ( R . drawable . afs_popup_background , android . R . attr . colorControlActivated , context ) ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ;", "output": "popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_popup_text_size ) ) ; } ; public static Consumer < TextView > MD2 = popupView -> { Resources resources = popupView . getResources ( ) ; popupView . setMinimumWidth ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_width ) ) ; popupView . setMinimumHeight ( resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_min_height ) ) ; FrameLayout . LayoutParams layoutParams = ( FrameLayout . LayoutParams ) popupView . getLayoutParams ( ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL | Gravity . TOP ; layoutParams . setMarginEnd ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_margin_end ) ) ; popupView . setLayoutParams ( layoutParams ) ; Context context = popupView . getContext ( ) ; popupView . setBackground ( new Md2PopupBackground ( context ) ) ; popupView . setElevation ( resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_elevation ) ) ; popupView . setEllipsize ( TextUtils . TruncateAt . MIDDLE ) ; popupView . setGravity ( Gravity . CENTER ) ; popupView . setIncludeFontPadding ( false ) ; popupView . setSingleLine ( true ) ; popupView . setTextColor ( Utils . getColorFromAttrRes ( android . R . attr . textColorPrimaryInverse , context ) ) ; popupView . setTextSize ( TypedValue . COMPLEX_UNIT_PX , resources . getDimensionPixelSize ( R . dimen . afs_md2_popup_text_size ) ) ; } ; }"}, {"input": "package android . app ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; public final class ActivityThread { public static ActivityThread currentActivityThread ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static Application currentApplication ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static String currentPackageName ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public final LoadedApk getPackageInfoNoCheck ( ApplicationInfo ai , CompatibilityInfo compatInfo ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; }", "output": "}"}, {"input": "public class MainActivity extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { EditText edtView = ( EditText ) findViewById ( R . id . editTextConvertValue ) ; edtView . setInputType ( <NUM_LIT> ) ; editor . setInputType ( InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText key = ( EditText ) findViewById ( R . id . editTextConvertValue ) ; key . setInputType ( <NUM_LIT> ) ; key . setInputType ( InputType . TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ; abc . setInputType ( InputType . TYPE_TEXT_FLAG_CAP_SENTENCES ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ;", "output": "abc . setInputType ( <NUM_LIT> ) ; EditText abc = ( EditText ) findViewById ( R . id . editTextConvertpwdValue ) ; abc . setInputType ( <NUM_LIT> ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . foregroundservice ; import static android . content . Context . POWER_SERVICE ; import android . app . NotificationChannel ; import android . app . NotificationManager ; import android . content . Context ; import android . content . Intent ; import android . os . Build ; import android . os . Bundle ; import android . os . PowerManager ; import androidx . annotation . Nullable ; import com . getcapacitor . plugin . util . AssetUtil ; import java . util . ArrayList ; public class ForegroundService { public static final String DEFAULT_NOTIFICATION_CHANNEL_ID = \"<STR_LIT>\" ; private final ForegroundServicePlugin plugin ; @ Nullable private PowerManager . WakeLock activeWakeLock ; public ForegroundService ( ForegroundServicePlugin plugin ) { this . plugin = plugin ; createNotificationChannel ( ) ; } public void startForegroundService ( String body , String icon , int id , String title , ArrayList < Bundle > buttons ) { acquireWakeLock ( ) ; int iconResourceId = AssetUtil . getResourceID ( plugin . getContext ( ) , AssetUtil . getResourceBaseName ( icon ) , \"<STR_LIT>\" ) ; Bundle notificationBundle = new Bundle ( ) ; notificationBundle . putString ( \"<STR_LIT>\" , body ) ; notificationBundle . putInt ( \"<STR_LIT>\" , iconResourceId ) ;", "output": "notificationBundle . putInt ( \"<STR_LIT>\" , id ) ; notificationBundle . putString ( \"<STR_LIT>\" , title ) ; notificationBundle . putParcelableArrayList ( \"<STR_LIT>\" , new ArrayList < Bundle > ( buttons ) ) ; Context context = plugin . getContext ( ) ; Intent intent = new Intent ( context , AndroidForegroundService . class ) ; intent . putExtra ( \"<STR_LIT>\" , notificationBundle ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { context . startForegroundService ( intent ) ; } else { context . startService ( intent ) ; } } public void stopForegroundService ( ) { releaseWakeLock ( ) ; Context context = plugin . getContext ( ) ; Intent intent = new Intent ( context , AndroidForegroundService . class ) ; context . stopService ( intent ) ; } private void acquireWakeLock ( ) { if ( activeWakeLock != null ) { return ; } PowerManager powerManager = ( PowerManager ) plugin . getContext ( ) . getSystemService ( POWER_SERVICE ) ; PowerManager . WakeLock wakeLock = powerManager . newWakeLock ( PowerManager . PARTIAL_WAKE_LOCK , \"<STR_LIT>\" ) ; wakeLock . acquire ( ) ; activeWakeLock = wakeLock ; } private void releaseWakeLock ( ) { if ( activeWakeLock == null ) { return ; } activeWakeLock . release ( ) ; activeWakeLock = null ; } private void createNotificationChannel ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { CharSequence name = \"<STR_LIT>\" ; String description = \"<STR_LIT>\" ; int importance = NotificationManager . IMPORTANCE_DEFAULT ; NotificationChannel channel = new NotificationChannel ( DEFAULT_NOTIFICATION_CHANNEL_ID , name , importance ) ; channel . setDescription ( description ) ; NotificationManager notificationManager = plugin . getContext ( ) . getSystemService ( NotificationManager . class ) ; notificationManager . createNotificationChannel ( channel ) ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . core ; import android . app . Activity ; import android . app . Application ; import android . app . Instrumentation ; import android . content . BroadcastReceiver ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Bundle ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . components . SharedPreferencesWrapper ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . features . customization . BubbleColors ; import com . wmods . wppenhacer . xposed . features . customization . CustomTheme ; import com . wmods . wppenhacer . xposed . features . customization . CustomTime ; import com . wmods . wppenhacer . xposed . features . customization . CustomToolbar ; import com . wmods . wppenhacer . xposed . features . customization . CustomView ; import com . wmods . wppenhacer . xposed . features . customization . DotOnline ; import com . wmods . wppenhacer . xposed . features . customization . FilterGroups ; import com . wmods . wppenhacer . xposed . features . customization . HideTabs ; import com . wmods . wppenhacer . xposed . features . customization . IGStatus ; import com . wmods . wppenhacer . xposed . features . customization . SeparateGroup ; import com . wmods . wppenhacer . xposed . features . general . AntiRevoke ; import com . wmods . wppenhacer . xposed . features . general . CallType ; import com . wmods . wppenhacer . xposed . features . general . ChatLimit ; import com . wmods . wppenhacer . xposed . features . general . DeleteStatus ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . features . general . NewChat ; import com . wmods . wppenhacer . xposed . features . general . Others ; import com . wmods . wppenhacer . xposed . features . general . PinnedLimit ; import com . wmods . wppenhacer . xposed . features . general . SeenTick ; import com . wmods . wppenhacer . xposed . features . general . ShareLimit ; import com . wmods . wppenhacer . xposed . features . general . ShowEditMessage ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . features . media . DownloadProfile ; import com . wmods . wppenhacer . xposed . features . media . DownloadViewOnce ; import com . wmods . wppenhacer . xposed . features . media . MediaPreview ; import com . wmods . wppenhacer . xposed . features . media . MediaQuality ; import com . wmods . wppenhacer . xposed . features . media . StatusDownload ; import com . wmods . wppenhacer . xposed . features . others . Channels ; import com . wmods . wppenhacer . xposed . features . others . ChatFilters ; import com . wmods . wppenhacer . xposed . features . others . CopyStatus ; import com . wmods . wppenhacer . xposed . features . others . DebugFeature ; import com . wmods . wppenhacer . xposed . features . others . GroupAdmin ; import com . wmods . wppenhacer . xposed . features . others . Stickers ; import com . wmods . wppenhacer . xposed . features . others . TextStatusComposer ; import com . wmods . wppenhacer . xposed . features . others . ToastViewer ; import com . wmods . wppenhacer . xposed . features . privacy . CallPrivacy ; import com . wmods . wppenhacer . xposed . features . privacy . DndMode ; import com . wmods . wppenhacer . xposed . features . privacy . FreezeLastSeen ; import com . wmods . wppenhacer . xposed . features . privacy . GhostMode ; import com . wmods . wppenhacer . xposed . features . privacy . HideChat ; import com . wmods . wppenhacer . xposed . features . privacy . HideReceipt ; import com . wmods . wppenhacer . xposed . features . privacy . HideSeen ; import com . wmods . wppenhacer . xposed . features . privacy . HideTagForward ; import com . wmods . wppenhacer . xposed . features . privacy . ViewOnce ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FeatureLoader { public static Application mApp ; public final static String PACKAGE_WPP = \"<STR_LIT>\" ; public final static String PACKAGE_BUSINESS = \"<STR_LIT>\" ; private static final ArrayList < ErrorItem > list = new ArrayList < > ( ) ; private static List < String > supportedVersions ; private static String currentVersion ; public static void start ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , String sourceDir ) { if ( ! Unobfuscator . initDexKit ( sourceDir ) ) { XposedBridge . log ( \"<STR_LIT>\" ) ; return ; } Feature . DEBUG = pref . getBoolean ( \"<STR_LIT>\" , true ) ; XposedHelpers . findAndHookMethod ( Instrumentation . class , \"<STR_LIT>\" , Application . class , new XC_MethodHook ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { mApp = ( Application ) param . args [ <NUM_LIT> ] ; PackageManager packageManager = mApp . getPackageManager ( ) ; pref . registerOnSharedPreferenceChangeListener ( ( sharedPreferences , s ) -> pref . reload ( ) ) ; PackageInfo packageInfo = packageManager . getPackageInfo ( mApp . getPackageName ( ) , <NUM_LIT> ) ; XposedBridge . log ( packageInfo . versionName ) ; currentVersion = packageInfo . versionName ; supportedVersions = Arrays . asList ( mApp . getResources ( ) . getStringArray ( Objects . equals ( mApp . getPackageName ( ) , FeatureLoader . PACKAGE_WPP ) ? ResId . array . supported_versions_wpp : ResId . array . supported_versions_business ) ) ; try { SharedPreferencesWrapper . hookInit ( mApp . getClassLoader ( ) ) ; UnobfuscatorCache . init ( mApp , pref ) ; WppCore . Initialize ( loader ) ; if ( supportedVersions . stream ( ) . noneMatch ( s -> packageInfo . versionName . startsWith ( s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) && ! pref . getBoolean ( \"<STR_LIT>\" , false ) ) { throw new Exception ( \"<STR_LIT>\" + packageInfo . versionName ) ; } DesignUtils . setPrefs ( pref ) ; initComponents ( loader , pref ) ; plugins ( loader , pref , packageInfo . versionName ) ; registerReceivers ( ) ; mApp . registerActivityLifecycleCallbacks ( new WaCallback ( ) ) ; sendEnabledBroadcast ( mApp ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( \"<STR_LIT>\" ) ; error . setWhatsAppVersion ( packageInfo . versionName ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + \"<STR_LIT>\" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( \"<STR_LIT>\" ) && ! s . getClassName ( ) . startsWith ( \"<STR_LIT>\" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , loader , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ! list . isEmpty ( ) ) { var activity = ( Activity ) param . thisObject ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . error_detected ) ) . setMessage ( activity . getString ( ResId . string . version_error ) + String . join ( \"<STR_LIT>\" , list . stream ( ) . map ( ErrorItem :: getPluginName ) . toArray ( String [ ] :: new ) ) + \"<STR_LIT>\" + currentVersion + \"<STR_LIT>\" + String . join ( \"<STR_LIT>\" , supportedVersions ) ) . setPositiveButton ( activity . getString ( ResId . string . copy_to_clipboard ) , ( dialog , which ) -> { var clipboard = ( ClipboardManager ) mApp . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( \"<STR_LIT>\" , String . join ( \"<STR_LIT>\" , list . stream ( ) . map ( ErrorItem :: toString ) . toArray ( String [ ] :: new ) ) ) ; clipboard . setPrimaryClip ( clip ) ; Toast . makeText ( mApp , ResId . string . copied_to_clipboard , Toast . LENGTH_SHORT ) . show ( ) ; dialog . dismiss ( ) ; } ) . show ( ) ; } } } ) ; } private static void initComponents ( ClassLoader loader , XSharedPreferences pref ) throws Exception { AlertDialogWpp . initDialog ( loader ) ; FMessageWpp . init ( loader ) ; } private static void registerReceivers ( ) { BroadcastReceiver restartReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { if ( context . getPackageName ( ) . equals ( intent . getStringExtra ( \"<STR_LIT>\" ) ) ) { var appName = context . getPackageManager ( ) . getApplicationLabel ( context . getApplicationInfo ( ) ) ; Toast . makeText ( context , context . getString ( ResId . string . rebooting ) + \"<STR_LIT>\" + appName + \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; if ( ! Utils . doRestart ( context ) ) Toast . makeText ( context , \"<STR_LIT>\" + appName , Toast . LENGTH_SHORT ) . show ( ) ; } } } ; ContextCompat . registerReceiver ( mApp , restartReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver wppReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { sendEnabledBroadcast ( context ) ; } } ; ContextCompat . registerReceiver ( mApp , wppReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) , ContextCompat . RECEIVER_EXPORTED ) ; BroadcastReceiver restartManualReceiver = new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { WppCore . setPrivBoolean ( \"<STR_LIT>\" , true ) ; } } ; ContextCompat . registerReceiver ( mApp , restartManualReceiver , new IntentFilter ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) , ContextCompat . RECEIVER_EXPORTED ) ; } private static void sendEnabledBroadcast ( Context context ) { try { Intent wppIntent = new Intent ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; wppIntent . putExtra ( \"<STR_LIT>\" , context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , <NUM_LIT> ) . versionName ) ; wppIntent . putExtra ( \"<STR_LIT>\" , context . getPackageName ( ) ) ; wppIntent . setPackage ( BuildConfig . APPLICATION_ID ) ; context . sendBroadcast ( wppIntent ) ; } catch ( Exception ignored ) { } } private static void plugins ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences pref , @ NonNull String versionWpp ) { var classes = new Class < ? > [ ] { DebugFeature . class , MenuStatus . class , ShowEditMessage . class , AntiRevoke . class , CustomToolbar . class , CustomView . class , SeenTick . class , BubbleColors . class , CallPrivacy . class , CustomTheme . class , ChatLimit . class , SeparateGroup . class , DotOnline . class , DndMode . class , FreezeLastSeen . class , GhostMode . class , HideChat . class , HideReceipt . class , HideSeen . class , HideTagForward . class , HideTabs . class , IGStatus . class , MediaQuality . class , NewChat . class , Others . class , PinnedLimit . class , CustomTime . class , ShareLimit . class , StatusDownload . class , ViewOnce . class , CallType . class , MediaPreview . class , FilterGroups . class , Tasker . class , DeleteStatus . class , DownloadViewOnce . class , Channels . class , DownloadProfile . class , ChatFilters . class , GroupAdmin . class , Stickers . class , CopyStatus . class , TextStatusComposer . class , ToastViewer . class } ; for ( var classe : classes ) { try { var constructor = classe . getConstructor ( ClassLoader . class , XSharedPreferences . class ) ; var plugin = ( Feature ) constructor . newInstance ( loader , pref ) ; plugin . doHook ( ) ; } catch ( Throwable e ) { XposedBridge . log ( e ) ; var error = new ErrorItem ( ) ; error . setPluginName ( classe . getSimpleName ( ) ) ; error . setWhatsAppVersion ( versionWpp ) ; error . setModuleVersion ( BuildConfig . VERSION_NAME ) ; error . setError ( e . getMessage ( ) + \"<STR_LIT>\" + Arrays . toString ( Arrays . stream ( e . getStackTrace ( ) ) . filter ( s -> ! s . getClassName ( ) . startsWith ( \"<STR_LIT>\" ) && ! s . getClassName ( ) . startsWith ( \"<STR_LIT>\" ) ) . map ( StackTraceElement :: toString ) . toArray ( ) ) ) ; list . add ( error ) ; } } } private static class ErrorItem { private String pluginName ; private String whatsAppVersion ; private String error ; private String moduleVersion ; @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + getPluginName ( ) + '<STR_LIT>' + \"<STR_LIT>\" + getModuleVersion ( ) + '<STR_LIT>' + \"<STR_LIT>\" + getWhatsAppVersion ( ) + '<STR_LIT>' + \"<STR_LIT>\" + getError ( ) + '<STR_LIT>' ; } public String getWhatsAppVersion ( ) { return whatsAppVersion ; } public void setWhatsAppVersion ( String whatsAppVersion ) { this . whatsAppVersion = whatsAppVersion ; } public String getError ( ) { return error ; } public void setError ( String error ) { this . error = error ; } public String getPluginName ( ) { return pluginName ; } public void setPluginName ( String pluginName ) {", "output": "this . pluginName = pluginName ; } public String getModuleVersion ( ) { return moduleVersion ; } public void setModuleVersion ( String moduleVersion ) { this . moduleVersion = moduleVersion ; } } }"}, {"input": "package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; public interface IUpdatePrompter {", "output": "void showPrompt ( @ NonNull UpdateEntity updateEntity , @ NonNull IUpdateProxy updateProxy , @ NonNull PromptEntity promptEntity ) ; }"}, {"input": "package com . reactnative . activityindicator ; import android . content . Context ; import android . graphics . Color ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . SimpleViewManager ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . yoga . YogaMeasureFunction ; import com . facebook . yoga . YogaMeasureMode ; import com . facebook . yoga . YogaMeasureOutput ; import com . facebook . yoga . YogaNode ; public class ActivityIndicatorManager extends SimpleViewManager < ActivityIndicator > { public static final String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected ActivityIndicator createViewInstance ( @ NonNull ThemedReactContext reactContext ) {", "output": "return new ActivityIndicator ( reactContext ) ; } @ Override public Class getShadowNodeClass ( ) { return ActivityIndicatorShadowNode . class ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new ActivityIndicatorShadowNode ( ) ; } @ ReactProp ( name = \"<STR_LIT>\" , defaultBoolean = true ) public void setAnimating ( ActivityIndicator view , boolean animating ) { view . setAnimating ( animating ) ; } @ ReactProp ( name = \"<STR_LIT>\" , customType = \"<STR_LIT>\" ) public void setColor ( ActivityIndicator view , @ Nullable Integer color ) { if ( color != null ) { view . setColor ( color ) ; } else { view . setColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; } } @ ReactProp ( name = \"<STR_LIT>\" ) public void setSize ( ActivityIndicator view , @ Nullable String size ) { if ( size != null && size . equals ( \"<STR_LIT>\" ) ) { view . setSize ( ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ) ; } else { view . setSize ( ( int ) ( PixelUtil . toPixelFromDIP ( <NUM_LIT> ) + <NUM_LIT> ) ) ; } } @ Override public long measure ( Context context , ReadableMap localData , ReadableMap props , ReadableMap state , float width , YogaMeasureMode widthMode , float height , YogaMeasureMode heightMode , @ Nullable float [ ] attachmentsPositions ) { String sizeStr = props . getString ( \"<STR_LIT>\" ) ; if ( sizeStr == null ) { sizeStr = \"<STR_LIT>\" ; } int size = sizeStr . equals ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ; return YogaMeasureOutput . make ( size , size ) ; } static class ActivityIndicatorShadowNode extends LayoutShadowNode implements YogaMeasureFunction { private String mSize ; private ActivityIndicatorShadowNode ( ) { initMeasureFunction ( ) ; } private void initMeasureFunction ( ) { setMeasureFunction ( this ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setSize ( @ Nullable String size ) { if ( mSize == null || ! mSize . equals ( size ) ) { mSize = size ; dirty ( ) ; } } @ Override public long measure ( YogaNode node , float width , YogaMeasureMode widthMode , float height , YogaMeasureMode heightMode ) { if ( mSize == null ) { mSize = \"<STR_LIT>\" ; } int size = ( int ) ( PixelUtil . toPixelFromDIP ( mSize . equals ( \"<STR_LIT>\" ) ? <NUM_LIT> : <NUM_LIT> ) + <NUM_LIT> ) ; return YogaMeasureOutput . make ( size , size ) ; } } }"}, {"input": "package com . reactnative . pulltorefresh ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . View ; import android . widget . ScrollView ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . views . view . ReactViewGroup ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; import com . scwang . smart . refresh . layout . api . RefreshLayout ; import com . scwang . smart . refresh . layout . constant . RefreshState ; import com . scwang . smart . refresh . layout . constant . SpinnerStyle ; @ SuppressLint ( \"<STR_LIT>\" ) public class PullToRefreshHeader extends ReactViewGroup implements RefreshHeader { private RefreshKernel mRefreshKernel ; private OnRefreshChangeListener onRefreshChangeListener ; private boolean mIsRefreshing = false ; public void setOnRefreshHeaderChangeListener ( OnRefreshChangeListener onRefreshChangeListener ) { this . onRefreshChangeListener = onRefreshChangeListener ; } public PullToRefreshHeader ( Context context ) { super ( context ) ; } @ NonNull @ Override public View getView ( ) { return this ; } public void setRefreshing ( boolean refreshing ) { mIsRefreshing = refreshing ; if ( refreshing ) { beginRefresh ( ) ; } else { finishRefresh ( ) ; } } public void beginRefresh ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isFooter && ! refreshState . isOpening ) { View scrollable = mRefreshKernel . getRefreshContent ( ) . getScrollableView ( ) ; if ( scrollable instanceof ScrollView ) { ScrollView scrollView = ( ScrollView ) scrollable ; scrollView . smoothScrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } else { scrollable . scrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } mRefreshKernel . getRefreshLayout ( ) . autoRefresh ( ) ; } } } public void finishRefresh ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isFooter && ! refreshState . isFinishing ) { mRefreshKernel . getRefreshLayout ( ) . finishRefresh ( ) ; } } } @ NonNull @ Override public SpinnerStyle getSpinnerStyle ( ) { return SpinnerStyle . Translate ; } @ Override public void setPrimaryColors ( int ... colors ) { } @ Override public void onInitialized ( @ NonNull RefreshKernel kernel , int height , int maxDragHeight ) { mRefreshKernel = kernel ; mRefreshKernel . getRefreshLayout ( ) . setOnRefreshListener ( refreshLayout -> { if ( onRefreshChangeListener != null && refreshLayout . getState ( ) == RefreshState . Refreshing ) { onRefreshChangeListener . onRefresh ( ) ; } } ) ; setRefreshing ( mIsRefreshing ) ; } @ Override public void onMoving ( boolean isDragging , float percent , int offset , int height , int maxDragHeight ) { if ( isDragging && onRefreshChangeListener != null ) { onRefreshChangeListener . onOffsetChange ( offset ) ; } } @ Override public void onReleased ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int measureMode = MeasureSpec . getMode ( heightMeasureSpec ) ; if ( measureMode == MeasureSpec . AT_MOST ) { heightMeasureSpec = MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ; } super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( getParent ( ) instanceof PullToRefresh && mRefreshKernel == null ) { PullToRefresh refreshLayout = ( PullToRefresh ) getParent ( ) ; int h = MeasureSpec . getSize ( heightMeasureSpec ) ; refreshLayout . setHeaderHeightPx ( h ) ; } } PullToRefreshHeaderLocalData headerLocalData = new PullToRefreshHeaderLocalData ( ) ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( headerLocalData . viewRect . top == top && headerLocalData . viewRect . bottom == bottom && headerLocalData . viewRect . left == left && headerLocalData . viewRect . right == right ) { return ; } headerLocalData . viewRect . top = top ; headerLocalData . viewRect . bottom = bottom ; headerLocalData . viewRect . left = left ; headerLocalData . viewRect . right = right ; Context context = getContext ( ) ; if ( context instanceof ReactContext ) { ReactContext reactContext = ( ReactContext ) context ; UIManagerModule uiManagerModule = reactContext . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule != null ) { uiManagerModule . setViewLocalData ( getId ( ) , headerLocalData ) ; } } } @ Override public void onStartAnimator ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public int onFinish ( @ NonNull RefreshLayout refreshLayout , boolean success ) { return <NUM_LIT> ; } @ Override public void onHorizontalDrag ( float percentX , int offsetX , int offsetMax ) { } @ Override public boolean isSupportHorizontalDrag ( ) { return false ; } @ Override public boolean autoOpen ( int duration , float dragRate , boolean animationOnly ) { return false ; } @ Override public void onStateChanged ( @ NonNull RefreshLayout refreshLayout , @ NonNull RefreshState oldState , @ NonNull RefreshState newState ) { if ( onRefreshChangeListener != null ) { PullToRefreshState oldPullToRefreshState = convertRefreshStateToPullToRefreshState ( oldState ) ; PullToRefreshState newPullToRefreshState = convertRefreshStateToPullToRefreshState ( newState ) ; if ( newPullToRefreshState != oldPullToRefreshState ) { onRefreshChangeListener . onStateChanged ( newPullToRefreshState ) ; } } } @ Override public PointerEvents getPointerEvents ( ) { RefreshState refreshState = mRefreshKernel != null ? mRefreshKernel . getRefreshLayout ( ) . getState ( ) : RefreshState . None ;", "output": "if ( refreshState . isHeader && refreshState . isOpening ) { return super . getPointerEvents ( ) ; } return PointerEvents . NONE ; } private PullToRefreshState convertRefreshStateToPullToRefreshState ( RefreshState state ) { if ( state == RefreshState . ReleaseToRefresh ) { return PullToRefreshState . Coming ; } if ( state == RefreshState . Refreshing || state == RefreshState . RefreshReleased ) { return PullToRefreshState . Refreshing ; } return PullToRefreshState . Idle ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class FreezeLastSeen extends Feature { public FreezeLastSeen ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( ! WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) && prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ;", "output": "var method = Unobfuscator . loadFreezeSeenMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . norman . webviewup . lib . util ; import android . os . Build ; import android . os . Process ; import android . util . Log ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . interfaces . IVMRuntime ; import java . lang . reflect . Method ; import java . util . Arrays ; public class ProcessUtils { private static String currentInstructionSet = null ; public static boolean is64Bit ( ) { boolean process64bit = false ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M ) { process64bit = Process . is64Bit ( ) ; } else { try { IVMRuntime vmRuntime = RuntimeAccess . staticAccess ( IVMRuntime . class ) ; vmRuntime = RuntimeAccess . objectAccess ( IVMRuntime . class , vmRuntime . getRuntime ( ) ) ; process64bit = vmRuntime . is64Bit ( ) ; } catch ( Throwable ignore ) { } } return process64bit ; } public static String getCurrentInstruction ( ) { if ( currentInstructionSet != null ) { return currentInstructionSet ; } try { IVMRuntime ivmRuntime = RuntimeAccess . staticAccess ( IVMRuntime . class ) ;", "output": "currentInstructionSet = ivmRuntime . getCurrentInstructionSet ( ) ; } catch ( Throwable throwable ) { String [ ] abiSearchArr = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Arrays . sort ( abiSearchArr ) ; for ( String search : abiSearchArr ) { int result = Arrays . binarySearch ( Build . SUPPORTED_ABIS , search ) ; if ( result >= <NUM_LIT> ) { if ( search . equals ( \"<STR_LIT>\" ) || search . equals ( \"<STR_LIT>\" ) ) { currentInstructionSet = \"<STR_LIT>\" ; } else if ( search . equals ( \"<STR_LIT>\" ) ) { currentInstructionSet = \"<STR_LIT>\" ; } else { currentInstructionSet = search ; } break ; } } } return currentInstructionSet ; } }"}, {"input": "package com . simon . harmonichackernews . linkpreview ; import android . content . Context ; import android . util . Xml ; import com . android . volley . Request ; import com . android . volley . RequestQueue ; import com . android . volley . toolbox . StringRequest ; import com . simon . harmonichackernews . data . ArxivInfo ; import com . simon . harmonichackernews . network . NetworkComponent ; import com . simon . harmonichackernews . utils . ArxivResolver ; import org . xmlpull . v1 . XmlPullParser ; import org . xmlpull . v1 . XmlPullParserException ; import java . io . IOException ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ArxivAbstractGetter { public static boolean isValidArxivUrl ( String url ) { String arxivUrlPattern = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( arxivUrlPattern ) ; Matcher matcher = pattern . matcher ( url ) ; return matcher . matches ( ) ; } public static void getAbstract ( String url , Context ctx , GetterCallback callback ) { String arxivID = url . substring ( url . lastIndexOf ( '<STR_LIT>' ) + <NUM_LIT> ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; StringRequest stringRequest = new StringRequest ( Request . Method . GET , \"<STR_LIT>\" + arxivID , response -> { try { XmlPullParser parser = Xml . newPullParser ( ) ; parser . setInput ( new StringReader ( response ) ) ; int eventType = parser . getEventType ( ) ; String abstractText = \"<STR_LIT>\" ; List < String > authorList = new ArrayList < > ( ) ; String primaryCategoryText = \"<STR_LIT>\" ; List < String > secondaryCategoryList = new ArrayList < > ( ) ; String publishedDateText = \"<STR_LIT>\" ; while ( eventType != XmlPullParser . END_DOCUMENT ) { String tagName = parser . getName ( ) ; if ( eventType == XmlPullParser . START_TAG && \"<STR_LIT>\" . equals ( tagName ) ) { parser . next ( ) ; abstractText = parser . getText ( ) ; } if ( eventType == XmlPullParser . START_TAG && \"<STR_LIT>\" . equals ( tagName ) ) { parser . next ( ) ; authorList . add ( parser . getText ( ) ) ; } if ( eventType == XmlPullParser . START_TAG && \"<STR_LIT>\" . equals ( tagName ) ) { primaryCategoryText = parser . getAttributeValue ( null , \"<STR_LIT>\" ) ; } if ( eventType == XmlPullParser . START_TAG && \"<STR_LIT>\" . equals ( tagName ) ) { String category = parser . getAttributeValue ( null , \"<STR_LIT>\" ) ; if ( ! category . equals ( primaryCategoryText ) ) { secondaryCategoryList . add ( category ) ; } } if ( eventType == XmlPullParser . START_TAG && \"<STR_LIT>\" . equals ( tagName ) ) { parser . next ( ) ; publishedDateText = parser . getText ( ) ; } eventType = parser . next ( ) ; } String [ ] authorsArray = authorList . toArray ( new String [ <NUM_LIT> ] ) ; List < String > secondaryCategoriesFiltered = new ArrayList < > ( ) ; for ( String category : secondaryCategoryList ) { if ( ArxivResolver . isArxivSubjet ( category ) ) { secondaryCategoriesFiltered . add ( category ) ; } } String [ ] secondaryCategoriesFilteredArray = secondaryCategoriesFiltered . toArray ( new String [ <NUM_LIT> ] ) ; ArxivInfo info = new ArxivInfo ( ) ; info . arxivAbstract = abstractText ; info . authors = authorsArray ; info . primaryCategory = primaryCategoryText ; info . secondaryCategories = secondaryCategoriesFilteredArray ; info . publishedDate = publishedDateText ; info . arxivID = arxivID ; if ( ! abstractText . isEmpty ( ) && authorsArray . length > <NUM_LIT> && ! primaryCategoryText . isEmpty ( ) && ! publishedDateText . isEmpty ( ) ) { callback . onSuccess ( info ) ; } else { callback . onFailure ( \"<STR_LIT>\" ) ; } } catch ( XmlPullParserException | IOException e ) { callback . onFailure ( \"<STR_LIT>\" ) ; e . printStackTrace ( ) ; } } , error -> { error . printStackTrace ( ) ; callback . onFailure ( \"<STR_LIT>\" ) ; } ) ; RequestQueue queue = NetworkComponent . getRequestQueueInstance ( ctx ) ;", "output": "queue . add ( stringRequest ) ; } public interface GetterCallback { void onSuccess ( ArxivInfo arxivInfo ) ; void onFailure ( String reason ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . app . Activity ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; public class InFileStream { private static Context context ; private static final String TAG = \"<STR_LIT>\" ; private static volatile String filename ; private static volatile InputStream is ; public static void setContext ( Context context ) { InFileStream . context = context ; } public static void setContext ( Context context , String filename ) { InFileStream . context = context ; InFileStream . filename = filename ; } public static void setContext ( Context context , InputStream is ) { InFileStream . context = context ; InFileStream . is = is ; } public static Context getContext ( ) { return context ;", "output": "} public static void reset ( ) { filename = null ; is = null ; } public static InputStream createMyPipedInputStream ( ) { return InPipedStream . createAndStart ( context ) ; } public static InputStream create16kStream ( ) { if ( is == null && filename == null ) { return new FileAudioInputStream ( createFileStream ( ) ) ; } if ( is != null ) { return new FileAudioInputStream ( is ) ; } else if ( filename != null ) { try { return new FileAudioInputStream ( filename ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } return null ; } private static InputStream createFileStream ( ) { try { InputStream is = context . getAssets ( ) . open ( \"<STR_LIT>\" ) ; MyLogger . info ( TAG , \"<STR_LIT>\" + is . available ( ) ) ; return is ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . os . Handler ; import android . os . Message ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; import com . baidu . speech . asr . SpeechConstant ; public class MessageStatusRecogListener extends StatusRecogListener { private Handler handler ; private long speechEndTime = <NUM_LIT> ; private boolean needTime = true ; private static final String TAG = \"<STR_LIT>\" ; public MessageStatusRecogListener ( Handler handler ) { this . handler = handler ; } @ Override public void onAsrReady ( ) { super . onAsrReady ( ) ; speechEndTime = <NUM_LIT> ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_WAKEUP_READY , \"<STR_LIT>\" ) ; } @ Override public void onAsrBegin ( ) { super . onAsrBegin ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_BEGIN , \"<STR_LIT>\" ) ; } @ Override public void onAsrEnd ( ) { super . onAsrEnd ( ) ; speechEndTime = System . currentTimeMillis ( ) ; sendMessage ( \"<STR_LIT>\" ) ; } @ Override public void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , \"<STR_LIT>\" + results [ <NUM_LIT> ] + \"<STR_LIT>\" + recogResult . getOrigalJson ( ) ) ; super . onAsrPartialResult ( results , recogResult ) ; } @ Override public void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) { super . onAsrFinalResult ( results , recogResult ) ; String message = \"<STR_LIT>\" + results [ <NUM_LIT> ] + \"<STR_LIT>\" ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , message + \"<STR_LIT>\" + recogResult . getOrigalJson ( ) ) ; if ( speechEndTime > <NUM_LIT> ) { long currentTime = System . currentTimeMillis ( ) ; long diffTime = currentTime - speechEndTime ; message += \"<STR_LIT>\" + diffTime + \"<STR_LIT>\" + currentTime ; } speechEndTime = <NUM_LIT> ; sendMessage ( message , status , true ) ; } @ Override public void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) { super . onAsrFinishError ( errorCode , subErrorCode , descMessage , recogResult ) ; String message = \"<STR_LIT>\" + errorCode + \"<STR_LIT>\" + subErrorCode + \"<STR_LIT>\" + descMessage ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , message ) ; if ( speechEndTime > <NUM_LIT> ) { long diffTime = System . currentTimeMillis ( ) - speechEndTime ; message += \"<STR_LIT>\" + diffTime + \"<STR_LIT>\" ; } speechEndTime = <NUM_LIT> ; sendMessage ( message , status , true ) ; speechEndTime = <NUM_LIT> ; } @ Override public void onAsrOnlineNluResult ( String nluResult ) { super . onAsrOnlineNluResult ( nluResult ) ; if ( ! nluResult . isEmpty ( ) ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL , \"<STR_LIT>\" + nluResult ) ; } } @ Override public void onAsrFinish ( RecogResult recogResult ) { super . onAsrFinish ( recogResult ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH , \"<STR_LIT>\" ) ; }", "output": "@ Override public void onAsrLongFinish ( ) { super . onAsrLongFinish ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_LONG_SPEECH , \"<STR_LIT>\" ) ; } @ Override public void onOfflineLoaded ( ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_LOADED , \"<STR_LIT>\" ) ; } @ Override public void onOfflineUnLoaded ( ) { sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_UNLOADED , \"<STR_LIT>\" ) ; } @ Override public void onAsrExit ( ) { super . onAsrExit ( ) ; sendStatusMessage ( SpeechConstant . CALLBACK_EVENT_ASR_EXIT , \"<STR_LIT>\" ) ; } private void sendStatusMessage ( String eventName , String message ) { message = \"<STR_LIT>\" + eventName + \"<STR_LIT>\" + message ; sendMessage ( message , status ) ; } private void sendMessage ( String message ) { sendMessage ( message , WHAT_MESSAGE_STATUS ) ; } private void sendMessage ( String message , int what ) { sendMessage ( message , what , false ) ; } private void sendMessage ( String message , int what , boolean highlight ) { if ( needTime && what != STATUS_FINISHED ) { message += \"<STR_LIT>\" + System . currentTimeMillis ( ) ; } if ( handler == null ) { Log . i ( TAG , message ) ; return ; } Message msg = Message . obtain ( ) ; msg . what = what ; msg . arg1 = status ; if ( highlight ) { msg . arg2 = <NUM_LIT> ; } msg . obj = message + \"<STR_LIT>\" ; handler . sendMessage ( msg ) ; } }"}, {"input": "package de . robv . android . xposed ; public interface IXposedHookCmdInit extends IXposedMod { void initCmdApp ( StartupParam startupParam ) throws Throwable ; final class StartupParam { StartupParam ( ) { } public String modulePath ;", "output": "public String startClassName ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Bundle ; import android . util . Base64 ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . opencsv . CSVReader ; import com . opencsv . CSVWriter ; import com . opencsv . exceptions . CsvValidationException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; public class MartialLawCommentAreaListActivity extends AppCompatActivity { private static final int REQUEST_CODE_EXPORT = <NUM_LIT> ; private static final int REQUEST_CODE_IMPORT = <NUM_LIT> ; RecyclerView recyclerView ; StatisticsDBOpenHelper dbOpenHelper ; Context context ; ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList ; MartialLawCommentAreaListAdapter adapter ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_martial_law_comment_area_list ) ; ByXposedLaunchedActivity . lastActivity = this ; context = this ; dbOpenHelper = new StatisticsDBOpenHelper ( context ) ; martialLawCommentAreaArrayList = dbOpenHelper . queryMartialLawCommentAreas ( ) ; recyclerView = findViewById ( R . id . rv_martial_law_comment_area ) ; adapter = new MartialLawCommentAreaListAdapter ( martialLawCommentAreaArrayList , context ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( RecyclerView . VERTICAL ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( linearLayoutManager ) ; } @ Override protected void onActivityResult ( int requestCode , int resultCode , @ Nullable Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { case REQUEST_CODE_EXPORT : ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( \"<STR_LIT>\" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( data != null ) { try ( OutputStream outputStream = getContentResolver ( ) . openOutputStream ( data . getData ( ) ) ; CSVWriter csvWriter = new CSVWriter ( new OutputStreamWriter ( outputStream ) ) ) { List < String [ ] > csvData = new ArrayList < > ( ) ; String [ ] csvHeader = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" }", "output": "; csvData . add ( csvHeader ) ; Collections . reverse ( martialLawCommentAreaArrayList ) ; for ( MartialLawCommentArea area : martialLawCommentAreaArrayList ) { byte [ ] imageData = dbOpenHelper . selectMartialLawCommentAreaCoverImage ( area . oid ) ; String [ ] csvRow = area . toStringArrays ( ) ; if ( imageData != null ) { csvRow [ <NUM_LIT> ] = Base64 . encodeToString ( imageData , Base64 . DEFAULT ) ; } csvData . add ( csvRow ) ; } Collections . reverse ( martialLawCommentAreaArrayList ) ; csvWriter . writeAll ( csvData ) ; runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; error ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } else { error ( \"<STR_LIT>\" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) . start ( ) ; break ; case REQUEST_CODE_IMPORT : ProgressDialog progressDialog1 = new ProgressDialog ( context ) ; progressDialog1 . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog1 . setMessage ( \"<STR_LIT>\" ) ; progressDialog1 . setCancelable ( false ) ; progressDialog1 . show ( ) ; Executor executor = Executors . newSingleThreadExecutor ( ) ; executor . execute ( new Runnable ( ) { @ Override public void run ( ) { List < MartialLawCommentArea > martialLawCommentAreas = new ArrayList < > ( ) ; if ( data != null ) { try ( InputStreamReader inputStreamReader = new InputStreamReader ( context . getContentResolver ( ) . openInputStream ( data . getData ( ) ) ) ; CSVReader csvReader = new CSVReader ( inputStreamReader ) ; ) { String [ ] fileds = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String [ ] csvLine ; int successCount = <NUM_LIT> ; int failCount = <NUM_LIT> ; if ( ( csvLine = csvReader . readNext ( ) ) != null ) { if ( Arrays . equals ( fileds , csvLine ) ) { while ( ( csvLine = csvReader . readNext ( ) ) != null ) { byte [ ] coverImageData = Base64 . decode ( csvLine [ <NUM_LIT> ] , Base64 . DEFAULT ) ; MartialLawCommentArea martialLawCommentArea = new MartialLawCommentArea ( csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , Integer . parseInt ( csvLine [ <NUM_LIT> ] ) , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , csvLine [ <NUM_LIT> ] , coverImageData ) ; System . out . println ( martialLawCommentArea ) ; if ( dbOpenHelper . insertMartialLawCommentArea ( martialLawCommentArea ) > <NUM_LIT> ) { martialLawCommentAreas . add ( martialLawCommentArea ) ; successCount ++ ; } else { failCount ++ ; } } int finalSuccessCount = successCount ; int finalFailCount = failCount ; runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; adapter . addData ( martialLawCommentAreas ) ; Toast . makeText ( context , \"<STR_LIT>\" + finalSuccessCount + \"<STR_LIT>\" + finalFailCount + \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } else { error ( \"<STR_LIT>\" ) ; } } else { error ( \"<STR_LIT>\" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } catch ( CsvValidationException e ) { e . printStackTrace ( ) ; error ( e . getMessage ( ) ) ; } } else { error ( \"<STR_LIT>\" ) ; } } public void error ( String msg ) { runOnUiThread ( ( ) -> { progressDialog1 . dismiss ( ) ; Toast . makeText ( context , msg , Toast . LENGTH_LONG ) . show ( ) ; } ) ; } } ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . menu_export_and_input , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } else if ( item . getItemId ( ) == R . id . item_export ) { Intent intent = new Intent ( Intent . ACTION_CREATE_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . CHINA ) ; intent . putExtra ( Intent . EXTRA_TITLE , \"<STR_LIT>\" + sdf . format ( new Date ( ) ) + \"<STR_LIT>\" ) ; startActivityForResult ( intent , REQUEST_CODE_EXPORT ) ; } else if ( item . getItemId ( ) == R . id . item_import ) { Intent intent = new Intent ( Intent . ACTION_OPEN_DOCUMENT ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . setType ( \"<STR_LIT>\" ) ; startActivityForResult ( intent , REQUEST_CODE_IMPORT ) ; } return true ; } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } }"}, {"input": "package in . hridayan . ashell . activities ; import static in . hridayan . ashell . utils . Preferences . LOCAL_FRAGMENT ; import static in . hridayan . ashell . utils . Preferences . MODE_REMEMBER_LAST_MODE ; import static in . hridayan . ashell . utils . Preferences . OTG_FRAGMENT ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . view . View ; import androidx . activity . EdgeToEdge ; import androidx . appcompat . app . AppCompatActivity ; import androidx . fragment . app . Fragment ; import androidx . lifecycle . ViewModelProvider ; import androidx . preference . PreferenceManager ; import com . google . android . material . badge . BadgeDrawable ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . KeyboardUtils ; import in . hridayan . ashell . UI . MainViewModel ; import in . hridayan . ashell . adapters . SettingsAdapter ; import in . hridayan . ashell . fragments . StartFragment ; import in . hridayan . ashell . fragments . aShellFragment ; import in . hridayan . ashell . fragments . otgShellFragment ; import in . hridayan . ashell . utils . FetchLatestVersionCode ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import in . hridayan . ashell . utils . Utils . FetchLatestVersionCodeCallback ; import java . util . ArrayList ; import java . util . List ; public class MainActivity extends AppCompatActivity implements otgShellFragment . OnFragmentInteractionListener , FetchLatestVersionCodeCallback { private boolean isKeyboardVisible , hasAppRestarted = true ; public BottomNavigationView mNav ; private SettingsAdapter adapter ; private SettingsItem settingsList ; private static int currentFragment ; private boolean isBlackThemeEnabled , isAmoledTheme ; private MainViewModel viewModel ; private String pendingSharedText = null ; @ Override public void onRequestReset ( ) { if ( ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof otgShellFragment ) ) { currentFragment = OTG_FRAGMENT ; mNav . setSelectedItemId ( R . id . nav_otgShell ) ; replaceFragment ( new otgShellFragment ( ) ) ; } } @ Override public void onResult ( int result ) { if ( result == Preferences . UPDATE_AVAILABLE ) { Utils . showBottomSheetUpdate ( this ) ; } } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; handleIncomingIntent ( intent ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; setCurrentFragment ( ) ; viewModel . setCurrentFragment ( currentFragment ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; isAmoledTheme = Preferences . getAmoledTheme ( this ) ; boolean currentTheme = isAmoledTheme ; if ( currentTheme != isBlackThemeEnabled ) { recreate ( ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; List < SettingsItem > settingsList = new ArrayList < > ( ) ; adapter = new SettingsAdapter ( settingsList , this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; viewModel = new ViewModelProvider ( this ) . get ( MainViewModel . class ) ; isAmoledTheme = Preferences . getAmoledTheme ( this ) ; mNav = findViewById ( R . id . bottom_nav_bar ) ; KeyboardUtils . attachVisibilityListener ( this , new KeyboardUtils . KeyboardVisibilityListener ( ) { @ Override public void onKeyboardVisibilityChanged ( boolean visible ) { isKeyboardVisible = visible ; if ( isKeyboardVisible ) { mNav . setVisibility ( View . GONE ) ; } else { new Handler ( Looper . getMainLooper ( ) ) . postDelayed ( ( ) -> { mNav . setVisibility ( View . VISIBLE ) ; } , <NUM_LIT> ) ; } } }", "output": ") ; setupNavigation ( ) ; if ( Utils . isAppUpdated ( this ) ) { Utils . showBottomSheetChangelog ( this ) ; } Preferences . setSavedVersionCode ( this , Utils . currentVersion ( ) ) ; isBlackThemeEnabled = isAmoledTheme ; setBadge ( R . id . nav_wireless , \"<STR_LIT>\" ) ; if ( Preferences . getAutoUpdateCheck ( this ) && hasAppRestarted && ! ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean ( \"<STR_LIT>\" , true ) ) ) { new FetchLatestVersionCode ( this , this ) . execute ( Preferences . buildGradleUrl ) ; } hasAppRestarted = false ; } private void handleSharedTextIntent ( String sharedText , Intent intent ) { setTextOnEditText ( sharedText , intent ) ; } private void handleUseCommandIntent ( String useCommand , Intent intent ) { setTextOnEditText ( useCommand , intent ) ; } private void setTextOnEditText ( String text , Intent intent ) { int currentFragment = Preferences . getCurrentFragment ( this ) ; switch ( currentFragment ) { case LOCAL_FRAGMENT : aShellFragment fragmentLocalAdb = ( aShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentLocalAdb != null ) { if ( intent . hasExtra ( Intent . EXTRA_TEXT ) ) { fragmentLocalAdb . handleSharedTextIntent ( getIntent ( ) , text ) ; } else { fragmentLocalAdb . updateInputField ( text ) ; } } break ; case OTG_FRAGMENT : otgShellFragment fragmentOtg = ( otgShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentOtg != null ) { fragmentOtg . updateInputField ( text ) ; } break ; default : break ; } } private void handlePendingSharedText ( ) { if ( pendingSharedText != null ) { switch ( Preferences . getCurrentFragment ( this ) ) { case LOCAL_FRAGMENT : aShellFragment fragmentLocalAdb = ( aShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentLocalAdb != null ) { fragmentLocalAdb . updateInputField ( pendingSharedText ) ; clearPendingSharedText ( ) ; } break ; case OTG_FRAGMENT : otgShellFragment fragmentOtg = ( otgShellFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragmentOtg != null ) { fragmentOtg . updateInputField ( pendingSharedText ) ; clearPendingSharedText ( ) ; } break ; default : break ; } } } private void setupNavigation ( ) { mNav . setVisibility ( View . VISIBLE ) ; mNav . setOnItemSelectedListener ( item -> { switch ( item . getItemId ( ) ) { case R . id . nav_localShell : showaShellFragment ( ) ; Preferences . setCurrentFragment ( this , LOCAL_FRAGMENT ) ; return true ; case R . id . nav_otgShell : showotgShellFragment ( ) ; Preferences . setCurrentFragment ( this , OTG_FRAGMENT ) ; return true ; default : return false ; } } ) ; initialFragment ( ) ; handleIncomingIntent ( getIntent ( ) ) ; } public void replaceFragment ( Fragment fragment ) { if ( ! getSupportFragmentManager ( ) . isStateSaved ( ) ) { setCurrentFragment ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . fragment_container , fragment ) . commit ( ) ; } } private void showotgShellFragment ( ) { if ( ! ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof otgShellFragment ) ) { currentFragment = OTG_FRAGMENT ; replaceFragment ( new otgShellFragment ( ) ) ; } } private void showaShellFragment ( ) { if ( ! ( getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) instanceof aShellFragment ) ) { currentFragment = LOCAL_FRAGMENT ; replaceFragment ( new aShellFragment ( ) ) ; } } private void showBetaWarning ( ) { MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( this ) ; builder . setCancelable ( false ) . setTitle ( getString ( R . string . warning ) ) . setMessage ( getString ( R . string . beta_warning ) ) . setPositiveButton ( getString ( R . string . accept ) , ( dialogInterface , i ) -> { replaceFragment ( new otgShellFragment ( ) ) ; } ) . setNegativeButton ( getString ( R . string . go_back ) , ( dialogInterface , i ) -> { mNav . setSelectedItemId ( R . id . nav_localShell ) ; } ) . setNeutralButton ( getString ( R . string . donot_show_again ) , ( dialogInterface , i ) -> { PreferenceManager . getDefaultSharedPreferences ( this ) . edit ( ) . putBoolean ( \"<STR_LIT>\" , false ) . apply ( ) ; replaceFragment ( new otgShellFragment ( ) ) ; } ) . show ( ) ; } private void setBadge ( int id , String text ) { BadgeDrawable badge = mNav . getOrCreateBadge ( id ) ; badge . setVisible ( true ) ; badge . setText ( text ) ; badge . setHorizontalOffset ( <NUM_LIT> ) ; } private void initialFragment ( ) { if ( PreferenceManager . getDefaultSharedPreferences ( this ) . getBoolean ( \"<STR_LIT>\" , true ) ) { mNav . setVisibility ( View . GONE ) ; replaceFragment ( new StartFragment ( ) ) ; } else { boolean isFragmentSaved = viewModel . isFragmentSaved ( ) ; if ( isFragmentSaved ) { int currentFragment = viewModel . currentFragment ( ) ; switchFragments ( currentFragment ) ; } else { int currentFragment = Preferences . getCurrentFragment ( this ) ; int workingMode = Preferences . getWorkingMode ( this ) ; switchFragments ( workingMode == MODE_REMEMBER_LAST_MODE ? currentFragment : workingMode + <NUM_LIT> ) ; } handlePendingSharedText ( ) ; } } private void setCurrentFragment ( ) { Fragment fragment = getSupportFragmentManager ( ) . findFragmentById ( R . id . fragment_container ) ; if ( fragment instanceof aShellFragment ) { currentFragment = LOCAL_FRAGMENT ; } else if ( fragment instanceof otgShellFragment ) { currentFragment = OTG_FRAGMENT ; } } private void switchFragments ( int currentFragment ) { switch ( currentFragment ) { case LOCAL_FRAGMENT : mNav . setSelectedItemId ( R . id . nav_localShell ) ; replaceFragment ( new aShellFragment ( ) ) ; break ; case OTG_FRAGMENT : mNav . setSelectedItemId ( R . id . nav_otgShell ) ; replaceFragment ( new otgShellFragment ( ) ) ; break ; default : break ; } } public void onUsbDetached ( ) { onRequestReset ( ) ; } private void handleIncomingIntent ( Intent intent ) { if ( Intent . ACTION_SEND . equals ( intent . getAction ( ) ) && intent . hasExtra ( Intent . EXTRA_TEXT ) ) { String sharedText = intent . getStringExtra ( Intent . EXTRA_TEXT ) ; if ( sharedText != null ) { sharedText = sharedText . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; pendingSharedText = sharedText ; handleSharedTextIntent ( sharedText , intent ) ; } } else if ( intent . hasExtra ( \"<STR_LIT>\" ) ) { String useCommand = intent . getStringExtra ( \"<STR_LIT>\" ) ; handleUseCommandIntent ( useCommand , intent ) ; } else if ( \"<STR_LIT>\" . equals ( intent . getAction ( ) ) ) { onUsbDetached ( ) ; } } public String getPendingSharedText ( ) { return pendingSharedText ; } public void clearPendingSharedText ( ) { pendingSharedText = null ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; public class GetChannelResult implements Result { @ Nullable private String channel ; public GetChannelResult ( @ Nullable String channel ) { this . channel = channel ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , channel ) ;", "output": "return result ; } }"}, {"input": "package com . reactnative . overlay ; import android . app . Activity ; import androidx . annotation . NonNull ; import androidx . core . graphics . Insets ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import com . facebook . common . logging . FLog ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . bridge . JavaOnlyMap ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . bridge . ReactContextBaseJavaModule ; import com . facebook . react . bridge . ReactMethod ; import com . facebook . react . bridge . ReadableMap ; import com . facebook . react . bridge . UiThreadUtil ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import java . util . HashMap ; public class OverlayModule extends ReactContextBaseJavaModule implements LifecycleEventListener { private final HashMap < String , Overlay > overlays = new HashMap < > ( ) ; private final ReactApplicationContext reactContext ; private final ReactNativeHost reactNativeHost ; public OverlayModule ( ReactApplicationContext reactContext , ReactNativeHost reactNativeHost ) { super ( reactContext ) ; this . reactContext = reactContext ; this . reactNativeHost = reactNativeHost ; reactContext . addLifecycleEventListener ( this ) ; } @ Override public void invalidate ( ) { reactContext . removeLifecycleEventListener ( this ) ; final Activity activity = getCurrentActivity ( ) ; if ( activity == null || activity . isFinishing ( ) ) { return ; } UiThreadUtil . runOnUiThread ( this :: handleDestroy ) ; } private void handleDestroy ( ) { for ( String key : overlays . keySet ( ) ) {", "output": "Overlay overlay = overlays . get ( key ) ; overlay . hide ( ) ; } overlays . clear ( ) ; } @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ ReactMethod public void show ( final String moduleName , final ReadableMap options ) { UiThreadUtil . runOnUiThread ( ( ) -> { final Activity activity = getCurrentActivity ( ) ; if ( activity == null || activity . isFinishing ( ) ) { return ; } Overlay overlay = overlays . get ( moduleName ) ; if ( overlay != null ) { overlay . update ( ) ; return ; } int id = options . getInt ( \"<STR_LIT>\" ) ; WritableMap props = JavaOnlyMap . deepClone ( options ) ; props . putMap ( \"<STR_LIT>\" , getInsets ( activity ) ) ; overlay = new Overlay ( activity , moduleName , reactNativeHost . getReactInstanceManager ( ) ) ; overlay . show ( props , options ) ; overlays . put ( genOverlayKey ( moduleName , id ) , overlay ) ; } ) ; } @ ReactMethod public void hide ( String moduleName , int id ) { UiThreadUtil . runOnUiThread ( ( ) -> { Overlay overlay = overlays . get ( genOverlayKey ( moduleName , id ) ) ; if ( overlay == null ) { return ; } overlays . remove ( genOverlayKey ( moduleName , id ) ) ; overlay . hide ( ) ; } ) ; } @ Override public void onHostResume ( ) { } @ Override public void onHostPause ( ) { } @ Override public void onHostDestroy ( ) { FLog . i ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; handleDestroy ( ) ; } private String genOverlayKey ( String moduleName , int id ) { return moduleName + \"<STR_LIT>\" + id ; } private ReadableMap getInsets ( Activity activity ) { WindowInsetsCompat windowInsets = ViewCompat . getRootWindowInsets ( activity . getWindow ( ) . getDecorView ( ) ) ; assert windowInsets != null ; Insets navigationBarInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . navigationBars ( ) ) ; Insets statusBarInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . statusBars ( ) ) ; Insets displayCutoutInsets = windowInsets . getInsetsIgnoringVisibility ( WindowInsetsCompat . Type . displayCutout ( ) ) ; WritableMap insets = new JavaOnlyMap ( ) ; insets . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( Math . max ( navigationBarInsets . left , displayCutoutInsets . left ) ) ) ; insets . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( statusBarInsets . top ) ) ; insets . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( Math . max ( navigationBarInsets . right , displayCutoutInsets . right ) ) ) ; insets . putDouble ( \"<STR_LIT>\" , PixelUtil . toDIPFromPixel ( navigationBarInsets . bottom ) ) ; return insets ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . face . FaceDetectorOptions ; public class ProcessImageOptions { private InputImage inputImage ; @ FaceDetectorOptions . PerformanceMode private int performanceMode ; @ FaceDetectorOptions . LandmarkMode private int landmarkMode ; @ FaceDetectorOptions . ContourMode private int contourMode ; @ FaceDetectorOptions . ClassificationMode private int classificationMode ; private float minFaceSize ; private boolean enableTracking ; public ProcessImageOptions ( InputImage inputImage , @ FaceDetectorOptions . PerformanceMode int performanceMode , @ FaceDetectorOptions . LandmarkMode int landmarkMode , @ FaceDetectorOptions . ContourMode int contourMode , @ FaceDetectorOptions . ClassificationMode int classificationMode , float minFaceSize , boolean enableTracking ) { this . inputImage = inputImage ; this . performanceMode = performanceMode ; this . landmarkMode = landmarkMode ; this . contourMode = contourMode ; this . classificationMode = classificationMode ; this . minFaceSize = minFaceSize ; this . enableTracking = enableTracking ; } public InputImage getInputImage ( ) { return inputImage ; } public int getPerformanceMode ( ) { return performanceMode ; } public int getLandmarkMode ( ) { return landmarkMode ; } public int getContourMode ( ) {", "output": "return contourMode ; } public int getClassificationMode ( ) { return classificationMode ; } public float getMinFaceSize ( ) { return minFaceSize ; } public boolean isTrackingEnabled ( ) { return enableTracking ; } }"}, {"input": "package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; import java . util . Queue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicBoolean ; public class AdbStream implements Closeable { private AdbConnection adbConn ; private int localId ; private int remoteId ; private AtomicBoolean writeReady ; private Queue < byte [ ] > readQueue ; private boolean isClosed ; public AdbStream ( AdbConnection adbConn , int localId ) { this . adbConn = adbConn ; this . localId = localId ; this . readQueue = new ConcurrentLinkedQueue < byte [ ] > ( ) ; this . writeReady = new AtomicBoolean ( false ) ;", "output": "this . isClosed = false ; } void addPayload ( byte [ ] payload ) { synchronized ( readQueue ) { readQueue . add ( payload ) ; readQueue . notifyAll ( ) ; } } void sendReady ( ) throws IOException { adbConn . channel . writex ( AdbProtocol . generateReady ( localId , remoteId ) ) ; } void updateRemoteId ( int remoteId ) { this . remoteId = remoteId ; } void readyForWrite ( ) { writeReady . set ( true ) ; } void notifyClose ( ) { isClosed = true ; synchronized ( this ) { notifyAll ( ) ; } synchronized ( readQueue ) { readQueue . notifyAll ( ) ; } } public byte [ ] read ( ) throws InterruptedException , IOException { byte [ ] data = null ; synchronized ( readQueue ) { while ( ! isClosed && ( data = readQueue . poll ( ) ) == null ) { readQueue . wait ( ) ; } if ( isClosed ) { throw new IOException ( \"<STR_LIT>\" ) ; } } return data ; } public void write ( String payload ) throws IOException , InterruptedException { write ( ( payload + \"<STR_LIT>\" ) . getBytes ( \"<STR_LIT>\" ) ) ; } public void write ( byte [ ] payload ) throws IOException , InterruptedException { synchronized ( this ) { while ( ! isClosed && ! writeReady . compareAndSet ( true , false ) ) wait ( ) ; if ( isClosed ) { throw new IOException ( \"<STR_LIT>\" ) ; } } adbConn . channel . writex ( AdbProtocol . generateWrite ( localId , remoteId , payload ) ) ; } @ Override public void close ( ) throws IOException { synchronized ( this ) { if ( isClosed ) return ; notifyClose ( ) ; } adbConn . channel . writex ( AdbProtocol . generateClose ( localId , remoteId ) ) ; } public boolean isClosed ( ) { return isClosed ; } }"}, {"input": "package com . reactnativecommunity . webview ; import android . util . Log ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import android . view . ViewParent ; import android . widget . OverScroller ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . NestedScrollingChild3 ; import androidx . core . view . NestedScrollingChildHelper ; import androidx . core . view . ViewCompat ; import com . facebook . react . uimanager . ThemedReactContext ; public class RNCNestedScrollWebView extends RNCWebViewManager . RNCWebView implements NestedScrollingChild3 { public RNCNestedScrollWebView ( ThemedReactContext reactContext ) { super ( reactContext ) ; mChildHelper = new NestedScrollingChildHelper ( this ) ;", "output": "setNestedScrollingEnabled ( true ) ; initScrollView ( ) ; } private static final String TAG = \"<STR_LIT>\" ; private static final int INVALID_POINTER = - <NUM_LIT> ; private final int [ ] mScrollOffset = new int [ <NUM_LIT> ] ; private final int [ ] mScrollConsumed = new int [ <NUM_LIT> ] ; private int mLastMotionY ; private final NestedScrollingChildHelper mChildHelper ; private boolean mIsBeingDragged = false ; private VelocityTracker mVelocityTracker ; private int mTouchSlop ; private int mActivePointerId = INVALID_POINTER ; private int mNestedYOffset ; private OverScroller mScroller ; private int mMinimumVelocity ; private int mMaximumVelocity ; int mLastScrollerY = <NUM_LIT> ; private void initScrollView ( ) { mScroller = new OverScroller ( getContext ( ) , null ) ; final ViewConfiguration configuration = ViewConfiguration . get ( getContext ( ) ) ; mTouchSlop = configuration . getScaledTouchSlop ( ) ; mMinimumVelocity = configuration . getScaledMinimumFlingVelocity ( ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { initVelocityTrackerIfNotExists ( ) ; boolean consumedScrollEvent = false ; final int actionMasked = ev . getAction ( ) ; if ( actionMasked == MotionEvent . ACTION_DOWN ) { mNestedYOffset = <NUM_LIT> ; } MotionEvent vtev = MotionEvent . obtain ( ev ) ; vtev . offsetLocation ( <NUM_LIT> , mNestedYOffset ) ; switch ( actionMasked ) { case MotionEvent . ACTION_DOWN : { initOrResetVelocityTracker ( ) ; mIsBeingDragged = ! mScroller . isFinished ( ) ; if ( mIsBeingDragged ) { mScroller . abortAnimation ( ) ; final ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } } mLastMotionY = ( int ) ev . getY ( ) ; mActivePointerId = ev . getPointerId ( <NUM_LIT> ) ; if ( hasNestedScrollingParent ( ViewCompat . TYPE_NON_TOUCH ) ) { stopNestedScroll ( ViewCompat . TYPE_NON_TOUCH ) ; } startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL , ViewCompat . TYPE_TOUCH ) ; break ; } case MotionEvent . ACTION_MOVE : final int activePointerIndex = ev . findPointerIndex ( mActivePointerId ) ; if ( activePointerIndex == - <NUM_LIT> ) { Log . e ( TAG , \"<STR_LIT>\" + mActivePointerId + \"<STR_LIT>\" ) ; break ; } final int y = ( int ) ev . getY ( activePointerIndex ) ; int deltaY = mLastMotionY - y ; if ( ! mIsBeingDragged && Math . abs ( deltaY ) > mTouchSlop ) { final ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } mIsBeingDragged = true ; deltaY = deltaY > <NUM_LIT> ? deltaY - mTouchSlop : deltaY + mTouchSlop ; } if ( mIsBeingDragged ) { mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; if ( dispatchNestedPreScroll ( <NUM_LIT> , deltaY , mScrollConsumed , mScrollOffset ) ) { deltaY -= mScrollConsumed [ <NUM_LIT> ] ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; } mLastMotionY = y - mScrollOffset [ <NUM_LIT> ] ; final int oldScrollY = getScrollY ( ) ; final int range = getScrollRange ( ) ; if ( overScrollByCompat ( deltaY , oldScrollY , range ) && ! hasNestedScrollingParent ( ViewCompat . TYPE_TOUCH ) ) { mVelocityTracker . clear ( ) ; } final int scrolledDeltaY = getScrollY ( ) - oldScrollY ; final int unconsumedY = deltaY - scrolledDeltaY ; mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( <NUM_LIT> , scrolledDeltaY , <NUM_LIT> , unconsumedY , mScrollOffset , ViewCompat . TYPE_TOUCH , mScrollConsumed ) ; mLastMotionY -= mScrollOffset [ <NUM_LIT> ] ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; consumedScrollEvent = true ; } break ; case MotionEvent . ACTION_UP : final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( <NUM_LIT> , mMaximumVelocity ) ; int initialVelocity = ( int ) velocityTracker . getYVelocity ( mActivePointerId ) ; if ( Math . abs ( initialVelocity ) > mMinimumVelocity ) { flingWithNestedDispatch ( - initialVelocity ) ; } else if ( springBack ( getScrollY ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } mActivePointerId = INVALID_POINTER ; endDrag ( ) ; break ; case MotionEvent . ACTION_CANCEL : if ( mIsBeingDragged && springBack ( getScrollY ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } mActivePointerId = INVALID_POINTER ; endDrag ( ) ; break ; case MotionEvent . ACTION_POINTER_DOWN : { final int index = ev . getActionIndex ( ) ; mLastMotionY = ( int ) ev . getY ( index ) ; mActivePointerId = ev . getPointerId ( index ) ; break ; } case MotionEvent . ACTION_POINTER_UP : onSecondaryPointerUp ( ev ) ; mLastMotionY = ( int ) ev . getY ( ev . findPointerIndex ( mActivePointerId ) ) ; break ; } if ( mVelocityTracker != null ) { mVelocityTracker . addMovement ( vtev ) ; } vtev . recycle ( ) ; if ( consumedScrollEvent ) { ev . setAction ( MotionEvent . ACTION_CANCEL ) ; } return super . onTouchEvent ( ev ) ; } boolean overScrollByCompat ( int deltaY , int scrollY , int scrollRangeY ) { final int top = <NUM_LIT> ; int newScrollY = scrollY + deltaY ; boolean clampedY = false ; if ( newScrollY > scrollRangeY ) { newScrollY = scrollRangeY ; clampedY = true ; } else if ( newScrollY < top ) { newScrollY = top ; clampedY = true ; } if ( clampedY && ! hasNestedScrollingParent ( ViewCompat . TYPE_NON_TOUCH ) ) { springBack ( newScrollY ) ; } onOverScrolled ( <NUM_LIT> , newScrollY , false , clampedY ) ; return clampedY ; } boolean springBack ( int startY ) { return mScroller . springBack ( <NUM_LIT> , startY , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , getScrollRange ( ) ) ; } int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } private void endDrag ( ) { mIsBeingDragged = false ; recycleVelocityTracker ( ) ; stopNestedScroll ( ViewCompat . TYPE_TOUCH ) ; } private void onSecondaryPointerUp ( MotionEvent ev ) { final int pointerIndex = ( ev . getAction ( ) & MotionEvent . ACTION_POINTER_INDEX_MASK ) > > MotionEvent . ACTION_POINTER_INDEX_SHIFT ; final int pointerId = ev . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; mLastMotionY = ( int ) ev . getY ( newPointerIndex ) ; mActivePointerId = ev . getPointerId ( newPointerIndex ) ; if ( mVelocityTracker != null ) { mVelocityTracker . clear ( ) ; } } } private void initOrResetVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void initVelocityTrackerIfNotExists ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } } private void recycleVelocityTracker ( ) { if ( mVelocityTracker != null ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } } private void flingWithNestedDispatch ( int velocityY ) { final int scrollY = getScrollY ( ) ; final boolean canFling = ( scrollY > <NUM_LIT> || velocityY > <NUM_LIT> ) && ( scrollY < getScrollRange ( ) || velocityY < <NUM_LIT> ) ; if ( ! dispatchNestedPreFling ( <NUM_LIT> , velocityY ) ) { dispatchNestedFling ( <NUM_LIT> , velocityY , canFling ) ; fling ( velocityY ) ; } } public void fling ( int velocityY ) { startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL , ViewCompat . TYPE_NON_TOUCH ) ; mScroller . fling ( getScrollX ( ) , getScrollY ( ) , <NUM_LIT> , velocityY , <NUM_LIT> , <NUM_LIT> , Integer . MIN_VALUE , Integer . MAX_VALUE , <NUM_LIT> , <NUM_LIT> ) ; mLastScrollerY = getScrollY ( ) ; ViewCompat . postInvalidateOnAnimation ( this ) ; } @ Override public void computeScroll ( ) { if ( nestedScrollEnabled ) { super . computeScroll ( ) ; return ; } if ( mScroller . isFinished ( ) ) { return ; } if ( mScroller . computeScrollOffset ( ) ) { final int y = mScroller . getCurrY ( ) ; int unconsumed = y - mLastScrollerY ; mLastScrollerY = y ; if ( unconsumed != <NUM_LIT> ) { mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedPreScroll ( <NUM_LIT> , unconsumed , mScrollConsumed , mScrollOffset , ViewCompat . TYPE_NON_TOUCH ) ; unconsumed -= mScrollConsumed [ <NUM_LIT> ] ; final int oldScrollY = getScrollY ( ) ; final int range = getScrollRange ( ) ; overScrollByCompat ( unconsumed , oldScrollY , range ) ; final int consumedByScroll = getScrollY ( ) - oldScrollY ; unconsumed -= consumedByScroll ; mScrollConsumed [ <NUM_LIT> ] = <NUM_LIT> ; dispatchNestedScroll ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , unconsumed , mScrollOffset , ViewCompat . TYPE_NON_TOUCH , mScrollConsumed ) ; mNestedYOffset += mScrollOffset [ <NUM_LIT> ] ; unconsumed -= mScrollConsumed [ <NUM_LIT> ] ; } boolean isScrollFinish = mScroller . isFinished ( ) || unconsumed != <NUM_LIT> ; if ( ! isScrollFinish ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } else { mScroller . forceFinished ( true ) ; stopNestedScroll ( ViewCompat . TYPE_NON_TOUCH ) ; } } } @ Override public boolean isNestedScrollingEnabled ( ) { return mChildHelper . isNestedScrollingEnabled ( ) ; } @ Override public int getNestedScrollAxes ( ) { return ViewCompat . SCROLL_AXIS_NONE ; } @ Override public void setNestedScrollingEnabled ( boolean enabled ) { mChildHelper . setNestedScrollingEnabled ( enabled ) ; } @ Override public boolean startNestedScroll ( int axes ) { return mChildHelper . startNestedScroll ( axes ) ; } @ Override public boolean startNestedScroll ( int axes , int type ) { return mChildHelper . startNestedScroll ( axes , type ) ; } @ Override public void stopNestedScroll ( ) { mChildHelper . stopNestedScroll ( ) ; } @ Override public void stopNestedScroll ( int type ) { mChildHelper . stopNestedScroll ( type ) ; } @ Override public boolean hasNestedScrollingParent ( ) { return mChildHelper . hasNestedScrollingParent ( ) ; } @ Override public boolean hasNestedScrollingParent ( int type ) { return mChildHelper . hasNestedScrollingParent ( type ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , int [ ] consumed , int [ ] offsetInWindow ) { return mChildHelper . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedPreScroll ( int dx , int dy , @ Nullable int [ ] consumed , @ Nullable int [ ] offsetInWindow , int type ) { return mChildHelper . dispatchNestedPreScroll ( dx , dy , consumed , offsetInWindow , type ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int [ ] offsetInWindow ) { return mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow ) ; } @ Override public boolean dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , @ Nullable int [ ] offsetInWindow , int type ) { return mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type ) ; } @ Override public void dispatchNestedScroll ( int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , @ Nullable int [ ] offsetInWindow , int type , @ NonNull int [ ] consumed ) { mChildHelper . dispatchNestedScroll ( dxConsumed , dyConsumed , dxUnconsumed , dyUnconsumed , offsetInWindow , type , consumed ) ; } @ Override public boolean dispatchNestedPreFling ( float velocityX , float velocityY ) { return mChildHelper . dispatchNestedPreFling ( velocityX , velocityY ) ; } @ Override public boolean dispatchNestedFling ( float velocityX , float velocityY , boolean consumed ) { return mChildHelper . dispatchNestedFling ( velocityX , velocityY , consumed ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; import android . util . Log ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . Date ; import java . util . Locale ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class DatetimePickerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_MODE_INVALID = \"<STR_LIT>\" ; public static final String ERROR_PICKER_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PICKER_DISMISSED = \"<STR_LIT>\" ; public static final String ERROR_CODE_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_CODE_DISMISSED = \"<STR_LIT>\" ; private DatetimePicker implementation ; public void load ( ) { DatetimePickerConfig config = getDatetimePickerConfig ( ) ; implementation = new DatetimePicker ( this , config ) ; } @ PluginMethod public void present ( PluginCall call ) { try {", "output": "String format = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String localeString = call . getString ( \"<STR_LIT>\" ) ; String max = call . getString ( \"<STR_LIT>\" ) ; String min = call . getString ( \"<STR_LIT>\" ) ; String mode = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String theme = call . getString ( \"<STR_LIT>\" ) ; String value = call . getString ( \"<STR_LIT>\" ) ; String cancelButtonText = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String doneButtonText = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String androidTimePickerModeText = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String androidDatePickerModeText = call . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; AndroidDatePickerMode androidDatePickerMode = null ; if ( androidDatePickerModeText != null ) { androidDatePickerMode = DatetimePickerHelper . convertStringToDatePickerMode ( androidDatePickerModeText ) ; } AndroidTimePickerMode androidTimePickerMode = null ; if ( androidTimePickerModeText != null ) { androidTimePickerMode = DatetimePickerHelper . convertStringToTimePickerMode ( androidTimePickerModeText ) ; } Locale locale = null ; if ( localeString != null ) { locale = DatetimePickerHelper . convertStringToLocale ( localeString ) ; } Date date = new Date ( ) ; if ( value != null ) { date = DatetimePickerHelper . convertStringToDate ( format , value ) ; } Date minDate = null ; if ( min != null ) { minDate = DatetimePickerHelper . convertStringToDate ( format , min ) ; } Date maxDate = null ; if ( max != null ) { maxDate = DatetimePickerHelper . convertStringToDate ( format , max ) ; } PresentResultCallback resultCallback = new PresentResultCallback ( ) ; resultCallback . setSuccessListener ( selectedDate -> { String dateAsString = DatetimePickerHelper . convertDateToString ( format , selectedDate ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , dateAsString ) ; call . resolve ( result ) ; } ) ; resultCallback . setCancelListener ( ( ) -> call . reject ( ERROR_PICKER_CANCELED , ERROR_CODE_CANCELED ) ) ; resultCallback . setDismissListener ( ( ) -> call . reject ( ERROR_PICKER_DISMISSED , ERROR_CODE_DISMISSED ) ) ; if ( mode . equals ( \"<STR_LIT>\" ) ) { implementation . presentDateTimePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else if ( mode . equals ( \"<STR_LIT>\" ) ) { implementation . presentDatePicker ( date , minDate , maxDate , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else if ( mode . equals ( \"<STR_LIT>\" ) ) { implementation . presentTimePicker ( date , locale , cancelButtonText , doneButtonText , theme , resultCallback , androidDatePickerMode , androidTimePickerMode ) ; } else { call . reject ( ERROR_MODE_INVALID ) ; } } catch ( Exception ex ) { String message = ex . getLocalizedMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } private DatetimePickerConfig getDatetimePickerConfig ( ) { DatetimePickerConfig config = new DatetimePickerConfig ( ) ; String theme = getConfig ( ) . getString ( \"<STR_LIT>\" ) ; config . setTheme ( theme , config . getTheme ( ) ) ; return config ; } }"}, {"input": "package de . robv . android . xposed ; import android . os . Environment ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . security . DigestException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . zip . Adler32 ; import static de . robv . android . xposed . XposedHelpers . inputStreamToByteArray ; class DexCreator { public static File DALVIK_CACHE = new File ( Environment . getDataDirectory ( ) , \"<STR_LIT>\" ) ; public static File getDefaultFile ( String childClz ) { return new File ( DALVIK_CACHE , \"<STR_LIT>\" + childClz . substring ( childClz . lastIndexOf ( '<STR_LIT>' ) + <NUM_LIT> ) + \"<STR_LIT>\" ) ; } public static File ensure ( String clz , Class < ? > realSuperClz , Class < ? > topClz ) throws IOException { if ( ! topClz . isAssignableFrom ( realSuperClz ) ) { throw new ClassCastException ( \"<STR_LIT>\" + clz + \"<STR_LIT>\" + realSuperClz + \"<STR_LIT>\" + topClz ) ; } try { return ensure ( \"<STR_LIT>\" + clz + \"<STR_LIT>\" , realSuperClz ) ; } catch ( IOException e ) { throw new IOException ( \"<STR_LIT>\" + clz , e ) ; } } public static File ensure ( String childClz , Class < ? > superClz ) throws IOException { return ensure ( getDefaultFile ( childClz ) , childClz , superClz . getName ( ) ) ; } public static File ensure ( File file , String childClz , String superClz ) throws IOException { try { byte [ ] dex = inputStreamToByteArray ( new FileInputStream ( file ) ) ; if ( matches ( dex , childClz , superClz ) ) { return file ; } else { file . delete ( ) ; } } catch ( IOException e ) { file . delete ( ) ; } byte [ ] dex = create ( childClz , superClz ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( dex ) ; fos . close ( ) ; return file ; } public static boolean matches ( byte [ ] dex , String childClz , String superClz ) throws IOException { boolean childFirst = childClz . compareTo ( superClz ) < <NUM_LIT> ; byte [ ] childBytes = stringToBytes ( \"<STR_LIT>\" + childClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + \"<STR_LIT>\" ) ; byte [ ] superBytes = stringToBytes ( \"<STR_LIT>\" + superClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + \"<STR_LIT>\" ) ; int pos = <NUM_LIT> ; if ( pos + childBytes . length + superBytes . length >= dex . length ) { return false ; } for ( byte b : childFirst ? childBytes : superBytes ) { if ( dex [ pos ++ ] != b ) { return false ; } } for ( byte b : childFirst ? superBytes : childBytes ) { if ( dex [ pos ++ ] != b ) { return false ; } } return true ; } public static byte [ ] create ( String childClz , String superClz ) throws IOException { boolean childFirst = childClz . compareTo ( superClz ) < <NUM_LIT> ; byte [ ] childBytes = stringToBytes ( \"<STR_LIT>\" + childClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + \"<STR_LIT>\" ) ; byte [ ] superBytes = stringToBytes ( \"<STR_LIT>\" + superClz . replace ( '<STR_LIT>' , '<STR_LIT>' ) + \"<STR_LIT>\" ) ; int stringsSize = childBytes . length + superBytes . length ; int padding = - stringsSize & <NUM_LIT> ; stringsSize += padding ;", "output": "ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; out . write ( \"<STR_LIT>\" . getBytes ( ) ) ; out . write ( new byte [ <NUM_LIT> ] ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + stringsSize ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> + ( childFirst ? childBytes . length : superBytes . length ) ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , childFirst ? <NUM_LIT> : <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , childFirst ? <NUM_LIT> : <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , - <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; out . write ( childFirst ? childBytes : superBytes ) ; out . write ( childFirst ? superBytes : childBytes ) ; out . write ( new byte [ padding ] ) ; writeInt ( out , <NUM_LIT> ) ; writeInt ( out , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> + stringsSize ) ; writeMapItem ( out , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> + stringsSize ) ; byte [ ] buf = out . toByteArray ( ) ; updateSignature ( buf ) ; updateChecksum ( buf ) ; return buf ; } private static void updateSignature ( byte [ ] dex ) { try { MessageDigest md = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; md . update ( dex , <NUM_LIT> , dex . length - <NUM_LIT> ) ; md . digest ( dex , <NUM_LIT> , <NUM_LIT> ) ; } catch ( NoSuchAlgorithmException | DigestException e ) { throw new RuntimeException ( e ) ; } } private static void updateChecksum ( byte [ ] dex ) { Adler32 a32 = new Adler32 ( ) ; a32 . update ( dex , <NUM_LIT> , dex . length - <NUM_LIT> ) ; int chksum = ( int ) a32 . getValue ( ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; dex [ <NUM_LIT> ] = ( byte ) ( chksum > > <NUM_LIT> & <NUM_LIT> ) ; } private static void writeUleb128 ( OutputStream out , int value ) throws IOException { while ( value > <NUM_LIT> ) { out . write ( ( value & <NUM_LIT> ) | <NUM_LIT> ) ; value >>>= <NUM_LIT> ; } out . write ( value ) ; } private static void writeInt ( OutputStream out , int value ) throws IOException { out . write ( value ) ; out . write ( value > > <NUM_LIT> ) ; out . write ( value > > <NUM_LIT> ) ; out . write ( value > > <NUM_LIT> ) ; } private static void writeMapItem ( OutputStream out , int type , int count , int offset ) throws IOException { writeInt ( out , type ) ; writeInt ( out , count ) ; writeInt ( out , offset ) ; } private static byte [ ] stringToBytes ( String s ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; writeUleb128 ( bytes , s . length ( ) ) ; bytes . write ( s . getBytes ( \"<STR_LIT>\" ) ) ; bytes . write ( <NUM_LIT> ) ; return bytes . toByteArray ( ) ; } private DexCreator ( ) { } }"}, {"input": "package com . wmods . wppenhacer ; import android . Manifest ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import android . os . Environment ; import android . view . Menu ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . Fragment ; import androidx . viewpager2 . widget . ViewPager2 ; import com . google . android . material . navigation . NavigationBarView ; import com . wmods . wppenhacer . activities . AboutActivity ; import com . wmods . wppenhacer . adapter . MainPagerAdapter ; import com . wmods . wppenhacer . databinding . ActivityMainBinding ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; public class MainActivity extends AppCompatActivity { private ActivityMainBinding binding ; public static File mainDir ; @ Override protected void onCreate ( Bundle savedInstanceState ) { setTheme ( R . style . AppTheme ) ; getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; App . changeLanguage ( this ) ; super . onCreate ( savedInstanceState ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayShowHomeEnabled ( true ) ; getSupportActionBar ( ) . setIcon ( R . mipmap . launcher ) ; } binding = ActivityMainBinding . inflate ( getLayoutInflater ( ) ) ; setContentView ( binding . getRoot ( ) ) ; MainPagerAdapter pagerAdapter = new MainPagerAdapter ( this ) ; binding . viewPager . setAdapter ( pagerAdapter ) ; binding . navView . setOnItemSelectedListener ( new NavigationBarView . OnItemSelectedListener ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override public boolean onNavigationItemSelected ( @ NonNull MenuItem item ) { return switch ( item . getItemId ( ) ) { case R . id . navigation_home -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_chat -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_privacy -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } case R . id . navigation_media -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; }", "output": "case R . id . navigation_colors -> { binding . viewPager . setCurrentItem ( <NUM_LIT> ) ; yield true ; } default -> false ; } ; } } ) ; binding . viewPager . registerOnPageChangeCallback ( new ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageSelected ( int position ) { super . onPageSelected ( position ) ; binding . navView . getMenu ( ) . getItem ( position ) . setChecked ( true ) ; } } ) ; setupPermissions ( ) ; createMainDir ( ) ; FilePicker . registerFilePicker ( this ) ; } private void setupPermissions ( ) { ArrayList < String > permissions = new ArrayList < > ( ) ; if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_MEDIA_IMAGES ) != PackageManager . PERMISSION_GRANTED && Build . VERSION . SDK_INT >= Build . VERSION_CODES . TIRAMISU ) { permissions . add ( Manifest . permission . READ_MEDIA_IMAGES ) ; } if ( ContextCompat . checkSelfPermission ( this , Manifest . permission . READ_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { permissions . add ( Manifest . permission . READ_EXTERNAL_STORAGE ) ; } if ( ! permissions . isEmpty ( ) ) { ActivityCompat . requestPermissions ( this , permissions . toArray ( new String [ <NUM_LIT> ] ) , <NUM_LIT> ) ; } } private void createMainDir ( ) { mainDir = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DOWNLOADS ) , \"<STR_LIT>\" ) ; if ( ! mainDir . exists ( ) ) { mainDir . mkdir ( ) ; } var nomedia = new File ( mainDir , \"<STR_LIT>\" ) ; if ( ! nomedia . exists ( ) ) { try { nomedia . createNewFile ( ) ; } catch ( IOException ignored ) { } } } @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; for ( Fragment fragment : getSupportFragmentManager ( ) . getFragments ( ) ) { fragment . onActivityResult ( requestCode , resultCode , data ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . header_menu , menu ) ; return true ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { if ( item . getItemId ( ) == R . id . menu_about ) { startActivity ( new Intent ( this , AboutActivity . class ) ) ; return true ; } return super . onOptionsItemSelected ( item ) ; } public static boolean isXposedEnabled ( ) { return false ; } }"}, {"input": "package com . simon . harmonichackernews . data ; public class RepoInfo { public String name ; public String owner ; public String about ; public String website ; public String license ; public String language ; public int stars ; public int watching ; public int forks ; public String formatStars ( ) { if ( stars == <NUM_LIT> ) { return \"<STR_LIT>\" ; } return kFormat ( stars ) + \"<STR_LIT>\" ; } public String formatWatching ( ) { return kFormat ( watching ) + \"<STR_LIT>\" ; } public String formatForks ( ) { if ( forks == <NUM_LIT> ) { return \"<STR_LIT>\" ; } return kFormat ( forks ) + \"<STR_LIT>\" ; } public String getShortenedUrl ( ) { if ( website == null ) { return null ; } if ( website . startsWith ( \"<STR_LIT>\" ) ) { website = website . substring ( <NUM_LIT> ) ; } else if ( website . startsWith ( \"<STR_LIT>\" ) ) { website = website . substring ( <NUM_LIT> ) ; } if ( website . startsWith ( \"<STR_LIT>\" ) ) { website = website . substring ( <NUM_LIT> ) ; } return website ;", "output": "} public String kFormat ( int number ) { if ( number < <NUM_LIT> ) { return String . valueOf ( number ) ; } else { double rounded = Math . round ( ( double ) number / <NUM_LIT> ) * <NUM_LIT> ; String result = String . format ( \"<STR_LIT>\" , rounded / <NUM_LIT> ) ; if ( result . endsWith ( \"<STR_LIT>\" ) ) { return result . substring ( <NUM_LIT> , result . length ( ) - <NUM_LIT> ) + \"<STR_LIT>\" ; } return result ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog . listener ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public interface IRecogListener { void onAsrReady ( ) ; void onAsrBegin ( ) ; void onAsrEnd ( ) ;", "output": "void onAsrPartialResult ( String [ ] results , RecogResult recogResult ) ; void onAsrOnlineNluResult ( String nluResult ) ; void onAsrFinalResult ( String [ ] results , RecogResult recogResult ) ; void onAsrFinish ( RecogResult recogResult ) ; void onAsrFinishError ( int errorCode , int subErrorCode , String descMessage , RecogResult recogResult ) ; void onAsrLongFinish ( ) ; void onAsrVolume ( int volumePercent , int volume ) ; void onAsrAudio ( byte [ ] data , int offset , int length ) ; void onAsrExit ( ) ; void onOfflineLoaded ( ) ; void onOfflineUnLoaded ( ) ; }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . bean ; public class TransferredBytesInfo { protected long usbReceiveBytes ; protected long usbSentBytes ; protected long wifiReceiveBytes ; protected long wifiSentBytes ; public TransferredBytesInfo ( long usbReceiveBytes , long usbSentBytes , long wifiReceiveBytes , long wifiSentBytes ) { this . usbReceiveBytes = usbReceiveBytes ; this . usbSentBytes = usbSentBytes ; this . wifiReceiveBytes = wifiReceiveBytes ; this . wifiSentBytes = wifiSentBytes ; } public long getUsbReceiveBytes ( ) { return usbReceiveBytes ;", "output": "} public long getUsbSentBytes ( ) { return usbSentBytes ; } public long getWifiReceiveBytes ( ) { return wifiReceiveBytes ; } public long getWifiSentBytes ( ) { return wifiSentBytes ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Handler ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuPresenter ; public class DialogDanmakuCheckWorker { private Context context ; private Handler handler ; private DanmakuPresenter danmakuPresenter ; private OnExitListener exitListener ; public DialogDanmakuCheckWorker ( Context context , Handler handler , DanmakuPresenter danmakuPresenter , OnExitListener exitListener ) { this . context = context ; this . handler = handler ; this . danmakuPresenter = danmakuPresenter ; this . exitListener = exitListener ; } public void startCheckDanmaku ( long oid , long dmid , String content , String accessKey , long avid ) { ProgressDialog progressDialog = DialogUtil . newProgressDialog ( context , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; progressDialog . setCancelable ( false ) ; progressDialog . show ( ) ; danmakuPresenter . checkDanmaku ( oid , dmid , content , accessKey , avid , new DanmakuPresenter . CheckDanmakuCallBack ( ) { @ Override public void onSleeping ( long waitTime ) { progressDialog . setMessage ( \"<STR_LIT>\" + waitTime + \"<STR_LIT>\" ) ; } @ Override public void onGettingHasAccountDMList ( ) { progressDialog . setMessage ( \"<STR_LIT>\" ) ; } @ Override public void onGettingNoAccountDMList ( ) { progressDialog . setMessage ( \"<STR_LIT>\" ) ; } @ Override public void thenOk ( ) { progressDialog . dismiss ( ) ; showCheckResult ( \"<STR_LIT>\" + CommentUtil . subComment ( content , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } @ Override public void thenDeleted ( ) { progressDialog . dismiss ( ) ; showCheckResult ( \"<STR_LIT>\" + CommentUtil . subComment ( content , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } @ Override public void thenShadowBan ( ) { progressDialog . dismiss ( ) ; showCheckResult ( \"<STR_LIT>\" + CommentUtil . subComment ( content , <NUM_LIT> ) + \"<STR_LIT>\" ) ; } @ Override public void onNetworkError ( Throwable th ) { progressDialog . dismiss ( ) ; } } ) ; } private void showCheckResult ( String message ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( message ) . setCancelable ( false ) . setNegativeButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { exitListener . exit ( ) ; }", "output": "} ) . show ( ) ; } }"}, {"input": "package com . reactnative . pulltorefresh ; public interface OnRefreshChangeListener { void onRefresh ( ) ;", "output": "void onOffsetChange ( int offset ) ; void onStateChanged ( PullToRefreshState state ) ; }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import com . unfbx . chatgpt . OpenAiClient ; import com . unfbx . chatgpt . entity . whisper . WhisperResponse ; import java . io . File ; import java . util . Arrays ; import okhttp3 . ConnectionSpec ; import okhttp3 . OkHttpClient ; public class WhisperApiClient { String url = \"<STR_LIT>\" ; String apiKey = \"<STR_LIT>\" ; OkHttpClient httpClient = null ; OpenAiClient chatGPT = null ; Context context = null ; public WhisperApiClient ( Context context , String url , String apiKey ) { this . context = context ; httpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . readTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . writeTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . connectionSpecs ( Arrays . asList ( ConnectionSpec . CLEARTEXT , ConnectionSpec . COMPATIBLE_TLS ) ) . build ( ) ;", "output": "setApiInfo ( url , apiKey ) ; } public void setApiInfo ( String url , String apiKey ) { if ( this . url . equals ( url ) && this . apiKey . equals ( apiKey ) ) { return ; } this . url = url ; this . apiKey = apiKey ; chatGPT = new OpenAiClient . Builder ( ) . apiKey ( Arrays . asList ( apiKey ) ) . apiHost ( url ) . okHttpClient ( httpClient ) . build ( ) ; } public String getWhisperResult ( File file ) throws Exception { if ( chatGPT == null ) { throw new Exception ( context . getString ( R . string . text_whisper_param_error ) ) ; } WhisperResponse whisperResponse = chatGPT . speechToTextTranscriptions ( file ) ; return whisperResponse . getText ( ) ; } }"}, {"input": "package org . woheller69 . weather . weather_api ; import com . android . volley . VolleyError ; public interface IProcessHttpRequest {", "output": "void processSuccessScenario ( String response , int cityId ) ; void processFailScenario ( VolleyError error ) ; }"}, {"input": "package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . ApksUtils ; import com . norman . webviewup . lib . util . FileUtils ; public abstract class UpgradePathSource extends UpgradeSource { private static final String PREFERENCE_NAME = \"<STR_LIT>\" ; private final SharedPreferences sharedPreferences ; private final String libsPath ; private final String path ; public UpgradePathSource ( @ NonNull Context context , String path ) { super ( context ) ; this . path = path ; this . libsPath = path + \"<STR_LIT>\" ; this . sharedPreferences = context . getSharedPreferences ( PREFERENCE_NAME , Context . MODE_PRIVATE ) ; } public synchronized void delete ( ) { this . sharedPreferences . edit ( ) . remove ( this . path ) . commit ( ) ; FileUtils . delete ( path ) ; FileUtils . delete ( this . libsPath ) ; } public String getApkPath ( ) { return path ; } public String getLibsPath ( ) { return libsPath ; } @ Override protected void onSuccess ( ) { super . onSuccess ( ) ; ApksUtils . extractNativeLibrary ( path , libsPath ) ; sharedPreferences . edit ( ) . putBoolean ( getApkPath ( ) , true ) . commit ( ) ; } @ Override public synchronized boolean isSuccess ( ) { if ( super . isSuccess ( ) ) { return true ; } if ( sharedPreferences . getBoolean ( getApkPath ( ) , false ) ) { if ( FileUtils . isNotEmpty ( getApkPath ( ) ) ) { success ( ) ; return true ; } sharedPreferences . edit ( ) . putBoolean ( getApkPath ( ) , false ) . commit ( ) ; } return false ; }", "output": "}"}, {"input": "package com . wmods . wppenhacer . views ; import static de . robv . android . xposed . XposedBridge . log ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . view . WindowManager ; import android . widget . FrameLayout ; import android . widget . ImageView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . core . WppCore ; import java . io . File ; import java . io . FileOutputStream ; import java . util . Properties ; import de . robv . android . xposed . XSharedPreferences ; @ SuppressLint ( \"<STR_LIT>\" ) public class WallpaperView extends FrameLayout { private final XSharedPreferences prefs ; private final Properties properties ; public WallpaperView ( @ NonNull Context context , XSharedPreferences preferences , Properties properties ) { super ( context ) ; this . prefs = preferences ; this . properties = properties ; init ( context ) ; } private void init ( Context context ) { ImageView bgView = new ImageView ( context ) ; bgView . setLayoutParams ( new FrameLayout . LayoutParams ( FrameLayout . LayoutParams . MATCH_PARENT , FrameLayout . LayoutParams . MATCH_PARENT ) ) ; bgView . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; bgView . setAdjustViewBounds ( false ) ; try { String image = ThemePreference . rootDirectory . getAbsolutePath ( ) + \"<STR_LIT>\" + prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + properties . getProperty ( \"<STR_LIT>\" ) ; if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { image = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } Drawable drawable = getDrawableImage ( image ) ; bgView . setImageDrawable ( drawable ) ; addView ( bgView ) ; } catch ( Exception e ) { log ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } private Drawable getDrawableImage ( String imagePath ) throws Exception { var fileOut = getContext ( ) . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" ; var file = new File ( imagePath ) ; if ( ! file . exists ( ) ) return null ; String filePath = file . getAbsolutePath ( ) ; long lastModified = file . lastModified ( ) ; String cacheKey = filePath + \"<STR_LIT>\" + lastModified ; String cachedData = WppCore . getPrivString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( cacheKey . equals ( cachedData ) && new File ( fileOut ) . exists ( ) ) { Bitmap bitmap = BitmapFactory . decodeFile ( fileOut ) ; return new BitmapDrawable ( getResources ( ) , bitmap ) ; } Bitmap bitmap = BitmapFactory . decodeFile ( imagePath ) ; DisplayMetrics displayMetrics = new DisplayMetrics ( ) ; var windowManager = ( WindowManager ) getContext ( ) . getSystemService ( Context . WINDOW_SERVICE ) ; windowManager . getDefaultDisplay ( ) . getMetrics ( displayMetrics ) ; int width = displayMetrics . widthPixels ; int height = displayMetrics . heightPixels ;", "output": "var scaledBitmap = Bitmap . createScaledBitmap ( bitmap , width , height , true ) ; try ( var outputStream = new FileOutputStream ( fileOut ) ) { scaledBitmap . compress ( Bitmap . CompressFormat . JPEG , <NUM_LIT> , outputStream ) ; outputStream . flush ( ) ; } WppCore . setPrivString ( \"<STR_LIT>\" , cacheKey ) ; bitmap . recycle ( ) ; return new BitmapDrawable ( getResources ( ) , scaledBitmap ) ; } }"}, {"input": "package org . woheller69 . weather . database ; import android . content . Context ; public class QuarterHourlyForecast { private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float windSpeed ; private float windDirection ; private float precipitation ; public QuarterHourlyForecast ( ) { } public float getWindDirection ( ) { return windDirection ; } public void setWindDirection ( float windDirection ) { this . windDirection = windDirection ; } public float getWindSpeed ( ) { return windSpeed ; } public void setWindSpeed ( float speed ) { this . windSpeed = speed ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; } public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ;", "output": "} public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . os . BaseBundle ; import android . os . Message ; import android . text . TextUtils ; import android . view . GestureDetector ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . listeners . DoubleTapListener ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . AnimationUtil ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Others extends Feature { public static HashMap < Integer , Boolean > propsBoolean = new HashMap < > ( ) ; public static HashMap < Integer , Integer > propsInteger = new HashMap < > ( ) ; private Properties properties ; public Others ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var novoTema = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var menuWIcons = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var newSettings = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var filterChats = prefs . getString ( \"<STR_LIT>\" , null ) ; var strokeButtons = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var outlinedIcons = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var showDnd = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var showFreezeLastSeen = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var filterSeen = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var fbstyle = Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var metaai = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var topnav = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var proximity = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var showOnline = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var floatingMenu = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var filter_items = prefs . getString ( \"<STR_LIT>\" , null ) ; var disable_defemojis = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var autonext_status = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var audio_type = Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var audio_transcription = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var oldStatus = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var igstatus = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var verticalStatus = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var animationEmojis = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; propsInteger . put ( <NUM_LIT> , oldStatus ? igstatus ? <NUM_LIT> : <NUM_LIT> : <NUM_LIT> ) ; propsBoolean . put ( <NUM_LIT> , filterSeen ) ; propsBoolean . put ( <NUM_LIT> , novoTema ) ; propsBoolean . put ( <NUM_LIT> , menuWIcons ) ; propsBoolean . put ( <NUM_LIT> , newSettings ) ; propsBoolean . put ( <NUM_LIT> , Objects . equals ( filterChats , \"<STR_LIT>\" ) ) ; propsBoolean . put ( <NUM_LIT> , strokeButtons ) ; propsBoolean . put ( <NUM_LIT> , outlinedIcons ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , ! topnav ) ; propsBoolean . put ( <NUM_LIT> , floatingMenu ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , animationEmojis ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; if ( metaai ) { propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; propsBoolean . put ( <NUM_LIT> , false ) ; } if ( audio_transcription ) { Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; Others . propsBoolean . put ( <NUM_LIT> , true ) ; } if ( verticalStatus ) { propsBoolean . put ( <NUM_LIT> , true ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; propsInteger . put ( <NUM_LIT> , <NUM_LIT> ) ; } else { propsInteger . put ( <NUM_LIT> , fbstyle ) ; propsInteger . put ( <NUM_LIT> , fbstyle ) ; } hookProps ( ) ; hookMenuOptions ( newSettings , showFreezeLastSeen , showDnd , filterChats ) ; if ( proximity ) { var proximitySensorMethod = Unobfuscator . loadProximitySensorMethod ( classLoader ) ; XposedBridge . hookMethod ( proximitySensorMethod , XC_MethodReplacement . DO_NOTHING ) ; } if ( filter_items != null && prefs . getBoolean ( \"<STR_LIT>\" , true ) ) { filterItems ( filter_items ) ; } if ( disable_defemojis ) { disable_defEmojis ( ) ; } if ( autonext_status ) { autoNextStatus ( ) ; } if ( audio_type > <NUM_LIT> ) { sendAudioType ( audio_type ) ; } customPlayBackSpeed ( ) ; showOnline ( showOnline ) ; animationList ( ) ; stampCopiedMessage ( ) ; doubleTapReaction ( ) ; } private void doubleTapReaction ( ) throws Exception { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( View ) param . thisObject ; if ( viewGroup == null ) return ; var gestureDetector = new GestureDetector ( viewGroup . getContext ( ) , new DoubleTapListener ( ( ) -> { var reactionView = ( ViewGroup ) viewGroup . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( reactionView != null && reactionView . getVisibility ( ) == View . VISIBLE ) { for ( int i = <NUM_LIT> ; i < reactionView . getChildCount ( ) ; i ++ ) { if ( reactionView . getChildAt ( i ) instanceof TextView textView ) { if ( textView . getText ( ) . toString ( ) . contains ( \"<STR_LIT>\" ) ) { WppCore . sendReaction ( \"<STR_LIT>\" , param . args [ <NUM_LIT> ] ) ; return ; } } } } WppCore . sendReaction ( \"<STR_LIT>\" , param . args [ <NUM_LIT> ] ) ; } ) ) ; viewGroup . setOnTouchListener ( ( v , event ) -> gestureDetector . onTouchEvent ( event ) ) ; } } ) ; } private void stampCopiedMessage ( ) throws Exception { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var copiedMessage = Unobfuscator . loadCopiedMessageMethod ( classLoader ) ; XposedBridge . hookMethod ( copiedMessage , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var Collection = ( java . util . Collection ) param . args [ param . args . length - <NUM_LIT> ] ; param . args [ param . args . length - <NUM_LIT> ] = new ArrayList < Object > ( Collection ) { @ Override public int size ( ) { return <NUM_LIT> ; } } ; } } ) ; } private void animationList ( ) throws Exception { var animation = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; if ( ! Objects . equals ( animation , \"<STR_LIT>\" ) ) { view . startAnimation ( AnimationUtil . getAnimation ( animation ) ) ; } else { if ( properties . containsKey ( \"<STR_LIT>\" ) ) { var animation = AnimationUtil . getAnimation ( properties . getProperty ( \"<STR_LIT>\" ) ) ; if ( animation != null ) { view . startAnimation ( animation ) ; } } } } } ) ; } private void customPlayBackSpeed ( ) throws Exception { var voicenote_speed = prefs . getFloat ( \"<STR_LIT>\" , <NUM_LIT> ) ; var playBackSpeed = Unobfuscator . loadPlaybackSpeed ( classLoader ) ; XposedBridge . hookMethod ( playBackSpeed , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( ( float ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = voicenote_speed ; } } } ) ; var voicenoteClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var method = ReflectionUtils . findAllMethodsUsingFilter ( voicenoteClass , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == int . class && method1 . getReturnType ( ) . equals ( void . class ) ) ; XposedBridge . hookMethod ( method [ method . length - <NUM_LIT> ] , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { var view = ( View ) param . thisObject ; var playback = ( TextView ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( playback != null ) { playback . setText ( String . valueOf ( voicenote_speed ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ;", "output": "} } } } ) ; } private void sendAudioType ( int audio_type ) throws Exception { var sendAudioTypeMethod = Unobfuscator . loadSendAudioTypeMethod ( classLoader ) ; log ( Unobfuscator . getMethodDescriptor ( sendAudioTypeMethod ) ) ; XposedBridge . hookMethod ( sendAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var results = ReflectionUtils . findArrayOfType ( param . args , Integer . class ) ; if ( results . size ( ) < <NUM_LIT> ) { log ( \"<STR_LIT>\" ) ; return ; } var mediaType = results . get ( <NUM_LIT> ) ; if ( ( int ) mediaType . second != <NUM_LIT> ) return ; var audioType = results . get ( <NUM_LIT> ) ; param . args [ audioType . first ] = audio_type - <NUM_LIT> ; } } ) ; var originFMessageField = Unobfuscator . loadOriginFMessageField ( classLoader ) ; var forwardAudioTypeMethod = Unobfuscator . loadForwardAudioTypeMethod ( classLoader ) ; XposedBridge . hookMethod ( forwardAudioTypeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = param . getResult ( ) ; originFMessageField . setAccessible ( true ) ; originFMessageField . setInt ( fMessage , audio_type - <NUM_LIT> ) ; } } ) ; } private void autoNextStatus ( ) throws Exception { Class < ? > StatusPlaybackContactFragmentClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var runNextStatusMethod = Unobfuscator . loadNextStatusRunMethod ( classLoader ) ; XposedBridge . hookMethod ( runNextStatusMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var obj = XposedHelpers . getObjectField ( param . thisObject , \"<STR_LIT>\" ) ; if ( StatusPlaybackContactFragmentClass . isInstance ( obj ) ) { param . setResult ( null ) ; } } } ) ; var onPlayBackFinished = Unobfuscator . loadOnPlaybackFinished ( classLoader ) ; XposedBridge . hookMethod ( onPlayBackFinished , XC_MethodReplacement . DO_NOTHING ) ; } private void disable_defEmojis ( ) throws Exception { var defEmojiClass = Unobfuscator . loadDefEmojiClass ( classLoader ) ; XposedBridge . hookMethod ( defEmojiClass , XC_MethodReplacement . returnConstant ( null ) ) ; } private void filterItems ( String filterItems ) { var itens = filterItems . split ( \"<STR_LIT>\" ) ; var idsFilter = new ArrayList < Integer > ( ) ; for ( String item : itens ) { var id = Utils . getID ( item , \"<STR_LIT>\" ) ; if ( id > <NUM_LIT> ) { idsFilter . add ( id ) ; } } XposedHelpers . findAndHookMethod ( View . class , \"<STR_LIT>\" , boolean . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . thisObject ; var id = view . getId ( ) ; if ( id > <NUM_LIT> && idsFilter . contains ( id ) && view . getVisibility ( ) == View . VISIBLE ) { view . setVisibility ( View . GONE ) ; } } } ) ; } private void showOnline ( boolean showOnline ) throws Exception { var checkOnlineMethod = Unobfuscator . loadCheckOnlineMethod ( classLoader ) ; XposedBridge . hookMethod ( checkOnlineMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var message = ( Message ) param . args [ <NUM_LIT> ] ; if ( message . arg1 != <NUM_LIT> ) return ; BaseBundle baseBundle = ( BaseBundle ) message . obj ; var jid = baseBundle . getString ( \"<STR_LIT>\" ) ; if ( WppCore . isGroup ( jid ) ) return ; var name = WppCore . getContactName ( WppCore . createUserJid ( jid ) ) ; name = TextUtils . isEmpty ( name ) ? WppCore . stripJID ( jid ) : name ; if ( showOnline ) Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . toast_online ) , name ) , Toast . LENGTH_SHORT ) ; Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jid ) , \"<STR_LIT>\" ) ; } } ) ; } @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) private static void InsertDNDOption ( Menu menu , Activity home , boolean newSettings ) { var dndmode = WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . dnd_mode_title ) ) ; var drawable = DesignUtils . getDrawableByName ( dndmode ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! dndmode ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . dnd_mode_title ) ) . setMessage ( home . getString ( ResId . string . dnd_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( \"<STR_LIT>\" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( \"<STR_LIT>\" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) private static void InsertFreezeLastSeenOption ( Menu menu , Activity home , boolean newSettings ) { final boolean freezelastseen = WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , home . getString ( ResId . string . freezelastseen_title ) ) ; var drawable = Utils . getApplication ( ) . getDrawable ( freezelastseen ? ResId . drawable . eye_disabled : ResId . drawable . eye_enabled ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( menuItem -> { if ( ! freezelastseen ) { new AlertDialogWpp ( home ) . setTitle ( home . getString ( ResId . string . freezelastseen_title ) ) . setMessage ( home . getString ( ResId . string . freezelastseen_message ) ) . setPositiveButton ( home . getString ( ResId . string . activate ) , ( dialog , which ) -> { WppCore . setPrivBoolean ( \"<STR_LIT>\" , true ) ; Utils . doRestart ( home ) ; } ) . setNegativeButton ( home . getString ( ResId . string . cancel ) , ( dialog , which ) -> dialog . dismiss ( ) ) . create ( ) . show ( ) ; return true ; } WppCore . setPrivBoolean ( \"<STR_LIT>\" , false ) ; Utils . doRestart ( home ) ; return true ; } ) ; } private void hookProps ( ) throws Exception { var methodPropsBoolean = Unobfuscator . loadPropsBooleanMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodPropsBoolean ) ) ; var dataUsageActivityClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; XposedBridge . hookMethod ( methodPropsBoolean , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsBoolean . get ( i ) ; if ( propValue != null ) { switch ( i ) { case <NUM_LIT> : if ( Unobfuscator . isCalledFromClass ( dataUsageActivityClass ) ) return ; break ; } param . setResult ( propValue ) ; } } } ) ; var methodPropsInteger = Unobfuscator . loadPropsIntegerMethod ( classLoader ) ; XposedBridge . hookMethod ( methodPropsInteger , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { int i = ( int ) param . args [ param . args . length - <NUM_LIT> ] ; var propValue = propsInteger . get ( i ) ; if ( propValue == null ) return ; param . setResult ( propValue ) ; } } ) ; } private void hookMenuOptions ( boolean newSettings , boolean showFreezeLastSeen , boolean showDnd , String filterChats ) { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var activity = ( Activity ) param . thisObject ; if ( prefs . getBoolean ( \"<STR_LIT>\" , true ) ) { var iconDraw = activity . getDrawable ( ResId . drawable . refresh ) ; iconDraw . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; var itemMenu = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . restart_whatsapp ) . setIcon ( iconDraw ) . setOnMenuItemClickListener ( item -> { Utils . doRestart ( activity ) ; return true ; } ) ; if ( newSettings ) { itemMenu . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } } if ( showFreezeLastSeen ) { InsertFreezeLastSeenOption ( menu , activity , newSettings ) ; } if ( showDnd ) { InsertDNDOption ( menu , activity , newSettings ) ; } else { var dndmode = WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) ; if ( dndmode ) { WppCore . setPrivBoolean ( \"<STR_LIT>\" , false ) ; Utils . doRestart ( activity ) ; } } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . findItem ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( item != null ) { item . setVisible ( Objects . equals ( filterChats , \"<STR_LIT>\" ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class KeyboardInsetsPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new KeyboardInsetsModule ( reactContext ) ) ; }", "output": "@ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new KeyboardInsetsViewManager ( ) ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . bean ; public class FileTransferEvent implements DevicesInterface { public static final int STATE_DOWNLOAD = <NUM_LIT> ; public static final int STATE_UPLOAD = <NUM_LIT> ; public static final int STATE_OVER = <NUM_LIT> ; protected int state ; protected int device ; protected String desc ; public FileTransferEvent ( int state , int device , String desc ) { this . state = state ; this . device = device ; this . desc = desc ; } public FileTransferEvent ( ) { } public int getState ( ) { return state ; } public int getDevice ( ) { return device ; } public String getDesc ( ) { return desc ; }", "output": "}"}, {"input": "package de . robv . android . xposed ; import de . robv . android . xposed . callbacks . XCallback ; public abstract class XC_MethodReplacement extends XC_MethodHook { public XC_MethodReplacement ( ) { super ( ) ; } public XC_MethodReplacement ( int priority ) { super ( priority ) ; } @ Override protected final void beforeHookedMethod ( MethodHookParam param ) throws Throwable { try { Object result = replaceHookedMethod ( param ) ; param . setResult ( result ) ; } catch ( Throwable t ) { param . setThrowable ( t ) ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) protected final void afterHookedMethod ( MethodHookParam param ) throws Throwable { } @ SuppressWarnings ( \"<STR_LIT>\" ) protected abstract Object replaceHookedMethod ( MethodHookParam param ) throws Throwable ; public static final XC_MethodReplacement DO_NOTHING = new XC_MethodReplacement ( PRIORITY_HIGHEST * <NUM_LIT> ) { @ Override protected Object replaceHookedMethod ( MethodHookParam param ) throws Throwable { return null ; } } ; public static XC_MethodReplacement returnConstant ( final Object result ) { return returnConstant ( PRIORITY_DEFAULT , result ) ; } public static XC_MethodReplacement returnConstant ( int priority , final Object result ) { return new XC_MethodReplacement ( priority ) { @ Override protected Object replaceHookedMethod ( MethodHookParam param ) throws Throwable { return result ; } }", "output": "; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import androidx . test . platform . app . InstrumentationRegistry ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) {", "output": "Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ; assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ; } }"}, {"input": "package com . reactnative . imagecrop ; import androidx . annotation . NonNull ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class ImageCropPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) {", "output": "return Arrays . asList ( new RNImageCropViewManager ( ) ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; import android . app . Activity ; import android . content . Context ; import android . util . AttributeSet ; import android . view . View ; import androidx . core . view . ViewCompat ; import androidx . core . widget . NestedScrollView ; import com . google . android . material . bottomnavigation . BottomNavigationView ; import in . hridayan . ashell . R ; public class CoordinatedNestedScrollView extends NestedScrollView { public CoordinatedNestedScrollView ( Context context ) { super ( context ) ; } public CoordinatedNestedScrollView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public CoordinatedNestedScrollView ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override public boolean onStartNestedScroll ( View child , View target , int axes , int type ) { return ( axes & ViewCompat . SCROLL_AXIS_VERTICAL ) != <NUM_LIT> ; } @ Override public void onNestedScroll ( View target , int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed , int type ) { if ( dyConsumed > <NUM_LIT> ) { BottomNavigationView bottomNavigationView = ( ( Activity ) getContext ( ) ) . findViewById ( R . id . bottom_nav_bar ) ; if ( bottomNavigationView != null ) { bottomNavigationView . setVisibility ( View . GONE ) ; } } else if ( dyConsumed < <NUM_LIT> ) { BottomNavigationView bottomNavigationView = ( ( Activity ) getContext ( ) ) . findViewById ( R . id . bottom_nav_bar ) ; if ( bottomNavigationView != null ) { bottomNavigationView . setVisibility ( View . VISIBLE ) ;", "output": "} } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . app . Service ; import android . content . Intent ; import android . os . IBinder ; import android . os . RemoteException ; import android . util . Log ; public class TransferServices extends Service { public TransferServiceBinder binder ; public TransferServices ( ) {", "output": "this . binder = new TransferServiceBinder ( ) ; } @ Override public void onDestroy ( ) { super . onDestroy ( ) ; try { binder . destroy ( ) ; } catch ( RemoteException ignored ) { } } @ Override public IBinder onBind ( Intent intent ) { return binder ; } }"}, {"input": "package com . gw . swipeback . tools ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; public class ActivityLifecycleCallbacksAdapter implements Application . ActivityLifecycleCallbacks { @ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) { } @ Override public void onActivityStarted ( Activity activity ) { }", "output": "@ Override public void onActivityResumed ( Activity activity ) { } @ Override public void onActivityPaused ( Activity activity ) { } @ Override public void onActivityStopped ( Activity activity ) { } @ Override public void onActivitySaveInstanceState ( Activity activity , Bundle outState ) { } @ Override public void onActivityDestroyed ( Activity activity ) { } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import androidx . annotation . NonNull ; import java . io . File ; import java . io . IOException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import icu . freedomIntrovert . biliSendCommAntifraud . BuildConfig ; import okhttp3 . Interceptor ; import okhttp3 . MediaType ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class LoggerInterceptor implements Interceptor { private final Logger logger ; public LoggerInterceptor ( ) { File logDir = new File ( \"<STR_LIT>\" + BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; if ( ! logDir . exists ( ) ) { logDir . mkdirs ( ) ; } logger = new Logger ( logDir ) ; } @ NonNull @ Override public Response intercept ( @ NonNull Chain chain ) throws IOException { Request request = chain . request ( ) ; Response response = null ; response = chain . proceed ( request ) ; String time = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . getDefault ( ) ) . format ( new Date ( ) ) ; logger . log ( \"<STR_LIT>\" + time + \"<STR_LIT>\" ) ; logger . log ( \"<STR_LIT>\" + request . url ( ) ) ; logger . log ( \"<STR_LIT>\" + request . method ( ) ) ; logger . log ( \"<STR_LIT>\" + request . headers ( ) ) ; logger . log ( \"<STR_LIT>\" + response . code ( ) ) ; logger . log ( \"<STR_LIT>\" + response . message ( ) ) ; logger . log ( \"<STR_LIT>\" + response . headers ( ) ) ; ResponseBody body = response . body ( ) ; if ( body != null ) { MediaType contentType = body . contentType ( ) ; if ( contentType != null && contentType . toString ( ) . contains ( \"<STR_LIT>\" ) ) { String responseBody = body . string ( ) ; logger . log ( \"<STR_LIT>\" + responseBody ) ; logger . log ( \"<STR_LIT>\" ) ;", "output": "return response . newBuilder ( ) . body ( ResponseBody . create ( contentType , responseBody ) ) . build ( ) ; } } logger . log ( \"<STR_LIT>\" ) ; return response ; } }"}, {"input": "public class WebAppInterface {", "output": "Context mContext ; WebAppInterface ( Context c ) { mContext = c ; } @ JavascriptInterface public void showToast ( String toast ) { Toast . makeText ( mContext , toast , Toast . LENGTH_SHORT ) . show ( ) ; } public void showToast2 ( String toast ) { Toast . makeText ( mContext , toast , Toast . LENGTH_SHORT ) . show ( ) ; } }"}, {"input": "package in . hridayan . ashell . activities ; import android . app . Activity ; import android . content . Context ; import android . content . res . Configuration ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextWatcher ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . EditText ; import android . widget . ImageView ; import android . widget . Toast ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedDispatcher ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . lifecycle . ViewModelProvider ; import androidx . lifecycle . ViewModel ; import androidx . recyclerview . widget . GridLayoutManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . appbar . AppBarLayout ; import com . google . android . material . chip . Chip ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . search . SearchBar ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . UI . CustomSearchView ; import in . hridayan . ashell . UI . ExamplesViewModel ; import in . hridayan . ashell . adapters . CommandsSearchAdapter ; import in . hridayan . ashell . adapters . ExamplesAdapter ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Commands ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . ThemeUtils ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; public class ExamplesActivity extends AppCompatActivity implements ExamplesAdapter . OnItemClickListener { private ExamplesViewModel viewModel ; private AppBarLayout appBarLayout ; private CustomSearchView searchView ; private RecyclerView mRecyclerView , mSearchRecyclerView ; private EditText editText ; private MaterialTextView noCommandFoundText ; private List < CommandItems > itemList ; private SearchBar mSearchBar ; private ExamplesAdapter mExamplesAdapter ; private Chip mSummaryChip ; private MenuItem sort , pin , selectAll , addBookmark , deselectAll ; private Menu searchBarMenu ; private View parent ; private int isSortingOptionSame ; private boolean isSummaryChipClicked = false , isAllItemsSelected ; @ Override protected void onPause ( ) { super . onPause ( ) ; viewModel . setToolbarExpanded ( Utils . isToolbarExpanded ( appBarLayout ) ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; if ( viewModel . isToolbarExpanded ( ) ) { if ( Utils . recyclerViewPosition ( mRecyclerView ) == <NUM_LIT> ) { Utils . expandToolbar ( appBarLayout ) ; } } else { Utils . collapseToolbar ( appBarLayout ) ; } } @ Override protected void onCreate ( Bundle savedInstanceState ) { EdgeToEdge . enable ( this ) ; ThemeUtils . updateTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_examples ) ; parent = findViewById ( android . R . id . content ) ; appBarLayout = findViewById ( R . id . appBarLayout ) ; searchView = findViewById ( R . id . search_view ) ; mSearchBar = findViewById ( R . id . search_bar ) ; mSearchRecyclerView = findViewById ( R . id . search_recycler_view ) ; mSummaryChip = findViewById ( R . id . search_summary ) ; editText = searchView . getSearchEditText ( ) ; searchBarMenu = mSearchBar . getMenu ( ) ; sort = searchBarMenu . findItem ( R . id . sort ) ; addBookmark = searchBarMenu . findItem ( R . id . add_bookmark ) ; pin = searchBarMenu . findItem ( R . id . pin ) ; selectAll = searchBarMenu . findItem ( R . id . select_all ) ; deselectAll = searchBarMenu . findItem ( R . id . deselect_all ) ; noCommandFoundText = findViewById ( R . id . no_command_found ) ; itemList = Commands . commandList ( this ) ; viewModel = new ViewModelProvider ( this ) . get ( ExamplesViewModel . class ) ; ImageView imageView = findViewById ( R . id . arrow_back ) ; OnBackPressedDispatcher dispatcher = getOnBackPressedDispatcher ( ) ; imageView . setOnClickListener ( v -> dispatcher . onBackPressed ( ) ) ; mSearchBar . clearFocus ( ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_search ) ; mSearchBar . setOnMenuItemClickListener ( item -> { switch ( item . getItemId ( ) ) { case R . id . sort : sortingDialog ( this , this ) ; return true ; case R . id . select_all : mExamplesAdapter . selectAll ( ) ; updateSearchBar ( ) ; return true ; case R . id . deselect_all : mExamplesAdapter . deselectAll ( ) ; updateSearchBar ( ) ; return true ; case R . id . add_bookmark : manageBookmarkAddOrRemove ( ) ; return true ; case R . id . pin : managePinUnpin ( ) ; return true ; default : return false ; } } ) ; mRecyclerView = findViewById ( R . id . recycler_view ) ; mSearchRecyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; mRecyclerView . setLayoutManager ( new LinearLayoutManager ( this ) ) ; GridLayoutManager mLayoutManager = new GridLayoutManager ( this , getResources ( ) . getConfiguration ( ) . orientation == Configuration . ORIENTATION_LANDSCAPE ? <NUM_LIT> : <NUM_LIT> ) ; mRecyclerView . setLayoutManager ( mLayoutManager ) ; mExamplesAdapter = new ExamplesAdapter ( Commands . commandList ( this ) , this ) ; mExamplesAdapter . sortData ( ) ; mExamplesAdapter . setOnItemClickListener ( this ) ; mRecyclerView . setAdapter ( mExamplesAdapter ) ; mRecyclerView . setVisibility ( View . VISIBLE ) ; editText . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence text , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence text , int i , int i1 , int i2 ) { } @ Override public void afterTextChanged ( Editable text ) { filterList ( text ) ; mSummaryChip . setOnClickListener ( v -> { isSummaryChipClicked = true ; filterList ( text ) ; } ) ; } } ) ; } private void filterList ( CharSequence text ) { List < CommandItems > filteredList = new ArrayList < > ( ) ; mSummaryChip . setVisibility ( View . GONE ) ; noCommandFoundText . setVisibility ( View . GONE ) ; if ( text != null && ! text . toString ( ) . isEmpty ( ) ) { searchTitle ( text , filteredList ) ; if ( filteredList . isEmpty ( ) ) { noCommandFoundText . setVisibility ( View . VISIBLE ) ; mSummaryChip . setVisibility ( View . VISIBLE ) ; if ( isSummaryChipClicked ) { chipSummaryOnClick ( text , filteredList ) ; } } if ( filteredList . isEmpty ( ) ) { noCommandFoundText . setVisibility ( View . VISIBLE ) ; } } mSearchRecyclerView . setVisibility ( View . VISIBLE ) ; CommandsSearchAdapter adapter = new CommandsSearchAdapter ( filteredList , this ) ; mSearchRecyclerView . setAdapter ( adapter ) ; } private void searchTitle ( CharSequence text , List < CommandItems > filteredList ) { for ( CommandItems item : itemList ) { if ( item . getTitle ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) ) { filteredList . add ( item ) ; } } } private void searchTitleAndSummary ( CharSequence text , List < CommandItems > filteredList ) { for ( CommandItems item : itemList ) { if ( item . getTitle ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) || item . getSummary ( ) . toLowerCase ( Locale . getDefault ( ) ) . contains ( text . toString ( ) . toLowerCase ( Locale . getDefault ( ) ) ) ) { filteredList . add ( item ) ; } } } private void chipSummaryOnClick ( CharSequence text , List < CommandItems > filteredList ) { noCommandFoundText . setVisibility ( View . GONE ) ; searchTitleAndSummary ( text , filteredList ) ; mSummaryChip . setVisibility ( View . GONE ) ; } private void sortingDialog ( Context context , Activity activity ) { CharSequence [ ] sortingOptions = { getString ( R . string . sort_A_Z ) , getString ( R . string . sort_Z_A ) , getString ( R . string . most_used ) , getString ( R . string . least_used ) } ; int currentSortingOption = Preferences . getSortingExamples ( context ) ; isSortingOptionSame = currentSortingOption ; final int [ ] sortingOption = { currentSortingOption } ; new MaterialAlertDialogBuilder ( activity ) . setTitle ( getString ( R . string . sort ) ) . setSingleChoiceItems ( sortingOptions , currentSortingOption , ( dialog , which ) -> { sortingOption [ <NUM_LIT> ] = which ; } ) . setPositiveButton ( getString ( R . string . ok ) , ( dialog , which ) -> { Preferences . setSortingExamples ( context , sortingOption [ <NUM_LIT> ] ) ; if ( isSortingOptionSame != sortingOption [ <NUM_LIT> ] ) { mExamplesAdapter . sortData ( ) ; } } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } private void updateSearchBar ( ) { int numSelectedItems = mExamplesAdapter . getSelectedItemsSize ( ) ; isAllItemsSelected = numSelectedItems == mExamplesAdapter . getItemCount ( ) ; if ( numSelectedItems > <NUM_LIT> ) { startSelection ( numSelectedItems ) ; } else { endSelection ( ) ; } } private void mSearchBarNavigationIconOnClickListener ( int numSelectedItems ) { mSearchBar . setNavigationOnClickListener ( v -> { if ( numSelectedItems > <NUM_LIT> ) { endSelection ( ) ; mExamplesAdapter . deselectAll ( ) ; } } ) ; } private void endSelection ( ) { mSearchBar . setHint ( R . string . search_command ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_search ) ; mSearchBar . setClickable ( true ) ; mSearchBarNavigationIconOnClickListener ( <NUM_LIT> ) ; updateMenuItemVisibility ( false , isAllItemsSelected ) ; } private void startSelection ( int numSelectedItems ) { String hint = getString ( R . string . selected ) + \"<STR_LIT>\" + \"<STR_LIT>\" + Integer . toString ( numSelectedItems ) + \"<STR_LIT>\" ; mSearchBar . setHint ( hint ) ; mSearchBar . setNavigationIcon ( R . drawable . ic_cross ) ; mSearchBar . setClickable ( false ) ; mSearchBarNavigationIconOnClickListener ( numSelectedItems ) ; updateMenuItemVisibility ( true , isAllItemsSelected ) ; } private void updateMenuItemVisibility ( boolean isItemSelecting , boolean isAllSelected ) { sort . setVisible ( ! isItemSelecting ) ; pin . setVisible ( isItemSelecting ) ; selectAll . setVisible ( isItemSelecting && ! isAllSelected ) ; deselectAll . setVisible ( isItemSelecting && isAllSelected ) ; if ( isItemSelecting ) { addBookmark . setVisible ( true ) ; addBookmark . setIcon ( mExamplesAdapter . isAllItemsBookmarked ( ) ? R . drawable . ic_bookmark_added : R . drawable . ic_add_bookmark ) ; pin . setIcon ( mExamplesAdapter . isAllItemsPinned ( ) ? R . drawable . ic_pinned : R . drawable . ic_pin ) ; } else { addBookmark . setVisible ( false ) ; } } private void batchBookmarkDialog ( int selectedCount , boolean isAllItemBookmarked , boolean isLimitReached , boolean isBatch ) { String message = isAllItemBookmarked ? getString ( R . string . confirm_batch_remove_bookmark , selectedCount ) : getString ( R . string . confirm_batch_add_bookmark , selectedCount ) ; new MaterialAlertDialogBuilder ( this ) . setTitle ( getString ( R . string . confirm ) ) . setMessage ( message ) . setPositiveButton ( getString ( R . string . ok ) , ( dialog , i ) -> { if ( isAllItemBookmarked ) { mExamplesAdapter . deleteSelectedFromBookmarks ( ) ; } else if ( ! isLimitReached ) { mExamplesAdapter . addSelectedToBookmarks ( ) ; } updateSearchBar ( ) ; bookmarksAddedOrRemovedMessage ( ! isAllItemBookmarked , isBatch , isLimitReached , selectedCount ) ; } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } private void manageBookmarkAddOrRemove ( ) { int selectedItems = mExamplesAdapter . getSelectedItemsSize ( ) ; boolean isAllItemBookmarked = mExamplesAdapter . isAllItemsBookmarked ( ) , isLimitReached = selectedItems + Utils . getBookmarks ( this ) . size ( ) > Preferences . MAX_BOOKMARKS_LIMIT && ! Preferences . getOverrideBookmarks ( this ) ; boolean isBatch = selectedItems > <NUM_LIT> ; if ( isBatch ) { batchBookmarkDialog ( selectedItems , isAllItemBookmarked , isLimitReached , isBatch ) ; } else { if ( isAllItemBookmarked ) { mExamplesAdapter . deleteSelectedFromBookmarks ( ) ; } else if ( ! isLimitReached ) { mExamplesAdapter . addSelectedToBookmarks ( ) ; } updateSearchBar ( ) ; bookmarksAddedOrRemovedMessage ( ! isAllItemBookmarked , isBatch , isLimitReached , selectedItems ) ; } } private void bookmarksAddedOrRemovedMessage ( boolean isAdded , boolean isBatch , boolean isLimitReached , int selectedCount ) { if ( isLimitReached && isAdded ) { Utils . snackBar ( parent , getString ( R . string . bookmark_limit_reached ) ) . show ( ) ; } else if ( isBatch ) { int message = isAdded ? R . string . batch_bookmark_added_message : R . string . batch_bookmark_removed_message ;", "output": "Utils . snackBar ( parent , getString ( message , selectedCount ) ) . show ( ) ; } else { String command = mExamplesAdapter . sanitizeText ( mExamplesAdapter . selectedItems . get ( <NUM_LIT> ) . getTitle ( ) ) ; int message = isAdded ? R . string . bookmark_added_message : R . string . bookmark_removed_message ; Utils . snackBar ( parent , getString ( message , command ) ) . show ( ) ; } } private void managePinUnpin ( ) { int size = mExamplesAdapter . getSelectedItemsSize ( ) ; String title = mExamplesAdapter . selectedItems . get ( <NUM_LIT> ) . getTitle ( ) ; boolean isBatch = size > <NUM_LIT> ; boolean isAllItemsPinned = mExamplesAdapter . isAllItemsPinned ( ) ; String confirmPin = isBatch ? getString ( R . string . confirm_pin ) : getString ( R . string . confirm_pin_single , title ) ; String confirmUnpin = isBatch ? getString ( R . string . confirm_unpin ) : getString ( R . string . confirm_unpin_single , title ) ; String message = isAllItemsPinned ? confirmUnpin : confirmPin ; String positiveButtonText = isAllItemsPinned ? getString ( R . string . unpin ) : getString ( R . string . pin ) ; String snackBarMessage ; if ( isBatch ) { snackBarMessage = isAllItemsPinned ? getString ( R . string . batch_unpinned_message , size ) : getString ( R . string . batch_pinned_message , size ) ; } else { snackBarMessage = isAllItemsPinned ? getString ( R . string . unpinned_message , title ) : getString ( R . string . pinned_message , title ) ; } new MaterialAlertDialogBuilder ( this ) . setTitle ( getString ( R . string . confirm ) ) . setMessage ( message ) . setPositiveButton ( positiveButtonText , ( dialog , i ) -> { mExamplesAdapter . pinUnpinSelectedItems ( isAllItemsPinned ) ; endSelection ( ) ; updateSearchBar ( ) ; Utils . snackBar ( parent , snackBarMessage ) . show ( ) ; } ) . setNegativeButton ( getString ( R . string . cancel ) , ( dialog , i ) -> { } ) . show ( ) ; } @ Override public void onItemClick ( int position ) { updateSearchBar ( ) ; } @ Override public void onItemLongClick ( int position ) { updateSearchBar ( ) ; } }"}, {"input": "package com . reactnative . nestedscrollwebview ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import com . reactnativecommunity . webview . RNCNestedScrollWebViewManager ; public class NestedScrollWebViewPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ;", "output": "} }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . List ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . ByXposedLaunchedActivity ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostCommentHook extends BaseHook { AtomicReference < Context > currentContext ; AtomicReference < String > currentOid ; AtomicReference < String > currentDynId ; AtomicReference < String > currentAreaType ; AtomicReference < String > currentComment ; AtomicReference < String > currentPictures ; public PostCommentHook ( ) { currentContext = new AtomicReference < > ( ) ; currentOid = new AtomicReference < > ( ) ; currentDynId = new AtomicReference < > ( ) ; currentAreaType = new AtomicReference < > ( ) ; currentComment = new AtomicReference < > ( ) ; currentPictures = new AtomicReference < > ( ) ; } @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { try { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , android . os . Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Method getIntentMethod = param . thisObject . getClass ( ) . getMethod ( \"<STR_LIT>\" ) ; Intent intent = ( Intent ) getIntentMethod . invoke ( param . thisObject ) ; Bundle fragment_args = intent . getExtras ( ) . getBundle ( \"<STR_LIT>\" ) ; XposedBridge . log ( \"<STR_LIT>\" + fragment_args . getString ( \"<STR_LIT>\" ) ) ; currentDynId . set ( fragment_args . getString ( \"<STR_LIT>\" ) ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; } catch ( XposedHelpers . ClassNotFoundError e ) { XposedBridge . log ( \"<STR_LIT>\" ) ; } XposedHelpers . findAndHookMethod ( Activity . class , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Context context = ( Context ) param . thisObject ; currentContext . set ( context ) ; XposedBridge . log ( \"<STR_LIT>\" + context ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , java . lang . Class . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object result = param . getResult ( ) ; if ( result != null ) { Class < ? > resultClass = result . getClass ( ) ; for ( Class < ? > classInterface : resultClass . getInterfaces ( ) ) { if ( classInterface . getCanonicalName ( ) . equals ( \"<STR_LIT>\" ) ) { XposedHelpers . findAndHookMethod ( resultClass , \"<STR_LIT>\" , java . util . Map . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Map < String , String > arrayMap = ( Map < String , String > ) param . args [ <NUM_LIT> ] ; currentComment . set ( arrayMap . get ( \"<STR_LIT>\" ) ) ; currentOid . set ( arrayMap . get ( \"<STR_LIT>\" ) ) ; currentAreaType . set ( arrayMap . get ( \"<STR_LIT>\" ) ) ; currentPictures . set ( arrayMap . get ( \"<STR_LIT>\" ) ) ; } } ) ;", "output": "} } } } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Object arg = param . getResult ( ) ; Object body = XposedHelpers . callMethod ( arg , \"<STR_LIT>\" ) ; if ( body != null ) { String bodyCanonicalName = body . getClass ( ) . getCanonicalName ( ) ; if ( bodyCanonicalName != null && bodyCanonicalName . equals ( \"<STR_LIT>\" ) ) { Object data = XposedHelpers . getObjectField ( body , \"<STR_LIT>\" ) ; if ( data != null && data . getClass ( ) . getCanonicalName ( ) . equals ( \"<STR_LIT>\" ) ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; Class < ? > biliCommentAddResultClass = data . getClass ( ) ; Object reply = XposedHelpers . getObjectField ( data , \"<STR_LIT>\" ) ; Object content = XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; Integer type = ( Integer ) XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; Long oid = ( Long ) XposedHelpers . getObjectField ( reply , \"<STR_LIT>\" ) ; if ( ( Integer ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) == <NUM_LIT> ) { intent . putExtra ( \"<STR_LIT>\" , ByXposedLaunchedActivity . TODO_CHECK_COMMENT ) ; intent . putExtra ( \"<STR_LIT>\" , ( String ) biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( oid ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( type ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , String . valueOf ( biliCommentAddResultClass . getField ( \"<STR_LIT>\" ) . get ( data ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , ( String ) XposedHelpers . getObjectField ( content , \"<STR_LIT>\" ) ) ; intent . putExtra ( \"<STR_LIT>\" , currentDynId . get ( ) ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { intent . putExtra ( \"<STR_LIT>\" , Utils . getBvidFormAvid ( oid ) ) ; } try { Field picturesField = content . getClass ( ) . getField ( \"<STR_LIT>\" ) ; List < ? > pictures = ( List < ? > ) picturesField . get ( content ) ; intent . putExtra ( \"<STR_LIT>\" , Utils . picturesObjToString ( pictures ) ) ; } catch ( NoSuchFieldException e ) { XposedBridge . log ( \"<STR_LIT>\" ) ; } long ctime = XposedHelpers . getLongField ( reply , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , ctime ) ; XposedBridge . log ( \"<STR_LIT>\" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } else if ( XposedHelpers . getIntField ( body , \"<STR_LIT>\" ) == CommentAddResult . CODE_CONTAIN_SENSITIVE ) { Intent intent = new Intent ( ) ; intent . setComponent ( new ComponentName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; intent . putExtra ( \"<STR_LIT>\" , ByXposedLaunchedActivity . TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) ; intent . putExtra ( \"<STR_LIT>\" , currentOid . get ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , currentComment . get ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , ( String ) XposedHelpers . getObjectField ( body , \"<STR_LIT>\" ) ) ; intent . putExtra ( \"<STR_LIT>\" , currentAreaType . get ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , currentDynId . get ( ) ) ; XposedBridge . log ( \"<STR_LIT>\" + intent . getExtras ( ) . toString ( ) ) ; currentContext . get ( ) . startActivity ( intent ) ; } } } } } ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . recog . listener ; import android . util . Log ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . EventListener ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; import com . baidu . aip . asrwakeup3 . core . recog . RecogResult ; public class RecogEventAdapter implements EventListener { private IRecogListener listener ; private static final String TAG = \"<STR_LIT>\" ; public RecogEventAdapter ( IRecogListener listener ) { this . listener = listener ; } @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { String currentJson = params ; String logMessage = \"<STR_LIT>\" + name + \"<STR_LIT>\" + params ; Log . i ( TAG , logMessage ) ; if ( false ) { return ; } if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_LOADED ) ) { listener . onOfflineLoaded ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_UNLOADED ) ) { listener . onOfflineUnLoaded ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_READY ) ) { listener . onAsrReady ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_BEGIN ) ) { listener . onAsrBegin ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_END ) ) { listener . onAsrEnd ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { RecogResult recogResult = RecogResult . parseJson ( params ) ; String [ ] results = recogResult . getResultsRecognition ( ) ; if ( recogResult . isFinalResult ( ) ) { listener . onAsrFinalResult ( results , recogResult ) ; } else if ( recogResult . isPartialResult ( ) ) { listener . onAsrPartialResult ( results , recogResult ) ; } else if ( recogResult . isNluResult ( ) ) { listener . onAsrOnlineNluResult ( new String ( data , offset , length ) ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH ) ) { RecogResult recogResult = RecogResult . parseJson ( params ) ; if ( recogResult . hasError ( ) ) { int errorCode = recogResult . getError ( ) ; int subErrorCode = recogResult . getSubError ( ) ; MyLogger . error ( TAG , \"<STR_LIT>\" + params ) ; listener . onAsrFinishError ( errorCode , subErrorCode , recogResult . getDesc ( ) , recogResult ) ; } else { listener . onAsrFinish ( recogResult ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_LONG_SPEECH ) ) { listener . onAsrLongFinish ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_EXIT ) ) { listener . onAsrExit ( ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_VOLUME ) ) { Volume vol = parseVolumeJson ( params ) ; listener . onAsrVolume ( vol . volumePercent , vol . volume ) ; } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_AUDIO ) ) { if ( data . length != length ) { MyLogger . error ( TAG , \"<STR_LIT>\" ) ; } listener . onAsrAudio ( data , offset , length ) ; } } private Volume parseVolumeJson ( String jsonStr ) { Volume vol = new Volume ( ) ;", "output": "vol . origalJson = jsonStr ; try { JSONObject json = new JSONObject ( jsonStr ) ; vol . volumePercent = json . getInt ( \"<STR_LIT>\" ) ; vol . volume = json . getInt ( \"<STR_LIT>\" ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return vol ; } private class Volume { private int volumePercent = - <NUM_LIT> ; private int volume = - <NUM_LIT> ; private String origalJson ; } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import android . content . pm . ApplicationInfo ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class WindowInsetsApplier implements OnApplyWindowInsetsListener { private WindowInsetsApplier ( ) { } public static boolean install ( @ NonNull ViewPager2 viewPager ) { ApplicationInfo appInfo = viewPager . getContext ( ) . getApplicationInfo ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R && appInfo . targetSdkVersion >= Build . VERSION_CODES . R ) { return false ; } ViewCompat . setOnApplyWindowInsetsListener ( viewPager , new WindowInsetsApplier ( ) ) ; return true ;", "output": "} @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat insets ) { ViewPager2 viewPager = ( ViewPager2 ) v ; final WindowInsetsCompat applied = ViewCompat . onApplyWindowInsets ( viewPager , insets ) ; if ( applied . isConsumed ( ) ) { return applied ; } final RecyclerView rv = viewPager . mRecyclerView ; for ( int i = <NUM_LIT> , count = rv . getChildCount ( ) ; i < count ; i ++ ) { ViewCompat . dispatchApplyWindowInsets ( rv . getChildAt ( i ) , new WindowInsetsCompat ( applied ) ) ; } return consumeAllInsets ( applied ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private WindowInsetsCompat consumeAllInsets ( @ NonNull WindowInsetsCompat insets ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { if ( WindowInsetsCompat . CONSUMED . toWindowInsets ( ) != null ) { return WindowInsetsCompat . CONSUMED ; } return insets . consumeSystemWindowInsets ( ) . consumeStableInsets ( ) ; } return insets ; } }"}, {"input": "package com . gw . swipeback . tools ; import android . app . Activity ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewGroup ; import android . webkit . WebView ; import android . widget . AbsListView ; import android . widget . HorizontalScrollView ; import android . widget . ScrollView ; import androidx . core . view . ViewCompat ; import androidx . core . widget . NestedScrollView ; import androidx . recyclerview . widget . RecyclerView ; import androidx . viewpager . widget . ViewPager ; public class Util { public static boolean canViewScrollUp ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollVertically ( mView , - <NUM_LIT> ) ; } public static boolean canViewScrollDown ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollVertically ( mView , <NUM_LIT> ) ; } public static boolean canViewScrollRight ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollHorizontally ( mView , - <NUM_LIT> ) ; } public static boolean canViewScrollLeft ( View mView , float x , float y , boolean defaultValueForNull ) { if ( mView == null || ! contains ( mView , x , y ) ) { return defaultValueForNull ; } return ViewCompat . canScrollHorizontally ( mView , <NUM_LIT> ) ; } public static View findAllScrollViews ( ViewGroup mViewGroup ) { for ( int i = <NUM_LIT> ; i < mViewGroup . getChildCount ( ) ; i ++ ) {", "output": "View mView = mViewGroup . getChildAt ( i ) ; if ( mView . getVisibility ( ) != View . VISIBLE ) { continue ; } if ( isScrollableView ( mView ) ) { return mView ; } if ( mView instanceof ViewGroup ) { mView = findAllScrollViews ( ( ViewGroup ) mView ) ; if ( mView != null ) { return mView ; } } } return null ; } public static boolean isScrollableView ( View mView ) { return mView instanceof ScrollView || mView instanceof HorizontalScrollView || mView instanceof NestedScrollView || mView instanceof AbsListView || mView instanceof RecyclerView || mView instanceof ViewPager || mView instanceof WebView ; } public static boolean contains ( View mView , float x , float y ) { Rect localRect = new Rect ( ) ; mView . getGlobalVisibleRect ( localRect ) ; return localRect . contains ( ( int ) x , ( int ) y ) ; } public static void onPanelSlide ( float fraction ) { Activity activity = WxSwipeBackActivityManager . getInstance ( ) . getPenultimateActivity ( ) ; if ( activity != null && ! activity . isFinishing ( ) ) { View decorView = activity . getWindow ( ) . getDecorView ( ) ; ViewCompat . setTranslationX ( decorView , - ( decorView . getMeasuredWidth ( ) / <NUM_LIT> ) * ( <NUM_LIT> - fraction ) ) ; } } public static void onPanelReset ( ) { Activity activity = WxSwipeBackActivityManager . getInstance ( ) . getPenultimateActivity ( ) ; if ( activity != null ) { View decorView = activity . getWindow ( ) . getDecorView ( ) ; ViewCompat . setTranslationX ( decorView , <NUM_LIT> ) ; } } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . RecyclerView . Adapter . StateRestorationPolicy . PREVENT_WHEN_EMPTY ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView . Adapter ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; class NestedAdapterWrapper { @ NonNull private final ViewTypeStorage . ViewTypeLookup mViewTypeLookup ; @ NonNull private final StableIdStorage . StableIdLookup mStableIdLookup ; public final Adapter < ViewHolder > adapter ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Callback mCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mCachedItemCount ; private RecyclerView . AdapterDataObserver mAdapterObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { mCachedItemCount = adapter . getItemCount ( ) ; mCallback . onChanged ( NestedAdapterWrapper . this ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , null ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { mCallback . onItemRangeChanged ( NestedAdapterWrapper . this , positionStart , itemCount , payload ) ;", "output": "} @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { mCachedItemCount += itemCount ; mCallback . onItemRangeInserted ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount > <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { mCachedItemCount -= itemCount ; mCallback . onItemRangeRemoved ( NestedAdapterWrapper . this , positionStart , itemCount ) ; if ( mCachedItemCount < <NUM_LIT> && adapter . getStateRestorationPolicy ( ) == PREVENT_WHEN_EMPTY ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { Preconditions . checkArgument ( itemCount == <NUM_LIT> , \"<STR_LIT>\" ) ; mCallback . onItemRangeMoved ( NestedAdapterWrapper . this , fromPosition , toPosition ) ; } @ Override public void onStateRestorationPolicyChanged ( ) { mCallback . onStateRestorationPolicyChanged ( NestedAdapterWrapper . this ) ; } } ; NestedAdapterWrapper ( Adapter < ViewHolder > adapter , final Callback callback , ViewTypeStorage viewTypeStorage , StableIdStorage . StableIdLookup stableIdLookup ) { this . adapter = adapter ; mCallback = callback ; mViewTypeLookup = viewTypeStorage . createViewTypeWrapper ( this ) ; mStableIdLookup = stableIdLookup ; mCachedItemCount = this . adapter . getItemCount ( ) ; this . adapter . registerAdapterDataObserver ( mAdapterObserver ) ; } void dispose ( ) { adapter . unregisterAdapterDataObserver ( mAdapterObserver ) ; mViewTypeLookup . dispose ( ) ; } int getCachedItemCount ( ) { return mCachedItemCount ; } int getItemViewType ( int localPosition ) { return mViewTypeLookup . localToGlobal ( adapter . getItemViewType ( localPosition ) ) ; } ViewHolder onCreateViewHolder ( ViewGroup parent , int globalViewType ) { int localType = mViewTypeLookup . globalToLocal ( globalViewType ) ; return adapter . onCreateViewHolder ( parent , localType ) ; } void onBindViewHolder ( ViewHolder viewHolder , int localPosition ) { adapter . bindViewHolder ( viewHolder , localPosition ) ; } public long getItemId ( int localPosition ) { long localItemId = adapter . getItemId ( localPosition ) ; return mStableIdLookup . localToGlobal ( localItemId ) ; } interface Callback { void onChanged ( @ NonNull NestedAdapterWrapper wrapper ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeChanged ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount , @ Nullable Object payload ) ; void onItemRangeInserted ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeRemoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int positionStart , int itemCount ) ; void onItemRangeMoved ( @ NonNull NestedAdapterWrapper nestedAdapterWrapper , int fromPosition , int toPosition ) ; void onStateRestorationPolicyChanged ( NestedAdapterWrapper nestedAdapterWrapper ) ; } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . content . Context ; import androidx . core . content . ContextCompat ; import androidx . core . content . res . ResourcesCompat ; import org . woheller69 . weather . database . WeekForecast ; import androidx . recyclerview . widget . RecyclerView ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . SQLiteHelper ; import org . woheller69 . weather . ui . Help . StringFormatUtils ; import org . woheller69 . weather . ui . UiResourceProvider ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . TimeZone ; public class WeekWeatherAdapter extends RecyclerView . Adapter < WeekWeatherAdapter . WeekForecastViewHolder > { private Context context ; private List < WeekForecast > weekForecastList ; private int cityID ; private Date courseOfDayHeaderDate ; WeekWeatherAdapter ( Context context , List < WeekForecast > weekForecastList , int cityID ) { this . context = context ; this . cityID = cityID ; this . weekForecastList = weekForecastList ; if ( weekForecastList != null && ! weekForecastList . isEmpty ( ) ) { this . courseOfDayHeaderDate = new Date ( weekForecastList . get ( <NUM_LIT> ) . getLocalForecastTime ( context ) ) ; } else this . courseOfDayHeaderDate = new Date ( ) ; } public void setCourseOfDayHeaderDate ( Date courseOfDayHeaderDate ) { Date oldDate = this . courseOfDayHeaderDate ; this . courseOfDayHeaderDate = courseOfDayHeaderDate ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; c . setTime ( oldDate ) ; int oldDay = c . get ( Calendar . DAY_OF_MONTH ) ; c . setTime ( courseOfDayHeaderDate ) ; int newDay = c . get ( Calendar . DAY_OF_MONTH ) ; if ( newDay != oldDay ) { notifyDataSetChanged ( ) ; } } @ Override public WeekForecastViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . list_item_week_forecast , parent , false ) ; return new WeekForecastViewHolder ( view ) ; } @ Override public void onBindViewHolder ( WeekForecastViewHolder holder , int position ) { WeekForecast weekForecast = weekForecastList . get ( position ) ; SQLiteHelper dbHelper = SQLiteHelper . getInstance ( context ) ; CurrentWeatherData currentWeather = dbHelper . getCurrentWeatherByCityId ( cityID ) ; Calendar forecastTime = Calendar . getInstance ( ) ; forecastTime . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; forecastTime . setTimeInMillis ( weekForecast . getLocalForecastTime ( context ) ) ; boolean isDay ; if ( currentWeather . getTimeSunrise ( ) == <NUM_LIT> || currentWeather . getTimeSunset ( ) == <NUM_LIT> ) { if ( ( dbHelper . getCityToWatch ( cityID ) . getLatitude ( ) ) > <NUM_LIT> ) { isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) >= <NUM_LIT> && forecastTime . get ( Calendar . DAY_OF_YEAR ) <= <NUM_LIT> ; } else {", "output": "isDay = forecastTime . get ( Calendar . DAY_OF_YEAR ) < <NUM_LIT> || forecastTime . get ( Calendar . DAY_OF_YEAR ) > <NUM_LIT> ; } } else { isDay = true ; } setIcon ( weekForecast . getWeatherID ( ) , holder . weather , isDay ) ; holder . windicon . setImageResource ( StringFormatUtils . colorWindSpeedWidget ( weekForecast . getWind_speed ( ) ) ) ; if ( weekForecast . getPrecipitation ( ) == <NUM_LIT> ) holder . precipitation . setText ( \"<STR_LIT>\" ) ; else holder . precipitation . setText ( StringFormatUtils . formatPrecipitation ( context , weekForecast . getPrecipitation ( ) ) ) ; if ( weekForecast . getUv_index ( ) == - <NUM_LIT> ) { holder . uv_index . setVisibility ( View . GONE ) ; } else { holder . uv_index . setVisibility ( View . VISIBLE ) ; holder . uv_index . setText ( String . format ( \"<STR_LIT>\" , StringFormatUtils . formatInt ( Math . round ( weekForecast . getUv_index ( ) ) ) ) ) ; holder . uv_index . setBackground ( StringFormatUtils . colorUVindex ( context , Math . round ( weekForecast . getUv_index ( ) ) ) ) ; } holder . wind_speed . setText ( StringFormatUtils . formatWindSpeed ( context , weekForecast . getWind_speed ( ) ) ) ; holder . wind_speed . setBackground ( StringFormatUtils . colorWindSpeed ( context , weekForecast . getWind_speed ( ) ) ) ; holder . sunshine_hours . setText ( \"<STR_LIT>\" + Math . round ( weekForecast . getSunshineHours ( ) ) + \"<STR_LIT>\" + context . getString ( R . string . units_hours ) ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeZone ( TimeZone . getTimeZone ( \"<STR_LIT>\" ) ) ; c . setTimeInMillis ( weekForecast . getLocalForecastTime ( context ) ) ; int day = c . get ( Calendar . DAY_OF_WEEK ) ; holder . day . setText ( StringFormatUtils . getDayShort ( day ) ) ; holder . temperature_max . setText ( StringFormatUtils . formatTemperature ( context , weekForecast . getMaxTemperature ( ) ) ) ; holder . temperature_min . setText ( StringFormatUtils . formatTemperature ( context , weekForecast . getMinTemperature ( ) ) ) ; day = c . get ( Calendar . DAY_OF_MONTH ) ; c . setTimeInMillis ( courseOfDayHeaderDate . getTime ( ) ) ; int dayheader = c . get ( Calendar . DAY_OF_MONTH ) ; if ( dayheader == day ) { holder . itemView . setBackground ( ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_highlight , null ) ) ; } else { holder . itemView . setBackground ( ResourcesCompat . getDrawable ( context . getResources ( ) , R . drawable . rounded_transparent , null ) ) ; } } @ Override public int getItemCount ( ) { if ( weekForecastList != null && ! weekForecastList . isEmpty ( ) ) return weekForecastList . size ( ) ; else return <NUM_LIT> ; } class WeekForecastViewHolder extends RecyclerView . ViewHolder { TextView day ; ImageView weather ; TextView temperature_max ; TextView temperature_min ; TextView wind_speed ; TextView precipitation ; TextView uv_index ; TextView sunshine_hours ; ImageView windicon ; WeekForecastViewHolder ( View itemView ) { super ( itemView ) ; day = itemView . findViewById ( R . id . week_forecast_day ) ; weather = itemView . findViewById ( R . id . week_forecast_weather ) ; temperature_max = itemView . findViewById ( R . id . week_forecast_temperature_max ) ; temperature_max . setTextColor ( ContextCompat . getColor ( context , R . color . red ) ) ; temperature_min = itemView . findViewById ( R . id . week_forecast_temperature_min ) ; temperature_min . setTextColor ( ContextCompat . getColor ( context , R . color . midblue ) ) ; wind_speed = itemView . findViewById ( R . id . week_forecast_wind_speed ) ; precipitation = itemView . findViewById ( R . id . week_forecast_precipitation ) ; uv_index = itemView . findViewById ( R . id . week_forecast_uv_index ) ; windicon = itemView . findViewById ( R . id . week_forecast_wind_icon ) ; sunshine_hours = itemView . findViewById ( R . id . week_forecast_sunshine_hours ) ; } } @ Override public void onAttachedToRecyclerView ( RecyclerView recyclerView ) { super . onAttachedToRecyclerView ( recyclerView ) ; } public void setIcon ( int value , ImageView imageView , boolean isDay ) { imageView . setImageResource ( UiResourceProvider . getIconResourceForWeatherCategory ( value , isDay ) ) ; } }"}, {"input": "package de . robv . android . xposed . services ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; public final class DirectAccessService extends BaseService { @ Override public boolean hasDirectFileAccess ( ) { return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public boolean checkFileAccess ( String filename , int mode ) { File file = new File ( filename ) ; if ( mode == F_OK && ! file . exists ( ) ) return false ; if ( ( mode & R_OK ) != <NUM_LIT> && ! file . canRead ( ) ) return false ; if ( ( mode & W_OK ) != <NUM_LIT> && ! file . canWrite ( ) ) return false ; if ( ( mode & X_OK ) != <NUM_LIT> && ! file . canExecute ( ) ) return false ; return true ; } @ Override public boolean checkFileExists ( String filename ) { return new File ( filename ) . exists ( ) ; } @ Override public FileResult statFile ( String filename ) throws IOException { File file = new File ( filename ) ; return new FileResult ( file . length ( ) , file . lastModified ( ) ) ; } @ Override public byte [ ] readFile ( String filename ) throws IOException { File file = new File ( filename ) ; byte content [ ] = new byte [ ( int ) file . length ( ) ] ; FileInputStream fis = new FileInputStream ( file ) ; fis . read ( content ) ; fis . close ( ) ; return content ; } @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; return new FileResult ( readFile ( filename ) , size , time ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; if ( offset <= <NUM_LIT> && length <= <NUM_LIT> ) return new FileResult ( readFile ( filename ) , size , time ) ; if ( offset > <NUM_LIT> && offset >= size ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + offset + \"<STR_LIT>\" + filename ) ; } else if ( offset < <NUM_LIT> ) { offset = <NUM_LIT> ; } if ( length > <NUM_LIT> && ( offset + length ) > size ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + length + \"<STR_LIT>\" + filename ) ; }", "output": "else if ( length <= <NUM_LIT> ) { length = ( int ) ( size - offset ) ; } byte content [ ] = new byte [ length ] ; FileInputStream fis = new FileInputStream ( file ) ; fis . skip ( offset ) ; fis . read ( content ) ; fis . close ( ) ; return new FileResult ( content , size , time ) ; } @ Override public InputStream getFileInputStream ( String filename ) throws IOException { return new BufferedInputStream ( new FileInputStream ( filename ) , <NUM_LIT> * <NUM_LIT> ) ; } @ Override public FileResult getFileInputStream ( String filename , long previousSize , long previousTime ) throws IOException { File file = new File ( filename ) ; long size = file . length ( ) ; long time = file . lastModified ( ) ; if ( previousSize == size && previousTime == time ) return new FileResult ( size , time ) ; return new FileResult ( new BufferedInputStream ( new FileInputStream ( filename ) , <NUM_LIT> * <NUM_LIT> ) , size , time ) ; } }"}, {"input": "package com . norman . webviewup . lib . util ; import android . text . TextUtils ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class FileUtils { public static void delete ( String path ) { delete ( new File ( path ) ) ; } public static void delete ( File file ) { if ( file . isFile ( ) ) { file . delete ( ) ; return ; } if ( file . isDirectory ( ) ) { File [ ] childFile = file . listFiles ( ) ; if ( childFile == null || childFile . length == <NUM_LIT> ) { file . delete ( ) ; return ; } for ( File f : childFile ) { delete ( f ) ; } file . delete ( ) ; } } public static void cleanDirectory ( String path ) { cleanDirectory ( new File ( path ) ) ; } public static void cleanDirectory ( File file ) { if ( file . isDirectory ( ) ) { File [ ] childFile = file . listFiles ( ) ; if ( childFile == null || childFile . length == <NUM_LIT> ) { return ; } for ( File f : childFile ) { delete ( f ) ; } } } public static void makeDirectory ( String path ) { makeDirectory ( new File ( path ) ) ; } public static void makeDirectory ( File file ) { if ( file != null && ! file . exists ( ) ) { file . mkdirs ( ) ; } } public static void moveFile ( File srcFile , File outputFile ) { boolean rename = srcFile . renameTo ( outputFile ) ; if ( ! rename ) { copyFile ( srcFile , outputFile ) ; delete ( srcFile ) ; } } public static void copyFile ( File srcFile , File outputFile ) { FileInputStream fileInputStream ; try { fileInputStream = new FileInputStream ( srcFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( fileInputStream , outputFile , true ) ; } public static void copyFile ( String srcPath , String outputPath ) { copyFile ( new File ( srcPath ) , new File ( outputPath ) ) ; } public static void copyFile ( File srcFile , FileOutputStream fileOutputStream , boolean close ) { FileInputStream fileInputStream ; try { fileInputStream = new FileInputStream ( srcFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( fileInputStream , fileOutputStream , true , close ) ; } public static void copyFile ( InputStream inputStream , File outputFile , boolean close ) { FileUtils . makeDirectory ( outputFile . getParentFile ( ) ) ; if ( ! outputFile . exists ( ) ) { try { outputFile . createNewFile ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } FileOutputStream fileOutputStream ; try { fileOutputStream = new FileOutputStream ( outputFile ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } copyFile ( inputStream , fileOutputStream , close , true ) ; } public static void copyFile ( InputStream inputStream , OutputStream outputStream , boolean close ) { copyFile ( inputStream , outputStream , close , close ) ; } public static void copyFile ( InputStream inputStream , OutputStream outputStream , boolean inputClose , boolean outputClose ) { BufferedInputStream bufferedInput = null ; BufferedOutputStream bufferedOutput = null ; try { byte [ ] buffer = new byte [ <NUM_LIT> ] ; bufferedInput = new BufferedInputStream ( inputStream ) ; bufferedOutput = new BufferedOutputStream ( outputStream ) ; int count ; while ( ( count = bufferedInput . read ( buffer ) ) > <NUM_LIT> ) { bufferedOutput . write ( buffer , <NUM_LIT> , count ) ; } bufferedOutput . flush ( ) ;", "output": "} catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } finally { try { if ( inputClose && bufferedInput != null ) { bufferedInput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( outputClose && bufferedOutput != null ) { bufferedOutput . close ( ) ; } } catch ( IOException ignore ) { } } } public static boolean existDirectory ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isDirectory ( ) && file . exists ( ) ; } public static boolean existFile ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isFile ( ) && file . exists ( ) ; } public static boolean exist ( File file ) { if ( file == null ) { return false ; } return file . exists ( ) ; } public static boolean isNotEmpty ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return false ; } File file = new File ( path ) ; return file . isFile ( ) && file . exists ( ) && file . length ( ) != <NUM_LIT> ; } public static boolean createFile ( File file ) { if ( file != null && ! file . exists ( ) ) { makeDirectory ( file . getParentFile ( ) ) ; try { return file . createNewFile ( ) ; } catch ( IOException ignore ) { return false ; } } return true ; } public static boolean createFile ( String path ) { return createFile ( new File ( path ) ) ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import android . graphics . Rect ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; public class SystemUI { public static boolean isImeVisible ( @ NonNull View view ) { WindowInsetsCompat insetsCompat = ViewCompat . getRootWindowInsets ( view ) ; assert insetsCompat != null ; return insetsCompat . isVisible ( WindowInsetsCompat . Type . ime ( ) ) ; }", "output": "public static int imeHeight ( @ NonNull View view ) { WindowInsetsCompat insetsCompat = ViewCompat . getRootWindowInsets ( view ) ; assert insetsCompat != null ; return insetsCompat . getInsets ( WindowInsetsCompat . Type . ime ( ) ) . bottom ; } public static EdgeInsets getEdgeInsetsForView ( @ NonNull View view ) { ViewGroup root = ( ViewGroup ) view . getRootView ( ) ; int windowHeight = root . getHeight ( ) ; int windowWidth = root . getWidth ( ) ; Rect offset = new Rect ( ) ; view . getDrawingRect ( offset ) ; root . offsetDescendantRectToMyCoords ( view , offset ) ; int leftMargin = <NUM_LIT> ; int topMargin = <NUM_LIT> ; int rightMargin = <NUM_LIT> ; int bottomMargin = <NUM_LIT> ; if ( view . getLayoutParams ( ) instanceof ViewGroup . MarginLayoutParams ) { ViewGroup . MarginLayoutParams lp = ( ViewGroup . MarginLayoutParams ) view . getLayoutParams ( ) ; leftMargin = lp . leftMargin ; topMargin = lp . topMargin ; rightMargin = lp . rightMargin ; bottomMargin = lp . bottomMargin ; } EdgeInsets insets = new EdgeInsets ( ) ; insets . left = Math . max ( offset . left - leftMargin , <NUM_LIT> ) ; insets . top = Math . max ( offset . top - topMargin , <NUM_LIT> ) ; insets . right = Math . max ( windowWidth - offset . right - rightMargin , <NUM_LIT> ) ; insets . bottom = Math . max ( windowHeight - offset . bottom - bottomMargin , <NUM_LIT> ) ; return insets ; } }"}, {"input": "package androidx . fluidviewpager2 . adapter ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . RecyclerView . ViewHolder ; import androidx . fragment . app . Fragment ; public final class FragmentViewHolder extends ViewHolder { private FragmentViewHolder ( @ NonNull FrameLayout container ) { super ( container ) ; } @ NonNull static FragmentViewHolder create ( @ NonNull ViewGroup parent ) { FrameLayout container = new FrameLayout ( parent . getContext ( ) ) ;", "output": "container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; container . setId ( View . generateViewId ( ) ) ; container . setSaveEnabled ( false ) ; return new FragmentViewHolder ( container ) ; } @ NonNull FrameLayout getContainer ( ) { return ( FrameLayout ) itemView ; } }"}, {"input": "package com . wmods . wppenhacer . ui . fragments . base ; import android . annotation . SuppressLint ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . preference . PreferenceFragmentCompat ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . Objects ; import rikka . material . preference . MaterialSwitchPreference ; public abstract class BasePreferenceFragment extends PreferenceFragmentCompat implements SharedPreferences . OnSharedPreferenceChangeListener { protected SharedPreferences mPrefs ; @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { mPrefs = PreferenceManager . getDefaultSharedPreferences ( requireContext ( ) ) ; mPrefs . registerOnSharedPreferenceChangeListener ( this ) ; } @ NonNull @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { chanceStates ( null ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , @ Nullable String s ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; App . getInstance ( ) . sendBroadcast ( intent ) ; chanceStates ( s ) ; } private void setPreferenceState ( String key , boolean enabled ) {", "output": "var pref = findPreference ( key ) ; if ( pref != null ) { pref . setEnabled ( enabled ) ; if ( pref instanceof MaterialSwitchPreference && ! enabled ) { ( ( MaterialSwitchPreference ) pref ) . setChecked ( false ) ; } } } @ SuppressLint ( \"<STR_LIT>\" ) private void chanceStates ( String key ) { if ( Objects . equals ( key , \"<STR_LIT>\" ) ) { var mode = Integer . parseInt ( mPrefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; App . setThemeMode ( mode ) ; } if ( Objects . equals ( key , \"<STR_LIT>\" ) ) { mPrefs . edit ( ) . commit ( ) ; Utils . doRestart ( requireContext ( ) ) ; } var igstatus = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; var verticalstatus = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! igstatus ) ; var oldstatus = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! oldstatus ) ; setPreferenceState ( \"<STR_LIT>\" , ! oldstatus ) ; setPreferenceState ( \"<STR_LIT>\" , ! oldstatus ) ; setPreferenceState ( \"<STR_LIT>\" , ! ( oldstatus || verticalstatus ) ) ; setPreferenceState ( \"<STR_LIT>\" , ! oldstatus ) ; var channels = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! channels && ! oldstatus ) ; var freezelastseen = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! freezelastseen ) ; var separategroups = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! separategroups ) ; var filtergroups = mPrefs . getBoolean ( \"<STR_LIT>\" , false ) ; setPreferenceState ( \"<STR_LIT>\" , ! filtergroups ) ; var callBlockContacts = findPreference ( \"<STR_LIT>\" ) ; var callWhiteContacts = findPreference ( \"<STR_LIT>\" ) ; if ( callBlockContacts != null && callWhiteContacts != null ) { var callType = Integer . parseInt ( mPrefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; switch ( callType ) { case <NUM_LIT> : callBlockContacts . setEnabled ( true ) ; callWhiteContacts . setEnabled ( false ) ; break ; case <NUM_LIT> : callWhiteContacts . setEnabled ( true ) ; callBlockContacts . setEnabled ( false ) ; break ; default : callWhiteContacts . setEnabled ( false ) ; callBlockContacts . setEnabled ( false ) ; break ; } } } }"}, {"input": "package com . skythinker . gptassistant ; import java . io . Serializable ; import java . util . Arrays ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONObject ; public class PromptTabData implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String tabTitle ; private String prompt ; public PromptTabData ( String tabTitle , String prompt ) { this . tabTitle = tabTitle ; this . prompt = prompt ; } public String getTitle ( ) { return tabTitle ; } public void setTitle ( String tabTitle ) { this . tabTitle = tabTitle ; } public String getPrompt ( ) { return prompt ; } public void setPrompt ( String prompt ) { this . prompt = prompt ; } public JSONObject parseParams ( ) { JSONObject params = new JSONObject ( ) ; try { Matcher headerMatcher = Pattern . compile ( \"<STR_LIT>\" ) . matcher ( prompt ) ; if ( headerMatcher . find ( ) ) { Matcher lineMatcher = Pattern . compile ( \"<STR_LIT>\" , Pattern . MULTILINE ) . matcher ( headerMatcher . group ( <NUM_LIT> ) ) ; JSONObject inputObject = new JSONObject ( ) ; while ( lineMatcher . find ( ) ) { String name = lineMatcher . group ( <NUM_LIT> ) ; String value = lineMatcher . group ( <NUM_LIT> ) ; if ( name == null || value == null ) continue ; value = value . trim ( ) ; if ( name . equals ( \"<STR_LIT>\" ) ) { params . putOpt ( name , value ) ; } else if ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) . contains ( name ) ) { params . putOpt ( name , value . equals ( \"<STR_LIT>\" ) ) ; } else if ( name . equals ( \"<STR_LIT>\" ) ) { inputObject . putOpt ( value , new JSONObject ( ) . putOpt ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } else if ( name . equals ( \"<STR_LIT>\" ) ) { String [ ] selectParams = value . split ( \"<STR_LIT>\" ) ; if ( selectParams . length > <NUM_LIT> ) { JSONArray itemsArray = new JSONArray ( ) ; for ( int i = <NUM_LIT> ; i < selectParams . length ; i ++ ) { String item = selectParams [ i ] . trim ( ) ; JSONObject itemObject = new JSONObject ( ) ; Matcher itemMatcher = Pattern . compile ( \"<STR_LIT>\" ) . matcher ( item ) ; if ( itemMatcher . find ( ) ) { itemObject . putOpt ( \"<STR_LIT>\" , itemMatcher . group ( <NUM_LIT> ) ) ; itemObject . putOpt ( \"<STR_LIT>\" , itemMatcher . group ( <NUM_LIT> ) ) ; } else { itemObject . putOpt ( \"<STR_LIT>\" , item ) ;", "output": "itemObject . putOpt ( \"<STR_LIT>\" , item ) ; } itemsArray . put ( itemObject ) ; } inputObject . putOpt ( selectParams [ <NUM_LIT> ] . trim ( ) , new JSONObject ( ) . putOpt ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . putOpt ( \"<STR_LIT>\" , itemsArray ) ) ; } } } if ( inputObject . size ( ) > <NUM_LIT> ) params . putOpt ( \"<STR_LIT>\" , inputObject ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return params ; } public String getContentWithoutParams ( ) { return prompt . replaceFirst ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public String getFormattedPrompt ( JSONObject inputValues ) { JSONObject inputParams = parseParams ( ) . getJSONObject ( \"<STR_LIT>\" ) ; String template = getContentWithoutParams ( ) ; if ( inputParams != null ) { for ( String key : inputValues . keySet ( ) ) { JSONObject paramObject = inputParams . getJSONObject ( key ) ; if ( paramObject != null ) { if ( paramObject . getStr ( \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { JSONArray items = paramObject . getJSONArray ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < items . size ( ) ; i ++ ) { JSONObject item = items . getJSONObject ( i ) ; if ( item . getStr ( \"<STR_LIT>\" ) . equals ( inputValues . getStr ( key ) ) ) { template = template . replace ( \"<STR_LIT>\" + key + \"<STR_LIT>\" , item . getStr ( \"<STR_LIT>\" ) ) ; break ; } } } else if ( paramObject . getStr ( \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { template = template . replace ( \"<STR_LIT>\" + key + \"<STR_LIT>\" , inputValues . getStr ( key ) ) ; } } } } return template ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . fragment . app . Fragment ; public class LoadingHistoryCommentFragment extends Fragment { private View rootView ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate ( R . layout . fragment_loading_history_comment , container , false ) ; return rootView ;", "output": "} }"}, {"input": "package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . NonNull ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; public class ParcelableFileTransferEvent extends FileTransferEvent implements Parcelable { public ParcelableFileTransferEvent ( FileTransferEvent event ) { super ( event . getState ( ) , event . getDevice ( ) , event . getDesc ( ) ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( this . state ) ; dest . writeInt ( this . device ) ; dest . writeString ( this . desc ) ; } public void readFromParcel ( Parcel source ) { this . state = source . readInt ( ) ; this . device = source . readInt ( ) ; this . desc = source . readString ( ) ; } protected ParcelableFileTransferEvent ( Parcel in ) { super ( in . readInt ( ) , in . readInt ( ) , in . readString ( ) ) ; } public static final Creator < ParcelableFileTransferEvent > CREATOR = new Creator < ParcelableFileTransferEvent > ( ) { @ Override public ParcelableFileTransferEvent createFromParcel ( Parcel source ) { return new ParcelableFileTransferEvent ( source ) ; }", "output": "@ Override public ParcelableFileTransferEvent [ ] newArray ( int size ) { return new ParcelableFileTransferEvent [ size ] ; } } ; }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . threads ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . Socket ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . LinkedBlockingDeque ; import top . weixiansen574 . hybridfilexfer . core . ControllerIdentifiers ; import top . weixiansen574 . hybridfilexfer . core . JobPublisher ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . core . ServerInfo ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferJob ; public class ClientControllerThread extends Thread implements TransferThread . OnExceptionListener { Socket controllerSocket ; DataInputStream dis ; DataOutputStream dos ; ReceiveThread usbReceiveThread ; ReceiveThread wifiReceiveThread ; JobPublisher jobPublisher ; SendThread usbSendThread ; SendThread wifiSendThread ; public ClientControllerThread ( ) { jobPublisher = new JobPublisher ( ) ; } @ Override public void run ( ) { try { controllerSocket = new Socket ( InetAddress . getLoopbackAddress ( ) , ServerInfo . PORT_CONTROLLER ) ; dis = new DataInputStream ( controllerSocket . getInputStream ( ) ) ; dos = new DataOutputStream ( controllerSocket . getOutputStream ( ) ) ; InetAddress serverWifiAddress ; try { serverWifiAddress = getServerWifiAddress ( ) ; } catch ( IOException e ) { System . out . println ( \"<STR_LIT>\" ) ; return ; } if ( Arrays . equals ( serverWifiAddress . getAddress ( ) , new byte [ <NUM_LIT> ] ) ) { System . out . println ( \"<STR_LIT>\" ) ; return ; } Socket wifiSocket ; try { wifiSocket = new Socket ( serverWifiAddress , ServerInfo . PORT_WIFI ) ; } catch ( IOException e ) { System . out . println ( \"<STR_LIT>\" + serverWifiAddress . getHostAddress ( ) + \"<STR_LIT>\" ) ; return ; } Socket usbSocket = new Socket ( InetAddress . getLoopbackAddress ( ) , ServerInfo . PORT_USB ) ; usbReceiveThread = new ReceiveThread ( null , ReceiveThread . DEVICE_USB , usbSocket . getInputStream ( ) ) ; usbReceiveThread . setName ( \"<STR_LIT>\" ) ; usbReceiveThread . setOnExceptionListener ( this ) ; usbReceiveThread . start ( ) ; wifiReceiveThread = new ReceiveThread ( null , ReceiveThread . DEVICE_WIFI , wifiSocket . getInputStream ( ) ) ; wifiReceiveThread . setName ( \"<STR_LIT>\" ) ; wifiReceiveThread . setOnExceptionListener ( this ) ; wifiReceiveThread . start ( ) ; usbSendThread = new SendThread ( null , SendThread . DEVICE_USB , jobPublisher , usbSocket . getOutputStream ( ) ) ; usbSendThread . setName ( \"<STR_LIT>\" ) ; usbSendThread . setOnExceptionListener ( this ) ; usbSendThread . start ( ) ; wifiSendThread = new SendThread ( null , SendThread . DEVICE_WIFI , jobPublisher , wifiSocket . getOutputStream ( ) ) ; wifiSendThread . setName ( \"<STR_LIT>\" ) ; wifiSendThread . setOnExceptionListener ( this ) ; wifiSendThread . start ( ) ; System . out . println ( \"<STR_LIT>\" + serverWifiAddress . getHostAddress ( ) ) ; waitingForRequest ( ) ; } catch ( IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; onException ( e ) ; } } private InetAddress getServerWifiAddress ( ) throws IOException { dos . writeShort ( ControllerIdentifiers . GET_WLAN_ADDRESS ) ; byte [ ] wlanV4AddressBytes = new byte [ <NUM_LIT> ] ; dis . readFully ( wlanV4AddressBytes ) ; return Inet4Address . getByAddress ( wlanV4AddressBytes ) ; } private void waitingForRequest ( ) throws IOException , ClassNotFoundException {", "output": "w : while ( true ) { short identifiers = dis . readShort ( ) ; switch ( identifiers ) { case ControllerIdentifiers . LIST_FILES : String path = dis . readUTF ( ) ; System . out . println ( \"<STR_LIT>\" + path ) ; handleListFiles ( path ) ; break ; case ControllerIdentifiers . TRANSPORT_FILES : String serverDir = dis . readUTF ( ) ; String dir = dis . readUTF ( ) ; int listSize = dis . readInt ( ) ; List < String > toTransferFilePaths = new ArrayList < > ( listSize ) ; for ( int i = <NUM_LIT> ; i < listSize ; i ++ ) { toTransferFilePaths . add ( dis . readUTF ( ) ) ; } handleTransferFileToServer ( serverDir , dir , toTransferFilePaths ) ; break ; case ControllerIdentifiers . SHUTDOWN : System . out . println ( \"<STR_LIT>\" ) ; usbSendThread . shutdown ( ) ; wifiSendThread . shutdown ( ) ; try { usbSendThread . join ( ) ; wifiSendThread . join ( ) ; usbReceiveThread . join ( ) ; wifiReceiveThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } controllerSocket . close ( ) ; break w ; } } } private void handleListFiles ( String path ) throws IOException { ArrayList < RemoteFile > files = new ArrayList < > ( ) ; if ( ! path . equals ( \"<STR_LIT>\" ) ) { File file = new File ( path ) ; File [ ] list = file . listFiles ( ) ; if ( list != null ) { for ( File file1 : list ) { files . add ( new RemoteFile ( file1 ) ) ; } } } else { File [ ] roots = File . listRoots ( ) ; if ( roots . length == <NUM_LIT> && roots [ <NUM_LIT> ] . getAbsolutePath ( ) . equals ( \"<STR_LIT>\" ) ) { roots = roots [ <NUM_LIT> ] . listFiles ( ) ; if ( roots == null ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } for ( File root : roots ) { files . add ( new RemoteFile ( root . getName ( ) , root . getPath ( ) , root . lastModified ( ) , root . length ( ) , root . isDirectory ( ) ) ) ; } } else { for ( File root : roots ) { files . add ( new RemoteFile ( root . getPath ( ) , root . getPath ( ) , root . lastModified ( ) , root . length ( ) , root . isDirectory ( ) ) ) ; } } } dos . writeInt ( files . size ( ) ) ; for ( RemoteFile file : files ) { dos . writeUTF ( file . getName ( ) ) ; dos . writeUTF ( file . getPath ( ) ) ; dos . writeLong ( file . getLastModified ( ) ) ; dos . writeLong ( file . getSize ( ) ) ; dos . writeBoolean ( file . isDirectory ( ) ) ; } } private void handleTransferFileToServer ( String serverDir , String dir , List < String > remoteFiles ) { File localDir = new File ( dir ) ; List < File > transferFiles = new ArrayList < > ( ) ; for ( String remoteFile : remoteFiles ) { transferFiles . add ( new File ( remoteFile ) ) ; } jobPublisher . addJob ( new TransferJob ( localDir , serverDir , transferFiles ) ) ; } @ Override public void onException ( Exception e ) { System . exit ( - <NUM_LIT> ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . content . SharedPreferences ; import android . text . TextUtils ; import androidx . fragment . app . FragmentManager ; import com . simon . harmonichackernews . LoginDialogFragment ; import kotlin . Triple ; public class AccountUtils { private final static String KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME = \"<STR_LIT>\" ; private final static String KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD = \"<STR_LIT>\" ; public final static int FAILURE_MODE_NONE = - <NUM_LIT> ; public final static int FAILURE_MODE_MAINKEY = <NUM_LIT> ; public final static int FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION = <NUM_LIT> ; public final static int FAILURE_MODE_NO_USERNAME = <NUM_LIT> ; public final static int FAILURE_MODE_NO_PASSWORD = <NUM_LIT> ; public static String getAccountUsername ( Context ctx ) { return SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME ) ; } public static void setAccountUsername ( Context ctx , String username ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_UNENCRYPTED_SHARED_PREFERENCES_USERNAME , username ) ; } public static boolean hasAccountDetails ( Context ctx ) { Triple < String , String , Integer > account = getAccountDetails ( ctx ) ; return ( account . getThird ( ) == FAILURE_MODE_NONE && ! TextUtils . isEmpty ( account . getFirst ( ) ) && ! TextUtils . isEmpty ( account . getSecond ( ) ) ) ; } public static Triple < String , String , Integer > getAccountDetails ( Context ctx ) { SharedPreferences sharedPreferences ; try { sharedPreferences = EncryptedSharedPreferencesHelper . getEncryptedSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return new Triple < > ( null , null , FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION ) ; } String username = getAccountUsername ( ctx ) ; String password = sharedPreferences . getString ( KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD , null ) ; if ( TextUtils . isEmpty ( username ) || TextUtils . isEmpty ( password ) ) { Utils . log ( \"<STR_LIT>\" + TextUtils . isEmpty ( username ) + \"<STR_LIT>\" + TextUtils . isEmpty ( password ) ) ; } if ( TextUtils . isEmpty ( username ) ) { return new Triple < > ( username , password , FAILURE_MODE_NO_USERNAME ) ; } if ( TextUtils . isEmpty ( password ) ) { return new Triple < > ( username , password , FAILURE_MODE_NO_PASSWORD ) ; } return new Triple < > ( username , password , FAILURE_MODE_NONE ) ; } public static void deleteAccountDetails ( Context ctx ) { setAccountDetails ( ctx , null , null ) ; boolean deleted = EncryptedSharedPreferencesHelper . deleteSharedPreferences ( ctx ) ; if ( ! deleted ) { Utils . toast ( \"<STR_LIT>\" , ctx ) ; } }", "output": "public static void setAccountDetails ( Context ctx , String username , String password ) { SharedPreferences sharedPreferences ; try { sharedPreferences = EncryptedSharedPreferencesHelper . getEncryptedSharedPreferences ( ctx ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return ; } SharedPreferences . Editor sharedPrefsEditor = sharedPreferences . edit ( ) ; sharedPrefsEditor . putString ( KEY_ENCRYPTED_SHARED_PREFERENCES_PASSWORD , password ) ; sharedPrefsEditor . apply ( ) ; setAccountUsername ( ctx , username ) ; } public static void showLoginPrompt ( FragmentManager fm ) { new LoginDialogFragment ( ) . show ( fm , LoginDialogFragment . TAG ) ; } public static boolean handlePossibleError ( Triple < String , String , Integer > account , FragmentManager fm , Context ctx ) { if ( account . getThird ( ) == AccountUtils . FAILURE_MODE_NONE ) { return false ; } if ( fm != null ) { AccountUtils . showLoginPrompt ( fm ) ; } switch ( account . getThird ( ) ) { case AccountUtils . FAILURE_MODE_MAINKEY : Utils . toast ( \"<STR_LIT>\" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_ENCRYPTED_PREFERENCES_EXCEPTION : Utils . toast ( \"<STR_LIT>\" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_NO_USERNAME : Utils . toast ( \"<STR_LIT>\" , ctx ) ; break ; case AccountUtils . FAILURE_MODE_NO_PASSWORD : Utils . toast ( \"<STR_LIT>\" , ctx ) ; break ; } return true ; } }"}, {"input": "package com . simon . harmonichackernews . adapters ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . GradientDrawable ; import android . text . SpannableStringBuilder ; import android . text . Spanned ; import android . text . TextUtils ; import android . text . style . ImageSpan ; import android . util . TypedValue ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . inputmethod . EditorInfo ; import android . view . inputmethod . InputMethodManager ; import android . widget . AdapterView ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . Spinner ; import android . widget . TextView ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . TooltipCompat ; import androidx . core . content . ContextCompat ; import androidx . recyclerview . widget . RecyclerView ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . network . FaviconLoader ; import com . simon . harmonichackernews . utils . FontUtils ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . jetbrains . annotations . NotNull ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class StoryRecyclerViewAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { private final List < Story > stories ; private ClickListener typeClickListener ; private ClickListener linkClickListener ; private ClickListener commentClickListener ; private ClickListener commentRepliesClickListener ; private ClickListener commentStoryClickListener ; private SearchListener storiesSearchListener ; private RefreshListener refreshListener ; private View . OnClickListener moreClickListener ; private LongClickCoordinateListener longClickListener ; private final boolean atSubmissions ; private final String submitter ; private static final int TYPE_HEADER_MAIN = <NUM_LIT> ; private static final int TYPE_HEADER_SUBMISSIONS = <NUM_LIT> ; private static final int TYPE_STORY = <NUM_LIT> ; private static final int TYPE_COMMENT = <NUM_LIT> ; public boolean loadingFailed = false ; public boolean loadingFailedServerError = false ; public boolean showPoints ; public boolean showCommentsCount ; public boolean compactView ; public boolean thumbnails ; public boolean showIndex ; public boolean compactHeader ; public boolean leftAlign ; public String faviconProvider ; public int hotness ; public int type ; public boolean searching = false ; public String lastSearch = \"<STR_LIT>\" ; public StoryRecyclerViewAdapter ( List < Story > items , boolean shouldShowPoints , boolean shouldShowCommentsCount , boolean shouldUseCompactView , boolean shouldShowThumbnails , boolean shouldShowIndex , boolean shouldUseCompactHeader , boolean shouldLeftAlign , int preferredHotness , String faviconProv , String submissionsUserName , int wantedType ) { stories = items ; showPoints = shouldShowPoints ; showCommentsCount = shouldShowCommentsCount ; compactView = shouldUseCompactView ; thumbnails = shouldShowThumbnails ; showIndex = shouldShowIndex ; compactHeader = shouldUseCompactHeader ; leftAlign = shouldLeftAlign ; hotness = preferredHotness ; faviconProvider = faviconProv ; type = wantedType ; atSubmissions = ! TextUtils . isEmpty ( submissionsUserName ) ; submitter = submissionsUserName ; } @ NotNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NotNull ViewGroup parent , int viewType ) { if ( viewType == TYPE_STORY ) { return new StoryViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( leftAlign ? R . layout . story_list_item_left : R . layout . story_list_item , parent , false ) ) ; } else if ( viewType == TYPE_HEADER_MAIN ) { return new MainHeaderViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . stories_header , parent , false ) ) ; } else if ( viewType == TYPE_HEADER_SUBMISSIONS ) { return new SubmissionsHeaderViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . submissions_header , parent , false ) ) ; } else { return new CommentViewHolder ( LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . submissions_comment , parent , false ) ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onBindViewHolder ( @ NotNull final RecyclerView . ViewHolder holder , int position ) { if ( holder instanceof StoryViewHolder ) { final StoryViewHolder storyViewHolder = ( StoryViewHolder ) holder ; final Context ctx = storyViewHolder . itemView . getContext ( ) ; storyViewHolder . story = stories . get ( position ) ; if ( showIndex ) { storyViewHolder . indexTextView . setText ( position + \"<STR_LIT>\" ) ; if ( storyViewHolder . story . clicked ) { storyViewHolder . indexTextView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorDisabled ) ) ; } else { storyViewHolder . indexTextView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorNormal ) ) ; } if ( position < <NUM_LIT> ) { storyViewHolder . indexTextView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; storyViewHolder . indexTextView . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; } else { storyViewHolder . indexTextView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , <NUM_LIT> ) ; storyViewHolder . indexTextView . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; } } storyViewHolder . indexTextView . setVisibility ( showIndex ? View . VISIBLE : View . GONE ) ; if ( storyViewHolder . story . loaded || storyViewHolder . story . loadingFailed ) { if ( ! TextUtils . isEmpty ( storyViewHolder . story . pdfTitle ) ) { SpannableStringBuilder sb = new SpannableStringBuilder ( storyViewHolder . story . pdfTitle + \"<STR_LIT>\" ) ; ImageSpan imageSpan = new ImageSpan ( ctx , storyViewHolder . story . clicked ? R . drawable . ic_action_pdf_clicked : R . drawable . ic_action_pdf ) ; sb . setSpan ( imageSpan , sb . length ( ) - <NUM_LIT> , sb . length ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; storyViewHolder . titleView . setText ( sb ) ; } else { storyViewHolder . titleView . setText ( storyViewHolder . story . title ) ; } final String commentCountText ; if ( showCommentsCount ) { commentCountText = Integer . toString ( storyViewHolder . story . descendants ) ; } else if ( storyViewHolder . story . descendants > <NUM_LIT> ) { commentCountText = \"<STR_LIT>\" ; } else { commentCountText = \"<STR_LIT>\" ; } storyViewHolder . commentsView . setText ( commentCountText ) ; String host = \"<STR_LIT>\" ; try { if ( storyViewHolder . story . url != null ) { host = Utils . getDomainName ( storyViewHolder . story . url ) ; } } catch ( Exception e ) { host = \"<STR_LIT>\" ; } if ( showPoints && ! storyViewHolder . story . isComment ) { String ptsString = storyViewHolder . story . score == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ; storyViewHolder . metaView . setText ( storyViewHolder . story . score + ptsString + \"<STR_LIT>\" + host + \"<STR_LIT>\" + storyViewHolder . story . getTimeFormatted ( ) ) ; } else { storyViewHolder . metaView . setText ( host + \"<STR_LIT>\" + storyViewHolder . story . getTimeFormatted ( ) ) ; } if ( thumbnails ) { FaviconLoader . loadFavicon ( storyViewHolder . story . url , storyViewHolder . metaFavicon , ctx , faviconProvider ) ; } storyViewHolder . commentsIcon . setImageResource ( hotness > <NUM_LIT> && storyViewHolder . story . score + storyViewHolder . story . descendants > hotness ? R . drawable . ic_action_whatshot : R . drawable . ic_action_comment ) ; FontUtils . setTypeface ( storyViewHolder . titleView , true , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; FontUtils . setTypeface ( storyViewHolder . metaView , false , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; FontUtils . setTypeface ( storyViewHolder . commentsView , true , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; if ( storyViewHolder . story . clicked && type != SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) { storyViewHolder . titleView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorDisabled ) ) ; storyViewHolder . commentsIcon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . metaFavicon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . commentsView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDisabled ) ) ; storyViewHolder . metaView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDisabled ) ) ; } else { storyViewHolder . titleView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . storyColorNormal ) ) ; storyViewHolder . commentsIcon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . metaFavicon . setAlpha ( <NUM_LIT> ) ; storyViewHolder . commentsView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDefault ) ) ; storyViewHolder . metaView . setTextColor ( Utils . getColorViaAttr ( ctx , R . attr . textColorDefault ) ) ; } storyViewHolder . titleShimmer . setVisibility ( View . GONE ) ; storyViewHolder . metaShimmer . setVisibility ( View . GONE ) ; storyViewHolder . titleView . setVisibility ( View . VISIBLE ) ; storyViewHolder . metaContainer . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . commentsView . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . metaFavicon . setVisibility ( thumbnails ? View . VISIBLE : View . GONE ) ; if ( storyViewHolder . story . loadingFailed ) { storyViewHolder . titleView . setText ( \"<STR_LIT>\" ) ; storyViewHolder . metaContainer . setVisibility ( View . GONE ) ; storyViewHolder . commentsView . setVisibility ( View . GONE ) ; } storyViewHolder . linkLayoutView . setClickable ( true ) ; storyViewHolder . commentLayoutView . setClickable ( ! storyViewHolder . story . loadingFailed ) ; } else { storyViewHolder . commentsIcon . setImageResource ( R . drawable . ic_action_comment ) ; storyViewHolder . titleShimmer . setVisibility ( View . VISIBLE ) ; storyViewHolder . metaShimmer . setVisibility ( compactView ? View . GONE : View . VISIBLE ) ; storyViewHolder . titleView . setVisibility ( View . GONE ) ; storyViewHolder . metaContainer . setVisibility ( View . GONE ) ; storyViewHolder . commentsView . setText ( null ) ; storyViewHolder . linkLayoutView . setClickable ( false ) ; storyViewHolder . commentLayoutView . setClickable ( false ) ; storyViewHolder . commentsIcon . setAlpha ( storyViewHolder . story . clicked ? <NUM_LIT> : <NUM_LIT> ) ; } } else if ( holder instanceof MainHeaderViewHolder ) { final MainHeaderViewHolder headerViewHolder = ( MainHeaderViewHolder ) holder ; final Context ctx = headerViewHolder . itemView . getContext ( ) ; if ( compactHeader ) { headerViewHolder . container . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ) ; } else { headerViewHolder . container . setPadding ( <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) , <NUM_LIT> , Utils . pxFromDpInt ( ctx . getResources ( ) , <NUM_LIT> ) ) ; } headerViewHolder . moreButton . setVisibility ( searching ? View . GONE : View . VISIBLE ) ; headerViewHolder . spinnerContainer . setVisibility ( searching ? View . GONE : View . VISIBLE ) ; headerViewHolder . searchButton . setImageResource ( searching ? R . drawable . ic_action_cancel : R . drawable . ic_action_search ) ; headerViewHolder . searchEditText . setVisibility ( searching ? View . VISIBLE : View . GONE ) ; headerViewHolder . searchEditText . setText ( stories . get ( <NUM_LIT> ) . title ) ; if ( searching ) { headerViewHolder . loadingIndicator . setVisibility ( View . GONE ) ; headerViewHolder . searchEditText . requestFocus ( ) ; headerViewHolder . searchEditText . setText ( lastSearch ) ; headerViewHolder . searchEditText . setSelection ( lastSearch . length ( ) ) ; headerViewHolder . searchEmptyContainer . setVisibility ( stories . size ( ) == <NUM_LIT> ? View . VISIBLE : View . GONE ) ; headerViewHolder . noBookmarksLayout . setVisibility ( View . GONE ) ; } else { headerViewHolder . noBookmarksLayout . setVisibility ( ( stories . size ( ) == <NUM_LIT> && type == SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) ? View . VISIBLE : View . GONE ) ; headerViewHolder . searchEmptyContainer . setVisibility ( View . GONE ) ; headerViewHolder . loadingIndicator . setVisibility ( stories . size ( ) == <NUM_LIT> && ! loadingFailed && ! loadingFailedServerError && ( type != SettingsUtils . getBookmarksIndex ( ctx . getResources ( ) ) ) ? View . VISIBLE : View . GONE ) ; } headerViewHolder . typeSpinner . setSelection ( type ) ; TooltipCompat . setTooltipText ( headerViewHolder . searchButton , searching ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; TooltipCompat . setTooltipText ( headerViewHolder . moreButton , \"<STR_LIT>\" ) ; headerViewHolder . loadingFailedLayout . setVisibility ( loadingFailed ? View . VISIBLE : View . GONE ) ; headerViewHolder . loadingFailedAlgoliaLayout . setVisibility ( loadingFailedServerError ? View . VISIBLE : View . GONE ) ; } else if ( holder instanceof SubmissionsHeaderViewHolder ) { final SubmissionsHeaderViewHolder submissionsHeaderViewHolder = ( SubmissionsHeaderViewHolder ) holder ; submissionsHeaderViewHolder . headerText . setText ( submitter + \"<STR_LIT>\" ) ; } else if ( holder instanceof CommentViewHolder ) { final CommentViewHolder commentViewHolder = ( CommentViewHolder ) holder ; Story story = stories . get ( position ) ; commentViewHolder . headerText . setText ( \"<STR_LIT>\" + story . commentMasterTitle + \"<STR_LIT>\" + Utils . getTimeAgo ( story . time ) ) ; commentViewHolder . bodyText . setHtml ( story . text ) ; commentViewHolder . bodyText . post ( new Runnable ( ) { @ Override public void run ( ) { commentViewHolder . scrim . setVisibility ( ViewUtils . isTextTruncated ( commentViewHolder . bodyText ) ? View . VISIBLE : View . GONE ) ; } } ) ; } } @ Override public int getItemViewType ( int position ) { if ( position == <NUM_LIT> ) { return atSubmissions ? TYPE_HEADER_SUBMISSIONS : TYPE_HEADER_MAIN ; } else { if ( atSubmissions ) { return stories . get ( position ) . isComment ? TYPE_COMMENT : TYPE_STORY ; } else { return TYPE_STORY ; } } } @ Override public int getItemCount ( ) { return stories . size ( ) ; } public class StoryViewHolder extends RecyclerView . ViewHolder { public final View mView ; public final TextView titleView ; public final TextView metaView ; public final TextView commentsView ; public final LinearLayout linkLayoutView ; public final LinearLayout commentLayoutView ; public final ImageView commentsIcon ; public final LinearLayout titleShimmer ; public final View metaShimmer ; public final LinearLayout metaContainer ; public final ImageView metaFavicon ; public final TextView indexTextView ; private int touchX , touchY ; public Story story ; @ SuppressLint ( \"<STR_LIT>\" ) public StoryViewHolder ( View view ) { super ( view ) ; mView = view ; titleView = view . findViewById ( R . id . story_title ) ; metaView = view . findViewById ( R . id . story_meta ) ; metaContainer = view . findViewById ( R . id . story_meta_container ) ; commentsView = view . findViewById ( R . id . story_comments ) ; linkLayoutView = view . findViewById ( R . id . story_link_layout ) ; commentLayoutView = view . findViewById ( R . id . story_comment_layout ) ; commentsIcon = view . findViewById ( R . id . story_comments_icon ) ; titleShimmer = view . findViewById ( R . id . story_title_shimmer ) ; metaShimmer = view . findViewById ( R . id . story_title_shimmer_meta ) ; metaFavicon = view . findViewById ( R . id . story_meta_favicon ) ; indexTextView = view . findViewById ( R . id . story_index ) ; linkLayoutView . setOnClickListener ( v -> linkClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ) ; commentLayoutView . setOnClickListener ( v -> commentClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ) ; if ( longClickListener != null ) { linkLayoutView . setOnTouchListener ( new View . OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { touchX = ( int ) event . getX ( ) ; touchY = ( int ) event . getY ( ) ; return false ;", "output": "} } ) ; linkLayoutView . setOnLongClickListener ( v -> longClickListener . onLongClick ( v , getAbsoluteAdapterPosition ( ) , touchX , touchY ) ) ; } } } public class MainHeaderViewHolder extends RecyclerView . ViewHolder { public final Spinner typeSpinner ; public final LinearLayout container ; public final LinearLayout loadingFailedLayout ; public final TextView loadingFailedAlgoliaLayout ; public final LinearLayout noBookmarksLayout ; public final LinearLayout spinnerContainer ; public final LinearLayout searchEmptyContainer ; public final RelativeLayout loadingIndicator ; public final EditText searchEditText ; public final ImageButton moreButton ; public final ImageButton searchButton ; public final Button retryButton ; public ArrayAdapter < CharSequence > typeAdapter ; public MainHeaderViewHolder ( View view ) { super ( view ) ; final Context ctx = view . getContext ( ) ; loadingFailedLayout = view . findViewById ( R . id . stories_header_loading_failed ) ; loadingFailedAlgoliaLayout = view . findViewById ( R . id . stories_header_loading_failed_algolia ) ; container = view . findViewById ( R . id . stories_header_container ) ; typeSpinner = view . findViewById ( R . id . stories_header_spinner ) ; noBookmarksLayout = view . findViewById ( R . id . stories_header_no_bookmarks ) ; searchEditText = view . findViewById ( R . id . stories_header_search_edittext ) ; moreButton = view . findViewById ( R . id . stories_header_more ) ; spinnerContainer = view . findViewById ( R . id . stories_header_spinner_container ) ; searchButton = view . findViewById ( R . id . stories_header_search_button ) ; searchEmptyContainer = view . findViewById ( R . id . stories_header_search_empty_container ) ; retryButton = view . findViewById ( R . id . stories_header_retry_button ) ; loadingIndicator = view . findViewById ( R . id . stories_header_loading_indicator ) ; retryButton . setOnClickListener ( ( v ) -> refreshListener . onRefresh ( ) ) ; moreButton . setOnClickListener ( moreClickListener ) ; searchEditText . setOnEditorActionListener ( new TextView . OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView textView , int actionId , KeyEvent keyEvent ) { if ( actionId != EditorInfo . IME_ACTION_SEARCH ) { return false ; } doSearch ( ) ; if ( textView != null ) { InputMethodManager imm = ( InputMethodManager ) ctx . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; } return true ; } } ) ; searchButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { searching = ! searching ; storiesSearchListener . onSearchStatusChanged ( ) ; InputMethodManager imm = ( InputMethodManager ) ctx . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; if ( searching ) { imm . toggleSoftInput ( InputMethodManager . SHOW_IMPLICIT , <NUM_LIT> ) ; } else { imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , <NUM_LIT> ) ; lastSearch = \"<STR_LIT>\" ; } } } ) ; String [ ] sortingOptions = ctx . getResources ( ) . getStringArray ( R . array . sorting_options ) ; ArrayList < CharSequence > typeAdapterList = new ArrayList < > ( Arrays . asList ( sortingOptions ) ) ; typeAdapter = new ArrayAdapter < > ( ctx , R . layout . spinner_top_layout , R . id . selection_dropdown_item_textview , typeAdapterList ) ; typeAdapter . setDropDownViewResource ( R . layout . spinner_item_layout ) ; typeSpinner . setAdapter ( typeAdapter ) ; typeSpinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { if ( i != type ) { typeClickListener . onItemClick ( i ) ; } } @ Override public void onNothingSelected ( AdapterView < ? > adapterView ) { } } ) ; } private void doSearch ( ) { storiesSearchListener . onQueryTextSubmit ( searchEditText . getText ( ) . toString ( ) ) ; } } public static class SubmissionsHeaderViewHolder extends RecyclerView . ViewHolder { public final TextView headerText ; public SubmissionsHeaderViewHolder ( View view ) { super ( view ) ; headerText = view . findViewById ( R . id . submissions_header_text ) ; } } public class CommentViewHolder extends RecyclerView . ViewHolder { public final TextView headerText ; public final HtmlTextView bodyText ; public final Button storyButton ; public final Button repliesButton ; public final View scrim ; public CommentViewHolder ( View view ) { super ( view ) ; headerText = view . findViewById ( R . id . submissions_comment_header ) ; bodyText = view . findViewById ( R . id . submissions_comment_body ) ; storyButton = view . findViewById ( R . id . submissions_comment_button_story ) ; repliesButton = view . findViewById ( R . id . submissions_comment_button_replies ) ; scrim = view . findViewById ( R . id . submissions_comment_scrim ) ; Context ctx = view . getContext ( ) ; GradientDrawable gradientDrawable = new GradientDrawable ( GradientDrawable . Orientation . TOP_BOTTOM , new int [ ] { Color . TRANSPARENT , ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) } ) ; scrim . setBackground ( gradientDrawable ) ; bodyText . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . launchCustomTab ( widget . getContext ( ) , href ) ; return true ; } } ) ; storyButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { int pos = getAbsoluteAdapterPosition ( ) ; if ( pos != RecyclerView . NO_POSITION ) { commentStoryClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ; } } } ) ; repliesButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { int pos = getAbsoluteAdapterPosition ( ) ; if ( pos != RecyclerView . NO_POSITION ) { commentRepliesClickListener . onItemClick ( getAbsoluteAdapterPosition ( ) ) ; } } } ) ; } } public void setOnTypeClickListener ( ClickListener clickListener ) { typeClickListener = clickListener ; } public void setOnLinkClickListener ( ClickListener clickListener ) { linkClickListener = clickListener ; } public void setOnCommentClickListener ( ClickListener clickListener ) { commentClickListener = clickListener ; } public void setOnCommentStoryClickListener ( ClickListener clickListener ) { commentStoryClickListener = clickListener ; } public void setOnCommentRepliesClickListener ( ClickListener clickListener ) { commentRepliesClickListener = clickListener ; } public void setOnLongClickListener ( LongClickCoordinateListener clickListener ) { longClickListener = clickListener ; } public void setOnRefreshListener ( RefreshListener listener ) { refreshListener = listener ; } public void setOnMoreClickListener ( View . OnClickListener listener ) { moreClickListener = listener ; } public interface ClickListener { void onItemClick ( int position ) ; } public void setSearchListener ( SearchListener searchListener ) { storiesSearchListener = searchListener ; } public interface SearchListener { void onQueryTextSubmit ( String query ) ; void onSearchStatusChanged ( ) ; } public interface RefreshListener { void onRefresh ( ) ; } public interface LongClickCoordinateListener { boolean onLongClick ( View v , int position , int x , int y ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . media ; import static com . wmods . wppenhacer . xposed . features . general . MenuStatus . menuStatuses ; import android . content . Intent ; import android . content . SharedPreferences ; import android . media . MediaScannerConnection ; import android . net . Uri ; import android . os . Environment ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . MenuStatus ; import com . wmods . wppenhacer . xposed . utils . MimeTypeUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Collections ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class StatusDownload extends Feature { private Field fieldFile ; public StatusDownload ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; fieldFile = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; var downloadStatus = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . download ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . download , <NUM_LIT> , ResId . string . download ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { downloadFile ( fMessageWpp ) ; } } ; menuStatuses . add ( downloadStatus ) ; var sharedMenu = new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( fMessage . getKey ( ) . isFromMe ) return null ; if ( menu . findItem ( ResId . string . share_as_status ) != null ) return null ; return menu . add ( <NUM_LIT> , ResId . string . share_as_status , <NUM_LIT> , ResId . string . share_as_status ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sharedStatus ( fMessageWpp ) ; } } ; menuStatuses . add ( sharedMenu ) ; } private void sharedStatus ( FMessageWpp fMessageWpp ) { try { var fileData = XposedHelpers . getObjectField ( fMessageWpp . getObject ( ) , \"<STR_LIT>\" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; Intent intent = new Intent ( ) ; intent . setClassName ( Utils . getApplication ( ) . getPackageName ( ) , \"<STR_LIT>\" ) ;", "output": "intent . putExtra ( \"<STR_LIT>\" , new ArrayList < > ( Collections . singleton ( \"<STR_LIT>\" ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , new ArrayList < > ( Collections . singleton ( Uri . fromFile ( file ) ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , fMessageWpp . getMessageStr ( ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } private void downloadFile ( FMessageWpp fMessage ) { try { var fileData = XposedHelpers . getObjectField ( fMessage . getObject ( ) , \"<STR_LIT>\" ) ; if ( ! fieldFile . getDeclaringClass ( ) . isInstance ( fileData ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . msg_text_status_not_downloadable ) , Toast . LENGTH_SHORT ) ; return ; } var file = ( File ) ReflectionUtils . getField ( fieldFile , fileData ) ; var userJid = fMessage . getUserJid ( ) ; var fileType = file . getName ( ) . substring ( file . getName ( ) . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; var destination = getPathDestination ( prefs , file ) ; var name = Utils . generateName ( userJid , fileType ) ; var destinationFile = new File ( destination , name ) ; var error = Utils . copyFile ( file , destinationFile ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destinationFile . getAbsolutePath ( ) , Toast . LENGTH_SHORT ) ; log ( \"<STR_LIT>\" + destinationFile . getAbsolutePath ( ) ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + \"<STR_LIT>\" + error , Toast . LENGTH_SHORT ) ; } } catch ( Throwable e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_SHORT ) ; } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private boolean copyFile ( SharedPreferences prefs , File file ) throws IOException { if ( file == null || ! file . exists ( ) ) throw new IOException ( \"<STR_LIT>\" ) ; var destination = getPathDestination ( prefs , file ) ; try ( FileInputStream in = new FileInputStream ( file ) ; FileOutputStream out = new FileOutputStream ( destination ) ) { byte [ ] bArr = new byte [ <NUM_LIT> ] ; while ( true ) { int read = in . read ( bArr ) ; if ( read <= <NUM_LIT> ) { in . close ( ) ; out . close ( ) ; MediaScannerConnection . scanFile ( Utils . getApplication ( ) , new String [ ] { destination } , new String [ ] { MimeTypeUtils . getMimeTypeFromExtension ( file . getAbsolutePath ( ) ) } , ( path , uri ) -> { } ) ; return true ; } out . write ( bArr , <NUM_LIT> , read ) ; } } } @ NonNull private String getPathDestination ( SharedPreferences sharedPreferences , @ NonNull File f ) { var fileName = f . getName ( ) . toLowerCase ( ) ; var mediaPath = getStatusFolderPath ( sharedPreferences , MimeTypeUtils . getMimeTypeFromExtension ( fileName ) ) ; if ( ! mediaPath . exists ( ) ) mediaPath . mkdirs ( ) ; return mediaPath + \"<STR_LIT>\" ; } @ NonNull private File getStatusFolderPath ( SharedPreferences sharedPreferences , @ NonNull String mimeType ) { String folderPath = sharedPreferences . getString ( \"<STR_LIT>\" , Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" ) ; if ( mimeType . contains ( \"<STR_LIT>\" ) ) { folderPath += \"<STR_LIT>\" ; } else if ( mimeType . contains ( \"<STR_LIT>\" ) ) { folderPath += \"<STR_LIT>\" ; } else if ( mimeType . contains ( \"<STR_LIT>\" ) ) { folderPath += \"<STR_LIT>\" ; } else { folderPath += \"<STR_LIT>\" ; } return new File ( folderPath ) ; } }"}, {"input": "package com . reactnative . bottomsheet ; import androidx . annotation . NonNull ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class BottomSheetManager extends ViewGroupManager < BottomSheet > { @ NonNull @ Override public String getName ( ) { return \"<STR_LIT>\" ; } @ NonNull @ Override protected BottomSheet createViewInstance ( @ NonNull ThemedReactContext reactContext ) { return new BottomSheet ( reactContext ) ; } @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( StateChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ ReactProp ( name = \"<STR_LIT>\" , defaultInt = <NUM_LIT> ) public void setPeekHeight ( BottomSheet view , int dp ) { view . setPeekHeight ( ( int ) ( PixelUtil . toPixelFromDIP ( dp ) + <NUM_LIT> ) ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setState ( BottomSheet view , String state ) { view . setState ( BottomSheetState . valueOf ( state . toUpperCase ( ) ) ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setDraggable ( BottomSheet view , boolean draggable ) {", "output": "view . setDraggable ( draggable ) ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . view . MotionEvent ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import com . simon . harmonichackernews . utils . ViewUtils ; public class BaseActivity extends AppCompatActivity { private int navBarHeight = <NUM_LIT> ; @ Override protected void onStart ( ) { super . onStart ( ) ; ViewCompat . setOnApplyWindowInsetsListener ( findViewById ( android . R . id . content ) , new OnApplyWindowInsetsListener ( ) { @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat windowInsets ) { Insets insets = windowInsets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) ; navBarHeight = insets . bottom ; return windowInsets ; } } ) ; ViewUtils . requestApplyInsetsWhenAttached ( findViewById ( android . R . id . content ) ) ;", "output": "} @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { int screenHeight = getWindow ( ) . getDecorView ( ) . getHeight ( ) ; int actionType = ev . getAction ( ) ; if ( ev . getY ( ) >= ( screenHeight - navBarHeight ) ) { if ( actionType == MotionEvent . ACTION_UP ) { return super . dispatchTouchEvent ( ev ) ; } return true ; } try { return super . dispatchTouchEvent ( ev ) ; } catch ( Exception e ) { return false ; } } }"}, {"input": "public class MyActivity extends FragmentActivity { @ Override protected void onCreate ( Bundle savedInstance ) { String fragmentName = this . getActivity ( ) . getIntent ( ) . getDataString ( ) ; getFragmentManager ( ) . beginTransaction ( ) . replace ( com . android . internal . R . id . prefs , Fragment . instantiate ( this , fragmentName , null ) ) . commit ( ) ;", "output": "getFragmentManager ( ) . beginTransaction ( ) . replace ( com . android . internal . R . id . prefs , Fragment . instantiate ( this , anotherName , null ) ) . commit ( ) ; } }"}, {"input": "package com . reactnative . bottomsheet ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . Event ; public class StateChangedEvent extends Event < StateChangedEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; private final String state ; public StateChangedEvent ( int surfaceId , int viewTag , String state ) { super ( surfaceId , viewTag ) ;", "output": "this . state = state ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap data = Arguments . createMap ( ) ; data . putString ( \"<STR_LIT>\" , state ) ; return data ; } }"}, {"input": "package external . org . apache . commons . lang3 . reflect ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Member ; import java . lang . reflect . Modifier ; import external . org . apache . commons . lang3 . ClassUtils ; public abstract class MemberUtils { private static final int ACCESS_TEST = Modifier . PUBLIC | Modifier . PROTECTED | Modifier . PRIVATE ; private static final Class < ? > [ ] ORDERED_PRIMITIVE_TYPES = { Byte . TYPE , Short . TYPE , Character . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; static void setAccessibleWorkaround ( AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return ; } Member m = ( Member ) o ; if ( Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true ) ; } catch ( SecurityException e ) { } } } static boolean isPackageAccess ( int modifiers ) { return ( modifiers & ACCESS_TEST ) == <NUM_LIT> ; } static boolean isAccessible ( Member m ) { return m != null && Modifier . isPublic ( m . getModifiers ( ) ) && ! m . isSynthetic ( ) ; } public static int compareParameterTypes ( Class < ? > [ ] left , Class < ? > [ ] right , Class < ? > [ ] actual ) { float leftCost = getTotalTransformationCost ( actual , left ) ; float rightCost = getTotalTransformationCost ( actual , right ) ; return leftCost < rightCost ? - <NUM_LIT> : rightCost < leftCost ? <NUM_LIT> : <NUM_LIT> ; }", "output": "private static float getTotalTransformationCost ( Class < ? > [ ] srcArgs , Class < ? > [ ] destArgs ) { float totalCost = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < srcArgs . length ; i ++ ) { Class < ? > srcClass , destClass ; srcClass = srcArgs [ i ] ; destClass = destArgs [ i ] ; totalCost += getObjectTransformationCost ( srcClass , destClass ) ; } return totalCost ; } private static float getObjectTransformationCost ( Class < ? > srcClass , Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = <NUM_LIT> ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { cost += <NUM_LIT> ; break ; } cost ++ ; srcClass = srcClass . getSuperclass ( ) ; } if ( srcClass == null ) { cost += <NUM_LIT> ; } return cost ; } private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = <NUM_LIT> ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) { cost += <NUM_LIT> ; cls = ClassUtils . wrapperToPrimitive ( cls ) ; } for ( int i = <NUM_LIT> ; cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; i ++ ) { if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { cost += <NUM_LIT> ; if ( i < ORDERED_PRIMITIVE_TYPES . length - <NUM_LIT> ) { cls = ORDERED_PRIMITIVE_TYPES [ i + <NUM_LIT> ] ; } } } return cost ; } }"}, {"input": "package com . norman . webviewup . lib . service . binder ; import android . os . IBinder ; import android . os . IInterface ; import android . os . Parcel ; import android . os . RemoteException ; import java . io . FileDescriptor ; public class ProxyBinder implements IBinder { private final IBinder mRemoteBinder ; private final IInterface mStubIInterface ; private IInterface mProxyIInterface ; public ProxyBinder ( IInterface stubIInterface ) { this . mStubIInterface = stubIInterface ; this . mRemoteBinder = stubIInterface . asBinder ( ) ; } public ProxyBinder ( IInterface stubIInterface , IInterface proxyIInterface ) { this ( stubIInterface ) ; setProxyInterface ( proxyIInterface ) ; } public synchronized void setProxyInterface ( IInterface proxyIInterface ) { this . mProxyIInterface = proxyIInterface ; } public synchronized IInterface getProxyIInterface ( ) { return mProxyIInterface ; } @ Override public String getInterfaceDescriptor ( ) throws RemoteException { return mRemoteBinder . getInterfaceDescriptor ( ) ; } @ Override public boolean pingBinder ( ) { return mRemoteBinder . pingBinder ( ) ; } @ Override public boolean isBinderAlive ( ) { return mRemoteBinder . isBinderAlive ( ) ; } @ Override public synchronized IInterface queryLocalInterface ( String descriptor ) { return mProxyIInterface != null ? mProxyIInterface : mStubIInterface ; } @ Override public void dump ( FileDescriptor fd , String [ ] args ) throws RemoteException { mRemoteBinder . dump ( fd , args ) ; } @ Override public void dumpAsync ( FileDescriptor fd , String [ ] args ) throws RemoteException {", "output": "mRemoteBinder . dumpAsync ( fd , args ) ; } @ Override public boolean transact ( int code , Parcel data , Parcel reply , int flags ) throws RemoteException { return mRemoteBinder . transact ( code , data , reply , flags ) ; } @ Override public void linkToDeath ( DeathRecipient recipient , int flags ) throws RemoteException { mRemoteBinder . linkToDeath ( recipient , flags ) ; } @ Override public boolean unlinkToDeath ( DeathRecipient recipient , int flags ) { return mRemoteBinder . unlinkToDeath ( recipient , flags ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core . bean ; import java . io . File ; import java . io . Serializable ; public class RemoteFile implements Serializable { protected String name ; protected String path ; protected long lastModified ; protected long size ; protected boolean isDirectory ; public RemoteFile ( File file ) { path = file . getPath ( ) ; isDirectory = file . isDirectory ( ) ; name = file . getName ( ) ; lastModified = file . lastModified ( ) ; size = file . length ( ) ; } public RemoteFile ( String name , String path , long lastModified , long size , boolean isDirectory ) { this . name = name ; this . path = path ; this . lastModified = lastModified ; this . size = size ; this . isDirectory = isDirectory ; } public RemoteFile ( RemoteFile file ) { this . name = file . name ; this . path = file . path ; this . lastModified = file . lastModified ; this . size = file . size ; this . isDirectory = file . isDirectory ; } protected RemoteFile ( ) {", "output": "} @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + path + '<STR_LIT>' + \"<STR_LIT>\" + isDirectory + '<STR_LIT>' ; } public String getPath ( ) { return path ; } public boolean isDirectory ( ) { return isDirectory ; } public String getName ( ) { return name ; } public long getLastModified ( ) { return lastModified ; } public long getSize ( ) { return size ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import android . graphics . Point ; import android . util . DisplayMetrics ; import android . view . Display ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . google . mlkit . vision . barcode . common . Barcode ; import com . google . mlkit . vision . common . InputImage ; import org . json . JSONArray ; import org . json . JSONException ; public class BarcodeScannerHelper { public static JSObject createBarcodeResultForBarcode ( @ NonNull Barcode barcode , @ Nullable Point imageSize , @ Nullable Point screenSize ) { Point [ ] cornerPoints = barcode . getCornerPoints ( ) ;", "output": "JSArray cornerPointsResult = new JSArray ( ) ; if ( cornerPoints != null && imageSize != null && screenSize != null ) { Point [ ] normalizedCornerPoints = normalizeCornerPoints ( cornerPoints , imageSize , screenSize ) ; for ( int i = <NUM_LIT> ; i < normalizedCornerPoints . length ; i ++ ) { JSArray cornerPointResult = new JSArray ( ) ; cornerPointResult . put ( normalizedCornerPoints [ i ] . x ) ; cornerPointResult . put ( normalizedCornerPoints [ i ] . y ) ; cornerPointsResult . put ( cornerPointResult ) ; } } JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , convertByteArrayToJsonArray ( barcode . getRawBytes ( ) ) ) ; if ( cornerPoints != null ) { result . put ( \"<STR_LIT>\" , cornerPointsResult ) ; } result . put ( \"<STR_LIT>\" , barcode . getDisplayValue ( ) ) ; result . put ( \"<STR_LIT>\" , convertBarcodeScannerFormatToString ( barcode . getFormat ( ) ) ) ; result . put ( \"<STR_LIT>\" , barcode . getRawValue ( ) ) ; result . put ( \"<STR_LIT>\" , convertBarcodeValueTypeToString ( barcode . getValueType ( ) ) ) ; return result ; } public static int [ ] convertStringsToBarcodeScannerFormats ( String [ ] values ) throws JSONException { int [ ] formats = new int [ values . length ] ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { Integer format = convertStringToBarcodeScannerFormat ( values [ i ] ) ; if ( format == null ) { continue ; } formats [ i ] = format ; } return formats ; } @ Nullable public static Integer convertStringToBarcodeScannerFormat ( String value ) { switch ( value ) { case \"<STR_LIT>\" : return Barcode . FORMAT_AZTEC ; case \"<STR_LIT>\" : return Barcode . FORMAT_CODABAR ; case \"<STR_LIT>\" : return Barcode . FORMAT_CODE_39 ; case \"<STR_LIT>\" : return Barcode . FORMAT_CODE_93 ; case \"<STR_LIT>\" : return Barcode . FORMAT_CODE_128 ; case \"<STR_LIT>\" : return Barcode . FORMAT_DATA_MATRIX ; case \"<STR_LIT>\" : return Barcode . FORMAT_EAN_8 ; case \"<STR_LIT>\" : return Barcode . FORMAT_EAN_13 ; case \"<STR_LIT>\" : return Barcode . FORMAT_ITF ; case \"<STR_LIT>\" : return Barcode . FORMAT_PDF417 ; case \"<STR_LIT>\" : return Barcode . FORMAT_QR_CODE ; case \"<STR_LIT>\" : return Barcode . FORMAT_UPC_A ; case \"<STR_LIT>\" : return Barcode . FORMAT_UPC_E ; default : return null ; } } @ Nullable public static String convertBarcodeScannerFormatToString ( int format ) { switch ( format ) { case Barcode . FORMAT_AZTEC : return \"<STR_LIT>\" ; case Barcode . FORMAT_CODABAR : return \"<STR_LIT>\" ; case Barcode . FORMAT_CODE_39 : return \"<STR_LIT>\" ; case Barcode . FORMAT_CODE_93 : return \"<STR_LIT>\" ; case Barcode . FORMAT_CODE_128 : return \"<STR_LIT>\" ; case Barcode . FORMAT_DATA_MATRIX : return \"<STR_LIT>\" ; case Barcode . FORMAT_EAN_8 : return \"<STR_LIT>\" ; case Barcode . FORMAT_EAN_13 : return \"<STR_LIT>\" ; case Barcode . FORMAT_ITF : return \"<STR_LIT>\" ; case Barcode . FORMAT_PDF417 : return \"<STR_LIT>\" ; case Barcode . FORMAT_QR_CODE : return \"<STR_LIT>\" ; case Barcode . FORMAT_UPC_A : return \"<STR_LIT>\" ; case Barcode . FORMAT_UPC_E : return \"<STR_LIT>\" ; default : return null ; } } @ Nullable public static String convertBarcodeValueTypeToString ( int format ) { switch ( format ) { case Barcode . TYPE_CALENDAR_EVENT : return \"<STR_LIT>\" ; case Barcode . TYPE_CONTACT_INFO : return \"<STR_LIT>\" ; case Barcode . TYPE_DRIVER_LICENSE : return \"<STR_LIT>\" ; case Barcode . TYPE_EMAIL : return \"<STR_LIT>\" ; case Barcode . TYPE_GEO : return \"<STR_LIT>\" ; case Barcode . TYPE_ISBN : return \"<STR_LIT>\" ; case Barcode . TYPE_PHONE : return \"<STR_LIT>\" ; case Barcode . TYPE_PRODUCT : return \"<STR_LIT>\" ; case Barcode . TYPE_SMS : return \"<STR_LIT>\" ; case Barcode . TYPE_TEXT : return \"<STR_LIT>\" ; case Barcode . TYPE_URL : return \"<STR_LIT>\" ; case Barcode . TYPE_WIFI : return \"<STR_LIT>\" ; default : return \"<STR_LIT>\" ; } } private static JSONArray convertByteArrayToJsonArray ( byte [ ] bytes ) { JSONArray ret = new JSONArray ( ) ; for ( byte _byte : bytes ) { ret . put ( _byte ) ; } return ret ; } private static Point [ ] normalizeCornerPoints ( @ NonNull Point [ ] cornerPoints , @ NonNull Point imageSize , @ NonNull Point screenSize ) { double screenWidth = screenSize . x ; double screenHeight = screenSize . y ; double imageWidth = imageSize . x ; double imageHeight = imageSize . y ; if ( screenWidth > screenHeight ) { imageWidth = imageSize . y ; imageHeight = imageSize . x ; } double scale = Math . max ( screenHeight / imageWidth , screenWidth / imageHeight ) ; double invisibleWidth = imageHeight * scale - screenWidth ; double invisibleHeight = imageWidth * scale - screenHeight ; Point [ ] normalizedCornerPoints = new Point [ cornerPoints . length ] ; for ( int i = <NUM_LIT> ; i < cornerPoints . length ; i ++ ) { int x = ( int ) ( ( cornerPoints [ i ] . x * scale ) - ( invisibleWidth / <NUM_LIT> ) ) ; int y = ( int ) ( ( cornerPoints [ i ] . y * scale ) - ( invisibleHeight / <NUM_LIT> ) ) ; normalizedCornerPoints [ i ] = new Point ( x , y ) ; } return normalizedCornerPoints ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class DiffUtil { private DiffUtil ( ) { } private static final Comparator < Diagonal > DIAGONAL_COMPARATOR = new Comparator < Diagonal > ( ) { @ Override public int compare ( Diagonal o1 , Diagonal o2 ) { return o1 . x - o2 . x ; } } ; @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb ) { return calculateDiff ( cb , true ) ; } @ NonNull public static DiffResult calculateDiff ( @ NonNull Callback cb , boolean detectMoves ) { final int oldSize = cb . getOldListSize ( ) ; final int newSize = cb . getNewListSize ( ) ; final List < Diagonal > diagonals = new ArrayList < > ( ) ; final List < Range > stack = new ArrayList < > ( ) ; stack . add ( new Range ( <NUM_LIT> , oldSize , <NUM_LIT> , newSize ) ) ; final int max = ( oldSize + newSize + <NUM_LIT> ) / <NUM_LIT> ; final CenteredArray forward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final CenteredArray backward = new CenteredArray ( max * <NUM_LIT> + <NUM_LIT> ) ; final List < Range > rangePool = new ArrayList < > ( ) ; while ( ! stack . isEmpty ( ) ) { final Range range = stack . remove ( stack . size ( ) - <NUM_LIT> ) ; final Snake snake = midPoint ( range , cb , forward , backward ) ; if ( snake != null ) { if ( snake . diagonalSize ( ) > <NUM_LIT> ) { diagonals . add ( snake . toDiagonal ( ) ) ; } final Range left = rangePool . isEmpty ( ) ? new Range ( ) : rangePool . remove ( rangePool . size ( ) - <NUM_LIT> ) ; left . oldListStart = range . oldListStart ; left . newListStart = range . newListStart ; left . oldListEnd = snake . startX ; left . newListEnd = snake . startY ; stack . add ( left ) ; final Range right = range ; right . oldListEnd = range . oldListEnd ; right . newListEnd = range . newListEnd ; right . oldListStart = snake . endX ; right . newListStart = snake . endY ; stack . add ( right ) ; } else { rangePool . add ( range ) ; } } Collections . sort ( diagonals , DIAGONAL_COMPARATOR ) ; return new DiffResult ( cb , diagonals , forward . backingData ( ) , backward . backingData ( ) , detectMoves ) ; } @ Nullable private static Snake midPoint ( Range range , Callback cb , CenteredArray forward , CenteredArray backward ) { if ( range . oldSize ( ) < <NUM_LIT> || range . newSize ( ) < <NUM_LIT> ) { return null ; } int max = ( range . oldSize ( ) + range . newSize ( ) + <NUM_LIT> ) / <NUM_LIT> ; forward . set ( <NUM_LIT> , range . oldListStart ) ; backward . set ( <NUM_LIT> , range . oldListEnd ) ; for ( int d = <NUM_LIT> ; d < max ; d ++ ) { Snake snake = forward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } snake = backward ( range , cb , forward , backward , d ) ; if ( snake != null ) { return snake ; } } return null ; } @ Nullable private static Snake forward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = Math . abs ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && forward . get ( k + <NUM_LIT> ) > forward . get ( k - <NUM_LIT> ) ) ) { x = startX = forward . get ( k + <NUM_LIT> ) ; } else { startX = forward . get ( k - <NUM_LIT> ) ;", "output": "x = startX + <NUM_LIT> ; } y = range . newListStart + ( x - range . oldListStart ) - k ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y - <NUM_LIT> ; while ( x < range . oldListEnd && y < range . newListEnd && cb . areItemsTheSame ( x , y ) ) { x ++ ; y ++ ; } forward . set ( k , x ) ; if ( checkForSnake ) { int backwardsK = delta - k ; if ( backwardsK >= - d + <NUM_LIT> && backwardsK <= d - <NUM_LIT> && backward . get ( backwardsK ) <= x ) { Snake snake = new Snake ( ) ; snake . startX = startX ; snake . startY = startY ; snake . endX = x ; snake . endY = y ; snake . reverse = false ; return snake ; } } } return null ; } @ Nullable private static Snake backward ( Range range , Callback cb , CenteredArray forward , CenteredArray backward , int d ) { boolean checkForSnake = ( range . oldSize ( ) - range . newSize ( ) ) % <NUM_LIT> == <NUM_LIT> ; int delta = range . oldSize ( ) - range . newSize ( ) ; for ( int k = - d ; k <= d ; k += <NUM_LIT> ) { final int startX ; final int startY ; int x , y ; if ( k == - d || ( k != d && backward . get ( k + <NUM_LIT> ) < backward . get ( k - <NUM_LIT> ) ) ) { x = startX = backward . get ( k + <NUM_LIT> ) ; } else { startX = backward . get ( k - <NUM_LIT> ) ; x = startX - <NUM_LIT> ; } y = range . newListEnd - ( ( range . oldListEnd - x ) - k ) ; startY = ( d == <NUM_LIT> || x != startX ) ? y : y + <NUM_LIT> ; while ( x > range . oldListStart && y > range . newListStart && cb . areItemsTheSame ( x - <NUM_LIT> , y - <NUM_LIT> ) ) { x -- ; y -- ; } backward . set ( k , x ) ; if ( checkForSnake ) { int forwardsK = delta - k ; if ( forwardsK >= - d && forwardsK <= d && forward . get ( forwardsK ) >= x ) { Snake snake = new Snake ( ) ; snake . startX = x ; snake . startY = y ; snake . endX = startX ; snake . endY = startY ; snake . reverse = true ; return snake ; } } } return null ; } public abstract static class Callback { public abstract int getOldListSize ( ) ; public abstract int getNewListSize ( ) ; public abstract boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) ; public abstract boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) ; @ Nullable public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { return null ; } } public abstract static class ItemCallback < T > { public abstract boolean areItemsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; public abstract boolean areContentsTheSame ( @ NonNull T oldItem , @ NonNull T newItem ) ; @ SuppressWarnings ( { \"<STR_LIT>\" } ) @ Nullable public Object getChangePayload ( @ NonNull T oldItem , @ NonNull T newItem ) { return null ; } } static class Diagonal { public final int x ; public final int y ; public final int size ; Diagonal ( int x , int y , int size ) { this . x = x ; this . y = y ; this . size = size ; } int endX ( ) { return x + size ; } int endY ( ) { return y + size ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class Snake { public int startX ; public int startY ; public int endX ; public int endY ; public boolean reverse ; boolean hasAdditionOrRemoval ( ) { return endY - startY != endX - startX ; } boolean isAddition ( ) { return endY - startY > endX - startX ; } int diagonalSize ( ) { return Math . min ( endX - startX , endY - startY ) ; } @ NonNull Diagonal toDiagonal ( ) { if ( hasAdditionOrRemoval ( ) ) { if ( reverse ) { return new Diagonal ( startX , startY , diagonalSize ( ) ) ; } else { if ( isAddition ( ) ) { return new Diagonal ( startX , startY + <NUM_LIT> , diagonalSize ( ) ) ; } else { return new Diagonal ( startX + <NUM_LIT> , startY , diagonalSize ( ) ) ; } } } else { return new Diagonal ( startX , startY , endX - startX ) ; } } } static class Range { int oldListStart , oldListEnd ; int newListStart , newListEnd ; public Range ( ) { } public Range ( int oldListStart , int oldListEnd , int newListStart , int newListEnd ) { this . oldListStart = oldListStart ; this . oldListEnd = oldListEnd ; this . newListStart = newListStart ; this . newListEnd = newListEnd ; } int oldSize ( ) { return oldListEnd - oldListStart ; } int newSize ( ) { return newListEnd - newListStart ; } } public static class DiffResult { public static final int NO_POSITION = - <NUM_LIT> ; private static final int FLAG_NOT_CHANGED = <NUM_LIT> ; private static final int FLAG_CHANGED = FLAG_NOT_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_CHANGED = FLAG_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED_NOT_CHANGED = FLAG_MOVED_CHANGED << <NUM_LIT> ; private static final int FLAG_MOVED = FLAG_MOVED_CHANGED | FLAG_MOVED_NOT_CHANGED ; private static final int FLAG_OFFSET = <NUM_LIT> ; private static final int FLAG_MASK = ( <NUM_LIT> << FLAG_OFFSET ) - <NUM_LIT> ; private final List < Diagonal > mDiagonals ; private final int [ ] mOldItemStatuses ; private final int [ ] mNewItemStatuses ; private final Callback mCallback ; private final int mOldListSize ; private final int mNewListSize ; private final boolean mDetectMoves ; DiffResult ( Callback callback , List < Diagonal > diagonals , int [ ] oldItemStatuses , int [ ] newItemStatuses , boolean detectMoves ) { mDiagonals = diagonals ; mOldItemStatuses = oldItemStatuses ; mNewItemStatuses = newItemStatuses ; Arrays . fill ( mOldItemStatuses , <NUM_LIT> ) ; Arrays . fill ( mNewItemStatuses , <NUM_LIT> ) ; mCallback = callback ; mOldListSize = callback . getOldListSize ( ) ; mNewListSize = callback . getNewListSize ( ) ; mDetectMoves = detectMoves ; addEdgeDiagonals ( ) ; findMatchingItems ( ) ; } private void addEdgeDiagonals ( ) { Diagonal first = mDiagonals . isEmpty ( ) ? null : mDiagonals . get ( <NUM_LIT> ) ; if ( first == null || first . x != <NUM_LIT> || first . y != <NUM_LIT> ) { mDiagonals . add ( <NUM_LIT> , new Diagonal ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; } mDiagonals . add ( new Diagonal ( mOldListSize , mNewListSize , <NUM_LIT> ) ) ; } private void findMatchingItems ( ) { for ( Diagonal diagonal : mDiagonals ) { for ( int offset = <NUM_LIT> ; offset < diagonal . size ; offset ++ ) { int posX = diagonal . x + offset ; int posY = diagonal . y + offset ; final boolean theSame = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = theSame ? FLAG_NOT_CHANGED : FLAG_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; } } if ( mDetectMoves ) { findMoveMatches ( ) ; } } private void findMoveMatches ( ) { int posX = <NUM_LIT> ; for ( Diagonal diagonal : mDiagonals ) { while ( posX < diagonal . x ) { if ( mOldItemStatuses [ posX ] == <NUM_LIT> ) { findMatchingAddition ( posX ) ; } posX ++ ; } posX = diagonal . endX ( ) ; } } private void findMatchingAddition ( int posX ) { int posY = <NUM_LIT> ; final int diagonalsSize = mDiagonals . size ( ) ; for ( int i = <NUM_LIT> ; i < diagonalsSize ; i ++ ) { final Diagonal diagonal = mDiagonals . get ( i ) ; while ( posY < diagonal . y ) { if ( mNewItemStatuses [ posY ] == <NUM_LIT> ) { boolean matching = mCallback . areItemsTheSame ( posX , posY ) ; if ( matching ) { boolean contentsMatching = mCallback . areContentsTheSame ( posX , posY ) ; final int changeFlag = contentsMatching ? FLAG_MOVED_NOT_CHANGED : FLAG_MOVED_CHANGED ; mOldItemStatuses [ posX ] = ( posY << FLAG_OFFSET ) | changeFlag ; mNewItemStatuses [ posY ] = ( posX << FLAG_OFFSET ) | changeFlag ; return ; } } posY ++ ; } posY = diagonal . endY ( ) ; } } public int convertOldPositionToNew ( @ IntRange ( from = <NUM_LIT> ) int oldListPosition ) { if ( oldListPosition < <NUM_LIT> || oldListPosition >= mOldListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + oldListPosition + \"<STR_LIT>\" + mOldListSize ) ; } final int status = mOldItemStatuses [ oldListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public int convertNewPositionToOld ( @ IntRange ( from = <NUM_LIT> ) int newListPosition ) { if ( newListPosition < <NUM_LIT> || newListPosition >= mNewListSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + newListPosition + \"<STR_LIT>\" + mNewListSize ) ; } final int status = mNewItemStatuses [ newListPosition ] ; if ( ( status & FLAG_MASK ) == <NUM_LIT> ) { return NO_POSITION ; } else { return status > > FLAG_OFFSET ; } } public void dispatchUpdatesTo ( @ NonNull final RecyclerView . Adapter adapter ) { dispatchUpdatesTo ( new AdapterListUpdateCallback ( adapter ) ) ; } public void dispatchUpdatesTo ( @ NonNull ListUpdateCallback updateCallback ) { final BatchingListUpdateCallback batchingCallback ; if ( updateCallback instanceof BatchingListUpdateCallback ) { batchingCallback = ( BatchingListUpdateCallback ) updateCallback ; } else { batchingCallback = new BatchingListUpdateCallback ( updateCallback ) ; updateCallback = batchingCallback ; } int currentListSize = mOldListSize ; final Collection < PostponedUpdate > postponedUpdates = new ArrayDeque < > ( ) ; int posX = mOldListSize ; int posY = mNewListSize ; for ( int diagonalIndex = mDiagonals . size ( ) - <NUM_LIT> ; diagonalIndex >= <NUM_LIT> ; diagonalIndex -- ) { final Diagonal diagonal = mDiagonals . get ( diagonalIndex ) ; int endX = diagonal . endX ( ) ; int endY = diagonal . endY ( ) ; while ( posX > endX ) { posX -- ; int status = mOldItemStatuses [ posX ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int newPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , newPos , false ) ; if ( postponedUpdate != null ) { int updatedNewPos = currentListSize - postponedUpdate . currentPos ; batchingCallback . onMoved ( posX , updatedNewPos - <NUM_LIT> ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( posX , newPos ) ; batchingCallback . onChanged ( updatedNewPos - <NUM_LIT> , <NUM_LIT> , changePayload ) ; } } else { postponedUpdates . add ( new PostponedUpdate ( posX , currentListSize - posX - <NUM_LIT> , true ) ) ; } } else { batchingCallback . onRemoved ( posX , <NUM_LIT> ) ; currentListSize -- ; } } while ( posY > endY ) { posY -- ; int status = mNewItemStatuses [ posY ] ; if ( ( status & FLAG_MOVED ) != <NUM_LIT> ) { int oldPos = status > > FLAG_OFFSET ; PostponedUpdate postponedUpdate = getPostponedUpdate ( postponedUpdates , oldPos , true ) ; if ( postponedUpdate == null ) { postponedUpdates . add ( new PostponedUpdate ( posY , currentListSize - posX , false ) ) ; } else { int updatedOldPos = currentListSize - postponedUpdate . currentPos - <NUM_LIT> ; batchingCallback . onMoved ( updatedOldPos , posX ) ; if ( ( status & FLAG_MOVED_CHANGED ) != <NUM_LIT> ) { Object changePayload = mCallback . getChangePayload ( oldPos , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } } } else { batchingCallback . onInserted ( posX , <NUM_LIT> ) ; currentListSize ++ ; } } posX = diagonal . x ; posY = diagonal . y ; for ( int i = <NUM_LIT> ; i < diagonal . size ; i ++ ) { if ( ( mOldItemStatuses [ posX ] & FLAG_MASK ) == FLAG_CHANGED ) { Object changePayload = mCallback . getChangePayload ( posX , posY ) ; batchingCallback . onChanged ( posX , <NUM_LIT> , changePayload ) ; } posX ++ ; posY ++ ; } posX = diagonal . x ; posY = diagonal . y ; } batchingCallback . dispatchLastEvent ( ) ; } @ Nullable private static PostponedUpdate getPostponedUpdate ( Collection < PostponedUpdate > postponedUpdates , int posInList , boolean removal ) { PostponedUpdate postponedUpdate = null ; Iterator < PostponedUpdate > itr = postponedUpdates . iterator ( ) ; while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( update . posInOwnerList == posInList && update . removal == removal ) { postponedUpdate = update ; itr . remove ( ) ; break ; } } while ( itr . hasNext ( ) ) { PostponedUpdate update = itr . next ( ) ; if ( removal ) { update . currentPos -- ; } else { update . currentPos ++ ; } } return postponedUpdate ; } } private static class PostponedUpdate { int posInOwnerList ; int currentPos ; boolean removal ; PostponedUpdate ( int posInOwnerList , int currentPos , boolean removal ) { this . posInOwnerList = posInOwnerList ; this . currentPos = currentPos ; this . removal = removal ; } } static class CenteredArray { private final int [ ] mData ; private final int mMid ; CenteredArray ( int size ) { mData = new int [ size ] ; mMid = mData . length / <NUM_LIT> ; } int get ( int index ) { return mData [ index + mMid ] ; } int [ ] backingData ( ) { return mData ; } void set ( int index , int value ) { mData [ index + mMid ] = value ; } public void fill ( int value ) { Arrays . fill ( mData , value ) ; } } }"}, {"input": "package com . norman . webviewup . lib ; import com . norman . webviewup . lib . source . UpgradePackageSource ; import com . norman . webviewup . lib . source . UpgradePathSource ; import com . norman . webviewup . lib . source . UpgradeSource ; import com . norman . webviewup . lib . util . HandlerUtils ; import java . util . HashSet ; import java . util . Set ; public class WebViewUpgrade { private static final Set < UpgradeCallback > UPGRADE_CALLBACK_SET = new HashSet < > ( ) ; private static final int STATUS_NEW = <NUM_LIT> ; private static final int STATUS_RUNNING = <NUM_LIT> ; private static final int STATUS_FAIL = <NUM_LIT> ; private static final int STATUS_COMPLETE = <NUM_LIT> ; private static int UPGRADE_STATUS = STATUS_NEW ; private static float UPGRADE_PROCESS ; private static Throwable UPGRADE_THROWABLE ; public synchronized static boolean isProcessing ( ) { return UPGRADE_STATUS == STATUS_RUNNING ; } public synchronized static boolean isCompleted ( ) { return UPGRADE_STATUS == STATUS_COMPLETE ; } public synchronized static boolean isFailed ( ) { return UPGRADE_STATUS == STATUS_FAIL ; } public synchronized static Throwable getUpgradeError ( ) { return UPGRADE_THROWABLE ; } public synchronized static float getUpgradeProcess ( ) { return UPGRADE_PROCESS ; } public synchronized static void addUpgradeCallback ( UpgradeCallback upgradeCallback ) { UPGRADE_CALLBACK_SET . add ( upgradeCallback ) ; } public synchronized static void removeUpgradeCallback ( UpgradeCallback upgradeCallback ) { UPGRADE_CALLBACK_SET . remove ( upgradeCallback ) ; } public static String getSystemWebViewPackageName ( ) { return WebViewReplace . getSystemWebViewPackageName ( ) ; } public static String getSystemWebViewPackageVersion ( ) { return WebViewReplace . getSystemWebViewPackageVersion ( ) ; } public static String getUpgradeWebViewPackageName ( ) { return WebViewReplace . getReplaceWebViewPackageName ( ) ;", "output": "} public static String getUpgradeWebViewVersion ( ) { return WebViewReplace . getReplaceWebViewVersion ( ) ; } public synchronized static void upgrade ( UpgradeSource webViewSource ) { try { if ( UPGRADE_STATUS == STATUS_RUNNING || UPGRADE_STATUS == STATUS_COMPLETE ) { return ; } UPGRADE_STATUS = STATUS_RUNNING ; UPGRADE_THROWABLE = null ; UPGRADE_PROCESS = <NUM_LIT> ; webViewSource . prepare ( new UpgradeSource . OnPrepareCallback ( ) { @ Override public void onPrepareSuccess ( UpgradeSource webViewSource ) { HandlerUtils . runInMainThread ( ( ) -> { try { if ( webViewSource instanceof UpgradePathSource ) { UpgradePathSource upgradePathSource = ( UpgradePathSource ) webViewSource ; WebViewReplace . replace ( webViewSource . getContext ( ) , upgradePathSource . getApkPath ( ) , upgradePathSource . getLibsPath ( ) ) ; } else if ( webViewSource instanceof UpgradePackageSource ) { UpgradePackageSource upgradePackageSource = ( UpgradePackageSource ) webViewSource ; WebViewReplace . replace ( webViewSource . getContext ( ) , upgradePackageSource . getPackageInfo ( ) ) ; } callProcessCallback ( <NUM_LIT> ) ; callCompleteCallback ( ) ; } catch ( WebViewReplaceException e ) { callErrorCallback ( e ) ; } } ) ; } @ Override public void onPrepareProcess ( UpgradeSource webViewSource , float percent ) { callProcessCallback ( percent * <NUM_LIT> ) ; } @ Override public void onPrepareError ( UpgradeSource webViewSource , Throwable throwable ) { callErrorCallback ( throwable ) ; } } ) ; } catch ( Throwable throwable ) { callErrorCallback ( throwable ) ; } } private static void callErrorCallback ( Throwable throwable ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_STATUS = STATUS_FAIL ; UPGRADE_THROWABLE = throwable ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( ( ) -> upgradeCallback . onUpgradeError ( throwable ) ) ; } } } private static void callCompleteCallback ( ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_STATUS = STATUS_COMPLETE ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( upgradeCallback :: onUpgradeComplete ) ; } } } private static void callProcessCallback ( float percent ) { synchronized ( WebViewUpgrade . class ) { UPGRADE_PROCESS = percent ; for ( UpgradeCallback upgradeCallback : UPGRADE_CALLBACK_SET ) { if ( upgradeCallback == null ) continue ; HandlerUtils . runInMainThread ( ( ) -> upgradeCallback . onUpgradeProcess ( percent ) ) ; } } } }"}, {"input": "package com . reactnative . pulltorefresh . event ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . Event ; public class RefreshEvent extends Event < RefreshEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; public RefreshEvent ( int surfaceId , int viewTag ) {", "output": "super ( surfaceId , viewTag ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { return Arguments . createMap ( ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . datetimepicker ; public class DatetimePickerConfig { private Theme theme = Theme . AUTO ; public Theme getTheme ( ) { return theme ; } public void setTheme ( String value , Theme fallback ) { Theme theme = DatetimePickerHelper . convertStringToTheme ( value ) ; if ( theme == null ) { this . theme = fallback ; } else { this . theme = theme ;", "output": "} } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . text . Layout ; import android . text . Selection ; import android . text . Spannable ; import android . text . method . LinkMovementMethod ; import android . text . method . Touch ; import android . text . style . ClickableSpan ; import android . view . MotionEvent ; import android . widget . TextView ; public class LocalLinkMovementMethod extends LinkMovementMethod { static LocalLinkMovementMethod sInstance ; public static LocalLinkMovementMethod getInstance ( ) { if ( sInstance == null ) sInstance = new LocalLinkMovementMethod ( ) ; return sInstance ; } @ Override public boolean onTouchEvent ( TextView widget , Spannable buffer , MotionEvent event ) { int action = event . getAction ( ) ; if ( action == MotionEvent . ACTION_UP || action == MotionEvent . ACTION_DOWN ) { int x = ( int ) event . getX ( ) ; int y = ( int ) event . getY ( ) ; x -= widget . getTotalPaddingLeft ( ) ; y -= widget . getTotalPaddingTop ( ) ; x += widget . getScrollX ( ) ; y += widget . getScrollY ( ) ; Layout layout = widget . getLayout ( ) ; int line = layout . getLineForVertical ( y ) ; int off = layout . getOffsetForHorizontal ( line , x ) ; ClickableSpan [ ] link = buffer . getSpans ( off , off , ClickableSpan . class ) ;", "output": "if ( link . length != <NUM_LIT> ) { if ( action == MotionEvent . ACTION_UP ) { link [ <NUM_LIT> ] . onClick ( widget ) ; } else if ( action == MotionEvent . ACTION_DOWN ) { Selection . setSelection ( buffer , buffer . getSpanStart ( link [ <NUM_LIT> ] ) , buffer . getSpanEnd ( link [ <NUM_LIT> ] ) ) ; } return true ; } else { Selection . removeSelection ( buffer ) ; Touch . onTouchEvent ( widget , buffer , event ) ; return false ; } } return Touch . onTouchEvent ( widget , buffer , event ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; public class Category { private String name ; public Category ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public static class LeadDeveloperItem { private String title ; private String description ; private int imageResource ; public LeadDeveloperItem ( String title , String description , int imageResource ) { this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ; } } public static class ContributorsItem { private String id , title , description ; private int imageResource ; public ContributorsItem ( String id , String title , String description , int imageResource ) { this . id = id ; this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getId ( ) { return id ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ;", "output": "} } public static class AppItem { private String id , title , description ; private int imageResource ; public AppItem ( String id , String title , String description , int imageResource ) { this . id = id ; this . title = title ; this . description = description ; this . imageResource = imageResource ; } public String getId ( ) { return id ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public int getImageResource ( ) { return imageResource ; } } }"}, {"input": "package com . wmods . wppenhacer . adapter ; import static com . wmods . wppenhacer . xposed . features . customization . IGStatus . itens ; import android . content . Context ; import android . content . Intent ; import android . graphics . Color ; import android . graphics . Typeface ; import android . text . TextUtils ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . views . dialog . TabDialogContent ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . Objects ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class IGStatusAdapter extends ArrayAdapter { private final Class < ? > clazzImageStatus ; private final Class < ? > statusInfoClazz ; private final Method setCountStatus ; @ NonNull @ Override public View getView ( int position , @ Nullable View convertView , @ NonNull ViewGroup parent ) { var item = itens . get ( position ) ; IGStatusViewHolder holder ; if ( convertView == null ) { holder = new IGStatusViewHolder ( ) ; convertView = createLayoutStatus ( holder ) ; convertView . setTag ( holder ) ; } else { holder = ( IGStatusViewHolder ) convertView . getTag ( ) ; } if ( item == null ) { holder . setInfo ( \"<STR_LIT>\" ) ; } else if ( statusInfoClazz . isInstance ( item ) ) { holder . setInfo ( item ) ; } convertView . setOnClickListener ( v -> { if ( holder . myStatus ) { var activity = WppCore . getCurrentActivity ( ) ; var dialog = WppCore . createBottomDialog ( activity ) ; var tabdialog = new TabDialogContent ( activity ) ; tabdialog . setTitle ( activity . getString ( ResId . string . select_status_type ) ) ; tabdialog . addTab ( UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) , DesignUtils . getIconByName ( \"<STR_LIT>\" , true ) , ( view ) -> { var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( \"<STR_LIT>\" , getContext ( ) . getClassLoader ( ) ) ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . open_camera ) , DesignUtils . getIconByName ( \"<STR_LIT>\" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , \"<STR_LIT>\" ) ; A09 . putExtra ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; A09 . putExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; A09 . putExtra ( \"<STR_LIT>\" , false ) ; A09 . putExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; A09 . putExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; A09 . putExtra ( \"<STR_LIT>\" , <NUM_LIT> ) ; activity . startActivity ( A09 ) ; dialog . dismissDialog ( ) ; } ) ; tabdialog . addTab ( activity . getString ( ResId . string . edit_text ) , DesignUtils . getIconByName ( \"<STR_LIT>\" , true ) , ( view ) -> { Intent A09 = new Intent ( ) ; A09 . setClassName ( activity . getPackageName ( ) , \"<STR_LIT>\" ) ; activity . startActivity ( A09 ) ;", "output": "dialog . dismissDialog ( ) ; } ) ; dialog . setContentView ( tabdialog ) ; dialog . showDialog ( ) ; return ; } var intent = new Intent ( WppCore . getCurrentActivity ( ) , XposedHelpers . findClass ( \"<STR_LIT>\" , getContext ( ) . getClassLoader ( ) ) ) ; intent . putExtra ( \"<STR_LIT>\" , holder . jid ) ; WppCore . getCurrentActivity ( ) . startActivity ( intent ) ; } ) ; return convertView ; } public IGStatusAdapter ( @ NonNull Context context , @ NonNull Class < ? > statusInfoClazz ) { super ( context , <NUM_LIT> ) ; this . clazzImageStatus = XposedHelpers . findClass ( \"<STR_LIT>\" , this . getContext ( ) . getClassLoader ( ) ) ; this . statusInfoClazz = statusInfoClazz ; this . setCountStatus = ReflectionUtils . findMethodUsingFilter ( this . clazzImageStatus , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; } @ Override public int getCount ( ) { return itens . size ( ) ; } class IGStatusViewHolder { public ImageView igStatusContactPhoto ; public RelativeLayout addButton ; public TextView igStatusContactName ; public boolean myStatus ; private String jid ; public void setInfo ( Object item ) { if ( Objects . equals ( item , \"<STR_LIT>\" ) ) { myStatus = true ; igStatusContactName . setText ( UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) ) ; igStatusContactPhoto . setImageDrawable ( WppCore . getMyPhoto ( ) ) ; setCountStatus ( <NUM_LIT> , <NUM_LIT> ) ; return ; } var statusInfo = XposedHelpers . getObjectField ( item , \"<STR_LIT>\" ) ; var field = ReflectionUtils . getFieldByType ( statusInfo . getClass ( ) , XposedHelpers . findClass ( \"<STR_LIT>\" , statusInfoClazz . getClassLoader ( ) ) ) ; var userJid = ReflectionUtils . getField ( field , statusInfo ) ; var contactName = WppCore . getContactName ( userJid ) ; jid = WppCore . getRawString ( userJid ) ; igStatusContactName . setText ( contactName ) ; var profile = WppCore . getContactPhotoDrawable ( jid ) ; if ( profile == null ) profile = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; igStatusContactPhoto . setImageDrawable ( profile ) ; var countUnseen = XposedHelpers . getIntField ( statusInfo , \"<STR_LIT>\" ) ; var total = XposedHelpers . getIntField ( statusInfo , \"<STR_LIT>\" ) ; setCountStatus ( countUnseen , total ) ; } public void setCountStatus ( int countUnseen , int total ) { if ( setCountStatus != null ) { try { setCountStatus . invoke ( igStatusContactPhoto , countUnseen , total ) ; } catch ( Exception e ) { XposedBridge . log ( e ) ; } } } } @ NonNull private RelativeLayout createLayoutStatus ( IGStatusViewHolder holder ) { RelativeLayout relativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams relativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , ViewGroup . LayoutParams . WRAP_CONTENT ) ; relativeLayout . setLayoutParams ( relativeParams ) ; FrameLayout frameLayout = new FrameLayout ( this . getContext ( ) ) ; frameLayout . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; LinearLayout linearLayout = new LinearLayout ( this . getContext ( ) ) ; LinearLayout . LayoutParams linearParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( linearParams ) ; RelativeLayout internalRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; RelativeLayout . LayoutParams internalRelativeParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; internalRelativeLayout . setLayoutParams ( internalRelativeParams ) ; var contactPhoto = ( ImageView ) XposedHelpers . newInstance ( this . clazzImageStatus , this . getContext ( ) ) ; RelativeLayout . LayoutParams photoParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; contactPhoto . setLayoutParams ( photoParams ) ; contactPhoto . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; contactPhoto . setScaleType ( ImageView . ScaleType . CENTER_CROP ) ; contactPhoto . setImageDrawable ( DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ) ; holder . igStatusContactPhoto = contactPhoto ; contactPhoto . setClickable ( true ) ; XposedHelpers . callMethod ( contactPhoto , \"<STR_LIT>\" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . callMethod ( contactPhoto , \"<STR_LIT>\" , ( float ) Utils . dipToPixels ( <NUM_LIT> ) ) ; XposedHelpers . setObjectField ( contactPhoto , \"<STR_LIT>\" , Color . GRAY ) ; XposedHelpers . setObjectField ( contactPhoto , \"<STR_LIT>\" , DesignUtils . getUnSeenColor ( ) ) ; RelativeLayout addBtnRelativeLayout = new RelativeLayout ( this . getContext ( ) ) ; addBtnRelativeLayout . setBackgroundColor ( Color . TRANSPARENT ) ; RelativeLayout . LayoutParams addBtnParams = new RelativeLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_BOTTOM ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_END ) ; addBtnParams . addRule ( RelativeLayout . ALIGN_PARENT_RIGHT ) ; addBtnRelativeLayout . setLayoutParams ( addBtnParams ) ; addBtnRelativeLayout . setVisibility ( View . GONE ) ; holder . addButton = addBtnRelativeLayout ; ImageView iconImageView = new ImageView ( this . getContext ( ) ) ; RelativeLayout . LayoutParams iconParams = new RelativeLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; iconImageView . setLayoutParams ( iconParams ) ; var icon = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; iconImageView . setImageDrawable ( icon ) ; iconImageView . setBackgroundColor ( Color . TRANSPARENT ) ; addBtnRelativeLayout . addView ( iconImageView ) ; internalRelativeLayout . addView ( contactPhoto ) ; internalRelativeLayout . addView ( addBtnRelativeLayout ) ; TextView contactName = new TextView ( this . getContext ( ) ) ; contactName . setEllipsize ( TextUtils . TruncateAt . END ) ; contactName . setGravity ( Gravity . CENTER ) ; LinearLayout . LayoutParams nameParams = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ; contactName . setLayoutParams ( nameParams ) ; contactName . setText ( \"<STR_LIT>\" ) ; contactName . setTextAlignment ( View . TEXT_ALIGNMENT_CENTER ) ; contactName . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; contactName . setTypeface ( Typeface . DEFAULT_BOLD ) ; contactName . setMaxLines ( <NUM_LIT> ) ; holder . igStatusContactName = contactName ; linearLayout . addView ( internalRelativeLayout ) ; linearLayout . addView ( contactName ) ; frameLayout . addView ( linearLayout ) ; relativeLayout . addView ( frameLayout ) ; return relativeLayout ; } }"}, {"input": "package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . ConnectException ; import java . util . HashMap ; public class AdbConnection implements Closeable { AdbChannel channel ; private int lastLocalId ; private Thread connectionThread ; private boolean connectAttempted ; private boolean connected ; private int maxData ; private AdbCrypto crypto ; private boolean sentSignature ; private HashMap < Integer , AdbStream > openStreams ; private AdbConnection ( ) { openStreams = new HashMap < Integer , AdbStream > ( ) ; lastLocalId = <NUM_LIT> ; connectionThread = createConnectionThread ( ) ; } public static AdbConnection create ( AdbChannel channel , AdbCrypto crypto ) throws IOException { AdbConnection newConn = new AdbConnection ( ) ; newConn . crypto = crypto ; newConn . channel = channel ; return newConn ; } private Thread createConnectionThread ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) final AdbConnection conn = this ; return new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( ! connectionThread . isInterrupted ( ) ) { try { AdbMessage msg = AdbMessage . parseAdbMessage ( channel ) ; if ( ! AdbProtocol . validateMessage ( msg ) ) continue ; switch ( msg . getCommand ( ) ) { case AdbProtocol . CMD_OKAY : case AdbProtocol . CMD_WRTE : case AdbProtocol . CMD_CLSE : if ( ! conn . connected ) continue ; AdbStream waitingStream = openStreams . get ( msg . getArg1 ( ) ) ; if ( waitingStream == null ) continue ; synchronized ( waitingStream ) { if ( msg . getCommand ( ) == AdbProtocol . CMD_OKAY ) { waitingStream . updateRemoteId ( msg . getArg0 ( ) ) ; waitingStream . readyForWrite ( ) ; waitingStream . notify ( ) ; } else if ( msg . getCommand ( ) == AdbProtocol . CMD_WRTE ) { waitingStream . addPayload ( msg . getPayload ( ) ) ; waitingStream . sendReady ( ) ; } else if ( msg . getCommand ( ) == AdbProtocol . CMD_CLSE ) { conn . openStreams . remove ( msg . getArg1 ( ) ) ; waitingStream . notifyClose ( ) ; } } break ; case AdbProtocol . CMD_AUTH : AdbMessage packet ; if ( msg . getArg0 ( ) == AdbProtocol . AUTH_TYPE_TOKEN ) { if ( conn . sentSignature ) { packet = AdbProtocol . generateAuth ( AdbProtocol . AUTH_TYPE_RSA_PUBLIC , conn . crypto . getAdbPublicKeyPayload ( ) ) ; } else { packet = AdbProtocol . generateAuth ( AdbProtocol . AUTH_TYPE_SIGNATURE , conn . crypto . signAdbTokenPayload ( msg . getPayload ( ) ) ) ; conn . sentSignature = true ; } conn . channel . writex ( packet ) ; } break ; case AdbProtocol . CMD_CNXN : synchronized ( conn ) { conn . maxData = msg . getArg1 ( ) ; conn . connected = true ; conn . notifyAll ( ) ; } break ; default : break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; break ; } } synchronized ( conn ) { cleanupStreams ( ) ; conn . notifyAll ( ) ; conn . connectAttempted = false ; } } } ) ; } public int getMaxData ( ) throws InterruptedException , IOException {", "output": "if ( ! connectAttempted ) throw new IllegalStateException ( \"<STR_LIT>\" ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( \"<STR_LIT>\" ) ; } } return maxData ; } public void connect ( ) throws IOException , InterruptedException { if ( connected ) throw new IllegalStateException ( \"<STR_LIT>\" ) ; channel . writex ( AdbProtocol . generateConnect ( ) ) ; connectAttempted = true ; connectionThread . start ( ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( \"<STR_LIT>\" ) ; } } } public AdbStream open ( String destination ) throws UnsupportedEncodingException , IOException , InterruptedException { int localId = ++ lastLocalId ; if ( ! connectAttempted ) throw new IllegalStateException ( \"<STR_LIT>\" ) ; synchronized ( this ) { if ( ! connected ) wait ( ) ; if ( ! connected ) { throw new IOException ( \"<STR_LIT>\" ) ; } } AdbStream stream = new AdbStream ( this , localId ) ; openStreams . put ( localId , stream ) ; channel . writex ( AdbProtocol . generateOpen ( localId , destination ) ) ; synchronized ( stream ) { stream . wait ( ) ; } if ( stream . isClosed ( ) ) throw new ConnectException ( \"<STR_LIT>\" ) ; return stream ; } private void cleanupStreams ( ) { for ( AdbStream s : openStreams . values ( ) ) { try { s . close ( ) ; } catch ( IOException e ) { } } openStreams . clear ( ) ; } @ Override public void close ( ) throws IOException { if ( connectionThread == null ) return ; channel . close ( ) ; connectionThread . interrupt ( ) ; try { connectionThread . join ( ) ; } catch ( InterruptedException e ) { } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; import top . weixiansen574 . hybridfilexfer . core . bean . TransferredBytesInfo ; public class ParcelableTransferredBytesInfo extends TransferredBytesInfo implements Parcelable { public ParcelableTransferredBytesInfo ( TransferredBytesInfo info ) { super ( info . getUsbReceiveBytes ( ) , info . getUsbSentBytes ( ) , info . getWifiReceiveBytes ( ) , info . getWifiSentBytes ( ) ) ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; }", "output": "@ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeLong ( this . usbReceiveBytes ) ; dest . writeLong ( this . usbSentBytes ) ; dest . writeLong ( this . wifiReceiveBytes ) ; dest . writeLong ( this . wifiSentBytes ) ; } public void readFromParcel ( Parcel source ) { this . usbReceiveBytes = source . readLong ( ) ; this . usbSentBytes = source . readLong ( ) ; this . wifiReceiveBytes = source . readLong ( ) ; this . wifiSentBytes = source . readLong ( ) ; } protected ParcelableTransferredBytesInfo ( Parcel in ) { super ( in . readLong ( ) , in . readLong ( ) , in . readLong ( ) , in . readLong ( ) ) ; } public static final Creator < ParcelableTransferredBytesInfo > CREATOR = new Creator < ParcelableTransferredBytesInfo > ( ) { @ Override public ParcelableTransferredBytesInfo createFromParcel ( Parcel source ) { return new ParcelableTransferredBytesInfo ( source ) ; } @ Override public ParcelableTransferredBytesInfo [ ] newArray ( int size ) { return new ParcelableTransferredBytesInfo [ size ] ; } } ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import java . util . ArrayList ; public class CommentReplyPage { public BiliComment root ; public ArrayList < BiliComment > replies ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . photoeditor ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . content . pm . ResolveInfo ; import android . net . Uri ; import android . provider . MediaStore ; import androidx . core . content . FileProvider ; import com . getcapacitor . Bridge ; import com . getcapacitor . Logger ; import java . io . File ; import java . net . URI ; import java . util . List ; public class PhotoEditor { private Bridge bridge ; PhotoEditor ( Bridge bridge ) { this . bridge = bridge ; } public Intent createEditPhotoIntent ( String path ) {", "output": "try { File file = new File ( new URI ( path ) ) ; String contextPackageName = bridge . getContext ( ) . getPackageName ( ) ; Uri uri = FileProvider . getUriForFile ( bridge . getActivity ( ) , contextPackageName + \"<STR_LIT>\" , file ) ; Intent intent = new Intent ( Intent . ACTION_EDIT ) ; intent . setDataAndType ( uri , \"<STR_LIT>\" ) ; intent . putExtra ( MediaStore . EXTRA_OUTPUT , uri ) ; int flags = Intent . FLAG_GRANT_READ_URI_PERMISSION | Intent . FLAG_GRANT_WRITE_URI_PERMISSION ; intent . addFlags ( flags ) ; List < ResolveInfo > resolveInfoList = bridge . getContext ( ) . getPackageManager ( ) . queryIntentActivities ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; for ( ResolveInfo resolveInfo : resolveInfoList ) { String packageName = resolveInfo . activityInfo . packageName ; bridge . getContext ( ) . grantUriPermission ( packageName , uri , flags ) ; } return intent ; } catch ( Exception exception ) { Logger . error ( \"<STR_LIT>\" , exception ) ; return null ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DownloadBundleOptions { @ NonNull private String bundleId ; @ Nullable private String checksum ; @ NonNull private String url ; public DownloadBundleOptions ( @ NonNull String bundleId , @ Nullable String checksum , @ NonNull String url ) { this . bundleId = bundleId ; this . checksum = checksum ; this . url = url ; } @ NonNull public String getBundleId ( ) {", "output": "return bundleId ; } @ Nullable public String getChecksum ( ) { return checksum ; } @ NonNull public String getUrl ( ) { return url ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; public class ActivityResult { public ActivityResult ( Intent intent ) { this . intent = intent ; }", "output": "public Intent intent ; }"}, {"input": "package com . appspa . update . logs ; import androidx . annotation . NonNull ; import android . util . Log ; import java . io . PrintWriter ; import java . io . StringWriter ; public class LogcatLogger implements ILogger { private static final int MAX_LOG_LENGTH = <NUM_LIT> ; @ Override public void log ( int priority , String tag , String message , Throwable t ) { if ( message != null && message . length ( ) == <NUM_LIT> ) { message = null ; } if ( message == null ) { if ( t == null ) { return ; } message = getStackTraceString ( t ) ; } else { if ( t != null ) { message += \"<STR_LIT>\" + getStackTraceString ( t ) ; } } log ( priority , tag , message ) ; } private String getStackTraceString ( Throwable t ) { StringWriter sw = new StringWriter ( <NUM_LIT> ) ; PrintWriter pw = new PrintWriter ( sw , false ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; return sw . toString ( ) ; } public void log ( int priority , String tag , String message ) { int subNum = message . length ( ) / MAX_LOG_LENGTH ; if ( subNum > <NUM_LIT> ) { int index = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < subNum ; i ++ ) { int lastIndex = index + MAX_LOG_LENGTH ; String sub = message . substring ( index , lastIndex ) ; logSub ( priority , tag , sub ) ; index = lastIndex ; } logSub ( priority , tag , message . substring ( index , message . length ( ) ) ) ; } else {", "output": "logSub ( priority , tag , message ) ; } } private void logSub ( int priority , @ NonNull String tag , @ NonNull String sub ) { switch ( priority ) { case Log . VERBOSE : Log . v ( tag , sub ) ; break ; case Log . DEBUG : Log . d ( tag , sub ) ; break ; case Log . INFO : Log . i ( tag , sub ) ; break ; case Log . WARN : Log . w ( tag , sub ) ; break ; case Log . ERROR : Log . e ( tag , sub ) ; break ; case Log . ASSERT : Log . wtf ( tag , sub ) ; break ; default : Log . v ( tag , sub ) ; break ; } } }"}, {"input": "package com . simon . harmonichackernews ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import android . text . Html ; import android . view . View ; import android . widget . TextView ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . utils . Changelog ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; public class AboutActivity extends AppCompatActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false ) ; setContentView ( R . layout . activity_about ) ; String versionText = \"<STR_LIT>\" + BuildConfig . VERSION_NAME ; if ( BuildConfig . DEBUG ) { versionText += String . format ( \"<STR_LIT>\" , BuildConfig . BUILD_TYPE ) ; } ( ( TextView ) findViewById ( R . id . about_version ) ) . setText ( versionText ) ; } public void openGithub ( View v ) { String url = \"<STR_LIT>\" ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; }", "output": "public void openChangelog ( View v ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( Html . fromHtml ( Changelog . getHTML ( ) ) ) . setNegativeButton ( \"<STR_LIT>\" , null ) . create ( ) ; dialog . show ( ) ; } public void openPrivacy ( View v ) { Utils . launchCustomTab ( this , \"<STR_LIT>\" ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . badge ; import static me . leolin . shortcutbadger . ShortcutBadger . isBadgeCounterSupported ; import android . content . Context ; import android . content . SharedPreferences ; import com . getcapacitor . Logger ; import me . leolin . shortcutbadger . ShortcutBadger ; public class Badge { private static final String STORAGE_KEY = \"<STR_LIT>\" ; private Context context ; private BadgeConfig config ; Badge ( Context context , BadgeConfig config ) { this . config = config ; if ( isBadgeCounterSupported ( context ) ) { this . context = context ; } else { this . context = context . getApplicationContext ( ) ; } boolean restoreCount = this . config . getPersist ( ) ; if ( restoreCount ) { restore ( ) ; } } public void handleOnResume ( ) { try { boolean resetCount = this . config . getAutoClear ( ) ;", "output": "if ( resetCount ) { set ( <NUM_LIT> ) ; } } catch ( Exception ex ) { Logger . error ( ex . getLocalizedMessage ( ) , ex ) ; } } public int get ( ) { return getPrefs ( ) . getInt ( STORAGE_KEY , <NUM_LIT> ) ; } public void set ( int count ) { SharedPreferences . Editor editor = getPrefs ( ) . edit ( ) ; editor . putInt ( STORAGE_KEY , count ) ; editor . apply ( ) ; ShortcutBadger . applyCount ( context , count ) ; } public void increase ( ) { int count = get ( ) ; set ( count + <NUM_LIT> ) ; } public void decrease ( ) { int count = get ( ) ; if ( count < <NUM_LIT> ) { return ; } set ( count - <NUM_LIT> ) ; } public void clear ( ) { set ( <NUM_LIT> ) ; } public boolean isSupported ( ) { int count = get ( ) ; boolean isSupported = ShortcutBadger . isBadgeCounterSupported ( context ) ; if ( isSupported ) { set ( count ) ; } return isSupported ; } private void restore ( ) { try { int count = get ( ) ; ShortcutBadger . applyCount ( context , count ) ; } catch ( Exception ex ) { Logger . error ( ex . getLocalizedMessage ( ) , ex ) ; } } private SharedPreferences getPrefs ( ) { return context . getSharedPreferences ( STORAGE_KEY , Context . MODE_PRIVATE ) ; } }"}, {"input": "package de . robv . android . xposed . callbacks ; import android . content . pm . ApplicationInfo ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_LoadPackage extends XCallback implements IXposedHookLoadPackage { @ SuppressWarnings ( \"<STR_LIT>\" ) public XC_LoadPackage ( ) { super ( ) ; } public XC_LoadPackage ( int priority ) { super ( priority ) ; } public static final class LoadPackageParam extends XCallback . Param { public LoadPackageParam ( CopyOnWriteSortedSet < XC_LoadPackage > callbacks ) { super ( callbacks ) ; } public String packageName ;", "output": "public String processName ; public ClassLoader classLoader ; public ApplicationInfo appInfo ; public boolean isFirstApplication ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof LoadPackageParam ) handleLoadPackage ( ( LoadPackageParam ) param ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . inputstream ; import android . content . Context ; import android . media . AudioFormat ; import android . media . AudioRecord ; import android . media . MediaRecorder ; import android . util . Log ; import java . io . IOException ; import java . io . InputStream ; public class MyMicrophoneInputStream extends InputStream { private static AudioRecord audioRecord ; private static MyMicrophoneInputStream is ; private boolean isStarted = false ; private static final String TAG = \"<STR_LIT>\" ; public MyMicrophoneInputStream ( ) { if ( audioRecord == null ) { int bufferSize = AudioRecord . getMinBufferSize ( <NUM_LIT> , AudioFormat . CHANNEL_IN_MONO , AudioFormat . ENCODING_PCM_16BIT ) * <NUM_LIT> ; audioRecord = new AudioRecord ( MediaRecorder . AudioSource . MIC , <NUM_LIT> , AudioFormat . CHANNEL_IN_MONO , AudioFormat . ENCODING_PCM_16BIT , bufferSize ) ; } } public static MyMicrophoneInputStream getInstance ( ) { if ( is == null ) { synchronized ( MyMicrophoneInputStream . class ) { if ( is == null ) { is = new MyMicrophoneInputStream ( ) ; } } } return is ; } public void start ( ) { Log . i ( TAG , \"<STR_LIT>\" ) ; try { if ( audioRecord == null || audioRecord . getState ( ) != AudioRecord . STATE_INITIALIZED ) {", "output": "throw new IllegalStateException ( \"<STR_LIT>\" + ( audioRecord == null ) ) ; } Context context = InFileStream . getContext ( ) ; audioRecord . startRecording ( ) ; } catch ( Exception e ) { Log . e ( TAG , e . getClass ( ) . getSimpleName ( ) , e ) ; } Log . i ( TAG , \"<STR_LIT>\" ) ; } @ Override public int read ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( ! isStarted ) { start ( ) ; isStarted = true ; } try { int count = audioRecord . read ( b , off , len ) ; return count ; } catch ( Exception e ) { Log . e ( TAG , e . getClass ( ) . getSimpleName ( ) , e ) ; throw e ; } } @ Override public void close ( ) throws IOException { Log . i ( TAG , \"<STR_LIT>\" ) ; if ( audioRecord != null ) { audioRecord . stop ( ) ; isStarted = false ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . LayerDrawable ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . RoundRectShape ; import android . view . Gravity ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class FilterGroups extends Feature { private Method methodSetFilter ; private Object mFilterInstance ; private Object mConversationFragment ; private Method methodInitFilter ; private TextView tabConversas ; private TextView tabGrupos ; public FilterGroups ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) || prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( Utils . getApplication ( ) . getPackageName ( ) . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var filterAdaperClass = Unobfuscator . loadFilterAdaperClass ( classLoader ) ; methodSetFilter = ReflectionUtils . findMethodUsingFilter ( filterAdaperClass , m -> m . getParameterCount ( ) == <NUM_LIT> && m . getParameterTypes ( ) [ <NUM_LIT> ] . equals ( int . class ) ) ; XposedBridge . hookAllConstructors ( filterAdaperClass , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mFilterInstance = param . thisObject ; } } ) ; var cFrag = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; XposedBridge . hookAllConstructors ( cFrag , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mConversationFragment = param . thisObject ; } } ) ; methodInitFilter = Unobfuscator . getFilterInitMethod ( classLoader ) ; var filterView = Unobfuscator . getFilterView ( classLoader ) ; XposedHelpers . findAndHookConstructor ( filterView , android . content . Context . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { setSetupSeparate ( ( ViewGroup ) param . thisObject ) ; } } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void setSetupSeparate ( ViewGroup view ) { var context = view . getContext ( ) ; if ( view . findViewById ( <NUM_LIT> ) != null ) return ; var container = new LinearLayout ( context ) ; container . setOrientation ( LinearLayout . VERTICAL ) ; container . setLayoutParams ( new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; container . setId ( <NUM_LIT> ) ; var filter = view . getChildAt ( <NUM_LIT> ) ; view . removeView ( filter ) ; LinearLayout mainLayout = new LinearLayout ( context ) ; mainLayout . setOrientation ( LinearLayout . VERTICAL ) ; var params = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . leftMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . rightMargin = Utils . dipToPixels ( <NUM_LIT> ) ; params . bottomMargin = Utils . dipToPixels ( <NUM_LIT> ) ; mainLayout . setLayoutParams ( params ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , DesignUtils . getUnSeenColor ( ) ) ; borderDrawable . setCornerRadius ( Utils . dipToPixels ( <NUM_LIT> ) ) ; mainLayout . setBackground ( borderDrawable ) ; LinearLayout tabLayout = new LinearLayout ( context ) ; tabLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; mainLayout . addView ( tabLayout , new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; tabConversas = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; tabConversas . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabConversas . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabGrupos = createTab ( context , UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; tabGrupos . setLayoutParams ( new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; tabGrupos . setOnClickListener ( v -> updateContent ( <NUM_LIT> ) ) ; tabLayout . addView ( tabConversas ) ; tabLayout . addView ( tabGrupos ) ; updateContent ( <NUM_LIT> ) ; container . addView ( mainLayout ) ; container . addView ( filter ) ; view . addView ( container , <NUM_LIT> ) ; } private TextView createTab ( Context context , String text , int left ) { TextView tab = new TextView ( context ) ; tab . setText ( text ) ; tab . setGravity ( Gravity . CENTER ) ; tab . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; tab . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; setDrawableSelected ( tab , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , left ) ; return tab ; } private void setDrawableSelected ( View view , int colorBackground , int colorStroke , int left ) { float border = Utils . dipToPixels ( <NUM_LIT> ) ; float [ ] rects = left == <NUM_LIT> ? new float [ ] { border , border , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , border , border } : new float [ ] { <NUM_LIT> , <NUM_LIT> , border , border , border , border , <NUM_LIT> , <NUM_LIT> } ; ShapeDrawable shape = new ShapeDrawable ( new RoundRectShape ( rects , null , null ) ) ; shape . getPaint ( ) . setColor ( colorBackground ) ; shape . setAlpha ( <NUM_LIT> ) ; GradientDrawable borderDrawable = new GradientDrawable ( ) ; borderDrawable . setColor ( Color . TRANSPARENT ) ; borderDrawable . setStroke ( Utils . dipToPixels ( <NUM_LIT> ) , colorStroke ) ; borderDrawable . setCornerRadii ( rects ) ; LayerDrawable layerDrawable = new LayerDrawable ( new Drawable [ ] { borderDrawable , shape } ) ; layerDrawable . setLayerInset ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; view . setBackground ( layerDrawable ) ; } private void updateContent ( int position ) { if ( position == <NUM_LIT> ) { setDrawableSelected ( tabConversas , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setDrawableSelected ( tabGrupos , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } else { setDrawableSelected ( tabConversas , Color . TRANSPARENT , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ;", "output": "setDrawableSelected ( tabGrupos , DesignUtils . getUnSeenColor ( ) , DesignUtils . getPrimaryTextColor ( ) , <NUM_LIT> ) ; setFilter ( position ) ; } } private void setFilter ( int position ) { try { ReflectionUtils . callMethod ( methodInitFilter , null , mConversationFragment ) ; ReflectionUtils . callMethod ( methodSetFilter , mFilterInstance , position + <NUM_LIT> ) ; } catch ( Exception e ) { logDebug ( e ) ; } } @ NonNull @ Override public String getPluginName ( ) { return null ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . content . res . Resources ; import android . graphics . Canvas ; import android . graphics . ColorFilter ; import android . graphics . Matrix ; import android . graphics . Outline ; import android . graphics . Paint ; import android . graphics . Path ; import android . graphics . PixelFormat ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . graphics . drawable . DrawableCompat ; class Md2PopupBackground extends Drawable {", "output": "@ NonNull private final Paint mPaint ; private final int mPaddingStart ; private final int mPaddingEnd ; @ NonNull private final Path mPath = new Path ( ) ; @ NonNull private final Matrix mTempMatrix = new Matrix ( ) ; public Md2PopupBackground ( @ NonNull Context context ) { mPaint = new Paint ( ) ; mPaint . setAntiAlias ( true ) ; mPaint . setColor ( Utils . getColorFromAttrRes ( android . R . attr . colorControlActivated , context ) ) ; mPaint . setStyle ( Paint . Style . FILL ) ; Resources resources = context . getResources ( ) ; mPaddingStart = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_start ) ; mPaddingEnd = resources . getDimensionPixelOffset ( R . dimen . afs_md2_popup_padding_end ) ; } @ Override public void draw ( @ NonNull Canvas canvas ) { canvas . drawPath ( mPath , mPaint ) ; } @ Override public boolean onLayoutDirectionChanged ( int layoutDirection ) { updatePath ( ) ; return true ; } @ Override public void setAlpha ( int alpha ) { } @ Override public void setColorFilter ( @ Nullable ColorFilter colorFilter ) { } @ Override public boolean isAutoMirrored ( ) { return true ; } private boolean needMirroring ( ) { return DrawableCompat . getLayoutDirection ( this ) == View . LAYOUT_DIRECTION_RTL ; } @ Override public int getOpacity ( ) { return PixelFormat . TRANSLUCENT ; } @ Override protected void onBoundsChange ( @ NonNull Rect bounds ) { updatePath ( ) ; } private void updatePath ( ) { mPath . reset ( ) ; Rect bounds = getBounds ( ) ; float width = bounds . width ( ) ; float height = bounds . height ( ) ; float r = height / <NUM_LIT> ; float sqrt2 = ( float ) Math . sqrt ( <NUM_LIT> ) ; width = Math . max ( r + sqrt2 * r , width ) ; pathArcTo ( mPath , r , r , r , <NUM_LIT> , <NUM_LIT> ) ; float o1X = width - sqrt2 * r ; pathArcTo ( mPath , o1X , r , r , - <NUM_LIT> , <NUM_LIT> ) ; float r2 = r / <NUM_LIT> ; float o2X = width - sqrt2 * r2 ; pathArcTo ( mPath , o2X , r , r2 , - <NUM_LIT> , <NUM_LIT> ) ; pathArcTo ( mPath , o1X , r , r , <NUM_LIT> , <NUM_LIT> ) ; mPath . close ( ) ; if ( needMirroring ( ) ) { mTempMatrix . setScale ( - <NUM_LIT> , <NUM_LIT> , width / <NUM_LIT> , <NUM_LIT> ) ; } else { mTempMatrix . reset ( ) ; } mTempMatrix . postTranslate ( bounds . left , bounds . top ) ; mPath . transform ( mTempMatrix ) ; } private static void pathArcTo ( @ NonNull Path path , float centerX , float centerY , float radius , float startAngle , float sweepAngle ) { path . arcTo ( centerX - radius , centerY - radius , centerX + radius , centerY + radius , startAngle , sweepAngle , false ) ; } @ Override public boolean getPadding ( @ NonNull Rect padding ) { if ( needMirroring ( ) ) { padding . set ( mPaddingEnd , <NUM_LIT> , mPaddingStart , <NUM_LIT> ) ; } else { padding . set ( mPaddingStart , <NUM_LIT> , mPaddingEnd , <NUM_LIT> ) ; } return true ; } @ Override public void getOutline ( @ NonNull Outline outline ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . Q && ! mPath . isConvex ( ) ) { super . getOutline ( outline ) ; return ; } outline . setConvexPath ( mPath ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . bean ; public class BookMark { public final int id ; public final String path ; public BookMark ( int id , String path ) { this . id = id ;", "output": "this . path = path ; } }"}, {"input": "package com . reactnative . overlay ; import android . content . Context ; import android . os . Bundle ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . view . ViewTreeObserver ; import androidx . annotation . Nullable ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . ReactRootView ; import java . lang . reflect . Method ; public class OverlayRootView extends ReactRootView { public OverlayRootView ( Context context ) { super ( context ) ; } public OverlayRootView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public OverlayRootView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } private boolean shouldConsumeTouchEvent = true ; public void setShouldConsumeTouchEvent ( boolean consume ) { this . shouldConsumeTouchEvent = consume ; } @ Override public boolean onTouchEvent ( MotionEvent ev ) { int action = ev . getAction ( ) & MotionEvent . ACTION_MASK ; if ( action == MotionEvent . ACTION_DOWN ) { onChildStartedNativeGesture ( ev ) ; } return shouldConsumeTouchEvent ;", "output": "} @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; removeOnGlobalLayoutListener ( ) ; } @ Override protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; removeOnGlobalLayoutListener ( ) ; } @ Override public void startReactApplication ( ReactInstanceManager reactInstanceManager , String moduleName , @ Nullable Bundle initialProperties ) { super . startReactApplication ( reactInstanceManager , moduleName , initialProperties ) ; removeOnGlobalLayoutListener ( ) ; } private boolean shouldRunApplication = true ; @ Override public void runApplication ( ) { if ( shouldRunApplication ) { shouldRunApplication = false ; super . runApplication ( ) ; } } private boolean hbd_isAttachedToReactInstance ; @ Override public void onAttachedToReactInstance ( ) { super . onAttachedToReactInstance ( ) ; hbd_isAttachedToReactInstance = true ; } @ Override public void setAppProperties ( @ Nullable Bundle appProperties ) { if ( hbd_isAttachedToReactInstance ) { shouldRunApplication = true ; super . setAppProperties ( appProperties ) ; } } @ Override public void unmountReactApplication ( ) { super . unmountReactApplication ( ) ; removeOnGlobalLayoutListener ( ) ; } private ViewTreeObserver . OnGlobalLayoutListener mGlobalLayoutListener ; private ViewTreeObserver . OnGlobalLayoutListener getGlobalLayoutListener ( ) { if ( mGlobalLayoutListener == null ) { try { Method method = ReactRootView . class . getDeclaredMethod ( \"<STR_LIT>\" ) ; method . setAccessible ( true ) ; mGlobalLayoutListener = ( ViewTreeObserver . OnGlobalLayoutListener ) method . invoke ( this ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return mGlobalLayoutListener ; } void addOnGlobalLayoutListener ( ) { removeOnGlobalLayoutListener ( ) ; getViewTreeObserver ( ) . addOnGlobalLayoutListener ( getGlobalLayoutListener ( ) ) ; } void removeOnGlobalLayoutListener ( ) { getViewTreeObserver ( ) . removeOnGlobalLayoutListener ( getGlobalLayoutListener ( ) ) ; } }"}, {"input": "package com . wmods . wppenhacer . listeners ; import android . view . GestureDetector ; import android . view . MotionEvent ; public class DoubleTapListener extends GestureDetector . SimpleOnGestureListener { private final OnDoubleClickListener listener ; public DoubleTapListener ( OnDoubleClickListener listener ) { this . listener = listener ; }", "output": "@ Override public boolean onDoubleTap ( MotionEvent e ) { listener . onDoubleClick ( ) ; return true ; } public interface OnDoubleClickListener { void onDoubleClick ( ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; import android . content . Context ; import android . util . AttributeSet ; import android . widget . EditText ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . material . R ; import com . google . android . material . search . SearchView ; public class CustomSearchView extends SearchView { public CustomSearchView ( @ NonNull Context context ) { super ( context ) ; } public CustomSearchView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ;", "output": "} public CustomSearchView ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } public EditText getSearchEditText ( ) { return findViewById ( R . id . open_search_view_edit_text ) ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; public class ReflectConstructor { private final Object mConstructorLock = new Object ( ) ; private String mClassName ; private Class < ? > mClass ; private Constructor < ? > mConstructor ; private Class < ? > [ ] mParameterTypes ; private Constructor < ? > assessConstructor ; public ReflectConstructor ( Constructor < ? > constructor ) { this . mConstructor = constructor ; this . mParameterTypes = constructor . getParameterTypes ( ) ; } public ReflectConstructor ( String className , Class < ? > ... parameterTypes ) { this . mClassName = className ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectConstructor ( Class < ? > cls , Class < ? > ... parameterTypes ) { this . mClass = cls ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectConstructor ( Object obj , Class < ? > ... parameterTypes ) { if ( obj != null ) { if ( obj instanceof Class < ? > ) { this . mClass = ( Class < ? > ) obj ;", "output": "} else { this . mClass = obj . getClass ( ) ; } } this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public Object newInstance ( Object ... args ) throws ReflectException { synchronized ( mConstructorLock ) { prepareConstructor ( ) ; try { return assessConstructor . newInstance ( args ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private void prepareConstructor ( ) throws ReflectException { synchronized ( mConstructorLock ) { try { if ( assessConstructor != null ) { return ; } Constructor < ? > findConstructor = mConstructor ; if ( findConstructor == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } if ( findClass != null ) { findConstructor = findClass . getDeclaredConstructor ( mParameterTypes ) ; } } if ( findConstructor == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" ) ; } int modifiers = findConstructor . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findConstructor . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findConstructor . isAccessible ( ) ) { findConstructor . setAccessible ( true ) ; } } assessConstructor = findConstructor ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . util ; import com . baidu . speech . asr . SpeechConstant ; import java . util . LinkedHashMap ; import java . util . Map ; public class AuthUtil { public static String getAk ( ) { return \"<STR_LIT>\" ; } public static String getSk ( ) { return \"<STR_LIT>\" ; } public static String getAppId ( ) { return \"<STR_LIT>\" ; } public static Map < String , Object > getParam ( ) { Map < String , Object > params = new LinkedHashMap < String , Object > ( ) ; params . put ( SpeechConstant . APP_ID , getAppId ( ) ) ; params . put ( SpeechConstant . APP_KEY , getAk ( ) ) ;", "output": "params . put ( SpeechConstant . SECRET , getSk ( ) ) ; return params ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . view . View ; import android . view . animation . Interpolator ; import androidx . annotation . NonNull ; import androidx . interpolator . view . animation . FastOutLinearInInterpolator ; import androidx . interpolator . view . animation . LinearOutSlowInInterpolator ; public class DefaultAnimationHelper implements FastScroller . AnimationHelper { private static final int SHOW_DURATION_MILLIS = <NUM_LIT> ; private static final int HIDE_DURATION_MILLIS = <NUM_LIT> ; private static final Interpolator SHOW_SCROLLBAR_INTERPOLATOR = new LinearOutSlowInInterpolator ( ) ; private static final Interpolator HIDE_SCROLLBAR_INTERPOLATOR = new FastOutLinearInInterpolator ( ) ; private static final int AUTO_HIDE_SCROLLBAR_DELAY_MILLIS = <NUM_LIT> ; @ NonNull private final View mView ; private boolean mScrollbarAutoHideEnabled = true ; private boolean mShowingScrollbar = true ; private boolean mShowingPopup ; public DefaultAnimationHelper ( @ NonNull View view ) { mView = view ; } @ Override public void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( mShowingScrollbar ) { return ; } mShowingScrollbar = true ; trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . setInterpolator ( SHOW_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) { if ( ! mShowingScrollbar ) { return ; } mShowingScrollbar = false ; boolean isLayoutRtl = mView . getLayoutDirection ( ) == View . LAYOUT_DIRECTION_RTL ; int width = Math . max ( trackView . getWidth ( ) , thumbView . getWidth ( ) ) ; float translationX ; if ( isLayoutRtl ) { translationX = trackView . getLeft ( ) == <NUM_LIT> ? - width : <NUM_LIT> ; } else { translationX = trackView . getRight ( ) == mView . getWidth ( ) ? width : <NUM_LIT> ; } trackView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ;", "output": "thumbView . animate ( ) . alpha ( <NUM_LIT> ) . translationX ( translationX ) . setDuration ( HIDE_DURATION_MILLIS ) . setInterpolator ( HIDE_SCROLLBAR_INTERPOLATOR ) . start ( ) ; } @ Override public boolean isScrollbarAutoHideEnabled ( ) { return mScrollbarAutoHideEnabled ; } public void setScrollbarAutoHideEnabled ( boolean enabled ) { mScrollbarAutoHideEnabled = enabled ; } @ Override public int getScrollbarAutoHideDelayMillis ( ) { return AUTO_HIDE_SCROLLBAR_DELAY_MILLIS ; } @ Override public void showPopup ( @ NonNull View popupView ) { if ( mShowingPopup ) { return ; } mShowingPopup = true ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( SHOW_DURATION_MILLIS ) . start ( ) ; } @ Override public void hidePopup ( @ NonNull View popupView ) { if ( ! mShowingPopup ) { return ; } mShowingPopup = false ; popupView . animate ( ) . alpha ( <NUM_LIT> ) . setDuration ( HIDE_DURATION_MILLIS ) . start ( ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . facemesh . FaceMeshDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class FaceMeshDetectionPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; private FaceMeshDetection implementation ; @ Override public void load ( ) { try {", "output": "implementation = new FaceMeshDetection ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer useCase = call . getInt ( \"<STR_LIT>\" , FaceMeshDetectorOptions . FACE_MESH ) ; InputImage image = implementation . createInputImageFromFilePath ( path ) ; if ( image == null ) { call . reject ( ERROR_LOAD_IMAGE_FAILED ) ; return ; } ProcessImageOptions options = new ProcessImageOptions ( image , useCase ) ; implementation . processImage ( options , new ProcessImageResultCallback ( ) { @ Override public void success ( ProcessImageResult result ) { try { call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } @ Override public void cancel ( ) { call . reject ( ERROR_PROCESS_IMAGE_CANCELED ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } }"}, {"input": "package com . appspa . update . listener . impl ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . DownloadEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . utils . ApkUtils ; import java . io . File ; import java . io . IOException ; public class DefaultInstallListener implements OnInstallListener { @ Override public boolean onInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) { if ( checkApkFile ( downloadEntity , apkFile ) ) { return installApkFile ( context , apkFile ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , \"<STR_LIT>\" ) ; return false ; } } protected boolean checkApkFile ( DownloadEntity downloadEntity , @ NonNull File apkFile ) { return downloadEntity != null && _AppSpace . isFileValid ( downloadEntity . getWholeMd5 ( ) , apkFile ) ; }", "output": "protected boolean installApkFile ( Context context , File apkFile ) { try { return ApkUtils . install ( context , apkFile ) ; } catch ( IOException e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . INSTALL_FAILED , \"<STR_LIT>\" + e . getMessage ( ) ) ; } return false ; } @ Override public void onInstallApkSuccess ( ) { } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashSet ; import java . util . Set ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class PinnedLimit extends Feature { public PinnedLimit ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void doHook ( ) throws Throwable { var pinnedLimitMethod = Unobfuscator . loadPinnedLimitMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( pinnedLimitMethod ) ) ; var pinnedSetMethod = Unobfuscator . loadPinnedHashSetMethod ( classLoader ) ; var pinnedInChatMethod = Unobfuscator . loadPinnedInChatMethod ( classLoader ) ; XposedBridge . hookMethod ( pinnedInChatMethod , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; XposedBridge . hookMethod ( pinnedSetMethod , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var pinnedset = ( Set ) param . getResult ( ) ; PinnedLinkedHashSet < Object > pinnedMod ; if ( ! ( pinnedset instanceof PinnedLinkedHashSet ) ) { pinnedMod = new PinnedLinkedHashSet < > ( ) ; pinnedMod . addAll ( pinnedset ) ; var setField = Unobfuscator . getFieldByType ( pinnedSetMethod . getDeclaringClass ( ) , Set . class ) ; XposedHelpers . setObjectField ( param . thisObject , setField . getName ( ) , pinnedMod ) ; param . setResult ( pinnedMod ) ; } else { pinnedMod = ( PinnedLinkedHashSet < Object > ) pinnedset ; } pinnedMod . setLimit ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ? <NUM_LIT> : <NUM_LIT> ) ; } } ) ; var idPin = Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; XposedBridge . hookMethod ( pinnedLimitMethod , new XC_MethodHook ( ) { private Unhook hooked ; @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( param . args . length > <NUM_LIT> && param . args [ <NUM_LIT> ] instanceof MenuItem menuItem ) { if ( menuItem . getItemId ( ) != idPin ) return ;", "output": "hooked = XposedHelpers . findAndHookMethod ( HashSet . class , \"<STR_LIT>\" , XC_MethodReplacement . returnConstant ( <NUM_LIT> ) ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( hooked != null ) hooked . unhook ( ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private static class PinnedLinkedHashSet < T > extends java . util . LinkedHashSet < T > { private int limit ; @ Override public int size ( ) { if ( super . size ( ) >= limit ) { return <NUM_LIT> ; } return <NUM_LIT> ; } public void setLimit ( int i ) { this . limit = i ; } } }"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . graphics . Canvas ; import android . graphics . Paint ; import android . os . Parcel ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import android . text . Layout ; import android . text . Spanned ; import android . text . style . BulletSpan ; public class NumberSpan extends BulletSpan { private final int mNumberGapWidth ; private final String mNumber ; public static final int STANDARD_GAP_WIDTH = <NUM_LIT> ; public NumberSpan ( int gapWidth , int number ) { super ( ) ; mNumberGapWidth = gapWidth ; mNumber = Integer . toString ( number ) . concat ( \"<STR_LIT>\" ) ; } public NumberSpan ( int number ) { this ( STANDARD_GAP_WIDTH , number ) ; } public NumberSpan ( Parcel src ) { super ( src ) ; mNumberGapWidth = src . readInt ( ) ; mNumber = src . readString ( ) ; } public void writeToParcel ( @ NonNull Parcel dest , int flags ) { super . writeToParcel ( dest , flags ) ; dest . writeInt ( mNumberGapWidth ) ; dest . writeString ( mNumber ) ; } public int getLeadingMargin ( boolean first ) { return <NUM_LIT> * STANDARD_GAP_WIDTH + mNumberGapWidth ; } @ Override public void drawLeadingMargin ( @ NonNull Canvas c , @ NonNull Paint p , int x , int dir , int top , int baseline , int bottom , @ NonNull CharSequence text , int start , int end , boolean first , @ Nullable Layout l ) { if ( ( ( Spanned ) text ) . getSpanStart ( this ) == start ) { Paint . Style style = p . getStyle ( ) ; p . setStyle ( Paint . Style . FILL ) ; if ( c . isHardwareAccelerated ( ) ) { c . save ( ) ; c . drawText ( mNumber , x + dir , baseline , p ) ;", "output": "c . restore ( ) ; } else { c . drawText ( mNumber , x + dir , ( top + bottom ) / <NUM_LIT> , p ) ; } p . setStyle ( style ) ; } } }"}, {"input": "package com . wmods . wppenhacer . utils ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static com . wmods . wppenhacer . utils . IColors . parseColor ; import static com . wmods . wppenhacer . xposed . features . customization . CustomTheme . loader1 ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . graphics . PorterDuffColorFilter ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewStub ; import android . widget . ImageView ; import android . widget . TextView ; import java . util . HashMap ; import de . robv . android . xposed . XposedHelpers ; public class ColorReplacement { public static void replaceColors ( View view , HashMap < String , String > colors ) { if ( view instanceof ImageView imageView ) { Image . replace ( imageView , colors ) ; } else if ( view instanceof TextView textView ) { Text . replace ( textView , colors ) ; } else if ( view instanceof ViewGroup viewGroup ) { Group . replace ( viewGroup , colors ) ; } else if ( view instanceof ViewStub viewStub ) { replaceColor ( viewStub . getBackground ( ) , colors ) ; } else if ( view . getClass ( ) . equals ( findClass ( \"<STR_LIT>\" , loader1 ) ) ) { CircularProgressBar . replace ( view , colors ) ; } } public static class Image {", "output": "static void replace ( ImageView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var colorFilter = view . getColorFilter ( ) ; if ( colorFilter == null ) return ; if ( colorFilter instanceof PorterDuffColorFilter filter ) { var color = ( int ) XposedHelpers . callMethod ( filter , \"<STR_LIT>\" ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setColorFilter ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( \"<STR_LIT>\" ) && ! sColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setColorFilter ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } } public static class CircularProgressBar { static void replace ( Object view , HashMap < String , String > colors ) { var progressColor = ( int ) callMethod ( view , \"<STR_LIT>\" ) ; var progressBackgroundColor = ( int ) callMethod ( view , \"<STR_LIT>\" ) ; var pcSColor = IColors . toString ( progressColor ) ; var pcbSColor = IColors . toString ( progressBackgroundColor ) ; var newPColor = colors . get ( pcSColor ) ; var newPBColor = colors . get ( pcbSColor ) ; if ( newPColor != null ) { callMethod ( view , \"<STR_LIT>\" , parseColor ( newPColor ) ) ; } if ( newPBColor != null ) { callMethod ( view , \"<STR_LIT>\" , parseColor ( newPBColor ) ) ; } } } public static class Text { static void replace ( TextView view , HashMap < String , String > colors ) { replaceColor ( view . getBackground ( ) , colors ) ; var color = view . getCurrentTextColor ( ) ; var sColor = IColors . toString ( color ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null ) { view . setTextColor ( IColors . parseColor ( newColor ) ) ; } else { if ( ! sColor . startsWith ( \"<STR_LIT>\" ) && ! sColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) view . setTextColor ( IColors . parseColor ( sColorSub + newColor ) ) ; } } } } public static class Group { static void replace ( ViewGroup view , HashMap < String , String > colors ) { var bg = view . getBackground ( ) ; var count = view . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { var child = view . getChildAt ( i ) ; replaceColors ( child , colors ) ; } replaceColor ( bg , colors ) ; } } }"}, {"input": "package de . robv . android . xposed ; import android . content . res . XResources ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_InitPackageResources . InitPackageResourcesParam ; public interface IXposedHookInitPackageResources extends IXposedMod { void handleInitPackageResources ( InitPackageResourcesParam resparam ) throws Throwable ; final class Wrapper extends XC_InitPackageResources { private final IXposedHookInitPackageResources instance ;", "output": "public Wrapper ( IXposedHookInitPackageResources instance ) { this . instance = instance ; } @ Override public void handleInitPackageResources ( InitPackageResourcesParam resparam ) throws Throwable { instance . handleInitPackageResources ( resparam ) ; } } }"}, {"input": "package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class PullToRefreshPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; }", "output": "@ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Arrays . asList ( new PullToRefreshManager ( ) , new PullToRefreshHeaderManager ( ) , new PullToRefreshFooterManager ( ) ) ; } }"}, {"input": "package com . reactnative . wheelpicker . wheel ; import java . util . TimerTask ; public final class SmoothScrollTimerTask extends TimerTask { private int realTotalOffset ; private int realOffset ; private int offset ; private final WheelView wheelView ; public SmoothScrollTimerTask ( WheelView wheelView , int offset ) { this . wheelView = wheelView ; this . offset = offset ; realTotalOffset = Integer . MAX_VALUE ; realOffset = <NUM_LIT> ; } @ Override public final void run ( ) { if ( realTotalOffset == Integer . MAX_VALUE ) { realTotalOffset = offset ; } realOffset = ( int ) ( ( float ) realTotalOffset * <NUM_LIT> ) ; if ( realOffset == <NUM_LIT> ) { if ( realTotalOffset < <NUM_LIT> ) { realOffset = - <NUM_LIT> ; } else { realOffset = <NUM_LIT> ; } } if ( Math . abs ( realTotalOffset ) <= <NUM_LIT> ) { wheelView . cancelFuture ( ) ;", "output": "wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_ITEM_SELECTED ) ; } else { wheelView . setTotalScrollY ( wheelView . getTotalScrollY ( ) + realOffset ) ; if ( ! wheelView . isLoop ( ) ) { float itemHeight = wheelView . getItemHeight ( ) ; float top = ( float ) ( - wheelView . getInitPosition ( ) ) * itemHeight ; float bottom = ( float ) ( wheelView . getItemsCount ( ) - <NUM_LIT> - wheelView . getInitPosition ( ) ) * itemHeight ; if ( wheelView . getTotalScrollY ( ) <= top || wheelView . getTotalScrollY ( ) >= bottom ) { wheelView . setTotalScrollY ( wheelView . getTotalScrollY ( ) - realOffset ) ; wheelView . cancelFuture ( ) ; wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_ITEM_SELECTED ) ; return ; } } wheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_INVALIDATE_LOOP_VIEW ) ; realTotalOffset = realTotalOffset - realOffset ; } } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; public abstract class SortedListAdapterCallback < T2 > extends SortedList . Callback < T2 > { final RecyclerView . Adapter < ? > mAdapter ; public SortedListAdapterCallback ( @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) RecyclerView . Adapter < ? > adapter ) { mAdapter = adapter ; } @ Override public void onInserted ( int position , int count ) { mAdapter . notifyItemRangeInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mAdapter . notifyItemRangeRemoved ( position , count ) ; }", "output": "@ Override public void onMoved ( int fromPosition , int toPosition ) { mAdapter . notifyItemMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mAdapter . notifyItemRangeChanged ( position , count ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { mAdapter . notifyItemRangeChanged ( position , count , payload ) ; } }"}, {"input": "package icu . freedomIntrovert . async ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; public abstract class EventHandler extends Handler { public EventHandler ( ) { super ( ) ; } public EventHandler ( @ NonNull Looper looper ) { super ( looper ) ;", "output": "} public void sendEventMessage ( EventMessage message ) { post ( ( ) -> handleEvent ( message ) ) ; } public void sendEventMessage ( int what , Object ... objects ) { post ( ( ) -> handleEvent ( new EventMessage ( what , objects ) ) ) ; } public void sendEmptyEventMessage ( int what ) { post ( ( ) -> handleEvent ( new EventMessage ( what ) ) ) ; } public void sendError ( Throwable th ) { post ( ( ) -> handleError ( th ) ) ; } protected abstract void handleEvent ( EventMessage message ) ; protected abstract void handleError ( Throwable th ) ; }"}, {"input": "package com . appspa . update . proxy ; import java . io . File ; public interface IFileEncryptor {", "output": "String encryptFile ( File file ) ; boolean isFileValid ( String encrypt , File file ) ; }"}, {"input": "package android . content . res ; import android . app . AndroidAppHelper ; import android . util . DisplayMetrics ; import java . lang . reflect . InvocationTargetException ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . IXposedHookZygoteInit ; import de . robv . android . xposed . IXposedHookZygoteInit . StartupParam ; import de . robv . android . xposed . callbacks . XC_InitPackageResources . InitPackageResourcesParam ; public class XModuleResources extends Resources { private XModuleResources ( AssetManager assets , DisplayMetrics metrics , Configuration config ) {", "output": "super ( assets , metrics , config ) ; } public static XModuleResources createInstance ( String path , XResources origRes ) { if ( path == null ) throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; AssetManager assets = new AssetManager ( ) ; try { AssetManager . class . getMethod ( \"<STR_LIT>\" , String . class ) . invoke ( assets , path ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } XModuleResources res ; if ( origRes != null ) res = new XModuleResources ( assets , origRes . getDisplayMetrics ( ) , origRes . getConfiguration ( ) ) ; else res = new XModuleResources ( assets , null , null ) ; AndroidAppHelper . addActiveResource ( path , res ) ; return res ; } public XResForwarder fwd ( int id ) { return new XResForwarder ( this , id ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import java . util . List ; class OpReorderer { final Callback mCallback ; OpReorderer ( Callback callback ) { mCallback = callback ; } void reorderOps ( List < AdapterHelper . UpdateOp > ops ) { int badMove ; while ( ( badMove = getLastMoveOutOfOrder ( ops ) ) != - <NUM_LIT> ) { swapMoveOp ( ops , badMove , badMove + <NUM_LIT> ) ; } } private void swapMoveOp ( List < AdapterHelper . UpdateOp > list , int badMove , int next ) { final AdapterHelper . UpdateOp moveOp = list . get ( badMove ) ; final AdapterHelper . UpdateOp nextOp = list . get ( next ) ; switch ( nextOp . cmd ) { case AdapterHelper . UpdateOp . REMOVE : swapMoveRemove ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . ADD : swapMoveAdd ( list , badMove , moveOp , next , nextOp ) ; break ; case AdapterHelper . UpdateOp . UPDATE : swapMoveUpdate ( list , badMove , moveOp , next , nextOp ) ; break ; } } void swapMoveRemove ( List < AdapterHelper . UpdateOp > list , int movePos , AdapterHelper . UpdateOp moveOp , int removePos , AdapterHelper . UpdateOp removeOp ) { AdapterHelper . UpdateOp extraRm = null ; boolean revertedMove = false ; final boolean moveIsBackwards ; if ( moveOp . positionStart < moveOp . itemCount ) { moveIsBackwards = false ; if ( removeOp . positionStart == moveOp . positionStart && removeOp . itemCount == moveOp . itemCount - moveOp . positionStart ) { revertedMove = true ; } } else { moveIsBackwards = true ; if ( removeOp . positionStart == moveOp . itemCount + <NUM_LIT> && removeOp . itemCount == moveOp . positionStart - moveOp . itemCount ) { revertedMove = true ; } } if ( moveOp . itemCount < removeOp . positionStart ) { removeOp . positionStart -- ; } else if ( moveOp . itemCount < removeOp . positionStart + removeOp . itemCount ) { removeOp . itemCount -- ; moveOp . cmd = AdapterHelper . UpdateOp . REMOVE ; moveOp . itemCount = <NUM_LIT> ; if ( removeOp . itemCount == <NUM_LIT> ) { list . remove ( removePos ) ; mCallback . recycleUpdateOp ( removeOp ) ; } return ; } if ( moveOp . positionStart <= removeOp . positionStart ) { removeOp . positionStart ++ ; } else if ( moveOp . positionStart < removeOp . positionStart + removeOp . itemCount ) { final int remaining = removeOp . positionStart + removeOp . itemCount - moveOp . positionStart ; extraRm = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . REMOVE , moveOp . positionStart + <NUM_LIT> , remaining , null ) ; removeOp . itemCount = moveOp . positionStart - removeOp . positionStart ; } if ( revertedMove ) { list . set ( movePos , removeOp ) ; list . remove ( removePos ) ; mCallback . recycleUpdateOp ( moveOp ) ; return ; } if ( moveIsBackwards ) { if ( extraRm != null ) { if ( moveOp . positionStart > extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount > extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart > removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount > removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } else { if ( extraRm != null ) { if ( moveOp . positionStart >= extraRm . positionStart ) { moveOp . positionStart -= extraRm . itemCount ; } if ( moveOp . itemCount >= extraRm . positionStart ) { moveOp . itemCount -= extraRm . itemCount ; } } if ( moveOp . positionStart >= removeOp . positionStart ) { moveOp . positionStart -= removeOp . itemCount ; } if ( moveOp . itemCount >= removeOp . positionStart ) { moveOp . itemCount -= removeOp . itemCount ; } } list . set ( movePos , removeOp ) ;", "output": "if ( moveOp . positionStart != moveOp . itemCount ) { list . set ( removePos , moveOp ) ; } else { list . remove ( removePos ) ; } if ( extraRm != null ) { list . add ( movePos , extraRm ) ; } } private void swapMoveAdd ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int add , AdapterHelper . UpdateOp addOp ) { int offset = <NUM_LIT> ; if ( moveOp . itemCount < addOp . positionStart ) { offset -- ; } if ( moveOp . positionStart < addOp . positionStart ) { offset ++ ; } if ( addOp . positionStart <= moveOp . positionStart ) { moveOp . positionStart += addOp . itemCount ; } if ( addOp . positionStart <= moveOp . itemCount ) { moveOp . itemCount += addOp . itemCount ; } addOp . positionStart += offset ; list . set ( move , addOp ) ; list . set ( add , moveOp ) ; } void swapMoveUpdate ( List < AdapterHelper . UpdateOp > list , int move , AdapterHelper . UpdateOp moveOp , int update , AdapterHelper . UpdateOp updateOp ) { AdapterHelper . UpdateOp extraUp1 = null ; AdapterHelper . UpdateOp extraUp2 = null ; if ( moveOp . itemCount < updateOp . positionStart ) { updateOp . positionStart -- ; } else if ( moveOp . itemCount < updateOp . positionStart + updateOp . itemCount ) { updateOp . itemCount -- ; extraUp1 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart , <NUM_LIT> , updateOp . payload ) ; } if ( moveOp . positionStart <= updateOp . positionStart ) { updateOp . positionStart ++ ; } else if ( moveOp . positionStart < updateOp . positionStart + updateOp . itemCount ) { final int remaining = updateOp . positionStart + updateOp . itemCount - moveOp . positionStart ; extraUp2 = mCallback . obtainUpdateOp ( AdapterHelper . UpdateOp . UPDATE , moveOp . positionStart + <NUM_LIT> , remaining , updateOp . payload ) ; updateOp . itemCount -= remaining ; } list . set ( update , moveOp ) ; if ( updateOp . itemCount > <NUM_LIT> ) { list . set ( move , updateOp ) ; } else { list . remove ( move ) ; mCallback . recycleUpdateOp ( updateOp ) ; } if ( extraUp1 != null ) { list . add ( move , extraUp1 ) ; } if ( extraUp2 != null ) { list . add ( move , extraUp2 ) ; } } private int getLastMoveOutOfOrder ( List < AdapterHelper . UpdateOp > list ) { boolean foundNonMove = false ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { final AdapterHelper . UpdateOp op1 = list . get ( i ) ; if ( op1 . cmd == AdapterHelper . UpdateOp . MOVE ) { if ( foundNonMove ) { return i ; } } else { foundNonMove = true ; } } return - <NUM_LIT> ; } interface Callback { AdapterHelper . UpdateOp obtainUpdateOp ( int cmd , int startPosition , int itemCount , Object payload ) ; void recycleUpdateOp ( AdapterHelper . UpdateOp op ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . media . MediaRecorder ; import android . util . Log ; import java . io . File ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; public class WhisperAsrClient extends AsrClientBase { MediaRecorder recorder = null ; File recordFile = null ; IAsrCallback callback = null ; WhisperApiClient apiClient = null ; double amplitude = <NUM_LIT> ; boolean isRecording = false ; boolean autoStop = false ; public WhisperAsrClient ( Context context , String url , String apiKey ) { recordFile = new File ( context . getFilesDir ( ) . getAbsolutePath ( ) + \"<STR_LIT>\" ) ; apiClient = new WhisperApiClient ( context , url , apiKey ) ; } public void setApiInfo ( String url , String apiKey ) { apiClient . setApiInfo ( url , apiKey ) ; } @ Override public void startRecognize ( ) { try { recorder = new MediaRecorder ( ) ; recorder . setAudioSource ( MediaRecorder . AudioSource . MIC ) ; recorder . setOutputFormat ( MediaRecorder . OutputFormat . MPEG_4 ) ; recorder . setOutputFile ( recordFile . getAbsolutePath ( ) ) ; recorder . setAudioEncoder ( MediaRecorder . AudioEncoder . AAC ) ; recorder . prepare ( ) ; recorder . start ( ) ; isRecording = true ; if ( autoStop ) { new Thread ( ( ) -> { boolean speechDetected = false ; final int SILENCE_THRESHOLD = <NUM_LIT> ; final int SILENCE_AFTER_SPEECH = <NUM_LIT> ; long lastSpeechTime = <NUM_LIT> ; while ( isRecording ) { try { if ( recorder != null ) { final double lpfRatio = <NUM_LIT> ;", "output": "double ratio = recorder . getMaxAmplitude ( ) ; if ( ratio < <NUM_LIT> ) ratio = <NUM_LIT> ; double db = <NUM_LIT> * Math . log10 ( ratio ) ; amplitude = ( <NUM_LIT> - lpfRatio ) * amplitude + lpfRatio * db ; if ( amplitude > SILENCE_THRESHOLD ) { speechDetected = true ; lastSpeechTime = System . currentTimeMillis ( ) ; } if ( speechDetected && amplitude < SILENCE_THRESHOLD && System . currentTimeMillis ( ) - lastSpeechTime > SILENCE_AFTER_SPEECH ) { speechDetected = false ; stopRecognize ( true ) ; } } Thread . sleep ( <NUM_LIT> ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } public void stopRecognize ( boolean callAutoStop ) { try { if ( recorder != null && isRecording ) { isRecording = false ; recorder . stop ( ) ; recorder . reset ( ) ; recorder . release ( ) ; new Thread ( ( ) -> { try { callback . onResult ( apiClient . getWhisperResult ( recordFile ) ) ; if ( callAutoStop ) { callback . onAutoStop ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } ) . start ( ) ; } } catch ( Exception e ) { callback . onError ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } @ Override public void stopRecognize ( ) { stopRecognize ( false ) ; } @ Override public void cancelRecognize ( ) { try { if ( recorder != null && isRecording ) { isRecording = false ; recorder . stop ( ) ; recorder . reset ( ) ; recorder . release ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { cancelRecognize ( ) ; } }"}, {"input": "package org . woheller69 . weather . activities ; import android . os . Bundle ; import android . text . method . LinkMovementMethod ; import android . widget . TextView ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class AboutActivity extends NavigationActivity { protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; ( ( TextView ) findViewById ( R . id . rainviewerURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . openmeteoURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . githubURL ) ) . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; ( ( TextView ) findViewById ( R . id . textFieldVersionName ) ) . setText ( BuildConfig . VERSION_NAME ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_about ;", "output": "} }"}, {"input": "public class MainActivity extends AppCompatActivity { private void test ( ) { getWindow ( ) . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; } private void test2 ( ) { Window window = activity . getWindow ( ) ; window . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; window . setFlags ( <NUM_LIT> , <NUM_LIT> ) ; } } public class MainActivity2 extends AppCompatActivity { private void test ( ) { } } public class MainActivity3 extends AppCompatActivity { private void test ( ) {", "output": "getWindow ( ) . addFlags ( <NUM_LIT> ) ; } }"}, {"input": "package org . woheller69 . weather . database ; public class CityToWatch { private int id ; private int cityId ; private String cityName ; private float lon ; private float lat ; private int rank ; public CityToWatch ( ) { } public CityToWatch ( int rank , int id , int cityId , float lon , float lat , String cityName ) { this . rank = rank ; this . lon = lon ; this . lat = lat ; this . id = id ; this . cityId = cityId ; this . cityName = cityName ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public int getCityId ( ) { return cityId ; } public void setCityId ( int cityId ) { this . cityId = cityId ; } public String getCityName ( ) { return cityName ; } public void setCityName ( String cityName ) { this . cityName = cityName ;", "output": "} public int getRank ( ) { return rank ; } public void setRank ( int rank ) { this . rank = rank ; } public void setLongitude ( float lon ) { this . lon = lon ; } public float getLongitude ( ) { return lon ; } public float getLatitude ( ) { return lat ; } public void setLatitude ( float lat ) { this . lat = lat ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facedetection . classes ; import android . graphics . PointF ; import android . graphics . Rect ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . google . mlkit . vision . face . Face ; import com . google . mlkit . vision . face . FaceContour ; import com . google . mlkit . vision . face . FaceLandmark ; import java . util . List ; public class ProcessImageResult { private List < Face > faces ; public ProcessImageResult ( List < Face > faces ) { this . faces = faces ; } public JSObject toJSObject ( ) { JSArray facesResult = this . createFacesResult ( ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , facesResult ) ; return result ; } private JSArray createFacesResult ( ) { JSArray result = new JSArray ( ) ; for ( Face face : faces ) { JSObject faceResult = this . createFaceResult ( face ) ; result . put ( faceResult ) ; } return result ; } private JSObject createFaceResult ( Face face ) { JSObject result = new JSObject ( ) ; Rect boundingBox = face . getBoundingBox ( ) ; JSObject boundsResult = this . createBoundsResult ( boundingBox ) ; result . put ( \"<STR_LIT>\" , boundsResult ) ; JSArray landmarksResult = new JSArray ( ) ; for ( FaceLandmark landmark : face . getAllLandmarks ( ) ) { JSObject landmarkResult = this . createLandmarkResult ( landmark ) ;", "output": "landmarksResult . put ( landmarkResult ) ; } if ( landmarksResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , landmarksResult ) ; } JSArray contoursResult = new JSArray ( ) ; for ( FaceContour contour : face . getAllContours ( ) ) { List < PointF > points = contour . getPoints ( ) ; JSArray pointsResult = new JSArray ( ) ; for ( PointF point : points ) { JSObject positionResult = this . createPositionResult ( point ) ; pointsResult . put ( positionResult ) ; } if ( pointsResult . length ( ) > <NUM_LIT> ) { JSObject contourResult = this . createContourResult ( contour , pointsResult ) ; contoursResult . put ( contourResult ) ; } } if ( contoursResult . length ( ) > <NUM_LIT> ) { result . put ( \"<STR_LIT>\" , contoursResult ) ; } Integer trackingId = face . getTrackingId ( ) ; if ( trackingId != null ) { result . put ( \"<STR_LIT>\" , trackingId ) ; } result . put ( \"<STR_LIT>\" , face . getHeadEulerAngleX ( ) ) ; result . put ( \"<STR_LIT>\" , face . getHeadEulerAngleY ( ) ) ; result . put ( \"<STR_LIT>\" , face . getHeadEulerAngleZ ( ) ) ; Float smilingProbability = face . getSmilingProbability ( ) ; if ( smilingProbability != null ) { result . put ( \"<STR_LIT>\" , smilingProbability ) ; } Float leftEyeOpenProbability = face . getLeftEyeOpenProbability ( ) ; if ( leftEyeOpenProbability != null ) { result . put ( \"<STR_LIT>\" , leftEyeOpenProbability ) ; } Float rightEyeOpenProbability = face . getRightEyeOpenProbability ( ) ; if ( rightEyeOpenProbability != null ) { result . put ( \"<STR_LIT>\" , rightEyeOpenProbability ) ; } return result ; } private JSObject createBoundsResult ( Rect boundingBox ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , boundingBox . left ) ; result . put ( \"<STR_LIT>\" , boundingBox . top ) ; result . put ( \"<STR_LIT>\" , boundingBox . right ) ; result . put ( \"<STR_LIT>\" , boundingBox . bottom ) ; return result ; } private JSObject createLandmarkResult ( FaceLandmark landmark ) { JSObject positionResult = this . createPositionResult ( landmark . getPosition ( ) ) ; JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , landmark . getLandmarkType ( ) ) ; result . put ( \"<STR_LIT>\" , positionResult ) ; return result ; } private JSObject createPositionResult ( PointF point ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , point . x ) ; result . put ( \"<STR_LIT>\" , point . y ) ; return result ; } private JSObject createContourResult ( FaceContour contour , JSArray pointsResult ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , contour . getFaceContourType ( ) ) ; result . put ( \"<STR_LIT>\" , pointsResult ) ; return result ; } }"}, {"input": "package com . getcapacitor . android ; import static org . junit . Assert . * ; import android . content . Context ; import androidx . test . ext . junit . runners . AndroidJUnit4 ; import androidx . test . platform . app . InstrumentationRegistry ; import org . junit . Test ; import org . junit . runner . RunWith ; @ RunWith ( AndroidJUnit4 . class ) public class ExampleInstrumentedTest { @ Test public void useAppContext ( ) throws Exception { Context appContext = InstrumentationRegistry . getInstrumentation ( ) . getTargetContext ( ) ;", "output": "assertEquals ( \"<STR_LIT>\" , appContext . getPackageName ( ) ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . badge ; public class BadgeConfig { private boolean persist = true ; private boolean autoClear = false ; public boolean getPersist ( ) { return persist ; }", "output": "public void setPersist ( boolean persist ) { this . persist = persist ; } public boolean getAutoClear ( ) { return autoClear ; } public void setAutoClear ( boolean autoClear ) { this . autoClear = autoClear ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . managedconfigurations ; import android . content . res . Configuration ; import com . getcapacitor . JSObject ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import org . json . JSONObject ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class ManagedConfigurationsPlugin extends Plugin { public static final String ERROR_KEY_MISSING = \"<STR_LIT>\" ; private ManagedConfigurations implementation ; @ Override public void load ( ) { implementation = new ManagedConfigurations ( getBridge ( ) ) ; } @ Override public void handleOnConfigurationChanged ( Configuration newConfig ) { super . handleOnConfigurationChanged ( newConfig ) ; implementation . refreshApplicationRestrictions ( ) ; } @ PluginMethod public void getString ( PluginCall call ) { String key = call . getString ( \"<STR_LIT>\" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } String value = implementation . getString ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , value == null ? JSONObject . NULL : value ) ; call . resolve ( ret ) ; } @ PluginMethod public void getNumber ( PluginCall call ) { String key = call . getString ( \"<STR_LIT>\" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } Integer value = implementation . getInteger ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , value == null ? JSONObject . NULL : value ) ; call . resolve ( ret ) ; } @ PluginMethod public void getBoolean ( PluginCall call ) { String key = call . getString ( \"<STR_LIT>\" ) ; if ( key == null ) { call . reject ( ERROR_KEY_MISSING ) ; return ; } Boolean value = implementation . getBoolean ( key ) ; JSObject ret = new JSObject ( ) ; ret . put ( \"<STR_LIT>\" , value == null ? JSONObject . NULL : value ) ;", "output": "call . resolve ( ret ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class SetCustomIdOptions { @ NonNull private String customId ; public SetCustomIdOptions ( @ NonNull String customId ) {", "output": "this . customId = customId ; } @ NonNull public String getCustomId ( ) { return customId ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . os . Handler ; import android . os . Looper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; public class AsyncListDiffer < T > { private final ListUpdateCallback mUpdateCallback ; @ SuppressWarnings ( \"<STR_LIT>\" ) final AsyncDifferConfig < T > mConfig ; Executor mMainThreadExecutor ; private static class MainThreadExecutor implements Executor { final Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; MainThreadExecutor ( ) { } @ Override public void execute ( @ NonNull Runnable command ) { mHandler . post ( command ) ; } } private static final Executor sMainThreadExecutor = new MainThreadExecutor ( ) ; public interface ListListener < T > { void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) ; } private final List < ListListener < T > > mListeners = new CopyOnWriteArrayList < > ( ) ; public AsyncListDiffer ( @ NonNull RecyclerView . Adapter adapter , @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { this ( new AdapterListUpdateCallback ( adapter ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public AsyncListDiffer ( @ NonNull ListUpdateCallback listUpdateCallback , @ NonNull AsyncDifferConfig < T > config ) { mUpdateCallback = listUpdateCallback ; mConfig = config ; if ( config . getMainThreadExecutor ( ) != null ) { mMainThreadExecutor = config . getMainThreadExecutor ( ) ; } else { mMainThreadExecutor = sMainThreadExecutor ; } } @ Nullable private List < T > mList ; @ NonNull private List < T > mReadOnlyList = Collections . emptyList ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) int mMaxScheduledGeneration ; @ NonNull public List < T > getCurrentList ( ) { return mReadOnlyList ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList ) { submitList ( newList , null ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void submitList ( @ Nullable final List < T > newList , @ Nullable final Runnable commitCallback ) { final int runGeneration = ++ mMaxScheduledGeneration ; if ( newList == mList ) { if ( commitCallback != null ) { commitCallback . run ( ) ; } return ; } final List < T > previousList = mReadOnlyList ; if ( newList == null ) { int countRemoved = mList . size ( ) ; mList = null ; mReadOnlyList = Collections . emptyList ( ) ; mUpdateCallback . onRemoved ( <NUM_LIT> , countRemoved ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } if ( mList == null ) { mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; mUpdateCallback . onInserted ( <NUM_LIT> , newList . size ( ) ) ; onCurrentListChanged ( previousList , commitCallback ) ; return ; } final List < T > oldList = mList ; mConfig . getBackgroundThreadExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final DiffUtil . DiffResult result = DiffUtil . calculateDiff ( new DiffUtil . Callback ( ) { @ Override public int getOldListSize ( ) { return oldList . size ( ) ; } @ Override public int getNewListSize ( ) { return newList . size ( ) ; } @ Override public boolean areItemsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areItemsTheSame ( oldItem , newItem ) ; } return oldItem == null && newItem == null ; } @ Override public boolean areContentsTheSame ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . areContentsTheSame ( oldItem , newItem ) ; } if ( oldItem == null && newItem == null ) { return true ; } throw new AssertionError ( ) ; } @ Nullable @ Override public Object getChangePayload ( int oldItemPosition , int newItemPosition ) { T oldItem = oldList . get ( oldItemPosition ) ; T newItem = newList . get ( newItemPosition ) ; if ( oldItem != null && newItem != null ) { return mConfig . getDiffCallback ( ) . getChangePayload ( oldItem , newItem ) ; } throw new AssertionError ( ) ; } } ) ; mMainThreadExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { if ( mMaxScheduledGeneration == runGeneration ) { latchList ( newList , result , commitCallback ) ; } } } ) ; } } ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void latchList ( @ NonNull List < T > newList , @ NonNull DiffUtil . DiffResult diffResult , @ Nullable Runnable commitCallback ) { final List < T > previousList = mReadOnlyList ; mList = newList ; mReadOnlyList = Collections . unmodifiableList ( newList ) ; diffResult . dispatchUpdatesTo ( mUpdateCallback ) ; onCurrentListChanged ( previousList , commitCallback ) ; } private void onCurrentListChanged ( @ NonNull List < T > previousList , @ Nullable Runnable commitCallback ) { for ( ListListener < T > listener : mListeners ) { listener . onCurrentListChanged ( previousList , mReadOnlyList ) ; } if ( commitCallback != null ) { commitCallback . run ( ) ; } } public void addListListener ( @ NonNull ListListener < T > listener ) { mListeners . add ( listener ) ; } public void removeListListener ( @ NonNull ListListener < T > listener ) {", "output": "mListeners . remove ( listener ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import static com . wmods . wppenhacer . utils . ColorReplacement . replaceColors ; import static com . wmods . wppenhacer . utils . DrawableColors . replaceColor ; import static de . robv . android . xposed . XposedHelpers . findAndHookConstructor ; import static de . robv . android . xposed . XposedHelpers . findAndHookMethod ; import android . Manifest ; import android . app . Activity ; import android . app . Notification ; import android . content . pm . PackageManager ; import android . content . res . ColorStateList ; import android . graphics . BlendMode ; import android . graphics . BlendModeColorFilter ; import android . graphics . Paint ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . ColorDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Build ; import android . os . Bundle ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import com . wmods . wppenhacer . utils . IColors ; import com . wmods . wppenhacer . views . WallpaperView ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . xmlpull . v1 . XmlPullParser ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . Properties ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CustomTheme extends Feature { public static ClassLoader loader1 ; private HashMap < String , String > wallAlpha ; private HashMap < String , String > navAlpha ; private HashMap < String , String > toolbarAlpha ; private Properties properties ; public CustomTheme ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; loader1 = loader ; } @ Override public void doHook ( ) throws Exception { properties = Utils . extractProperties ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; hookColors ( ) ; hookWallpaper ( ) ; } private void hookWallpaper ( ) throws Exception { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) && ! Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) return ; var clazz = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; XposedHelpers . findAndHookMethod ( clazz . getSuperclass ( ) , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; if ( ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_MEDIA_IMAGES ) == PackageManager . PERMISSION_GRANTED || ContextCompat . checkSelfPermission ( activity , Manifest . permission . READ_EXTERNAL_STORAGE ) == PackageManager . PERMISSION_GRANTED ) { injectWallpaper ( activity . findViewById ( android . R . id . content ) ) ; } } } ) ; var hookFragmentView = Unobfuscator . loadFragmentViewMethod ( classLoader ) ; XposedBridge . hookMethod ( hookFragmentView , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewGroup = ( ViewGroup ) param . getResult ( ) ; replaceColors ( viewGroup , wallAlpha ) ; } } ) ; var loadTabFrameClass = Unobfuscator . loadTabFrameClass ( classLoader ) ; XposedHelpers . findAndHookMethod ( FrameLayout . class , \"<STR_LIT>\" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! loadTabFrameClass . isInstance ( param . thisObject ) ) return ; var viewGroup = ( ViewGroup ) param . thisObject ; var background = viewGroup . getBackground ( ) ; try { var colorfilters = XposedHelpers . getObjectField ( background , \"<STR_LIT>\" ) ; var fields = ReflectionUtils . getFieldsByType ( colorfilters . getClass ( ) , ColorStateList . class ) ; var colorStateList = ( ColorStateList ) fields . get ( <NUM_LIT> ) . get ( colorfilters ) ; if ( colorStateList == null ) return ; var color = IColors . toString ( colorStateList . getDefaultColor ( ) ) ; var newColor = navAlpha . get ( color ) ; if ( newColor != null ) { background . setTint ( IColors . parseColor ( newColor ) ) ; } } catch ( Throwable ignored ) { } } } ) ; var customWallpaper = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( customWallpaper || properties . containsKey ( \"<STR_LIT>\" ) ) { wallAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlpha = customWallpaper ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; replaceTransparency ( wallAlpha , ( <NUM_LIT> - wallpaperAlpha ) / <NUM_LIT> ) ; navAlpha = new HashMap < > ( IColors . colors ) ; var wallpaperAlphaNav = customWallpaper ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; replaceTransparency ( navAlpha , ( <NUM_LIT> - wallpaperAlphaNav ) / <NUM_LIT> ) ; toolbarAlpha = new HashMap < > ( IColors . colors ) ; var colorOrig = \"<STR_LIT>\" ; var color = toolbarAlpha . get ( colorOrig ) ; if ( Objects . equals ( colorOrig , color ) ) toolbarAlpha . put ( colorOrig , \"<STR_LIT>\" ) ; var wallpaperToolbarAlpha = customWallpaper ? prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) : Utils . tryParseInt ( properties . getProperty ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; replaceTransparency ( toolbarAlpha , ( <NUM_LIT> - wallpaperToolbarAlpha ) / <NUM_LIT> ) ; } } private void hookColors ( ) throws Exception { var customDrawable1 = Unobfuscator . loadExpandableWidgetClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + customDrawable1 . getName ( ) ) ; var customDrawable2 = Unobfuscator . loadMaterialShapeDrawableClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + customDrawable2 . getName ( ) ) ; var customDrawable3 = Unobfuscator . loadCustomDrawableClass ( classLoader ) ; logDebug ( \"<STR_LIT>\" + customDrawable3 . getName ( ) ) ; var primaryColorInt = prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; var secondaryColorInt = prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; var backgroundColorInt = prefs . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; var primaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var secondaryColor = DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var backgroundColor = DesignUtils . checkSystemColor ( properties . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { primaryColor = primaryColorInt == <NUM_LIT> ? \"<STR_LIT>\" : IColors . toString ( primaryColorInt ) ; secondaryColor = secondaryColorInt == <NUM_LIT> ? \"<STR_LIT>\" : IColors . toString ( secondaryColorInt ) ; backgroundColor = backgroundColorInt == <NUM_LIT> ? \"<STR_LIT>\" : IColors . toString ( backgroundColorInt ) ; } if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) || Objects . equals ( properties . getProperty ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) { for ( var c : IColors . colors . keySet ( ) ) { if ( ! primaryColor . equals ( \"<STR_LIT>\" ) && DesignUtils . isValidColor ( primaryColor ) ) { primaryColor = primaryColor . length ( ) == <NUM_LIT> ? primaryColor : \"<STR_LIT>\" + primaryColor . substring ( <NUM_LIT> ) ; switch ( c ) { case \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" -> IColors . colors . put ( c , primaryColor . substring ( <NUM_LIT> ) ) ; case \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" -> IColors . colors . put ( c , primaryColor ) ; case \"<STR_LIT>\" -> IColors . colors . put ( c , \"<STR_LIT>\" + primaryColor . substring ( <NUM_LIT> ) ) ; }", "output": "} if ( ! backgroundColor . equals ( \"<STR_LIT>\" ) && DesignUtils . isValidColor ( backgroundColor ) ) { backgroundColor = backgroundColor . length ( ) == <NUM_LIT> ? backgroundColor : \"<STR_LIT>\" + backgroundColor . substring ( <NUM_LIT> ) ; switch ( c ) { case \"<STR_LIT>\" -> IColors . colors . put ( c , backgroundColor . substring ( <NUM_LIT> ) ) ; case \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" -> IColors . colors . put ( c , backgroundColor ) ; } } if ( ! secondaryColor . equals ( \"<STR_LIT>\" ) && DesignUtils . isValidColor ( secondaryColor ) ) { secondaryColor = secondaryColor . length ( ) == <NUM_LIT> ? secondaryColor : \"<STR_LIT>\" + secondaryColor . substring ( <NUM_LIT> ) ; if ( c . equals ( \"<STR_LIT>\" ) ) { IColors . colors . put ( c , secondaryColor ) ; } } } } findAndHookMethod ( Activity . class . getName ( ) , classLoader , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; var colors = IColors . colors ; var activity = ( Activity ) param . thisObject ; var view = activity . findViewById ( android . R . id . content ) . getRootView ( ) ; replaceColors ( view , colors ) ; } } ) ; var intBgHook = new IntBgColorHook ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { findAndHookConstructor ( BlendModeColorFilter . class , int . class , BlendMode . class , intBgHook ) ; } findAndHookConstructor ( PorterDuffColorFilter . class , int . class , PorterDuff . Mode . class , intBgHook ) ; findAndHookMethod ( TextView . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( Paint . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( GradientDrawable . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( ColorDrawable . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( Notification . Builder . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , int . class , intBgHook ) ; var colorStateListHook = new ColorStateListHook ( ) ; findAndHookMethod ( Drawable . class . getName ( ) , classLoader , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable1 , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; findAndHookMethod ( customDrawable2 , \"<STR_LIT>\" , int . class , intBgHook ) ; findAndHookMethod ( customDrawable3 , \"<STR_LIT>\" , ColorStateList . class , colorStateListHook ) ; var inflaterHook = ( XC_MethodHook ) new LayoutInflaterHook ( ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , \"<STR_LIT>\" , XmlPullParser . class , ViewGroup . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , \"<STR_LIT>\" , int . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( LayoutInflater . class . getName ( ) , classLoader , \"<STR_LIT>\" , XmlPullParser . class , ViewGroup . class , boolean . class , inflaterHook ) ; findAndHookMethod ( View . class . getName ( ) , classLoader , \"<STR_LIT>\" , Drawable . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var drawable = ( Drawable ) param . args [ <NUM_LIT> ] ; replaceColor ( drawable , colors ) ; } } ) ; } private void replaceTransparency ( HashMap < String , String > wallpaperColors , float mAlpha ) { var hexAlpha = Integer . toHexString ( ( int ) Math . ceil ( mAlpha * <NUM_LIT> ) ) ; hexAlpha = hexAlpha . length ( ) == <NUM_LIT> ? \"<STR_LIT>\" + hexAlpha : hexAlpha ; for ( var c : List . of ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) { var oldColor = wallpaperColors . get ( c ) ; if ( oldColor == null ) continue ; var newColor = \"<STR_LIT>\" + hexAlpha + oldColor . substring ( <NUM_LIT> ) ; wallpaperColors . put ( c , newColor ) ; wallpaperColors . put ( oldColor , newColor ) ; } } private void injectWallpaper ( View view ) { var content = ( ViewGroup ) view ; var rootView = ( ViewGroup ) content . getChildAt ( <NUM_LIT> ) ; var header = ( ViewGroup ) rootView . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; replaceColors ( header , toolbarAlpha ) ; var frameLayout = new WallpaperView ( rootView . getContext ( ) , prefs , properties ) ; rootView . addView ( frameLayout , <NUM_LIT> ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } public static class LayoutInflaterHook extends XC_MethodHook { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var view = ( View ) param . getResult ( ) ; if ( view == null ) return ; replaceColors ( view , colors ) ; } } public static class ColorStateListHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var colorStateList = param . args [ <NUM_LIT> ] ; if ( colorStateList != null ) { var mColors = ( int [ ] ) XposedHelpers . getObjectField ( colorStateList , \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < mColors . length ; i ++ ) { var sColor = IColors . toString ( mColors [ i ] ) ; var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { mColors [ i ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( \"<STR_LIT>\" ) && ! sColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { mColors [ i ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } XposedHelpers . setObjectField ( colorStateList , \"<STR_LIT>\" , mColors ) ; param . args [ <NUM_LIT> ] = colorStateList ; } } } public static class IntBgColorHook extends XC_MethodHook { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var colors = IColors . colors ; var color = ( int ) param . args [ <NUM_LIT> ] ; var sColor = IColors . toString ( color ) ; if ( param . thisObject instanceof TextView textView ) { var id = Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( textView . getId ( ) == id ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( \"<STR_LIT>\" + sColor . substring ( sColor . length ( ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) ) ; return ; } } var newColor = colors . get ( sColor ) ; if ( newColor != null && newColor . length ( ) == <NUM_LIT> ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( newColor ) ; } else { if ( ! sColor . equals ( \"<STR_LIT>\" ) && ! sColor . startsWith ( \"<STR_LIT>\" ) ) { var sColorSub = sColor . substring ( <NUM_LIT> , <NUM_LIT> ) ; newColor = colors . get ( sColor . substring ( <NUM_LIT> ) ) ; if ( newColor != null ) { param . args [ <NUM_LIT> ] = IColors . parseColor ( sColorSub + newColor ) ; } } } } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import com . google . mlkit . vision . barcode . common . Barcode ; public interface ScanResultCallback { void success ( Barcode barcode ) ; void cancel ( ) ; void error ( Exception exception ) ;", "output": "}"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . util . Log ; import android . view . View ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class DividerItemDecoration extends RecyclerView . ItemDecoration { public static final int HORIZONTAL = LinearLayout . HORIZONTAL ; public static final int VERTICAL = LinearLayout . VERTICAL ; private static final String TAG = \"<STR_LIT>\" ; private static final int [ ] ATTRS = new int [ ] { android . R . attr . listDivider } ; private Drawable mDivider ; private int mOrientation ; private final Rect mBounds = new Rect ( ) ; @ SuppressLint ( \"<STR_LIT>\" ) public DividerItemDecoration ( Context context , int orientation ) { final TypedArray a = context . obtainStyledAttributes ( ATTRS ) ; mDivider = a . getDrawable ( <NUM_LIT> ) ; if ( mDivider == null ) { Log . w ( TAG , \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } a . recycle ( ) ; setOrientation ( orientation ) ; } public void setOrientation ( int orientation ) { if ( orientation != HORIZONTAL && orientation != VERTICAL ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mOrientation = orientation ; } public void setDrawable ( @ NonNull Drawable drawable ) { if ( drawable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mDivider = drawable ; } @ Nullable public Drawable getDrawable ( ) { return mDivider ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onDraw ( Canvas c , RecyclerView parent , RecyclerView . State state ) { if ( parent . getLayoutManager ( ) == null || mDivider == null ) { return ;", "output": "} if ( mOrientation == VERTICAL ) { drawVertical ( c , parent ) ; } else { drawHorizontal ( c , parent ) ; } } private void drawVertical ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int left ; final int right ; if ( parent . getClipToPadding ( ) ) { left = parent . getPaddingLeft ( ) ; right = parent . getWidth ( ) - parent . getPaddingRight ( ) ; canvas . clipRect ( left , parent . getPaddingTop ( ) , right , parent . getHeight ( ) - parent . getPaddingBottom ( ) ) ; } else { left = <NUM_LIT> ; right = parent . getWidth ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int bottom = mBounds . bottom + Math . round ( child . getTranslationY ( ) ) ; final int top = bottom - mDivider . getIntrinsicHeight ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } private void drawHorizontal ( Canvas canvas , RecyclerView parent ) { canvas . save ( ) ; final int top ; final int bottom ; if ( parent . getClipToPadding ( ) ) { top = parent . getPaddingTop ( ) ; bottom = parent . getHeight ( ) - parent . getPaddingBottom ( ) ; canvas . clipRect ( parent . getPaddingLeft ( ) , top , parent . getWidth ( ) - parent . getPaddingRight ( ) , bottom ) ; } else { top = <NUM_LIT> ; bottom = parent . getHeight ( ) ; } final int childCount = parent . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = parent . getChildAt ( i ) ; parent . getLayoutManager ( ) . getDecoratedBoundsWithMargins ( child , mBounds ) ; final int right = mBounds . right + Math . round ( child . getTranslationX ( ) ) ; final int left = right - mDivider . getIntrinsicWidth ( ) ; mDivider . setBounds ( left , top , right , bottom ) ; mDivider . draw ( canvas ) ; } canvas . restore ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( mDivider == null ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; return ; } if ( mOrientation == VERTICAL ) { outRect . set ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicHeight ( ) ) ; } else { outRect . set ( <NUM_LIT> , <NUM_LIT> , mDivider . getIntrinsicWidth ( ) , <NUM_LIT> ) ; } } }"}, {"input": "package com . reactnative . pulltorefresh . event ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . PixelUtil ; import com . facebook . react . uimanager . events . Event ; public class OffsetChangedEvent extends Event < OffsetChangedEvent > { public static final String Name = \"<STR_LIT>\" ; public static final String JSEventName = \"<STR_LIT>\" ; private final float offset ; public OffsetChangedEvent ( int surfaceId , int viewTag , float offset ) {", "output": "super ( surfaceId , viewTag ) ; this . offset = PixelUtil . toDIPFromPixel ( offset ) ; } @ Override public String getEventName ( ) { return Name ; } @ Nullable protected WritableMap getEventData ( ) { WritableMap map = Arguments . createMap ( ) ; map . putDouble ( \"<STR_LIT>\" , offset ) ; return map ; } }"}, {"input": "package com . cgutman . adblib ; import android . hardware . usb . UsbConstants ; import android . hardware . usb . UsbDeviceConnection ; import android . hardware . usb . UsbEndpoint ; import android . hardware . usb . UsbInterface ; import android . hardware . usb . UsbRequest ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . LinkedList ; public class UsbChannel implements AdbChannel { private final UsbDeviceConnection mDeviceConnection ; private final UsbEndpoint mEndpointOut ; private final UsbEndpoint mEndpointIn ; private final UsbInterface mInterface ; private final int defaultTimeout = <NUM_LIT> ; private final LinkedList < UsbRequest > mInRequestPool = new LinkedList < UsbRequest > ( ) ; public void releaseInRequest ( UsbRequest request ) { synchronized ( mInRequestPool ) { mInRequestPool . add ( request ) ; } } public UsbRequest getInRequest ( ) { synchronized ( mInRequestPool ) { if ( mInRequestPool . isEmpty ( ) ) { UsbRequest request = new UsbRequest ( ) ; request . initialize ( mDeviceConnection , mEndpointIn ) ; return request ; } else { return mInRequestPool . removeFirst ( ) ; } } }", "output": "@ Override public void readx ( byte [ ] buffer , int length ) throws IOException { UsbRequest usbRequest = getInRequest ( ) ; ByteBuffer expected = ByteBuffer . allocate ( length ) . order ( ByteOrder . LITTLE_ENDIAN ) ; usbRequest . setClientData ( expected ) ; if ( ! usbRequest . queue ( expected , length ) ) { throw new IOException ( \"<STR_LIT>\" ) ; } while ( true ) { UsbRequest wait = mDeviceConnection . requestWait ( ) ; if ( wait == null ) { throw new IOException ( \"<STR_LIT>\" ) ; } ByteBuffer clientData = ( ByteBuffer ) wait . getClientData ( ) ; wait . setClientData ( null ) ; if ( wait . getEndpoint ( ) == mEndpointOut ) { } else if ( expected == clientData ) { releaseInRequest ( wait ) ; break ; } else { throw new IOException ( \"<STR_LIT>\" ) ; } } expected . flip ( ) ; expected . get ( buffer ) ; } private void writex ( byte [ ] buffer ) throws IOException { int offset = <NUM_LIT> ; int transferred = <NUM_LIT> ; byte [ ] tmp = new byte [ buffer . length ] ; System . arraycopy ( buffer , <NUM_LIT> , tmp , <NUM_LIT> , buffer . length ) ; while ( ( transferred = mDeviceConnection . bulkTransfer ( mEndpointOut , tmp , buffer . length - offset , defaultTimeout ) ) >= <NUM_LIT> ) { offset += transferred ; if ( offset >= buffer . length ) { break ; } else { System . arraycopy ( buffer , offset , tmp , <NUM_LIT> , buffer . length - offset ) ; } } if ( transferred < <NUM_LIT> ) { throw new IOException ( \"<STR_LIT>\" ) ; } } @ Override public void writex ( AdbMessage message ) throws IOException { writex ( message . getMessage ( ) ) ; if ( message . getPayload ( ) != null ) { writex ( message . getPayload ( ) ) ; } } @ Override public void close ( ) throws IOException { mDeviceConnection . releaseInterface ( mInterface ) ; mDeviceConnection . close ( ) ; } public UsbChannel ( UsbDeviceConnection connection , UsbInterface intf ) { mDeviceConnection = connection ; mInterface = intf ; UsbEndpoint epOut = null ; UsbEndpoint epIn = null ; for ( int i = <NUM_LIT> ; i < intf . getEndpointCount ( ) ; i ++ ) { UsbEndpoint ep = intf . getEndpoint ( i ) ; if ( ep . getType ( ) == UsbConstants . USB_ENDPOINT_XFER_BULK ) { if ( ep . getDirection ( ) == UsbConstants . USB_DIR_OUT ) { epOut = ep ; } else { epIn = ep ; } } } if ( epOut == null || epIn == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mEndpointOut = epOut ; mEndpointIn = epIn ; } }"}, {"input": "public class Test { public void test1 ( ) { Intent intent = new Intent ( applicationContext , SomeActivity . class ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( applicationContext , <NUM_LIT> , intent , <NUM_LIT> ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( applicationContext , <NUM_LIT> , intent , <NUM_LIT> ) ; Intent anotherIntent = new Intent ( ) ;", "output": "anotherIntent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; anotherIntent . putExtra ( \"<STR_LIT>\" , pendingIntent ) ; startActivity ( anotherIntent ) ; } }"}, {"input": "package de . robv . android . xposed ; import java . lang . reflect . Member ; import de . robv . android . xposed . callbacks . IXUnhook ; import de . robv . android . xposed . callbacks . XCallback ; public abstract class XC_MethodHook extends XCallback { @ SuppressWarnings ( \"<STR_LIT>\" ) public XC_MethodHook ( ) { super ( ) ; } public XC_MethodHook ( int priority ) {", "output": "super ( priority ) ; } protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { } public void callBeforeHookedMethod ( MethodHookParam param ) throws Throwable { beforeHookedMethod ( param ) ; } protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { } public void callAfterHookedMethod ( MethodHookParam param ) throws Throwable { afterHookedMethod ( param ) ; } public static final class MethodHookParam extends XCallback . Param { @ SuppressWarnings ( \"<STR_LIT>\" ) public MethodHookParam ( ) { super ( ) ; } public Member method ; public Object thisObject ; public Object [ ] args ; public Object result = null ; public Throwable throwable = null ; public boolean returnEarly = false ; public Object getResult ( ) { return result ; } public void setResult ( Object result ) { this . result = result ; this . throwable = null ; this . returnEarly = true ; } public Throwable getThrowable ( ) { return throwable ; } public boolean hasThrowable ( ) { return throwable != null ; } public void setThrowable ( Throwable throwable ) { this . throwable = throwable ; this . result = null ; this . returnEarly = true ; } public Object getResultOrThrowable ( ) throws Throwable { if ( throwable != null ) throw throwable ; return result ; } } public class Unhook implements IXUnhook < XC_MethodHook > { private final Member hookMethod ; Unhook ( Member hookMethod ) { this . hookMethod = hookMethod ; } public Member getHookedMethod ( ) { return hookMethod ; } @ Override public XC_MethodHook getCallback ( ) { return XC_MethodHook . this ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void unhook ( ) { XposedBridge . unhookMethod ( hookMethod , XC_MethodHook . this ) ; } } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . util . AttributeSet ; import android . view . View ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; public class FixItemDecorationRecyclerView extends RecyclerView { public FixItemDecorationRecyclerView ( @ NonNull Context context ) { super ( context ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; } public FixItemDecorationRecyclerView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; } @ Override protected void dispatchDraw ( @ NonNull Canvas canvas ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDraw ( canvas , this , decor . getState ( ) ) ; } super . dispatchDraw ( canvas ) ; for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration decor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; decor . getItemDecoration ( ) . onDrawOver ( canvas , this , decor . getState ( ) ) ; } } @ Override public void addItemDecoration ( @ NonNull ItemDecoration decor , int index ) { super . addItemDecoration ( new FixItemDecoration ( decor ) , index ) ; } @ NonNull @ Override public ItemDecoration getItemDecorationAt ( int index ) { return ( ( FixItemDecoration ) super . getItemDecorationAt ( index ) ) . getItemDecoration ( ) ; } @ Override public void removeItemDecoration ( @ NonNull ItemDecoration decor ) { if ( ! ( decor instanceof FixItemDecoration ) ) { for ( int i = <NUM_LIT> , count = getItemDecorationCount ( ) ; i < count ; ++ i ) { FixItemDecoration fixDecor = ( FixItemDecoration ) super . getItemDecorationAt ( i ) ; if ( fixDecor . getItemDecoration ( ) == decor ) { decor = fixDecor ; break ;", "output": "} } } super . removeItemDecoration ( decor ) ; } private static class FixItemDecoration extends ItemDecoration { @ NonNull private final ItemDecoration mItemDecoration ; private State mState ; private FixItemDecoration ( @ NonNull ItemDecoration itemDecoration ) { mItemDecoration = itemDecoration ; } @ NonNull public ItemDecoration getItemDecoration ( ) { return mItemDecoration ; } public State getState ( ) { return mState ; } @ Override public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { mState = state ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void onDraw ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent , @ NonNull State state ) { } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void onDrawOver ( @ NonNull Canvas c , @ NonNull RecyclerView parent ) { } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public void getItemOffsets ( @ NonNull Rect outRect , int itemPosition , @ NonNull RecyclerView parent ) { mItemDecoration . getItemOffsets ( outRect , itemPosition , parent ) ; } @ Override public void getItemOffsets ( @ NonNull Rect outRect , @ NonNull View view , @ NonNull RecyclerView parent , @ NonNull State state ) { mItemDecoration . getItemOffsets ( outRect , view , parent , state ) ; } } }"}, {"input": "package com . simon . harmonichackernews . network ; import com . android . volley . AuthFailureError ; import com . android . volley . Header ; import com . android . volley . Request ; import com . android . volley . toolbox . BaseHttpStack ; import com . android . volley . toolbox . HttpResponse ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import okhttp3 . Call ; import okhttp3 . Headers ; import okhttp3 . MediaType ; import okhttp3 . OkHttpClient ; import okhttp3 . RequestBody ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class VolleyOkHttp3StackInterceptors extends BaseHttpStack { private static final RequestBody EMPTY_REQUEST = RequestBody . create ( new byte [ <NUM_LIT> ] ) ; public VolleyOkHttp3StackInterceptors ( ) { } private static void setConnectionParametersForRequest ( okhttp3 . Request . Builder builder , Request < ? > request ) throws AuthFailureError { switch ( request . getMethod ( ) ) { case Request . Method . DEPRECATED_GET_OR_POST : byte [ ] postBody = request . getBody ( ) ; if ( postBody != null ) { builder . post ( RequestBody . create ( postBody , MediaType . parse ( request . getBodyContentType ( ) ) ) ) ; } break ; case Request . Method . GET : builder . get ( ) ; break ; case Request . Method . DELETE : builder . delete ( createRequestBody ( request ) ) ; break ; case Request . Method . POST : builder . post ( createRequestBody ( request ) ) ; break ; case Request . Method . PUT : builder . put ( createRequestBody ( request ) ) ; break ; case Request . Method . HEAD : builder . head ( ) ; break ; case Request . Method . OPTIONS : builder . method ( \"<STR_LIT>\" , null ) ; break ; case Request . Method . TRACE : builder . method ( \"<STR_LIT>\" , null ) ; break ; case Request . Method . PATCH : builder . patch ( createRequestBody ( request ) ) ; break ; default : throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } private static RequestBody createRequestBody ( Request < ? > r ) throws AuthFailureError { final byte [ ] body = r . getBody ( ) ; if ( body == null ) { return EMPTY_REQUEST ; } return RequestBody . create ( body , MediaType . parse ( r . getBodyContentType ( ) ) ) ; } @ Override public HttpResponse executeRequest ( Request < ? > request , Map < String , String > additionalHeaders ) throws IOException , AuthFailureError { OkHttpClient . Builder clientBuilder = NetworkComponent . getOkHttpClientInstance ( ) . newBuilder ( ) ; int timeoutMs = request . getTimeoutMs ( ) ; clientBuilder . connectTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; clientBuilder . readTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; clientBuilder . writeTimeout ( timeoutMs , TimeUnit . MILLISECONDS ) ; okhttp3 . Request . Builder okHttpRequestBuilder = new okhttp3 . Request . Builder ( ) ; okHttpRequestBuilder . url ( request . getUrl ( ) ) ; Map < String , String > headers = request . getHeaders ( ) ; for ( Map . Entry < String , String > header : headers . entrySet ( ) ) { okHttpRequestBuilder . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } for ( Map . Entry < String , String > header : additionalHeaders . entrySet ( ) ) { okHttpRequestBuilder . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } setConnectionParametersForRequest ( okHttpRequestBuilder , request ) ; OkHttpClient client = clientBuilder . build ( ) ; okhttp3 . Request okHttpRequest = okHttpRequestBuilder . build ( ) ; Call okHttpCall = client . newCall ( okHttpRequest ) ; Response okHttpResponse = okHttpCall . execute ( ) ; int code = okHttpResponse . code ( ) ; ResponseBody body = okHttpResponse . body ( ) ; InputStream content = body == null ? null : body . byteStream ( ) ; int contentLength = body == null ? <NUM_LIT> : ( int ) body . contentLength ( ) ; List < Header > responseHeaders = mapHeaders ( okHttpResponse . headers ( ) ) ; return new HttpResponse ( code , responseHeaders , contentLength , content ) ; } private List < Header > mapHeaders ( Headers responseHeaders ) { List < Header > headers = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> , len = responseHeaders . size ( ) ; i < len ;", "output": "i ++ ) { final String name = responseHeaders . name ( i ) , value = responseHeaders . value ( i ) ; headers . add ( new Header ( name , value ) ) ; } return headers ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . database . sqlite . SQLiteDatabase ; import android . text . TextUtils ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class ToastViewer extends Feature { private static final long MIN_INTERVAL = <NUM_LIT> ; private static final Map < String , Long > lastEventTimeMap = new HashMap < > ( ) ; private static final ScheduledExecutorService scheduler = Executors . newScheduledThreadPool ( <NUM_LIT> ) ; public ToastViewer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; startCleanupTask ( ) ; } @ Override public void doHook ( ) throws Throwable { var toastViewedStatus = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var toastViewedMessage = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var onInsertReceipt = Unobfuscator . loadOnInsertReceipt ( classLoader ) ; XposedBridge . hookMethod ( onInsertReceipt , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var type = ( int ) param . args [ <NUM_LIT> ] ; var id = ( long ) param . args [ <NUM_LIT> ] ; if ( type != <NUM_LIT> ) return ; var PhoneUserJid = param . args [ <NUM_LIT> ] ; CompletableFuture . runAsync ( ( ) -> { var raw = WppCore . getRawString ( PhoneUserJid ) ; var UserJid = WppCore . createUserJid ( raw ) ; var contactName = WppCore . getContactName ( UserJid ) ; if ( TextUtils . isEmpty ( contactName ) ) contactName = WppCore . stripJID ( raw ) ; var sql = MessageStore . getInstance ( ) . getDatabase ( ) ; checkDataBase ( sql , id , contactName , raw , toastViewedMessage , toastViewedStatus ) ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private synchronized void checkDataBase ( SQLiteDatabase sql , long id , String contactName , String raw , boolean toastViewedMessage , boolean toast_viewed_status ) { try ( var result2 = sql . query ( \"<STR_LIT>\" , null , \"<STR_LIT>\" , new String [ ] {", "output": "String . valueOf ( id ) } , null , null , null ) ) { if ( ! result2 . moveToNext ( ) ) return ; var participantHash = result2 . getString ( result2 . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; if ( participantHash != null ) { if ( toast_viewed_status ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_status , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , \"<STR_LIT>\" ) ; return ; } if ( Objects . equals ( WppCore . getCurrentRawJID ( ) , raw ) ) return ; var chat_id = result2 . getLong ( result2 . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; try ( var result3 = sql . query ( \"<STR_LIT>\" , null , \"<STR_LIT>\" , new String [ ] { String . valueOf ( chat_id ) } , null , null , null ) ) { if ( ! result3 . moveToNext ( ) ) return ; var key = raw + \"<STR_LIT>\" + \"<STR_LIT>\" ; long currentTime = System . currentTimeMillis ( ) ; Long lastEventTime = lastEventTimeMap . get ( key ) ; if ( lastEventTime == null || ( currentTime - lastEventTime ) >= MIN_INTERVAL ) { lastEventTimeMap . put ( key , currentTime ) ; if ( toastViewedMessage ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . viewed_your_message , contactName ) , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( contactName , WppCore . stripJID ( raw ) , \"<STR_LIT>\" ) ; } } } } private void startCleanupTask ( ) { scheduler . scheduleWithFixedDelay ( ( ) -> { long currentTime = System . currentTimeMillis ( ) ; synchronized ( lastEventTimeMap ) { lastEventTimeMap . entrySet ( ) . removeIf ( entry -> ( currentTime - entry . getValue ( ) ) >= MIN_INTERVAL ) ; } } , MIN_INTERVAL , MIN_INTERVAL , TimeUnit . MILLISECONDS ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import androidx . core . util . Pools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; final class AdapterHelper implements OpReorderer . Callback { static final int POSITION_TYPE_INVISIBLE = <NUM_LIT> ; static final int POSITION_TYPE_NEW_OR_LAID_OUT = <NUM_LIT> ; private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; private Pools . Pool < UpdateOp > mUpdateOpPool = new Pools . SimplePool < UpdateOp > ( UpdateOp . POOL_SIZE ) ; final ArrayList < UpdateOp > mPendingUpdates = new ArrayList < UpdateOp > ( ) ; final ArrayList < UpdateOp > mPostponedList = new ArrayList < UpdateOp > ( ) ; final Callback mCallback ; Runnable mOnItemProcessedCallback ; final boolean mDisableRecycler ; final OpReorderer mOpReorderer ; private int mExistingUpdateTypes = <NUM_LIT> ; AdapterHelper ( Callback callback ) { this ( callback , false ) ; } AdapterHelper ( Callback callback , boolean disableRecycler ) { mCallback = callback ; mDisableRecycler = disableRecycler ; mOpReorderer = new OpReorderer ( this ) ; } AdapterHelper addUpdateOp ( UpdateOp ... ops ) { Collections . addAll ( mPendingUpdates , ops ) ; return this ; } void reset ( ) { recycleUpdateOpsAndClearList ( mPendingUpdates ) ; recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } void preProcess ( ) { mOpReorderer . reorderOps ( mPendingUpdates ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : applyAdd ( op ) ; break ; case UpdateOp . REMOVE : applyRemove ( op ) ; break ; case UpdateOp . UPDATE : applyUpdate ( op ) ; break ; case UpdateOp . MOVE : applyMove ( op ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } mPendingUpdates . clear ( ) ; } void consumePostponedUpdates ( ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { mCallback . onDispatchSecondPass ( mPostponedList . get ( i ) ) ; } recycleUpdateOpsAndClearList ( mPostponedList ) ; mExistingUpdateTypes = <NUM_LIT> ; } private void applyMove ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void applyRemove ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { boolean typeChanged = false ; RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; dispatchAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; postponeAndUpdateViewHolders ( newOp ) ; typeChanged = true ; } type = POSITION_TYPE_INVISIBLE ; } if ( typeChanged ) { position -= tmpCount ; tmpEnd -= tmpCount ; tmpCount = <NUM_LIT> ; } else { tmpCount ++ ; } } if ( tmpCount != op . itemCount ) { recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . REMOVE , tmpStart , tmpCount , null ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void applyUpdate ( UpdateOp op ) { int tmpStart = op . positionStart ; int tmpCount = <NUM_LIT> ; int tmpEnd = op . positionStart + op . itemCount ; int type = - <NUM_LIT> ; for ( int position = op . positionStart ; position < tmpEnd ; position ++ ) { RecyclerView . ViewHolder vh = mCallback . findViewHolder ( position ) ; if ( vh != null || canFindInPreLayout ( position ) ) { if ( type == POSITION_TYPE_INVISIBLE ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; dispatchAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_NEW_OR_LAID_OUT ; } else { if ( type == POSITION_TYPE_NEW_OR_LAID_OUT ) { UpdateOp newOp = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , op . payload ) ; postponeAndUpdateViewHolders ( newOp ) ; tmpCount = <NUM_LIT> ; tmpStart = position ; } type = POSITION_TYPE_INVISIBLE ; } tmpCount ++ ; } if ( tmpCount != op . itemCount ) { Object payload = op . payload ; recycleUpdateOp ( op ) ; op = obtainUpdateOp ( UpdateOp . UPDATE , tmpStart , tmpCount , payload ) ; } if ( type == POSITION_TYPE_INVISIBLE ) { dispatchAndUpdateViewHolders ( op ) ; } else { postponeAndUpdateViewHolders ( op ) ; } } private void dispatchAndUpdateViewHolders ( UpdateOp op ) { if ( op . cmd == UpdateOp . ADD || op . cmd == UpdateOp . MOVE ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } int tmpStart = updatePositionWithPostponed ( op . positionStart , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op . positionStart + \"<STR_LIT>\" + tmpStart ) ; } int tmpCnt = <NUM_LIT> ; int offsetPositionForPartial = op . positionStart ; final int positionMultiplier ; switch ( op . cmd ) { case UpdateOp . UPDATE : positionMultiplier = <NUM_LIT> ; break ; case UpdateOp . REMOVE : positionMultiplier = <NUM_LIT> ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } for ( int p = <NUM_LIT> ; p < op . itemCount ; p ++ ) { final int pos = op . positionStart + ( positionMultiplier * p ) ; int updatedPos = updatePositionWithPostponed ( pos , op . cmd ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + pos + \"<STR_LIT>\" + updatedPos ) ; } boolean continuous = false ; switch ( op . cmd ) { case UpdateOp . UPDATE : continuous = updatedPos == tmpStart + <NUM_LIT> ; break ; case UpdateOp . REMOVE : continuous = updatedPos == tmpStart ; break ; } if ( continuous ) { tmpCnt ++ ; } else { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , op . payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; if ( op . cmd == UpdateOp . UPDATE ) { offsetPositionForPartial += tmpCnt ; } tmpStart = updatedPos ; tmpCnt = <NUM_LIT> ; } } Object payload = op . payload ; recycleUpdateOp ( op ) ; if ( tmpCnt > <NUM_LIT> ) { UpdateOp tmp = obtainUpdateOp ( op . cmd , tmpStart , tmpCnt , payload ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + tmp ) ; } dispatchFirstPassAndUpdateViewHolders ( tmp , offsetPositionForPartial ) ; recycleUpdateOp ( tmp ) ; } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } void dispatchFirstPassAndUpdateViewHolders ( UpdateOp op , int offsetStart ) { mCallback . onDispatchFirstPass ( op ) ; switch ( op . cmd ) { case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingInvisible ( offsetStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( offsetStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private int updatePositionWithPostponed ( int pos , int cmd ) { final int count = mPostponedList . size ( ) ; for ( int i = count - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp postponed = mPostponedList . get ( i ) ; if ( postponed . cmd == UpdateOp . MOVE ) { int start , end ; if ( postponed . positionStart < postponed . itemCount ) { start = postponed . positionStart ; end = postponed . itemCount ; } else { start = postponed . itemCount ; end = postponed . positionStart ; } if ( pos >= start && pos <= end ) { if ( start == postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . itemCount -- ; } pos ++ ; } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } pos -- ; } } else if ( pos < postponed . positionStart ) { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; postponed . itemCount ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; postponed . itemCount -- ; } } } else { if ( postponed . positionStart <= pos ) { if ( postponed . cmd == UpdateOp . ADD ) { pos -= postponed . itemCount ; } else if ( postponed . cmd == UpdateOp . REMOVE ) { pos += postponed . itemCount ; } } else { if ( cmd == UpdateOp . ADD ) { postponed . positionStart ++ ; } else if ( cmd == UpdateOp . REMOVE ) { postponed . positionStart -- ; } } } if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" ) ; Log . d ( TAG , \"<STR_LIT>\" + i + \"<STR_LIT>\" + pos ) ; for ( UpdateOp updateOp : mPostponedList ) { Log . d ( TAG , updateOp . toString ( ) ) ; } Log . d ( TAG , \"<STR_LIT>\" ) ; } } for ( int i = mPostponedList . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . itemCount == op . positionStart || op . itemCount < <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } else if ( op . itemCount <= <NUM_LIT> ) { mPostponedList . remove ( i ) ; recycleUpdateOp ( op ) ; } } return pos ; } private boolean canFindInPreLayout ( int position ) { final int count = mPostponedList . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( findPositionOffset ( op . itemCount , i + <NUM_LIT> ) == position ) { return true ; } } else if ( op . cmd == UpdateOp . ADD ) { final int end = op . positionStart + op . itemCount ; for ( int pos = op . positionStart ; pos < end ; pos ++ ) { if ( findPositionOffset ( pos , i + <NUM_LIT> ) == position ) { return true ; } } } } return false ; } private void applyAdd ( UpdateOp op ) { postponeAndUpdateViewHolders ( op ) ; } private void postponeAndUpdateViewHolders ( UpdateOp op ) { if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + op ) ; } mPostponedList . add ( op ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . MOVE : mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . offsetPositionsForRemovingLaidOutOrNewView ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + op ) ; } } boolean hasPendingUpdates ( ) { return mPendingUpdates . size ( ) > <NUM_LIT> ; } boolean hasAnyUpdateTypes ( int updateTypes ) { return ( mExistingUpdateTypes & updateTypes ) != <NUM_LIT> ; } int findPositionOffset ( int position ) { return findPositionOffset ( position , <NUM_LIT> ) ; } int findPositionOffset ( int position , int firstPostponedItem ) { int count = mPostponedList . size ( ) ; for ( int i = firstPostponedItem ; i < count ; ++ i ) { UpdateOp op = mPostponedList . get ( i ) ; if ( op . cmd == UpdateOp . MOVE ) { if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -- ; } if ( op . itemCount <= position ) { position ++ ; } } } else if ( op . positionStart <= position ) { if ( op . cmd == UpdateOp . REMOVE ) { if ( position < op . positionStart + op . itemCount ) { return - <NUM_LIT> ; } position -= op . itemCount ; } else if ( op . cmd == UpdateOp . ADD ) { position += op . itemCount ; } } } return position ; } boolean onItemRangeChanged ( int positionStart , int itemCount , Object payload ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . UPDATE , positionStart , itemCount , payload ) ) ; mExistingUpdateTypes |= UpdateOp . UPDATE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeInserted ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . ADD , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . ADD ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeRemoved ( int positionStart , int itemCount ) { if ( itemCount < <NUM_LIT> ) { return false ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . REMOVE , positionStart , itemCount , null ) ) ; mExistingUpdateTypes |= UpdateOp . REMOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } boolean onItemRangeMoved ( int from , int to , int itemCount ) { if ( from == to ) { return false ; } if ( itemCount != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } mPendingUpdates . add ( obtainUpdateOp ( UpdateOp . MOVE , from , to , null ) ) ; mExistingUpdateTypes |= UpdateOp . MOVE ; return mPendingUpdates . size ( ) == <NUM_LIT> ; } void consumeUpdatesInOnePass ( ) { consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ;", "output": "mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback != null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = <NUM_LIT> ; } public int applyPendingUpdatesToPosition ( int position ) { final int size = mPendingUpdates . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : if ( op . positionStart <= position ) { position += op . itemCount ; } break ; case UpdateOp . REMOVE : if ( op . positionStart <= position ) { final int end = op . positionStart + op . itemCount ; if ( end > position ) { return RecyclerView . NO_POSITION ; } position -= op . itemCount ; } break ; case UpdateOp . MOVE : if ( op . positionStart == position ) { position = op . itemCount ; } else { if ( op . positionStart < position ) { position -= <NUM_LIT> ; } if ( op . itemCount <= position ) { position += <NUM_LIT> ; } } break ; } } return position ; } boolean hasUpdates ( ) { return ! mPostponedList . isEmpty ( ) && ! mPendingUpdates . isEmpty ( ) ; } static final class UpdateOp { static final int ADD = <NUM_LIT> ; static final int REMOVE = <NUM_LIT> << <NUM_LIT> ; static final int UPDATE = <NUM_LIT> << <NUM_LIT> ; static final int MOVE = <NUM_LIT> << <NUM_LIT> ; static final int POOL_SIZE = <NUM_LIT> ; int cmd ; int positionStart ; Object payload ; int itemCount ; UpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { this . cmd = cmd ; this . positionStart = positionStart ; this . itemCount = itemCount ; this . payload = payload ; } String cmdToString ( ) { switch ( cmd ) { case ADD : return \"<STR_LIT>\" ; case REMOVE : return \"<STR_LIT>\" ; case UPDATE : return \"<STR_LIT>\" ; case MOVE : return \"<STR_LIT>\" ; } return \"<STR_LIT>\" ; } @ Override public String toString ( ) { return Integer . toHexString ( System . identityHashCode ( this ) ) + \"<STR_LIT>\" + cmdToString ( ) + \"<STR_LIT>\" + positionStart + \"<STR_LIT>\" + itemCount + \"<STR_LIT>\" + payload + \"<STR_LIT>\" ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof UpdateOp ) ) { return false ; } UpdateOp op = ( UpdateOp ) o ; if ( cmd != op . cmd ) { return false ; } if ( cmd == MOVE && Math . abs ( itemCount - positionStart ) == <NUM_LIT> ) { if ( itemCount == op . positionStart && positionStart == op . itemCount ) { return true ; } } if ( itemCount != op . itemCount ) { return false ; } if ( positionStart != op . positionStart ) { return false ; } if ( payload != null ) { if ( ! payload . equals ( op . payload ) ) { return false ; } } else if ( op . payload != null ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = cmd ; result = <NUM_LIT> * result + positionStart ; result = <NUM_LIT> * result + itemCount ; return result ; } } @ Override public UpdateOp obtainUpdateOp ( int cmd , int positionStart , int itemCount , Object payload ) { UpdateOp op = mUpdateOpPool . acquire ( ) ; if ( op == null ) { op = new UpdateOp ( cmd , positionStart , itemCount , payload ) ; } else { op . cmd = cmd ; op . positionStart = positionStart ; op . itemCount = itemCount ; op . payload = payload ; } return op ; } @ Override public void recycleUpdateOp ( UpdateOp op ) { if ( ! mDisableRecycler ) { op . payload = null ; mUpdateOpPool . release ( op ) ; } } void recycleUpdateOpsAndClearList ( List < UpdateOp > ops ) { final int count = ops . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { recycleUpdateOp ( ops . get ( i ) ) ; } ops . clear ( ) ; } interface Callback { RecyclerView . ViewHolder findViewHolder ( int position ) ; void offsetPositionsForRemovingInvisible ( int positionStart , int itemCount ) ; void offsetPositionsForRemovingLaidOutOrNewView ( int positionStart , int itemCount ) ; void markViewHoldersUpdated ( int positionStart , int itemCount , Object payloads ) ; void onDispatchFirstPass ( UpdateOp updateOp ) ; void onDispatchSecondPass ( UpdateOp updateOp ) ; void offsetPositionsForAdd ( int positionStart , int itemCount ) ; void offsetPositionsForMove ( int from , int to ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . app . Activity ; import android . widget . EditText ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . views . dialog . SimpleColorPickerDialog ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . util . concurrent . atomic . AtomicReference ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class TextStatusComposer extends Feature { private static final AtomicReference < ColorData > colorData = new AtomicReference < > ( ) ; public TextStatusComposer ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var setColorTextComposer = Unobfuscator . loadTextStatusComposer ( classLoader ) ; log ( \"<STR_LIT>\" + Unobfuscator . getMethodDescriptor ( setColorTextComposer ) ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , classLoader . loadClass ( \"<STR_LIT>\" ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var viewRoot = activity . getWindow ( ) . getDecorView ( ) ; var pickerColor = viewRoot . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var entry = ( EditText ) viewRoot . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; pickerColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { try { Field fieldInt = ReflectionUtils . findFieldUsingFilter ( param . thisObject . getClass ( ) , field -> field . getType ( ) == int . class ) ; fieldInt . setInt ( param . thisObject , color ) ; ReflectionUtils . callMethod ( setColorTextComposer , null , param . thisObject ) ; } catch ( Exception e ) { log ( e ) ; } } ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; var textColor = viewRoot . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; textColor . setOnLongClickListener ( v -> { var dialog = new SimpleColorPickerDialog ( activity , color -> { var colorData = new ColorData ( ) ; colorData . instance = param . thisObject ; colorData . color = color ; TextStatusComposer . colorData . set ( colorData ) ; entry . setTextColor ( color ) ;", "output": "} ) ; dialog . create ( ) . setCanceledOnTouchOutside ( false ) ; dialog . show ( ) ; return true ; } ) ; } } ) ; var setColorTextComposer2 = Unobfuscator . loadTextStatusComposer2 ( classLoader ) ; log ( \"<STR_LIT>\" + Unobfuscator . getMethodDescriptor ( setColorTextComposer2 ) ) ; XposedBridge . hookMethod ( setColorTextComposer2 , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( colorData . get ( ) != null ) { var message = param . getResult ( ) ; var textData = XposedHelpers . getObjectField ( message , \"<STR_LIT>\" ) ; XposedHelpers . setObjectField ( textData , \"<STR_LIT>\" , colorData . get ( ) . color ) ; colorData . set ( null ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } public static class ColorData { public Object instance ; public int color ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; interface ThreadUtil < T > { interface MainThreadCallback < T > { void updateItemCount ( int generation , int itemCount ) ; @ SuppressLint ( \"<STR_LIT>\" ) void addTile ( int generation , TileList . Tile < T > tile ) ;", "output": "void removeTile ( int generation , int position ) ; } interface BackgroundCallback < T > { void refresh ( int generation ) ; void updateRange ( int rangeStart , int rangeEnd , int extRangeStart , int extRangeEnd , int scrollHint ) ; void loadTile ( int position , int scrollHint ) ; @ SuppressLint ( \"<STR_LIT>\" ) void recycleTile ( TileList . Tile < T > tile ) ; } MainThreadCallback < T > getMainThreadProxy ( MainThreadCallback < T > callback ) ; BackgroundCallback < T > getBackgroundProxy ( BackgroundCallback < T > callback ) ; }"}, {"input": "package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import java . io . File ; import java . util . Map ; public interface IUpdateHttpService { void asyncGet ( @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull Callback callBack ) ; void asyncPost ( @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull Callback callBack ) ; void download ( @ NonNull String url , @ NonNull String path , @ NonNull String fileName , @ NonNull DownloadCallback callback ) ; void cancelDownload ( @ NonNull String url ) ; interface Callback { void onSuccess ( String result ) ; void onError ( Throwable throwable ) ; } interface DownloadCallback { void onStart ( ) ; void onProgress ( float progress , long total ) ; void onSuccess ( File file ) ; void onError ( Throwable throwable ) ;", "output": "} }"}, {"input": "package in . hridayan . ashell . utils ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . List ; import rikka . shizuku . Shizuku ; import rikka . shizuku . ShizukuRemoteProcess ; public class ShizukuShell { private static List < String > mOutput ; private static ShizukuRemoteProcess mProcess = null ; private static String mCommand ; private static String mDir = \"<STR_LIT>\" ; public ShizukuShell ( List < String > output , String command ) { mOutput = output ; mCommand = command ; } public boolean isBusy ( ) { return mOutput != null && mOutput . size ( ) > <NUM_LIT> && ! mOutput . get ( mOutput . size ( ) - <NUM_LIT> ) . equals ( \"<STR_LIT>\" ) ; } public void exec ( ) { try { mProcess = Shizuku . newProcess ( new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , mCommand } , null , mDir ) ; BufferedReader mInput = new BufferedReader ( new InputStreamReader ( mProcess . getInputStream ( ) ) ) ; BufferedReader mError = new BufferedReader ( new InputStreamReader ( mProcess . getErrorStream ( ) ) ) ;", "output": "String line ; while ( ( line = mInput . readLine ( ) ) != null ) { mOutput . add ( line ) ; } while ( ( line = mError . readLine ( ) ) != null ) { mOutput . add ( \"<STR_LIT>\" + line + \"<STR_LIT>\" ) ; } if ( mCommand . startsWith ( \"<STR_LIT>\" ) && ! mOutput . get ( mOutput . size ( ) - <NUM_LIT> ) . endsWith ( \"<STR_LIT>\" ) ) { String [ ] array = mCommand . split ( \"<STR_LIT>\" ) ; String dir ; if ( array [ array . length - <NUM_LIT> ] . equals ( \"<STR_LIT>\" ) ) { dir = \"<STR_LIT>\" ; } else if ( array [ array . length - <NUM_LIT> ] . startsWith ( \"<STR_LIT>\" ) ) { dir = array [ array . length - <NUM_LIT> ] ; } else { dir = mDir + array [ array . length - <NUM_LIT> ] ; } if ( ! dir . endsWith ( \"<STR_LIT>\" ) ) { dir = dir + \"<STR_LIT>\" ; } mDir = dir ; } mProcess . waitFor ( ) ; } catch ( Exception ignored ) { } } public void destroy ( ) { if ( mProcess != null ) mProcess . destroy ( ) ; } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import java . util . Locale ; final class PageTransformerAdapter extends ViewPager2 . OnPageChangeCallback { private final LinearLayoutManager mLayoutManager ; private ViewPager2 . PageTransformer mPageTransformer ; PageTransformerAdapter ( LinearLayoutManager layoutManager ) { mLayoutManager = layoutManager ; } ViewPager2 . PageTransformer getPageTransformer ( ) { return mPageTransformer ; } void setPageTransformer ( @ Nullable ViewPager2 . PageTransformer transformer ) { mPageTransformer = transformer ; } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { if ( mPageTransformer == null ) { return ; } float transformOffset = - positionOffset ; for ( int i = <NUM_LIT> ; i < mLayoutManager . getChildCount ( ) ; i ++ ) {", "output": "View view = mLayoutManager . getChildAt ( i ) ; if ( view == null ) { throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" , i , mLayoutManager . getChildCount ( ) ) ) ; } int currPos = mLayoutManager . getPosition ( view ) ; float viewOffset = transformOffset + ( currPos - position ) ; mPageTransformer . transformPage ( view , viewOffset ) ; } } @ Override public void onPageSelected ( int position ) { } @ Override public void onPageScrollStateChanged ( int state ) { } }"}, {"input": "package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; public interface IPrompterProxy { String getUrl ( ) ; void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) ; void backgroundDownload ( ) ; void cancelDownload ( ) ;", "output": "void recycle ( ) ; }"}, {"input": "package androidx . fluidviewpager2 . widget ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . core . util . Preconditions ; import androidx . fluidrecyclerview . widget . RecyclerView ; public final class MarginPageTransformer implements ViewPager2 . PageTransformer { private final int mMarginPx ; public MarginPageTransformer ( @ Px int marginPx ) { Preconditions . checkArgumentNonnegative ( marginPx , \"<STR_LIT>\" ) ; mMarginPx = marginPx ; } @ Override public void transformPage ( @ NonNull View page , float position ) { ViewPager2 viewPager = requireViewPager ( page ) ; float offset = mMarginPx * position ; if ( viewPager . getOrientation ( ) == ViewPager2 . ORIENTATION_HORIZONTAL ) { page . setTranslationX ( viewPager . isRtl ( ) ? - offset : offset ) ;", "output": "} else { page . setTranslationY ( offset ) ; } } private ViewPager2 requireViewPager ( @ NonNull View page ) { ViewParent parent = page . getParent ( ) ; ViewParent parentParent = parent . getParent ( ) ; if ( parent instanceof RecyclerView && parentParent instanceof ViewPager2 ) { return ( ViewPager2 ) parentParent ; } throw new IllegalStateException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; import com . alibaba . fastjson . JSON ; public class SensitiveScanResult { public SensitiveScanResult ( int normalPosition , int unusualPosition ) { this . normalPosition = normalPosition ;", "output": "this . unusualPosition = unusualPosition ; } public SensitiveScanResult ( ) { } public int normalPosition ; public int unusualPosition ; @ NonNull @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . view . View ; class ScrollbarHelper { static int computeScrollOffset ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled , boolean reverseLayout ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) {", "output": "return <NUM_LIT> ; } final int minPosition = Math . min ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int maxPosition = Math . max ( lm . getPosition ( startChild ) , lm . getPosition ( endChild ) ) ; final int itemsBefore = reverseLayout ? Math . max ( <NUM_LIT> , state . getItemCount ( ) - maxPosition - <NUM_LIT> ) : Math . max ( <NUM_LIT> , minPosition ) ; if ( ! smoothScrollbarEnabled ) { return itemsBefore ; } final int laidOutArea = Math . abs ( orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ) ; final int itemRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; final float avgSizePerRow = ( float ) laidOutArea / itemRange ; return Math . round ( itemsBefore * avgSizePerRow + ( orientation . getStartAfterPadding ( ) - orientation . getDecoratedStart ( startChild ) ) ) ; } static int computeScrollExtent ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; } final int extend = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; return Math . min ( orientation . getTotalSpace ( ) , extend ) ; } static int computeScrollRange ( RecyclerView . State state , OrientationHelper orientation , View startChild , View endChild , RecyclerView . LayoutManager lm , boolean smoothScrollbarEnabled ) { if ( lm . getChildCount ( ) == <NUM_LIT> || state . getItemCount ( ) == <NUM_LIT> || startChild == null || endChild == null ) { return <NUM_LIT> ; } if ( ! smoothScrollbarEnabled ) { return state . getItemCount ( ) ; } final int laidOutArea = orientation . getDecoratedEnd ( endChild ) - orientation . getDecoratedStart ( startChild ) ; final int laidOutRange = Math . abs ( lm . getPosition ( startChild ) - lm . getPosition ( endChild ) ) + <NUM_LIT> ; return ( int ) ( ( float ) laidOutArea / laidOutRange * state . getItemCount ( ) ) ; } private ScrollbarHelper ( ) { } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class DndMode extends Feature { public DndMode ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception {", "output": "if ( ! WppCore . getPrivBoolean ( \"<STR_LIT>\" , false ) ) return ; var dndMethod = Unobfuscator . loadDndModeMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( dndMethod ) ) ; XposedBridge . hookMethod ( dndMethod , XC_MethodReplacement . DO_NOTHING ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . appspa . demo . entity ; import java . io . Serializable ; public class CustomResult implements Serializable { public boolean success ; public VersionInfo data ; public static class VersionInfo implements Serializable { public boolean hasUpdate ; public boolean isForce ; public boolean isIgnorable ; public boolean isSilent ; public String md5 ; public int versionCode ; public String versionName ; public String changeLog ; public String downloadUrl ; public long size ; public PatchInfo patchInfo ; } public static class PatchInfo implements Serializable { public String md5 ; public String sMd5 ; public String tMd5 ; public String tip ; public String downloadUrl ;", "output": "public long size ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import okhttp3 . OkHttpClient ; import okhttp3 . Request ; import okhttp3 . Response ; import okhttp3 . ResponseBody ; public class PictureStorage { private static final Map < String , Bitmap > bitmapMap = new HashMap < > ( ) ; private static final LinkedList < String > bitmapLink = new LinkedList < > ( ) ; public synchronized static boolean save ( Context context , String url ) throws IOException { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( ! pictureFile . exists ( ) ) { OkHttpClient httpClient = OkHttpUtil . getHttpClient ( ) ; Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; Response response = httpClient . newCall ( request ) . execute ( ) ; if ( ! response . isSuccessful ( ) ) { return false ; } ResponseBody body = response . body ( ) ; OkHttpUtil . respNotNull ( body ) ; InputStream inputStream = body . byteStream ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( pictureFile ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) != - <NUM_LIT> ) { fileOutputStream . write ( buffer , <NUM_LIT> , read ) ; } fileOutputStream . close ( ) ; } return true ; } public synchronized static void save ( Context context , InputStream inputStream , String name ) throws IOException { byte [ ] buffer = new byte [ <NUM_LIT> ] ; FileOutputStream fos = new FileOutputStream ( new File ( getPicturesDir ( context ) , name ) ) ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } fos . close ( ) ; } public synchronized static Bitmap getBitMap ( String url ) { Bitmap bitmap = bitmapMap . get ( url ) ; if ( bitmap != null ) { bitmapLink . remove ( url ) ; bitmapLink . addFirst ( url ) ; } return bitmap ; } public synchronized static boolean loadImage ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { FileInputStream fileInputStream = null ; try { fileInputStream = new FileInputStream ( pictureFile ) ; } catch ( FileNotFoundException e ) { return false ;", "output": "} bitmapMap . put ( url , BitmapFactory . decodeStream ( fileInputStream ) ) ; bitmapLink . addFirst ( url ) ; if ( bitmapLink . size ( ) > <NUM_LIT> ) { bitmapMap . remove ( bitmapLink . getLast ( ) ) ; bitmapLink . removeLast ( ) ; } return true ; } else { return false ; } } public synchronized static void delete ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { pictureFile . delete ( ) ; } } public static File getPictureFile ( Context context , String url ) { File pictureFile = new File ( getPicturesDir ( context ) , getPicFileNameFromUrl ( url ) ) ; if ( pictureFile . exists ( ) ) { return pictureFile ; } return null ; } public static File getPicturesDir ( Context context ) { return context . getExternalFilesDir ( \"<STR_LIT>\" ) ; } private static String getPicFileNameFromUrl ( String url ) { String [ ] split = url . split ( \"<STR_LIT>\" ) ; return split [ split . length - <NUM_LIT> ] ; } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ScrollState ; import static java . lang . annotation . RetentionPolicy . SOURCE ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . view . ViewGroup . MarginLayoutParams ; import androidx . annotation . IntDef ; import androidx . annotation . NonNull ; import androidx . fluidrecyclerview . widget . LinearLayoutManager ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . lang . annotation . Retention ; import java . util . Locale ; final class ScrollEventAdapter extends RecyclerView . OnScrollListener { private static final int STATE_IDLE = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_MANUAL_DRAG = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_SMOOTH_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_IMMEDIATE_SCROLL = <NUM_LIT> ; private static final int STATE_IN_PROGRESS_FAKE_DRAG = <NUM_LIT> ; private static final int NO_POSITION = - <NUM_LIT> ; private final @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final @ NonNull RecyclerView mRecyclerView ; private final @ NonNull LinearLayoutManager mLayoutManager ; private OnPageChangeCallback mCallback ; private @ AdapterState int mAdapterState ; private @ ScrollState int mScrollState ; private ScrollEventValues mScrollValues ; private int mDragStartPosition ; private int mTarget ; private boolean mDispatchSelected ; private boolean mScrollHappened ; private boolean mDataSetChangeHappened ; private boolean mFakeDragging ; ScrollEventAdapter ( @ NonNull androidx . fluidviewpager2 . widget . ViewPager2 viewPager ) { mViewPager = viewPager ; mRecyclerView = mViewPager . mRecyclerView ; mLayoutManager = ( LinearLayoutManager ) mRecyclerView . getLayoutManager ( ) ; mScrollValues = new ScrollEventValues ( ) ; resetState ( ) ; } private void resetState ( ) { mAdapterState = STATE_IDLE ; mScrollState = SCROLL_STATE_IDLE ; mScrollValues . reset ( ) ; mDragStartPosition = NO_POSITION ; mTarget = NO_POSITION ; mDispatchSelected = false ; mScrollHappened = false ; mFakeDragging = false ; mDataSetChangeHappened = false ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { if ( ( mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG || mScrollState != SCROLL_STATE_DRAGGING ) && newState == RecyclerView . SCROLL_STATE_DRAGGING ) { startDrag ( false ) ; return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_SETTLING ) { if ( mScrollHappened ) { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; mDispatchSelected = true ; } return ; } if ( isInAnyDraggingState ( ) && newState == RecyclerView . SCROLL_STATE_IDLE ) { boolean dispatchIdle = false ; updateScrollEventValues ( ) ; if ( ! mScrollHappened ) { if ( mScrollValues . mPosition != RecyclerView . NO_POSITION ) { dispatchScrolled ( mScrollValues . mPosition , <NUM_LIT> , <NUM_LIT> ) ; } dispatchIdle = true ; } else if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { dispatchIdle = true ; if ( mDragStartPosition != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } } if ( dispatchIdle ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } if ( mAdapterState == STATE_IN_PROGRESS_SMOOTH_SCROLL && newState == RecyclerView . SCROLL_STATE_IDLE && mDataSetChangeHappened ) { updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mTarget != mScrollValues . mPosition ) { dispatchSelected ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { mScrollHappened = true ; updateScrollEventValues ( ) ; if ( mDispatchSelected ) { mDispatchSelected = false ; boolean scrollingForward = dy > <NUM_LIT> || ( dy == <NUM_LIT> && dx < <NUM_LIT> == mViewPager . isRtl ( ) ) ; mTarget = scrollingForward && mScrollValues . mOffsetPx != <NUM_LIT> ? mScrollValues . mPosition + <NUM_LIT> : mScrollValues . mPosition ; if ( mDragStartPosition != mTarget ) { dispatchSelected ( mTarget ) ; } } else if ( mAdapterState == STATE_IDLE ) { int position = mScrollValues . mPosition ; dispatchSelected ( position == NO_POSITION ? <NUM_LIT> : position ) ; } dispatchScrolled ( mScrollValues . mPosition == NO_POSITION ? <NUM_LIT> : mScrollValues . mPosition , mScrollValues . mOffset , mScrollValues . mOffsetPx ) ; if ( ( mScrollValues . mPosition == mTarget || mTarget == NO_POSITION ) && mScrollValues . mOffsetPx == <NUM_LIT> && ! ( mScrollState == SCROLL_STATE_DRAGGING ) ) { dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } } private void updateScrollEventValues ( ) { ScrollEventValues values = mScrollValues ; values . mPosition = mLayoutManager . findFirstVisibleItemPosition ( ) ; if ( values . mPosition == RecyclerView . NO_POSITION ) { values . reset ( ) ; return ; } View firstVisibleView = mLayoutManager . findViewByPosition ( values . mPosition ) ; if ( firstVisibleView == null ) { values . reset ( ) ; return ; } int leftDecorations = mLayoutManager . getLeftDecorationWidth ( firstVisibleView ) ; int rightDecorations = mLayoutManager . getRightDecorationWidth ( firstVisibleView ) ; int topDecorations = mLayoutManager . getTopDecorationHeight ( firstVisibleView ) ; int bottomDecorations = mLayoutManager . getBottomDecorationHeight ( firstVisibleView ) ; LayoutParams params = firstVisibleView . getLayoutParams ( ) ; if ( params instanceof MarginLayoutParams ) { MarginLayoutParams margin = ( MarginLayoutParams ) params ; leftDecorations += margin . leftMargin ; rightDecorations += margin . rightMargin ; topDecorations += margin . topMargin ; bottomDecorations += margin . bottomMargin ; } int decoratedHeight = firstVisibleView . getHeight ( ) + topDecorations + bottomDecorations ; int decoratedWidth = firstVisibleView . getWidth ( ) + leftDecorations + rightDecorations ; boolean isHorizontal = mLayoutManager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; int start , sizePx ; if ( isHorizontal ) { sizePx = decoratedWidth ; start = firstVisibleView . getLeft ( ) - leftDecorations - mRecyclerView . getPaddingLeft ( ) ; if ( mViewPager . isRtl ( ) ) { start = - start ; } } else { sizePx = decoratedHeight ; start = firstVisibleView . getTop ( ) - topDecorations - mRecyclerView . getPaddingTop ( ) ; }", "output": "values . mOffsetPx = - start ; if ( values . mOffsetPx < <NUM_LIT> ) { if ( new AnimateLayoutChangeDetector ( mLayoutManager ) . mayHaveInterferingAnimations ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } throw new IllegalStateException ( String . format ( Locale . US , \"<STR_LIT>\" + \"<STR_LIT>\" , values . mOffsetPx ) ) ; } values . mOffset = sizePx == <NUM_LIT> ? <NUM_LIT> : ( float ) values . mOffsetPx / sizePx ; } private void startDrag ( boolean isFakeDrag ) { mFakeDragging = isFakeDrag ; mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG ; if ( mTarget != NO_POSITION ) { mDragStartPosition = mTarget ; mTarget = NO_POSITION ; } else if ( mDragStartPosition == NO_POSITION ) { mDragStartPosition = getPosition ( ) ; } dispatchStateChanged ( SCROLL_STATE_DRAGGING ) ; } void notifyDataSetChangeHappened ( ) { mDataSetChangeHappened = true ; } void notifyProgrammaticScroll ( int target , boolean smooth ) { mAdapterState = smooth ? STATE_IN_PROGRESS_SMOOTH_SCROLL : STATE_IN_PROGRESS_IMMEDIATE_SCROLL ; mFakeDragging = false ; boolean hasNewTarget = mTarget != target ; mTarget = target ; dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; if ( hasNewTarget ) { dispatchSelected ( target ) ; } } void notifyBeginFakeDrag ( ) { mAdapterState = STATE_IN_PROGRESS_FAKE_DRAG ; startDrag ( true ) ; } void notifyEndFakeDrag ( ) { if ( isDragging ( ) && ! mFakeDragging ) { return ; } mFakeDragging = false ; updateScrollEventValues ( ) ; if ( mScrollValues . mOffsetPx == <NUM_LIT> ) { if ( mScrollValues . mPosition != mDragStartPosition ) { dispatchSelected ( mScrollValues . mPosition ) ; } dispatchStateChanged ( SCROLL_STATE_IDLE ) ; resetState ( ) ; } else { dispatchStateChanged ( SCROLL_STATE_SETTLING ) ; } } void setOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallback = callback ; } int getScrollState ( ) { return mScrollState ; } boolean isIdle ( ) { return mScrollState == SCROLL_STATE_IDLE ; } boolean isDragging ( ) { return mScrollState == SCROLL_STATE_DRAGGING ; } boolean isFakeDragging ( ) { return mFakeDragging ; } private boolean isInAnyDraggingState ( ) { return mAdapterState == STATE_IN_PROGRESS_MANUAL_DRAG || mAdapterState == STATE_IN_PROGRESS_FAKE_DRAG ; } double getRelativeScrollPosition ( ) { updateScrollEventValues ( ) ; return mScrollValues . mPosition + ( double ) mScrollValues . mOffset ; } private void dispatchStateChanged ( @ ScrollState int state ) { if ( mAdapterState == STATE_IN_PROGRESS_IMMEDIATE_SCROLL && mScrollState == SCROLL_STATE_IDLE ) { return ; } if ( mScrollState == state ) { return ; } mScrollState = state ; if ( mCallback != null ) { mCallback . onPageScrollStateChanged ( state ) ; } } private void dispatchSelected ( int target ) { if ( mCallback != null ) { mCallback . onPageSelected ( target ) ; } } private void dispatchScrolled ( int position , float offset , int offsetPx ) { if ( mCallback != null ) { mCallback . onPageScrolled ( position , offset , offsetPx ) ; } } private int getPosition ( ) { return mLayoutManager . findFirstVisibleItemPosition ( ) ; } @ Retention ( SOURCE ) @ IntDef ( { STATE_IDLE , STATE_IN_PROGRESS_MANUAL_DRAG , STATE_IN_PROGRESS_SMOOTH_SCROLL , STATE_IN_PROGRESS_IMMEDIATE_SCROLL , STATE_IN_PROGRESS_FAKE_DRAG } ) private @ interface AdapterState { } private static final class ScrollEventValues { int mPosition ; float mOffset ; int mOffsetPx ; ScrollEventValues ( ) { } void reset ( ) { mPosition = RecyclerView . NO_POSITION ; mOffset = <NUM_LIT> ; mOffsetPx = <NUM_LIT> ; } } }"}, {"input": "package com . norman . webviewup . demo ; import android . app . Activity ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . text . TextUtils ; import android . util . Log ; import android . view . View ; import android . webkit . WebView ; import android . widget . ProgressBar ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import com . norman . webviewup . lib . UpgradeCallback ; import com . norman . webviewup . lib . WebViewUpgrade ; import com . norman . webviewup . lib . source . UpgradeAssetSource ; import com . norman . webviewup . lib . source . UpgradePackageSource ; import com . norman . webviewup . lib . source . UpgradeSource ; import com . norman . webviewup . lib . source . download . UpgradeDownloadSource ; import com . norman . webviewup . lib . util . ProcessUtils ; import com . norman . webviewup . lib . util . VersionUtils ; import java . io . File ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class MainActivity extends Activity implements UpgradeCallback { private static final Map < String , List < UpgradeInfo > > UPGRADE_PACKAGE_MAP = new HashMap < > ( ) ; static { UPGRADE_PACKAGE_MAP . put ( \"<STR_LIT>\" , Arrays . asList ( new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; UPGRADE_PACKAGE_MAP . put ( \"<STR_LIT>\" , Arrays . asList ( new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; UPGRADE_PACKAGE_MAP . put ( \"<STR_LIT>\" , Arrays . asList ( new UpgradeInfo ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; } ProgressBar progressBar ; TextView systemWebViewPackageTextView ; TextView upgradeWebViewPackageTextView ; TextView upgradeStatusTextView ; TextView upgradeErrorTextView ; TextView upgradeProgressTextView ; UpgradeInfo selectUpgradeInfo ; protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; WebViewUpgrade . addUpgradeCallback ( this ) ; progressBar = findViewById ( R . id . upgradeProgressBar ) ; systemWebViewPackageTextView = findViewById ( R . id . systemWebViewPackageTextView ) ; upgradeWebViewPackageTextView = findViewById ( R . id . upgradeWebViewPackageTextView ) ; upgradeStatusTextView = findViewById ( R . id . upgradeStatusTextView ) ; upgradeErrorTextView = findViewById ( R . id . upgradeErrorTextView ) ; upgradeProgressTextView = findViewById ( R . id . upgradeProgressTextView ) ; updateSystemWebViewPackageInfo ( ) ; updateSystemWebViewPackageInfo ( ) ; updateUpgradeWebViewStatus ( ) ; findViewById ( R . id . upgradeButton ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { showChooseWebViewDialog ( ) ; } } ) ; findViewById ( R . id . webViewButton ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { startActivity ( new Intent ( MainActivity . this , WebViewActivity . class ) ) ; } } ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; WebViewUpgrade . removeUpgradeCallback ( this ) ; } @ Override public void onUpgradeProcess ( float percent ) { updateUpgradeWebViewStatus ( ) ; } @ Override public void onUpgradeComplete ( ) { updateUpgradeWebViewStatus ( ) ; Toast . makeText ( getApplicationContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onUpgradeError ( Throwable throwable ) { Toast . makeText ( getApplicationContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; Log . e ( \"<STR_LIT>\" , \"<STR_LIT>\" + throwable . getMessage ( ) + \"<STR_LIT>\" + Log . getStackTraceString ( throwable ) ) ; updateUpgradeWebViewStatus ( ) ; } private void showChooseWebViewDialog ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( \"<STR_LIT>\" ) ; List < UpgradeInfo > upgradeInfoList = UPGRADE_PACKAGE_MAP . get ( ProcessUtils . getCurrentInstruction ( ) ) ; String [ ] items = new String [ upgradeInfoList . size ( ) ] ; for ( int i = <NUM_LIT> ; i < items . length ; i ++ ) { items [ i ] = upgradeInfoList . get ( i ) . title ; } builder . setItems ( items , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( WebViewUpgrade . isProcessing ( ) ) { Toast . makeText ( getApplicationContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } else if ( WebViewUpgrade . isCompleted ( ) ) { Toast . makeText ( getApplicationContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } else { UpgradeInfo upgradeInfo = upgradeInfoList . get ( which ) ; String systemWebViewPackageName = WebViewUpgrade . getSystemWebViewPackageName ( ) ; if ( systemWebViewPackageName != null && systemWebViewPackageName . equals ( upgradeInfo . packageName ) && VersionUtils . compareVersion ( WebViewUpgrade . getSystemWebViewPackageVersion ( ) , upgradeInfo . versionName ) >= <NUM_LIT> ) { Toast . makeText ( getApplicationContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; return ; } selectUpgradeInfo = upgradeInfo ; UpgradeSource upgradeSource = getUpgradeSource ( upgradeInfo ) ; if ( upgradeSource == null ) { return ; } WebViewUpgrade . upgrade ( upgradeSource ) ; updateUpgradeWebViewPackageInfo ( ) ; updateUpgradeWebViewStatus ( ) ; } } } ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; } @ Nullable private UpgradeSource getUpgradeSource ( UpgradeInfo upgradeInfo ) { UpgradeSource upgradeSource = null ; if ( upgradeInfo . extraInfo . equals ( \"<STR_LIT>\" ) ) { upgradeSource = new UpgradeDownloadSource ( getApplicationContext ( ) , upgradeInfo . url , new File ( getApplicationContext ( ) . getFilesDir ( ) , upgradeInfo . packageName + \"<STR_LIT>\" + upgradeInfo . versionName + \"<STR_LIT>\" ) ) ; } else if ( upgradeInfo . extraInfo . equals ( \"<STR_LIT>\" ) ) { upgradeSource = new UpgradeAssetSource ( getApplicationContext ( ) , upgradeInfo . url , new File ( getApplicationContext ( ) . getFilesDir ( ) , upgradeInfo . packageName + \"<STR_LIT>\" + upgradeInfo . versionName + \"<STR_LIT>\" ) ) ;", "output": "} else if ( upgradeInfo . extraInfo . equals ( \"<STR_LIT>\" ) ) { upgradeSource = new UpgradePackageSource ( getApplicationContext ( ) , upgradeInfo . packageName ) ; } return upgradeSource ; } private void updateSystemWebViewPackageInfo ( ) { String systemWebViewPackageName = WebViewUpgrade . getSystemWebViewPackageName ( ) ; String systemWebViewPackageVersion = WebViewUpgrade . getSystemWebViewPackageVersion ( ) ; String systemWebViewPackageInfo = \"<STR_LIT>\" ; if ( ! TextUtils . isEmpty ( systemWebViewPackageName ) || ! TextUtils . isEmpty ( systemWebViewPackageVersion ) ) { systemWebViewPackageInfo = ( ! TextUtils . isEmpty ( systemWebViewPackageName ) ? systemWebViewPackageName : \"<STR_LIT>\" ) + \"<STR_LIT>\" + ( ! TextUtils . isEmpty ( systemWebViewPackageVersion ) ? systemWebViewPackageVersion : \"<STR_LIT>\" ) ; } systemWebViewPackageTextView . setText ( systemWebViewPackageInfo ) ; } private void updateUpgradeWebViewPackageInfo ( ) { String upgradeWebViewPackageName = selectUpgradeInfo != null ? selectUpgradeInfo . packageName : null ; String upgradeWebViewPackageVersion = selectUpgradeInfo != null ? selectUpgradeInfo . versionName : null ; String upgradeWebViewPackageInfo = \"<STR_LIT>\" ; if ( ! TextUtils . isEmpty ( upgradeWebViewPackageName ) || ! TextUtils . isEmpty ( upgradeWebViewPackageVersion ) ) { upgradeWebViewPackageInfo = ( ! TextUtils . isEmpty ( upgradeWebViewPackageName ) ? upgradeWebViewPackageName : \"<STR_LIT>\" ) + \"<STR_LIT>\" + ( ! TextUtils . isEmpty ( upgradeWebViewPackageVersion ) ? upgradeWebViewPackageVersion : \"<STR_LIT>\" ) ; } else { upgradeWebViewPackageInfo = \"<STR_LIT>\" ; } upgradeWebViewPackageTextView . setText ( upgradeWebViewPackageInfo ) ; } private void updateUpgradeWebViewStatus ( ) { if ( WebViewUpgrade . isProcessing ( ) ) { upgradeStatusTextView . setText ( \"<STR_LIT>\" ) ; } else if ( WebViewUpgrade . isFailed ( ) ) { upgradeStatusTextView . setText ( \"<STR_LIT>\" ) ; } else if ( WebViewUpgrade . isCompleted ( ) ) { upgradeStatusTextView . setText ( \"<STR_LIT>\" ) ; } else { upgradeStatusTextView . setText ( \"<STR_LIT>\" ) ; } int process = ( int ) ( WebViewUpgrade . getUpgradeProcess ( ) * <NUM_LIT> ) ; progressBar . setProgress ( process ) ; upgradeProgressTextView . setText ( process + \"<STR_LIT>\" ) ; Throwable throwable = WebViewUpgrade . getUpgradeError ( ) ; if ( throwable == null ) { upgradeErrorTextView . setText ( \"<STR_LIT>\" ) ; } else { upgradeErrorTextView . setText ( \"<STR_LIT>\" + throwable . getMessage ( ) + \"<STR_LIT>\" + Log . getStackTraceString ( throwable ) ) ; } } static class UpgradeInfo { public UpgradeInfo ( String packageName , String versionName , String url , String extraInfo ) { this . title = packageName + \"<STR_LIT>\" + versionName ; this . extraInfo = ! TextUtils . isEmpty ( extraInfo ) ? extraInfo : \"<STR_LIT>\" ; if ( ! extraInfo . isEmpty ( ) ) { this . title = this . title + \"<STR_LIT>\" + extraInfo ; } this . url = url ; this . packageName = packageName ; this . versionName = versionName ; } public UpgradeInfo ( String packageName , String versionName , String url ) { this ( packageName , versionName , url , \"<STR_LIT>\" ) ; } String title ; String url ; String packageName ; String versionName ; String extraInfo ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import static de . robv . android . xposed . XposedHelpers . findClass ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . text . InputType ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . EditText ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . AlertDialogWpp ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class NewChat extends Feature { public NewChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) { var homeActivity = findClass ( \"<STR_LIT>\" , classLoader ) ; var newSettings = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , true ) ) return ; XposedHelpers . findAndHookMethod ( homeActivity , \"<STR_LIT>\" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var activity = ( Activity ) param . thisObject ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . new_chat ) ; var drawable = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; if ( drawable != null ) { drawable . setTint ( newSettings ? DesignUtils . getPrimaryTextColor ( ) : <NUM_LIT> ) ; item . setIcon ( drawable ) ; } if ( newSettings ) { item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; } item . setOnMenuItemClickListener ( item1 -> { var view = new LinearLayout ( activity ) ; view . setGravity ( Gravity . CENTER ) ; view . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ;", "output": "var edt = new EditText ( view . getContext ( ) ) ; edt . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT , <NUM_LIT> ) ) ; edt . setMaxLines ( <NUM_LIT> ) ; edt . setInputType ( InputType . TYPE_CLASS_PHONE ) ; edt . setTransformationMethod ( null ) ; edt . setHint ( ResId . string . number_with_country_code ) ; view . addView ( edt ) ; new AlertDialogWpp ( activity ) . setTitle ( activity . getString ( ResId . string . new_chat ) ) . setView ( view ) . setPositiveButton ( activity . getString ( ResId . string . message ) , ( dialog , which ) -> { var number = edt . getText ( ) . toString ( ) ; var numberFomatted = number . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" + numberFomatted ) ) ; intent . setPackage ( Utils . getApplication ( ) . getPackageName ( ) ) ; activity . startActivity ( intent ) ; } ) . setNegativeButton ( activity . getString ( ResId . string . cancel ) , null ) . show ( ) ; return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . res . Configuration ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ImageView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . preference . PreferenceManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . materialswitch . MaterialSwitch ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . AboutActivity ; import in . hridayan . ashell . activities . ExamplesActivity ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . SettingsItem ; import in . hridayan . ashell . utils . Utils ; import java . util . List ; public class SettingsAdapter extends RecyclerView . Adapter < SettingsAdapter . ViewHolder > { private List < SettingsItem > settingsList ; private Context context ; private int currentTheme ; public SettingsAdapter ( List < SettingsItem > settingsList , Context context , int currentTheme ) { this . settingsList = settingsList ; this . context = context ; this . currentTheme = currentTheme ; } public SettingsAdapter ( List < SettingsItem > settingsList , Context context ) { this . settingsList = settingsList ; this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . item_settings , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( ViewHolder holder , int position ) { SettingsItem settingsItem = settingsList . get ( position ) ; Drawable symbolDrawable = settingsItem . getSymbol ( context ) ; holder . symbolImageView . setImageDrawable ( symbolDrawable ) ; holder . titleTextView . setText ( settingsItem . getTitle ( ) ) ;", "output": "holder . descriptionTextView . setText ( settingsItem . getDescription ( ) ) ; holder . descriptionTextView . setVisibility ( TextUtils . isEmpty ( settingsItem . getDescription ( ) ) ? View . GONE : View . VISIBLE ) ; holder . switchView . setVisibility ( settingsItem . hasSwitch ( ) ? View . VISIBLE : View . GONE ) ; holder . switchView . setChecked ( settingsItem . isChecked ( ) ) ; holder . switchView . setOnCheckedChangeListener ( ( buttonView , isChecked ) -> { settingsItem . setChecked ( isChecked ) ; settingsItem . saveSwitchState ( context ) ; switch ( settingsItem . getId ( ) ) { case \"<STR_LIT>\" : if ( ( context . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ) == Configuration . UI_MODE_NIGHT_YES ) { applyTheme ( isChecked ) ; } break ; default : break ; } } ) ; View . OnClickListener clickListener = new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent intent ; switch ( settingsItem . getId ( ) ) { case \"<STR_LIT>\" : Preferences . setSpecificCardVisibility ( context , \"<STR_LIT>\" , true ) ; Toast . makeText ( context , context . getString ( R . string . unhide_cards_message ) , Toast . LENGTH_SHORT ) . show ( ) ; break ; case \"<STR_LIT>\" : intent = new Intent ( context , ExamplesActivity . class ) ; context . startActivity ( intent ) ; break ; case \"<STR_LIT>\" : intent = new Intent ( context , AboutActivity . class ) ; context . startActivity ( intent ) ; break ; case \"<STR_LIT>\" : Utils . defaultWorkingModeDialog ( context ) ; break ; default : return ; } } } ; holder . settingsItemLayout . setOnClickListener ( clickListener ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == getItemCount ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; holder . itemView . setLayoutParams ( layoutParams ) ; } private void applyTheme ( boolean isAmoledTheme ) { int themeId = isAmoledTheme ? R . style . ThemeOverlay_aShellYou_AmoledTheme : R . style . aShellYou_AppTheme ; context . setTheme ( themeId ) ; currentTheme = themeId ; ( ( AppCompatActivity ) context ) . recreate ( ) ; } @ Override public int getItemCount ( ) { return settingsList . size ( ) ; } public boolean getSavedSwitchState ( String id ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; return prefs . getBoolean ( id , false ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { ImageView symbolImageView ; TextView titleTextView , descriptionTextView ; MaterialSwitch switchView ; ConstraintLayout settingsItemLayout ; public ViewHolder ( View itemView ) { super ( itemView ) ; symbolImageView = itemView . findViewById ( R . id . symbol_image_view ) ; titleTextView = itemView . findViewById ( R . id . setting_title ) ; descriptionTextView = itemView . findViewById ( R . id . setting_description ) ; switchView = itemView . findViewById ( R . id . setting_switch ) ; settingsItemLayout = itemView . findViewById ( R . id . settings_item_layout ) ; } } }"}, {"input": "package android . app ; import android . content . pm . ApplicationInfo ; public final class LoadedApk { public ApplicationInfo getApplicationInfo ( ) {", "output": "throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public ClassLoader getClassLoader ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getPackageName ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public String getResDir ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package android . content . res ; import android . os . Parcel ; import android . os . Parcelable ; public class CompatibilityInfo implements Parcelable { @ Override public int describeContents ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static final Parcelable . Creator < CompatibilityInfo > CREATOR = null ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class DeleteBundleOptions { @ NonNull private String bundleId ; public DeleteBundleOptions ( @ NonNull String bundleId ) { this . bundleId = bundleId ; }", "output": "@ NonNull public String getBundleId ( ) { return bundleId ; } }"}, {"input": "package com . reactnative . imagecrop ; import com . facebook . react . bridge . ReadableMap ; public class ObjectRect { private int top ; private int left ; private int width ; private int height ; public ObjectRect ( int top , int left , int width , int height ) { this . top = top ; this . left = left ; this . width = width ; this . height = height ; } public static ObjectRect fromReadableMap ( ReadableMap map ) {", "output": "int top = - <NUM_LIT> , left = - <NUM_LIT> , width = - <NUM_LIT> , height = - <NUM_LIT> ; if ( map . hasKey ( \"<STR_LIT>\" ) ) { top = map . getInt ( \"<STR_LIT>\" ) ; } if ( map . hasKey ( \"<STR_LIT>\" ) ) { left = map . getInt ( \"<STR_LIT>\" ) ; } if ( map . hasKey ( \"<STR_LIT>\" ) ) { width = map . getInt ( \"<STR_LIT>\" ) ; } if ( map . hasKey ( \"<STR_LIT>\" ) ) { height = map . getInt ( \"<STR_LIT>\" ) ; } if ( top != - <NUM_LIT> && left != - <NUM_LIT> && width != - <NUM_LIT> && height != - <NUM_LIT> ) { return new ObjectRect ( top , left , width , height ) ; } return null ; } public int getTop ( ) { return top ; } public void setTop ( int top ) { this . top = top ; } public int getLeft ( ) { return left ; } public void setLeft ( int left ) { this . left = left ; } public int getWidth ( ) { return width ; } public void setWidth ( int width ) { this . width = width ; } public int getHeight ( ) { return height ; } public void setHeight ( int height ) { this . height = height ; } }"}, {"input": "package org . woheller69 . weather . database ; import java . util . Locale ; public class City { private int cityId ; private String cityName ; private String countryCode ; private float lon ; private float lat ; public City ( ) { } public int getCityId ( ) { return cityId ; } public void setCityId ( int cityId ) { this . cityId = cityId ; } public String getCityName ( ) { return cityName ; } public void setCityName ( String cityName ) { this . cityName = cityName ; } public String getCountryCode ( ) { return countryCode ; } public void setCountryCode ( String countryCode ) { this . countryCode = countryCode ; } @ Override public String toString ( ) { return String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , cityName , countryCode , lat , lon ) ; } public void setLatitude ( float latitude ) { lat = latitude ;", "output": "} public float getLatitude ( ) { return lat ; } public float getLongitude ( ) { return lon ; } public void setLongitude ( float lon ) { this . lon = lon ; } }"}, {"input": "package in . hridayan . ashell . adapters ; import static in . hridayan . ashell . utils . Preferences . SORT_A_TO_Z ; import static in . hridayan . ashell . utils . Preferences . SORT_LEAST_USED ; import static in . hridayan . ashell . utils . Preferences . SORT_MOST_USED ; import static in . hridayan . ashell . utils . Preferences . SORT_Z_TO_A ; import android . animation . ObjectAnimator ; import android . content . Context ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Build ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . animation . AnimationUtils ; import androidx . annotation . NonNull ; import androidx . appcompat . widget . AppCompatImageButton ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . card . MaterialCardView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . stream . IntStream ; public class ExamplesAdapter extends RecyclerView . Adapter < ExamplesAdapter . ViewHolder > { public final List < CommandItems > data ; public List < CommandItems > selectedItems = new ArrayList < > ( ) ; private Context context ; private CommandItems commands ; private OnItemClickListener listener ; public ExamplesAdapter ( List < CommandItems > data , Context context ) { this . data = data ; this . context = context ; } public void setOnItemClickListener ( OnItemClickListener listener ) { this . listener = listener ; } public interface OnItemClickListener { void onItemClick ( int position ) ; void onItemLongClick ( int position ) ; } @ NonNull @ Override public ExamplesAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_examples , parent , false ) ; return new ExamplesAdapter . ViewHolder ( rowItem ) ;", "output": "} @ Override public void onBindViewHolder ( @ NonNull ExamplesAdapter . ViewHolder holder , int position ) { CommandItems currentItem = this . data . get ( position ) ; holder . pin . setVisibility ( currentItem . isPinned ( ) ? View . VISIBLE : View . GONE ) ; if ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ) { holder . pin . setColorFilter ( Utils . getColor ( pinColor ( ) , context ) ) ; } holder . card . setStrokeWidth ( currentItem . isPinned ( ) ? <NUM_LIT> : <NUM_LIT> ) ; holder . card . setChecked ( currentItem . isChecked ( ) ) ; holder . itemView . startAnimation ( AnimationUtils . loadAnimation ( context , R . anim . on_scroll_animator ) ) ; holder . mTitle . setText ( currentItem . getTitle ( ) ) ; if ( currentItem . getSummary ( ) != null ) { holder . mSummary . setText ( currentItem . getSummary ( ) ) ; int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; layoutParams . bottomMargin = position == data . size ( ) - <NUM_LIT> ? paddingInPixels : <NUM_LIT> ; holder . itemView . setLayoutParams ( layoutParams ) ; translatePinIcon ( holder . card . isChecked ( ) , holder . pin ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener , View . OnLongClickListener { private final MaterialTextView mTitle , mSummary ; private MaterialCardView card ; private AppCompatImageButton pin ; private float pinTranslation = <NUM_LIT> ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; view . setOnLongClickListener ( this ) ; this . card = view . findViewById ( R . id . commands_card ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; this . pin = view . findViewById ( R . id . pin ) ; } @ Override public void onClick ( View view ) { if ( data . get ( getAdapterPosition ( ) ) . getExample ( ) != null && ! isAtLeastOneItemChecked ( ) ) { String sanitizedText = sanitizeText ( data . get ( getAdapterPosition ( ) ) . getTitle ( ) ) ; String string = String . valueOf ( data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ) ; Context context = view . getContext ( ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . example ) . setMessage ( data . get ( getAdapterPosition ( ) ) . getExample ( ) ) . setPositiveButton ( R . string . use , ( dialogInterface , i ) -> { int counter = data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ; data . get ( getAdapterPosition ( ) ) . setUseCounter ( counter + <NUM_LIT> ) ; Intent intent = new Intent ( context , MainActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , sanitizedText ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; context . startActivity ( intent ) ; } ) . setNegativeButton ( R . string . copy , ( dialogInterface , i ) -> { Utils . copyToClipboard ( sanitizedText , context ) ; } ) . show ( ) ; } else { startItemSelecting ( ) ; } } @ Override public boolean onLongClick ( View view ) { startItemSelecting ( ) ; return true ; } public void startItemSelecting ( ) { card . setChecked ( ! card . isChecked ( ) ) ; data . get ( getAdapterPosition ( ) ) . setChecked ( card . isChecked ( ) ) ; updateSelectedItems ( data . get ( getAdapterPosition ( ) ) , card . isChecked ( ) ) ; listener . onItemLongClick ( getAdapterPosition ( ) ) ; translatePinIcon ( card . isChecked ( ) , pin ) ; } public boolean isAtLeastOneItemChecked ( ) { for ( CommandItems item : data ) { if ( item . isChecked ( ) ) { return true ; } } return false ; } } public void updateSelectedItems ( CommandItems item , boolean isChecked ) { if ( isChecked ) { selectedItems . add ( item ) ; } else { selectedItems . remove ( item ) ; } } public List < CommandItems > getSelectedItems ( ) { return selectedItems ; } public int getSelectedItemsSize ( ) { return selectedItems . size ( ) ; } public void selectAll ( ) { for ( CommandItems item : data ) { if ( ! item . isChecked ( ) ) { item . setChecked ( true ) ; updateSelectedItems ( item , true ) ; } notifyDataSetChanged ( ) ; } } public void deselectAll ( ) { for ( CommandItems item : data ) { if ( item . isChecked ( ) ) { item . setChecked ( false ) ; updateSelectedItems ( item , false ) ; } notifyDataSetChanged ( ) ; } } public void addSelectedToBookmarks ( ) { int totalItems = selectedItems . size ( ) ; int numBatches = ( totalItems < <NUM_LIT> ) ? totalItems : <NUM_LIT> ; int batchSize = totalItems / numBatches ; int remainingItems = totalItems % numBatches ; AtomicInteger counter = new AtomicInteger ( <NUM_LIT> ) ; IntStream . range ( <NUM_LIT> , numBatches ) . parallel ( ) . forEach ( i -> { int startIndex = i * batchSize ; int endIndex = ( i == numBatches - <NUM_LIT> ) ? totalItems : ( startIndex + batchSize ) ; List < CommandItems > batch = selectedItems . subList ( startIndex , endIndex ) ; Set < String > bookmarksSet = new HashSet < > ( Utils . getBookmarks ( context ) ) ; batch . forEach ( item -> { String command = sanitizeText ( item . getTitle ( ) ) ; if ( ! bookmarksSet . contains ( command ) ) { Utils . addToBookmark ( command , context ) ; } else { counter . incrementAndGet ( ) ; } } ) ; } ) ; } public void deleteSelectedFromBookmarks ( ) { for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; Utils . deleteFromBookmark ( command , context ) ; } } public boolean isAllItemsBookmarked ( ) { int i = <NUM_LIT> ; for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; if ( ! Utils . isBookmarked ( command , context ) ) { return false ; } } return true ; } public boolean isAllItemsPinned ( ) { int i = <NUM_LIT> ; for ( CommandItems item : selectedItems ) { String command = sanitizeText ( item . getTitle ( ) . toString ( ) ) ; if ( ! item . isPinned ( ) ) { return false ; } } return true ; } public String sanitizeText ( String text ) { String sanitizedText = text . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return sanitizedText . trim ( ) ; } public void pinUnpinSelectedItems ( boolean isAllPinned ) { if ( ! selectedItems . isEmpty ( ) ) { List < CommandItems > pinnedItems = new ArrayList < > ( selectedItems ) ; for ( CommandItems selectedItem : pinnedItems ) { if ( ! isAllPinned ) { selectedItem . setPinned ( true ) ; data . remove ( selectedItem ) ; data . add ( <NUM_LIT> , selectedItem ) ; } else { selectedItem . setPinned ( false ) ; } sortData ( ) ; selectedItem . setChecked ( false ) ; updateSelectedItems ( selectedItem , false ) ; } notifyDataSetChanged ( ) ; } } public void sortData ( ) { Collections . sort ( data , new Comparator < CommandItems > ( ) { @ Override public int compare ( CommandItems item1 , CommandItems item2 ) { if ( item1 . isPinned ( ) && ! item2 . isPinned ( ) ) { return - <NUM_LIT> ; } else if ( ! item1 . isPinned ( ) && item2 . isPinned ( ) ) { return <NUM_LIT> ; } int sortOption = Preferences . getSortingExamples ( context ) ; int counter1 = item1 . getUseCounter ( ) ; int counter2 = item2 . getUseCounter ( ) ; switch ( sortOption ) { case SORT_A_TO_Z : return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; case SORT_Z_TO_A : return item2 . getTitle ( ) . compareToIgnoreCase ( item1 . getTitle ( ) ) ; case SORT_MOST_USED : if ( counter1 != counter2 ) { return counter2 - counter1 ; } else { return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; } case SORT_LEAST_USED : if ( counter1 != counter2 ) { return counter1 - counter2 ; } else { return item1 . getTitle ( ) . compareToIgnoreCase ( item2 . getTitle ( ) ) ; } default : return <NUM_LIT> ; } } } ) ; notifyDataSetChanged ( ) ; } private int pinColor ( ) { int currentMode = context . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; return currentMode == Configuration . UI_MODE_NIGHT_YES ? android . R . color . system_accent3_100 : android . R . color . system_accent3_500 ; } private void translatePinIcon ( boolean isChecked , AppCompatImageButton pin ) { float translationX = isChecked ? - Utils . convertDpToPixel ( <NUM_LIT> , context ) : <NUM_LIT> ; if ( pin . getTranslationX ( ) != translationX ) { ObjectAnimator animator = ObjectAnimator . ofFloat ( pin , \"<STR_LIT>\" , translationX ) ; animator . setDuration ( <NUM_LIT> ) ; animator . start ( ) ; pin . setTranslationX ( translationX ) ; } } }"}, {"input": "package in . hridayan . ashell . adapters ; import android . content . Context ; import android . content . Intent ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textview . MaterialTextView ; import in . hridayan . ashell . R ; import in . hridayan . ashell . activities . MainActivity ; import in . hridayan . ashell . utils . CommandItems ; import in . hridayan . ashell . utils . Utils ; import java . util . ArrayList ; import java . util . List ; public class CommandsSearchAdapter extends RecyclerView . Adapter < CommandsSearchAdapter . ViewHolder > { private final List < CommandItems > data ; private Context context ; public CommandsSearchAdapter ( @ Nullable List < CommandItems > data , Context context ) { this . data = data != null ? data : new ArrayList < > ( ) ; this . context = context ; } public void setFilteredList ( List < CommandItems > filteredList ) { this . data . clear ( ) ; this . data . addAll ( filteredList ) ; notifyDataSetChanged ( ) ; } @ NonNull @ Override public CommandsSearchAdapter . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { View rowItem = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . rv_examples , parent , false ) ; return new CommandsSearchAdapter . ViewHolder ( rowItem ) ; } @ Override public void onBindViewHolder ( @ NonNull CommandsSearchAdapter . ViewHolder holder , int position ) { holder . mTitle . setText ( this . data . get ( position ) . getTitle ( ) ) ; if ( this . data . get ( position ) . getSummary ( ) != null ) { holder . mSummary . setText ( this . data . get ( position ) . getSummary ( ) ) ; int paddingInDp ; if ( position == data . size ( ) - <NUM_LIT> && data . size ( ) != <NUM_LIT> ) { paddingInDp = <NUM_LIT> ; } else if ( position == <NUM_LIT> ) { paddingInDp = <NUM_LIT> ; } else { paddingInDp = <NUM_LIT> ; } int paddingInPixels = ( int ) ( Utils . convertDpToPixel ( <NUM_LIT> , context ) ) ; ViewGroup . MarginLayoutParams layoutParams = ( ViewGroup . MarginLayoutParams ) holder . itemView . getLayoutParams ( ) ; if ( position == data . size ( ) - <NUM_LIT> && data . size ( ) != <NUM_LIT> ) { layoutParams . bottomMargin = paddingInPixels ; } else if ( position == <NUM_LIT> || data . size ( ) == <NUM_LIT> ) { layoutParams . topMargin = paddingInPixels ; } else { layoutParams . bottomMargin = <NUM_LIT> ; } holder . itemView . setLayoutParams ( layoutParams ) ; } } @ Override public int getItemCount ( ) { return this . data . size ( ) ; } public class ViewHolder extends RecyclerView . ViewHolder implements View . OnClickListener { private final MaterialTextView mTitle , mSummary ; public ViewHolder ( View view ) { super ( view ) ; view . setOnClickListener ( this ) ; this . mTitle = view . findViewById ( R . id . title ) ; this . mSummary = view . findViewById ( R . id . summary ) ; } @ Override public void onClick ( View view ) { if ( data . get ( getAdapterPosition ( ) ) . getExample ( ) != null ) { String sanitizedText = sanitizeText ( data . get ( getAdapterPosition ( ) ) . getTitle ( ) ) ; Context context = view . getContext ( ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . example ) . setMessage ( data . get ( getAdapterPosition ( ) ) . getExample ( ) ) . setPositiveButton ( R . string . use , ( dialogInterface , i ) -> { int counter = data . get ( getAdapterPosition ( ) ) . getUseCounter ( ) ; data . get ( getAdapterPosition ( ) ) . setUseCounter ( counter + <NUM_LIT> ) ; Intent intent = new Intent ( context , MainActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , sanitizedText ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_SINGLE_TOP | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; context . startActivity ( intent ) ; } ) . setNegativeButton ( R . string . copy , ( dialogInterface , i ) -> { Utils . copyToClipboard ( sanitizedText , context ) ; }", "output": ") . show ( ) ; } } private String sanitizeText ( String text ) { String sanitizedText = text . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return sanitizedText . trim ( ) ; } } }"}, {"input": "package com . simon . harmonichackernews . utils ; public class Changelog { static public String getHTML ( ) {", "output": "return \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . app . Dialog ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . text . TextWatcher ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatDialogFragment ; import androidx . fragment . app . FragmentManager ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . simon . harmonichackernews . adapters . CommentSearchAdapter ; import com . simon . harmonichackernews . data . Comment ; import java . io . Serializable ; import java . util . List ; public class CommentsSearchDialogFragment extends AppCompatDialogFragment { public static String TAG = \"<STR_LIT>\" ; public final static String EXTRA_SEARCHABLE_COMMENTS = \"<STR_LIT>\" ; private TextInputEditText searchBar ; private RecyclerView recyclerView ; private TextView matchesText ; private CommentSearchAdapter adapter ; private List < Comment > comments ; private final CommentSelectedListener listener ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( getArguments ( ) != null ) { comments = ( List < Comment > ) getArguments ( ) . getSerializable ( EXTRA_SEARCHABLE_COMMENTS ) ; }", "output": "} public CommentsSearchDialogFragment ( CommentSelectedListener commentSelectedListener ) { this . listener = commentSelectedListener ; } @ NonNull @ Override public Dialog onCreateDialog ( @ Nullable Bundle savedInstanceState ) { super . onCreateDialog ( savedInstanceState ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( requireContext ( ) ) ; LayoutInflater inflater = requireActivity ( ) . getLayoutInflater ( ) ; View rootView = inflater . inflate ( R . layout . comments_search_dialog , null ) ; searchBar = rootView . findViewById ( R . id . comments_search_edittext ) ; recyclerView = rootView . findViewById ( R . id . comments_search_recyclerview ) ; matchesText = rootView . findViewById ( R . id . comments_search_matches ) ; if ( getArguments ( ) != null ) { comments = ( List < Comment > ) getArguments ( ) . getSerializable ( EXTRA_SEARCHABLE_COMMENTS ) ; comments = comments . subList ( <NUM_LIT> , comments . size ( ) ) ; } updateMatches ( null ) ; adapter = new CommentSearchAdapter ( comments ) ; recyclerView . setAdapter ( adapter ) ; recyclerView . setLayoutManager ( new LinearLayoutManager ( getContext ( ) ) ) ; searchBar . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void afterTextChanged ( Editable editable ) { String searchTerm = editable . toString ( ) ; adapter . setSearchTerm ( searchTerm ) ; adapter . notifyDataSetChanged ( ) ; updateMatches ( searchTerm ) ; } } ) ; builder . setView ( rootView ) ; final AlertDialog dialog = builder . create ( ) ; adapter . setItemClickListener ( new CommentSearchAdapter . ItemClickListener ( ) { @ Override public void onItemClick ( Comment comment ) { if ( listener != null ) { listener . onCommentSelected ( comment ) ; } dialog . cancel ( ) ; } } ) ; return dialog ; } private void updateMatches ( String searchTerm ) { int matchingComments = <NUM_LIT> ; if ( TextUtils . isEmpty ( searchTerm ) ) { matchingComments = comments . size ( ) ; } else { for ( Comment c : comments ) { if ( c . text . toUpperCase ( ) . contains ( searchTerm . toUpperCase ( ) ) ) { matchingComments ++ ; } } } matchesText . setText ( \"<STR_LIT>\" + matchingComments + ( matchingComments == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; } public static void showCommentSearchDialog ( FragmentManager fm , List < Comment > comments , CommentSelectedListener listener ) { CommentsSearchDialogFragment dialogFragment = new CommentsSearchDialogFragment ( listener ) ; Bundle bundle = new Bundle ( ) ; bundle . putSerializable ( EXTRA_SEARCHABLE_COMMENTS , ( Serializable ) comments ) ; dialogFragment . setArguments ( bundle ) ; dialogFragment . show ( fm , CommentsSearchDialogFragment . TAG ) ; } public interface CommentSelectedListener { void onCommentSelected ( Comment comment ) ; } }"}, {"input": "package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . app . Application ; import android . content . Context ; import android . content . Intent ; import android . os . Handler ; import android . os . Looper ; import androidx . appcompat . app . AppCompatDelegate ; import androidx . preference . PreferenceManager ; import java . util . Locale ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import rikka . material . app . LocaleDelegate ; public class App extends Application { private static App instance ; private static final ExecutorService executorService = Executors . newCachedThreadPool ( ) ; private static final Handler MainHandler = new Handler ( Looper . getMainLooper ( ) ) ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onCreate ( ) { super . onCreate ( ) ; instance = this ; var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( this ) ; sharedPreferences . edit ( ) . putLong ( \"<STR_LIT>\" , System . currentTimeMillis ( ) ) . commit ( ) ; var mode = Integer . parseInt ( sharedPreferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; setThemeMode ( mode ) ; changeLanguage ( this ) ; } public static void setThemeMode ( int mode ) { switch ( mode ) { case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_FOLLOW_SYSTEM ) ;", "output": "break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_YES ) ; break ; case <NUM_LIT> : AppCompatDelegate . setDefaultNightMode ( AppCompatDelegate . MODE_NIGHT_NO ) ; break ; } } public static App getInstance ( ) { return instance ; } public static ExecutorService getExecutorService ( ) { return executorService ; } public static Handler getMainHandler ( ) { return MainHandler ; } public void restartApp ( String packageWpp ) { Intent intent = new Intent ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , packageWpp ) ; sendBroadcast ( intent ) ; } public static void changeLanguage ( Context context ) { var force = PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( \"<STR_LIT>\" , false ) ; LocaleDelegate . setDefaultLocale ( force ? Locale . ENGLISH : Locale . getDefault ( ) ) ; var res = context . getResources ( ) ; var config = res . getConfiguration ( ) ; config . setLocale ( LocaleDelegate . getDefaultLocale ( ) ) ; res . updateConfiguration ( config , res . getDisplayMetrics ( ) ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . media ; import android . graphics . Color ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedHelpers ; public class DownloadProfile extends Feature { public DownloadProfile ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ;", "output": "} @ Override public void doHook ( ) throws Throwable { var loadProfileInfoField = Unobfuscator . loadProfileInfoField ( classLoader ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Menu . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; var icon = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; if ( icon != null ) { icon . setTint ( Color . WHITE ) ; item . setIcon ( icon ) ; } item . setOnMenuItemClickListener ( menuItem -> { var subCls = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( subCls == null ) { log ( new Exception ( \"<STR_LIT>\" ) ) ; return true ; } var field = Unobfuscator . getFieldByType ( subCls , loadProfileInfoField . getDeclaringClass ( ) ) ; var jidObj = ReflectionUtils . getField ( loadProfileInfoField , ReflectionUtils . getField ( field , param . thisObject ) ) ; var jid = WppCore . stripJID ( WppCore . getRawString ( jidObj ) ) ; var file = WppCore . getContactPhotoFile ( jid ) ; var destPath = Utils . getDestination ( prefs , \"<STR_LIT>\" ) ; var name = Utils . generateName ( jidObj , \"<STR_LIT>\" ) ; var error = Utils . copyFile ( file , new File ( destPath , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + destPath , Toast . LENGTH_LONG ) . show ( ) ; } else { Toast . makeText ( Utils . getApplication ( ) , Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + \"<STR_LIT>\" + error , Toast . LENGTH_LONG ) . show ( ) ; } return true ; } ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . content . res . Resources ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . PorterDuffColorFilter ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . text . TextUtils ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . DelMessageStore ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Field ; import java . text . DateFormat ; import java . util . Arrays ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiRevoke extends Feature { private static final HashMap < String , HashSet < String > > messageRevokedMap = new HashMap < > ( ) ; public AntiRevoke ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var antiRevokeMessageMethod = Unobfuscator . loadAntiRevokeMessageMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( antiRevokeMessageMethod ) ) ; var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var unknownStatusPlaybackMethod = Unobfuscator . loadUnknownStatusPlaybackMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( unknownStatusPlaybackMethod ) ) ; var statusPlaybackField = Unobfuscator . loadStatusPlaybackViewField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( statusPlaybackField ) ) ; XposedBridge . hookMethod ( antiRevokeMessageMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Exception { var fMessage = new FMessageWpp ( param . args [ <NUM_LIT> ] ) ; var messageKey = fMessage . getKey ( ) ; var deviceJid = fMessage . getDeviceJid ( ) ; var id = fMessage . getRowId ( ) ; var messageID = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , \"<STR_LIT>\" ) ; if ( WppCore . getPrivBoolean ( messageID + \"<STR_LIT>\" , false ) ) { WppCore . removePrivKey ( messageID + \"<STR_LIT>\" ) ; var activity = WppCore . getCurrentActivity ( ) ; Class < ? > StatusPlaybackActivityClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; if ( activity != null && StatusPlaybackActivityClass . isInstance ( activity ) ) { activity . finish ( ) ; } return ; } var rawString = WppCore . getRawString ( messageKey . remoteJid ) ; if ( WppCore . isGroup ( rawString ) ) { if ( deviceJid != null && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } else if ( ! messageKey . isFromMe && antiRevoke ( fMessage ) != <NUM_LIT> ) { param . setResult ( true ) ; } } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var dateTextView = ( TextView ) param . args [ <NUM_LIT> ] ; isMRevoked ( objMessage , dateTextView , \"<STR_LIT>\" ) ; } } ) ; XposedBridge . hookMethod ( unknownStatusPlaybackMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var obj = param . args [ <NUM_LIT> ] ; var objMessage = param . args [ <NUM_LIT> ] ; Object objView = statusPlaybackField . get ( obj ) ; Field [ ] textViews = Arrays . stream ( statusPlaybackField . getType ( ) . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) == TextView . class ) . toArray ( Field [ ] :: new ) ; if ( textViews == null ) { log ( \"<STR_LIT>\" ) ; return ; } int dateId = Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; for ( Field textView : textViews ) { TextView textView1 = ( TextView ) XposedHelpers . getObjectField ( objView , textView . getName ( ) ) ; if ( textView1 == null || textView1 . getId ( ) == dateId ) { isMRevoked ( objMessage , textView1 , \"<STR_LIT>\" ) ; break ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } public static Drawable scaleImage ( Resources resources , Drawable image , float scaleFactor ) { if ( ! ( image instanceof BitmapDrawable ) ) { return image ; } Bitmap b = ( ( BitmapDrawable ) image ) . getBitmap ( ) ; int sizeX = Math . round ( image . getIntrinsicWidth ( ) * scaleFactor ) ; int sizeY = Math . round ( image . getIntrinsicHeight ( ) * scaleFactor ) ; Bitmap bitmapResized = Bitmap . createScaledBitmap ( b , sizeX , sizeY , false ) ; return new BitmapDrawable ( resources , bitmapResized ) ; } private static void saveRevokedMessage ( FMessageWpp fMessage ) { var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , \"<STR_LIT>\" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; HashSet < String > messages = getRevokedMessages ( fMessage ) ;", "output": "messages . add ( messageKey ) ; DelMessageStore . getInstance ( Utils . getApplication ( ) ) . insertMessage ( stripJID , messageKey , System . currentTimeMillis ( ) ) ; } private static HashSet < String > getRevokedMessages ( FMessageWpp fMessage ) { String jid = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; if ( messageRevokedMap . containsKey ( jid ) ) { return messageRevokedMap . get ( jid ) ; } var messages = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getMessagesByJid ( jid ) ; if ( messages == null ) messages = new HashSet < > ( ) ; messageRevokedMap . put ( jid , messages ) ; return messages ; } private void isMRevoked ( Object objMessage , TextView dateTextView , String antirevokeType ) { if ( dateTextView == null ) return ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; var messageRevokedList = getRevokedMessages ( fMessage ) ; var id = fMessage . getRowId ( ) ; String keyOrig = null ; if ( messageRevokedList . contains ( key . messageID ) || ( ( keyOrig = MessageStore . getInstance ( ) . getOriginalMessageKey ( id ) ) != null && messageRevokedList . contains ( keyOrig ) ) ) { var timestamp = DelMessageStore . getInstance ( Utils . getApplication ( ) ) . getTimestampByMessageId ( keyOrig == null ? key . messageID : keyOrig ) ; if ( timestamp > <NUM_LIT> ) { Locale locale = Utils . getApplication ( ) . getResources ( ) . getConfiguration ( ) . getLocales ( ) . get ( <NUM_LIT> ) ; DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , locale ) ; var date = dateFormat . format ( new Date ( timestamp ) ) ; dateTextView . getPaint ( ) . setUnderlineText ( true ) ; dateTextView . setOnClickListener ( v -> Utils . showToast ( String . format ( Utils . getApplication ( ) . getString ( ResId . string . message_removed_on ) , date ) , Toast . LENGTH_LONG ) ) ; } var antirevokeValue = Integer . parseInt ( prefs . getString ( antirevokeType , \"<STR_LIT>\" ) ) ; if ( antirevokeValue == <NUM_LIT> ) { var newTextData = UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) + \"<STR_LIT>\" + dateTextView . getText ( ) ; dateTextView . setText ( newTextData ) ; } else if ( antirevokeValue == <NUM_LIT> ) { var icon = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; var drawable = scaleImage ( Utils . getApplication ( ) . getResources ( ) , icon , <NUM_LIT> ) ; drawable . setColorFilter ( new PorterDuffColorFilter ( Color . RED , PorterDuff . Mode . SRC_ATOP ) ) ; dateTextView . setCompoundDrawablesWithIntrinsicBounds ( null , null , drawable , null ) ; dateTextView . setCompoundDrawablePadding ( <NUM_LIT> ) ; } } else { dateTextView . setCompoundDrawables ( null , null , null , null ) ; var revokeNotice = UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) + \"<STR_LIT>\" ; var dateText = dateTextView . getText ( ) . toString ( ) ; if ( dateText . contains ( revokeNotice ) ) { dateTextView . setText ( dateText . replace ( revokeNotice , \"<STR_LIT>\" ) ) ; } dateTextView . getPaint ( ) . setUnderlineText ( false ) ; dateTextView . setOnClickListener ( null ) ; } } private int antiRevoke ( FMessageWpp fMessage ) { showToast ( fMessage ) ; var messageKey = ( String ) XposedHelpers . getObjectField ( fMessage . getObject ( ) , \"<STR_LIT>\" ) ; var stripJID = WppCore . stripJID ( WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ) ; var revokeboolean = stripJID . equals ( \"<STR_LIT>\" ) ? Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( revokeboolean == <NUM_LIT> ) return revokeboolean ; var messageRevokedList = getRevokedMessages ( fMessage ) ; if ( ! messageRevokedList . contains ( messageKey ) ) { try { AsyncTask . THREAD_POOL_EXECUTOR . execute ( ( ) -> { saveRevokedMessage ( fMessage ) ; try { var mConversation = WppCore . getCurrentConversation ( ) ; if ( mConversation != null && WppCore . stripJID ( WppCore . getCurrentRawJID ( ) ) . equals ( stripJID ) ) { mConversation . runOnUiThread ( ( ) -> { if ( mConversation . hasWindowFocus ( ) ) { mConversation . startActivity ( mConversation . getIntent ( ) ) ; mConversation . overridePendingTransition ( <NUM_LIT> , <NUM_LIT> ) ; mConversation . getWindow ( ) . getDecorView ( ) . findViewById ( android . R . id . content ) . postInvalidate ( ) ; } else { mConversation . recreate ( ) ; } } ) ; } } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } ) ; } catch ( Exception e ) { XposedBridge . log ( e . getMessage ( ) ) ; } } return revokeboolean ; } private void showToast ( FMessageWpp fMessage ) { var jidAuthor = WppCore . getRawString ( fMessage . getKey ( ) . remoteJid ) ; var messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_message ) ; var isStatus = Objects . equals ( WppCore . stripJID ( jidAuthor ) , \"<STR_LIT>\" ) ; if ( isStatus ) { messageSuffix = Utils . getApplication ( ) . getString ( ResId . string . deleted_status ) ; jidAuthor = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; } if ( TextUtils . isEmpty ( jidAuthor ) ) return ; String name = WppCore . getContactName ( WppCore . createUserJid ( jidAuthor ) ) ; if ( TextUtils . isEmpty ( name ) ) { name = WppCore . stripJID ( jidAuthor ) ; } String message ; if ( WppCore . isGroup ( jidAuthor ) && fMessage . getUserJid ( ) != null ) { var participantJid = fMessage . getUserJid ( ) ; String participantName = WppCore . getContactName ( participantJid ) ; if ( TextUtils . isEmpty ( participantName ) ) { participantName = WppCore . stripJID ( WppCore . getRawString ( participantJid ) ) ; } message = Utils . getApplication ( ) . getString ( ResId . string . deleted_a_message_in_group , participantName , name ) ; } else { message = name + \"<STR_LIT>\" + messageSuffix ; } if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { Utils . showToast ( message , Toast . LENGTH_LONG ) ; } Tasker . sendTaskerEvent ( name , WppCore . stripJID ( jidAuthor ) , isStatus ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import android . graphics . PointF ; import android . util . DisplayMetrics ; import android . view . View ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public class PagerSnapHelper extends SnapHelper { private static final int MAX_SCROLL_ON_FLING_DURATION = <NUM_LIT> ; @ Nullable private OrientationHelper mVerticalHelper ; @ Nullable private OrientationHelper mHorizontalHelper ; @ Nullable @ Override public int [ ] calculateDistanceToFinalSnap ( @ NonNull RecyclerView . LayoutManager layoutManager , @ NonNull View targetView ) { int [ ] out = new int [ <NUM_LIT> ] ; if ( layoutManager . canScrollHorizontally ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getHorizontalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } if ( layoutManager . canScrollVertically ( ) ) { out [ <NUM_LIT> ] = distanceToCenter ( targetView , getVerticalHelper ( layoutManager ) ) ; } else { out [ <NUM_LIT> ] = <NUM_LIT> ; } return out ; } @ Nullable @ Override @ SuppressLint ( \"<STR_LIT>\" ) public View findSnapView ( RecyclerView . LayoutManager layoutManager ) {", "output": "if ( layoutManager . canScrollVertically ( ) ) { return findCenterView ( layoutManager , getVerticalHelper ( layoutManager ) ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return findCenterView ( layoutManager , getHorizontalHelper ( layoutManager ) ) ; } return null ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public int findTargetSnapPosition ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( itemCount == <NUM_LIT> ) { return RecyclerView . NO_POSITION ; } final OrientationHelper orientationHelper = getOrientationHelper ( layoutManager ) ; if ( orientationHelper == null ) { return RecyclerView . NO_POSITION ; } View closestChildBeforeCenter = null ; int distanceBefore = Integer . MIN_VALUE ; View closestChildAfterCenter = null ; int distanceAfter = Integer . MAX_VALUE ; final int childCount = layoutManager . getChildCount ( ) ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; if ( child == null ) { continue ; } final int distance = distanceToCenter ( child , orientationHelper ) ; if ( distance <= <NUM_LIT> && distance > distanceBefore ) { distanceBefore = distance ; closestChildBeforeCenter = child ; } if ( distance >= <NUM_LIT> && distance < distanceAfter ) { distanceAfter = distance ; closestChildAfterCenter = child ; } } final boolean forwardDirection = isForwardFling ( layoutManager , velocityX , velocityY ) ; if ( forwardDirection && closestChildAfterCenter != null ) { return layoutManager . getPosition ( closestChildAfterCenter ) ; } else if ( ! forwardDirection && closestChildBeforeCenter != null ) { return layoutManager . getPosition ( closestChildBeforeCenter ) ; } View visibleView = forwardDirection ? closestChildBeforeCenter : closestChildAfterCenter ; if ( visibleView == null ) { return RecyclerView . NO_POSITION ; } int visiblePosition = layoutManager . getPosition ( visibleView ) ; int snapToPosition = visiblePosition + ( isReverseLayout ( layoutManager ) == forwardDirection ? - <NUM_LIT> : + <NUM_LIT> ) ; if ( snapToPosition < <NUM_LIT> || snapToPosition >= itemCount ) { return RecyclerView . NO_POSITION ; } return snapToPosition ; } private boolean isForwardFling ( RecyclerView . LayoutManager layoutManager , int velocityX , int velocityY ) { if ( layoutManager . canScrollHorizontally ( ) ) { return velocityX > <NUM_LIT> ; } else { return velocityY > <NUM_LIT> ; } } private boolean isReverseLayout ( RecyclerView . LayoutManager layoutManager ) { final int itemCount = layoutManager . getItemCount ( ) ; if ( ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { RecyclerView . SmoothScroller . ScrollVectorProvider vectorProvider = ( RecyclerView . SmoothScroller . ScrollVectorProvider ) layoutManager ; PointF vectorForEnd = vectorProvider . computeScrollVectorForPosition ( itemCount - <NUM_LIT> ) ; if ( vectorForEnd != null ) { return vectorForEnd . x < <NUM_LIT> || vectorForEnd . y < <NUM_LIT> ; } } return false ; } @ Nullable @ Override protected RecyclerView . SmoothScroller createScroller ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( ! ( layoutManager instanceof RecyclerView . SmoothScroller . ScrollVectorProvider ) ) { return null ; } return new LinearSmoothScroller ( mRecyclerView . getContext ( ) ) { @ Override protected void onTargetFound ( @ NonNull View targetView , @ NonNull RecyclerView . State state , @ NonNull Action action ) { int [ ] snapDistances = calculateDistanceToFinalSnap ( mRecyclerView . getLayoutManager ( ) , targetView ) ; final int dx = snapDistances [ <NUM_LIT> ] ; final int dy = snapDistances [ <NUM_LIT> ] ; final int time = calculateTimeForDeceleration ( Math . max ( Math . abs ( dx ) , Math . abs ( dy ) ) ) ; if ( time > <NUM_LIT> ) { action . update ( dx , dy , time , mDecelerateInterpolator ) ; } } @ Override protected float calculateSpeedPerPixel ( @ NonNull DisplayMetrics displayMetrics ) { return MILLISECONDS_PER_INCH / displayMetrics . densityDpi ; } @ Override protected int calculateTimeForScrolling ( int dx ) { return Math . min ( MAX_SCROLL_ON_FLING_DURATION , super . calculateTimeForScrolling ( dx ) ) ; } } ; } private int distanceToCenter ( @ NonNull View targetView , OrientationHelper helper ) { final int childCenter = helper . getDecoratedStart ( targetView ) + ( helper . getDecoratedMeasurement ( targetView ) / <NUM_LIT> ) ; final int containerCenter = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; return childCenter - containerCenter ; } @ Nullable private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount == <NUM_LIT> ) { return null ; } View closestChild = null ; final int center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / <NUM_LIT> ; int absClosest = Integer . MAX_VALUE ; for ( int i = <NUM_LIT> ; i < childCount ; i ++ ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / <NUM_LIT> ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } @ Nullable private OrientationHelper getOrientationHelper ( RecyclerView . LayoutManager layoutManager ) { if ( layoutManager . canScrollVertically ( ) ) { return getVerticalHelper ( layoutManager ) ; } else if ( layoutManager . canScrollHorizontally ( ) ) { return getHorizontalHelper ( layoutManager ) ; } else { return null ; } } @ NonNull private OrientationHelper getVerticalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mVerticalHelper == null || mVerticalHelper . mLayoutManager != layoutManager ) { mVerticalHelper = OrientationHelper . createVerticalHelper ( layoutManager ) ; } return mVerticalHelper ; } @ NonNull private OrientationHelper getHorizontalHelper ( @ NonNull RecyclerView . LayoutManager layoutManager ) { if ( mHorizontalHelper == null || mHorizontalHelper . mLayoutManager != layoutManager ) { mHorizontalHelper = OrientationHelper . createHorizontalHelper ( layoutManager ) ; } return mHorizontalHelper ; } }"}, {"input": "package com . appspa . update . widget ; import androidx . annotation . NonNull ; import com . appspa . update . service . OnFileDownloadListener ; import java . io . File ; import java . lang . ref . WeakReference ; public class WeakFileDownloadListener implements OnFileDownloadListener { private WeakReference < IDownloadEventHandler > mDownloadHandlerRef ; public WeakFileDownloadListener ( @ NonNull IDownloadEventHandler handler ) { mDownloadHandlerRef = new WeakReference < > ( handler ) ; }", "output": "@ Override public void onStart ( ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleStart ( ) ; } } @ Override public void onProgress ( float progress , long total ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleProgress ( progress ) ; } } @ Override public boolean onCompleted ( File file ) { if ( getEventHandler ( ) != null ) { return getEventHandler ( ) . handleCompleted ( file ) ; } else { return true ; } } @ Override public void onError ( Throwable throwable ) { if ( getEventHandler ( ) != null ) { getEventHandler ( ) . handleError ( throwable ) ; } } private IDownloadEventHandler getEventHandler ( ) { return mDownloadHandlerRef != null ? mDownloadHandlerRef . get ( ) : null ; } }"}, {"input": "package org . woheller69 . weather . weather_api . open_meteo ; import org . woheller69 . weather . weather_api . IApiToDatabaseConversion ; public class OMToDatabaseConversion extends IApiToDatabaseConversion { @ Override public int convertWeatherCategory ( String category ) { int value = Integer . parseInt ( category ) ; if ( value == <NUM_LIT> ) { return WeatherCategories . CLEAR_SKY . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . FEW_CLOUDS . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . SCATTERED_CLOUDS . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . OVERCAST_CLOUDS . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . MIST . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . DRIZZLE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . FREEZING_DRIZZLE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . LIGHT_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) {", "output": "return WeatherCategories . MODERATE_RAIN . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . HEAVY_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_FREEZING_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . FREEZING_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SNOW . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . MODERATE_SNOW . getNumVal ( ) ; } else if ( value >= <NUM_LIT> && value <= <NUM_LIT> ) { return WeatherCategories . HEAVY_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SHOWER_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . SHOWER_RAIN . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . LIGHT_SHOWER_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . SHOWER_SNOW . getNumVal ( ) ; } else if ( value == <NUM_LIT> ) { return WeatherCategories . THUNDERSTORM . getNumVal ( ) ; } else if ( value == <NUM_LIT> || value == <NUM_LIT> ) { return WeatherCategories . THUNDERSTORM_HAIL . getNumVal ( ) ; } return WeatherCategories . ERROR . getNumVal ( ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . view ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . View ; import android . widget . Button ; import android . widget . ProgressBar ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class ProgressBarDialog implements DialogInterface { public static final int DEFAULT_MAX_PROGRESS = <NUM_LIT> ; public final AlertDialog alertDialog ; final ProgressBar progressBar ; ProgressBarDialog ( AlertDialog alertDialog , ProgressBar progressBar ) { this . alertDialog = alertDialog ; this . progressBar = progressBar ; } public void setProgress ( int progress ) { progressBar . setProgress ( progress ) ; } public void setMax ( int max ) { progressBar . setMax ( max ) ; } public void setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; } public void setMessage ( String message ) { alertDialog . setMessage ( message ) ; } public void setTitle ( String title ) { alertDialog . setTitle ( title ) ; } public Button getButton ( int whichButton ) { return alertDialog . getButton ( whichButton ) ; } @ Override public void cancel ( ) { alertDialog . cancel ( ) ; } @ Override public void dismiss ( ) { alertDialog . dismiss ( ) ; } public static class Builder { private final AlertDialog . Builder dialogBuilder ; private final ProgressBar progressBar ; public Builder ( Context context ) { dialogBuilder = new AlertDialog . Builder ( context ) ; View view = View . inflate ( context , R . layout . dialog_wait_progress , null ) ; progressBar = view . findViewById ( R . id . wait_progress_bar ) ; dialogBuilder . setView ( view ) ; progressBar . setMax ( DEFAULT_MAX_PROGRESS ) ; } public Builder setTitle ( String title ) { dialogBuilder . setTitle ( title ) ; return this ; } public Builder setMessage ( String message ) { dialogBuilder . setMessage ( message ) ; return this ; } public Builder setPositiveButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setPositiveButton ( text , listener ) ; return this ; } public Builder setNegativeButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNegativeButton ( text , listener ) ; return this ; } public Builder setNeutralButton ( String text , DialogInterface . OnClickListener listener ) { dialogBuilder . setNeutralButton ( text , listener ) ; return this ; } public Builder setCancelable ( boolean cancelable ) { dialogBuilder . setCancelable ( cancelable ) ; return this ; } public Builder setOnCancelListener ( DialogInterface . OnCancelListener listener ) { dialogBuilder . setOnCancelListener ( listener ) ; return this ;", "output": "} public Builder setOnDismissListener ( DialogInterface . OnDismissListener listener ) { dialogBuilder . setOnDismissListener ( listener ) ; return this ; } public Builder setProgress ( int progress ) { progressBar . setProgress ( progress ) ; return this ; } public Builder setMax ( int max ) { progressBar . setMax ( max ) ; return this ; } public Builder setIndeterminate ( boolean indeterminate ) { progressBar . setIndeterminate ( indeterminate ) ; return this ; } public ProgressBarDialog show ( ) { return new ProgressBarDialog ( dialogBuilder . show ( ) , progressBar ) ; } } }"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . GestureDetector ; import android . view . MotionEvent ; import android . view . View ; public class OnSwipeDownListener implements View . OnTouchListener { private final GestureDetector gestureDetector ; public OnSwipeDownListener ( Context context ) { gestureDetector = new GestureDetector ( context , new GestureListener ( ) ) ; } @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouch ( final View view , final MotionEvent motionEvent ) { return gestureDetector . onTouchEvent ( motionEvent ) ; } private final class GestureListener extends GestureDetector . SimpleOnGestureListener { private static final int SWIPE_THRESHOLD = <NUM_LIT> ; private static final int SWIPE_VELOCITY_THRESHOLD = <NUM_LIT> ; @ Override public boolean onFling ( MotionEvent e1 , MotionEvent e2 , float velocityX , float velocityY ) {", "output": "boolean result = false ; try { float diffY = e2 . getY ( ) - e1 . getY ( ) ; if ( Math . abs ( diffY ) > SWIPE_THRESHOLD && Math . abs ( velocityY ) > SWIPE_VELOCITY_THRESHOLD ) { if ( diffY > <NUM_LIT> ) { onSwipeDown ( ) ; } } } catch ( Exception exception ) { exception . printStackTrace ( ) ; } return result ; } } public void onSwipeDown ( ) { } }"}, {"input": "package com . wmods . wppenhacer ; import android . net . Uri ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . utils . RealPathUtil ; import java . io . File ; public class FilePicker { private static OnFilePickedListener mOnFilePickedListener ; private static AppCompatActivity mActivity ; public static ActivityResultLauncher < String > fileSalve ; private static OnUriPickedListener mOnUriPickedListener ; public static ActivityResultLauncher < String [ ] > fileCapture ; public static ActivityResultLauncher < Uri > directoryCapture ; public static void registerFilePicker ( AppCompatActivity activity ) { mActivity = activity ; fileCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocument ( ) , FilePicker :: setFile ) ; directoryCapture = activity . registerForActivityResult ( new ActivityResultContracts . OpenDocumentTree ( ) , FilePicker :: setDirectory ) ; fileSalve = activity . registerForActivityResult ( new ActivityResultContracts . CreateDocument ( \"<STR_LIT>\" ) , FilePicker :: setFile ) ; } private static void setFile ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFilePath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } private static void setDirectory ( Uri uri ) { if ( uri == null ) return ; if ( mOnFilePickedListener == null ) { mOnUriPickedListener . onUriPicked ( uri ) ; mOnUriPickedListener = null ; } if ( mOnFilePickedListener != null ) { String realPath = null ; try { realPath = RealPathUtil . getRealFolderPath ( mActivity , uri ) ; } catch ( Exception ignored ) { } if ( realPath == null ) return ; mOnFilePickedListener . onFilePicked ( new File ( realPath ) ) ; mOnFilePickedListener = null ; } } public static void setOnFilePickedListener ( OnFilePickedListener onFilePickedListener ) { mOnFilePickedListener = onFilePickedListener ; } public static void setOnUriPickedListener ( OnUriPickedListener onFilePickedListener ) { mOnUriPickedListener = onFilePickedListener ; } public interface OnFilePickedListener { void onFilePicked ( File file ) ; } public interface OnUriPickedListener { void onUriPicked ( Uri uri ) ; }", "output": "}"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . R ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; public class DialogUtils { public static void showTextSelectionDialog ( Context ctx , String text ) { MaterialAlertDialogBuilder selectTextDialogBuilder = new MaterialAlertDialogBuilder ( ctx ) ; View rootView = LayoutInflater . from ( ctx ) . inflate ( R . layout . select_text_dialog , null ) ; selectTextDialogBuilder . setView ( rootView ) ; HtmlTextView htmlTextView = rootView . findViewById ( R . id . select_text_htmltextview ) ;", "output": "htmlTextView . setHtml ( text ) ; htmlTextView . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( ctx , href ) ; return true ; } } ) ; final AlertDialog selectTextDialog = selectTextDialogBuilder . create ( ) ; selectTextDialog . show ( ) ; } }"}, {"input": "package com . cgutman . adblib ; import java . io . Closeable ; import java . io . IOException ; public interface AdbChannel extends Closeable { void readx ( byte [ ] buffer , int length ) throws IOException ; void writex ( AdbMessage message ) throws IOException ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed ; import android . content . Context ; import java . util . Arrays ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . IntentTransferStationHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostCommentHookByGlobal ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . PostPictureHook ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks . ShowInvisibleCommentHook ; public class XposedInit implements IXposedHookLoadPackage { @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam loadPackageParam ) throws Throwable { if ( loadPackageParam . packageName . equals ( \"<STR_LIT>\" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( \"<STR_LIT>\" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHook ( ) ) ; hookStater . startHook ( new ShowInvisibleCommentHook ( ) ) ; hookStater . startHook ( new IntentTransferStationHook ( ) ) ; hookStater . startHook ( new PostPictureHook ( ) ) ; } else if ( loadPackageParam . packageName . equals ( \"<STR_LIT>\" ) ) { ClassLoader classLoader = loadPackageParam . classLoader ; int appVersionCode = systemContext ( ) . getPackageManager ( ) . getPackageInfo ( loadPackageParam . packageName , <NUM_LIT> ) . versionCode ; XposedBridge . log ( \"<STR_LIT>\" + appVersionCode ) ; HookStater hookStater = new HookStater ( appVersionCode , classLoader ) ; hookStater . startHook ( new PostCommentHookByGlobal ( ) ) ; } } public static Context systemContext ( ) { Object obj = null ; Class < ? > findClassIfExists = XposedHelpers . findClass ( \"<STR_LIT>\" , null ) ; if ( findClassIfExists != null ) { obj = XposedHelpers . callStaticMethod ( findClassIfExists , \"<STR_LIT>\" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } return ( Context ) XposedHelpers . callMethod ( obj , \"<STR_LIT>\" , Arrays . copyOf ( new Object [ <NUM_LIT> ] , <NUM_LIT> ) ) ; }", "output": "}"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . METHOD ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { METHOD } ) public @ interface Constructor {", "output": "}"}, {"input": "package org . woheller69 . weather . ui . RecycleList ; import androidx . recyclerview . widget . RecyclerView ; import android . view . View ; import android . widget . TextView ; import org . woheller69 . weather . R ; public class ItemViewHolder extends RecyclerView . ViewHolder { private TextView tvInformation ; public ItemViewHolder ( View itemView ) { super ( itemView ) ;", "output": "tvInformation = ( TextView ) itemView . findViewById ( R . id . city_overview_list_item_text ) ; } public TextView getTvInformation ( ) { return tvInformation ; } }"}, {"input": "package xposed . dummy ; import android . content . res . Resources ; public class XResourcesSuperClass extends Resources { protected XResourcesSuperClass ( ) { super ( null , null , null ) ;", "output": "throw new UnsupportedOperationException ( ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . util . SparseArray ; import android . util . SparseIntArray ; import androidx . annotation . NonNull ; import java . util . ArrayList ; import java . util . List ; interface ViewTypeStorage { @ NonNull NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) ; @ NonNull ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) ; interface ViewTypeLookup { int localToGlobal ( int localType ) ; int globalToLocal ( int globalType ) ; void dispose ( ) ; } class SharedIdRangeViewTypeStorage implements ViewTypeStorage { SparseArray < List < NestedAdapterWrapper > > mGlobalTypeToWrapper = new SparseArray < > ( ) ; @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { List < NestedAdapterWrapper > nestedAdapterWrappers = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( nestedAdapterWrappers == null || nestedAdapterWrappers . isEmpty ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return nestedAdapterWrappers . get ( <NUM_LIT> ) ; } @ NonNull @ Override public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . valueAt ( i ) ; if ( wrappers . remove ( wrapper ) ) { if ( wrappers . isEmpty ( ) ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } } class WrapperViewTypeLookup implements ViewTypeLookup { final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { List < NestedAdapterWrapper > wrappers = mGlobalTypeToWrapper . get ( localType ) ; if ( wrappers == null ) { wrappers = new ArrayList < > ( ) ; mGlobalTypeToWrapper . put ( localType , wrappers ) ; } if ( ! wrappers . contains ( mWrapper ) ) { wrappers . add ( mWrapper ) ; } return localType ; } @ Override public int globalToLocal ( int globalType ) { return globalType ; } @ Override public void dispose ( ) { removeWrapper ( mWrapper ) ; } } } class IsolatedViewTypeStorage implements ViewTypeStorage { SparseArray < NestedAdapterWrapper > mGlobalTypeToWrapper = new SparseArray < > ( ) ; int mNextViewType = <NUM_LIT> ; int obtainViewType ( NestedAdapterWrapper wrapper ) { int nextId = mNextViewType ++ ; mGlobalTypeToWrapper . put ( nextId , wrapper ) ; return nextId ; } @ NonNull @ Override public NestedAdapterWrapper getWrapperForGlobalType ( int globalViewType ) { NestedAdapterWrapper wrapper = mGlobalTypeToWrapper . get ( globalViewType ) ; if ( wrapper == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + globalViewType ) ; } return wrapper ; } @ Override @ NonNull public ViewTypeLookup createViewTypeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { return new WrapperViewTypeLookup ( wrapper ) ; } void removeWrapper ( @ NonNull NestedAdapterWrapper wrapper ) { for ( int i = mGlobalTypeToWrapper . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { NestedAdapterWrapper existingWrapper = mGlobalTypeToWrapper . valueAt ( i ) ; if ( existingWrapper == wrapper ) { mGlobalTypeToWrapper . removeAt ( i ) ; } } } class WrapperViewTypeLookup implements ViewTypeLookup { private SparseIntArray mLocalToGlobalMapping = new SparseIntArray ( <NUM_LIT> ) ; private SparseIntArray mGlobalToLocalMapping = new SparseIntArray ( <NUM_LIT> ) ; final NestedAdapterWrapper mWrapper ; WrapperViewTypeLookup ( NestedAdapterWrapper wrapper ) { mWrapper = wrapper ; } @ Override public int localToGlobal ( int localType ) { int index = mLocalToGlobalMapping . indexOfKey ( localType ) ; if ( index > - <NUM_LIT> ) { return mLocalToGlobalMapping . valueAt ( index ) ; } int globalType = obtainViewType ( mWrapper ) ; mLocalToGlobalMapping . put ( localType , globalType ) ; mGlobalToLocalMapping . put ( globalType , localType ) ; return globalType ; } @ Override public int globalToLocal ( int globalType ) { int index = mGlobalToLocalMapping . indexOfKey ( globalType ) ; if ( index < <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" + globalType + \"<STR_LIT>\" + \"<STR_LIT>\" + mWrapper . adapter ) ; } return mGlobalToLocalMapping . valueAt ( index ) ; } @ Override public void dispose ( ) {", "output": "removeWrapper ( mWrapper ) ; } } } }"}, {"input": "package external . org . apache . commons . lang3 . mutable ; public interface Mutable < T > { T getValue ( ) ;", "output": "void setValue ( T value ) ; }"}, {"input": "package com . norman . webviewup . lib . util ; import android . text . TextUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class ApksUtils { public static void extractNativeLibrary ( String apkPath , String libsDir ) { ZipFile zipFile = null ; try { if ( TextUtils . isEmpty ( apkPath ) ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } if ( TextUtils . isEmpty ( libsDir ) ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } zipFile = new ZipFile ( new File ( apkPath ) ) ; Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ;", "output": "List < ZipEntry > libsEntryList = new ArrayList < > ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . contains ( \"<STR_LIT>\" ) || entry . isDirectory ( ) ) { continue ; } if ( ! entryName . startsWith ( \"<STR_LIT>\" ) && ! entryName . endsWith ( \"<STR_LIT>\" ) ) { continue ; } libsEntryList . add ( entry ) ; } for ( ZipEntry zipEntry : libsEntryList ) { String [ ] split = zipEntry . getName ( ) . split ( \"<STR_LIT>\" ) ; File targetFile = new File ( libsDir , split [ <NUM_LIT> ] + \"<STR_LIT>\" + split [ split . length - <NUM_LIT> ] ) ; FileUtils . copyFile ( zipFile . getInputStream ( zipEntry ) , targetFile , true ) ; } } catch ( IOException ioException ) { FileUtils . cleanDirectory ( libsDir ) ; throw new RuntimeException ( ioException ) ; } finally { if ( zipFile != null ) { try { zipFile . close ( ) ; } catch ( IOException ignore ) { } } } } }"}, {"input": "package com . appspa . demo . http ; import androidx . annotation . NonNull ; import com . appspa . update . proxy . IUpdateHttpService ; import com . zhy . http . okhttp . OkHttpUtils ; import com . zhy . http . okhttp . callback . FileCallBack ; import com . zhy . http . okhttp . callback . StringCallback ; import com . zhy . http . okhttp . request . RequestCall ; import java . io . File ; import java . util . Map ; import java . util . TreeMap ; import okhttp3 . Call ; import okhttp3 . Request ; public class OKHttpUpdateHttpService implements IUpdateHttpService { private boolean mIsPostJson ; public OKHttpUpdateHttpService ( ) { this ( false ) ; } public OKHttpUpdateHttpService ( boolean isPostJson ) { mIsPostJson = isPostJson ; }", "output": "@ Override public void asyncGet ( @ NonNull String url , @ NonNull Map < String , Object > params , final @ NonNull Callback callBack ) { OkHttpUtils . get ( ) . params ( transform ( params ) ) . build ( ) . execute ( new StringCallback ( ) { @ Override public void onError ( Call call , Exception e , int id ) { callBack . onError ( e ) ; } @ Override public void onResponse ( String response , int id ) { callBack . onSuccess ( response ) ; } } ) ; } @ Override public void asyncPost ( @ NonNull String url , @ NonNull Map < String , Object > params , final @ NonNull Callback callBack ) { } @ Override public void download ( @ NonNull String url , @ NonNull String path , @ NonNull String fileName , final @ NonNull DownloadCallback callback ) { OkHttpUtils . get ( ) . url ( url ) . tag ( url ) . build ( ) . execute ( new FileCallBack ( path , fileName ) { @ Override public void inProgress ( float progress , long total , int id ) { callback . onProgress ( progress , total ) ; } @ Override public void onError ( Call call , Exception e , int id ) { callback . onError ( e ) ; } @ Override public void onResponse ( File response , int id ) { callback . onSuccess ( response ) ; } @ Override public void onBefore ( Request request , int id ) { super . onBefore ( request , id ) ; callback . onStart ( ) ; } } ) ; } @ Override public void cancelDownload ( @ NonNull String url ) { OkHttpUtils . getInstance ( ) . cancelTag ( url ) ; } private Map < String , String > transform ( Map < String , Object > params ) { Map < String , String > map = new TreeMap < > ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) . toString ( ) ) ; } return map ; } }"}, {"input": "package com . simon . harmonichackernews . adapters ; import android . graphics . drawable . RippleDrawable ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Comment ; import com . simon . harmonichackernews . utils . ThemeUtils ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class CommentSearchAdapter extends RecyclerView . Adapter < RecyclerView . ViewHolder > { public static final int TYPE_COMMENT = <NUM_LIT> ; public static final int TYPE_COLLAPSED = <NUM_LIT> ; private final List < Comment > comments ; private String searchTerm ; public ItemClickListener itemClickListener ; private String markedColor ; public CommentSearchAdapter ( List < Comment > comments ) { this . comments = comments ; } public void setSearchTerm ( String searchTerm ) { this . searchTerm = searchTerm ; } public void setItemClickListener ( ItemClickListener clickListener ) { itemClickListener = clickListener ; } public class CommentViewHolder extends RecyclerView . ViewHolder { public HtmlTextView commentText ; public TextView commentBy ; public LinearLayout container ; public CommentViewHolder ( View view ) { super ( view ) ; commentText = view . findViewById ( R . id . comment_search_item_text ) ; commentBy = view . findViewById ( R . id . comment_search_item_by ) ; container = view . findViewById ( R . id . comment_search_item_container ) ; container . setOnClickListener ( ( v ) -> { itemClickListener . onItemClick ( comments . get ( getAbsoluteAdapterPosition ( ) ) ) ; } ) ;", "output": "markedColor = ThemeUtils . isDarkMode ( view . getContext ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; final RippleDrawable rippleDrawable = ( RippleDrawable ) container . getBackground ( ) ; commentText . setOnTouchListener ( new View . OnTouchListener ( ) { @ Override public boolean onTouch ( View v , MotionEvent event ) { switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : rippleDrawable . setHotspot ( event . getX ( ) , event . getY ( ) ) ; container . setPressed ( true ) ; return true ; case MotionEvent . ACTION_UP : container . performClick ( ) ; container . setPressed ( false ) ; return true ; case MotionEvent . ACTION_CANCEL : container . setPressed ( false ) ; return true ; } return false ; } } ) ; } } @ NonNull @ Override public RecyclerView . ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { if ( viewType == TYPE_COMMENT ) { View v = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . comments_search_item , parent , false ) ; return new CommentViewHolder ( v ) ; } else { return new RecyclerView . ViewHolder ( new View ( parent . getContext ( ) ) ) { } ; } } @ Override public void onBindViewHolder ( @ NonNull RecyclerView . ViewHolder holder , int position ) { if ( ! ( holder instanceof CommentSearchAdapter . CommentViewHolder ) ) { return ; } final CommentViewHolder commentViewHolder = ( CommentViewHolder ) holder ; Comment comment = comments . get ( position ) ; String text = comment . text ; StringBuffer sb = new StringBuffer ( ) ; if ( ! TextUtils . isEmpty ( searchTerm ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" + Pattern . quote ( searchTerm ) ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { String replacement = \"<STR_LIT>\" + markedColor + \"<STR_LIT>\" + matcher . group ( ) + \"<STR_LIT>\" ; matcher . appendReplacement ( sb , Matcher . quoteReplacement ( replacement ) ) ; } matcher . appendTail ( sb ) ; text = sb . toString ( ) ; } commentViewHolder . commentText . setHtml ( text ) ; commentViewHolder . commentBy . setText ( comment . by ) ; } @ Override public int getItemViewType ( int position ) { return TextUtils . isEmpty ( searchTerm ) || comments . get ( position ) . text . toUpperCase ( ) . contains ( searchTerm . toUpperCase ( ) ) ? TYPE_COMMENT : TYPE_COLLAPSED ; } @ Override public int getItemCount ( ) { return comments . size ( ) ; } public interface ItemClickListener { void onItemClick ( Comment comment ) ; } }"}, {"input": "package com . gw . swipeback ; import android . app . Activity ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Color ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . FloatRange ; import androidx . annotation . IntDef ; import androidx . annotation . IntRange ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . MotionEventCompat ; import androidx . core . view . ViewCompat ; import androidx . customview . widget . ViewDragHelper ; import com . gw . swipeback . tools . Util ; import com . simon . harmonichackernews . R ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; public class SwipeBackLayout extends ViewGroup { private static final String TAG = \"<STR_LIT>\" ; public static final int FROM_LEFT = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_RIGHT = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_TOP = <NUM_LIT> << <NUM_LIT> ; public static final int FROM_BOTTOM = <NUM_LIT> << <NUM_LIT> ; @ IntDef ( { FROM_LEFT , FROM_TOP , FROM_RIGHT , FROM_BOTTOM } ) @ Retention ( RetentionPolicy . SOURCE ) public @ interface DirectionMode { } private int mDirectionMode = FROM_LEFT ; private final ViewDragHelper mDragHelper ; private View mDragContentView ; private View innerScrollView ; private int width , height ; private int mTouchSlop ; private float swipeBackFactor = <NUM_LIT> ; private float swipeBackFraction ; private int maskAlpha = <NUM_LIT> ; private boolean isSwipeFromEdge = false ; private float downX , downY ; private boolean active = true ; private int leftOffset = <NUM_LIT> ; private int topOffset = <NUM_LIT> ; private float autoFinishedVelocityLimit = <NUM_LIT> ; private int touchedEdge = ViewDragHelper . INVALID_POINTER ; public SwipeBackLayout ( @ NonNull Context context ) { this ( context , null ) ; } public SwipeBackLayout ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public SwipeBackLayout ( @ NonNull Context context , @ Nullable AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; setWillNotDraw ( false ) ; mDragHelper = ViewDragHelper . create ( this , <NUM_LIT> , new DragHelperCallback ( ) ) ; mDragHelper . setEdgeTrackingEnabled ( mDirectionMode ) ; mTouchSlop = mDragHelper . getTouchSlop ( ) ; setSwipeBackListener ( defaultSwipeBackListener ) ; init ( context , attrs ) ; } private void init ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . SwipeBackLayout ) ; setDirectionMode ( a . getInt ( R . styleable . SwipeBackLayout_directionMode , mDirectionMode ) ) ; setSwipeBackFactor ( a . getFloat ( R . styleable . SwipeBackLayout_swipeBackFactor , swipeBackFactor ) ) ; setMaskAlpha ( a . getInteger ( R . styleable . SwipeBackLayout_maskAlpha , maskAlpha ) ) ; isSwipeFromEdge = a . getBoolean ( R . styleable . SwipeBackLayout_isSwipeFromEdge , isSwipeFromEdge ) ; a . recycle ( ) ; } public void attachToActivity ( Activity activity ) { ViewGroup decorView = ( ViewGroup ) activity . getWindow ( ) . getDecorView ( ) ; ViewGroup decorChild = ( ViewGroup ) decorView . getChildAt ( <NUM_LIT> ) ; decorChild . setBackgroundColor ( Color . TRANSPARENT ) ; decorView . removeView ( decorChild ) ; addView ( decorChild ) ; decorView . addView ( this ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; int childCount = getChildCount ( ) ; if ( childCount > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } int defaultMeasuredWidth = <NUM_LIT> ; int defaultMeasuredHeight = <NUM_LIT> ; int measuredWidth ; int measuredHeight ; if ( childCount > <NUM_LIT> ) { measureChildren ( widthMeasureSpec , heightMeasureSpec ) ; mDragContentView = getChildAt ( <NUM_LIT> ) ; defaultMeasuredWidth = mDragContentView . getMeasuredWidth ( ) ; defaultMeasuredHeight = mDragContentView . getMeasuredHeight ( ) ; } measuredWidth = View . resolveSize ( defaultMeasuredWidth , widthMeasureSpec ) + getPaddingLeft ( ) + getPaddingRight ( ) ; measuredHeight = View . resolveSize ( defaultMeasuredHeight , heightMeasureSpec ) + getPaddingTop ( ) + getPaddingBottom ( ) ; setMeasuredDimension ( measuredWidth , measuredHeight ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { if ( getChildCount ( ) == <NUM_LIT> ) return ; int left = getPaddingLeft ( ) + leftOffset ; int top = getPaddingTop ( ) + topOffset ; int right = left + mDragContentView . getMeasuredWidth ( ) ; int bottom = top + mDragContentView . getMeasuredHeight ( ) ; mDragContentView . layout ( left , top , right , bottom ) ; if ( changed ) { width = getWidth ( ) ; height = getHeight ( ) ; } innerScrollView = Util . findAllScrollViews ( this ) ; } @ Override protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; canvas . drawARGB ( maskAlpha - ( int ) ( maskAlpha * swipeBackFraction ) , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( ! active ) { return super . onInterceptTouchEvent ( ev ) ; } switch ( MotionEventCompat . getActionMasked ( ev ) ) { case MotionEvent . ACTION_DOWN : downX = ev . getRawX ( ) ; downY = ev . getRawY ( ) ; break ; case MotionEvent . ACTION_MOVE : if ( innerScrollView != null && Util . contains ( innerScrollView , downX , downY ) ) { float distanceX = Math . abs ( ev . getRawX ( ) - downX ) ; float distanceY = Math . abs ( ev . getRawY ( ) - downY ) ; if ( mDirectionMode == FROM_LEFT || mDirectionMode == FROM_RIGHT ) { if ( distanceY > mTouchSlop && distanceY > distanceX ) { return super . onInterceptTouchEvent ( ev ) ; } } else if ( mDirectionMode == FROM_TOP || mDirectionMode == FROM_BOTTOM ) { if ( distanceX > mTouchSlop && distanceX > distanceY ) { return super . onInterceptTouchEvent ( ev ) ; } } } break ; } boolean handled = mDragHelper . shouldInterceptTouchEvent ( ev ) ; return handled ? handled : super . onInterceptTouchEvent ( ev ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mDragHelper . processTouchEvent ( event ) ; return true ; } @ Override public void computeScroll ( ) { if ( mDragHelper . continueSettling ( true ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } public void smoothScrollToX ( int finalLeft ) { if ( mDragHelper . settleCapturedViewAt ( finalLeft , getPaddingTop ( ) ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } public void smoothScrollToY ( int finalTop ) { if ( mDragHelper . settleCapturedViewAt ( getPaddingLeft ( ) , finalTop ) ) { ViewCompat . postInvalidateOnAnimation ( this ) ; } } private class DragHelperCallback extends ViewDragHelper . Callback { @ Override public boolean tryCaptureView ( View child , int pointerId ) { return child == mDragContentView ; } @ Override public int clampViewPositionHorizontal ( View child , int left , int dx ) { leftOffset = getPaddingLeft ( ) ; if ( isSwipeEnabled ( ) ) { if ( mDirectionMode == FROM_LEFT && ! Util . canViewScrollRight ( innerScrollView , downX , downY , false ) ) { leftOffset = Math . min ( Math . max ( left , getPaddingLeft ( ) ) , width ) ; } else if ( mDirectionMode == FROM_RIGHT && ! Util . canViewScrollLeft ( innerScrollView , downX , downY , false ) ) { leftOffset = Math . min ( Math . max ( left , - width ) , getPaddingRight ( ) ) ;", "output": "} } return leftOffset ; } @ Override public int clampViewPositionVertical ( View child , int top , int dy ) { topOffset = getPaddingTop ( ) ; if ( isSwipeEnabled ( ) ) { if ( mDirectionMode == FROM_TOP && ! Util . canViewScrollUp ( innerScrollView , downX , downY , false ) ) { topOffset = Math . min ( Math . max ( top , getPaddingTop ( ) ) , height ) ; } else if ( mDirectionMode == FROM_BOTTOM && ! Util . canViewScrollDown ( innerScrollView , downX , downY , false ) ) { topOffset = Math . min ( Math . max ( top , - height ) , getPaddingBottom ( ) ) ; } } return topOffset ; } @ Override public void onViewPositionChanged ( View changedView , int left , int top , int dx , int dy ) { super . onViewPositionChanged ( changedView , left , top , dx , dy ) ; left = Math . abs ( left ) ; top = Math . abs ( top ) ; switch ( mDirectionMode ) { case FROM_LEFT : case FROM_RIGHT : swipeBackFraction = <NUM_LIT> * left / width ; break ; case FROM_TOP : case FROM_BOTTOM : swipeBackFraction = <NUM_LIT> * top / height ; break ; } if ( mSwipeBackListener != null ) { mSwipeBackListener . onViewPositionChanged ( mDragContentView , swipeBackFraction , swipeBackFactor ) ; } } @ Override public void onViewReleased ( View releasedChild , float xvel , float yvel ) { super . onViewReleased ( releasedChild , xvel , yvel ) ; leftOffset = topOffset = <NUM_LIT> ; if ( ! isSwipeEnabled ( ) ) { touchedEdge = ViewDragHelper . INVALID_POINTER ; return ; } touchedEdge = ViewDragHelper . INVALID_POINTER ; boolean isBackToEnd = backJudgeBySpeed ( xvel , yvel ) || swipeBackFraction >= swipeBackFactor ; if ( isBackToEnd ) { switch ( mDirectionMode ) { case FROM_LEFT : smoothScrollToX ( width ) ; break ; case FROM_TOP : smoothScrollToY ( height ) ; break ; case FROM_RIGHT : smoothScrollToX ( - width ) ; break ; case FROM_BOTTOM : smoothScrollToY ( - height ) ; break ; } } else { switch ( mDirectionMode ) { case FROM_LEFT : case FROM_RIGHT : smoothScrollToX ( getPaddingLeft ( ) ) ; break ; case FROM_BOTTOM : case FROM_TOP : smoothScrollToY ( getPaddingTop ( ) ) ; break ; } } } @ Override public void onViewDragStateChanged ( int state ) { super . onViewDragStateChanged ( state ) ; if ( state == ViewDragHelper . STATE_IDLE ) { if ( mSwipeBackListener != null ) { if ( swipeBackFraction == <NUM_LIT> ) { mSwipeBackListener . onViewSwipeFinished ( mDragContentView , false ) ; } else if ( swipeBackFraction == <NUM_LIT> ) { mSwipeBackListener . onViewSwipeFinished ( mDragContentView , true ) ; } } } } @ Override public int getViewHorizontalDragRange ( View child ) { return width ; } @ Override public int getViewVerticalDragRange ( View child ) { return height ; } @ Override public void onEdgeTouched ( int edgeFlags , int pointerId ) { super . onEdgeTouched ( edgeFlags , pointerId ) ; touchedEdge = edgeFlags ; } } public void finish ( ) { ( ( Activity ) getContext ( ) ) . finish ( ) ; } private boolean isSwipeEnabled ( ) { if ( isSwipeFromEdge ) { switch ( mDirectionMode ) { case FROM_LEFT : return touchedEdge == ViewDragHelper . EDGE_LEFT ; case FROM_TOP : return touchedEdge == ViewDragHelper . EDGE_TOP ; case FROM_RIGHT : return touchedEdge == ViewDragHelper . EDGE_RIGHT ; case FROM_BOTTOM : return touchedEdge == ViewDragHelper . EDGE_BOTTOM ; } } return true ; } private boolean backJudgeBySpeed ( float xvel , float yvel ) { switch ( mDirectionMode ) { case FROM_LEFT : return xvel > autoFinishedVelocityLimit ; case FROM_TOP : return yvel > autoFinishedVelocityLimit ; case FROM_RIGHT : return xvel < - autoFinishedVelocityLimit ; case FROM_BOTTOM : return yvel < - autoFinishedVelocityLimit ; } return false ; } public void setSwipeBackFactor ( @ FloatRange ( from = <NUM_LIT> , to = <NUM_LIT> ) float swipeBackFactor ) { if ( swipeBackFactor > <NUM_LIT> ) { swipeBackFactor = <NUM_LIT> ; } else if ( swipeBackFactor < <NUM_LIT> ) { swipeBackFactor = <NUM_LIT> ; } this . swipeBackFactor = swipeBackFactor ; } public float getSwipeBackFactor ( ) { return swipeBackFactor ; } public void setMaskAlpha ( @ IntRange ( from = <NUM_LIT> , to = <NUM_LIT> ) int maskAlpha ) { if ( maskAlpha > <NUM_LIT> ) { maskAlpha = <NUM_LIT> ; } else if ( maskAlpha < <NUM_LIT> ) { maskAlpha = <NUM_LIT> ; } this . maskAlpha = maskAlpha ; } public int getMaskAlpha ( ) { return maskAlpha ; } public void setDirectionMode ( @ DirectionMode int direction ) { mDirectionMode = direction ; mDragHelper . setEdgeTrackingEnabled ( direction ) ; } public void setActive ( boolean a ) { active = a ; } public int getDirectionMode ( ) { return mDirectionMode ; } public float getAutoFinishedVelocityLimit ( ) { return autoFinishedVelocityLimit ; } public void setAutoFinishedVelocityLimit ( float autoFinishedVelocityLimit ) { this . autoFinishedVelocityLimit = autoFinishedVelocityLimit ; } public boolean isSwipeFromEdge ( ) { return isSwipeFromEdge ; } public void setSwipeFromEdge ( boolean isSwipeFromEdge ) { this . isSwipeFromEdge = isSwipeFromEdge ; } private OnSwipeBackListener mSwipeBackListener ; private OnSwipeBackListener defaultSwipeBackListener = new OnSwipeBackListener ( ) { @ Override public void onViewPositionChanged ( View mView , float swipeBackFraction , float swipeBackFactor ) { invalidate ( ) ; } @ Override public void onViewSwipeFinished ( View mView , boolean isEnd ) { if ( isEnd ) { finish ( ) ; } } } ; public void setSwipeBackListener ( OnSwipeBackListener mSwipeBackListener ) { this . mSwipeBackListener = mSwipeBackListener ; } public interface OnSwipeBackListener { void onViewPositionChanged ( View mView , float swipeBackFraction , float swipeBackFactor ) ; void onViewSwipeFinished ( View mView , boolean isEnd ) ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . widget . NestedScrollView ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollNestedScrollView extends NestedScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollNestedScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollNestedScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } private void init ( ) { setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ;", "output": "} private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollNestedScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollNestedScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollNestedScrollView . super . onTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected int computeVerticalScrollRange ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollRange ( ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected int computeVerticalScrollOffset ( ) { return FastScrollNestedScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollNestedScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollNestedScrollView . this . scrollTo ( x , y ) ; } } }"}, {"input": "package androidx . fluidviewpager2 . adapter ; import static androidx . core . util . Preconditions . checkArgument ; import static androidx . fluidrecyclerview . widget . RecyclerView . NO_ID ; import static androidx . fluidviewpager2 . adapter . FragmentStateAdapter . FragmentTransactionCallback . OnPostEventListener ; import static androidx . lifecycle . Lifecycle . State . RESUMED ; import static androidx . lifecycle . Lifecycle . State . STARTED ; import android . os . Bundle ; import android . os . Handler ; import android . os . Looper ; import android . os . Parcelable ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import android . widget . FrameLayout ; import androidx . annotation . CallSuper ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . OptIn ; import androidx . annotation . RequiresOptIn ; import androidx . collection . ArraySet ; import androidx . collection . LongSparseArray ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . fragment . app . FragmentManager ; import androidx . fragment . app . FragmentTransaction ; import androidx . lifecycle . Lifecycle ; import androidx . lifecycle . LifecycleEventObserver ; import androidx . lifecycle . LifecycleOwner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; public abstract class FragmentStateAdapter extends RecyclerView . Adapter < FragmentViewHolder > implements StatefulAdapter { private static final String KEY_PREFIX_FRAGMENT = \"<STR_LIT>\" ; private static final String KEY_PREFIX_STATE = \"<STR_LIT>\" ; private static final long GRACE_WINDOW_TIME_MS = <NUM_LIT> ; @ SuppressWarnings ( \"<STR_LIT>\" ) final Lifecycle mLifecycle ; @ SuppressWarnings ( \"<STR_LIT>\" ) final FragmentManager mFragmentManager ; @ SuppressWarnings ( \"<STR_LIT>\" ) final LongSparseArray < Fragment > mFragments = new LongSparseArray < > ( ) ; private final LongSparseArray < Fragment . SavedState > mSavedStates = new LongSparseArray < > ( ) ; private final LongSparseArray < Integer > mItemIdToViewHolder = new LongSparseArray < > ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) FragmentEventDispatcher mFragmentEventDispatcher = new FragmentEventDispatcher ( ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) boolean mIsInGracePeriod = false ; private FragmentMaxLifecycleEnforcer mFragmentMaxLifecycleEnforcer ; private boolean mHasStaleFragments = false ; public FragmentStateAdapter ( @ NonNull FragmentActivity fragmentActivity ) { this ( fragmentActivity . getSupportFragmentManager ( ) , fragmentActivity . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull Fragment fragment ) { this ( fragment . getChildFragmentManager ( ) , fragment . getLifecycle ( ) ) ; } public FragmentStateAdapter ( @ NonNull FragmentManager fragmentManager , @ NonNull Lifecycle lifecycle ) { mFragmentManager = fragmentManager ; mLifecycle = lifecycle ; super . setHasStableIds ( true ) ; } private static @ NonNull String createKey ( @ NonNull String prefix , long id ) { return prefix + id ; } private static boolean isValidKey ( @ NonNull String key , @ NonNull String prefix ) { return key . startsWith ( prefix ) && key . length ( ) > prefix . length ( ) ; } private static long parseIdFromKey ( @ NonNull String key , @ NonNull String prefix ) { return Long . parseLong ( key . substring ( prefix . length ( ) ) ) ; } @ CallSuper @ Override public void onAttachedToRecyclerView ( @ NonNull RecyclerView recyclerView ) { checkArgument ( mFragmentMaxLifecycleEnforcer == null ) ; mFragmentMaxLifecycleEnforcer = new FragmentMaxLifecycleEnforcer ( ) ; mFragmentMaxLifecycleEnforcer . register ( recyclerView ) ; } @ CallSuper @ Override public void onDetachedFromRecyclerView ( @ NonNull RecyclerView recyclerView ) { mFragmentMaxLifecycleEnforcer . unregister ( recyclerView ) ; mFragmentMaxLifecycleEnforcer = null ; } public abstract @ NonNull Fragment createFragment ( int position ) ; @ NonNull @ Override public final FragmentViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return FragmentViewHolder . create ( parent ) ; } @ Override public final void onBindViewHolder ( final @ NonNull FragmentViewHolder holder , int position ) { final long itemId = holder . getItemId ( ) ; final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null && boundItemId != itemId ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } mItemIdToViewHolder . put ( itemId , viewHolderId ) ; ensureFragment ( position ) ; final FrameLayout container = holder . getContainer ( ) ; if ( container . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void gcFragments ( ) { if ( ! mHasStaleFragments || shouldDelayFragmentTransactions ( ) ) { return ; } Set < Long > toRemove = new ArraySet < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! containsItem ( itemId ) ) { toRemove . add ( itemId ) ; mItemIdToViewHolder . remove ( itemId ) ; } } if ( ! mIsInGracePeriod ) { mHasStaleFragments = false ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; if ( ! isFragmentViewBound ( itemId ) ) { toRemove . add ( itemId ) ; } } } for ( Long itemId : toRemove ) { removeFragment ( itemId ) ; } } private boolean isFragmentViewBound ( long itemId ) { if ( mItemIdToViewHolder . containsKey ( itemId ) ) { return true ; } Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return false ; } View view = fragment . getView ( ) ; if ( view == null ) { return false ; } return view . getParent ( ) != null ; } private Long itemForViewHolder ( int viewHolderId ) { Long boundItemId = null ; for ( int ix = <NUM_LIT> ; ix < mItemIdToViewHolder . size ( ) ; ix ++ ) { if ( mItemIdToViewHolder . valueAt ( ix ) == viewHolderId ) { if ( boundItemId != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } boundItemId = mItemIdToViewHolder . keyAt ( ix ) ; } } return boundItemId ; } private void ensureFragment ( int position ) { long itemId = getItemId ( position ) ; if ( ! mFragments . containsKey ( itemId ) ) { Fragment newFragment = createFragment ( position ) ; newFragment . setInitialSavedState ( mSavedStates . get ( itemId ) ) ; mFragments . put ( itemId , newFragment ) ; } } @ Override public final void onViewAttachedToWindow ( @ NonNull final FragmentViewHolder holder ) { placeFragmentInViewHolder ( holder ) ; gcFragments ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void placeFragmentInViewHolder ( @ NonNull final FragmentViewHolder holder ) { Fragment fragment = mFragments . get ( holder . getItemId ( ) ) ; if ( fragment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } FrameLayout container = holder . getContainer ( ) ; View view = fragment . getView ( ) ; if ( ! fragment . isAdded ( ) && view != null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( fragment . isAdded ( ) && view == null ) { scheduleViewAttach ( fragment , container ) ; return ; } if ( fragment . isAdded ( ) && view . getParent ( ) != null ) { if ( view . getParent ( ) != container ) { addViewToContainer ( view , container ) ; } return ; } if ( fragment . isAdded ( ) ) { addViewToContainer ( view , container ) ; return ; } if ( ! shouldDelayFragmentTransactions ( ) ) { scheduleViewAttach ( fragment , container ) ; List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreAdded ( fragment ) ; try { fragment . setMenuVisibility ( false ) ; mFragmentManager . beginTransaction ( ) . add ( fragment , \"<STR_LIT>\" + holder . getItemId ( ) ) . setMaxLifecycle ( fragment , STARTED ) . commitNow ( ) ; mFragmentMaxLifecycleEnforcer . updateFragmentMaxLifecycle ( false ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } else { if ( mFragmentManager . isDestroyed ( ) ) { return ; } mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } source . getLifecycle ( ) . removeObserver ( this ) ; if ( holder . getContainer ( ) . isAttachedToWindow ( ) ) { placeFragmentInViewHolder ( holder ) ; } } } ) ; } } private void scheduleViewAttach ( final Fragment fragment , @ NonNull final FrameLayout container ) { mFragmentManager . registerFragmentLifecycleCallbacks ( new FragmentManager . FragmentLifecycleCallbacks ( ) { @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void onFragmentViewCreated ( @ NonNull FragmentManager fm , @ NonNull Fragment f , @ NonNull View v , @ Nullable Bundle savedInstanceState ) { if ( f == fragment ) { fm . unregisterFragmentLifecycleCallbacks ( this ) ; addViewToContainer ( v , container ) ; } } } , false ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void addViewToContainer ( @ NonNull View v , @ NonNull FrameLayout container ) { if ( container . getChildCount ( ) > <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( v . getParent ( ) == container ) { return ; } if ( container . getChildCount ( ) > <NUM_LIT> ) { container . removeAllViews ( ) ; } if ( v . getParent ( ) != null ) { ( ( ViewGroup ) v . getParent ( ) ) . removeView ( v ) ; } container . addView ( v ) ; } @ Override public final void onViewRecycled ( @ NonNull FragmentViewHolder holder ) { final int viewHolderId = holder . getContainer ( ) . getId ( ) ; final Long boundItemId = itemForViewHolder ( viewHolderId ) ; if ( boundItemId != null ) { removeFragment ( boundItemId ) ; mItemIdToViewHolder . remove ( boundItemId ) ; } } @ Override public final boolean onFailedToRecycleView ( @ NonNull FragmentViewHolder holder ) { return true ; } private void removeFragment ( long itemId ) { Fragment fragment = mFragments . get ( itemId ) ; if ( fragment == null ) { return ; } if ( fragment . getView ( ) != null ) { ViewParent viewParent = fragment . getView ( ) . getParent ( ) ; if ( viewParent != null ) { ( ( FrameLayout ) viewParent ) . removeAllViews ( ) ; } } if ( ! containsItem ( itemId ) ) { mSavedStates . remove ( itemId ) ; } if ( ! fragment . isAdded ( ) ) { mFragments . remove ( itemId ) ; return ; } if ( shouldDelayFragmentTransactions ( ) ) { mHasStaleFragments = true ; return ; } if ( fragment . isAdded ( ) && containsItem ( itemId ) ) { List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreSavedInstanceState ( fragment ) ; Fragment . SavedState savedState = mFragmentManager . saveFragmentInstanceState ( fragment ) ; mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; mSavedStates . put ( itemId , savedState ) ; } List < OnPostEventListener > onPost = mFragmentEventDispatcher . dispatchPreRemoved ( fragment ) ; try { mFragmentManager . beginTransaction ( ) . remove ( fragment ) . commitNow ( ) ; mFragments . remove ( itemId ) ; } finally { mFragmentEventDispatcher . dispatchPostEvents ( onPost ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) boolean shouldDelayFragmentTransactions ( ) { return mFragmentManager . isStateSaved ( ) ; } @ Override public long getItemId ( int position ) { return position ; } public boolean containsItem ( long itemId ) { return itemId >= <NUM_LIT> && itemId < getItemCount ( ) ; } @ Override public final void setHasStableIds ( boolean hasStableIds ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public final @ NonNull Parcelable saveState ( ) { Bundle savedState = new Bundle ( mFragments . size ( ) + mSavedStates . size ( ) ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . get ( itemId ) ; if ( fragment != null && fragment . isAdded ( ) ) { String key = createKey ( KEY_PREFIX_FRAGMENT , itemId ) ; mFragmentManager . putFragment ( savedState , key , fragment ) ; } } for ( int ix = <NUM_LIT> ; ix < mSavedStates . size ( ) ; ix ++ ) { long itemId = mSavedStates . keyAt ( ix ) ; if ( containsItem ( itemId ) ) { String key = createKey ( KEY_PREFIX_STATE , itemId ) ; savedState . putParcelable ( key , mSavedStates . get ( itemId ) ) ; } } return savedState ; } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public final void restoreState ( @ NonNull Parcelable savedState ) { if ( ! mSavedStates . isEmpty ( ) || ! mFragments . isEmpty ( ) ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } Bundle bundle = ( Bundle ) savedState ; if ( bundle . getClassLoader ( ) == null ) { bundle . setClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } for ( String key : bundle . keySet ( ) ) { if ( isValidKey ( key , KEY_PREFIX_FRAGMENT ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_FRAGMENT ) ; Fragment fragment = mFragmentManager . getFragment ( bundle , key ) ; mFragments . put ( itemId , fragment ) ; continue ; } if ( isValidKey ( key , KEY_PREFIX_STATE ) ) { long itemId = parseIdFromKey ( key , KEY_PREFIX_STATE ) ; Fragment . SavedState state = bundle . getParcelable ( key ) ; if ( containsItem ( itemId ) ) { mSavedStates . put ( itemId , state ) ; } continue ; } throw new IllegalArgumentException ( \"<STR_LIT>\" + key ) ; } if ( ! mFragments . isEmpty ( ) ) { mHasStaleFragments = true ; mIsInGracePeriod = true ; gcFragments ( ) ; scheduleGracePeriodEnd ( ) ; } } private void scheduleGracePeriodEnd ( ) { final Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { mIsInGracePeriod = false ; gcFragments ( ) ; } } ; mLifecycle . addObserver ( new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { if ( event == Lifecycle . Event . ON_DESTROY ) { handler . removeCallbacks ( runnable ) ; source . getLifecycle ( ) . removeObserver ( this ) ; } } } ) ; handler . postDelayed ( runnable , GRACE_WINDOW_TIME_MS ) ; } public void registerFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . registerCallback ( callback ) ; } public void unregisterFragmentTransactionCallback ( @ NonNull FragmentTransactionCallback callback ) { mFragmentEventDispatcher . unregisterCallback ( callback ) ; } @ RequiresOptIn ( level = RequiresOptIn . Level . WARNING ) public @ interface ExperimentalFragmentStateAdapterApi { } private abstract static class DataSetChangeObserver extends RecyclerView . AdapterDataObserver { @ Override public abstract void onChanged ( ) ; @ Override public final void onItemRangeChanged ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { onChanged ( ) ; } @ Override public final void onItemRangeInserted ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeRemoved ( int positionStart , int itemCount ) { onChanged ( ) ; } @ Override public final void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { onChanged ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) static class FragmentEventDispatcher { private List < FragmentTransactionCallback > mCallbacks = new CopyOnWriteArrayList < > ( ) ; public void registerCallback ( FragmentTransactionCallback callback ) { mCallbacks . add ( callback ) ; } public void unregisterCallback ( FragmentTransactionCallback callback ) { mCallbacks . remove ( callback ) ; } public List < OnPostEventListener > dispatchMaxLifecyclePreUpdated ( Fragment fragment , Lifecycle . State maxState ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentMaxLifecyclePreUpdated ( fragment , maxState ) ) ; } return result ; } public void dispatchPostEvents ( List < OnPostEventListener > entries ) { for ( OnPostEventListener entry : entries ) { entry . onPost ( ) ; } } public List < OnPostEventListener > dispatchPreAdded ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreAdded ( fragment ) ) ; } return result ; } @ OptIn ( markerClass = ExperimentalFragmentStateAdapterApi . class ) public List < OnPostEventListener > dispatchPreSavedInstanceState ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreSavedInstanceState ( fragment ) ) ; } return result ; } public List < OnPostEventListener > dispatchPreRemoved ( Fragment fragment ) { List < OnPostEventListener > result = new ArrayList < > ( ) ; for ( FragmentTransactionCallback callback : mCallbacks ) { result . add ( callback . onFragmentPreRemoved ( fragment ) ) ; } return result ; } } public abstract static class FragmentTransactionCallback { private static final @ NonNull OnPostEventListener NO_OP = new OnPostEventListener ( ) { @ Override public void onPost ( ) { } } ; @ NonNull public OnPostEventListener onFragmentPreAdded ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull @ ExperimentalFragmentStateAdapterApi public OnPostEventListener onFragmentPreSavedInstanceState ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentPreRemoved ( @ NonNull Fragment fragment ) { return NO_OP ; } @ NonNull public OnPostEventListener onFragmentMaxLifecyclePreUpdated ( @ NonNull Fragment fragment , @ NonNull Lifecycle . State maxLifecycleState ) { return NO_OP ; } public interface OnPostEventListener { void onPost ( ) ; } } class FragmentMaxLifecycleEnforcer { private androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback mPageChangeCallback ; private RecyclerView . AdapterDataObserver mDataObserver ; private LifecycleEventObserver mLifecycleObserver ; private androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private long mPrimaryItemId = NO_ID ; void register ( @ NonNull RecyclerView recyclerView ) { mViewPager = inferViewPager ( recyclerView ) ; mPageChangeCallback = new androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ( ) { @ Override public void onPageScrollStateChanged ( int state ) { updateFragmentMaxLifecycle ( false ) ; } @ Override public void onPageSelected ( int position ) { updateFragmentMaxLifecycle ( false ) ; } } ; mViewPager . registerOnPageChangeCallback ( mPageChangeCallback ) ; mDataObserver = new DataSetChangeObserver ( ) { @ Override public void onChanged ( ) { updateFragmentMaxLifecycle ( true ) ; } } ; registerAdapterDataObserver ( mDataObserver ) ; mLifecycleObserver = new LifecycleEventObserver ( ) { @ Override public void onStateChanged ( @ NonNull LifecycleOwner source , @ NonNull Lifecycle . Event event ) { updateFragmentMaxLifecycle ( false ) ;", "output": "} } ; mLifecycle . addObserver ( mLifecycleObserver ) ; } void unregister ( @ NonNull RecyclerView recyclerView ) { androidx . fluidviewpager2 . widget . ViewPager2 viewPager = inferViewPager ( recyclerView ) ; viewPager . unregisterOnPageChangeCallback ( mPageChangeCallback ) ; unregisterAdapterDataObserver ( mDataObserver ) ; mLifecycle . removeObserver ( mLifecycleObserver ) ; mViewPager = null ; } void updateFragmentMaxLifecycle ( boolean dataSetChanged ) { if ( shouldDelayFragmentTransactions ( ) ) { return ; } if ( mViewPager . getScrollState ( ) != androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ) { return ; } if ( mFragments . isEmpty ( ) || getItemCount ( ) == <NUM_LIT> ) { return ; } final int currentItem = mViewPager . getCurrentItem ( ) ; if ( currentItem >= getItemCount ( ) ) { return ; } long currentItemId = getItemId ( currentItem ) ; if ( currentItemId == mPrimaryItemId && ! dataSetChanged ) { return ; } Fragment currentItemFragment = mFragments . get ( currentItemId ) ; if ( currentItemFragment == null || ! currentItemFragment . isAdded ( ) ) { return ; } mPrimaryItemId = currentItemId ; FragmentTransaction transaction = mFragmentManager . beginTransaction ( ) ; Fragment toResume = null ; List < List < OnPostEventListener > > onPost = new ArrayList < > ( ) ; for ( int ix = <NUM_LIT> ; ix < mFragments . size ( ) ; ix ++ ) { long itemId = mFragments . keyAt ( ix ) ; Fragment fragment = mFragments . valueAt ( ix ) ; if ( ! fragment . isAdded ( ) ) { continue ; } if ( itemId != mPrimaryItemId ) { transaction . setMaxLifecycle ( fragment , STARTED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( fragment , STARTED ) ) ; } else { toResume = fragment ; } fragment . setMenuVisibility ( itemId == mPrimaryItemId ) ; } if ( toResume != null ) { transaction . setMaxLifecycle ( toResume , RESUMED ) ; onPost . add ( mFragmentEventDispatcher . dispatchMaxLifecyclePreUpdated ( toResume , RESUMED ) ) ; } if ( ! transaction . isEmpty ( ) ) { transaction . commitNow ( ) ; Collections . reverse ( onPost ) ; for ( List < OnPostEventListener > event : onPost ) { mFragmentEventDispatcher . dispatchPostEvents ( event ) ; } } } @ NonNull private androidx . fluidviewpager2 . widget . ViewPager2 inferViewPager ( @ NonNull RecyclerView recyclerView ) { ViewParent parent = recyclerView . getParent ( ) ; if ( parent instanceof androidx . fluidviewpager2 . widget . ViewPager2 ) { return ( ViewPager2 ) parent ; } throw new IllegalStateException ( \"<STR_LIT>\" + parent ) ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . docmenthelper ; import android . content . Intent ; import java . io . File ; public class ActivityResultForFile extends ActivityResult { public ActivityResultForFile ( Intent intent , File file ) { super ( intent ) ; this . file = file ; }", "output": "public File file ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . content . Context ; import android . content . SharedPreferences ; public class Config { public static final int SORT_RULER_DATE_DESC = <NUM_LIT> ; public static final int SORT_RULER_DATE_ASC = <NUM_LIT> ; public static final int SORT_RULER_LIKE_DESC = <NUM_LIT> ; public static final int SORT_RULER_REPLY_COUNT_DESC = <NUM_LIT> ; Context context ; public SharedPreferences sp_config ; public Config ( Context context ) { this . context = context ; sp_config = context . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; } public boolean getRecordeHistory ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setRecordeHistory ( boolean recordeHistory ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , recordeHistory ) . apply ( ) ; } public String getCookie ( ) { return sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public void setCookie ( String cookie ) { sp_config . edit ( ) . putString ( \"<STR_LIT>\" , cookie ) . apply ( ) ; } public String getDeputyCookie ( ) { return sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public void setDeputyCookie ( String cookie ) { sp_config . edit ( ) . putString ( \"<STR_LIT>\" , cookie ) . apply ( ) ; } public long getWaitTime ( ) { return sp_config . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; } public void setWaitTime ( long waitTime ) {", "output": "sp_config . edit ( ) . putLong ( \"<STR_LIT>\" , waitTime ) . apply ( ) ; } public long getWaitTimeByDanmakuSend ( ) { return sp_config . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; } public void setWaitTimeByDanmakuSend ( long waitTimeByDanmakuSend ) { sp_config . edit ( ) . putLong ( \"<STR_LIT>\" , waitTimeByDanmakuSend ) . apply ( ) ; } public long getWaitTimeByHasPictures ( ) { return sp_config . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; } public void setWaitTimeByHasPictures ( long waitTimeByHasPictures ) { sp_config . edit ( ) . putLong ( \"<STR_LIT>\" , waitTimeByHasPictures ) . apply ( ) ; } public boolean getEnableRecordeBannedComments ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setEnableRecordeBannedComments ( boolean autoRecorde ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , autoRecorde ) . apply ( ) ; } public boolean getRecordeHistoryIsEnable ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setSortRuler ( int sortRuler ) { sp_config . edit ( ) . putInt ( \"<STR_LIT>\" , sortRuler ) . apply ( ) ; } public int getSortRuler ( ) { return sp_config . getInt ( \"<STR_LIT>\" , SORT_RULER_DATE_DESC ) ; } public void setFilterRulerEnableNormal ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableNormal ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableShadowBan ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableShadowBan ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableDeleted ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableDelete ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableOther ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableOther ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public boolean getFilterRulerEnableType1 ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableType1 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType12 ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableType12 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public void setFilterRulerEnableType11 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType11 ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void setFilterRulerEnableType17 ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } public boolean getFilterRulerEnableType17 ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public boolean get\u82b1\u91cc\u80e1\u54e8Enable ( ) { return sp_config . getBoolean ( \"<STR_LIT>\" , true ) ; } public void set\u82b1\u91cc\u80e1\u54e8Enable ( boolean enable ) { sp_config . edit ( ) . putBoolean ( \"<STR_LIT>\" , enable ) . apply ( ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . db ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . util . Log ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . MartialLawCommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . SensitiveScanResult ; public class StatisticsDBOpenHelper extends SQLiteOpenHelper { public static final int VERSION = <NUM_LIT> ; public static final String ORDER_BY_DATE_DESC = \"<STR_LIT>\" ; public static final String ORDER_BY_DATE_ASC = \"<STR_LIT>\" ; public static final String ORDER_BY_LIKE_DESC = \"<STR_LIT>\" ; public static final String ORDER_BY_REPLY_COUNT_DESC = \"<STR_LIT>\" ; public static final String DB_NAME = \"<STR_LIT>\" ; public static final String TABLE_NAME_MARTIAL_LAW_AREA = \"<STR_LIT>\" ; public static final String TABLE_NAME_HISTORY_COMMENT = \"<STR_LIT>\" ; long count = <NUM_LIT> ; public StatisticsDBOpenHelper ( Context context ) {", "output": "super ( context , DB_NAME , null , VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( \"<STR_LIT>\" + TABLE_NAME_MARTIAL_LAW_AREA + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { switch ( oldVersion ) { case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; db . execSQL ( \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; case <NUM_LIT> : db . execSQL ( \"<STR_LIT>\" ) ; } } public long insertMartialLawCommentArea ( MartialLawCommentArea area ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , area . oid ) ; values . put ( \"<STR_LIT>\" , area . sourceId ) ; values . put ( \"<STR_LIT>\" , area . type ) ; values . put ( \"<STR_LIT>\" , area . defaultDisposalMethod ) ; values . put ( \"<STR_LIT>\" , area . title ) ; values . put ( \"<STR_LIT>\" , area . up ) ; values . put ( \"<STR_LIT>\" , area . coverImageData ) ; return db . insert ( TABLE_NAME_MARTIAL_LAW_AREA , null , values ) ; } public long deleteMartialLawCommentArea ( long oid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_MARTIAL_LAW_AREA , \"<STR_LIT>\" , new String [ ] { String . valueOf ( oid ) } ) ; } public ArrayList < MartialLawCommentArea > queryMartialLawCommentAreas ( ) { ArrayList < MartialLawCommentArea > martialLawCommentAreaArrayList = new ArrayList < > ( ) ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( \"<STR_LIT>\" + TABLE_NAME_MARTIAL_LAW_AREA , null ) ; while ( cursor . moveToNext ( ) ) { martialLawCommentAreaArrayList . add ( new MartialLawCommentArea ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getInt ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) , null ) ) ; } cursor . close ( ) ; return martialLawCommentAreaArrayList ; } public byte [ ] selectMartialLawCommentAreaCoverImage ( long oid ) { byte [ ] imageData = null ; SQLiteDatabase db = getReadableDatabase ( ) ; Cursor cursor = db . rawQuery ( \"<STR_LIT>\" + TABLE_NAME_MARTIAL_LAW_AREA + \"<STR_LIT>\" , new String [ ] { String . valueOf ( oid ) } ) ; if ( cursor . moveToNext ( ) ) { imageData = cursor . getBlob ( <NUM_LIT> ) ; } cursor . close ( ) ; return imageData ; } public int updateCheckedArea ( long rpid , int areaChecked ) { SQLiteDatabase db = getReadableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , areaChecked ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , values , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public List < HistoryComment > getDemoHistoryComments ( ) { List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; CommentArea commentArea = new CommentArea ( <NUM_LIT> , \"<STR_LIT>\" , CommentArea . AREA_TYPE_VIDEO ) ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , \"<STR_LIT>\" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , \"<STR_LIT>\" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , null , null ) ) ; count ++ ; historyCommentList . add ( new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , \"<STR_LIT>\" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , HistoryComment . STATE_NORMAL , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , HistoryComment . STATE_NORMAL , \"<STR_LIT>\" , null ) ) ; count ++ ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SHADOW_BAN ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_DELETED ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SENSITIVE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_INVISIBLE ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNDER_REVIEW ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_SUSPECTED_NO_PROBLEM ) ) ; historyCommentList . add ( newDemoComment ( HistoryComment . STATE_UNKNOWN ) ) ; return historyCommentList ; } private HistoryComment newDemoComment ( String state ) { CommentArea commentArea = new CommentArea ( <NUM_LIT> , \"<STR_LIT>\" , CommentArea . AREA_TYPE_VIDEO ) ; HistoryComment historyComment = new HistoryComment ( commentArea , count , <NUM_LIT> , <NUM_LIT> , \"<STR_LIT>\" , new Date ( count ) , <NUM_LIT> , <NUM_LIT> , state , new Date ( count ) , HistoryComment . CHECKED_NO_CHECK , state , null , null ) ; count ++ ; return historyComment ; } public List < HistoryComment > queryAllHistoryComments ( String dateOrderBy ) { return selectHistoryComments ( \"<STR_LIT>\" + dateOrderBy ) ; } public List < HistoryComment > queryHistoryCommentsByDateGT ( long timestamp ) { return selectHistoryComments ( \"<STR_LIT>\" + timestamp + \"<STR_LIT>\" ) ; } public List < HistoryComment > queryHistoryCommentsCountLimit ( int limit ) { return selectHistoryComments ( \"<STR_LIT>\" + limit ) ; } private List < HistoryComment > selectHistoryComments ( String selectAddition ) { SQLiteDatabase db = getReadableDatabase ( ) ; List < HistoryComment > historyCommentList = new ArrayList < > ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( \"<STR_LIT>\" + TABLE_NAME_HISTORY_COMMENT + \"<STR_LIT>\" + selectAddition , null ) ) ; while ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , cursor . getInt ( \"<STR_LIT>\" ) ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , new Date ( cursor . getLong ( \"<STR_LIT>\" ) ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , new Date ( cursor . getLong ( \"<STR_LIT>\" ) ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , JSON . parseObject ( cursor . getString ( \"<STR_LIT>\" ) , SensitiveScanResult . class ) ) ; historyCommentList . add ( historyComment ) ; } cursor . close ( ) ; return historyCommentList ; } public long insertHistoryComment ( HistoryComment historyComment ) { deletePendingCheckComment ( historyComment . rpid ) ; SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , historyComment . rpid ) ; cv . put ( \"<STR_LIT>\" , historyComment . parent ) ; cv . put ( \"<STR_LIT>\" , historyComment . root ) ; cv . put ( \"<STR_LIT>\" , historyComment . commentArea . oid ) ; cv . put ( \"<STR_LIT>\" , historyComment . commentArea . type ) ; cv . put ( \"<STR_LIT>\" , historyComment . commentArea . sourceId ) ; cv . put ( \"<STR_LIT>\" , historyComment . comment ) ; cv . put ( \"<STR_LIT>\" , historyComment . like ) ; cv . put ( \"<STR_LIT>\" , historyComment . replyCount ) ; cv . put ( \"<STR_LIT>\" , historyComment . lastState ) ; cv . put ( \"<STR_LIT>\" , historyComment . lastCheckDate . getTime ( ) ) ; cv . put ( \"<STR_LIT>\" , historyComment . date . getTime ( ) ) ; cv . put ( \"<STR_LIT>\" , historyComment . checkedArea ) ; cv . put ( \"<STR_LIT>\" , historyComment . firstState ) ; cv . put ( \"<STR_LIT>\" , historyComment . pictures ) ; if ( historyComment . sensitiveScanResult != null ) { cv . put ( \"<STR_LIT>\" , JSON . toJSONString ( historyComment . sensitiveScanResult ) ) ; } return db . insert ( TABLE_NAME_HISTORY_COMMENT , null , cv ) ; } public int updateHistoryCommentLastState ( long rpid , String state ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , state ) ; cv . put ( \"<STR_LIT>\" , System . currentTimeMillis ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int updateHistoryCommentStates ( long rpid , String state , int like , int replyCount , Date last_check_date ) { SQLiteDatabase db = getWritableDatabase ( ) ; ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , state ) ; cv . put ( \"<STR_LIT>\" , like ) ; cv . put ( \"<STR_LIT>\" , replyCount ) ; cv . put ( \"<STR_LIT>\" , last_check_date . getTime ( ) ) ; return db . update ( TABLE_NAME_HISTORY_COMMENT , cv , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public int deleteHistoryComment ( long rpid ) { SQLiteDatabase db = getWritableDatabase ( ) ; return db . delete ( TABLE_NAME_HISTORY_COMMENT , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public HistoryComment getHistoryComment ( long rpid ) { SQLiteDatabase db = getReadableDatabase ( ) ; GreatCursor cursor = new GreatCursor ( db . rawQuery ( \"<STR_LIT>\" + TABLE_NAME_HISTORY_COMMENT + \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ) ; if ( cursor . moveToNext ( ) ) { HistoryComment historyComment = new HistoryComment ( new CommentArea ( cursor . getLong ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , cursor . getInt ( \"<STR_LIT>\" ) ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getLong ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , new Date ( cursor . getLong ( \"<STR_LIT>\" ) ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , new Date ( cursor . getLong ( \"<STR_LIT>\" ) ) , cursor . getInt ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , cursor . getString ( \"<STR_LIT>\" ) , JSON . parseObject ( cursor . getString ( \"<STR_LIT>\" ) , SensitiveScanResult . class ) ) ; cursor . close ( ) ; return historyComment ; } else { cursor . close ( ) ; return null ; } } public void insertPendingCheckComment ( Comment comment ) { ContentValues values = new ContentValues ( ) ; values . put ( \"<STR_LIT>\" , comment . rpid ) ; values . put ( \"<STR_LIT>\" , comment . parent ) ; values . put ( \"<STR_LIT>\" , comment . root ) ; values . put ( \"<STR_LIT>\" , comment . comment ) ; values . put ( \"<STR_LIT>\" , comment . pictures ) ; values . put ( \"<STR_LIT>\" , comment . date . getTime ( ) ) ; values . put ( \"<STR_LIT>\" , comment . commentArea . oid ) ; values . put ( \"<STR_LIT>\" , comment . commentArea . sourceId ) ; values . put ( \"<STR_LIT>\" , comment . commentArea . type ) ; long newRowId = getWritableDatabase ( ) . insert ( \"<STR_LIT>\" , null , values ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + newRowId ) ; } public List < Comment > getAllPendingCheckComments ( ) { String [ ] projection = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; Cursor cursor = getReadableDatabase ( ) . query ( \"<STR_LIT>\" , projection , null , null , null , null , \"<STR_LIT>\" ) ; List < Comment > commentList = new ArrayList < > ( ) ; while ( cursor . moveToNext ( ) ) { long rpid = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; Comment comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; commentList . add ( comment ) ; } cursor . close ( ) ; return commentList ; } public Comment getPendingCheckCommentByRpid ( long rpid ) { String [ ] projection = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String selection = \"<STR_LIT>\" ; String [ ] selectionArgs = { String . valueOf ( rpid ) } ; Cursor cursor = getReadableDatabase ( ) . query ( \"<STR_LIT>\" , projection , selection , selectionArgs , null , null , null ) ; Comment comment = null ; if ( cursor . moveToFirst ( ) ) { long parent = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long root = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String commentText = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String pictures = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; long dateMillis = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; Date date = new Date ( dateMillis ) ; long areaOid = cursor . getLong ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; String areaSourceId = cursor . getString ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; int areaType = cursor . getInt ( cursor . getColumnIndexOrThrow ( \"<STR_LIT>\" ) ) ; CommentArea area = new CommentArea ( areaOid , areaSourceId , areaType ) ; comment = new Comment ( area , rpid , parent , root , commentText , pictures , date ) ; } cursor . close ( ) ; return comment ; } public void deletePendingCheckComment ( long rpid ) { getWritableDatabase ( ) . delete ( \"<STR_LIT>\" , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public void addSensitiveScanResultToHistoryComment ( long rpid , SensitiveScanResult result ) { ContentValues cv = new ContentValues ( ) ; cv . put ( \"<STR_LIT>\" , JSON . toJSONString ( result ) ) ; getWritableDatabase ( ) . update ( TABLE_NAME_HISTORY_COMMENT , cv , \"<STR_LIT>\" , new String [ ] { String . valueOf ( rpid ) } ) ; } public Map < String , String > countingStatus ( ) { Map < String , String > map = new HashMap < > ( ) ; Cursor cursor = getReadableDatabase ( ) . rawQuery ( \"<STR_LIT>\" , null ) ; while ( cursor . moveToNext ( ) ) { map . put ( cursor . getString ( <NUM_LIT> ) , cursor . getString ( <NUM_LIT> ) ) ; } cursor . close ( ) ; return map ; } }"}, {"input": "package com . norman . webviewup . lib . source . download ; import android . content . Context ; import com . arialyy . aria . core . Aria ; import com . arialyy . aria . core . AriaManager ; import com . arialyy . aria . core . config . DownloadConfig ; import com . arialyy . aria . core . download . DownloadEntity ; import com . arialyy . aria . core . download . DownloadReceiver ; import com . arialyy . aria . core . download . DownloadTaskListener ; import com . arialyy . aria . core . inf . IEntity ; import com . arialyy . aria . core . task . DownloadTask ; import com . norman . webviewup . lib . source . UpgradePathSource ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Objects ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class UpgradeDownloadSource extends UpgradePathSource implements DownloadTaskListener { public static final int MAX_DOWNLOAD_THREAD_NUM = <NUM_LIT> ; private final String url ; private final int threadNum ; private DownloadReceiver downloadReceiver ; private String tempPath ; private DownloadEntity downloadEntity ; public UpgradeDownloadSource ( Context context , String url , File file , int threadNum ) { super ( context , file . getPath ( ) ) ; this . url = url ; this . threadNum = threadNum ; } public UpgradeDownloadSource ( Context context , String url , File file ) { this ( context , url , file , MAX_DOWNLOAD_THREAD_NUM ) ; } @ Override protected void onPrepare ( Object params ) { AriaManager ariaManager = Aria . init ( getContext ( ) ) ; DownloadConfig downloadConfig = ariaManager . getDownloadConfig ( ) ; downloadConfig . setThreadNum ( threadNum ) ; downloadReceiver = Aria . download ( this ) ; downloadEntity = downloadReceiver . getFirstDownloadEntity ( url ) ; tempPath = getApkPath ( ) + \"<STR_LIT>\" ; this . downloadReceiver . register ( ) ; if ( downloadEntity == null || downloadEntity . getState ( ) == IEntity . STATE_CANCEL ) { FileUtils . createFile ( tempPath ) ; long taskId = downloadReceiver . load ( url ) . setFilePath ( tempPath ) . ignoreCheckPermissions ( ) . ignoreFilePathOccupy ( ) . create ( ) ; downloadEntity = downloadReceiver . getDownloadEntity ( taskId ) ; } else if ( downloadEntity . getState ( ) == IEntity . STATE_WAIT || downloadEntity . getState ( ) == IEntity . STATE_OTHER || downloadEntity . getState ( ) == IEntity . STATE_FAIL || downloadEntity . getState ( ) == IEntity . STATE_STOP ) { downloadReceiver . load ( downloadEntity . getId ( ) ) . ignoreCheckPermissions ( ) . resume ( ) ; } else if ( downloadEntity . getState ( ) == IEntity . STATE_COMPLETE ) { copyApk ( ) ; } } private void copyApk ( ) { new Thread ( ( ) -> { BufferedInputStream bufferedInput = null ; BufferedOutputStream bufferedOutput = null ; ZipFile zipFile = null ; try { if ( isValidApk ( tempPath ) ) { bufferedInput = new BufferedInputStream ( new FileInputStream ( tempPath ) ) ; } else { zipFile = new ZipFile ( tempPath ) ; bufferedInput = findStreamInZip ( zipFile ) ; } Objects . requireNonNull ( bufferedInput ) ; FileUtils . createFile ( getApkPath ( ) ) ; bufferedOutput = new BufferedOutputStream ( new FileOutputStream ( getApkPath ( ) ) ) ; copyBufferStream ( bufferedInput , bufferedOutput ) ; success ( ) ; deleteDownload ( ) ; } catch ( Throwable e ) { FileUtils . delete ( getApkPath ( ) ) ; error ( e ) ; } finally { try { if ( bufferedInput != null ) { bufferedInput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( bufferedOutput != null ) { bufferedOutput . close ( ) ; } } catch ( IOException ignore ) { } try { if ( zipFile != null ) { zipFile . close ( ) ; } } catch ( IOException ignore ) { } } } ) . start ( ) ; } private BufferedInputStream findStreamInZip ( ZipFile zipFile ) throws IOException { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; String entryName = entry . getName ( ) ; if ( entryName . endsWith ( \"<STR_LIT>\" ) ) { return new BufferedInputStream ( zipFile . getInputStream ( entry ) ) ; } } return null ; } private void copyBufferStream ( BufferedInputStream bufferedInput , BufferedOutputStream bufferedOutput ) throws IOException { int count ; int readCount = <NUM_LIT> ; int availableByteCount = bufferedInput . available ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; while ( ( count = bufferedInput . read ( buffer ) ) > <NUM_LIT> ) { bufferedOutput . write ( buffer , <NUM_LIT> , count ) ; readCount = readCount + count ; process ( <NUM_LIT> * readCount / availableByteCount + <NUM_LIT> ) ; } bufferedOutput . flush ( ) ; } private void deleteDownload ( ) { try { downloadReceiver . load ( downloadEntity . getId ( ) ) . ignoreCheckPermissions ( ) . cancel ( true ) ; } catch ( Throwable ignore ) { } } @ Override public void onWait ( DownloadTask task ) { } @ Override public void onPre ( DownloadTask task ) { downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskPre ( DownloadTask task ) { } @ Override public void onTaskResume ( DownloadTask task ) { } @ Override public void onTaskStart ( DownloadTask task ) { } @ Override public void onTaskStop ( DownloadTask task ) { downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskCancel ( DownloadTask task ) {", "output": "downloadEntity = task . getDownloadEntity ( ) ; } @ Override public void onTaskFail ( DownloadTask task , Exception e ) { if ( e == null ) { error ( new RuntimeException ( \"<STR_LIT>\" ) ) ; } else { error ( e ) ; } } @ Override public void onTaskComplete ( DownloadTask task ) { copyApk ( ) ; } @ Override public void onTaskRunning ( DownloadTask task ) { float percent = task . getPercent ( ) / <NUM_LIT> * <NUM_LIT> ; process ( percent ) ; } @ Override public void onNoSupportBreakPoint ( DownloadTask task ) { } private boolean isValidApk ( String path ) { try { return getContext ( ) . getPackageManager ( ) . getPackageArchiveInfo ( path , <NUM_LIT> ) != null ; } catch ( Throwable ignore ) { } return false ; } }"}, {"input": "package com . appspa . update . proxy ; import androidx . annotation . NonNull ; import java . util . Map ; public interface IUpdateChecker { void onBeforeCheck ( ) ; void checkVersion ( boolean isGet , @ NonNull String url , @ NonNull Map < String , Object > params , @ NonNull IUpdateProxy updateProxy ) ; void onAfterCheck ( ) ;", "output": "void processCheckResult ( @ NonNull String result , @ NonNull IUpdateProxy updateProxy ) ; void noNewVersion ( Throwable throwable ) ; }"}, {"input": "package com . simon . harmonichackernews . utils ; import com . simon . harmonichackernews . data . Story ; public class StoryUpdate { public static StoryUpdateListener storyUpdateListener ; public static void updateStory ( Story story ) { if ( storyUpdateListener != null ) { storyUpdateListener . callback ( story ) ; } }", "output": "public static void setStoryUpdatedListener ( StoryUpdateListener storyUpdateListener ) { StoryUpdate . storyUpdateListener = storyUpdateListener ; } public interface StoryUpdateListener { void callback ( Story story ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; public class PendingCommentListAdapter extends RecyclerView . Adapter < PendingCommentListAdapter . ViewHolder > { private final Context context ; private final StatisticsDBOpenHelper helper ; private final List < Comment > comments ; private final DialogCommCheckWorker worker ; public PendingCommentListAdapter ( Context context ) { this . context = context ; helper = new StatisticsDBOpenHelper ( context ) ; comments = helper . getAllPendingCheckComments ( ) ; Config config = new Config ( context ) ; worker = new DialogCommCheckWorker ( context , config , helper , new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) , new CommentUtil ( context ) ) ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . item_pending_check_comment , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { Comment comment = comments . get ( position ) ; holder . txv_comment . setText ( comment . comment ) ; holder . txv_info . setText ( comment . commentArea . sourceId ) ; holder . txv_date . setText ( comment . getFormatDateFor_yMdHms ( ) ) ; holder . itemView . setOnClickListener ( view -> { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( comment . comment ) . setPositiveButton ( android . R . string . ok , ( dialogInterface , i ) -> { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void onNewCommentRpid ( long rpid ) { comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } } ) ; worker . checkComment ( comment , progressBarDialog ) ; } ) . setNegativeButton ( android . R . string . cancel , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( \"<STR_LIT>\" , ( dialogInterface , i ) -> { helper . deletePendingCheckComment ( comment . rpid ) ; comments . remove ( holder . getBindingAdapterPosition ( ) ) ; notifyItemRemoved ( holder . getBindingAdapterPosition ( ) ) ; } ) . show ( ) ; } ) ; } @ Override public int getItemCount ( ) { return comments . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { TextView txv_comment , txv_info , txv_date ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; txv_comment = itemView . findViewById ( R . id . txv_comment_content ) ; txv_info = itemView . findViewById ( R . id . txv_info ) ; txv_date = itemView . findViewById ( R . id . txv_date ) ; } }", "output": "}"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . TYPE ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { TYPE } ) @ Inherited public @ interface ClassName { String value ( ) ;", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public abstract class BookmarkAdapter extends RecyclerView . Adapter < BookmarkAdapter . MyViewHolder > { public Context context ; public DialogInterface dialog ; public BookmarkAdapter ( Context context , DialogInterface dialog ) { this . context = context ; this . dialog = dialog ; } @ NonNull @ Override public MyViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new MyViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_bookmark , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull MyViewHolder holder , int position ) { BookMark item = getItem ( position ) ; holder . fileName . setText ( item . path ) ; holder . itemView . setOnClickListener ( v -> { onItemClick ( item ) ; dialog . dismiss ( ) ; } ) ; holder . itemView . setOnLongClickListener ( v -> { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" + item . path + \"<STR_LIT>\" ) . setNegativeButton ( \"<STR_LIT>\" , null ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> {", "output": "if ( onDelete ( item ) ) { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; notifyItemRemoved ( holder . getAdapterPosition ( ) ) ; } else { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . show ( ) ; return true ; } ) ; } protected abstract boolean onDelete ( BookMark bookMark ) ; protected abstract BookMark getItem ( int position ) ; protected abstract void onItemClick ( BookMark bookMark ) ; public static class MyViewHolder extends RecyclerView . ViewHolder { TextView fileName ; public MyViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; fileName = itemView . findViewById ( R . id . file_name ) ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . options ; import androidx . annotation . NonNull ; public class SetBundleOptions { @ NonNull private String bundleId ; public SetBundleOptions ( @ NonNull String bundleId ) { this . bundleId = bundleId ; } @ NonNull public String getBundleId ( ) { return bundleId ;", "output": "} }"}, {"input": "package io . capawesome . capacitorjs . plugins . fileopener ; import android . content . ActivityNotFoundException ; import android . content . Intent ; import android . net . Uri ; import android . util . Log ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class FileOpenerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_FILE_NOT_EXIST = \"<STR_LIT>\" ; public static final String ERROR_CANNOT_OPEN_FILE = \"<STR_LIT>\" ; private FileOpener implementation ; @ Override public void load ( ) { implementation = new FileOpener ( this ) ; } @ PluginMethod public void openFile ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } String mimeType = call . getString ( \"<STR_LIT>\" ) ; Uri uri = implementation . getUriByPath ( path ) ; boolean fileExists = implementation . isFileExists ( uri ) ; if ( ! fileExists ) { call . reject ( ERROR_FILE_NOT_EXIST ) ;", "output": "return ; } try { Intent intent = implementation . createIntent ( uri , mimeType ) ; getActivity ( ) . startActivity ( intent ) ; call . resolve ( ) ; } catch ( ActivityNotFoundException exception ) { call . reject ( ERROR_CANNOT_OPEN_FILE ) ; } } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } }"}, {"input": "package external . org . apache . commons . lang3 . builder ; final class IDKey {", "output": "private final Object value ; private final int id ; public IDKey ( Object _value ) { id = System . identityHashCode ( _value ) ; value = _value ; } @ Override public int hashCode ( ) { return id ; } @ Override public boolean equals ( Object other ) { if ( ! ( other instanceof IDKey ) ) { return false ; } IDKey idKey = ( IDKey ) other ; if ( id != idKey . id ) { return false ; } return value == idKey . value ; } }"}, {"input": "public class MainActivity extends AppCompatActivity { private SSLSocketFactory defaultSslSocketFactory ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory1 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory2 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; }", "output": "private SSLSocketFactory defaultSslSocketFactory3 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory4 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } private SSLSocketFactory defaultSslSocketFactory5 ( X509TrustManager trustManager ) throws NoSuchAlgorithmException , KeyManagementException { SSLContext sslContext = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sslContext . init ( null , new TrustManager [ ] { trustManager } , null ) ; return sslContext . getSocketFactory ( ) ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . graphics . Canvas ; import android . view . MotionEvent ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; public abstract class SimpleViewHelper implements FastScroller . ViewHelper { @ Nullable private Runnable mOnPreDrawListener ; @ Nullable private Runnable mOnScrollChangedListener ; @ Nullable private Predicate < MotionEvent > mOnTouchEventListener ; private boolean mListenerInterceptingTouchEvent ; @ Override public void addOnPreDrawListener ( @ Nullable Runnable listener ) { mOnPreDrawListener = listener ; } public void draw ( @ NonNull Canvas canvas ) { if ( mOnPreDrawListener != null ) { mOnPreDrawListener . run ( ) ; } superDraw ( canvas ) ; } @ Override public void addOnScrollChangedListener ( @ Nullable Runnable listener ) { mOnScrollChangedListener = listener ; } public void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { superOnScrollChanged ( left , top , oldLeft , oldTop ) ; if ( mOnScrollChangedListener != null ) { mOnScrollChangedListener . run ( ) ; } } @ Override public void addOnTouchEventListener ( @ Nullable Predicate < MotionEvent > listener ) { mOnTouchEventListener = listener ; } public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null && mOnTouchEventListener . test ( event ) ) { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnInterceptTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnInterceptTouchEvent ( event ) ; } return true ; } return superOnInterceptTouchEvent ( event ) ; } public boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( mOnTouchEventListener != null ) { if ( mListenerInterceptingTouchEvent ) { mOnTouchEventListener . test ( event ) ; int actionMasked = event . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_UP || actionMasked == MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = false ; } return true ; } else { int actionMasked = event . getActionMasked ( ) ; if ( actionMasked != MotionEvent . ACTION_DOWN && mOnTouchEventListener . test ( event ) ) { if ( actionMasked != MotionEvent . ACTION_UP && actionMasked != MotionEvent . ACTION_CANCEL ) { mListenerInterceptingTouchEvent = true ; } if ( actionMasked != MotionEvent . ACTION_CANCEL ) { MotionEvent cancelEvent = MotionEvent . obtain ( event ) ; cancelEvent . setAction ( MotionEvent . ACTION_CANCEL ) ; superOnTouchEvent ( cancelEvent ) ; cancelEvent . recycle ( ) ; } else { superOnTouchEvent ( event ) ; } return true ; } } } return superOnTouchEvent ( event ) ;", "output": "} @ Override public int getScrollRange ( ) { return computeVerticalScrollRange ( ) ; } @ Override public int getScrollOffset ( ) { return computeVerticalScrollOffset ( ) ; } @ Override public void scrollTo ( int offset ) { scrollTo ( getScrollX ( ) , offset ) ; } protected abstract void superDraw ( @ NonNull Canvas canvas ) ; protected abstract void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) ; protected abstract boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract boolean superOnTouchEvent ( @ NonNull MotionEvent event ) ; protected abstract int computeVerticalScrollRange ( ) ; protected abstract int computeVerticalScrollOffset ( ) ; protected abstract int getScrollX ( ) ; protected abstract void scrollTo ( int x , int y ) ; }"}, {"input": "package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class AboutViewModel extends ViewModel { private boolean isToolbarExpanded = true ; public boolean isToolbarExpanded ( ) { return isToolbarExpanded ; } public void setToolbarExpanded ( boolean toolbarExpanded ) {", "output": "isToolbarExpanded = toolbarExpanded ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . foregroundservice ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import com . getcapacitor . Logger ; public class NotificationActionBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { try { int buttonId = intent . getExtras ( ) . getInt ( \"<STR_LIT>\" ) ; ForegroundServicePlugin . onButtonClicked ( buttonId ) ; } catch ( Exception exception ) { Logger . error ( ForegroundServicePlugin . TAG , exception . getMessage ( ) , exception ) ; }", "output": "} }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideReceipt extends Feature { public HideReceipt ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; }", "output": "@ Override public void doHook ( ) throws Exception { var method = Unobfuscator . loadReceiptMethod ( classLoader ) ; logDebug ( \"<STR_LIT>\" + Unobfuscator . getMethodDescriptor ( method ) ) ; var method2 = Unobfuscator . loadReceiptOutsideChat ( classLoader ) ; logDebug ( \"<STR_LIT>\" + Unobfuscator . getMethodDescriptor ( method2 ) ) ; var method3 = Unobfuscator . loadReceiptInChat ( classLoader ) ; logDebug ( \"<STR_LIT>\" + Unobfuscator . getMethodDescriptor ( method3 ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( ! Unobfuscator . isCalledFromMethod ( method2 ) && ! Unobfuscator . isCalledFromMethod ( method3 ) ) return ; var jid = WppCore . getRawString ( param . args [ <NUM_LIT> ] ) ; if ( ( jid == null || jid . contains ( \"<STR_LIT>\" ) ) && param . args [ <NUM_LIT> ] != \"<STR_LIT>\" ) { param . args [ <NUM_LIT> ] = \"<STR_LIT>\" ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class ForwardDynamicResult { public long dyn_id ; public String dyn_id_str ; public int dyn_type ; public long dyn_rid ;", "output": "}"}, {"input": "package com . reactnative . wheelpicker . wheel ; import java . util . TimerTask ; public final class InertiaTimerTask extends TimerTask { private float mCurrentVelocityY ; private final float mFirstVelocityY ; private final WheelView mWheelView ; public InertiaTimerTask ( WheelView wheelView , float velocityY ) { super ( ) ; this . mWheelView = wheelView ; this . mFirstVelocityY = velocityY ; mCurrentVelocityY = Integer . MAX_VALUE ; } @ Override public final void run ( ) { if ( mCurrentVelocityY == Integer . MAX_VALUE ) { if ( Math . abs ( mFirstVelocityY ) > <NUM_LIT> ) { mCurrentVelocityY = mFirstVelocityY > <NUM_LIT> ? <NUM_LIT> : - <NUM_LIT> ; } else { mCurrentVelocityY = mFirstVelocityY ; } } if ( Math . abs ( mCurrentVelocityY ) >= <NUM_LIT> && Math . abs ( mCurrentVelocityY ) <= <NUM_LIT> ) { mWheelView . cancelFuture ( ) ; mWheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_SMOOTH_SCROLL ) ; return ; } int dy = ( int ) ( mCurrentVelocityY / <NUM_LIT> ) ; mWheelView . setTotalScrollY ( mWheelView . getTotalScrollY ( ) - dy ) ; if ( ! mWheelView . isLoop ( ) ) { float itemHeight = mWheelView . getItemHeight ( ) ; float top = ( - mWheelView . getInitPosition ( ) ) * itemHeight ; float bottom = ( mWheelView . getItemsCount ( ) - <NUM_LIT> - mWheelView . getInitPosition ( ) ) * itemHeight ; if ( mWheelView . getTotalScrollY ( ) - itemHeight * <NUM_LIT> < top ) { top = mWheelView . getTotalScrollY ( ) + dy ; }", "output": "else if ( mWheelView . getTotalScrollY ( ) + itemHeight * <NUM_LIT> > bottom ) { bottom = mWheelView . getTotalScrollY ( ) + dy ; } if ( mWheelView . getTotalScrollY ( ) <= top ) { mCurrentVelocityY = <NUM_LIT> ; mWheelView . setTotalScrollY ( ( int ) top ) ; } else if ( mWheelView . getTotalScrollY ( ) >= bottom ) { mWheelView . setTotalScrollY ( ( int ) bottom ) ; mCurrentVelocityY = - <NUM_LIT> ; } } if ( mCurrentVelocityY < <NUM_LIT> ) { mCurrentVelocityY = mCurrentVelocityY + <NUM_LIT> ; } else { mCurrentVelocityY = mCurrentVelocityY - <NUM_LIT> ; } mWheelView . getHandler ( ) . sendEmptyMessage ( MessageHandler . WHAT_INVALIDATE_LOOP_VIEW ) ; } }"}, {"input": "package in . hridayan . ashell . UI ; import android . content . Context ; import android . os . Handler ; import android . os . Looper ; import android . view . View ; import android . view . ViewTreeObserver ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . floatingactionbutton . ExtendedFloatingActionButton ; import com . google . android . material . floatingactionbutton . FloatingActionButton ; import com . google . android . material . textfield . TextInputEditText ; import in . hridayan . ashell . utils . Preferences ; import in . hridayan . ashell . utils . Utils ; import java . util . Objects ; public class BehaviorFAB { private static final int FAST_SCROLL_THRESHOLD = <NUM_LIT> ; private static final int VISIBILITY_DELAY_MILLIS = <NUM_LIT> ; private static final int FAST_SCROLL_THRESHOLD_EXTENDED = <NUM_LIT> ; public static class FabLocalScrollUpListener extends RecyclerView . OnScrollListener { private final FloatingActionButton fab ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabLocalScrollUpListener ( FloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; LinearLayoutManager layoutManager = ( LinearLayoutManager ) recyclerView . getLayoutManager ( ) ; int firstVisibleItemPosition = layoutManager . findFirstVisibleItemPosition ( ) ; if ( firstVisibleItemPosition == <NUM_LIT> ) { fab . hide ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= <NUM_LIT> ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } } } public static class FabOtgScrollUpListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabOtgScrollUpListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } private FabLocalScrollUpListener FabLocalScrollUpListener ; public BehaviorFAB ( FloatingActionButton fab ) { FabLocalScrollUpListener = new FabLocalScrollUpListener ( fab ) ; } public static class OtgShareButtonListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable showFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . show ( ) ; } } ; public OtgShareButtonListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy != <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( showFabRunnable ) ; fab . hide ( ) ; } else if ( dy == <NUM_LIT> ) { fab . show ( ) ; } else { visibilityHandler . postDelayed ( showFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } public static class FabLocalScrollDownListener extends RecyclerView . OnScrollListener { private final FloatingActionButton fab ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabLocalScrollDownListener ( FloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; LinearLayoutManager layoutManager = ( LinearLayoutManager ) recyclerView . getLayoutManager ( ) ; int lastVisibleItemPosition = layoutManager . findLastVisibleItemPosition ( ) ; int totalItemCount = layoutManager . getItemCount ( ) ; if ( lastVisibleItemPosition == totalItemCount - <NUM_LIT> ) { fab . hide ( ) ; } else if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= <NUM_LIT> ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } } } public static class FabOtgScrollDownListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final FloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; private Handler visibilityHandler = new Handler ( Looper . getMainLooper ( ) ) ; private Runnable hideFabRunnable = new Runnable ( ) { @ Override public void run ( ) { fab . hide ( ) ; } } ; public FabOtgScrollDownListener ( CoordinatedNestedScrollView scrollView , FloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; int scrollRange = scrollView . getChildAt ( <NUM_LIT> ) . getHeight ( ) - scrollView . getHeight ( ) ; int scrollDiff = scrollRange - scrollY ; if ( scrollDiff <= <NUM_LIT> ) { fab . hide ( ) ; } else { int dy = scrollY - lastScrollY ; if ( dy > <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { visibilityHandler . removeCallbacks ( hideFabRunnable ) ; fab . show ( ) ; } else if ( dy < <NUM_LIT> && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD ) { fab . hide ( ) ; } else { visibilityHandler . postDelayed ( hideFabRunnable , VISIBILITY_DELAY_MILLIS ) ; } lastScrollY = scrollY ; } } } public static class FabExtendingOnScrollListener extends RecyclerView . OnScrollListener { private final ExtendedFloatingActionButton fab ; public FabExtendingOnScrollListener ( ExtendedFloatingActionButton fab ) { this . fab = fab ; } @ Override public void onScrollStateChanged ( @ NonNull RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; if ( newState == RecyclerView . SCROLL_STATE_IDLE ) { if ( recyclerView . computeVerticalScrollOffset ( ) == <NUM_LIT> ) { fab . extend ( ) ; } }", "output": "} @ Override public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( dy > <NUM_LIT> && fab . isExtended ( ) && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { fab . shrink ( ) ; } else if ( dy < <NUM_LIT> && ! fab . isExtended ( ) && Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { fab . extend ( ) ; } } } public static class FabExtendingOnScrollViewListener implements ViewTreeObserver . OnScrollChangedListener { private final CoordinatedNestedScrollView scrollView ; private final ExtendedFloatingActionButton fab ; private int lastScrollY = <NUM_LIT> ; public FabExtendingOnScrollViewListener ( CoordinatedNestedScrollView scrollView , ExtendedFloatingActionButton fab ) { this . scrollView = scrollView ; this . fab = fab ; this . scrollView . getViewTreeObserver ( ) . addOnScrollChangedListener ( this ) ; } @ Override public void onScrollChanged ( ) { int scrollY = scrollView . getScrollY ( ) ; if ( scrollY == <NUM_LIT> ) { fab . extend ( ) ; } else { int dy = scrollY - lastScrollY ; if ( Math . abs ( dy ) >= FAST_SCROLL_THRESHOLD_EXTENDED ) { if ( dy > <NUM_LIT> && fab . isExtended ( ) ) { fab . shrink ( ) ; } else if ( dy < <NUM_LIT> && ! fab . isExtended ( ) ) { fab . extend ( ) ; } } } lastScrollY = scrollY ; } } public static void handleTopAndBottomArrow ( FloatingActionButton topButton , FloatingActionButton bottomButton , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView , Context context , String fragment ) { topButton . setOnClickListener ( new View . OnClickListener ( ) { private long lastClickTime = <NUM_LIT> ; @ Override public void onClick ( View v ) { long currentTime = System . currentTimeMillis ( ) ; long timeDifference = currentTime - lastClickTime ; if ( timeDifference < <NUM_LIT> ) { topScroll ( fragment , recyclerView , scrollView ) ; } else { boolean switchState = Preferences . getSmoothScroll ( context ) ; if ( switchState ) { smoothTopScroll ( fragment , recyclerView , scrollView ) ; } else { topScroll ( fragment , recyclerView , scrollView ) ; } } lastClickTime = currentTime ; } } ) ; bottomButton . setOnClickListener ( new View . OnClickListener ( ) { private long lastClickTime = <NUM_LIT> ; @ Override public void onClick ( View v ) { long currentTime = System . currentTimeMillis ( ) ; long timeDifference = currentTime - lastClickTime ; if ( timeDifference < <NUM_LIT> ) { bottomScroll ( fragment , recyclerView , scrollView ) ; } else { boolean switchState = Preferences . getSmoothScroll ( context ) ; if ( switchState ) { smoothBottomScroll ( fragment , recyclerView , scrollView ) ; } else { bottomScroll ( fragment , recyclerView , scrollView ) ; } } lastClickTime = currentTime ; } } ) ; } private static void topScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == \"<STR_LIT>\" ) { recyclerView . scrollToPosition ( <NUM_LIT> ) ; } else { scrollView . scrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } } private static void smoothTopScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == \"<STR_LIT>\" ) { recyclerView . smoothScrollToPosition ( <NUM_LIT> ) ; } else { scrollView . smoothScrollTo ( <NUM_LIT> , <NUM_LIT> ) ; } } private static void bottomScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == \"<STR_LIT>\" ) { recyclerView . scrollToPosition ( Objects . requireNonNull ( recyclerView . getAdapter ( ) ) . getItemCount ( ) - <NUM_LIT> ) ; } else { scrollView . fullScroll ( View . FOCUS_DOWN ) ; } } private static void smoothBottomScroll ( String fragment , RecyclerView recyclerView , CoordinatedNestedScrollView scrollView ) { if ( fragment == \"<STR_LIT>\" ) { recyclerView . smoothScrollToPosition ( Objects . requireNonNull ( recyclerView . getAdapter ( ) ) . getItemCount ( ) - <NUM_LIT> ) ; } else { scrollView . smoothScrollTo ( <NUM_LIT> , scrollView . getChildAt ( <NUM_LIT> ) . getBottom ( ) ) ; } } public static void pasteAndUndo ( ExtendedFloatingActionButton paste , FloatingActionButton undo , TextInputEditText editText ) { Handler mHandler = new Handler ( Looper . getMainLooper ( ) ) ; paste . setOnClickListener ( v -> { undo . show ( ) ; mHandler . postDelayed ( ( ) -> { undo . hide ( ) ; mHandler . removeCallbacksAndMessages ( null ) ; } , <NUM_LIT> ) ; Utils . pasteFromClipboard ( editText ) ; } ) ; undo . setOnClickListener ( v -> { editText . setText ( null ) ; undo . hide ( ) ; mHandler . removeCallbacksAndMessages ( null ) ; } ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . AlertDialog ; import android . app . Dialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; public class DialogUtil { public static Dialog dialogMessage ( Context context , String title , String message ) { return dialogMessage ( context , title , message , null ) ; } public static Dialog dialogMessage ( Context context , String title , String message , DialogInterface . OnClickListener onClose ) { AlertDialog . Builder dialogBuilder = new AlertDialog . Builder ( context ) . setMessage ( message ) ; if ( onClose == null ) { dialogBuilder . setPositiveButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) ; } else { dialogBuilder . setPositiveButton ( \"<STR_LIT>\" , onClose ) ; } if ( title != null ) { dialogBuilder . setTitle ( title ) ; } return dialogBuilder . show ( ) ; } public static ProgressDialog newProgressDialog ( Context context , String title , String message ) { ProgressDialog progressDialog = new ProgressDialog ( context ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_SPINNER ) ; progressDialog . setMessage ( message ) ;", "output": "if ( title != null ) { progressDialog . setTitle ( title ) ; } return progressDialog ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import java . lang . reflect . Field ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class ShowInvisibleCommentHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; param . setResult ( false ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , new XC_MethodReplacement ( ) { @ Override protected Object replaceHookedMethod ( MethodHookParam methodHookParam ) throws Throwable { Object thisObject = methodHookParam . thisObject ; Field invisibleField = thisObject . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; invisibleField . setAccessible ( true ) ; boolean invisible = invisibleField . getBoolean ( thisObject ) ; Field locationField = thisObject . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ;", "output": "locationField . setAccessible ( true ) ; String location = ( String ) locationField . get ( thisObject ) ; if ( invisible ) { return location + \"<STR_LIT>\" ; } else { return location ; } } } ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate ; import androidx . annotation . Nullable ; import java . security . Key ; public class LiveUpdateConfig { @ Nullable private String appId = null ; private boolean autoDeleteBundles = false ; private boolean enabled = true ; @ Nullable private String location = null ; @ Nullable private String publicKey = null ; private int readyTimeout = <NUM_LIT> ; private boolean resetOnUpdate = true ; @ Nullable public String getAppId ( ) { return appId ; } public boolean getAutoDeleteBundles ( ) { return autoDeleteBundles ; } public boolean getEnabled ( ) { return enabled ; } @ Nullable public String getLocation ( ) { return location ; } @ Nullable public String getPublicKey ( ) { return publicKey ; } public int getReadyTimeout ( ) { return readyTimeout ; } public boolean getResetOnUpdate ( ) { return resetOnUpdate ; } public void setAppId ( @ Nullable String appId ) { this . appId = appId ; } public void setAutoDeleteBundles ( boolean autoDeleteBundles ) {", "output": "this . autoDeleteBundles = autoDeleteBundles ; } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public void setLocation ( @ Nullable String location ) { this . location = location ; } public void setPublicKey ( @ Nullable String publicKey ) { this . publicKey = publicKey ; } public void setReadyTimeout ( int readyTimeout ) { this . readyTimeout = readyTimeout ; } public void setResetOnUpdate ( boolean resetOnUpdate ) { this . resetOnUpdate = resetOnUpdate ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import icu . freedomIntrovert . async . BackstageTaskByMVP ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class BatchReviewCommentStatusTask extends BackstageTaskByMVP < BatchReviewCommentStatusTask . EventHandler > { private final AtomicBoolean isBreak = new AtomicBoolean ( false ) ; private final CommentManipulator commentManipulator ; private final StatisticsDBOpenHelper statisticsDB ; private final List < HistoryComment > comments ; public BatchReviewCommentStatusTask ( CommentManipulator commentManipulator , StatisticsDBOpenHelper statisticsDB , List < HistoryComment > comments , EventHandler uiHandler ) { super ( uiHandler ) ; this . commentManipulator = commentManipulator ; this . statisticsDB = statisticsDB ; this . comments = comments ; } @ Override protected void onStart ( EventHandler eventHandlerProxy ) throws Throwable { for ( HistoryComment comment : comments ) { if ( isBreak . get ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; break ; } eventHandlerProxy . onStartCheck ( comment ) ; eventHandlerProxy . onCheckOver ( checkComment ( comment ) ) ; } } public void breakRun ( ) { isBreak . set ( true ) ; } public String checkComment ( HistoryComment historyComment ) throws IOException , CookieFailedException , BiliBiliApiException { if ( ! commentManipulator . checkCookieNotFailed ( ) ) { throw new CookieFailedException ( ) ; } CommentArea commentArea = historyComment . commentArea ; long rpid = historyComment . rpid ; GeneralResponse < CommentReplyPage > resp = commentManipulator . getCommentReplyHasAccount ( commentArea , rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( resp ) ; if ( resp . isSuccess ( ) ) { BiliComment rootComment = resp . data . root ; if ( rootComment . rpid == rpid ) { GeneralResponse < CommentReplyPage > resp1 = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( resp1 ) ; if ( resp1 . isSuccess ( ) ) { BiliComment foundComment = commentManipulator . findCommentUsingSeekRpid ( historyComment , false ) ; if ( foundComment == null ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_UNDER_REVIEW , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_UNDER_REVIEW ; } else { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_INVISIBLE , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_NORMAL , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } } else { statisticsDB . updateHistoryCommentStates ( rootComment . rpid , HistoryComment . STATE_SHADOW_BAN , rootComment . like , rootComment . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } else { GeneralResponse < CommentReplyPage > body = commentManipulator . getCommentReplyNoAccount ( commentArea , rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( body ) ; if ( body . isSuccess ( ) ) { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , false ) ; if ( foundReply != null ) { if ( rootComment . invisible ) { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_INVISIBLE , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_INVISIBLE ; } else { statisticsDB . updateHistoryCommentStates ( foundReply . rpid , HistoryComment . STATE_NORMAL , foundReply . like , foundReply . rcount , new Date ( ) ) ; return HistoryComment . STATE_NORMAL ; } } else { BiliComment foundReplyHasAcc = commentManipulator . findCommentFromCommentReplyArea ( commentArea , rpid , rootComment . rpid , true ) ; if ( foundReplyHasAcc != null ) { statisticsDB . updateHistoryCommentStates ( foundReplyHasAcc . rpid , HistoryComment . STATE_SHADOW_BAN , foundReplyHasAcc . like , foundReplyHasAcc . rcount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } } } else { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_SHADOW_BAN , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_SHADOW_BAN ; } } } else if ( resp . code == CommentAddResult . CODE_DELETED ) { statisticsDB . updateHistoryCommentStates ( historyComment . rpid , HistoryComment . STATE_DELETED , historyComment . like , historyComment . replyCount , new Date ( ) ) ; return HistoryComment . STATE_DELETED ; } else if ( resp . code == <NUM_LIT> ) { return \"<STR_LIT>\" ; } else { throw new BiliBiliApiException ( resp , \"<STR_LIT>\" ) ; } } public interface EventHandler extends BaseEventHandler {", "output": "void onStartCheck ( HistoryComment checkingComment ) ; void onCheckOver ( String newStatus ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . Service ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . content . ServiceConnection ; import android . os . Bundle ; import android . os . IBinder ; import android . os . RemoteException ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuItem ; import android . view . MotionEvent ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . widget . Toolbar ; import androidx . constraintlayout . widget . ConstraintLayout ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Objects ; import rikka . shizuku . Shizuku ; import top . weixiansen574 . async . TaskManger ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class TransferActivity extends AppCompatActivity implements ServiceConnection { private boolean isRootMode ; private boolean isLeftFocus = true ; private Context context ; private RecyclerView rv_left_files , rv_right_files ; private ConstraintLayout shadowLeft , shadowRight ; private FrameLayout frameLeft , frameRight ; private IIServiceFileSelectAdapter leftRVAdapter ; private IIServiceFileSelectAdapter rightRVAdapter ; private Toolbar toolbar ; private FrameLayout frameLayout ; private View currentSelectView ; private View leftSelectView , rightSelectView ; private FileTransferEventMonitorThread fileTransferEventMonitorThread ; private TransferSpeedMeterThread transferSpeedMeterThread ; private AlertDialog errorDialog ; private ConfigDB configDB ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_transfer ) ; context = this ; toolbar = findViewById ( R . id . toolbar ) ; setSupportActionBar ( toolbar ) ; Objects . requireNonNull ( getSupportActionBar ( ) ) . setDisplayHomeAsUpEnabled ( true ) ; frameLayout = findViewById ( R . id . frame_tool ) ; leftSelectView = LayoutInflater . from ( context ) . inflate ( R . layout . toolbar_select , null ) ; rightSelectView = LayoutInflater . from ( context ) . inflate ( R . layout . toolbar_select , null ) ; frameLeft = findViewById ( R . id . frame_left ) ; frameRight = findViewById ( R . id . frame_right ) ; shadowLeft = findViewById ( R . id . inner_shadow_left ) ; shadowRight = findViewById ( R . id . inner_shadow_right ) ; rv_left_files = findViewById ( R . id . rv_left_files ) ; rv_right_files = findViewById ( R . id . rv_right_files ) ; frameLeft . removeView ( shadowLeft ) ; Intent intent = getIntent ( ) ; isRootMode = intent . getBooleanExtra ( \"<STR_LIT>\" , false ) ; LinearLayoutManager linearLayoutManager = new LinearLayoutManager ( context ) ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; rv_left_files . setLayoutManager ( linearLayoutManager ) ; linearLayoutManager = new LinearLayoutManager ( context ) ; ; linearLayoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; rv_right_files . setLayoutManager ( linearLayoutManager ) ; bindService ( ) ; configDB = new ConfigDB ( context ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { ITransferService iTransferService = ITransferService . Stub . asInterface ( service ) ; System . out . println ( \"<STR_LIT>\" + service + \"<STR_LIT>\" + iTransferService ) ; OnTouchListener onTouchListenerForLeft = new OnTouchListener ( this , true ) ; Toolbar localFileSelectToolbar = leftSelectView . findViewById ( R . id . toolbar ) ; Toolbar remoteFileSelectToolbar = rightSelectView . findViewById ( R . id . toolbar ) ; OnTouchListener onTouchListenerForRight = new OnTouchListener ( this , false ) ; leftRVAdapter = new LocalFileSelectAdapter ( this , onTouchListenerForLeft , localFileSelectToolbar , findViewById ( R . id . frame_rv_left_root ) , findViewById ( R . id . frame_rv_left ) , iTransferService ) ; rightRVAdapter = new RemoteFileSelectAdapter ( this , onTouchListenerForRight , remoteFileSelectToolbar , findViewById ( R . id . frame_rv_right_root ) , findViewById ( R . id . frame_rv_right ) , iTransferService ) ; rv_left_files . setOnTouchListener ( onTouchListenerForLeft ) ; rv_right_files . setOnTouchListener ( onTouchListenerForRight ) ; leftRVAdapter . setSelectModeListener ( isSelectMode -> switchSelectView ( isSelectMode ? leftSelectView : null ) ) ; rightRVAdapter . setSelectModeListener ( isSelectMode -> switchSelectView ( isSelectMode ? rightSelectView : null ) ) ; rv_left_files . setAdapter ( leftRVAdapter ) ; rv_right_files . setAdapter ( rightRVAdapter ) ; fileTransferEventMonitorThread = new FileTransferEventMonitorThread ( this , iTransferService ) ; fileTransferEventMonitorThread . setDaemon ( true ) ; fileTransferEventMonitorThread . setName ( \"<STR_LIT>\" ) ; fileTransferEventMonitorThread . start ( ) ; transferSpeedMeterThread = new TransferSpeedMeterThread ( this , iTransferService ) ; transferSpeedMeterThread . setName ( \"<STR_LIT>\" ) ; transferSpeedMeterThread . start ( ) ; findViewById ( R . id . speed_info ) . setOnClickListener ( v -> showTransferProgressDialog ( ) ) ; TextView usb_upload_speed = findViewById ( R . id . usb_upload_speed ) ; TextView usb_download_speed = findViewById ( R . id . usb_download_speed ) ; TextView wifi_upload_speed = findViewById ( R . id . wifi_upload_speed ) ; TextView wifi_download_speed = findViewById ( R . id . wifi_download_speed ) ; transferSpeedMeterThread . addListener ( new OnInternetSpeedChangeListener ( ) { @ Override public void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) { usb_upload_speed . setText ( Utils . formatSpeed ( usbUpSpeed ) ) ; usb_download_speed . setText ( Utils . formatSpeed ( usbDownSpeed ) ) ; wifi_upload_speed . setText ( Utils . formatSpeed ( wifiUpSpeed ) ) ; wifi_download_speed . setText ( Utils . formatSpeed ( wifiDownSpeed ) ) ; } } ) ; leftRVAdapter . setOnToTransferListener ( ( selectedItems , dir ) -> { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" + selectedItems . size ( ) + \"<STR_LIT>\" + rightRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { leftRVAdapter . cancelSelect ( ) ; showTransferProgressDialog ( ) ; try { iTransferService . transferToPc ( selectedItems , dir , rightRVAdapter . getCurrentDir ( ) ) ; } catch ( RemoteException e ) { onServerDied ( ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , ( dialog , which ) -> { } ) . show ( ) ; } ) ; rightRVAdapter . setOnToTransferListener ( ( selectedItems , dir ) -> { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" + selectedItems . size ( ) + \"<STR_LIT>\" + leftRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { rightRVAdapter . cancelSelect ( ) ; showTransferProgressDialog ( ) ; TaskManger . start ( ( ) -> { try { iTransferService . transferToMe ( selectedItems , dir , leftRVAdapter . getCurrentDir ( ) ) ; } catch ( RemoteException e ) { onServerDied ( ) ; } } ) ; } ) . setNegativeButton ( \"<STR_LIT>\" , ( dialog , which ) -> { } ) . show ( ) ; } ) ; } @ Override public void onServiceDisconnected ( ComponentName name ) { } private void bindService ( ) { if ( isRootMode ) { Shizuku . bindUserService ( Utils . getUserServiceArgs ( context ) , this ) ; } else { Intent intent = new Intent ( context , TransferServices . class ) ; bindService ( intent , this , Service . BIND_AUTO_CREATE ) ; } } private void unbindService ( ) { if ( isRootMode ) { Shizuku . unbindUserService ( Utils . getUserServiceArgs ( context ) , this , false ) ; } else { unbindService ( this ) ; } } public void onServerDied ( ) { runOnUiThread ( ( ) -> { if ( errorDialog == null && ! isDestroyed ( ) ) { errorDialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setCancelable ( false ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { finish ( ) ; } ) . show ( ) ; } } ) ; } public void switchTo ( boolean isLeft ) { if ( isLeft ) { if ( ! this . isLeftFocus ) { frameLeft . removeView ( shadowLeft ) ; frameRight . addView ( shadowRight ) ; } switchSelectView ( leftRVAdapter . isSelectMode ( ) ? leftSelectView : null ) ; } else { if ( isLeftFocus ) { frameRight . removeView ( shadowRight ) ; frameLeft . addView ( shadowLeft ) ; } switchSelectView ( rightRVAdapter . isSelectMode ( ) ? rightSelectView : null ) ; } this . isLeftFocus = isLeft ; } @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { if ( isLeftFocus ) { if ( leftRVAdapter . isSelectMode ( ) ) { leftRVAdapter . cancelSelect ( ) ; } else { leftRVAdapter . cdParent ( ) ; } } else { if ( rightRVAdapter . isSelectMode ( ) ) { rightRVAdapter . cancelSelect ( ) ; } else { rightRVAdapter . cdParent ( ) ; } } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void switchSelectView ( View selectView ) { if ( currentSelectView != selectView ) { if ( currentSelectView != null ) { frameLayout . removeView ( currentSelectView ) ; } if ( selectView != null ) { frameLayout . addView ( selectView ) ; } currentSelectView = selectView ; } } private static class OnTouchListener implements View . OnTouchListener { private final TransferActivity activity ; private final boolean isLeft ; public OnTouchListener ( TransferActivity activity , boolean isLeft ) { this . activity = activity ; this . isLeft = isLeft ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouch ( View v , MotionEvent event ) { if ( event . getAction ( ) == MotionEvent . ACTION_DOWN ) { System . out . println ( \"<STR_LIT>\" + ( isLeft ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ) ; activity . switchTo ( isLeft ) ; } return false ; } } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { int id = item . getItemId ( ) ; if ( id == android . R . id . home ) { finish ( ) ; return true ; } else if ( id == R . id . refresh ) { if ( leftRVAdapter == null || rightRVAdapter == null ) { return true ; } if ( isLeftFocus ) { leftRVAdapter . cd ( leftRVAdapter . getCurrentDir ( ) ) ; } else { rightRVAdapter . cd ( rightRVAdapter . getCurrentDir ( ) ) ; } } else if ( id == R . id . bookmark_list ) { View dialogView = View . inflate ( context , R . layout . dialog_bookmarks , null ) ; RecyclerView recyclerView = dialogView . findViewById ( R . id . bookmark_list ) ; LinearLayoutManager layoutManager = new LinearLayoutManager ( context ) ; layoutManager . setOrientation ( RecyclerView . VERTICAL ) ; recyclerView . setLayoutManager ( layoutManager ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) . setView ( dialogView ) . setPositiveButton ( \"<STR_LIT>\" , null ) ; if ( isLeftFocus ) { builder . setTitle ( \"<STR_LIT>\" ) ; recyclerView . setAdapter ( new LocalBookmarkAdapter ( context , builder . show ( ) , leftRVAdapter , configDB ) ) ; } else { builder . setTitle ( \"<STR_LIT>\" ) ; recyclerView . setAdapter ( new RemoteBookmarkAdapter ( context , builder . show ( ) , rightRVAdapter , configDB ) ) ; } } else if ( id == R . id . add_bookmark ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; if ( isLeftFocus ) { builder . setTitle ( \"<STR_LIT>\" ) . setMessage ( leftRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { addBookmark ( false , leftRVAdapter . getCurrentDir ( ) ) ; } ) ; } else { builder . setTitle ( \"<STR_LIT>\" ) . setMessage ( rightRVAdapter . getCurrentDir ( ) ) . setPositiveButton ( R . string . ok , ( dialog , which ) -> { addBookmark ( true , rightRVAdapter . getCurrentDir ( ) ) ; } ) ; } builder . setNegativeButton ( R . string . cancel , null ) ; builder . show ( ) ; } return super . onOptionsItemSelected ( item ) ; } private void addBookmark ( boolean isRemote , String path ) { boolean exists ; if ( isRemote ) { exists = configDB . checkRemoteBookmarkExists ( path ) ; if ( ! exists ) { configDB . addRemoteBookmark ( path ) ; } } else { exists = configDB . checkLocalBookmarkExists ( path ) ; if ( ! exists ) { configDB . addLocalBookmark ( path ) ; } } if ( ! exists ) { Toast . makeText ( this , \"<STR_LIT>\" + ( isRemote ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } else { Toast . makeText ( this , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . toolbar_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; unbindService ( ) ; if ( transferSpeedMeterThread != null ) { transferSpeedMeterThread . isRun = false ; transferSpeedMeterThread . interrupt ( ) ; } if ( fileTransferEventMonitorThread != null ) { try { fileTransferEventMonitorThread . service . stopGetNextEvent ( ) ; } catch ( RemoteException ignored ) { } } } private void showTransferProgressDialog ( ) { View dialogView = View . inflate ( context , R . layout . dialog_transfer_progress_2 , null ) ; TextView txv_usb_transfer_event = dialogView . findViewById ( R . id . txv_usb_transfer_event ) ; TextView txv_wifi_transfer_event = dialogView . findViewById ( R . id . txv_wifi_transfer_event ) ; TextView txv_usb_upload_speed = dialogView . findViewById ( R . id . txv_usb_upload_speed ) ; TextView txv_usb_download_speed = dialogView . findViewById ( R . id . txv_usb_download_speed ) ; TextView txv_wifi_upload_speed = dialogView . findViewById ( R . id . txv_wifi_upload_speed ) ; TextView txv_wifi_download_speed = dialogView . findViewById ( R . id . txv_wifi_download_speed ) ; OnFileTransferEventListener listener = new OnFileTransferEventListener ( ) { @ Override public void onEvent ( ParcelableFileTransferEvent event ) { TextView setText = null ; if ( event . getDevice ( ) == ParcelableFileTransferEvent . DEVICE_USB ) { setText = txv_usb_transfer_event ; } else if ( event . getDevice ( ) == ParcelableFileTransferEvent . DEVICE_WIFI ) { setText = txv_wifi_transfer_event ; } else { throw new RuntimeException ( \"<STR_LIT>\" + event . getDevice ( ) ) ; } switch ( event . getState ( ) ) { case ParcelableFileTransferEvent . STATE_UPLOAD : setText . setText ( \"<STR_LIT>\" + event . getDesc ( ) ) ; break ; case ParcelableFileTransferEvent . STATE_DOWNLOAD : setText . setText ( \"<STR_LIT>\" + event . getDesc ( ) ) ; break ; case ParcelableFileTransferEvent . STATE_OVER : setText . setText ( \"<STR_LIT>\" + event . getDesc ( ) ) ; break ; } } } ; AlertDialog dialog = new AlertDialog . Builder ( this ) . setView ( dialogView ) . setTitle ( \"<STR_LIT>\" ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; OnInternetSpeedChangeListener speedChangeListener = new OnInternetSpeedChangeListener ( ) { @ Override public void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) { dialog . setTitle ( String . format ( Locale . getDefault ( ) , \"<STR_LIT>\" , ( ( float ) usbUpSpeed + wifiUpSpeed ) / <NUM_LIT> / <NUM_LIT> , ( ( float ) usbDownSpeed + wifiDownSpeed ) / <NUM_LIT> / <NUM_LIT> ) ) ; txv_usb_upload_speed . setText ( Utils . formatSpeed ( usbUpSpeed ) ) ; txv_usb_download_speed . setText ( Utils . formatSpeed ( usbDownSpeed ) ) ; txv_wifi_upload_speed . setText ( Utils . formatSpeed ( wifiUpSpeed ) ) ; txv_wifi_download_speed . setText ( Utils . formatSpeed ( wifiDownSpeed ) ) ; } } ; fileTransferEventMonitorThread . addListener ( listener ) ; transferSpeedMeterThread . addListener ( speedChangeListener ) ; dialog . setOnDismissListener ( dialog1 -> { fileTransferEventMonitorThread . removeListener ( listener ) ; transferSpeedMeterThread . removeListener ( speedChangeListener ) ; } ) ; } public static class FileTransferEventMonitorThread extends Thread { private boolean isRun ; private TransferActivity activity ; private ITransferService service ; List < OnFileTransferEventListener > listeners ; public FileTransferEventMonitorThread ( TransferActivity activity , ITransferService service ) { this . activity = activity ; this . service = service ; this . listeners = new ArrayList < > ( ) ; } @ Override public void run ( ) { isRun = true ; while ( isRun ) { try { ParcelableFileTransferEvent nextFileTransferEvent = service . getNextFileTransferEvent ( ) ; if ( nextFileTransferEvent != null ) { activity . runOnUiThread ( ( ) -> { for ( OnFileTransferEventListener listener : listeners ) { listener . onEvent ( nextFileTransferEvent ) ; } } ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; break ; } } catch ( RemoteException e ) { isRun = false ; e . printStackTrace ( ) ; activity . onServerDied ( ) ; } } } public void addListener ( OnFileTransferEventListener eventListener ) { listeners . add ( eventListener ) ;", "output": "} public void removeListener ( OnFileTransferEventListener eventListener ) { listeners . remove ( eventListener ) ; } } public interface OnFileTransferEventListener { void onEvent ( ParcelableFileTransferEvent event ) ; } public static class TransferSpeedMeterThread extends Thread { private boolean isRun ; private Activity activity ; private ITransferService service ; private ArrayList < OnInternetSpeedChangeListener > listeners ; public TransferSpeedMeterThread ( Activity activity , ITransferService service ) { this . activity = activity ; this . service = service ; listeners = new ArrayList < > ( ) ; } @ Override public void run ( ) { isRun = true ; while ( isRun ) { try { Thread . sleep ( <NUM_LIT> ) ; ParcelableTransferredBytesInfo info = service . getTransferredBytesInfo ( ) ; activity . runOnUiThread ( ( ) -> { for ( OnInternetSpeedChangeListener listener : listeners ) { listener . onInternetSpeedChanged ( info . getUsbSentBytes ( ) , info . getUsbReceiveBytes ( ) , info . getWifiSentBytes ( ) , info . getWifiReceiveBytes ( ) ) ; } } ) ; } catch ( InterruptedException | RemoteException ignored ) { } } } public void addListener ( OnInternetSpeedChangeListener listener ) { listeners . add ( listener ) ; } public void removeListener ( OnInternetSpeedChangeListener listener ) { listeners . remove ( listener ) ; } } public interface OnInternetSpeedChangeListener { void onInternetSpeedChanged ( long usbUpSpeed , long usbDownSpeed , long wifiUpSpeed , long wifiDownSpeed ) ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . res . Resources ; import android . text . Layout ; import android . text . TextWatcher ; import android . view . View ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; public class ViewUtils { public static void setUpSwipeRefreshWithStatusBarOffset ( SwipeRefreshLayout layout ) { int start = layout . getProgressViewStartOffset ( ) ; int end = layout . getProgressViewEndOffset ( ) ; ViewCompat . setOnApplyWindowInsetsListener ( layout , ( v , insets ) -> { int top = insets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) . top ; if ( SettingsUtils . shouldUseTransparentStatusBar ( layout . getContext ( ) ) ) { layout . setProgressViewOffset ( false , start , end + top ) ; } else { layout . setProgressViewOffset ( false , start + top , end + top ) ; } return insets ; } ) ; requestApplyInsetsWhenAttached ( layout ) ;", "output": "} public static void requestApplyInsetsWhenAttached ( @ NonNull View view ) { if ( ViewCompat . isAttachedToWindow ( view ) ) { ViewCompat . requestApplyInsets ( view ) ; } else { view . addOnAttachStateChangeListener ( new View . OnAttachStateChangeListener ( ) { @ Override public void onViewAttachedToWindow ( @ NonNull View v ) { v . removeOnAttachStateChangeListener ( this ) ; ViewCompat . requestApplyInsets ( v ) ; } @ Override public void onViewDetachedFromWindow ( View v ) { } } ) ; } } public static int getNavigationBarHeight ( Resources res ) { int resourceId = res . getIdentifier ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( resourceId > <NUM_LIT> ) { return res . getDimensionPixelSize ( resourceId ) ; } return <NUM_LIT> ; } public static boolean isTextTruncated ( TextView textView ) { Layout layout = textView . getLayout ( ) ; if ( layout != null ) { int maxLines = textView . getMaxLines ( ) ; if ( maxLines == - <NUM_LIT> ) { return false ; } int lineCount = layout . getLineCount ( ) ; if ( lineCount <= maxLines ) { return false ; } else { return true ; } } return false ; } public abstract static class SimpleTextWatcher implements TextWatcher { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } } }"}, {"input": "public class A { byte [ ] key = new byte [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( this . key , \"<STR_LIT>\" ) , new IvParameterSpec ( iv ) ) ;", "output": "return cipher . doFinal ( data ) ; } } public class B { String key = \"<STR_LIT>\" ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( this . key . getBytes ( ) , \"<STR_LIT>\" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( data ) ; } } public class C { String key ; byte [ ] iv = new byte [ ] { <NUM_LIT> } ; private byte [ ] aes ( byte [ ] data , int mode ) { key = getString ( R . string . key ) ; Cipher cipher = Cipher . getInstance ( AES_MODE ) ; cipher . init ( mode , new SecretKeySpec ( key . toByteArray ( ) , \"<STR_LIT>\" ) , new IvParameterSpec ( iv ) ) ; return cipher . doFinal ( data ) ; } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . wakeup . listener ; import android . os . Handler ; import com . baidu . aip . asrwakeup3 . core . recog . IStatus ; import com . baidu . aip . asrwakeup3 . core . wakeup . WakeUpResult ; public class RecogWakeupListener extends SimpleWakeupListener implements IStatus { private static final String TAG = \"<STR_LIT>\" ; private Handler handler ; public RecogWakeupListener ( Handler handler ) { this . handler = handler ;", "output": "} @ Override public void onSuccess ( String word , WakeUpResult result ) { super . onSuccess ( word , result ) ; handler . sendMessage ( handler . obtainMessage ( STATUS_WAKEUP_SUCCESS ) ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . NotificationManager ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . os . Build ; import android . os . Bundle ; import android . os . Handler ; import android . provider . Settings ; import android . view . Window ; import android . widget . Toast ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import java . io . IOException ; import java . util . Date ; import java . util . List ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . danmaku . DanmakuManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . BiliApiCallback ; import icu . freedomIntrovert . biliSendCommAntifraud . picturestorage . PictureStorage ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ByXposedLaunchedActivity extends AppCompatActivity { public static final int TODO_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_CHECK_DANMAKU = <NUM_LIT> ; public static final int TODO_CONTINUE_CHECK_COMMENT = <NUM_LIT> ; public static final int TODO_SAVE_CONTAIN_SENSITIVE_CONTENT = <NUM_LIT> ; public static Activity lastActivity ; Context context ; Handler handler ; CommentManipulator commentManipulator ; CommentUtil commentUtil ; StatisticsDBOpenHelper statisticsDBOpenHelper ; DanmakuManipulator danmakuManipulator ; boolean toContinueTo = true ; Config config ; @ Override protected void onCreate ( Bundle savedInstanceState ) { if ( lastActivity != null ) { System . out . println ( \"<STR_LIT>\" + lastActivity . getClass ( ) . getCanonicalName ( ) + \"<STR_LIT>\" ) ; lastActivity . finish ( ) ; } super . onCreate ( savedInstanceState ) ; supportRequestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . activity_by_xposed_launched ) ; this . context = this ; config = new Config ( context ) ; handler = new Handler ( ) ; commentManipulator = new CommentManipulator ( config . getCookie ( ) , config . getDeputyCookie ( ) ) ; commentUtil = new CommentUtil ( context ) ; statisticsDBOpenHelper = new StatisticsDBOpenHelper ( context ) ; danmakuManipulator = new DanmakuManipulator ( ) ; Intent intent = getIntent ( ) ; int todo = intent . getIntExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; long waitTime = config . getWaitTime ( ) ; long waitTimeByHasPictures = config . getWaitTimeByHasPictures ( ) ; Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { showExtrasError ( null ) ; } else if ( todo == TODO_CHECK_COMMENT ) { String message = extras . getString ( \"<STR_LIT>\" ) ; String s_oid = extras . getString ( \"<STR_LIT>\" ) ; String s_type = extras . getString ( \"<STR_LIT>\" ) ; String s_resultRpid = extras . getString ( \"<STR_LIT>\" ) ; String s_root = extras . getString ( \"<STR_LIT>\" ) ; String s_parent = extras . getString ( \"<STR_LIT>\" ) ; String commentText = extras . getString ( \"<STR_LIT>\" ) ; String dynamicId = extras . getString ( \"<STR_LIT>\" ) ; String bvid = extras . getString ( \"<STR_LIT>\" ) ; String pictures = extras . getString ( \"<STR_LIT>\" ) ; long ctime = extras . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) * <NUM_LIT> ; if ( message == null || s_oid == null || s_type == null || s_resultRpid == null || s_root == null || s_parent == null || commentText == null ) { showExtrasError ( extras ) ; return ; } long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; long resultRpid = Long . parseLong ( s_resultRpid ) ; long root = Long . parseLong ( s_root ) ; long parent = Long . parseLong ( s_parent ) ; CommentArea commentArea = null ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentArea = new CommentArea ( oid , bvid , type ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { commentArea = new CommentArea ( oid , s_oid , type ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { commentArea = new CommentArea ( oid , \"<STR_LIT>\" + oid , type ) ; } else { commentArea = new CommentArea ( oid , dynamicId != null ? dynamicId : \"<STR_LIT>\" , type ) ; } Comment comment = new Comment ( commentArea , resultRpid , parent , root , commentText , pictures , new Date ( ctime ) ) ; statisticsDBOpenHelper . insertPendingCheckComment ( comment ) ; boolean hasPictures = comment . hasPictures ( ) ; long totalWaitTime ; String proMsg ; if ( hasPictures ) { totalWaitTime = waitTime + waitTimeByHasPictures ; proMsg = \"<STR_LIT>\" + waitTime + \"<STR_LIT>\" + waitTimeByHasPictures + \"<STR_LIT>\" + totalWaitTime + \"<STR_LIT>\" ; } else { totalWaitTime = waitTime ; proMsg = \"<STR_LIT>\" + waitTime + \"<STR_LIT>\" ; } ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( String . format ( proMsg , <NUM_LIT> ) ) . setPositiveButton ( \"<STR_LIT>\" , null ) . setCancelable ( false ) . show ( ) ; ProgressTimer progressTimer = new ProgressTimer ( totalWaitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , new ProgressTimer . ProgressLister ( ) { @ Override public void onNewProgress ( int progress , long sleepSeg ) { runOnUiThread ( ( ) -> { progressBarDialog . setProgress ( progress ) ; progressBarDialog . setMessage ( String . format ( proMsg , progress * sleepSeg ) ) ; } ) ; } } ) ; long lastTime = System . currentTimeMillis ( ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( v -> { if ( checkNotificationPermission ( context ) ) { Intent intent1 = new Intent ( context , WaitService . class ) ; if ( hasPictures ) { intent1 . putExtra ( \"<STR_LIT>\" , totalWaitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } else { intent1 . putExtra ( \"<STR_LIT>\" , waitTime - ( System . currentTimeMillis ( ) - lastTime ) ) ; } intent1 . putExtra ( \"<STR_LIT>\" , resultRpid ) ; intent1 . putExtra ( \"<STR_LIT>\" , commentText ) ; startService ( intent1 ) ; toContinueTo = false ; finish ( ) ; } else { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_LONG ) . show ( ) ; requestNotificationPermission ( context ) ; } } ) ; new Thread ( ( ) -> { progressTimer . start ( ) ; if ( toContinueTo ) { runOnUiThread ( ( ) -> { progressBarDialog . setIndeterminate ( true ) ; progressBarDialog . setTitle ( \"<STR_LIT>\" ) ; progressBarDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( false ) ; toCheckComment ( comment , progressBarDialog ) ; } ) ; } } ) . start ( ) ; } else if ( todo == TODO_CONTINUE_CHECK_COMMENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; long rpid = intent . getLongExtra ( \"<STR_LIT>\" , - <NUM_LIT> ) ; Comment comment = statisticsDBOpenHelper . getPendingCheckCommentByRpid ( rpid ) ; System . out . println ( comment ) ; if ( comment == null ) { dialogMessageAndExit ( \"<STR_LIT>\" , \"<STR_LIT>\" + rpid + \"<STR_LIT>\" ) ; } else { toCheckComment ( comment , progressBarDialog ) ; } } else if ( todo == TODO_SAVE_CONTAIN_SENSITIVE_CONTENT ) { ProgressBarDialog progressBarDialog = new ProgressBarDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setIndeterminate ( true ) . setCancelable ( false ) . show ( ) ; String comment = intent . getStringExtra ( \"<STR_LIT>\" ) ; String message = intent . getStringExtra ( \"<STR_LIT>\" ) ; String s_oid = intent . getStringExtra ( \"<STR_LIT>\" ) ; String s_type = intent . getStringExtra ( \"<STR_LIT>\" ) ; String dynamicId = intent . getStringExtra ( \"<STR_LIT>\" ) ; DialogInterface . OnClickListener onClose = ( dialog , which ) -> finish ( ) ; if ( comment != null && s_oid != null && s_type != null ) { long oid = Long . parseLong ( s_oid ) ; int type = Integer . parseInt ( s_type ) ; if ( type == CommentArea . AREA_TYPE_VIDEO ) { commentManipulator . getVideoInfoByAid ( oid ) . enqueue ( new BiliApiCallback < GeneralResponse < VideoInfo > > ( ) { @ Override public void onError ( Throwable th ) { progressBarDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , th . getMessage ( ) , onClose ) ; } @ Override public void onSuccess ( GeneralResponse < VideoInfo > videoInfoGeneralResponse ) { progressBarDialog . dismiss ( ) ; if ( videoInfoGeneralResponse . isSuccess ( ) ) { addSensitiveComment ( new CommentArea ( oid , videoInfoGeneralResponse . data . bvid , type ) , comment , message , onClose ) ; } else { DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , videoInfoGeneralResponse . message , onClose ) ; } } } ) ; } else if ( type == CommentArea . AREA_TYPE_ARTICLE ) { addSensitiveComment ( new CommentArea ( oid , \"<STR_LIT>\" + oid , type ) , comment , message , onClose ) ; } else if ( type == CommentArea . AREA_TYPE_DYNAMIC17 ) { addSensitiveComment ( new CommentArea ( oid , String . valueOf ( oid ) , type ) , comment , message , onClose ) ; } else { addSensitiveComment ( new CommentArea ( oid , dynamicId != null ? dynamicId : \"<STR_LIT>\" , type ) , comment , message , onClose ) ; } } else { DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" + intent . getExtras ( ) , onClose ) ; } } } private void addSensitiveComment ( CommentArea commentArea , String commentText , String message , DialogInterface . OnClickListener onClose ) { HistoryComment historyComment = new HistoryComment ( new Comment ( commentArea , - System . currentTimeMillis ( ) , <NUM_LIT> , <NUM_LIT> , commentText , null , new Date ( ) ) ) ; historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SENSITIVE ) ; if ( statisticsDBOpenHelper . insertHistoryComment ( historyComment ) > <NUM_LIT> ) { DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" + message + \"<STR_LIT>\" + commentText , onClose ) ; } else { DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" , onClose ) ; } } private void showExtrasError ( @ Nullable Bundle extras ) { dialogMessageAndExit ( \"<STR_LIT>\" , \"<STR_LIT>\" + extras ) ; } private void dialogMessageAndExit ( String title , String message ) { new AlertDialog . Builder ( context ) . setTitle ( title ) . setMessage ( message ) . setNegativeButton ( \"<STR_LIT>\" , ( dialog , which ) -> finish ( ) ) . show ( ) ; } private void toCheckComment ( Comment comment , ProgressBarDialog progressDialog ) { DialogCommCheckWorker worker = new DialogCommCheckWorker ( context , config , statisticsDBOpenHelper , commentManipulator , commentUtil ) ; worker . setExitListener ( new OnExitListener ( ) { @ Override public void exit ( ) { finish ( ) ; } } ) ; List < Comment . PictureInfo > pictureInfoList = comment . getPictureInfoList ( ) ; if ( pictureInfoList != null ) { TaskManger . start ( ( ) -> { try { for ( int i = <NUM_LIT> ; i < pictureInfoList . size ( ) ; i ++ ) { int finalI = i ; runOnUiThread ( ( ) -> { progressDialog . setMessage ( \"<STR_LIT>\" + ( finalI + <NUM_LIT> ) + \"<STR_LIT>\" + pictureInfoList . size ( ) + \"<STR_LIT>\" ) ; } ) ; PictureStorage . save ( context , pictureInfoList . get ( i ) . img_src ) ; } runOnUiThread ( ( ) -> { progressDialog . setMessage ( \"<STR_LIT>\" ) ; worker . checkComment ( comment , progressDialog ) ; } ) ; } catch ( IOException e ) { runOnUiThread ( ( ) -> { progressDialog . dismiss ( ) ; DialogUtil . dialogMessage ( context , \"<STR_LIT>\" , \"<STR_LIT>\" + e . getMessage ( ) ) ; } ) ; e . printStackTrace ( ) ; } } ) ; } else { worker . checkComment ( comment , progressDialog ) ; } } @ Override protected void attachBaseContext ( Context newBase ) { super . attachBaseContext ( getConfigurationContext ( newBase ) ) ; } @ Override protected void onNewIntent ( Intent intent ) { super . onNewIntent ( intent ) ; System . out . println ( \"<STR_LIT>\" ) ; System . out . println ( this ) ; } private static Context getConfigurationContext ( Context context ) { Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; if ( configuration . fontScale > <NUM_LIT> ) { configuration . fontScale = <NUM_LIT> ; } return context . createConfigurationContext ( configuration ) ; } public static boolean checkNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; if ( notificationManager != null ) { return notificationManager . areNotificationsEnabled ( ) ; } } else { return true ; } return false ; }", "output": "public static void requestNotificationPermission ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { Intent intent = new Intent ( Settings . ACTION_APP_NOTIFICATION_SETTINGS ) ; intent . putExtra ( Settings . EXTRA_APP_PACKAGE , context . getPackageName ( ) ) ; context . startActivity ( intent ) ; } else { Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } }"}, {"input": "package com . appspa . update . widget ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . util . DisplayMetrics ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . core . app . ActivityCompat ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . R ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; import static com . appspa . update . widget . UpdateDialogFragment . REQUEST_CODE_REQUEST_PERMISSIONS ; public class UpdateDialog extends BaseDialog implements View . OnClickListener , IDownloadEventHandler { private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private IPrompterProxy mPrompterProxy ; private PromptEntity mPromptEntity ; public static UpdateDialog newInstance ( @ NonNull Context context , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , PromptEntity promptEntity ) { UpdateDialog dialog = new UpdateDialog ( context ) ; dialog . setIPrompterProxy ( prompterProxy ) . setUpdateEntity ( updateEntity ) . setPromptEntity ( promptEntity ) ; dialog . initTheme ( promptEntity . getThemeColor ( ) , promptEntity . getTopResId ( ) , promptEntity . getButtonTextColor ( ) , promptEntity . getWidthRatio ( ) , promptEntity . getHeightRatio ( ) ) ; return dialog ; } private UpdateDialog ( Context context ) { super ( context , R . layout . spa_dialog_update ) ; } public UpdateDialog setPromptEntity ( PromptEntity promptEntity ) { mPromptEntity = promptEntity ; return this ; } @ Override protected void initViews ( ) { mIvTop = findViewById ( R . id . iv_top ) ; mTvTitle = findViewById ( R . id . tv_title ) ; mTvUpdateInfo = findViewById ( R . id . tv_update_info ) ; mBtnUpdate = findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = findViewById ( R . id . btn_background_update ) ; mTvIgnore = findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = findViewById ( R . id . npb_progress ) ; mLlClose = findViewById ( R . id . ll_close ) ; mIvClose = findViewById ( R . id . iv_close ) ; } @ Override protected void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; setCancelable ( false ) ; setCanceledOnTouchOutside ( false ) ; setIsSyncSystemUiVisibility ( true ) ; } private String getUrl ( ) { return mPrompterProxy != null ? mPrompterProxy . getUrl ( ) : \"<STR_LIT>\" ; } @ Override public void show ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; super . show ( ) ; } @ Override public void dismiss ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ;", "output": "clearIPrompterProxy ( ) ; super . dismiss ( ) ; } private void clearIPrompterProxy ( ) { if ( mPrompterProxy != null ) { mPrompterProxy . recycle ( ) ; mPrompterProxy = null ; } } public UpdateDialog setUpdateEntity ( UpdateEntity updateEntity ) { mUpdateEntity = updateEntity ; initUpdateInfo ( mUpdateEntity ) ; return this ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( getContext ( ) , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor , float widthRatio , float heightRatio ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( getContext ( ) , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor , widthRatio , heightRatio ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor , float widthRatio , float heightRatio ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; initWindow ( widthRatio , heightRatio ) ; } private void initWindow ( float widthRatio , float heightRatio ) { Window window = getWindow ( ) ; if ( window == null ) { return ; } WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getContext ( ) . getResources ( ) . getDisplayMetrics ( ) ; if ( widthRatio > <NUM_LIT> && widthRatio < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * widthRatio ) ; } if ( heightRatio > <NUM_LIT> && heightRatio < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * heightRatio ) ; } window . setAttributes ( lp ) ; } private UpdateDialog setIPrompterProxy ( IPrompterProxy prompterProxy ) { mPrompterProxy = prompterProxy ; return this ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( getContext ( ) , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( ( Activity ) getContext ( ) , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { mPrompterProxy . backgroundDownload ( ) ; dismiss ( ) ; } else if ( i == R . id . iv_close ) { mPrompterProxy . cancelDownload ( ) ; dismiss ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( getContext ( ) , mUpdateEntity . getVersionName ( ) ) ; dismiss ( ) ; } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismiss ( ) ; } else { showInstallButton ( ) ; } } else { if ( mPrompterProxy != null ) { mPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( isShowing ( ) ) { doStart ( ) ; } } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( isShowing ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( isShowing ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismiss ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( isShowing ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismiss ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } @ Override public void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; } @ Override public void onDetachedFromWindow ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; super . onDetachedFromWindow ( ) ; } }"}, {"input": "package com . appspa . update . proxy . impl ; import android . text . TextUtils ; import com . appspa . update . utils . Md5Utils ; import com . appspa . update . proxy . IFileEncryptor ; import java . io . File ; public class DefaultFileEncryptor implements IFileEncryptor { @ Override public String encryptFile ( File file ) { return Md5Utils . getFileMD5 ( file ) ; } @ Override public boolean isFileValid ( String encrypt , File file ) { return TextUtils . isEmpty ( encrypt ) || encrypt . equalsIgnoreCase ( encryptFile ( file ) ) ;", "output": "} }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import android . content . pm . PackageInfo ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( value = \"<STR_LIT>\" ) public interface IWebViewProviderResponse { @ Field ( value = \"<STR_LIT>\" ) void setPackageInfo ( PackageInfo packageInfo ) ; @ Field ( value = \"<STR_LIT>\" ) PackageInfo getPackageInfo ( ) ;", "output": "}"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class SortedList < T > { public static final int INVALID_POSITION = - <NUM_LIT> ; private static final int MIN_CAPACITY = <NUM_LIT> ; private static final int CAPACITY_GROWTH = MIN_CAPACITY ; private static final int INSERTION = <NUM_LIT> ; private static final int DELETION = <NUM_LIT> << <NUM_LIT> ; private static final int LOOKUP = <NUM_LIT> << <NUM_LIT> ; T [ ] mData ; private T [ ] mOldData ; private int mOldDataStart ; private int mOldDataSize ; private int mNewDataStart ; private Callback mCallback ; private BatchedCallback mBatchedCallback ; private int mSize ; private final Class < T > mTClass ; public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback ) { this ( klass , callback , MIN_CAPACITY ) ; } public SortedList ( @ NonNull Class < T > klass , @ NonNull Callback < T > callback , int initialCapacity ) { mTClass = klass ; mData = ( T [ ] ) Array . newInstance ( klass , initialCapacity ) ; mCallback = callback ; mSize = <NUM_LIT> ; } public int size ( ) { return mSize ; } public int add ( T item ) { throwIfInMutationOperation ( ) ; return add ( item , true ) ; } public void addAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( items . length == <NUM_LIT> ) { return ; } if ( mayModifyInput ) { addAllInternal ( items ) ; } else { addAllInternal ( copyArray ( items ) ) ; } } public void addAll ( @ NonNull T ... items ) { addAll ( items , false ) ; } public void addAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; addAll ( items . toArray ( copy ) , true ) ; } public void replaceAll ( @ NonNull T [ ] items , boolean mayModifyInput ) { throwIfInMutationOperation ( ) ; if ( mayModifyInput ) { replaceAllInternal ( items ) ; } else { replaceAllInternal ( copyArray ( items ) ) ; } } public void replaceAll ( @ NonNull T ... items ) { replaceAll ( items , false ) ; } public void replaceAll ( @ NonNull Collection < T > items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . size ( ) ) ; replaceAll ( items . toArray ( copy ) , true ) ; } private void addAllInternal ( T [ ] newItems ) { if ( newItems . length < <NUM_LIT> ) { return ; } final int newSize = sortAndDedup ( newItems ) ; if ( mSize == <NUM_LIT> ) { mData = newItems ; mSize = newSize ; mCallback . onInserted ( <NUM_LIT> , newSize ) ; } else { merge ( newItems , newSize ) ; } } private void replaceAllInternal ( @ NonNull T [ ] newData ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; mOldData = mData ; mNewDataStart = <NUM_LIT> ; int newSize = sortAndDedup ( newData ) ; mData = ( T [ ] ) Array . newInstance ( mTClass , newSize ) ; while ( mNewDataStart < newSize || mOldDataStart < mOldDataSize ) { if ( mOldDataStart >= mOldDataSize ) { int insertIndex = mNewDataStart ; int itemCount = newSize - mNewDataStart ; System . arraycopy ( newData , insertIndex , mData , insertIndex , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( insertIndex , itemCount ) ; break ; } if ( mNewDataStart >= newSize ) { int itemCount = mOldDataSize - mOldDataStart ; mSize -= itemCount ; mCallback . onRemoved ( mNewDataStart , itemCount ) ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ mNewDataStart ] ; int result = mCallback . compare ( oldItem , newItem ) ; if ( result < <NUM_LIT> ) { replaceAllRemove ( ) ; } else if ( result > <NUM_LIT> ) { replaceAllInsert ( newItem ) ; } else { if ( ! mCallback . areItemsTheSame ( oldItem , newItem ) ) { replaceAllRemove ( ) ; replaceAllInsert ( newItem ) ; } else { mData [ mNewDataStart ] = newItem ; mOldDataStart ++ ; mNewDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void replaceAllInsert ( T newItem ) { mData [ mNewDataStart ] = newItem ; mNewDataStart ++ ; mSize ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } private void replaceAllRemove ( ) { mSize -- ; mOldDataStart ++ ; mCallback . onRemoved ( mNewDataStart , <NUM_LIT> ) ; } private int sortAndDedup ( @ NonNull T [ ] items ) { if ( items . length == <NUM_LIT> ) { return <NUM_LIT> ; } Arrays . sort ( items , mCallback ) ; int rangeStart = <NUM_LIT> ; int rangeEnd = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < items . length ; ++ i ) { T currentItem = items [ i ] ; int compare = mCallback . compare ( items [ rangeStart ] , currentItem ) ; if ( compare == <NUM_LIT> ) { final int sameItemPos = findSameItem ( currentItem , items , rangeStart , rangeEnd ) ; if ( sameItemPos != INVALID_POSITION ) { items [ sameItemPos ] = currentItem ; } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeEnd ++ ; } } else { if ( rangeEnd != i ) { items [ rangeEnd ] = currentItem ; } rangeStart = rangeEnd ++ ; } } return rangeEnd ; } private int findSameItem ( T item , T [ ] items , int from , int to ) { for ( int pos = from ; pos < to ; pos ++ ) { if ( mCallback . areItemsTheSame ( items [ pos ] , item ) ) { return pos ; } } return INVALID_POSITION ; } private void merge ( T [ ] newData , int newDataSize ) { final boolean forceBatchedUpdates = ! ( mCallback instanceof BatchedCallback ) ; if ( forceBatchedUpdates ) { beginBatchedUpdates ( ) ; } mOldData = mData ; mOldDataStart = <NUM_LIT> ; mOldDataSize = mSize ; final int mergedCapacity = mSize + newDataSize + CAPACITY_GROWTH ; mData = ( T [ ] ) Array . newInstance ( mTClass , mergedCapacity ) ; mNewDataStart = <NUM_LIT> ; int newDataStart = <NUM_LIT> ; while ( mOldDataStart < mOldDataSize || newDataStart < newDataSize ) { if ( mOldDataStart == mOldDataSize ) { int itemCount = newDataSize - newDataStart ; System . arraycopy ( newData , newDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; mSize += itemCount ; mCallback . onInserted ( mNewDataStart - itemCount , itemCount ) ; break ; } if ( newDataStart == newDataSize ) { int itemCount = mOldDataSize - mOldDataStart ; System . arraycopy ( mOldData , mOldDataStart , mData , mNewDataStart , itemCount ) ; mNewDataStart += itemCount ; break ; } T oldItem = mOldData [ mOldDataStart ] ; T newItem = newData [ newDataStart ] ; int compare = mCallback . compare ( oldItem , newItem ) ; if ( compare > <NUM_LIT> ) { mData [ mNewDataStart ++ ] = newItem ; mSize ++ ; newDataStart ++ ; mCallback . onInserted ( mNewDataStart - <NUM_LIT> , <NUM_LIT> ) ; } else if ( compare == <NUM_LIT> && mCallback . areItemsTheSame ( oldItem , newItem ) ) { mData [ mNewDataStart ++ ] = newItem ; newDataStart ++ ; mOldDataStart ++ ; if ( ! mCallback . areContentsTheSame ( oldItem , newItem ) ) { mCallback . onChanged ( mNewDataStart - <NUM_LIT> , <NUM_LIT> , mCallback . getChangePayload ( oldItem , newItem ) ) ; } } else { mData [ mNewDataStart ++ ] = oldItem ; mOldDataStart ++ ; } } mOldData = null ; if ( forceBatchedUpdates ) { endBatchedUpdates ( ) ; } } private void throwIfInMutationOperation ( ) { if ( mOldData != null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } public void beginBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { return ; } if ( mBatchedCallback == null ) { mBatchedCallback = new BatchedCallback ( mCallback ) ; } mCallback = mBatchedCallback ; } public void endBatchedUpdates ( ) { throwIfInMutationOperation ( ) ; if ( mCallback instanceof BatchedCallback ) { ( ( BatchedCallback ) mCallback ) . dispatchLastEvent ( ) ; } if ( mCallback == mBatchedCallback ) { mCallback = mBatchedCallback . mWrappedCallback ; } } private int add ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , INSERTION ) ; if ( index == INVALID_POSITION ) { index = <NUM_LIT> ; } else if ( index < mSize ) { T existing = mData [ index ] ; if ( mCallback . areItemsTheSame ( existing , item ) ) { if ( mCallback . areContentsTheSame ( existing , item ) ) {", "output": "mData [ index ] = item ; return index ; } else { mData [ index ] = item ; mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; return index ; } } } addToData ( index , item ) ; if ( notify ) { mCallback . onInserted ( index , <NUM_LIT> ) ; } return index ; } public boolean remove ( T item ) { throwIfInMutationOperation ( ) ; return remove ( item , true ) ; } public T removeItemAt ( int index ) { throwIfInMutationOperation ( ) ; T item = get ( index ) ; removeItemAtIndex ( index , true ) ; return item ; } private boolean remove ( T item , boolean notify ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mSize , DELETION ) ; if ( index == INVALID_POSITION ) { return false ; } removeItemAtIndex ( index , notify ) ; return true ; } private void removeItemAtIndex ( int index , boolean notify ) { System . arraycopy ( mData , index + <NUM_LIT> , mData , index , mSize - index - <NUM_LIT> ) ; mSize -- ; mData [ mSize ] = null ; if ( notify ) { mCallback . onRemoved ( index , <NUM_LIT> ) ; } } public void updateItemAt ( int index , T item ) { throwIfInMutationOperation ( ) ; final T existing = get ( index ) ; boolean contentsChanged = existing == item || ! mCallback . areContentsTheSame ( existing , item ) ; if ( existing != item ) { final int cmp = mCallback . compare ( existing , item ) ; if ( cmp == <NUM_LIT> ) { mData [ index ] = item ; if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } return ; } } if ( contentsChanged ) { mCallback . onChanged ( index , <NUM_LIT> , mCallback . getChangePayload ( existing , item ) ) ; } removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public void recalculatePositionOfItemAt ( int index ) { throwIfInMutationOperation ( ) ; final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index != newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } public T get ( int index ) throws IndexOutOfBoundsException { if ( index >= mSize || index < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mOldData != null ) { if ( index >= mNewDataStart ) { return mOldData [ index - mNewDataStart + mOldDataStart ] ; } } return mData [ index ] ; } public int indexOf ( T item ) { if ( mOldData != null ) { int index = findIndexOf ( item , mData , <NUM_LIT> , mNewDataStart , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index ; } index = findIndexOf ( item , mOldData , mOldDataStart , mOldDataSize , LOOKUP ) ; if ( index != INVALID_POSITION ) { return index - mOldDataStart + mNewDataStart ; } return INVALID_POSITION ; } return findIndexOf ( item , mData , <NUM_LIT> , mSize , LOOKUP ) ; } private int findIndexOf ( T item , T [ ] mData , int left , int right , int reason ) { while ( left < right ) { final int middle = ( left + right ) / <NUM_LIT> ; T myItem = mData [ middle ] ; final int cmp = mCallback . compare ( myItem , item ) ; if ( cmp < <NUM_LIT> ) { left = middle + <NUM_LIT> ; } else if ( cmp == <NUM_LIT> ) { if ( mCallback . areItemsTheSame ( myItem , item ) ) { return middle ; } else { int exact = linearEqualitySearch ( item , middle , left , right ) ; if ( reason == INSERTION ) { return exact == INVALID_POSITION ? middle : exact ; } else { return exact ; } } } else { right = middle ; } } return reason == INSERTION ? left : INVALID_POSITION ; } private int linearEqualitySearch ( T item , int middle , int left , int right ) { for ( int next = middle - <NUM_LIT> ; next >= left ; next -- ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } for ( int next = middle + <NUM_LIT> ; next < right ; next ++ ) { T nextItem = mData [ next ] ; int cmp = mCallback . compare ( nextItem , item ) ; if ( cmp != <NUM_LIT> ) { break ; } if ( mCallback . areItemsTheSame ( nextItem , item ) ) { return next ; } } return INVALID_POSITION ; } private void addToData ( int index , T item ) { if ( index > mSize ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + mSize ) ; } if ( mSize == mData . length ) { T [ ] newData = ( T [ ] ) Array . newInstance ( mTClass , mData . length + CAPACITY_GROWTH ) ; System . arraycopy ( mData , <NUM_LIT> , newData , <NUM_LIT> , index ) ; newData [ index ] = item ; System . arraycopy ( mData , index , newData , index + <NUM_LIT> , mSize - index ) ; mData = newData ; } else { System . arraycopy ( mData , index , mData , index + <NUM_LIT> , mSize - index ) ; mData [ index ] = item ; } mSize ++ ; } private T [ ] copyArray ( T [ ] items ) { T [ ] copy = ( T [ ] ) Array . newInstance ( mTClass , items . length ) ; System . arraycopy ( items , <NUM_LIT> , copy , <NUM_LIT> , items . length ) ; return copy ; } public void clear ( ) { throwIfInMutationOperation ( ) ; if ( mSize == <NUM_LIT> ) { return ; } final int prevSize = mSize ; Arrays . fill ( mData , <NUM_LIT> , prevSize , null ) ; mSize = <NUM_LIT> ; mCallback . onRemoved ( <NUM_LIT> , prevSize ) ; } public static abstract class Callback < T2 > implements Comparator < T2 > , ListUpdateCallback { @ Override abstract public int compare ( T2 o1 , T2 o2 ) ; abstract public void onChanged ( int position , int count ) ; @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { onChanged ( position , count ) ; } abstract public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) ; abstract public boolean areItemsTheSame ( T2 item1 , T2 item2 ) ; @ Nullable public Object getChangePayload ( T2 item1 , T2 item2 ) { return null ; } } public static class BatchedCallback < T2 > extends Callback < T2 > { final Callback < T2 > mWrappedCallback ; private final BatchingListUpdateCallback mBatchingListUpdateCallback ; @ SuppressLint ( \"<STR_LIT>\" ) public BatchedCallback ( Callback < T2 > wrappedCallback ) { mWrappedCallback = wrappedCallback ; mBatchingListUpdateCallback = new BatchingListUpdateCallback ( mWrappedCallback ) ; } @ Override public int compare ( T2 o1 , T2 o2 ) { return mWrappedCallback . compare ( o1 , o2 ) ; } @ Override public void onInserted ( int position , int count ) { mBatchingListUpdateCallback . onInserted ( position , count ) ; } @ Override public void onRemoved ( int position , int count ) { mBatchingListUpdateCallback . onRemoved ( position , count ) ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { mBatchingListUpdateCallback . onMoved ( fromPosition , toPosition ) ; } @ Override public void onChanged ( int position , int count ) { mBatchingListUpdateCallback . onChanged ( position , count , null ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { mBatchingListUpdateCallback . onChanged ( position , count , payload ) ; } @ Override public boolean areContentsTheSame ( T2 oldItem , T2 newItem ) { return mWrappedCallback . areContentsTheSame ( oldItem , newItem ) ; } @ Override public boolean areItemsTheSame ( T2 item1 , T2 item2 ) { return mWrappedCallback . areItemsTheSame ( item1 , item2 ) ; } @ Nullable @ Override public Object getChangePayload ( T2 item1 , T2 item2 ) { return mWrappedCallback . getChangePayload ( item1 , item2 ) ; } public void dispatchLastEvent ( ) { mBatchingListUpdateCallback . dispatchLastEvent ( ) ; } } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import static androidx . fluidviewpager2 . widget . ViewPager2 . ORIENTATION_HORIZONTAL ; import android . os . SystemClock ; import android . view . MotionEvent ; import android . view . VelocityTracker ; import android . view . ViewConfiguration ; import androidx . annotation . UiThread ; import androidx . fluidrecyclerview . widget . RecyclerView ; final class FakeDrag { private final androidx . fluidviewpager2 . widget . ViewPager2 mViewPager ; private final androidx . fluidviewpager2 . widget . ScrollEventAdapter mScrollEventAdapter ; private final RecyclerView mRecyclerView ; private VelocityTracker mVelocityTracker ; private int mMaximumVelocity ; private float mRequestedDragDistance ; private int mActualDraggedDistance ; private long mFakeDragBeginTime ; FakeDrag ( ViewPager2 viewPager , androidx . fluidviewpager2 . widget . ScrollEventAdapter scrollEventAdapter , RecyclerView recyclerView ) { mViewPager = viewPager ; mScrollEventAdapter = scrollEventAdapter ; mRecyclerView = recyclerView ; } boolean isFakeDragging ( ) { return mScrollEventAdapter . isFakeDragging ( ) ; } @ UiThread boolean beginFakeDrag ( ) { if ( mScrollEventAdapter . isDragging ( ) ) { return false ;", "output": "} mRequestedDragDistance = mActualDraggedDistance = <NUM_LIT> ; mFakeDragBeginTime = SystemClock . uptimeMillis ( ) ; beginFakeVelocityTracker ( ) ; mScrollEventAdapter . notifyBeginFakeDrag ( ) ; if ( ! mScrollEventAdapter . isIdle ( ) ) { mRecyclerView . stopScroll ( ) ; } addFakeMotionEvent ( mFakeDragBeginTime , MotionEvent . ACTION_DOWN , <NUM_LIT> , <NUM_LIT> ) ; return true ; } @ UiThread boolean fakeDragBy ( float offsetPxFloat ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mRequestedDragDistance -= offsetPxFloat ; int offsetPx = Math . round ( mRequestedDragDistance - mActualDraggedDistance ) ; mActualDraggedDistance += offsetPx ; long time = SystemClock . uptimeMillis ( ) ; boolean isHorizontal = mViewPager . getOrientation ( ) == ORIENTATION_HORIZONTAL ; final int offsetX = isHorizontal ? offsetPx : <NUM_LIT> ; final int offsetY = isHorizontal ? <NUM_LIT> : offsetPx ; final float x = isHorizontal ? mRequestedDragDistance : <NUM_LIT> ; final float y = isHorizontal ? <NUM_LIT> : mRequestedDragDistance ; mRecyclerView . scrollBy ( offsetX , offsetY ) ; addFakeMotionEvent ( time , MotionEvent . ACTION_MOVE , x , y ) ; return true ; } @ UiThread boolean endFakeDrag ( ) { if ( ! mScrollEventAdapter . isFakeDragging ( ) ) { return false ; } mScrollEventAdapter . notifyEndFakeDrag ( ) ; final int pixelsPerSecond = <NUM_LIT> ; final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( pixelsPerSecond , mMaximumVelocity ) ; int xVelocity = ( int ) velocityTracker . getXVelocity ( ) ; int yVelocity = ( int ) velocityTracker . getYVelocity ( ) ; if ( ! mRecyclerView . fling ( xVelocity , yVelocity ) ) { mViewPager . snapToPage ( ) ; } return true ; } private void beginFakeVelocityTracker ( ) { if ( mVelocityTracker == null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; final ViewConfiguration configuration = ViewConfiguration . get ( mViewPager . getContext ( ) ) ; mMaximumVelocity = configuration . getScaledMaximumFlingVelocity ( ) ; } else { mVelocityTracker . clear ( ) ; } } private void addFakeMotionEvent ( long time , int action , float x , float y ) { final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , action , x , y , <NUM_LIT> ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; } }"}, {"input": "package icu . freedomIntrovert . async ; public abstract class BackstageTask < T extends EventHandler > implements Runnable { private final T handle ; public BackstageTask ( T handle ) { this . handle = handle ; } @ Override public void run ( ) { try { onStart ( handle ) ; } catch ( Throwable e ) { handle . sendError ( e ) ; } } public void execute ( ) { TaskManger . execute ( this ) ; }", "output": "protected abstract void onStart ( T eventHandler ) throws Throwable ; protected void sleep ( long time ) { try { Thread . sleep ( time ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . os . Bundle ; import android . view . MenuItem ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . recyclerview . widget . LinearLayoutManager ; import androidx . recyclerview . widget . RecyclerView ; public class PendingCheckCommentsActivity extends AppCompatActivity { RecyclerView recyclerView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ;", "output": "setContentView ( R . layout . activity_pending_check_comments ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; } LinearLayoutManager layoutManager = new LinearLayoutManager ( this ) ; layoutManager . setOrientation ( LinearLayoutManager . VERTICAL ) ; recyclerView = findViewById ( R . id . recycler_view ) ; recyclerView . setLayoutManager ( layoutManager ) ; recyclerView . setAdapter ( new PendingCommentListAdapter ( this ) ) ; } @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; break ; } return true ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . graphics . Color ; import android . net . Uri ; import android . os . Bundle ; import android . text . Html ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import androidx . activity . EdgeToEdge ; import androidx . activity . OnBackPressedCallback ; import androidx . activity . SystemBarStyle ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import androidx . coordinatorlayout . widget . CoordinatorLayout ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . fragment . app . FragmentTransaction ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . simon . harmonichackernews . data . CommentsScrollProgress ; import com . simon . harmonichackernews . data . Story ; import com . simon . harmonichackernews . utils . Changelog ; import com . simon . harmonichackernews . utils . FoldableSplitInitializer ; import com . simon . harmonichackernews . utils . SettingsUtils ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import java . util . ArrayList ; public class MainActivity extends BaseActivity implements StoriesFragment . StoryClickListener { public static ArrayList < CommentsScrollProgress > commentsScrollProgresses = new ArrayList < > ( ) ; int lastPosition = <NUM_LIT> ; public OnBackPressedCallback backPressedCallback ; public int bottom = <NUM_LIT> ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( Utils . isFirstAppStart ( this ) ) { startActivity ( new Intent ( this , WelcomeActivity . class ) ) ; finish ( ) ; } ThemeUtils . setupTheme ( this ) ; setContentView ( R . layout . activity_main ) ; updateFragmentLayout ( ) ; if ( Utils . justUpdated ( this ) && SettingsUtils . shouldShowChangelog ( this ) ) { showUpdateDialog ( ) ; } backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { final StoriesFragment fragment = ( StoriesFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . main_fragment_stories_container ) ; if ( fragment != null ) { fragment . exitSearch ( ) ; } } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; backPressedCallback . setEnabled ( false ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; updateFragmentLayout ( ) ; } @ Override public void openStory ( Story story , int pos , boolean showWebsite ) { Bundle bundle = story . toBundle ( ) ; bundle . putInt ( CommentsFragment . EXTRA_FORWARD , pos - lastPosition ) ; bundle . putBoolean ( CommentsFragment . EXTRA_SHOW_WEBSITE , showWebsite ) ; if ( FoldableSplitInitializer . isSplitSupported ( this ) ) { bundle . putBoolean ( CommentsActivity . PREVENT_BACK , true ) ; } lastPosition = pos ; if ( Utils . isTablet ( getResources ( ) ) ) { CommentsFragment fragment = new CommentsFragment ( ) ; fragment . setArguments ( bundle ) ; FragmentTransaction transaction = getSupportFragmentManager ( ) . beginTransaction ( ) ; transaction . replace ( R . id . main_fragment_comments_container , fragment ) ; transaction . commit ( ) ; } else { Intent intent = new Intent ( getApplicationContext ( ) , CommentsActivity . class ) ; intent . putExtras ( bundle ) ; startActivity ( intent ) ; if ( ! SettingsUtils . shouldDisableCommentsSwipeBack ( getApplicationContext ( ) ) ) {", "output": "overridePendingTransition ( R . anim . activity_in_animation , R . anim . hold ) ; } } } private void updateFragmentLayout ( ) { if ( Utils . isTablet ( getResources ( ) ) && findViewById ( R . id . main_fragments_container ) != null ) { LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( <NUM_LIT> , ViewGroup . LayoutParams . MATCH_PARENT , getResources ( ) . getInteger ( R . integer . stories_pane_weight ) ) ; findViewById ( R . id . main_fragment_stories_container ) . setLayoutParams ( params ) ; int extraPadding = getResources ( ) . getDimensionPixelSize ( R . dimen . extra_pane_padding ) ; findViewById ( R . id . main_fragments_container ) . setPadding ( extraPadding , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } } private void showUpdateDialog ( ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( Html . fromHtml ( Changelog . getHTML ( ) ) ) . setNeutralButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { String url = \"<STR_LIT>\" ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , null ) . create ( ) ; dialog . show ( ) ; } }"}, {"input": "package org . woheller69 . weather . database ; import android . content . Context ; public class WeekForecast { public static final float NO_RAIN_VALUE = <NUM_LIT> ; private int id ; private int city_id ; private long timestamp ; private long forecastFor ; private int weatherID ; private float temperature ; private float temperature_min ; private float temperature_max ; private float humidity ; private float pressure ; private float precipitation ; private float wind_speed ; private float wind_direction ; private float uv_index ; private long timeSunrise ; private long timeSunset ; private float sunshineHours ; public WeekForecast ( ) { } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public long getForecastTime ( ) { return forecastFor ; }", "output": "public long getLocalForecastTime ( Context context ) { SQLiteHelper dbhelper = SQLiteHelper . getInstance ( context ) ; int timezoneseconds = dbhelper . getCurrentWeatherByCityId ( city_id ) . getTimeZoneSeconds ( ) ; return forecastFor + timezoneseconds * <NUM_LIT> ; } public void setForecastTime ( long forecastFor ) { this . forecastFor = forecastFor ; } public long getTimestamp ( ) { return timestamp ; } public void setTimestamp ( long timestamp ) { this . timestamp = timestamp ; } public int getCity_id ( ) { return city_id ; } public void setCity_id ( int city_id ) { this . city_id = city_id ; } public int getWeatherID ( ) { return weatherID ; } public void setWeatherID ( int weatherID ) { this . weatherID = weatherID ; } public float getTemperature ( ) { return temperature ; } public void setTemperature ( float temperature ) { this . temperature = temperature ; } public float getMinTemperature ( ) { return temperature_min ; } public void setMinTemperature ( float temperature_min ) { this . temperature_min = temperature_min ; } public float getMaxTemperature ( ) { return temperature_max ; } public void setMaxTemperature ( float temperature_max ) { this . temperature_max = temperature_max ; } public float getHumidity ( ) { return humidity ; } public void setHumidity ( float humidity ) { this . humidity = humidity ; } public float getPressure ( ) { return pressure ; } public void setPressure ( float pressure ) { this . pressure = pressure ; } public float getPrecipitation ( ) { return precipitation ; } public void setPrecipitation ( float precipitation ) { this . precipitation = precipitation ; } public float getWind_speed ( ) { return wind_speed ; } public void setWind_speed ( float wind_speed ) { this . wind_speed = wind_speed ; } public float getWind_direction ( ) { return wind_direction ; } public void setWind_direction ( float wind_direction ) { this . wind_direction = wind_direction ; } public float getUv_index ( ) { return uv_index ; } public void setUv_index ( float uv_index ) { this . uv_index = uv_index ; } public long getTimeSunrise ( ) { return timeSunrise ; } public void setTimeSunrise ( long timeSunrise ) { this . timeSunrise = timeSunrise ; } public long getTimeSunset ( ) { return timeSunset ; } public void setTimeSunset ( long timeSunset ) { this . timeSunset = timeSunset ; } public float getSunshineHours ( ) { return sunshineHours ; } public void setSunshineHours ( float sunshineHours ) { this . sunshineHours = sunshineHours ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; public class WebViewLoginByDeputyActivity extends WebViewLoginActivity { @ Override protected void onCookieSet ( String cookie ) { config . setDeputyCookie ( cookie ) ; }", "output": "}"}, {"input": "package external . org . apache . commons . lang3 . reflect ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import external . org . apache . commons . lang3 . ArrayUtils ; import external . org . apache . commons . lang3 . ClassUtils ; public class MethodUtils { public MethodUtils ( ) { super ( ) ; } public static Object invokeMethod ( Object object , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeMethod ( object , methodName , args , parameterTypes ) ; } public static Object invokeMethod ( Object object , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } Method method = getMatchingAccessibleMethod ( object . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + object . getClass ( ) . getName ( ) ) ; } return method . invoke ( object , args ) ; } public static Object invokeExactMethod ( Object object , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeExactMethod ( object , methodName , args , parameterTypes ) ; } public static Object invokeExactMethod ( Object object , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ;", "output": "} if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } Method method = getAccessibleMethod ( object . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + object . getClass ( ) . getName ( ) ) ; } return method . invoke ( object , args ) ; } public static Object invokeExactStaticMethod ( Class < ? > cls , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } Method method = getAccessibleMethod ( cls , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + cls . getName ( ) ) ; } return method . invoke ( null , args ) ; } public static Object invokeStaticMethod ( Class < ? > cls , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeStaticMethod ( cls , methodName , args , parameterTypes ) ; } public static Object invokeStaticMethod ( Class < ? > cls , String methodName , Object [ ] args , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } Method method = getMatchingAccessibleMethod ( cls , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + cls . getName ( ) ) ; } return method . invoke ( null , args ) ; } public static Object invokeExactStaticMethod ( Class < ? > cls , String methodName , Object ... args ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } int arguments = args . length ; Class < ? > [ ] parameterTypes = new Class [ arguments ] ; for ( int i = <NUM_LIT> ; i < arguments ; i ++ ) { parameterTypes [ i ] = args [ i ] . getClass ( ) ; } return invokeExactStaticMethod ( cls , methodName , args , parameterTypes ) ; } public static Method getAccessibleMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } } public static Method getAccessibleMethod ( Method method ) { if ( ! MemberUtils . isAccessible ( method ) ) { return null ; } Class < ? > cls = method . getDeclaringClass ( ) ; if ( Modifier . isPublic ( cls . getModifiers ( ) ) ) { return method ; } String methodName = method . getName ( ) ; Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; method = getAccessibleMethodFromInterfaceNest ( cls , methodName , parameterTypes ) ; if ( method == null ) { method = getAccessibleMethodFromSuperclass ( cls , methodName , parameterTypes ) ; } return method ; } private static Method getAccessibleMethodFromSuperclass ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { Class < ? > parentClass = cls . getSuperclass ( ) ; while ( parentClass != null ) { if ( Modifier . isPublic ( parentClass . getModifiers ( ) ) ) { try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } } parentClass = parentClass . getSuperclass ( ) ; } return null ; } private static Method getAccessibleMethodFromInterfaceNest ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { Method method = null ; for ( ; cls != null ; cls = cls . getSuperclass ( ) ) { Class < ? > [ ] interfaces = cls . getInterfaces ( ) ; for ( int i = <NUM_LIT> ; i < interfaces . length ; i ++ ) { if ( ! Modifier . isPublic ( interfaces [ i ] . getModifiers ( ) ) ) { continue ; } try { method = interfaces [ i ] . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { } if ( method != null ) { break ; } method = getAccessibleMethodFromInterfaceNest ( interfaces [ i ] , methodName , parameterTypes ) ; if ( method != null ) { break ; } } } return method ; } public static Method getMatchingAccessibleMethod ( Class < ? > cls , String methodName , Class < ? > ... parameterTypes ) { try { Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( NoSuchMethodException e ) { } Method bestMatch = null ; Method [ ] methods = cls . getMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && ClassUtils . isAssignable ( parameterTypes , method . getParameterTypes ( ) , true ) ) { Method accessibleMethod = getAccessibleMethod ( method ) ; if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareParameterTypes ( accessibleMethod . getParameterTypes ( ) , bestMatch . getParameterTypes ( ) , parameterTypes ) < <NUM_LIT> ) ) { bestMatch = accessibleMethod ; } } } if ( bestMatch != null ) { MemberUtils . setAccessibleWorkaround ( bestMatch ) ; } return bestMatch ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class IntentTransferStationHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Bundle . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable {", "output": "super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; positioningActivity ( activity , activity . getIntent ( ) , classLoader ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; positioningActivity ( ( Activity ) param . thisObject , ( Intent ) param . args [ <NUM_LIT> ] , classLoader ) ; } } ) ; } private void positioningActivity ( Activity activity , Intent intent , ClassLoader classLoader ) throws ClassNotFoundException { Bundle extras = intent . getExtras ( ) ; if ( extras == null ) { return ; } String transferActivity = extras . getString ( \"<STR_LIT>\" ) ; if ( transferActivity == null ) { return ; } Bundle transferExtras = extras . getBundle ( \"<STR_LIT>\" ) ; Intent newIntent = new Intent ( activity , classLoader . loadClass ( transferActivity ) ) ; String transferUri = extras . getString ( \"<STR_LIT>\" , null ) ; if ( transferUri != null ) { newIntent . setData ( Uri . parse ( transferUri ) ) ; } if ( transferExtras != null ) { newIntent . putExtras ( transferExtras ) ; } activity . startActivity ( newIntent ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Intent ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . ImageButton ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; import androidx . recyclerview . widget . RecyclerView ; public class TabConfListAdapter extends RecyclerView . Adapter < TabConfListAdapter . ViewHolder > { private TabConfActivity tabConfActivity ; public TabConfListAdapter ( TabConfActivity tabConfActivity ) { this . tabConfActivity = tabConfActivity ; } public static class ViewHolder extends RecyclerView . ViewHolder { private TextView tvTitle , tvPrompt ; private LinearLayout llOuter ; public ViewHolder ( View itemView ) { super ( itemView ) ; tvTitle = itemView . findViewById ( R . id . tv_list_item_title ) ; tvPrompt = itemView . findViewById ( R . id . tv_list_item_prompt ) ; llOuter = itemView . findViewById ( R . id . ll_list_item_outer ) ; llOuter . setOnClickListener ( null ) ; llOuter . setOnClickListener ( view -> { PromptTabData tab = GlobalDataHolder . getTabDataList ( ) . get ( getAdapterPosition ( ) ) ; Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; broadcastIntent . putExtra ( \"<STR_LIT>\" , tab . getTitle ( ) ) ; broadcastIntent . putExtra ( \"<STR_LIT>\" , tab . getPrompt ( ) ) ; broadcastIntent . putExtra ( \"<STR_LIT>\" , getAdapterPosition ( ) ) ; LocalBroadcastManager . getInstance ( view . getContext ( ) ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + tab . getTitle ( ) + \"<STR_LIT>\" + getAdapterPosition ( ) ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + GlobalDataHolder . getTabDataList ( ) . get ( <NUM_LIT> ) . getTitle ( ) ) ; } ) ; } } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . tab_conf_list_item , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { PromptTabData tab = GlobalDataHolder . getTabDataList ( ) . get ( position ) ; holder . tvTitle . setText ( tab . getTitle ( ) ) ; holder . tvPrompt . setText ( tab . getContentWithoutParams ( ) ) ; } @ Override public int getItemCount ( ) {", "output": "return GlobalDataHolder . getTabDataList ( ) . size ( ) ; } }"}, {"input": "package androidx . fluidviewpager2 . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Px ; import androidx . fluidviewpager2 . widget . ViewPager2 . OnPageChangeCallback ; import java . util . ArrayList ; import java . util . ConcurrentModificationException ; import java . util . List ; final class CompositeOnPageChangeCallback extends OnPageChangeCallback { @ NonNull private final List < OnPageChangeCallback > mCallbacks ; CompositeOnPageChangeCallback ( int initialCapacity ) { mCallbacks = new ArrayList < > ( initialCapacity ) ; } void addOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . add ( callback ) ; } void removeOnPageChangeCallback ( OnPageChangeCallback callback ) { mCallbacks . remove ( callback ) ; } @ Override public void onPageScrolled ( int position , float positionOffset , @ Px int positionOffsetPixels ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrolled ( position , positionOffset , positionOffsetPixels ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; }", "output": "} @ Override public void onPageSelected ( int position ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageSelected ( position ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } @ Override public void onPageScrollStateChanged ( @ ViewPager2 . ScrollState int state ) { try { for ( OnPageChangeCallback callback : mCallbacks ) { callback . onPageScrollStateChanged ( state ) ; } } catch ( ConcurrentModificationException ex ) { throwCallbackListModifiedWhileInUse ( ex ) ; } } private void throwCallbackListModifiedWhileInUse ( ConcurrentModificationException parent ) { throw new IllegalStateException ( \"<STR_LIT>\" , parent ) ; } }"}, {"input": "package com . norman . webviewup . lib . reflect ; import android . text . TextUtils ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; class ReflectMethod { private final Object mMethodLock = new Object ( ) ; private String mName ; private Class < ? > mClass ; private String mClassName ;", "output": "private Object mObject ; private Class < ? > [ ] mParameterTypes ; private Method mMethod ; private Method assessMethod ; private int staticType ; public ReflectMethod ( Method method ) { this ( null , method ) ; } public ReflectMethod ( Object object , Method method ) { this . mMethod = method ; this . mParameterTypes = method . getParameterTypes ( ) ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public ReflectMethod ( String className , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mClassName = className ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectMethod ( Class < ? > cls , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mClass = cls ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; } public ReflectMethod ( Object object , String name , Class < ? > ... parameterTypes ) { this . mName = name ; this . mParameterTypes = parameterTypes == null ? new Class < ? > [ <NUM_LIT> ] : parameterTypes ; if ( object != null ) { if ( object instanceof Class < ? > ) { this . mClass = ( Class < ? > ) object ; } else { this . mObject = object ; this . mClass = object . getClass ( ) ; } } } public Object invoke ( Object ... args ) throws ReflectException { synchronized ( mMethodLock ) { prepareMethod ( ) ; try { return assessMethod . invoke ( mObject , args ) ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } public void setStaticType ( int staticValue ) { this . staticType = staticValue ; } private void prepareMethod ( ) throws ReflectException { synchronized ( mMethodLock ) { try { if ( assessMethod != null ) { return ; } Method findMethod = mMethod ; if ( findMethod == null ) { String className = null ; String filedName = mName ; if ( ! TextUtils . isEmpty ( mName ) ) { int lastDotIndex = mName . lastIndexOf ( \"<STR_LIT>\" ) ; if ( lastDotIndex >= <NUM_LIT> && lastDotIndex < mName . length ( ) - <NUM_LIT> ) { className = mName . substring ( <NUM_LIT> , lastDotIndex ) ; filedName = mName . substring ( lastDotIndex + <NUM_LIT> ) ; } } if ( className != null ) { try { Class < ? > relfectClass = Class . forName ( className ) ; findMethod = findMethod ( relfectClass , filedName ) ; } catch ( Throwable ignore ) { } } if ( findMethod == null ) { Class < ? > findClass = null ; if ( mClass != null ) { findClass = mClass ; } else if ( mClassName != null ) { findClass = Class . forName ( mClassName ) ; } findMethod = findMethod ( findClass , filedName ) ; } } if ( findMethod == null ) { throw new NoSuchMethodException ( \"<STR_LIT>\" + mName ) ; } int modifiers = findMethod . getModifiers ( ) ; if ( ! Modifier . isPublic ( modifiers ) || ! Modifier . isPublic ( findMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { if ( ! findMethod . isAccessible ( ) ) { findMethod . setAccessible ( true ) ; } } assessMethod = findMethod ; } catch ( Throwable throwable ) { throw new ReflectException ( throwable ) ; } } } private Method findMethod ( Class < ? > findClass , String filedName ) { for ( Class < ? > clazz = findClass ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { try { Method method = clazz . getDeclaredMethod ( filedName , mParameterTypes ) ; boolean staticModifiers = Modifier . isStatic ( method . getModifiers ( ) ) ; if ( ( staticType == <NUM_LIT> && staticModifiers ) || ( staticType == <NUM_LIT> && ! staticModifiers ) ) { continue ; } return method ; } catch ( Throwable ignore ) { } } return null ; } }"}, {"input": "package com . norman . webviewup . lib . service . binder ; import android . os . IBinder ; public abstract class BinderHook { private final Object sync = new Object ( ) ; private IBinder originalBinder ; private ProxyBinder proxyBinder ; private boolean currentHook ; private boolean recentHook ; public BinderHook ( ) { } public final void hook ( ) { synchronized ( sync ) { if ( currentHook ) { return ; } if ( recentHook ) { onProxyBinderReplace ( proxyBinder ) ; } else { IBinder original = onTargetBinderObtain ( ) ; ProxyBinder proxy = onProxyBinderCreate ( original ) ; onProxyBinderReplace ( proxy ) ; this . originalBinder = original ; this . proxyBinder = proxy ; this . recentHook = true ; } currentHook = true ; } } public boolean isHook ( ) { synchronized ( sync ) { return currentHook ; } } public final boolean restore ( ) { synchronized ( sync ) { if ( ! currentHook ) { return false ; } onTargetBinderRestore ( originalBinder ) ; currentHook = false ; return true ; } } protected ProxyBinder getProxyBinder ( ) { return proxyBinder ; } protected abstract IBinder onTargetBinderObtain ( ) ; protected abstract ProxyBinder onProxyBinderCreate ( IBinder binder ) ; protected abstract void onTargetBinderRestore ( IBinder binder ) ;", "output": "protected abstract void onProxyBinderReplace ( ProxyBinder binder ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import androidx . annotation . Nullable ; import androidx . camera . core . CameraSelector ; import com . google . mlkit . vision . barcode . common . Barcode ; public class ScanSettings { @ Barcode . BarcodeFormat public int [ ] formats = new int [ ] { }", "output": "; @ Nullable @ CameraSelector . LensFacing public Integer lensFacing ; }"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . util . Log ; import android . view . View ; import android . view . ViewGroup ; import java . util . ArrayList ; import java . util . List ; class ChildHelper { private static final boolean DEBUG = false ; private static final String TAG = \"<STR_LIT>\" ; final Callback mCallback ; final Bucket mBucket ; final List < View > mHiddenViews ; ChildHelper ( Callback callback ) { mCallback = callback ; mBucket = new Bucket ( ) ; mHiddenViews = new ArrayList < View > ( ) ; } private void hideViewInternal ( View child ) { mHiddenViews . add ( child ) ; mCallback . onEnteredHiddenState ( child ) ; } private boolean unhideViewInternal ( View child ) { if ( mHiddenViews . remove ( child ) ) { mCallback . onLeftHiddenState ( child ) ; return true ; } else { return false ; } } void addView ( View child , boolean hidden ) { addView ( child , - <NUM_LIT> , hidden ) ; } void addView ( View child , int index , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ;", "output": "} mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . addView ( child , offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } private int getOffset ( int index ) { if ( index < <NUM_LIT> ) { return - <NUM_LIT> ; } final int limit = mCallback . getChildCount ( ) ; int offset = index ; while ( offset < limit ) { final int removedBefore = mBucket . countOnesBefore ( offset ) ; final int diff = index - ( offset - removedBefore ) ; if ( diff == <NUM_LIT> ) { while ( mBucket . get ( offset ) ) { offset ++ ; } return offset ; } else { offset += diff ; } } return - <NUM_LIT> ; } void removeView ( View view ) { int index = mCallback . indexOfChild ( view ) ; if ( index < <NUM_LIT> ) { return ; } if ( mBucket . remove ( index ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( index ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + this ) ; } } void removeViewAt ( int index ) { final int offset = getOffset ( index ) ; final View view = mCallback . getChildAt ( offset ) ; if ( view == null ) { return ; } if ( mBucket . remove ( offset ) ) { unhideViewInternal ( view ) ; } mCallback . removeViewAt ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } View getChildAt ( int index ) { final int offset = getOffset ( index ) ; return mCallback . getChildAt ( offset ) ; } void removeAllViewsUnfiltered ( ) { mBucket . reset ( ) ; for ( int i = mHiddenViews . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { mCallback . onLeftHiddenState ( mHiddenViews . get ( i ) ) ; mHiddenViews . remove ( i ) ; } mCallback . removeAllViews ( ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" ) ; } } View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) == position && ! holder . isInvalid ( ) && ! holder . isRemoved ( ) ) { return view ; } } return null ; } void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams , boolean hidden ) { final int offset ; if ( index < <NUM_LIT> ) { offset = mCallback . getChildCount ( ) ; } else { offset = getOffset ( index ) ; } mBucket . insert ( offset , hidden ) ; if ( hidden ) { hideViewInternal ( child ) ; } mCallback . attachViewToParent ( child , offset , layoutParams ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + \"<STR_LIT>\" + hidden + \"<STR_LIT>\" + this ) ; } } int getChildCount ( ) { return mCallback . getChildCount ( ) - mHiddenViews . size ( ) ; } int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } View getUnfilteredChildAt ( int index ) { return mCallback . getChildAt ( index ) ; } void detachViewFromParent ( int index ) { final int offset = getOffset ( index ) ; mBucket . remove ( offset ) ; mCallback . detachViewFromParent ( offset ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + index + \"<STR_LIT>\" + offset ) ; } } int indexOfChild ( View child ) { final int index = mCallback . indexOfChild ( child ) ; if ( index == - <NUM_LIT> ) { return - <NUM_LIT> ; } if ( mBucket . get ( index ) ) { if ( DEBUG ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } else { return - <NUM_LIT> ; } } return index - mBucket . countOnesBefore ( index ) ; } boolean isHidden ( View view ) { return mHiddenViews . contains ( view ) ; } void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( DEBUG && mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . set ( offset ) ; hideViewInternal ( view ) ; if ( DEBUG ) { Log . d ( TAG , \"<STR_LIT>\" + view + \"<STR_LIT>\" + offset + \"<STR_LIT>\" + this ) ; } } void unhide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + view ) ; } if ( ! mBucket . get ( offset ) ) { throw new RuntimeException ( \"<STR_LIT>\" + view ) ; } mBucket . clear ( offset ) ; unhideViewInternal ( view ) ; } @ Override public String toString ( ) { return mBucket . toString ( ) + \"<STR_LIT>\" + mHiddenViews . size ( ) ; } boolean removeViewIfHidden ( View view ) { final int index = mCallback . indexOfChild ( view ) ; if ( index == - <NUM_LIT> ) { if ( unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } return true ; } if ( mBucket . get ( index ) ) { mBucket . remove ( index ) ; if ( ! unhideViewInternal ( view ) && DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } mCallback . removeViewAt ( index ) ; return true ; } return false ; } static class Bucket { static final int BITS_PER_WORD = Long . SIZE ; static final long LAST_BIT = <NUM_LIT> << ( Long . SIZE - <NUM_LIT> ) ; long mData = <NUM_LIT> ; Bucket mNext ; void set ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . set ( index - BITS_PER_WORD ) ; } else { mData |= <NUM_LIT> << index ; } } private void ensureNext ( ) { if ( mNext == null ) { mNext = new Bucket ( ) ; } } void clear ( int index ) { if ( index >= BITS_PER_WORD ) { if ( mNext != null ) { mNext . clear ( index - BITS_PER_WORD ) ; } } else { mData &= ~ ( <NUM_LIT> << index ) ; } } boolean get ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . get ( index - BITS_PER_WORD ) ; } else { return ( mData & ( <NUM_LIT> << index ) ) != <NUM_LIT> ; } } void reset ( ) { mData = <NUM_LIT> ; if ( mNext != null ) { mNext . reset ( ) ; } } void insert ( int index , boolean value ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; mNext . insert ( index - BITS_PER_WORD , value ) ; } else { final boolean lastBit = ( mData & LAST_BIT ) != <NUM_LIT> ; long mask = ( <NUM_LIT> << index ) - <NUM_LIT> ; final long before = mData & mask ; final long after = ( mData & ~ mask ) << <NUM_LIT> ; mData = before | after ; if ( value ) { set ( index ) ; } else { clear ( index ) ; } if ( lastBit || mNext != null ) { ensureNext ( ) ; mNext . insert ( <NUM_LIT> , lastBit ) ; } } } boolean remove ( int index ) { if ( index >= BITS_PER_WORD ) { ensureNext ( ) ; return mNext . remove ( index - BITS_PER_WORD ) ; } else { long mask = ( <NUM_LIT> << index ) ; final boolean value = ( mData & mask ) != <NUM_LIT> ; mData &= ~ mask ; mask = mask - <NUM_LIT> ; final long before = mData & mask ; final long after = Long . rotateRight ( mData & ~ mask , <NUM_LIT> ) ; mData = before | after ; if ( mNext != null ) { if ( mNext . get ( <NUM_LIT> ) ) { set ( BITS_PER_WORD - <NUM_LIT> ) ; } mNext . remove ( <NUM_LIT> ) ; } return value ; } } int countOnesBefore ( int index ) { if ( mNext == null ) { if ( index >= BITS_PER_WORD ) { return Long . bitCount ( mData ) ; } return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } if ( index < BITS_PER_WORD ) { return Long . bitCount ( mData & ( ( <NUM_LIT> << index ) - <NUM_LIT> ) ) ; } else { return mNext . countOnesBefore ( index - BITS_PER_WORD ) + Long . bitCount ( mData ) ; } } @ Override public String toString ( ) { return mNext == null ? Long . toBinaryString ( mData ) : mNext . toString ( ) + \"<STR_LIT>\" + Long . toBinaryString ( mData ) ; } } interface Callback { int getChildCount ( ) ; void addView ( View child , int index ) ; int indexOfChild ( View view ) ; void removeViewAt ( int index ) ; View getChildAt ( int offset ) ; void removeAllViews ( ) ; RecyclerView . ViewHolder getChildViewHolder ( View view ) ; void attachViewToParent ( View child , int index , ViewGroup . LayoutParams layoutParams ) ; void detachViewFromParent ( int offset ) ; void onEnteredHiddenState ( View child ) ; void onLeftHiddenState ( View child ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . CapacitorPlugin ; import com . google . mlkit . vision . common . InputImage ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class SelfieSegmentationPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PROCESS_IMAGE_CANCELED = \"<STR_LIT>\" ; public static final String ERROR_PATH_MISSING = \"<STR_LIT>\" ; public static final String ERROR_LOAD_IMAGE_FAILED = \"<STR_LIT>\" ; public static final float CONFIDENCE = <NUM_LIT> ; private SelfieSegmentation implementation ; @ Override public void load ( ) { try { implementation = new SelfieSegmentation ( this ) ; } catch ( Exception exception ) { Logger . error ( TAG , exception . getMessage ( ) , exception ) ; } } @ PluginMethod public void processImage ( PluginCall call ) { try { String path = call . getString ( \"<STR_LIT>\" , null ) ; if ( path == null ) { call . reject ( ERROR_PATH_MISSING ) ; return ; } Integer width = call . getInt ( \"<STR_LIT>\" , null ) ; Integer height = call . getInt ( \"<STR_LIT>\" , null ) ; Float confidence = call . getFloat ( \"<STR_LIT>\" , CONFIDENCE ) ; InputImage image = implementation . createInputImageFromFilePath ( path ) ; if ( image == null ) { call . reject ( ERROR_LOAD_IMAGE_FAILED ) ; return ; } ProcessImageOptions options = new ProcessImageOptions ( image , width , height , confidence ) ; implementation . processImage ( options , new ProcessImageResultCallback ( ) { @ Override public void success ( ProcessImageResult result ) { try { call . resolve ( result . toJSObject ( ) ) ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } @ Override public void cancel ( ) { call . reject ( ERROR_PROCESS_IMAGE_CANCELED ) ; } @ Override public void error ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } }", "output": ") ; } catch ( Exception exception ) { String message = exception . getMessage ( ) ; Logger . error ( TAG , message , exception ) ; call . reject ( message ) ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import android . os . Message ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . features . general . Tasker ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class CallPrivacy extends Feature { public CallPrivacy ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var onCallReceivedMethod = Unobfuscator . loadAntiRevokeOnCallReceivedMethod ( classLoader ) ; XposedBridge . hookMethod ( onCallReceivedMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { Object callinfo = ( ( Message ) param . args [ <NUM_LIT> ] ) . obj ;", "output": "Class < ? > callInfoClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; if ( callinfo == null || ! callInfoClass . isInstance ( callinfo ) ) return ; if ( ( boolean ) XposedHelpers . callMethod ( callinfo , \"<STR_LIT>\" ) ) return ; var userJid = XposedHelpers . callMethod ( callinfo , \"<STR_LIT>\" ) ; var callId = XposedHelpers . callMethod ( callinfo , \"<STR_LIT>\" ) ; var type = Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; Tasker . sendTaskerEvent ( WppCore . getContactName ( userJid ) , WppCore . stripJID ( WppCore . getRawString ( userJid ) ) , \"<STR_LIT>\" ) ; var blockCall = checkCallBlock ( userJid , type ) ; if ( ! blockCall ) return ; var clazzVoip = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var rejectType = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; switch ( rejectType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : var rejectCallMethod = ReflectionUtils . findMethodUsingFilter ( clazzVoip , m -> m . getName ( ) . equals ( \"<STR_LIT>\" ) ) ; var obj = new Object [ rejectCallMethod . getParameterCount ( ) ] ; obj [ <NUM_LIT> ] = callId ; obj [ <NUM_LIT> ] = \"<STR_LIT>\" . equals ( rejectType ) ? null : rejectType ; if ( obj . length > <NUM_LIT> ) { obj [ <NUM_LIT> ] = <NUM_LIT> ; } ReflectionUtils . callMethod ( rejectCallMethod , null , obj ) ; param . setResult ( true ) ; break ; case \"<STR_LIT>\" : try { XposedHelpers . callStaticMethod ( clazzVoip , \"<STR_LIT>\" , true ) ; } catch ( NoSuchMethodError e ) { XposedHelpers . callStaticMethod ( clazzVoip , \"<STR_LIT>\" , true , <NUM_LIT> ) ; } param . setResult ( true ) ; break ; default : } } } ) ; XposedBridge . hookAllMethods ( classLoader . loadClass ( \"<STR_LIT>\" ) , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) return ; var userJid = param . args [ <NUM_LIT> ] ; var type = Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var block = checkCallBlock ( userJid , type ) ; if ( block ) { param . setResult ( <NUM_LIT> ) ; } } } ) ; } public boolean checkCallBlock ( Object userJid , int type ) throws IllegalAccessException , InvocationTargetException { if ( type == <NUM_LIT> ) return false ; if ( type == <NUM_LIT> ) return true ; var jid = WppCore . stripJID ( WppCore . getRawString ( userJid ) ) ; if ( jid == null ) return false ; switch ( type ) { case <NUM_LIT> : if ( WppCore . stripJID ( jid ) . equals ( jid ) ) { jid = jid . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] + \"<STR_LIT>\" ; } var contactName = WppCore . getSContactName ( WppCore . createUserJid ( jid ) , true ) ; return TextUtils . isEmpty ( contactName ) || contactName . equals ( jid ) ; case <NUM_LIT> : var callBlockList = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var blockList = Arrays . stream ( callBlockList . substring ( <NUM_LIT> , callBlockList . length ( ) - <NUM_LIT> ) . split ( \"<STR_LIT>\" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var blockNumber : blockList ) { if ( ! TextUtils . isEmpty ( blockNumber ) && jid . contains ( blockNumber ) ) { return true ; } } return false ; case <NUM_LIT> : var callWhiteList = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var whiteList = Arrays . stream ( callWhiteList . substring ( <NUM_LIT> , callWhiteList . length ( ) - <NUM_LIT> ) . split ( \"<STR_LIT>\" ) ) . map ( String :: trim ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; for ( var whiteNumber : whiteList ) { if ( ! TextUtils . isEmpty ( whiteNumber ) && jid . contains ( whiteNumber ) ) { return false ; } } return true ; } return false ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . appspa . update . utils ; public class PatchUtils { static {", "output": "System . loadLibrary ( \"<STR_LIT>\" ) ; } public static native int patch ( String oldApkPath , String newApkPath , String patchPath ) ; }"}, {"input": "package in . hridayan . ashell . adapters ; import android . content . Context ; import android . graphics . PorterDuff ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import androidx . core . content . ContextCompat ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import com . google . android . material . divider . MaterialDivider ; import in . hridayan . ashell . R ; import in . hridayan . ashell . utils . ChangelogItem ; import java . util . List ; public class ChangelogAdapter extends RecyclerView . Adapter < ChangelogAdapter . ViewHolder > { private List < ChangelogItem > changelogList ; private Context context ; public ChangelogAdapter ( List < ChangelogItem > changelogList , Context context ) { this . changelogList = changelogList ; this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { View view = LayoutInflater . from ( parent . getContext ( ) ) . inflate ( R . layout . item_changelog , parent , false ) ; return new ViewHolder ( view ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { ChangelogItem changelogItem = changelogList . get ( position ) ; holder . titleTextView . setText ( changelogItem . getTitle ( ) ) ; holder . descriptionTextView . setText ( changelogItem . getDescription ( ) ) ; holder . divider . setVisibility ( position == changelogList . size ( ) - <NUM_LIT> ? View . GONE : View . VISIBLE ) ; holder . titleTextView . setTextAppearance ( position == <NUM_LIT> ? R . style . LatestVersionTitle : R . style . OtherVersionTitle ) ; } @ Override public int getItemCount ( ) {", "output": "return changelogList . size ( ) ; } public static class ViewHolder extends RecyclerView . ViewHolder { TextView titleTextView ; TextView descriptionTextView ; MaterialDivider divider ; public ViewHolder ( View itemView ) { super ( itemView ) ; titleTextView = itemView . findViewById ( R . id . changelog_title ) ; descriptionTextView = itemView . findViewById ( R . id . changelog_description ) ; divider = itemView . findViewById ( R . id . divider ) ; } } }"}, {"input": "package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; public class PromptEntity implements Parcelable { @ ColorInt private int mThemeColor ; @ DrawableRes private int mTopResId ; private String mTopDrawableTag ; @ ColorInt private int mButtonTextColor ; private boolean mSupportBackgroundUpdate ; private float mWidthRatio ; private float mHeightRatio ; private boolean mIgnoreDownloadError ; public PromptEntity ( ) { mThemeColor = - <NUM_LIT> ; mTopResId = - <NUM_LIT> ; mTopDrawableTag = \"<STR_LIT>\" ; mButtonTextColor = <NUM_LIT> ; mSupportBackgroundUpdate = false ; mWidthRatio = - <NUM_LIT> ; mHeightRatio = - <NUM_LIT> ; mIgnoreDownloadError = false ; } protected PromptEntity ( Parcel in ) { mThemeColor = in . readInt ( ) ; mTopResId = in . readInt ( ) ; mTopDrawableTag = in . readString ( ) ; mButtonTextColor = in . readInt ( ) ; mSupportBackgroundUpdate = in . readByte ( ) != <NUM_LIT> ; mWidthRatio = in . readFloat ( ) ; mHeightRatio = in . readFloat ( ) ; mIgnoreDownloadError = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < PromptEntity > CREATOR = new Creator < PromptEntity > ( ) { @ Override public PromptEntity createFromParcel ( Parcel in ) { return new PromptEntity ( in ) ; } @ Override public PromptEntity [ ] newArray ( int size ) { return new PromptEntity [ size ] ; } } ; public int getThemeColor ( ) {", "output": "return mThemeColor ; } public PromptEntity setThemeColor ( int themeColor ) { mThemeColor = themeColor ; return this ; } public int getTopResId ( ) { return mTopResId ; } public PromptEntity setTopResId ( int topResId ) { mTopResId = topResId ; return this ; } public String getTopDrawableTag ( ) { return mTopDrawableTag ; } public PromptEntity setTopDrawableTag ( String topDrawableTag ) { mTopDrawableTag = topDrawableTag ; return this ; } public int getButtonTextColor ( ) { return mButtonTextColor ; } public PromptEntity setButtonTextColor ( int buttonTextColor ) { mButtonTextColor = buttonTextColor ; return this ; } public boolean isSupportBackgroundUpdate ( ) { return mSupportBackgroundUpdate ; } public PromptEntity setSupportBackgroundUpdate ( boolean supportBackgroundUpdate ) { mSupportBackgroundUpdate = supportBackgroundUpdate ; return this ; } public PromptEntity setWidthRatio ( float widthRatio ) { mWidthRatio = widthRatio ; return this ; } public float getWidthRatio ( ) { return mWidthRatio ; } public PromptEntity setHeightRatio ( float heightRatio ) { mHeightRatio = heightRatio ; return this ; } public float getHeightRatio ( ) { return mHeightRatio ; } public PromptEntity setIgnoreDownloadError ( boolean ignoreDownloadError ) { mIgnoreDownloadError = ignoreDownloadError ; return this ; } public boolean isIgnoreDownloadError ( ) { return mIgnoreDownloadError ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + mThemeColor + \"<STR_LIT>\" + mTopResId + \"<STR_LIT>\" + mTopDrawableTag + \"<STR_LIT>\" + mButtonTextColor + \"<STR_LIT>\" + mSupportBackgroundUpdate + \"<STR_LIT>\" + mWidthRatio + \"<STR_LIT>\" + mHeightRatio + \"<STR_LIT>\" + mIgnoreDownloadError + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( mThemeColor ) ; dest . writeInt ( mTopResId ) ; dest . writeString ( mTopDrawableTag ) ; dest . writeInt ( mButtonTextColor ) ; dest . writeByte ( ( byte ) ( mSupportBackgroundUpdate ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeFloat ( mWidthRatio ) ; dest . writeFloat ( mHeightRatio ) ; dest . writeByte ( ( byte ) ( mIgnoreDownloadError ? <NUM_LIT> : <NUM_LIT> ) ) ; } }"}, {"input": "package com . simon . harmonichackernews . data ; import android . text . TextUtils ; import com . simon . harmonichackernews . utils . ArxivResolver ; public class ArxivInfo { public String arxivAbstract ; public String [ ] authors ; public String primaryCategory ; public String arxivID ; public String [ ] secondaryCategories ; public String publishedDate ; public String concatNames ( ) { return TextUtils . join ( \"<STR_LIT>\" , authors ) ; }", "output": "public String formatDate ( ) { return publishedDate . substring ( <NUM_LIT> , <NUM_LIT> ) ; } public String formatSubjects ( ) { StringBuilder allSubjects = new StringBuilder ( ArxivResolver . resolveFull ( primaryCategory ) ) ; for ( String secondaryCategory : secondaryCategories ) { allSubjects . append ( \"<STR_LIT>\" ) . append ( ArxivResolver . resolveFull ( secondaryCategory ) ) ; } return allSubjects . toString ( ) ; } public String getPDFURL ( ) { return \"<STR_LIT>\" + arxivID + \"<STR_LIT>\" ; } }"}, {"input": "package com . reactnative . overlay ; import androidx . annotation . NonNull ; import com . facebook . react . ReactInstanceManager ; import com . facebook . react . ReactNativeHost ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; import java . util . Collections ; import java . util . List ; public class OverlayPackage implements ReactPackage { private final ReactNativeHost reactNativeHost ; public OverlayPackage ( ReactNativeHost reactNativeHost ) { this . reactNativeHost = reactNativeHost ; } @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) {", "output": "return Collections . singletonList ( new OverlayModule ( reactContext , reactNativeHost ) ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . view . View ; import android . widget . TextView ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CopyStatus extends Feature { public CopyStatus ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . getResult ( ) ; var caption = ( TextView ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( caption != null ) { caption . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( caption . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; var viewStatusMethod = Unobfuscator . loadBlueOnReplayStatusViewMethod ( classLoader ) ; XposedBridge . hookMethod ( viewStatusMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var text = ( TextView ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( text != null ) {", "output": "text . setOnLongClickListener ( ( view1 -> { Utils . setToClipboard ( text . getText ( ) . toString ( ) ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . copied_to_clipboard ) , Toast . LENGTH_LONG ) ; return true ; } ) ) ; } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "public class SplashScreen extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { } }", "output": "public class SplashScreen extends AppCompatActivity { @ Override public void onCreate ( Bundle savedInstanceState ) { test ( ) ; } private void test ( ) { AppUpdateManager appUpdateManager = AppUpdateManagerFactory . create ( context ) ; appUpdateManager . startUpdateFlowForResult ( appUpdateInfo , AppUpdateType . IMMEDIATE , this , MY_REQUEST_CODE ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . interfaces ; import com . getcapacitor . JSObject ; public interface Result { JSObject toJSObject ( ) ;", "output": "}"}, {"input": "package org . sufficientlysecure . htmltextview ; import android . content . res . Resources ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . Canvas ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . text . Html . ImageGetter ; import android . util . Log ; import android . view . View ; import android . widget . TextView ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . ref . WeakReference ; import java . net . URI ; import java . net . URL ; public class HtmlHttpImageGetter implements ImageGetter { private TextView container ; private URI baseUri ; private boolean matchParentWidth ; private int placeHolder ; private boolean compressImage = false ; private int qualityImage = <NUM_LIT> ; public HtmlHttpImageGetter ( TextView textView ) { this . container = textView ; this . matchParentWidth = false ; } public HtmlHttpImageGetter ( TextView textView , String baseUrl ) { this . container = textView ; if ( baseUrl != null ) { this . baseUri = URI . create ( baseUrl ) ; } } public HtmlHttpImageGetter ( TextView textView , String baseUrl , boolean matchParentWidth ) { this ( textView , baseUrl , <NUM_LIT> , matchParentWidth ) ; } public HtmlHttpImageGetter ( TextView textView , String baseUrl , int placeHolder , boolean matchParentWidth ) { this . container = textView ; this . placeHolder = placeHolder ; this . matchParentWidth = matchParentWidth ; if ( baseUrl != null ) { this . baseUri = URI . create ( baseUrl ) ; } } public void enableCompressImage ( boolean enable ) { enableCompressImage ( enable , <NUM_LIT> ) ; } public void enableCompressImage ( boolean enable , int quality ) { compressImage = enable ; qualityImage = quality ; } public Drawable getDrawable ( String source ) { UrlDrawable urlDrawable = new UrlDrawable ( ) ; if ( placeHolder != <NUM_LIT> ) { Drawable placeDrawable = container . getContext ( ) . getResources ( ) . getDrawable ( placeHolder ) ; placeDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , placeDrawable . getIntrinsicWidth ( ) , placeDrawable . getIntrinsicHeight ( ) ) ; urlDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , placeDrawable . getIntrinsicWidth ( ) , placeDrawable . getIntrinsicHeight ( ) ) ; urlDrawable . drawable = placeDrawable ; } ImageGetterAsyncTask asyncTask = new ImageGetterAsyncTask ( urlDrawable , this , container , matchParentWidth , compressImage , qualityImage ) ; asyncTask . execute ( source ) ; return urlDrawable ; } private static class ImageGetterAsyncTask extends AsyncTask < String , Void , Drawable > { private final WeakReference < UrlDrawable > drawableReference ; private final WeakReference < HtmlHttpImageGetter > imageGetterReference ; private final WeakReference < View > containerReference ; private final WeakReference < Resources > resources ; private String source ; private boolean matchParentWidth ; private float scale ; private boolean compressImage = false ; private int qualityImage = <NUM_LIT> ; public ImageGetterAsyncTask ( UrlDrawable d , HtmlHttpImageGetter imageGetter , View container , boolean matchParentWidth , boolean compressImage , int qualityImage ) { this . drawableReference = new WeakReference < > ( d ) ; this . imageGetterReference = new WeakReference < > ( imageGetter ) ; this . containerReference = new WeakReference < > ( container ) ; this . resources = new WeakReference < > ( container . getResources ( ) ) ; this . matchParentWidth = matchParentWidth ; this . compressImage = compressImage ; this . qualityImage = qualityImage ; } @ Override protected Drawable doInBackground ( String ... params ) { source = params [ <NUM_LIT> ] ; if ( resources . get ( ) != null ) { if ( compressImage ) { return fetchCompressedDrawable ( resources . get ( ) , source ) ; } else { return fetchDrawable ( resources . get ( ) , source ) ; } } return null ; } @ Override protected void onPostExecute ( Drawable result ) { if ( result == null ) { Log . w ( HtmlTextView . TAG , \"<STR_LIT>\" + source + \"<STR_LIT>\" ) ; return ; } final UrlDrawable urlDrawable = drawableReference . get ( ) ; if ( urlDrawable == null ) { return ; } urlDrawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( result . getIntrinsicWidth ( ) * scale ) , ( int ) ( result . getIntrinsicHeight ( ) * scale ) ) ; urlDrawable . drawable = result ; final HtmlHttpImageGetter imageGetter = imageGetterReference . get ( ) ; if ( imageGetter == null ) { return ; } imageGetter . container . invalidate ( ) ; imageGetter . container . setText ( imageGetter . container . getText ( ) ) ; } public Drawable fetchDrawable ( Resources res , String urlString ) { try { InputStream is = fetch ( urlString ) ; Drawable drawable = new BitmapDrawable ( res , is ) ; scale = getScale ( drawable ) ; drawable . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( drawable . getIntrinsicWidth ( ) * scale ) , ( int ) ( drawable . getIntrinsicHeight ( ) * scale ) ) ; return drawable ; } catch ( Exception e ) { return null ; } } public Drawable fetchCompressedDrawable ( Resources res , String urlString ) { try { InputStream is = fetch ( urlString ) ; Bitmap original = new BitmapDrawable ( res , is ) . getBitmap ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; original . compress ( Bitmap . CompressFormat . JPEG , qualityImage , out ) ; original . recycle ( ) ; is . close ( ) ; Bitmap decoded = BitmapFactory . decodeStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; out . close ( ) ; scale = getScale ( decoded ) ; BitmapDrawable b = new BitmapDrawable ( res , decoded ) ; b . setBounds ( <NUM_LIT> , <NUM_LIT> , ( int ) ( b . getIntrinsicWidth ( ) * scale ) , ( int ) ( b . getIntrinsicHeight ( ) * scale ) ) ; return b ; } catch ( Exception e ) { return null ; } } private float getScale ( Bitmap bitmap ) { View container = containerReference . get ( ) ; if ( container == null ) { return <NUM_LIT> ; } float maxWidth = container . getWidth ( ) ; float originalDrawableWidth = bitmap . getWidth ( ) ; return maxWidth / originalDrawableWidth ; } private float getScale ( Drawable drawable ) { View container = containerReference . get ( ) ; if ( ! matchParentWidth || container == null ) { return <NUM_LIT> ; } float maxWidth = container . getWidth ( ) ; float originalDrawableWidth = drawable . getIntrinsicWidth ( ) ; return maxWidth / originalDrawableWidth ; } private InputStream fetch ( String urlString ) throws IOException { URL url ; final HtmlHttpImageGetter imageGetter = imageGetterReference . get ( ) ; if ( imageGetter == null ) { return null ; } if ( imageGetter . baseUri != null ) { url = imageGetter . baseUri . resolve ( urlString ) . toURL ( ) ; } else { url = URI . create ( urlString ) . toURL ( ) ; } return ( InputStream ) url . getContent ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public class UrlDrawable extends BitmapDrawable { protected Drawable drawable ; @ Override public void draw ( Canvas canvas ) {", "output": "if ( drawable != null ) { drawable . draw ( canvas ) ; } } } }"}, {"input": "public class TestClass { protected boolean getBoolean ( ) { return false ; } protected void test ( ) { WebView webview2 = new WebView ( this ) ; String url = \"<STR_LIT>\" ; webview2 . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( false ) ; webview2 . getSettings ( ) . setAllowFileAccess ( true ) ; webview2 . getSettings ( ) . setAllowContentAccess ( true ) ; webview2 . getSettings ( ) . setAllowFileAccessFromFileURLs ( this . getBoolean ( ) ) ; webview2 . loadUrl ( url ) ; } protected void test2 ( ) { WebView webview2 = new WebView ( this ) ;", "output": "WebSettings settings = webView . getSettings ( ) ; settings . setJavaScriptEnabled ( true ) ; String url = \"<STR_LIT>\" ; settings . setAllowUniversalAccessFromFileURLs ( false ) ; settings . setAllowFileAccess ( true ) ; settings . setAllowContentAccess ( true ) ; settings . setAllowFileAccessFromFileURLs ( this . getBoolean ( ) ) ; webview2 . loadUrl ( url ) ; } public class WebAppInnnerCalss extends WebView { Context mContext ; public void test4 ( ) { getSettings ( ) . setAllowUniversalAccessFromFileURLs ( true ) ; getSettings ( ) . setAllowFileAccess ( false ) ; getSettings ( ) . setAllowContentAccess ( true ) ; getSettings ( ) . setAllowFileAccessFromFileURLs ( false ) ; } } }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . wakeup ; import android . content . Context ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . aip . asrwakeup3 . core . wakeup . listener . IWakeupListener ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONObject ; import java . util . Map ; public class MyWakeup { private static boolean isInited = false ; private EventManager wp ; private EventListener eventListener ; private static final String TAG = \"<STR_LIT>\" ; public MyWakeup ( Context context , EventListener eventListener ) { if ( isInited ) { MyLogger . error ( TAG , \"<STR_LIT>\" ) ; throw new RuntimeException ( \"<STR_LIT>\" ) ; } isInited = true ; this . eventListener = eventListener ; wp = EventManagerFactory . create ( context , \"<STR_LIT>\" ) ; wp . registerListener ( eventListener ) ; } public MyWakeup ( Context context , IWakeupListener eventListener ) {", "output": "this ( context , new WakeupEventAdapter ( eventListener ) ) ; } public void start ( Map < String , Object > params ) { String json = new JSONObject ( params ) . toString ( ) ; MyLogger . info ( TAG + \"<STR_LIT>\" , \"<STR_LIT>\" + json ) ; wp . send ( SpeechConstant . WAKEUP_START , json , null , <NUM_LIT> , <NUM_LIT> ) ; } public void stop ( ) { MyLogger . info ( TAG , \"<STR_LIT>\" ) ; wp . send ( SpeechConstant . WAKEUP_STOP , null , null , <NUM_LIT> , <NUM_LIT> ) ; } public void setEventListener ( EventListener eventListener ) { this . eventListener = eventListener ; } public void setEventListener ( IWakeupListener eventListener ) { this . eventListener = new WakeupEventAdapter ( eventListener ) ; } public void release ( ) { stop ( ) ; wp . unregisterListener ( eventListener ) ; wp = null ; isInited = false ; } }"}, {"input": "package com . reactnative . pulltorefresh ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . ViewParent ; import androidx . annotation . Nullable ; import androidx . core . view . ViewCompat ; import com . facebook . react . uimanager . ReactOverflowView ; import com . facebook . react . uimanager . events . NativeGestureUtil ; import com . scwang . smart . refresh . layout . SmartRefreshLayout ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshHeader ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; public class PullToRefresh extends SmartRefreshLayout implements ReactOverflowView { private final static String TAG = \"<STR_LIT>\" ; private final Rect mRect ; private String mOverflow = \"<STR_LIT>\" ; public PullToRefresh ( Context context ) { super ( context ) ; mRect = new Rect ( ) ; } public void setOverflow ( String overflow ) { mOverflow = overflow ; invalidate ( ) ; } @ Nullable @ Override public String getOverflow ( ) { return mOverflow ; } private final Runnable measureAndLayout = ( ) -> { measure ( View . MeasureSpec . makeMeasureSpec ( getWidth ( ) , View . MeasureSpec . EXACTLY ) , View . MeasureSpec . makeMeasureSpec ( getHeight ( ) , View . MeasureSpec . EXACTLY ) ) ; layout ( getLeft ( ) , getTop ( ) , getRight ( ) , getBottom ( ) ) ; } ; @ Override public void requestLayout ( ) { super . requestLayout ( ) ; post ( measureAndLayout ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { ViewGroup view = ( ViewGroup ) mRefreshContent . getScrollableView ( ) ; String viewName = view . getClass ( ) . getCanonicalName ( ) ; if ( viewName != null && viewName . contains ( \"<STR_LIT>\" ) ) { if ( mIsBeingDragged ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; } return super . dispatchTouchEvent ( ev ) ; } if ( view . canScrollHorizontally ( - <NUM_LIT> ) || view . canScrollHorizontally ( <NUM_LIT> ) ) { if ( mIsBeingDragged ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; } return super . dispatchTouchEvent ( ev ) ; } if ( ! view . canScrollVertically ( - <NUM_LIT> ) && ! view . canScrollVertically ( <NUM_LIT> ) ) { view . onInterceptTouchEvent ( ev ) ; view . onTouchEvent ( ev ) ; if ( ev . getAction ( ) == MotionEvent . ACTION_DOWN ) { view . startNestedScroll ( ViewCompat . SCROLL_AXIS_VERTICAL ) ; } if ( ev . getAction ( ) == MotionEvent . ACTION_UP || ev . getAction ( ) == MotionEvent . ACTION_CANCEL ) { view . stopNestedScroll ( ) ; } if ( shouldInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; ViewParent parent = getParent ( ) ; if ( parent != null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } return true ; } } return super . dispatchTouchEvent ( ev ) ; } private int mLastMotionY ; private boolean shouldInterceptTouchEvent ( MotionEvent ev ) { final int action = ev . getAction ( ) ; if ( ( action == MotionEvent . ACTION_MOVE ) && ( mIsBeingDragged ) ) { return true ; } switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_MOVE : { final int y = ( int ) ev . getRawY ( ) ; final int yDiff = Math . abs ( y - mLastMotionY ) ; if ( yDiff >= mTouchSlop ) { mIsBeingDragged = true ; } break ; } case MotionEvent . ACTION_DOWN : { mLastMotionY = ( int ) ev . getRawY ( ) ; break ;", "output": "} case MotionEvent . ACTION_CANCEL : case MotionEvent . ACTION_UP : mIsBeingDragged = false ; } return mIsBeingDragged ; } public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( super . onInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; return true ; } return false ; } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; float height = ( float ) ( getMeasuredHeight ( ) * <NUM_LIT> ) ; RefreshHeader header = getRefreshHeader ( ) ; if ( header != null ) { int headerHeight = header . getView ( ) . getMeasuredHeight ( ) ; setHeaderMaxDragRate ( height / headerHeight ) ; } RefreshFooter footer = getRefreshFooter ( ) ; if ( footer != null ) { int footerHeight = footer . getView ( ) . getMeasuredHeight ( ) ; setFooterMaxDragRate ( height / footerHeight ) ; } } @ Override protected void dispatchDraw ( Canvas canvas ) { getDrawingRect ( mRect ) ; if ( ! \"<STR_LIT>\" . equals ( mOverflow ) ) { canvas . clipRect ( mRect ) ; } super . dispatchDraw ( canvas ) ; } public RefreshKernel getRefreshKernel ( ) { return mKernel ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import com . alibaba . fastjson . JSON ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . FutureTask ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . VideoInfo ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . ServiceGenerator ; public class Utils { public static String picturesObjToString ( List < ? > obj ) { List < BiliComment . Picture > pictures = new ArrayList < > ( ) ; if ( obj == null || obj . size ( ) == <NUM_LIT> ) { return null ; } for ( Object o : obj ) { BiliComment . Picture picture = new BiliComment . Picture ( ) ; picture . img_src = ( String ) XposedHelpers . getObjectField ( o , \"<STR_LIT>\" ) ; picture . img_width = ( Double ) XposedHelpers . getObjectField ( o , \"<STR_LIT>\" ) ; picture . img_height = ( Double ) XposedHelpers . getObjectField ( o , \"<STR_LIT>\" ) ; picture . img_size = ( Double ) XposedHelpers . getObjectField ( o , \"<STR_LIT>\" ) ; pictures . add ( picture ) ;", "output": "} return JSON . toJSONString ( pictures ) ; } public static String getBvidFormAvid ( long avid ) throws ExecutionException , InterruptedException { Callable < String > callable = ( ) -> { BiliApiService biliApiService = ServiceGenerator . getBiliApiService ( ) ; GeneralResponse < VideoInfo > body = biliApiService . getVideoInfoByAid ( avid ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; return body . data . bvid ; } ; FutureTask < String > task = new FutureTask < > ( callable ) ; task . run ( ) ; return task . get ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . adapter ; import androidx . annotation . NonNull ; import androidx . fragment . app . Fragment ; import androidx . fragment . app . FragmentActivity ; import androidx . viewpager2 . adapter . FragmentStateAdapter ; import com . wmods . wppenhacer . ui . fragments . CustomizationFragment ; import com . wmods . wppenhacer . ui . fragments . GeneralFragment ; import com . wmods . wppenhacer . ui . fragments . HomeFragment ; import com . wmods . wppenhacer . ui . fragments . MediaFragment ; import com . wmods . wppenhacer . ui . fragments . PrivacyFragment ; public class MainPagerAdapter extends FragmentStateAdapter { public MainPagerAdapter ( @ NonNull FragmentActivity fragmentActivity ) { super ( fragmentActivity ) ; } @ NonNull @ Override public Fragment createFragment ( int position ) { return switch ( position ) { case <NUM_LIT> -> new GeneralFragment ( ) ; case <NUM_LIT> -> new PrivacyFragment ( ) ; case <NUM_LIT> -> new MediaFragment ( ) ; case <NUM_LIT> -> new CustomizationFragment ( ) ;", "output": "default -> new HomeFragment ( ) ; } ; } @ Override public int getItemCount ( ) { return <NUM_LIT> ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . ProgressBar ; import android . widget . TextView ; import androidx . annotation . NonNull ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . List ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; @ SuppressLint ( \"<STR_LIT>\" ) public class BatchCheckAdapter extends RecyclerView . Adapter < BatchCheckAdapter . ViewHolder > { private final Context context ; private final List < String > oldStatusList = new ArrayList < > ( ) ; private final List < HistoryComment > checkedComments = new ArrayList < > ( ) ; private HistoryComment checkingComment ; public BatchCheckAdapter ( Context context ) { this . context = context ; } @ NonNull @ Override public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { return new ViewHolder ( LayoutInflater . from ( context ) . inflate ( R . layout . item_one_batch_checking_comment , parent , false ) ) ; } @ Override public void onBindViewHolder ( @ NonNull ViewHolder holder , int position ) { if ( position == checkedComments . size ( ) ) { holder . txv_comment_content . setText ( checkingComment . comment ) ; setStatus ( checkingComment . lastState , holder . txv_old_status , holder . img_old_status ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( new ProgressBar ( context ) ) ; return ; } HistoryComment comment = checkedComments . get ( position ) ; holder . txv_comment_content . setText ( comment . comment ) ; setStatus ( oldStatusList . get ( position ) , holder . txv_old_status , holder . img_old_status ) ; ImageView imageView = new ImageView ( context ) ; holder . new_status_icon_frame . removeAllViews ( ) ; holder . new_status_icon_frame . addView ( imageView ) ; setStatus ( comment . lastState , holder . txv_new_status , imageView ) ; } @ Override public int getItemCount ( ) { int size = checkedComments . size ( ) ; if ( checkingComment != null ) { size ++ ; } return size ; } private void setStatus ( String status , TextView textView , ImageView imageView ) { switch ( status ) { case HistoryComment . STATE_NORMAL : imageView . setImageDrawable ( context . getDrawable ( R . drawable . normal ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_SHADOW_BAN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . hide ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_UNDER_REVIEW : imageView . setImageDrawable ( context . getDrawable ( R . drawable . i ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_DELETED : imageView . setImageDrawable ( context . getDrawable ( R . drawable . deleted ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_SENSITIVE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . sensitive ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_INVISIBLE : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ghost ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_UNKNOWN : imageView . setImageDrawable ( context . getDrawable ( R . drawable . unknown ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; case HistoryComment . STATE_SUSPECTED_NO_PROBLEM : imageView . setImageDrawable ( context . getDrawable ( R . drawable . ic_baseline_access_time_24 ) ) ; textView . setText ( \"<STR_LIT>\" ) ; break ; default : textView . setText ( status ) ; } } public void setCheckingComment ( HistoryComment historyComment ) { checkingComment = historyComment ; oldStatusList . add ( historyComment . lastState ) ; notifyItemInserted ( getItemCount ( ) - <NUM_LIT> ) ; } public void overCheckComment ( String newStatus ) { if ( checkingComment == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } checkingComment . lastState = newStatus ; checkedComments . add ( checkingComment ) ; checkingComment = null ; notifyItemChanged ( getItemCount ( ) - <NUM_LIT> ) ; } public static class ViewHolder extends RecyclerView . ViewHolder {", "output": "ImageView img_old_status = itemView . findViewById ( R . id . img_old_status ) ; TextView txv_old_status = itemView . findViewById ( R . id . txv_old_status ) ; FrameLayout new_status_icon_frame = itemView . findViewById ( R . id . new_status_icon_frame ) ; TextView txv_new_status = itemView . findViewById ( R . id . txv_new_status ) ; TextView txv_comment_content = itemView . findViewById ( R . id . txv_comment_content ) ; public ViewHolder ( @ NonNull View itemView ) { super ( itemView ) ; } } }"}, {"input": "package com . simon . harmonichackernews . data ; import android . os . Bundle ; import android . text . TextUtils ; import com . simon . harmonichackernews . CommentsFragment ; import com . simon . harmonichackernews . utils . Utils ; import java . util . ArrayList ; public class Story { public String by ; public int descendants ; public int id ; public int score ; public int time ; public String title ; public String pdfTitle ; public String url ; public int [ ] kids ; public int [ ] pollOptions ; public ArrayList < PollOption > pollOptionArrayList ; public boolean loaded ; public boolean clicked ; public String text ; public RepoInfo repoInfo ; public ArxivInfo arxivInfo ; public WikipediaInfo wikiInfo ; public boolean isLink ; public boolean isJob = false ; public boolean loadingFailed = false ; public boolean isComment = false ; public String commentMasterTitle ; public int commentMasterId ; public String commentMasterUrl ; public Story ( ) { } public Story ( String title , int id , boolean loaded , boolean clicked ) { this . title = title ; this . id = id ; this . loaded = loaded ; this . clicked = clicked ; } public void update ( String by , int id , int score , int time , String title ) { this . by = by ; this . id = id ; this . score = score ; this . time = time ; this . title = title ; }", "output": "public String getTimeFormatted ( ) { return Utils . getTimeAgo ( this . time ) ; } @ Override public String toString ( ) { return title ; } public Bundle toBundle ( ) { Bundle bundle = new Bundle ( ) ; bundle . putString ( CommentsFragment . EXTRA_TITLE , title ) ; bundle . putString ( CommentsFragment . EXTRA_PDF_TITLE , pdfTitle ) ; bundle . putString ( CommentsFragment . EXTRA_BY , by ) ; bundle . putString ( CommentsFragment . EXTRA_URL , url ) ; bundle . putInt ( CommentsFragment . EXTRA_TIME , time ) ; bundle . putIntArray ( CommentsFragment . EXTRA_KIDS , kids ) ; bundle . putIntArray ( CommentsFragment . EXTRA_POLL_OPTIONS , pollOptions ) ; bundle . putInt ( CommentsFragment . EXTRA_DESCENDANTS , descendants ) ; bundle . putInt ( CommentsFragment . EXTRA_ID , id ) ; bundle . putInt ( CommentsFragment . EXTRA_SCORE , score ) ; bundle . putString ( CommentsFragment . EXTRA_TEXT , text ) ; bundle . putBoolean ( CommentsFragment . EXTRA_IS_LINK , isLink ) ; bundle . putBoolean ( CommentsFragment . EXTRA_IS_COMMENT , isComment ) ; return bundle ; } public boolean hasExtraInfo ( ) { return arxivInfo != null || repoInfo != null || wikiInfo != null ; } }"}, {"input": "package com . norman . webviewup . lib . service . proxy ; import com . norman . webviewup . lib . reflect . RuntimeProxy ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( value = \"<STR_LIT>\" ) public abstract class WebViewUpdateServiceProxy extends RuntimeProxy { public WebViewUpdateServiceProxy ( ) { super ( ) ; } @ Method ( \"<STR_LIT>\" ) protected abstract Object waitForAndGetProvider ( ) ;", "output": "@ Method ( \"<STR_LIT>\" ) protected abstract android . os . IBinder asBinder ( ) ; @ Method ( \"<STR_LIT>\" ) protected abstract boolean isMultiProcessEnabled ( ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . api ; import androidx . annotation . Nullable ; import org . json . JSONObject ; public class GetLatestBundleResponse { private String bundleId ; @ Nullable private String checksum ; @ Nullable private String signature ; private String url ; public GetLatestBundleResponse ( JSONObject responseJson ) { this . bundleId = responseJson . optString ( \"<STR_LIT>\" ) ; String checksum = responseJson . optString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "if ( checksum . equals ( \"<STR_LIT>\" ) ) { this . checksum = null ; } else { this . checksum = checksum ; } String signature = responseJson . optString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( signature . equals ( \"<STR_LIT>\" ) ) { this . signature = null ; } else { this . signature = signature ; } this . url = responseJson . optString ( \"<STR_LIT>\" ) ; } public String getBundleId ( ) { return bundleId ; } @ Nullable public String getChecksum ( ) { return checksum ; } @ Nullable public String getSignature ( ) { return signature ; } public String getUrl ( ) { return url ; } }"}, {"input": "package org . woheller69 . weather . weather_api ; public abstract class IApiToDatabaseConversion { public enum WeatherCategories { ERROR ( - <NUM_LIT> ) , CLEAR_SKY ( <NUM_LIT> ) , FEW_CLOUDS ( <NUM_LIT> ) , SCATTERED_CLOUDS ( <NUM_LIT> ) , OVERCAST_CLOUDS ( <NUM_LIT> ) , MIST ( <NUM_LIT> ) , DRIZZLE_RAIN ( <NUM_LIT> ) , FREEZING_DRIZZLE_RAIN ( <NUM_LIT> ) , LIGHT_RAIN ( <NUM_LIT> ) , MODERATE_RAIN ( <NUM_LIT> ) , HEAVY_RAIN ( <NUM_LIT> ) , LIGHT_FREEZING_RAIN ( <NUM_LIT> ) , FREEZING_RAIN ( <NUM_LIT> ) , LIGHT_SNOW ( <NUM_LIT> ) , MODERATE_SNOW ( <NUM_LIT> ) , HEAVY_SNOW ( <NUM_LIT> ) , LIGHT_SHOWER_RAIN ( <NUM_LIT> ) , SHOWER_RAIN ( <NUM_LIT> ) , SHOWER_RAIN_SNOW ( <NUM_LIT> ) , LIGHT_SHOWER_SNOW ( <NUM_LIT> ) , SHOWER_SNOW ( <NUM_LIT> ) , THUNDERSTORM ( <NUM_LIT> ) , THUNDERSTORM_HAIL ( <NUM_LIT> ) ;", "output": "private int numVal ; WeatherCategories ( int numVal ) { this . numVal = numVal ; } public int getNumVal ( ) { return numVal ; } } public abstract int convertWeatherCategory ( String category ) ; }"}, {"input": "package io . capawesome . capacitorjs . plugins . screenorientation ; public class ScreenOrientationType { public static final String LANDSCAPE = \"<STR_LIT>\" ; public static final String LANDSCAPE_PRIMARY = \"<STR_LIT>\" ; public static final String LANDSCAPE_SECONDARY = \"<STR_LIT>\" ; public static final String PORTRAIT = \"<STR_LIT>\" ; public static final String PORTRAIT_PRIMARY = \"<STR_LIT>\" ; public static final String PORTRAIT_SECONDARY = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; import com . alibaba . fastjson . annotation . JSONField ; import java . util . List ; public class BiliComment { public long rpid ; public long oid ; public int type ; public long mid ; public long root ; public long parent ; public Content content ; public Member member ; public int rcount ; public List < BiliComment > replies ; public int like ; public boolean invisible ; public long ctime ; public static class Member { public long mid ; public String uname ; public String avatar ; public LevelInFo level_info ; } public static class LevelInFo { @ JSONField ( name = \"<STR_LIT>\" ) public int currentLevel ; } public static class Content { public String message ; public List < Picture > pictures ;", "output": "public int max_line ; } public static class Picture { public String img_src ; public Double img_width ; public Double img_height ; public Double img_size ; } }"}, {"input": "public class ThreadReferenceLeakActivity extends AppCompatActivity { private static LeakyThread thread ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; createThread ( ) ; redirectToNewScreen ( ) ; } private void createThread ( ) { thread = new LeakyThread ( ) ; thread . start ( ) ; } private void redirectToNewScreen ( ) { startActivity ( new Intent ( this , SecondActivity . class ) ) ; } private class LeakyThread extends Thread {", "output": "@ Override public void run ( ) { while ( true ) { } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . view . Menu ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . List ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class Channels extends Feature { public Channels ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } private static void removeItems ( ArrayList < ? > arrList , boolean channels , boolean removechannelRec , Class < ? > headerChannelItem , Class < ? > listChannelItem , Class < ? > removeChannelRecClass ) {", "output": "arrList . removeIf ( ( e ) -> { if ( channels ) { if ( headerChannelItem . isInstance ( e ) || listChannelItem . isInstance ( e ) ) return true ; } if ( channels || removechannelRec ) { return removeChannelRecClass . isInstance ( e ) ; } return false ; } ) ; } @ Override public void doHook ( ) throws Throwable { var channels = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var removechannelRec = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( channels || removechannelRec ) { var removeChannelRecClass = Unobfuscator . loadRemoveChannelRecClass ( classLoader ) ; log ( \"<STR_LIT>\" + removeChannelRecClass ) ; var headerChannelItem = Unobfuscator . loadHeaderChannelItemClass ( classLoader ) ; log ( \"<STR_LIT>\" + headerChannelItem ) ; var listChannelItem = Unobfuscator . loadListChannelItemClass ( classLoader ) ; log ( \"<STR_LIT>\" + listChannelItem ) ; var listUpdateItems = Unobfuscator . loadListUpdateItemsConstructor ( classLoader ) ; log ( \"<STR_LIT>\" + Unobfuscator . getConstructorDescriptor ( listUpdateItems ) ) ; XposedBridge . hookMethod ( listUpdateItems , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var list = ReflectionUtils . findArrayOfType ( param . args , ArrayList . class ) ; if ( list . isEmpty ( ) ) return ; var arrList = ( ArrayList < ? > ) list . get ( <NUM_LIT> ) . second ; removeItems ( arrList , channels , removechannelRec , headerChannelItem , listChannelItem , removeChannelRecClass ) ; } } ) ; XposedBridge . hookAllConstructors ( removeChannelRecClass , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var pairs = ReflectionUtils . findArrayOfType ( param . args , List . class ) ; for ( var pair : pairs ) { param . args [ pair . first ] = new ArrayList < > ( ) ; } } } ) ; if ( channels ) { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , Menu . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var id = Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; var menuItem = menu . findItem ( id ) ; if ( menuItem != null ) { menuItem . setVisible ( false ) ; } } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . content . SharedPreferences ; import android . util . Base64 ; import android . util . Log ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class GlobalDataHolder { private static List < PromptTabData > tabDataList = null ; private static boolean asrUseWhisper ; private static boolean asrUseGoogle ; private static boolean asrUseBaidu ; private static String asrAppId ; private static String asrApiKey ; private static String asrSecretKey ; private static boolean asrUseRealTime ; private static String gptApiHost ; private static String gptApiKey ; private static String gptModel ; private static List < String > customModels = null ; private static boolean checkAccessOnStart ; private static boolean defaultEnableTts ; private static boolean defaultEnableMultiChat ; private static int selectedTab ; private static boolean enableInternetAccess ; private static int webMaxCharCount ; private static boolean onlyLatestWebResult ; private static boolean limitVisionSize ; private static boolean autoSaveHistory ; private static SharedPreferences sp = null ; public static void init ( Context context ) { sp = context . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; loadTabDataList ( ) ; if ( tabDataList . size ( ) == <NUM_LIT> ) { tabDataList . add ( new PromptTabData ( context . getString ( R . string . text_default_tab_title ) , context . getString ( R . string . text_default_tab_content ) ) ) ; saveTabDataList ( ) ; } loadAsrSelection ( ) ; loadBaiduAsrInfo ( ) ; loadGptApiInfo ( ) ; loadStartUpSetting ( ) ; loadTtsSetting ( ) ; loadMultiChatSetting ( ) ; loadSelectedTab ( ) ; loadFunctionSetting ( ) ; loadVisionSetting ( ) ; loadHistorySetting ( ) ; } public static List < PromptTabData > getTabDataList ( ) { return tabDataList ; } public static void saveTabDataList ( ) { SharedPreferences . Editor editor = sp . edit ( ) ; try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( tabDataList ) ; String base64 = Base64 . encodeToString ( baos . toByteArray ( ) , Base64 . DEFAULT ) ; editor . putString ( \"<STR_LIT>\" , base64 ) ; editor . apply ( ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void loadTabDataList ( ) { String base64 = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( base64 . equals ( \"<STR_LIT>\" ) ) { tabDataList = new ArrayList < > ( ) ; return ; } byte [ ] bytes = Base64 . decode ( base64 , Base64 . DEFAULT ) ; try { ByteArrayInputStream bais = new ByteArrayInputStream ( bytes ) ; tabDataList = ( List < PromptTabData > ) ( new ObjectInputStream ( bais ) . readObject ( ) ) ; } catch ( ClassNotFoundException | IOException e ) { e . printStackTrace ( ) ; } } public static void loadAsrSelection ( ) { asrUseWhisper = sp . getBoolean ( \"<STR_LIT>\" , false ) ; asrUseBaidu = sp . getBoolean ( \"<STR_LIT>\" , false ) ; asrUseGoogle = sp . getBoolean ( \"<STR_LIT>\" , false ) ; } public static void saveAsrSelection ( boolean useWhisper , boolean useBaidu , boolean useGoogle ) { asrUseWhisper = useWhisper ; asrUseBaidu = useBaidu ; asrUseGoogle = useGoogle ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , asrUseWhisper ) ; editor . putBoolean ( \"<STR_LIT>\" , asrUseBaidu ) ; editor . putBoolean ( \"<STR_LIT>\" , asrUseGoogle ) ; editor . apply ( ) ; } public static void loadBaiduAsrInfo ( ) { asrAppId = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; asrApiKey = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; asrSecretKey = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; asrUseRealTime = sp . getBoolean ( \"<STR_LIT>\" , false ) ; } public static void saveBaiduAsrInfo ( String appId , String apiKey , String secretKey , boolean useRealTime ) { asrApiKey = apiKey ; asrAppId = appId ; asrSecretKey = secretKey ; asrUseRealTime = useRealTime ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( \"<STR_LIT>\" , asrAppId ) ; editor . putString ( \"<STR_LIT>\" , asrApiKey ) ; editor . putString ( \"<STR_LIT>\" , asrSecretKey ) ; editor . putBoolean ( \"<STR_LIT>\" , asrUseRealTime ) ; editor . apply ( ) ; } public static void loadGptApiInfo ( ) { gptApiHost = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; gptApiKey = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; gptModel = sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; customModels = new ArrayList < > ( Arrays . asList ( sp . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) ) ) ; customModels . removeIf ( String :: isEmpty ) ; } public static void saveGptApiInfo ( String host , String key , String model , List < String > customModelList ) { gptApiHost = host ; gptApiKey = key ; gptModel = model ; customModels = customModelList ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putString ( \"<STR_LIT>\" , gptApiHost ) ; editor . putString ( \"<STR_LIT>\" , gptApiKey ) ; editor . putString ( \"<STR_LIT>\" , gptModel ) ; editor . putString ( \"<STR_LIT>\" , String . join ( \"<STR_LIT>\" , customModels ) ) ; editor . apply ( ) ; } public static void loadStartUpSetting ( ) { checkAccessOnStart = sp . getBoolean ( \"<STR_LIT>\" , true ) ; } public static void saveStartUpSetting ( boolean checkAccess ) { checkAccessOnStart = checkAccess ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , checkAccessOnStart ) ; editor . apply ( ) ; } public static void loadTtsSetting ( ) { defaultEnableTts = sp . getBoolean ( \"<STR_LIT>\" , true ) ; } public static void saveTtsSetting ( boolean enable ) { defaultEnableTts = enable ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , defaultEnableTts ) ; editor . apply ( ) ; } public static void loadMultiChatSetting ( ) { defaultEnableMultiChat = sp . getBoolean ( \"<STR_LIT>\" , false ) ;", "output": "} public static void saveMultiChatSetting ( boolean defaultEnable ) { defaultEnableMultiChat = defaultEnable ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , defaultEnableMultiChat ) ; editor . apply ( ) ; } public static void loadSelectedTab ( ) { selectedTab = sp . getInt ( \"<STR_LIT>\" , - <NUM_LIT> ) ; } public static void saveSelectedTab ( int tab ) { selectedTab = tab ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putInt ( \"<STR_LIT>\" , selectedTab ) ; editor . apply ( ) ; } public static void loadFunctionSetting ( ) { enableInternetAccess = sp . getBoolean ( \"<STR_LIT>\" , false ) ; webMaxCharCount = sp . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; onlyLatestWebResult = sp . getBoolean ( \"<STR_LIT>\" , false ) ; } public static void saveFunctionSetting ( boolean enableInternet , int maxCharCount , boolean onlyLatest ) { enableInternetAccess = enableInternet ; webMaxCharCount = maxCharCount ; onlyLatestWebResult = onlyLatest ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , enableInternetAccess ) ; editor . putInt ( \"<STR_LIT>\" , webMaxCharCount ) ; editor . putBoolean ( \"<STR_LIT>\" , onlyLatestWebResult ) ; editor . apply ( ) ; } public static void loadVisionSetting ( ) { limitVisionSize = sp . getBoolean ( \"<STR_LIT>\" , false ) ; } public static void saveVisionSetting ( boolean limitSize ) { limitVisionSize = limitSize ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , limitVisionSize ) ; editor . apply ( ) ; } public static void loadHistorySetting ( ) { autoSaveHistory = sp . getBoolean ( \"<STR_LIT>\" , true ) ; } public static void saveHistorySetting ( boolean autoSave ) { autoSaveHistory = autoSave ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , autoSaveHistory ) ; editor . apply ( ) ; } public static boolean getAsrUseWhisper ( ) { return asrUseWhisper ; } public static boolean getAsrUseGoogle ( ) { return asrUseGoogle ; } public static boolean getAsrUseBaidu ( ) { return asrUseBaidu ; } public static String getAsrAppId ( ) { return asrAppId ; } public static String getAsrApiKey ( ) { return asrApiKey ; } public static String getAsrSecretKey ( ) { return asrSecretKey ; } public static boolean getAsrUseRealTime ( ) { return asrUseRealTime ; } public static String getGptApiHost ( ) { return gptApiHost ; } public static String getGptApiKey ( ) { return gptApiKey ; } public static String getGptModel ( ) { return gptModel ; } public static List < String > getCustomModels ( ) { return customModels ; } public static boolean getCheckAccessOnStart ( ) { return checkAccessOnStart ; } public static boolean getDefaultEnableTts ( ) { return defaultEnableTts ; } public static boolean getDefaultEnableMultiChat ( ) { return defaultEnableMultiChat ; } public static int getSelectedTab ( ) { return selectedTab ; } public static boolean getEnableInternetAccess ( ) { return enableInternetAccess ; } public static int getWebMaxCharCount ( ) { return webMaxCharCount ; } public static boolean getOnlyLatestWebResult ( ) { return onlyLatestWebResult ; } public static boolean getLimitVisionSize ( ) { return limitVisionSize ; } public static boolean getAutoSaveHistory ( ) { return autoSaveHistory ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . content . Context ; import android . graphics . Rect ; import android . graphics . drawable . Drawable ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . ViewGroup ; import android . view . ViewGroupOverlay ; import android . widget . FrameLayout ; import android . widget . TextView ; import java . util . Objects ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . widget . AppCompatTextView ; import androidx . core . math . MathUtils ; import androidx . core . util . Consumer ; public class FastScroller { private final int mMinTouchTargetSize ; private final int mTouchSlop ; @ NonNull private final ViewGroup mView ; @ NonNull private final ViewHelper mViewHelper ; @ Nullable private Rect mUserPadding ; @ NonNull private final AnimationHelper mAnimationHelper ; private final int mTrackWidth ; private final int mThumbWidth ; private final int mThumbHeight ; @ NonNull private final View mTrackView ; @ NonNull private final View mThumbView ; @ NonNull private final TextView mPopupView ; private boolean mScrollbarEnabled ; private int mThumbOffset ; private float mDownX ; private float mDownY ; private float mLastY ; private float mDragStartY ; private int mDragStartThumbOffset ; private boolean mDragging ; @ NonNull private final Runnable mAutoHideScrollbarRunnable = this :: autoHideScrollbar ; @ NonNull private final Rect mTempRect = new Rect ( ) ; public FastScroller ( @ NonNull ViewGroup view , @ NonNull ViewHelper viewHelper , @ Nullable Rect padding , @ NonNull Drawable trackDrawable , @ NonNull Drawable thumbDrawable , @ NonNull Consumer < TextView > popupStyle , @ NonNull AnimationHelper animationHelper ) { mMinTouchTargetSize = view . getResources ( ) . getDimensionPixelSize ( R . dimen . afs_min_touch_target_size ) ; Context context = view . getContext ( ) ; mTouchSlop = ViewConfiguration . get ( context ) . getScaledTouchSlop ( ) ; mView = view ; mViewHelper = viewHelper ; mUserPadding = padding ; mAnimationHelper = animationHelper ; mTrackWidth = requireNonNegative ( trackDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbWidth = requireNonNegative ( thumbDrawable . getIntrinsicWidth ( ) , \"<STR_LIT>\" ) ; mThumbHeight = requireNonNegative ( thumbDrawable . getIntrinsicHeight ( ) , \"<STR_LIT>\" ) ; mTrackView = new View ( context ) ; mTrackView . setBackground ( trackDrawable ) ; mThumbView = new View ( context ) ; mThumbView . setBackground ( thumbDrawable ) ; mPopupView = new AppCompatTextView ( context ) ; mPopupView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; popupStyle . accept ( mPopupView ) ; ViewGroupOverlay overlay = mView . getOverlay ( ) ; overlay . add ( mTrackView ) ; overlay . add ( mThumbView ) ; overlay . add ( mPopupView ) ; postAutoHideScrollbar ( ) ; mPopupView . setAlpha ( <NUM_LIT> ) ; mViewHelper . addOnPreDrawListener ( this :: onPreDraw ) ; mViewHelper . addOnScrollChangedListener ( this :: onScrollChanged ) ; mViewHelper . addOnTouchEventListener ( this :: onTouchEvent ) ; } private static int requireNonNegative ( int value , @ NonNull String message ) { if ( value < <NUM_LIT> ) { throw new IllegalArgumentException ( message ) ; } return value ; } public void setPadding ( int left , int top , int right , int bottom ) { if ( mUserPadding != null && mUserPadding . left == left && mUserPadding . top == top && mUserPadding . right == right && mUserPadding . bottom == bottom ) { return ; } if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( left , top , right , bottom ) ; mView . invalidate ( ) ; } public void setPadding ( @ Nullable Rect padding ) { if ( Objects . equals ( mUserPadding , padding ) ) { return ; } if ( padding != null ) { if ( mUserPadding == null ) { mUserPadding = new Rect ( ) ; } mUserPadding . set ( padding ) ; } else { mUserPadding = null ; } mView . invalidate ( ) ; } @ NonNull private Rect getPadding ( ) { if ( mUserPadding != null ) { mTempRect . set ( mUserPadding ) ; } else { mTempRect . set ( mView . getPaddingLeft ( ) , mView . getPaddingTop ( ) , mView . getPaddingRight ( ) , mView . getPaddingBottom ( ) ) ; } return mTempRect ; } private void onPreDraw ( ) { updateScrollbarState ( ) ; mTrackView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; mThumbView . setVisibility ( mScrollbarEnabled ? View . VISIBLE : View . INVISIBLE ) ; if ( ! mScrollbarEnabled ) { mPopupView . setVisibility ( View . INVISIBLE ) ; return ; } int layoutDirection = mView . getLayoutDirection ( ) ; mTrackView . setLayoutDirection ( layoutDirection ) ; mThumbView . setLayoutDirection ( layoutDirection ) ; mPopupView . setLayoutDirection ( layoutDirection ) ; boolean isLayoutRtl = layoutDirection == View . LAYOUT_DIRECTION_RTL ; int viewWidth = mView . getWidth ( ) ; int viewHeight = mView . getHeight ( ) ; Rect padding = getPadding ( ) ; int trackLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mTrackWidth ; layoutView ( mTrackView , trackLeft , padding . top , trackLeft + mTrackWidth , Math . max ( viewHeight - padding . bottom , padding . top ) ) ; int thumbLeft = isLayoutRtl ? padding . left : viewWidth - padding . right - mThumbWidth ; int thumbTop = padding . top + mThumbOffset ; layoutView ( mThumbView , thumbLeft , thumbTop , thumbLeft + mThumbWidth , thumbTop + mThumbHeight ) ; CharSequence popupText = mViewHelper . getPopupText ( ) ; boolean hasPopup = ! TextUtils . isEmpty ( popupText ) ; mPopupView . setVisibility ( hasPopup ? View . VISIBLE : View . INVISIBLE ) ; if ( hasPopup ) { FrameLayout . LayoutParams popupLayoutParams = ( FrameLayout . LayoutParams ) mPopupView . getLayoutParams ( ) ; if ( ! Objects . equals ( mPopupView . getText ( ) , popupText ) ) { mPopupView . setText ( popupText ) ; int widthMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewWidth , View . MeasureSpec . EXACTLY ) , padding . left + padding . right + mThumbWidth + popupLayoutParams . leftMargin + popupLayoutParams . rightMargin , popupLayoutParams . width ) ; int heightMeasureSpec = ViewGroup . getChildMeasureSpec ( View . MeasureSpec . makeMeasureSpec ( viewHeight , View . MeasureSpec . EXACTLY ) , padding . top + padding . bottom + popupLayoutParams . topMargin + popupLayoutParams . bottomMargin , popupLayoutParams . height ) ; mPopupView . measure ( widthMeasureSpec , heightMeasureSpec ) ; } int popupWidth = mPopupView . getMeasuredWidth ( ) ; int popupHeight = mPopupView . getMeasuredHeight ( ) ; int popupLeft = isLayoutRtl ? padding . left + mThumbWidth + popupLayoutParams . leftMargin : viewWidth - padding . right - mThumbWidth - popupLayoutParams . rightMargin - popupWidth ; int popupAnchorY ; switch ( popupLayoutParams . gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) { case Gravity . LEFT : default : popupAnchorY = <NUM_LIT> ; break ; case Gravity . CENTER_HORIZONTAL : popupAnchorY = popupHeight / <NUM_LIT> ; break ; case Gravity . RIGHT : popupAnchorY = popupHeight ; break ; } int thumbAnchorY ; switch ( popupLayoutParams . gravity & Gravity . VERTICAL_GRAVITY_MASK ) { case Gravity . TOP : default : thumbAnchorY = mThumbView . getPaddingTop ( ) ; break ; case Gravity . CENTER_VERTICAL : { int thumbPaddingTop = mThumbView . getPaddingTop ( ) ; thumbAnchorY = thumbPaddingTop + ( mThumbHeight - thumbPaddingTop - mThumbView . getPaddingBottom ( ) ) / <NUM_LIT> ; break ; } case Gravity . BOTTOM : thumbAnchorY = mThumbHeight - mThumbView . getPaddingBottom ( ) ; break ; } int popupTop = MathUtils . clamp ( thumbTop + thumbAnchorY - popupAnchorY , padding . top + popupLayoutParams . topMargin , viewHeight - padding . bottom - popupLayoutParams . bottomMargin - popupHeight ) ; layoutView ( mPopupView , popupLeft , popupTop , popupLeft + popupWidth , popupTop + popupHeight ) ; } } private void updateScrollbarState ( ) { int scrollOffsetRange = getScrollOffsetRange ( ) ; mScrollbarEnabled = scrollOffsetRange > <NUM_LIT> ; mThumbOffset = mScrollbarEnabled ? ( int ) ( ( long ) getThumbOffsetRange ( ) * mViewHelper . getScrollOffset ( ) / scrollOffsetRange ) : <NUM_LIT> ; } private void layoutView ( @ NonNull View view , int left , int top , int right , int bottom ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; view . layout ( scrollX + left , scrollY + top , scrollX + right , scrollY + bottom ) ; } private void onScrollChanged ( ) { updateScrollbarState ( ) ; if ( ! mScrollbarEnabled ) { return ; } mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; postAutoHideScrollbar ( ) ; } private boolean onTouchEvent ( @ NonNull MotionEvent event ) { if ( ! mScrollbarEnabled ) { return false ; } float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; Rect padding = getPadding ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : mDownX = eventX ; mDownY = eventY ; if ( mThumbView . getAlpha ( ) > <NUM_LIT> && isInViewTouchTarget ( mThumbView , eventX , eventY ) ) { mDragStartY = eventY ; mDragStartThumbOffset = mThumbOffset ; setDragging ( true ) ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mDragging && isInViewTouchTarget ( mTrackView , mDownX , mDownY ) && Math . abs ( eventY - mDownY ) > mTouchSlop ) { if ( isInViewTouchTarget ( mThumbView , mDownX , mDownY ) ) { mDragStartY = mLastY ; mDragStartThumbOffset = mThumbOffset ; } else { mDragStartY = eventY ; mDragStartThumbOffset = ( int ) ( eventY - padding . top - mThumbHeight / <NUM_LIT> ) ; scrollToThumbOffset ( mDragStartThumbOffset ) ; } setDragging ( true ) ; } if ( mDragging ) { int thumbOffset = mDragStartThumbOffset + ( int ) ( eventY - mDragStartY ) ; scrollToThumbOffset ( thumbOffset ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : setDragging ( false ) ; break ; } mLastY = eventY ; return mDragging ; } private boolean isInView ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return x >= view . getLeft ( ) - scrollX && x < view . getRight ( ) - scrollX && y >= view . getTop ( ) - scrollY && y < view . getBottom ( ) - scrollY ; } private boolean isInViewTouchTarget ( @ NonNull View view , float x , float y ) { int scrollX = mView . getScrollX ( ) ; int scrollY = mView . getScrollY ( ) ; return isInTouchTarget ( x , view . getLeft ( ) - scrollX , view . getRight ( ) - scrollX , <NUM_LIT> , mView . getWidth ( ) ) && isInTouchTarget ( y , view . getTop ( ) - scrollY , view . getBottom ( ) - scrollY , <NUM_LIT> , mView . getHeight ( ) ) ; } private boolean isInTouchTarget ( float position , int viewStart , int viewEnd , int parentStart , int parentEnd ) { int viewSize = viewEnd - viewStart ; if ( viewSize >= mMinTouchTargetSize ) { return position >= viewStart && position < viewEnd ; } int touchTargetStart = viewStart - ( mMinTouchTargetSize - viewSize ) / <NUM_LIT> ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } int touchTargetEnd = touchTargetStart + mMinTouchTargetSize ; if ( touchTargetEnd > parentEnd ) { touchTargetEnd = parentEnd ; touchTargetStart = touchTargetEnd - mMinTouchTargetSize ; if ( touchTargetStart < parentStart ) { touchTargetStart = parentStart ; } } return position >= touchTargetStart && position < touchTargetEnd ; } private void scrollToThumbOffset ( int thumbOffset ) { int thumbOffsetRange = getThumbOffsetRange ( ) ; thumbOffset = MathUtils . clamp ( thumbOffset , <NUM_LIT> , thumbOffsetRange ) ; int scrollOffset = ( int ) ( ( long ) getScrollOffsetRange ( ) * thumbOffset / thumbOffsetRange ) ; mViewHelper . scrollTo ( scrollOffset ) ; } private int getScrollOffsetRange ( ) { return mViewHelper . getScrollRange ( ) - mView . getHeight ( ) ; } private int getThumbOffsetRange ( ) { Rect padding = getPadding ( ) ; return mView . getHeight ( ) - padding . top - padding . bottom - mThumbHeight ; } private void setDragging ( boolean dragging ) { if ( mDragging == dragging ) { return ; } mDragging = dragging ; if ( mDragging ) { mView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } mTrackView . setPressed ( mDragging ) ; mThumbView . setPressed ( mDragging ) ; if ( mDragging ) { cancelAutoHideScrollbar ( ) ; mAnimationHelper . showScrollbar ( mTrackView , mThumbView ) ; mAnimationHelper . showPopup ( mPopupView ) ; } else { postAutoHideScrollbar ( ) ; mAnimationHelper . hidePopup ( mPopupView ) ; } } private void postAutoHideScrollbar ( ) { cancelAutoHideScrollbar ( ) ; if ( mAnimationHelper . isScrollbarAutoHideEnabled ( ) ) { mView . postDelayed ( mAutoHideScrollbarRunnable , mAnimationHelper . getScrollbarAutoHideDelayMillis ( ) ) ; } } private void autoHideScrollbar ( ) { if ( mDragging ) { return ; } mAnimationHelper . hideScrollbar ( mTrackView , mThumbView ) ; } private void cancelAutoHideScrollbar ( ) { mView . removeCallbacks ( mAutoHideScrollbarRunnable ) ; } public interface ViewHelper { void addOnPreDrawListener ( @ NonNull Runnable onPreDraw ) ;", "output": "void addOnScrollChangedListener ( @ NonNull Runnable onScrollChanged ) ; void addOnTouchEventListener ( @ NonNull Predicate < MotionEvent > onTouchEvent ) ; int getScrollRange ( ) ; int getScrollOffset ( ) ; void scrollTo ( int offset ) ; @ Nullable default CharSequence getPopupText ( ) { return null ; } } public interface AnimationHelper { void showScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; void hideScrollbar ( @ NonNull View trackView , @ NonNull View thumbView ) ; boolean isScrollbarAutoHideEnabled ( ) ; int getScrollbarAutoHideDelayMillis ( ) ; void showPopup ( @ NonNull View popupView ) ; void hidePopup ( @ NonNull View popupView ) ; } }"}, {"input": "package com . wmods . wppenhacer . adapter ; import android . content . Context ; import android . graphics . Typeface ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ArrayAdapter ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . db . MessageHistory ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . List ; public class MessageAdapter extends ArrayAdapter < MessageHistory . MessageItem > { private final Context context ; private final List < MessageHistory . MessageItem > items ; public MessageAdapter ( Context context , List < MessageHistory . MessageItem > items ) { super ( context , android . R . layout . simple_list_item_2 , android . R . id . text1 , items ) ; this . context = context ; this . items = items ; } @ Override public int getCount ( ) { return items . size ( ) ; } @ Override public MessageHistory . MessageItem getItem ( int position ) { return items . get ( position ) ; } @ Override public long getItemId ( int position ) { return position ; } @ NonNull @ Override public View getView ( int position , View convertView , @ NonNull ViewGroup parent ) { View view1 = super . getView ( position , convertView , parent ) ; TextView textView0 = view1 . findViewById ( android . R . id . text1 ) ; textView0 . setTextSize ( <NUM_LIT> ) ; textView0 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView0 . setText ( this . items . get ( position ) . message ) ; TextView textView1 = view1 . findViewById ( android . R . id . text2 ) ; textView1 . setTextSize ( <NUM_LIT> ) ; textView1 . setAlpha ( <NUM_LIT> ) ; textView1 . setTypeface ( null , Typeface . ITALIC ) ;", "output": "textView1 . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; var timestamp = this . items . get ( position ) . timestamp ; textView1 . setText ( ( timestamp == <NUM_LIT> ? context . getString ( ResId . string . message_original ) : \"<STR_LIT>\" + Utils . getDateTimeFromMillis ( timestamp ) ) ) ; return view1 ; } }"}, {"input": "package com . wmods . wppenhacer . preference ; import android . content . Context ; import android . content . res . TypedArray ; import android . util . AttributeSet ; import android . widget . SeekBar ; import android . widget . TextView ; import androidx . preference . Preference ; import androidx . preference . PreferenceViewHolder ; import com . wmods . wppenhacer . R ; public class FloatSeekBarPreference extends Preference implements SeekBar . OnSeekBarChangeListener { private float minValue ; private float maxValue ; private float valueSpacing ; private String format ; private SeekBar seekbar ; private TextView textView ; private float defaultValue = <NUM_LIT> ; private float newValue = <NUM_LIT> ; public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( context , attrs , defStyleAttr , defStyleRes ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { this ( context , attrs , defStyleAttr , <NUM_LIT> ) ; } public FloatSeekBarPreference ( Context context , AttributeSet attrs ) { this ( context , attrs , androidx . preference . R . attr . seekBarPreferenceStyle ) ; } public FloatSeekBarPreference ( Context context ) { this ( context , null ) ; } @ Override protected Object onGetDefaultValue ( TypedArray ta , int index ) { defaultValue = ta . getFloat ( index , <NUM_LIT> ) ; return defaultValue ; } @ Override protected void onSetInitialValue ( Object defaultValue ) { newValue = getPersistedFloat ( ( defaultValue instanceof Float ) ? ( Float ) defaultValue : this . defaultValue ) ; } @ Override public void onBindViewHolder ( PreferenceViewHolder holder ) { super . onBindViewHolder ( holder ) ; holder . itemView . setClickable ( false ) ; seekbar = ( SeekBar ) holder . findViewById ( R . id . seekbar ) ; textView = ( TextView ) holder . findViewById ( R . id . seekbar_value ) ;", "output": "seekbar . setOnSeekBarChangeListener ( this ) ; seekbar . setMax ( ( int ) ( ( maxValue - minValue ) / valueSpacing ) ) ; seekbar . setProgress ( ( int ) ( ( newValue - minValue ) / valueSpacing ) ) ; seekbar . setEnabled ( isEnabled ( ) ) ; textView . setText ( String . format ( format , newValue ) ) ; } @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { if ( ! fromUser ) { return ; } float v = minValue + progress * valueSpacing ; textView . setText ( String . format ( format , v ) ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { float v = minValue + seekBar . getProgress ( ) * valueSpacing ; persistFloat ( v ) ; } private void init ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { setWidgetLayoutResource ( R . layout . pref_float_seekbar ) ; TypedArray ta = context . obtainStyledAttributes ( attrs , R . styleable . FloatSeekBarPreference , defStyleAttr , defStyleRes ) ; minValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_minValue , <NUM_LIT> ) ; maxValue = ta . getFloat ( R . styleable . FloatSeekBarPreference_maxValue , <NUM_LIT> ) ; valueSpacing = ta . getFloat ( R . styleable . FloatSeekBarPreference_valueSpacing , <NUM_LIT> ) ; format = ta . getString ( R . styleable . FloatSeekBarPreference_format ) ; if ( format == null ) { format = \"<STR_LIT>\" ; } ta . recycle ( ) ; } public float getValue ( ) { return ( seekbar != null ) ? ( seekbar . getProgress ( ) * valueSpacing ) + minValue : <NUM_LIT> ; } public void setValue ( float value ) { newValue = value ; persistFloat ( value ) ; notifyChanged ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import static de . robv . android . xposed . XposedHelpers . callMethod ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import android . annotation . SuppressLint ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . BaseAdapter ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeparateGroup extends Feature { public static final int CHATS = <NUM_LIT> ; public static final int STATUS = <NUM_LIT> ; public static final int CALLS = <NUM_LIT> ; public static final int COMMUNITY = <NUM_LIT> ; public static final int GROUPS = <NUM_LIT> ; public static ArrayList < Integer > tabs = new ArrayList < > ( ) ; public static HashMap < Integer , Object > tabInstances = new HashMap < > ( ) ; public SeparateGroup ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } public void doHook ( ) throws Exception { var cFrag = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var home = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; hookTabList ( home ) ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; hookTabIcon ( ) ; hookTabInstance ( cFrag ) ; hookTabName ( home ) ; hookTabCount ( ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private void hookTabCount ( ) throws Exception { var runMethod = Unobfuscator . loadTabCountMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( runMethod ) ) ; var enableCountMethod = Unobfuscator . loadEnableCountTabMethod ( classLoader ) ; var constructor1 = Unobfuscator . loadEnableCountTabConstructor1 ( classLoader ) ; var constructor2 = Unobfuscator . loadEnableCountTabConstructor2 ( classLoader ) ; var constructor3 = Unobfuscator . loadEnableCountTabConstructor3 ( classLoader ) ; constructor3 . setAccessible ( true ) ; logDebug ( Unobfuscator . getMethodDescriptor ( enableCountMethod ) ) ; XposedBridge . hookMethod ( enableCountMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var indexTab = ( int ) param . args [ <NUM_LIT> ] ; if ( indexTab == tabs . indexOf ( CHATS ) ) { var chatCount = <NUM_LIT> ; var groupCount = <NUM_LIT> ; synchronized ( SeparateGroup . class ) { var db = MessageStore . getInstance ( ) . getDatabase ( ) ; var sql = \"<STR_LIT>\" ; var cursor = db . rawQuery ( sql , null ) ; while ( cursor . moveToNext ( ) ) { int jid = cursor . getInt ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; int groupType = cursor . getInt ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; int archived = cursor . getInt ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; int chatLocked = cursor . getInt ( cursor . getColumnIndex ( \"<STR_LIT>\" ) ) ; if ( archived != <NUM_LIT> || ( groupType != <NUM_LIT> && groupType != <NUM_LIT> ) || chatLocked != <NUM_LIT> ) continue ; var sql2 = \"<STR_LIT>\" ; var cursor1 = db . rawQuery ( sql2 , new String [ ] { String . valueOf ( jid ) } ) ; if ( ! cursor1 . moveToFirst ( ) ) continue ; var server = cursor1 . getString ( cursor1 . getColumnIndex ( \"<STR_LIT>\" ) ) ; if ( server . equals ( \"<STR_LIT>\" ) ) { groupCount ++ ; } else { chatCount ++ ; } cursor1 . close ( ) ; } cursor . close ( ) ; } if ( tabs . contains ( CHATS ) && tabInstances . containsKey ( CHATS ) ) { var instance12 = chatCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( chatCount ) ; var instance22 = constructor1 . newInstance ( instance12 ) ; param . args [ <NUM_LIT> ] = instance22 ; } if ( tabs . contains ( GROUPS ) && tabInstances . containsKey ( GROUPS ) ) { var instance2 = groupCount <= <NUM_LIT> ? constructor3 . newInstance ( ) : constructor2 . newInstance ( groupCount ) ; var instance1 = constructor1 . newInstance ( instance2 ) ; enableCountMethod . invoke ( param . thisObject , param . args [ <NUM_LIT> ] , instance1 , tabs . indexOf ( GROUPS ) ) ; } } } } ) ; } private void hookTabIcon ( ) throws Exception { var iconTabMethod = Unobfuscator . loadIconTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( iconTabMethod ) ) ; var iconField = Unobfuscator . loadIconTabField ( classLoader ) ; var iconFrameField = Unobfuscator . loadIconTabLayoutField ( classLoader ) ; var iconMenuField = Unobfuscator . loadIconMenuField ( classLoader ) ; XposedBridge . hookMethod ( iconTabMethod , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var superClass = param . thisObject . getClass ( ) . getSuperclass ( ) ; if ( superClass != null && superClass == iconTabMethod . getDeclaringClass ( ) ) { var field1 = superClass . getDeclaredField ( iconField . getName ( ) ) . get ( param . thisObject ) ; var field2 = getObjectField ( field1 , iconFrameField . getName ( ) ) ; if ( field2 == null ) return ; var menu = ( Menu ) getObjectField ( field2 , iconMenuField . getName ( ) ) ; if ( menu == null ) return ; var menuItem = ( MenuItem ) menu . findItem ( GROUPS ) ; if ( menuItem != null ) { menuItem . setIcon ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } } } } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void hookTabName ( Class < ? > home ) throws Exception { var tabNameMethod = Unobfuscator . loadTabNameMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( tabNameMethod ) ) ; XposedBridge . hookMethod ( tabNameMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; var tab = ( int ) param . args [ <NUM_LIT> ] ; if ( tab == GROUPS ) { param . setResult ( UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) ) ; } } } ) ; } private void hookTabInstance ( Class < ? > cFrag ) throws Exception { var getTabMethod = Unobfuscator . loadGetTabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getTabMethod ) ) ; var methodTabInstance = Unobfuscator . loadTabFragmentMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( methodTabInstance ) ) ; var recreateFragmentMethod = Unobfuscator . loadRecreateFragmentConstructor ( classLoader ) ; XposedBridge . hookMethod ( recreateFragmentMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var object = param . args [ <NUM_LIT> ] ; var desc = XposedHelpers . getObjectField ( object , \"<STR_LIT>\" ) ; if ( desc == null ) return ; var split = desc . toString ( ) . split ( \"<STR_LIT>\" ) ; var id = <NUM_LIT> ; try { id = Integer . parseInt ( split [ split . length - <NUM_LIT> ] ) ; } catch ( Exception ignored ) { return ; } if ( id == GROUPS || id == CHATS ) { var convFragment = XposedHelpers . getObjectField ( param . thisObject , \"<STR_LIT>\" ) ;", "output": "tabInstances . remove ( id ) ; tabInstances . put ( id , convFragment ) ; } } } ) ; XposedBridge . hookMethod ( getTabMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; if ( tabId == GROUPS || tabId == CHATS ) { var convFragment = cFrag . newInstance ( ) ; param . setResult ( convFragment ) ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var tabId = ( ( Number ) tabs . get ( ( int ) param . args [ <NUM_LIT> ] ) ) . intValue ( ) ; tabInstances . remove ( tabId ) ; tabInstances . put ( tabId , param . getResult ( ) ) ; } } ) ; XposedBridge . hookMethod ( methodTabInstance , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var chatsList = ( List ) param . getResult ( ) ; var resultList = filterChat ( param . thisObject , chatsList ) ; param . setResult ( resultList ) ; } } ) ; var fabintMethod = Unobfuscator . loadFabMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( fabintMethod ) ) ; XposedBridge . hookMethod ( fabintMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( Objects . equals ( tabInstances . get ( GROUPS ) , param . thisObject ) ) { param . setResult ( GROUPS ) ; } } } ) ; var publishResultsMethod = Unobfuscator . loadGetFiltersMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( publishResultsMethod ) ) ; XposedBridge . hookMethod ( publishResultsMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var filters = param . args [ <NUM_LIT> ] ; var chatsList = ( List ) XposedHelpers . getObjectField ( filters , \"<STR_LIT>\" ) ; var baseField = Unobfuscator . getFieldByExtendType ( publishResultsMethod . getDeclaringClass ( ) , BaseAdapter . class ) ; if ( baseField == null ) return ; var convField = Unobfuscator . getFieldByType ( baseField . getType ( ) , cFrag ) ; Object thiz = convField . get ( baseField . get ( param . thisObject ) ) ; if ( thiz == null ) return ; var resultList = filterChat ( thiz , chatsList ) ; XposedHelpers . setObjectField ( filters , \"<STR_LIT>\" , resultList ) ; XposedHelpers . setIntField ( filters , \"<STR_LIT>\" , resultList . size ( ) ) ; } } ) ; } private List filterChat ( Object thiz , List chatsList ) { var tabChat = tabInstances . get ( CHATS ) ; var tabGroup = tabInstances . get ( GROUPS ) ; if ( ! Objects . equals ( tabChat , thiz ) && ! Objects . equals ( tabGroup , thiz ) ) { return chatsList ; } var editableChatList = new ArrayListFilter ( Objects . equals ( tabGroup , thiz ) ) ; editableChatList . addAll ( chatsList ) ; return editableChatList ; } private void hookTabList ( @ NonNull Class < ? > home ) throws Exception { var onCreateTabList = Unobfuscator . loadTabListMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateTabList ) ) ; var fieldTabsList = Arrays . stream ( home . getDeclaredFields ( ) ) . filter ( f -> f . getType ( ) . equals ( List . class ) ) . findFirst ( ) . orElse ( null ) ; if ( fieldTabsList == null ) { throw new NullPointerException ( \"<STR_LIT>\" ) ; } fieldTabsList . setAccessible ( true ) ; XposedBridge . hookMethod ( onCreateTabList , new XC_MethodHook ( ) { @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { tabs = ( ArrayList < Integer > ) fieldTabsList . get ( null ) ; if ( tabs == null ) return ; if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; if ( ! tabs . contains ( GROUPS ) ) { tabs . add ( tabs . isEmpty ( ) ? <NUM_LIT> : <NUM_LIT> , GROUPS ) ; } } } ) ; } public static class ArrayListFilter extends ArrayList < Object > { private final boolean isGroup ; public ArrayListFilter ( boolean isGroup ) { this . isGroup = isGroup ; } @ Override public void add ( int index , Object element ) { if ( checkGroup ( element ) ) { super . add ( index , element ) ; } } @ Override public boolean add ( Object object ) { if ( checkGroup ( object ) ) { return super . add ( object ) ; } return true ; } @ Override public boolean addAll ( @ NonNull Collection c ) { for ( var chat : c ) { if ( checkGroup ( chat ) ) { super . add ( chat ) ; } } return true ; } private boolean checkGroup ( Object chat ) { var requiredServer = isGroup ? \"<STR_LIT>\" : \"<STR_LIT>\" ; var jid = getObjectField ( chat , \"<STR_LIT>\" ) ; if ( XposedHelpers . findMethodExactIfExists ( jid . getClass ( ) , \"<STR_LIT>\" ) != null ) { var server = ( String ) callMethod ( jid , \"<STR_LIT>\" ) ; return server . equals ( requiredServer ) ; } return true ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; public class ResId { public static class drawable { public static int eye_disabled ; public static int eye_enabled ; public static int admin ; public static int preview_eye ; public static int ic_reload ; public static int refresh ; } public static class string { public static int edited_history ; public static int dnd_message ; public static int dnd_mode_title ; public static int freezelastseen_message ; public static int freezelastseen_title ; public static int activate ; public static int cancel ; public static int message_original ; public static int new_chat ; public static int number_with_country_code ; public static int message ; public static int download ; public static int error_when_saving_try_again ; public static int msg_text_status_not_downloadable ; public static int saved_to ; public static int restart_whatsapp ; public static int restart_wpp ; public static int send_blue_tick ; public static int sending_read_blue_tick ; public static int send ; public static int send_sticker ; public static int do_you_want_to_send_sticker ; public static int whatsapp_call ; public static int phone_call ; public static int yes ; public static int no ; public static int version_error ; public static int copy_to_clipboard ; public static int copied_to_clipboard ; public static int error_detected ; public static int rebooting ; public static int deleted_status ; public static int deleted_message ; public static int toast_online ; public static int message_removed_on ; public static int loading ; public static int delete_for_me ; public static int share_as_status ; public static int viewed_your_status ; public static int viewed_your_message ; public static int select_status_type ; public static int open_camera ; public static int edit_text ; public static int select_a_color ; public static int read_all_mark_as_read ;", "output": "public static int grant_permission ; public static int expiration ; public static int deleted_a_message_in_group ; } public static class array { public static int supported_versions_wpp ; public static int supported_versions_business ; } }"}, {"input": "package com . wmods . wppenhacer . views . dialog ; import android . content . Context ; import android . graphics . Color ; import android . graphics . Typeface ; import android . graphics . drawable . Drawable ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class TabDialogContent extends LinearLayout { private TextView mTitle ; private LinearLayout contentLinear ; public TabDialogContent ( Context context ) { super ( context ) ; init ( context ) ; } private void init ( Context context ) { var params = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ; setLayoutParams ( params ) ; setOrientation ( VERTICAL ) ; setBackground ( DesignUtils . createDrawable ( \"<STR_LIT>\" , DesignUtils . getPrimarySurfaceColor ( ) ) ) ; setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; LinearLayout layoutLine = new LinearLayout ( context ) ; layoutLine . setOrientation ( LinearLayout . HORIZONTAL ) ; var layoutParams = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; layoutParams . gravity = Gravity . CENTER_HORIZONTAL ; layoutParams . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; layoutLine . setLayoutParams ( layoutParams ) ; ImageView imageView = new ImageView ( context ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , LinearLayout . LayoutParams . MATCH_PARENT ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( DesignUtils . createDrawable ( \"<STR_LIT>\" , DesignUtils . getPrimaryTextColor ( ) ) ) ; layoutLine . addView ( imageView ) ; addView ( layoutLine ) ; mTitle = new TextView ( context ) ; var paramsTitle = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTitle . gravity = Gravity . CENTER ; paramsTitle . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mTitle . setLayoutParams ( paramsTitle ) ; mTitle . setGravity ( Gravity . CENTER ) ; mTitle . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; mTitle . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ; mTitle . setTypeface ( null , Typeface . BOLD ) ; addView ( mTitle ) ; var view = new View ( context ) ; var paramsView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , Utils . dipToPixels ( <NUM_LIT> ) ) ; paramsView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; view . setLayoutParams ( paramsView ) ; view . setBackgroundColor ( Color . GRAY ) ; addView ( view ) ; contentLinear = new LinearLayout ( context ) ; contentLinear . setOrientation ( LinearLayout . HORIZONTAL ) ; contentLinear . setGravity ( Gravity . CENTER_HORIZONTAL ) ; var paramsContent = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsContent . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) ) ; contentLinear . setLayoutParams ( paramsContent ) ; addView ( contentLinear ) ; } public void setTitle ( String title ) { mTitle . setText ( title ) ; } public void addTab ( String title , @ Nullable Drawable image , @ Nullable View . OnClickListener listener ) { var linearLayout = new LinearLayout ( getContext ( ) ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setGravity ( Gravity . CENTER ) ; var params = new LinearLayout . LayoutParams ( <NUM_LIT> , LinearLayout . LayoutParams . WRAP_CONTENT , <NUM_LIT> ) ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> ) ; linearLayout . setLayoutParams ( params ) ; linearLayout . setPadding ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; linearLayout . setBackground ( DesignUtils . createDrawable ( \"<STR_LIT>\" , DesignUtils . getPrimaryTextColor ( ) ) ) ; linearLayout . setOnClickListener ( listener ) ; var imageView = new ImageView ( getContext ( ) ) ; var paramsImageView = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; imageView . setLayoutParams ( paramsImageView ) ; imageView . setImageDrawable ( image ) ; linearLayout . addView ( imageView ) ; var textView = new TextView ( getContext ( ) ) ; var paramsTextView = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; paramsTextView . setMargins ( <NUM_LIT> , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; textView . setLayoutParams ( paramsTextView ) ; textView . setText ( title ) ; textView . setTextColor ( DesignUtils . getPrimaryTextColor ( ) ) ; textView . setTextSize ( TypedValue . COMPLEX_UNIT_SP , <NUM_LIT> ) ;", "output": "textView . setTypeface ( null , Typeface . BOLD ) ; linearLayout . addView ( textView ) ; contentLinear . addView ( linearLayout ) ; } }"}, {"input": "package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . res . AssetFileDescriptor ; import android . content . res . AssetManager ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . ApksUtils ; import com . norman . webviewup . lib . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . channels . FileChannel ; public class UpgradeAssetSource extends UpgradePathSource { private final String assetName ; public UpgradeAssetSource ( Context context , @ NonNull String assetName , @ NonNull File file ) { super ( context , file . getPath ( ) ) ; this . assetName = assetName ; } private final Runnable copyAssetRunnable = new Runnable ( ) { @ Override public void run ( ) { FileOutputStream outputStream = null ; FileInputStream inputStream = null ; try { FileUtils . createFile ( getApkPath ( ) ) ; outputStream = new FileOutputStream ( getApkPath ( ) ) ; FileChannel dstChannel = outputStream . getChannel ( ) ; AssetManager assetManager = getContext ( ) . getAssets ( ) ; AssetFileDescriptor assetFileDescriptor = assetManager . openFd ( assetName ) ; inputStream = assetFileDescriptor . createInputStream ( ) ; FileChannel fileChannel = inputStream . getChannel ( ) ; long startOffset = assetFileDescriptor . getStartOffset ( ) ; long declaredLength = assetFileDescriptor . getDeclaredLength ( ) ; int size = <NUM_LIT> ; long partSize = ( long ) Math . ceil ( declaredLength * <NUM_LIT> / size ) ; long position = startOffset ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { long count = i != size - <NUM_LIT> ? partSize : declaredLength - i * partSize ; fileChannel . transferTo ( position , count , dstChannel ) ; process ( i * <NUM_LIT> / size ) ; position = position + count ; }", "output": "success ( ) ; } catch ( Throwable e ) { FileUtils . delete ( getApkPath ( ) ) ; error ( e ) ; } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException ignore ) { } } if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ignore ) { } } } } } ; @ Override protected void onPrepare ( Object params ) { new Thread ( copyAssetRunnable ) . start ( ) ; } }"}, {"input": "public class MainActivity extends AppCompatActivity { public Socket createSocket ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { String [ ] weakCiphers = { \"<STR_LIT>\" } ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ;", "output": "s . setEnabledCipherSuites ( weakCiphers ) ; return s ; } public Socket createSocket1 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { String [ ] a = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < a . length ; i ++ ) { a [ i ] = \"<STR_LIT>\" ; } if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( a ) ; return s ; } public Socket createSocket2 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > weakCiphers = new ArrayList < > ( ) ; weakCiphers . add ( \"<STR_LIT>\" ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( weakCiphers . toArray ( ) ) ; return s ; } public Socket createSocket3 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > mixCiphers = new ArrayList < > ( ) ; String [ ] mixedStrenghtCiphers = { \"<STR_LIT>\" , \"<STR_LIT>\" , } ; mixCiphers . addAll ( mixedStrenghtCiphers ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( mixCiphers . toArray ( ) ) ; return s ; } public Socket createSocket4 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > weakCiphers = new ArrayList < > ( ) ; String [ ] b = new String [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < a . length ; i ++ ) { b [ i ] = \"<STR_LIT>\" ; } if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( b ) ; return s ; } public Socket createSocket5 ( InetAddress address , int port , InetAddress localAddress , int localPort ) throws IOException { ArrayList < String > strongCiphers = new ArrayList < > ( ) ; strongCiphers . add ( \"<STR_LIT>\" ) ; if ( g_IOException != null ) throw g_IOException ; SSLSocket s = ( SSLSocket ) g_factory . createSocket ( address , port , localAddress , localPort ) ; s . setEnabledCipherSuites ( strongCiphers ) ; return s ; } }"}, {"input": "package com . appspa . update . listener . impl ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . UpdateLog ; public class DefaultUpdateFailureListener implements OnUpdateFailureListener { @ Override public void onFailure ( UpdateError error ) { UpdateLog . e ( error ) ; }", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . cloudinary ; public interface DownloadResourceResultCallback { void success ( String path ) ; void error ( String message ) ;", "output": "}"}, {"input": "package androidx . fluidrecyclerview . widget ; import android . annotation . SuppressLint ; import androidx . annotation . NonNull ; public class BatchingListUpdateCallback implements ListUpdateCallback { private static final int TYPE_NONE = <NUM_LIT> ; private static final int TYPE_ADD = <NUM_LIT> ; private static final int TYPE_REMOVE = <NUM_LIT> ; private static final int TYPE_CHANGE = <NUM_LIT> ; final ListUpdateCallback mWrapped ; int mLastEventType = TYPE_NONE ; int mLastEventPosition = - <NUM_LIT> ; int mLastEventCount = - <NUM_LIT> ; Object mLastEventPayload = null ; public BatchingListUpdateCallback ( @ NonNull ListUpdateCallback callback ) { mWrapped = callback ; } public void dispatchLastEvent ( ) { if ( mLastEventType == TYPE_NONE ) { return ; } switch ( mLastEventType ) { case TYPE_ADD : mWrapped . onInserted ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_REMOVE : mWrapped . onRemoved ( mLastEventPosition , mLastEventCount ) ; break ; case TYPE_CHANGE : mWrapped . onChanged ( mLastEventPosition , mLastEventCount , mLastEventPayload ) ; break ; } mLastEventPayload = null ; mLastEventType = TYPE_NONE ; } @ Override public void onInserted ( int position , int count ) { if ( mLastEventType == TYPE_ADD && position >= mLastEventPosition && position <= mLastEventPosition + mLastEventCount ) { mLastEventCount += count ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; return ; } dispatchLastEvent ( ) ;", "output": "mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_ADD ; } @ Override public void onRemoved ( int position , int count ) { if ( mLastEventType == TYPE_REMOVE && mLastEventPosition >= position && mLastEventPosition <= position + count ) { mLastEventCount += count ; mLastEventPosition = position ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventType = TYPE_REMOVE ; } @ Override public void onMoved ( int fromPosition , int toPosition ) { dispatchLastEvent ( ) ; mWrapped . onMoved ( fromPosition , toPosition ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public void onChanged ( int position , int count , Object payload ) { if ( mLastEventType == TYPE_CHANGE && ! ( position > mLastEventPosition + mLastEventCount || position + count < mLastEventPosition || mLastEventPayload != payload ) ) { int previousEnd = mLastEventPosition + mLastEventCount ; mLastEventPosition = Math . min ( position , mLastEventPosition ) ; mLastEventCount = Math . max ( previousEnd , position + count ) - mLastEventPosition ; return ; } dispatchLastEvent ( ) ; mLastEventPosition = position ; mLastEventCount = count ; mLastEventPayload = payload ; mLastEventType = TYPE_CHANGE ; } }"}, {"input": "package com . reactnative . pulltorefresh ; import android . annotation . SuppressLint ; import android . content . Context ; import android . view . View ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . PointerEvents ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . views . view . ReactViewGroup ; import com . scwang . smart . refresh . layout . api . RefreshFooter ; import com . scwang . smart . refresh . layout . api . RefreshKernel ; import com . scwang . smart . refresh . layout . api . RefreshLayout ; import com . scwang . smart . refresh . layout . constant . RefreshState ; import com . scwang . smart . refresh . layout . constant . SpinnerStyle ; @ SuppressLint ( \"<STR_LIT>\" ) public class PullToRefreshFooter extends ReactViewGroup implements RefreshFooter { private RefreshKernel mRefreshKernel ; private OnRefreshChangeListener onRefreshChangeListener ; private boolean mIsLoadingMore = false ; private boolean mEnableAutoloadMore = true ; private boolean mNoMoreData = false ; public void setOnRefreshHeaderChangeListener ( OnRefreshChangeListener onRefreshChangeListener ) { this . onRefreshChangeListener = onRefreshChangeListener ; } public PullToRefreshFooter ( Context context ) { super ( context ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int measureMode = MeasureSpec . getMode ( heightMeasureSpec ) ; if ( measureMode == MeasureSpec . AT_MOST ) { heightMeasureSpec = MeasureSpec . makeMeasureSpec ( getMeasuredHeight ( ) , MeasureSpec . EXACTLY ) ; } super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( getParent ( ) instanceof PullToRefresh && mRefreshKernel == null ) { PullToRefresh refreshLayout = ( PullToRefresh ) getParent ( ) ; int h = MeasureSpec . getSize ( heightMeasureSpec ) ; refreshLayout . setFooterHeightPx ( h ) ; } } PullToRefreshFooterLocalData footerLocalData = new PullToRefreshFooterLocalData ( ) ; @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( footerLocalData . viewRect . top == top && footerLocalData . viewRect . bottom == bottom && footerLocalData . viewRect . left == left && footerLocalData . viewRect . right == right ) { return ; } footerLocalData . viewRect . top = top ; footerLocalData . viewRect . bottom = bottom ; footerLocalData . viewRect . left = left ; footerLocalData . viewRect . right = right ; Context context = getContext ( ) ; if ( context instanceof ReactContext ) { ReactContext reactContext = ( ReactContext ) context ; UIManagerModule uiManagerModule = reactContext . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule != null ) { uiManagerModule . setViewLocalData ( getId ( ) , footerLocalData ) ; } }", "output": "} public void setLoadingMore ( boolean loadingMore ) { mIsLoadingMore = loadingMore ; if ( loadingMore ) { beginLoadMore ( ) ; } else { finishLoadMore ( ) ; } } @ Override public boolean setNoMoreData ( boolean noMoreData ) { mNoMoreData = noMoreData ; if ( mRefreshKernel != null ) { mRefreshKernel . getRefreshLayout ( ) . setNoMoreData ( noMoreData ) ; return noMoreData ; } return false ; } public void setAutoLoadMore ( boolean enable ) { mEnableAutoloadMore = enable ; if ( mRefreshKernel != null ) { mRefreshKernel . getRefreshLayout ( ) . setEnableAutoLoadMore ( enable ) ; } } @ NonNull @ Override public View getView ( ) { return this ; } public void beginLoadMore ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isHeader && ! refreshState . isOpening ) { mRefreshKernel . getRefreshLayout ( ) . autoLoadMore ( ) ; } } } public void finishLoadMore ( ) { if ( mRefreshKernel != null ) { RefreshState refreshState = mRefreshKernel . getRefreshLayout ( ) . getState ( ) ; if ( ! refreshState . isHeader && ! refreshState . isFinishing ) { mRefreshKernel . getRefreshLayout ( ) . finishLoadMore ( ) ; } } } @ NonNull @ Override public SpinnerStyle getSpinnerStyle ( ) { return SpinnerStyle . Translate ; } @ Override public void setPrimaryColors ( int ... colors ) { } @ Override public void onInitialized ( @ NonNull RefreshKernel kernel , int height , int maxDragHeight ) { mRefreshKernel = kernel ; mRefreshKernel . getRefreshLayout ( ) . setOnLoadMoreListener ( refreshLayout -> { if ( onRefreshChangeListener != null ) { onRefreshChangeListener . onRefresh ( ) ; } } ) ; setLoadingMore ( mIsLoadingMore ) ; setAutoLoadMore ( mEnableAutoloadMore ) ; setNoMoreData ( mNoMoreData ) ; } @ Override public void onMoving ( boolean isDragging , float percent , int offset , int height , int maxDragHeight ) { if ( isDragging && onRefreshChangeListener != null ) { onRefreshChangeListener . onOffsetChange ( offset ) ; } } @ Override public void onReleased ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public void onStartAnimator ( @ NonNull RefreshLayout refreshLayout , int height , int maxDragHeight ) { } @ Override public int onFinish ( @ NonNull RefreshLayout refreshLayout , boolean success ) { return <NUM_LIT> ; } @ Override public void onHorizontalDrag ( float percentX , int offsetX , int offsetMax ) { } @ Override public boolean isSupportHorizontalDrag ( ) { return false ; } @ Override public boolean autoOpen ( int duration , float dragRate , boolean animationOnly ) { return false ; } @ Override public void onStateChanged ( @ NonNull RefreshLayout refreshLayout , @ NonNull RefreshState oldState , @ NonNull RefreshState newState ) { if ( onRefreshChangeListener != null ) { PullToRefreshState oldPullToRefreshState = convertRefreshStateToPullToRefreshState ( oldState ) ; PullToRefreshState newPullToRefreshState = convertRefreshStateToPullToRefreshState ( newState ) ; if ( newPullToRefreshState != oldPullToRefreshState ) { onRefreshChangeListener . onStateChanged ( newPullToRefreshState ) ; } } } @ Override public PointerEvents getPointerEvents ( ) { RefreshState refreshState = mRefreshKernel != null ? mRefreshKernel . getRefreshLayout ( ) . getState ( ) : RefreshState . None ; if ( refreshState . isHeader && refreshState . isOpening ) { return super . getPointerEvents ( ) ; } return PointerEvents . NONE ; } private PullToRefreshState convertRefreshStateToPullToRefreshState ( RefreshState state ) { if ( state == RefreshState . ReleaseToLoad ) { return PullToRefreshState . Coming ; } if ( state == RefreshState . Loading || state == RefreshState . LoadReleased ) { return PullToRefreshState . Refreshing ; } return PullToRefreshState . Idle ; } }"}, {"input": "package com . android . internal . os ; public class RuntimeInit { public static final void main ( String [ ] argv ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ;", "output": "} }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . translation ; import androidx . annotation . NonNull ; import com . google . android . gms . tasks . OnFailureListener ; import com . google . android . gms . tasks . OnSuccessListener ; import com . google . mlkit . common . model . DownloadConditions ; import com . google . mlkit . common . model . RemoteModelManager ; import com . google . mlkit . nl . translate . TranslateRemoteModel ; import com . google . mlkit . nl . translate . Translator ; import com . google . mlkit . nl . translate . TranslatorOptions ; import java . util . Set ; public class Translation { private RemoteModelManager modelManager ; public Translation ( ) { this . modelManager = RemoteModelManager . getInstance ( ) ; } public void deleteDownloadedModel ( String language , final DeleteDownloadedModelResultCallback resultCallback ) { TranslateRemoteModel frenchModel = new TranslateRemoteModel . Builder ( language ) . build ( ) ; modelManager . deleteDownloadedModel ( frenchModel ) . addOnSuccessListener ( ( OnSuccessListener ) result -> { resultCallback . success ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void downloadModel ( String language , final DownloadModelResultCallback resultCallback ) { TranslateRemoteModel frenchModel = new TranslateRemoteModel . Builder ( language ) . build ( ) ; DownloadConditions conditions = new DownloadConditions . Builder ( ) . requireWifi ( ) . build ( ) ; modelManager . download ( frenchModel , conditions ) . addOnSuccessListener ( ( OnSuccessListener ) result -> { resultCallback . success ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void getDownloadedModels ( final GetDownloadedModelsResultCallback resultCallback ) { modelManager . getDownloadedModels ( TranslateRemoteModel . class ) . addOnSuccessListener ( ( OnSuccessListener < Set < TranslateRemoteModel > > ) models -> { resultCallback . success ( models ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; } ) ; } public void translate ( String text , String sourceLanguage , String targetLanguage , final TranslateResultCallback resultCallback ) { TranslatorOptions options = new TranslatorOptions . Builder ( ) . setSourceLanguage ( sourceLanguage ) . setTargetLanguage ( targetLanguage ) . build ( ) ; final Translator translator = com . google . mlkit . nl . translate . Translation . getClient ( options ) ; DownloadConditions conditions = new DownloadConditions . Builder ( ) . requireWifi ( ) . build ( ) ; translator . downloadModelIfNeeded ( conditions ) . addOnSuccessListener ( ( OnSuccessListener ) downloadModelIfNeededResult -> { translator . translate ( text ) . addOnSuccessListener ( ( OnSuccessListener < String > ) translateResult -> { resultCallback . success ( translateResult ) ; translator . close ( ) ; } ) . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; translator . close ( ) ; } ) ; }", "output": ") . addOnFailureListener ( exception -> { resultCallback . error ( exception ) ; translator . close ( ) ; } ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . media ; import android . annotation . SuppressLint ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . widget . Toast ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DownloadViewOnce extends Feature { public DownloadViewOnce ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var initIntField = Unobfuscator . loadViewOnceDownloadMenuField2 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( initIntField ) ) ; var callMethod = Unobfuscator . loadViewOnceDownloadMenuCallMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( callMethod ) ) ; var fileField = Unobfuscator . loadStatusDownloadFileField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( fileField ) ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . download ) . setIcon ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { try { var i = XposedHelpers . getIntField ( param . thisObject , initIntField . getName ( ) ) ; var message = callMethod . getParameterCount ( ) == <NUM_LIT> ? XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , param . thisObject , i ) : XposedHelpers . callMethod ( param . thisObject , callMethod . getName ( ) , i ) ; if ( message != null ) { var fileData = XposedHelpers . getObjectField ( message , \"<STR_LIT>\" ) ; var file = ( File ) ReflectionUtils . getField ( fileField , fileData ) ; var dest = Utils . getDestination ( prefs , \"<STR_LIT>\" ) ; var userJid = new FMessageWpp ( message ) . getKey ( ) . remoteJid ; var fileExtension = file . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; var name = Utils . generateName ( userJid , fileExtension ) ; var error = Utils . copyFile ( file , new File ( dest , name ) ) ; if ( TextUtils . isEmpty ( error ) ) { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . saved_to ) + dest , Toast . LENGTH_LONG ) ; } else { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . error_when_saving_try_again ) + \"<STR_LIT>\" + error , Toast . LENGTH_LONG ) ; } } } catch ( Exception e ) { Utils . showToast ( e . getMessage ( ) , Toast . LENGTH_LONG ) ; } return true ; } ) ; } } } ) ; } } @ NonNull @ Override public String getPluginName ( ) {", "output": "return \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . views . dialog ; import android . app . Dialog ; import android . graphics . Color ; import android . view . View ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . utils . Utils ; public class BottomDialogWpp { private final Dialog dialog ; public BottomDialogWpp ( @ NonNull Dialog dialog ) { this . dialog = dialog ; } public void dismissDialog ( ) { dialog . dismiss ( ) ; } public void showDialog ( ) {", "output": "dialog . show ( ) ; if ( dialog . getWindow ( ) != null ) { dialog . getWindow ( ) . setBackgroundDrawable ( null ) ; dialog . getWindow ( ) . setDimAmount ( <NUM_LIT> ) ; var view = dialog . getWindow ( ) . getDecorView ( ) ; view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) . setBackgroundColor ( Color . TRANSPARENT ) ; dialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_PAN ) ; } } public void setContentView ( View view ) { dialog . setContentView ( view ) ; } public void setCanceledOnTouchOutside ( boolean b ) { dialog . setCanceledOnTouchOutside ( b ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . util . Log ; import android . util . Pair ; import androidx . annotation . Nullable ; import com . unfbx . chatgpt . OpenAiStreamClient ; import com . unfbx . chatgpt . entity . chat . BaseChatCompletion ; import com . unfbx . chatgpt . entity . chat . ChatCompletionWithPicture ; import com . unfbx . chatgpt . entity . chat . Content ; import com . unfbx . chatgpt . entity . chat . FunctionCall ; import com . unfbx . chatgpt . entity . chat . Functions ; import com . unfbx . chatgpt . entity . chat . ImageUrl ; import com . unfbx . chatgpt . entity . chat . Message ; import com . unfbx . chatgpt . entity . chat . ChatCompletion ; import com . unfbx . chatgpt . entity . chat . MessagePicture ; import com . unfbx . chatgpt . entity . chat . Parameters ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import cn . hutool . json . JSONObject ; import okhttp3 . ConnectionSpec ; import okhttp3 . OkHttpClient ; import okhttp3 . Response ; import okhttp3 . internal . http2 . StreamResetException ; import okhttp3 . sse . EventSource ; import okhttp3 . sse . EventSourceListener ; import com . skythinker . gptassistant . ChatManager . ChatMessage . ChatRole ; import com . skythinker . gptassistant . ChatManager . ChatMessage ; import com . unfbx . chatgpt . entity . whisper . WhisperResponse ; public class ChatApiClient { public interface OnReceiveListener { void onMsgReceive ( String message ) ; void onError ( String message ) ; void onFunctionCall ( String name , String arg ) ; void onFinished ( boolean completed ) ; } String url = \"<STR_LIT>\" ; String apiKey = \"<STR_LIT>\" ; String model = \"<STR_LIT>\" ; OnReceiveListener listener = null ; OkHttpClient httpClient = null ; OpenAiStreamClient chatGPT = null ; List < Functions > functions = new ArrayList < > ( ) ; String callingFuncName = \"<STR_LIT>\" ; String callingFuncArg = \"<STR_LIT>\" ; Context context = null ; public ChatApiClient ( Context context , String url , String apiKey , String model , OnReceiveListener listener ) { this . context = context ; this . listener = listener ; this . model = model ; httpClient = new OkHttpClient . Builder ( ) . connectTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . readTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . writeTimeout ( <NUM_LIT> , java . util . concurrent . TimeUnit . SECONDS ) . connectionSpecs ( Arrays . asList ( ConnectionSpec . CLEARTEXT , ConnectionSpec . COMPATIBLE_TLS ) ) . build ( ) ; setApiInfo ( url , apiKey ) ; } public void sendPromptList ( List < ChatMessage > promptList ) { if ( url . isEmpty ( ) ) { listener . onError ( \"<STR_LIT>\" ) ; return ; } else if ( apiKey . isEmpty ( ) ) { listener . onError ( \"<STR_LIT>\" ) ; return ; } else if ( chatGPT == null ) { listener . onError ( \"<STR_LIT>\" ) ; return ; } BaseChatCompletion chatCompletion = null ; if ( ! GlobalUtils . checkVisionSupport ( model ) ) { ArrayList < Message > messageList = new ArrayList < > ( ) ; for ( ChatMessage message : promptList ) { if ( message . role == ChatRole . SYSTEM ) { messageList . add ( Message . builder ( ) . role ( Message . Role . SYSTEM ) . content ( message . contentText ) . build ( ) ) ; } else if ( message . role == ChatRole . USER ) { messageList . add ( Message . builder ( ) . role ( Message . Role . USER ) . content ( message . contentText ) . build ( ) ) ; } else if ( message . role == ChatRole . ASSISTANT ) { if ( message . functionName != null ) { FunctionCall functionCall = FunctionCall . builder ( ) . name ( message . functionName ) . arguments ( message . contentText ) . build ( ) ; messageList . add ( Message . builder ( ) . role ( Message . Role . ASSISTANT ) . functionCall ( functionCall ) . build ( ) ) ; } else { messageList . add ( Message . builder ( ) . role ( Message . Role . ASSISTANT ) . content ( message . contentText ) . build ( ) ) ; } } else if ( message . role == ChatRole . FUNCTION ) { messageList . add ( Message . builder ( ) . role ( Message . Role . FUNCTION ) . name ( message . functionName ) . content ( message . contentText ) . build ( ) ) ; } } if ( ! functions . isEmpty ( ) ) { chatCompletion = ChatCompletion . builder ( ) . messages ( messageList ) . model ( model ) . functions ( functions ) . functionCall ( \"<STR_LIT>\" ) . build ( ) ; } else { chatCompletion = ChatCompletion . builder ( ) . messages ( messageList ) . model ( model ) . build ( ) ; } } else { ArrayList < MessagePicture > messageList = new ArrayList < > ( ) ; for ( ChatMessage message : promptList ) { List < Content > contentList = new ArrayList < > ( ) ; if ( message . contentText != null ) { contentList . add ( Content . builder ( ) . type ( Content . Type . TEXT . getName ( ) ) . text ( message . contentText ) . build ( ) ) ; } if ( message . contentImageBase64 != null ) { ImageUrl imageUrl = ImageUrl . builder ( ) . url ( \"<STR_LIT>\" + message . contentImageBase64 ) . build ( ) ; contentList . add ( Content . builder ( ) . type ( Content . Type . IMAGE_URL . getName ( ) ) . imageUrl ( imageUrl ) . build ( ) ) ; } if ( message . role == ChatRole . SYSTEM ) { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . SYSTEM ) . content ( contentList ) . build ( ) ) ; } else if ( message . role == ChatRole . USER ) {", "output": "messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . USER ) . content ( contentList ) . build ( ) ) ; } else if ( message . role == ChatRole . ASSISTANT ) { if ( message . functionName != null ) { FunctionCall functionCall = FunctionCall . builder ( ) . name ( message . functionName ) . arguments ( message . contentText ) . build ( ) ; messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . ASSISTANT ) . functionCall ( functionCall ) . build ( ) ) ; } else { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . ASSISTANT ) . content ( contentList ) . build ( ) ) ; } } else if ( message . role == ChatRole . FUNCTION ) { messageList . add ( MessagePicture . builder ( ) . role ( Message . Role . FUNCTION ) . name ( message . functionName ) . content ( contentList ) . build ( ) ) ; } } chatCompletion = ChatCompletionWithPicture . builder ( ) . messages ( messageList ) . model ( model . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) . build ( ) ; } callingFuncName = callingFuncArg = \"<STR_LIT>\" ; chatGPT . streamChatCompletion ( chatCompletion , new EventSourceListener ( ) { @ Override public void onOpen ( EventSource eventSource , Response response ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public void onEvent ( EventSource eventSource , @ Nullable String id , @ Nullable String type , String data ) { if ( data . equals ( \"<STR_LIT>\" ) ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( callingFuncName . isEmpty ( ) ) { listener . onFinished ( true ) ; } else { listener . onFunctionCall ( callingFuncName , callingFuncArg ) ; } } else { JSONObject json = new JSONObject ( data ) ; if ( json . containsKey ( \"<STR_LIT>\" ) && json . getJSONArray ( \"<STR_LIT>\" ) . size ( ) > <NUM_LIT> ) { JSONObject delta = ( ( JSONObject ) json . getJSONArray ( \"<STR_LIT>\" ) . get ( <NUM_LIT> ) ) . getJSONObject ( \"<STR_LIT>\" ) ; if ( delta != null ) { if ( delta . containsKey ( \"<STR_LIT>\" ) ) { JSONObject functionCall = delta . getJSONObject ( \"<STR_LIT>\" ) ; if ( functionCall . containsKey ( \"<STR_LIT>\" ) ) callingFuncName = functionCall . getStr ( \"<STR_LIT>\" ) ; callingFuncArg += functionCall . getStr ( \"<STR_LIT>\" ) ; } else if ( delta . containsKey ( \"<STR_LIT>\" ) ) { String msg = delta . getStr ( \"<STR_LIT>\" ) ; if ( msg != null ) listener . onMsgReceive ( msg ) ; } } } } } @ Override public void onClosed ( EventSource eventSource ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public void onFailure ( EventSource eventSource , @ Nullable Throwable throwable , @ Nullable Response response ) { if ( throwable != null ) { if ( throwable instanceof StreamResetException ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; listener . onFinished ( false ) ; } else { String err = throwable . toString ( ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + err + \"<STR_LIT>\" + Log . getStackTraceString ( throwable ) ) ; if ( err . equals ( \"<STR_LIT>\" ) ) { err = context . getString ( R . string . text_gpt_cancel ) ; } else if ( err . equals ( \"<STR_LIT>\" ) ) { err = context . getString ( R . string . text_gpt_timeout ) ; } listener . onError ( err ) ; } } else { if ( response != null && response . body ( ) != null ) { try { String err = response . body ( ) . string ( ) ; if ( err . length ( ) > <NUM_LIT> ) { err = err . substring ( <NUM_LIT> , <NUM_LIT> ) ; err += \"<STR_LIT>\" ; } listener . onError ( err ) ; } catch ( IOException ignore ) { } } else { listener . onError ( context . getString ( R . string . text_gpt_unknown_error ) ) ; } } } } ) ; } public void setApiInfo ( String url , String apiKey ) { if ( this . url . equals ( url ) && this . apiKey . equals ( apiKey ) ) { return ; } this . url = url ; this . apiKey = apiKey ; chatGPT = new OpenAiStreamClient . Builder ( ) . apiKey ( Arrays . asList ( apiKey ) ) . apiHost ( url ) . okHttpClient ( httpClient ) . build ( ) ; } public boolean isStreaming ( ) { return httpClient . connectionPool ( ) . connectionCount ( ) - httpClient . connectionPool ( ) . idleConnectionCount ( ) > <NUM_LIT> ; } public void stop ( ) { httpClient . dispatcher ( ) . cancelAll ( ) ; } public void setModel ( String model ) { this . model = model ; } public void addFunction ( String name , String desc , String params , String [ ] required ) { removeFunction ( name ) ; Parameters parameters = Parameters . builder ( ) . type ( \"<STR_LIT>\" ) . properties ( new JSONObject ( params ) ) . required ( Arrays . asList ( required ) ) . build ( ) ; Functions functions = Functions . builder ( ) . name ( name ) . description ( desc ) . parameters ( parameters ) . build ( ) ; this . functions . add ( functions ) ; } public void removeFunction ( String name ) { for ( int i = <NUM_LIT> ; i < this . functions . size ( ) ; i ++ ) { if ( this . functions . get ( i ) . getName ( ) . equals ( name ) ) { this . functions . remove ( i ) ; break ; } } } public void clearAllFunctions ( ) { this . functions . clear ( ) ; } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( \"<STR_LIT>\" ) public interface IWebViewFactory { @ Field ( value = \"<STR_LIT>\" , type = Field . STATIC ) Object getProviderLock ( ) ; @ Field ( value = \"<STR_LIT>\" , type = Field . STATIC ) Object getProviderInstance ( ) ; @ Field ( value = \"<STR_LIT>\" , type = Field . STATIC ) void setProviderInstance ( Object instance ) ;", "output": "}"}, {"input": "package com . cgutman . adblib ; import java . io . UnsupportedEncodingException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; public class AdbProtocol { public static final int ADB_HEADER_LENGTH = <NUM_LIT> ; public static final int CMD_SYNC = <NUM_LIT> ; public static final int CMD_CNXN = <NUM_LIT> ; public static final int CONNECT_VERSION = <NUM_LIT> ; public static final int CONNECT_MAXDATA = <NUM_LIT> ; public static byte [ ] CONNECT_PAYLOAD ; static { try { CONNECT_PAYLOAD = \"<STR_LIT>\" . getBytes ( \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { } } public static final int CMD_AUTH = <NUM_LIT> ; public static final int AUTH_TYPE_TOKEN = <NUM_LIT> ; public static final int AUTH_TYPE_SIGNATURE = <NUM_LIT> ; public static final int AUTH_TYPE_RSA_PUBLIC = <NUM_LIT> ; public static final int CMD_OPEN = <NUM_LIT> ; public static final int CMD_OKAY = <NUM_LIT> ; public static final int CMD_CLSE = <NUM_LIT> ; public static final int CMD_WRTE = <NUM_LIT> ; public static boolean validateMessage ( AdbMessage msg ) { if ( msg . getCommand ( ) != ( msg . getMagic ( ) ^ <NUM_LIT> ) ) return false ; if ( msg . getPayloadLength ( ) != <NUM_LIT> ) { if ( AdbMessage . checksum ( msg . getPayload ( ) ) != msg . getChecksum ( ) ) return false ; } return true ; } public static AdbMessage generateMessage ( int cmd , int arg0 , int arg1 , byte [ ] payload ) { return new AdbMessage ( cmd , arg0 , arg1 , payload ) ; } public static AdbMessage generateConnect ( ) { return generateMessage ( CMD_CNXN , CONNECT_VERSION , CONNECT_MAXDATA , CONNECT_PAYLOAD ) ; } public static AdbMessage generateAuth ( int type , byte [ ] data ) { return generateMessage ( CMD_AUTH , type , <NUM_LIT> , data ) ;", "output": "} public static AdbMessage generateOpen ( int localId , String dest ) throws UnsupportedEncodingException { ByteBuffer bbuf = ByteBuffer . allocate ( dest . length ( ) + <NUM_LIT> ) ; bbuf . put ( dest . getBytes ( \"<STR_LIT>\" ) ) ; bbuf . put ( ( byte ) <NUM_LIT> ) ; return generateMessage ( CMD_OPEN , localId , <NUM_LIT> , bbuf . array ( ) ) ; } public static AdbMessage generateWrite ( int localId , int remoteId , byte [ ] data ) { return generateMessage ( CMD_WRTE , localId , remoteId , data ) ; } public static AdbMessage generateClose ( int localId , int remoteId ) { return generateMessage ( CMD_CLSE , localId , remoteId , null ) ; } public static AdbMessage generateReady ( int localId , int remoteId ) { return generateMessage ( CMD_OKAY , localId , remoteId , null ) ; } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; import com . norman . webviewup . lib . reflect . annotation . Method ; @ ClassName ( \"<STR_LIT>\" ) public interface IVMRuntime { @ Method ( value = \"<STR_LIT>\" , type = Method . STATIC ) Object getRuntime ( ) ; @ Method ( value = \"<STR_LIT>\" ) boolean is64Bit ( ) ; @ Method ( value = \"<STR_LIT>\" , type = Method . STATIC ) String getCurrentInstructionSet ( ) ;", "output": "}"}, {"input": "package io . capawesome . capacitorjs . plugins . filepicker ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . util . Log ; import androidx . activity . result . ActivityResult ; import androidx . annotation . Nullable ; import com . getcapacitor . JSArray ; import com . getcapacitor . JSObject ; import com . getcapacitor . Logger ; import com . getcapacitor . Plugin ; import com . getcapacitor . PluginCall ; import com . getcapacitor . PluginMethod ; import com . getcapacitor . annotation . ActivityCallback ; import com . getcapacitor . annotation . CapacitorPlugin ; import java . util . ArrayList ; import java . util . List ; import org . json . JSONException ; @ CapacitorPlugin ( name = \"<STR_LIT>\" ) public class FilePickerPlugin extends Plugin { public static final String TAG = \"<STR_LIT>\" ; public static final String ERROR_PICK_FILE_FAILED = \"<STR_LIT>\" ; public static final String ERROR_PICK_FILE_CANCELED = \"<STR_LIT>\" ; private FilePicker implementation ; public void load ( ) { implementation = new FilePicker ( this . getBridge ( ) ) ; } @ PluginMethod public void convertHeicToJpeg ( PluginCall call ) { call . unimplemented ( \"<STR_LIT>\" ) ; } @ PluginMethod public void pickFiles ( PluginCall call ) { try { int limit = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; JSArray types = call . getArray ( \"<STR_LIT>\" , null ) ; String [ ] parsedTypes = parseTypesOption ( types ) ; Intent intent = new Intent ( Intent . ACTION_GET_CONTENT ) ; intent . setType ( \"<STR_LIT>\" ) ; intent . addCategory ( Intent . CATEGORY_OPENABLE ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; if ( limit == <NUM_LIT> && parsedTypes != null && parsedTypes . length > <NUM_LIT> ) { intent . putExtra ( Intent . EXTRA_MIME_TYPES , parsedTypes ) ; } startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickImages ( PluginCall call ) { try { int limit = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { \"<STR_LIT>\" } ) ; startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickMedia ( PluginCall call ) { try { int limit = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; }", "output": "catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ PluginMethod public void pickVideos ( PluginCall call ) { try { int limit = call . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ; Intent intent = new Intent ( Intent . ACTION_PICK ) ; intent . putExtra ( Intent . EXTRA_ALLOW_MULTIPLE , limit == <NUM_LIT> ) ; intent . setType ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , limit == <NUM_LIT> ) ; intent . putExtra ( Intent . EXTRA_MIME_TYPES , new String [ ] { \"<STR_LIT>\" } ) ; startActivityForResult ( call , intent , \"<STR_LIT>\" ) ; } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } @ Nullable private String [ ] parseTypesOption ( @ Nullable JSArray types ) { if ( types == null ) { return null ; } try { List < String > typesList = types . toList ( ) ; if ( typesList . contains ( \"<STR_LIT>\" ) ) { typesList . add ( \"<STR_LIT>\" ) ; } return typesList . toArray ( new String [ <NUM_LIT> ] ) ; } catch ( JSONException exception ) { Logger . error ( \"<STR_LIT>\" , exception ) ; return null ; } } @ ActivityCallback private void pickFilesResult ( PluginCall call , ActivityResult result ) { try { if ( call == null ) { return ; } boolean readData = call . getBoolean ( \"<STR_LIT>\" , false ) ; int resultCode = result . getResultCode ( ) ; switch ( resultCode ) { case Activity . RESULT_OK : JSObject callResult = createPickFilesResult ( result . getData ( ) , readData ) ; call . resolve ( callResult ) ; break ; case Activity . RESULT_CANCELED : call . reject ( ERROR_PICK_FILE_CANCELED ) ; break ; default : call . reject ( ERROR_PICK_FILE_FAILED ) ; } } catch ( Exception ex ) { String message = ex . getMessage ( ) ; Log . e ( TAG , message ) ; call . reject ( message ) ; } } private JSObject createPickFilesResult ( @ Nullable Intent data , boolean readData ) { JSObject callResult = new JSObject ( ) ; List < JSObject > filesResultList = new ArrayList < > ( ) ; if ( data == null ) { callResult . put ( \"<STR_LIT>\" , JSArray . from ( filesResultList ) ) ; return callResult ; } List < Uri > uris = new ArrayList < > ( ) ; if ( data . getClipData ( ) == null ) { Uri uri = data . getData ( ) ; uris . add ( uri ) ; } else { for ( int i = <NUM_LIT> ; i < data . getClipData ( ) . getItemCount ( ) ; i ++ ) { Uri uri = data . getClipData ( ) . getItemAt ( i ) . getUri ( ) ; uris . add ( uri ) ; } } for ( int i = <NUM_LIT> ; i < uris . size ( ) ; i ++ ) { Uri uri = uris . get ( i ) ; if ( uri == null ) { continue ; } JSObject fileResult = new JSObject ( ) ; if ( readData ) { fileResult . put ( \"<STR_LIT>\" , implementation . getDataFromUri ( uri ) ) ; } Long duration = implementation . getDurationFromUri ( uri ) ; if ( duration != null ) { fileResult . put ( \"<STR_LIT>\" , duration ) ; } FileResolution resolution = implementation . getHeightAndWidthFromUri ( uri ) ; if ( resolution != null ) { fileResult . put ( \"<STR_LIT>\" , resolution . height ) ; fileResult . put ( \"<STR_LIT>\" , resolution . width ) ; } fileResult . put ( \"<STR_LIT>\" , implementation . getMimeTypeFromUri ( uri ) ) ; Long modifiedAt = implementation . getModifiedAtFromUri ( uri ) ; if ( modifiedAt != null ) { fileResult . put ( \"<STR_LIT>\" , modifiedAt ) ; } fileResult . put ( \"<STR_LIT>\" , implementation . getNameFromUri ( uri ) ) ; fileResult . put ( \"<STR_LIT>\" , implementation . getPathFromUri ( uri ) ) ; fileResult . put ( \"<STR_LIT>\" , implementation . getSizeFromUri ( uri ) ) ; filesResultList . add ( fileResult ) ; } callResult . put ( \"<STR_LIT>\" , JSArray . from ( filesResultList . toArray ( ) ) ) ; return callResult ; } }"}, {"input": "package com . getcapacitor ; import static org . junit . Assert . * ; import org . junit . Test ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ;", "output": "} }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . wakeup ; import com . baidu . aip . asrwakeup3 . core . util . MyLogger ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; public class WakeUpResult { private String name ; private String origalJson ; private String word ; private String desc ; private int errorCode ; private static int ERROR_NONE = <NUM_LIT> ; private static final String TAG = \"<STR_LIT>\" ; public boolean hasError ( ) { return errorCode != ERROR_NONE ; } public String getOrigalJson ( ) { return origalJson ; } public void setOrigalJson ( String origalJson ) { this . origalJson = origalJson ; } public String getWord ( ) { return word ; } public void setWord ( String word ) { this . word = word ; } public String getDesc ( ) { return desc ; } public void setDesc ( String desc ) { this . desc = desc ; } public int getErrorCode ( ) { return errorCode ; } public void setErrorCode ( int errorCode ) { this . errorCode = errorCode ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; }", "output": "public static WakeUpResult parseJson ( String name , String jsonStr ) { WakeUpResult result = new WakeUpResult ( ) ; result . setOrigalJson ( jsonStr ) ; try { JSONObject json = new JSONObject ( jsonStr ) ; if ( SpeechConstant . CALLBACK_EVENT_WAKEUP_SUCCESS . equals ( name ) ) { int error = json . optInt ( \"<STR_LIT>\" ) ; result . setErrorCode ( error ) ; result . setDesc ( json . optString ( \"<STR_LIT>\" ) ) ; if ( ! result . hasError ( ) ) { result . setWord ( json . optString ( \"<STR_LIT>\" ) ) ; } } else { int error = json . optInt ( \"<STR_LIT>\" ) ; result . setErrorCode ( error ) ; result . setDesc ( json . optString ( \"<STR_LIT>\" ) ) ; } } catch ( JSONException e ) { MyLogger . error ( TAG , \"<STR_LIT>\" + jsonStr ) ; e . printStackTrace ( ) ; } return result ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment . bean ; import androidx . annotation . NonNull ; public class MartialLawCommentArea extends CommentArea { public static final String DISPOSAL_METHOD_SHADOW_BAN = \"<STR_LIT>\" ; public static final String DISPOSAL_METHOD_QUICK_DELETE = \"<STR_LIT>\" ; public String title , defaultDisposalMethod , up ; public byte [ ] coverImageData ; public MartialLawCommentArea ( CommentArea commentArea , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { this ( String . valueOf ( commentArea . oid ) , commentArea . sourceId , commentArea . type , defaultDisposalMethod , title , up , coverImageData ) ; } public MartialLawCommentArea ( String oid , String sourceId , int areaType , String defaultDisposalMethod , String title , String up , byte [ ] coverImageData ) { super ( Long . parseLong ( oid ) , sourceId , areaType ) ; this . up = up ; this . title = title ;", "output": "this . defaultDisposalMethod = defaultDisposalMethod ; this . coverImageData = coverImageData ; } public String [ ] toStringArrays ( ) { return new String [ ] { String . valueOf ( oid ) , sourceId , String . valueOf ( type ) , defaultDisposalMethod , title , up , null } ; } @ NonNull @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + oid + '<STR_LIT>' + \"<STR_LIT>\" + sourceId + '<STR_LIT>' + \"<STR_LIT>\" + type + \"<STR_LIT>\" + title + '<STR_LIT>' + \"<STR_LIT>\" + defaultDisposalMethod + '<STR_LIT>' + \"<STR_LIT>\" + up + '<STR_LIT>' + '<STR_LIT>' ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . utils ; import java . io . ByteArrayOutputStream ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; public abstract class HKDF { public static HKDF createFor ( int version ) { if ( version == <NUM_LIT> ) { return new HKDFv3 ( ) ; } throw new AssertionError ( \"<STR_LIT>\" + version ) ; } public byte [ ] deriveSecrets ( byte [ ] arr_b , byte [ ] arr_b1 , int v ) { return this . deriveSecrets ( arr_b , new byte [ <NUM_LIT> ] , arr_b1 , v ) ; } public byte [ ] deriveSecrets ( byte [ ] inputKeyMaterial , byte [ ] salt , byte [ ] info , int outputLength ) { byte [ ] derivedKey ; try { Mac mac = Mac . getInstance ( \"<STR_LIT>\" ) ; mac . init ( new SecretKeySpec ( salt , \"<STR_LIT>\" ) ) ; derivedKey = mac . doFinal ( inputKeyMaterial ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException e ) { throw new AssertionError ( e ) ; } try {", "output": "int iterations = ( int ) Math . ceil ( ( ( double ) outputLength ) / <NUM_LIT> ) ; byte [ ] outputKey = new byte [ <NUM_LIT> ] ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; for ( int i = getIterationStartOffset ( ) ; i < getIterationStartOffset ( ) + iterations ; ++ i ) { Mac macIteration = Mac . getInstance ( \"<STR_LIT>\" ) ; macIteration . init ( new SecretKeySpec ( derivedKey , \"<STR_LIT>\" ) ) ; macIteration . update ( outputKey ) ; if ( info != null ) { macIteration . update ( info ) ; } macIteration . update ( ( byte ) i ) ; outputKey = macIteration . doFinal ( ) ; int remainingLength = Math . min ( outputLength , outputKey . length ) ; outputStream . write ( outputKey , <NUM_LIT> , remainingLength ) ; outputLength -= remainingLength ; } return outputStream . toByteArray ( ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException ex ) { throw new AssertionError ( ex ) ; } } protected abstract int getIterationStartOffset ( ) ; }"}, {"input": "package de . robv . android . xposed ; import android . annotation . SuppressLint ; import android . content . res . Resources ; import android . content . res . TypedArray ; import android . util . Log ; import com . android . internal . os . RuntimeInit ; import com . android . internal . os . ZygoteInit ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Constructor ; import java . lang . reflect . Executable ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import dalvik . system . PathClassLoader ; import de . robv . android . xposed . XC_MethodHook . MethodHookParam ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; import top . bienvenido . xposedcompat . JKLog ; import top . bienvenido . xposedcompat . MundoXposedBridge ; import static de . robv . android . xposed . XposedHelpers . getIntField ; import static de . robv . android . xposed . XposedHelpers . setObjectField ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class XposedBridge { public static final ClassLoader BOOTCLASSLOADER = ClassLoader . getSystemClassLoader ( ) ; public static final String TAG = \"<STR_LIT>\" ; @ Deprecated public static int XPOSED_BRIDGE_VERSION = <NUM_LIT> ; static boolean isZygote = true ; private static final int RUNTIME_DALVIK = <NUM_LIT> ; private static final int RUNTIME_ART = <NUM_LIT> ; static boolean disableHooks = false ; static long BOOT_START_TIME ; private static final Object [ ] EMPTY_ARRAY = new Object [ <NUM_LIT> ] ; private static final Map < Member , CopyOnWriteSortedSet < XC_MethodHook > > sHookedMethodCallbacks = new HashMap < > ( ) ; static final CopyOnWriteSortedSet < XC_LoadPackage > sLoadedPackageCallbacks = new CopyOnWriteSortedSet < > ( ) ; static final CopyOnWriteSortedSet < XC_InitPackageResources > sInitPackageResourcesCallbacks = new CopyOnWriteSortedSet < > ( ) ; private XposedBridge ( ) { } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static void main ( String [ ] args ) { try { initXResources ( ) ; SELinuxHelper . initOnce ( ) ; SELinuxHelper . initForProcess ( null ) ; XPOSED_BRIDGE_VERSION = getXposedVersion ( ) ; if ( isZygote ) { XposedInit . hookResources ( ) ; XposedInit . initForZygote ( ) ; } XposedInit . loadModules ( ) ; } catch ( Throwable t ) { Log . e ( TAG , \"<STR_LIT>\" , t ) ; disableHooks = true ; } if ( isZygote ) { ZygoteInit . main ( args ) ;", "output": "} else { RuntimeInit . main ( args ) ; } } protected static final class ToolEntryPoint { protected static void main ( String [ ] args ) { isZygote = false ; XposedBridge . main ( args ) ; } } private static void initXResources ( ) throws IOException { Resources res = Resources . getSystem ( ) ; File resDexFile = ensureSuperDexFile ( \"<STR_LIT>\" , res . getClass ( ) , Resources . class ) ; Class < ? > taClass = TypedArray . class ; try { TypedArray ta = res . obtainTypedArray ( res . getIdentifier ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; taClass = ta . getClass ( ) ; ta . recycle ( ) ; } catch ( Resources . NotFoundException nfe ) { XposedBridge . log ( nfe ) ; } Runtime . getRuntime ( ) . gc ( ) ; File taDexFile = ensureSuperDexFile ( \"<STR_LIT>\" , taClass , TypedArray . class ) ; ClassLoader myCL = XposedBridge . class . getClassLoader ( ) ; String paths = resDexFile . getAbsolutePath ( ) + File . pathSeparator + taDexFile . getAbsolutePath ( ) ; PathClassLoader dummyCL = new PathClassLoader ( paths , myCL . getParent ( ) ) ; setObjectField ( myCL , \"<STR_LIT>\" , dummyCL ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private static File ensureSuperDexFile ( String clz , Class < ? > realSuperClz , Class < ? > topClz ) throws IOException { File dexFile = DexCreator . ensure ( clz , realSuperClz , topClz ) ; dexFile . setReadable ( true , false ) ; return dexFile ; } public static int getXposedVersion ( ) { return <NUM_LIT> ; } public synchronized static void log ( String text ) { Log . i ( TAG , text ) ; } public synchronized static void log ( Throwable t ) { Log . e ( TAG , Log . getStackTraceString ( t ) ) ; } public static XC_MethodHook . Unhook hookMethod ( Member hookMethod , XC_MethodHook callback ) { if ( ! ( hookMethod instanceof Executable ) ) throw new IllegalArgumentException ( \"<STR_LIT>\" + hookMethod . toString ( ) ) ; boolean newMethod = false ; CopyOnWriteSortedSet < XC_MethodHook > callbacks ; synchronized ( sHookedMethodCallbacks ) { callbacks = sHookedMethodCallbacks . get ( hookMethod ) ; if ( callbacks == null ) { callbacks = new CopyOnWriteSortedSet < > ( ) ; sHookedMethodCallbacks . put ( hookMethod , callbacks ) ; newMethod = true ; } } callbacks . add ( callback ) ; if ( newMethod ) { AdditionalHookInfo additionalInfo = new AdditionalHookInfo ( callbacks ) ; hookMethodNative ( hookMethod , additionalInfo ) ; } return callback . new Unhook ( hookMethod ) ; } @ Deprecated public static void unhookMethod ( Member hookMethod , XC_MethodHook callback ) { CopyOnWriteSortedSet < XC_MethodHook > callbacks ; synchronized ( sHookedMethodCallbacks ) { callbacks = sHookedMethodCallbacks . get ( hookMethod ) ; if ( callbacks == null ) return ; } callbacks . remove ( callback ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static Set < XC_MethodHook . Unhook > hookAllMethods ( Class < ? > hookClass , String methodName , XC_MethodHook callback ) { Set < XC_MethodHook . Unhook > unhooks = new HashSet < > ( ) ; for ( Member method : hookClass . getDeclaredMethods ( ) ) if ( method . getName ( ) . equals ( methodName ) ) unhooks . add ( hookMethod ( method , callback ) ) ; return unhooks ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static Set < XC_MethodHook . Unhook > hookAllConstructors ( Class < ? > hookClass , XC_MethodHook callback ) { Set < XC_MethodHook . Unhook > unhooks = new HashSet < > ( ) ; for ( Member constructor : hookClass . getDeclaredConstructors ( ) ) unhooks . add ( hookMethod ( constructor , callback ) ) ; return unhooks ; } private static Object handleHookedMethod ( Member method , int originalMethodId , Object additionalInfoObj , Object thisObject , Object [ ] args ) throws Throwable { AdditionalHookInfo additionalInfo = ( AdditionalHookInfo ) additionalInfoObj ; if ( disableHooks ) { return invokeOriginalMethodNative ( method , originalMethodId , thisObject , args ) ; } Object [ ] callbacksSnapshot = additionalInfo . callbacks . getSnapshot ( ) ; final int callbacksLength = callbacksSnapshot . length ; if ( callbacksLength == <NUM_LIT> ) { return invokeOriginalMethodNative ( method , originalMethodId , thisObject , args ) ; } MethodHookParam param = new MethodHookParam ( ) ; param . method = method ; param . thisObject = thisObject ; param . args = args ; int beforeIdx = <NUM_LIT> ; do { try { ( ( XC_MethodHook ) callbacksSnapshot [ beforeIdx ] ) . beforeHookedMethod ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; param . setResult ( null ) ; param . returnEarly = false ; continue ; } if ( param . returnEarly ) { beforeIdx ++ ; break ; } } while ( ++ beforeIdx < callbacksLength ) ; if ( ! param . returnEarly ) { param . setResult ( invokeOriginalMethodNative ( method , originalMethodId , param . thisObject , param . args ) ) ; } int afterIdx = beforeIdx - <NUM_LIT> ; do { Object lastResult = param . getResult ( ) ; Throwable lastThrowable = param . getThrowable ( ) ; try { ( ( XC_MethodHook ) callbacksSnapshot [ afterIdx ] ) . afterHookedMethod ( param ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; if ( lastThrowable == null ) param . setResult ( lastResult ) ; else param . setThrowable ( lastThrowable ) ; } } while ( -- afterIdx >= <NUM_LIT> ) ; if ( param . hasThrowable ( ) ) throw param . getThrowable ( ) ; else return param . getResult ( ) ; } public static void hookLoadPackage ( XC_LoadPackage callback ) { synchronized ( sLoadedPackageCallbacks ) { sLoadedPackageCallbacks . add ( callback ) ; } } public static void hookInitPackageResources ( XC_InitPackageResources callback ) { synchronized ( sInitPackageResourcesCallbacks ) { sInitPackageResourcesCallbacks . add ( callback ) ; } } private static void hookMethodNative ( Member method , AdditionalHookInfo additionalInfo ) { MundoXposedBridge . hookMethod ( method , additionalInfo ) ; } private synchronized static Object invokeOriginalMethodNative ( Member method , int methodId , Object thisObject , Object [ ] args ) { CopyOnWriteSortedSet < XC_MethodHook > callbacks = sHookedMethodCallbacks . get ( method ) ; Object res = null ; if ( callbacks != null ) { Object [ ] e = callbacks . elements ; callbacks . elements = new XC_MethodHook [ ] { } ; try { if ( method instanceof Constructor ) { res = ( ( Constructor < ? > ) method ) . newInstance ( args ) ; } else if ( method instanceof Method ) { res = ( ( Method ) method ) . invoke ( thisObject , args ) ; } } catch ( Throwable t ) { JKLog . INSTANCE . e ( t ) ; } callbacks . elements = e ; } return res ; } public static Object invokeOriginalMethod ( Member method , Object thisObject , Object [ ] args ) throws NullPointerException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { if ( args == null ) { args = EMPTY_ARRAY ; } return invokeOriginalMethodNative ( method , <NUM_LIT> , thisObject , args ) ; } public static final class CopyOnWriteSortedSet < E > { public transient volatile Object [ ] elements = EMPTY_ARRAY ; @ SuppressWarnings ( \"<STR_LIT>\" ) public synchronized boolean add ( E e ) { int index = indexOf ( e ) ; if ( index >= <NUM_LIT> ) return false ; Object [ ] newElements = new Object [ elements . length + <NUM_LIT> ] ; System . arraycopy ( elements , <NUM_LIT> , newElements , <NUM_LIT> , elements . length ) ; newElements [ elements . length ] = e ; Arrays . sort ( newElements ) ; elements = newElements ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public synchronized boolean remove ( E e ) { int index = indexOf ( e ) ; if ( index == - <NUM_LIT> ) return false ; Object [ ] newElements = new Object [ elements . length - <NUM_LIT> ] ; System . arraycopy ( elements , <NUM_LIT> , newElements , <NUM_LIT> , index ) ; System . arraycopy ( elements , index + <NUM_LIT> , newElements , index , elements . length - index - <NUM_LIT> ) ; elements = newElements ; return true ; } private int indexOf ( Object o ) { for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( o . equals ( elements [ i ] ) ) return i ; } return - <NUM_LIT> ; } public Object [ ] getSnapshot ( ) { return elements ; } } public static class AdditionalHookInfo { public final CopyOnWriteSortedSet < XC_MethodHook > callbacks ; private AdditionalHookInfo ( CopyOnWriteSortedSet < XC_MethodHook > callbacks ) { this . callbacks = callbacks ; } } }"}, {"input": "package android . app ; import android . content . SharedPreferences ; import android . content . pm . ApplicationInfo ; import android . content . res . CompatibilityInfo ; import android . content . res . Configuration ; import android . content . res . Resources ; import android . os . Build ; import android . os . IBinder ; import android . view . Display ; import java . lang . ref . WeakReference ; import java . util . Map ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import static de . robv . android . xposed . XposedHelpers . findClass ; import static de . robv . android . xposed . XposedHelpers . findFieldIfExists ; import static de . robv . android . xposed . XposedHelpers . findMethodExactIfExists ; import static de . robv . android . xposed . XposedHelpers . getObjectField ; import static de . robv . android . xposed . XposedHelpers . newInstance ; import static de . robv . android . xposed . XposedHelpers . setFloatField ; public final class AndroidAppHelper { private AndroidAppHelper ( ) { } private static final Class < ? > CLASS_RESOURCES_KEY ; private static final boolean HAS_IS_THEMEABLE ; private static final boolean HAS_THEME_CONFIG_PARAMETER ; static { CLASS_RESOURCES_KEY = ( Build . VERSION . SDK_INT < <NUM_LIT> ) ? findClass ( \"<STR_LIT>\" , null ) : findClass ( \"<STR_LIT>\" , null ) ; HAS_IS_THEMEABLE = findFieldIfExists ( CLASS_RESOURCES_KEY , \"<STR_LIT>\" ) != null ; HAS_THEME_CONFIG_PARAMETER = HAS_IS_THEMEABLE && Build . VERSION . SDK_INT >= <NUM_LIT> && findMethodExactIfExists ( \"<STR_LIT>\" , null , \"<STR_LIT>\" ) != null ; } @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) private static Map < Object , WeakReference > getResourcesMap ( ActivityThread activityThread ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resourcesManager = getObjectField ( activityThread , \"<STR_LIT>\" ) ; return ( Map ) getObjectField ( resourcesManager , \"<STR_LIT>\" ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resourcesManager = getObjectField ( activityThread , \"<STR_LIT>\" ) ; return ( Map ) getObjectField ( resourcesManager , \"<STR_LIT>\" ) ; } else { return ( Map ) getObjectField ( activityThread , \"<STR_LIT>\" ) ; } } private static Object createResourcesKey ( String resDir , float scale ) { try { if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , scale , false ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , scale ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , int displayId , Configuration overrideConfiguration , float scale ) { try { if ( HAS_THEME_CONFIG_PARAMETER ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , null ) ; else if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , int displayId , Configuration overrideConfiguration , float scale , IBinder token ) { try { if ( HAS_THEME_CONFIG_PARAMETER ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , null , token ) ; else if ( HAS_IS_THEMEABLE ) return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , false , token ) ; else return newInstance ( CLASS_RESOURCES_KEY , resDir , displayId , overrideConfiguration , scale , token ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } private static Object createResourcesKey ( String resDir , String [ ] splitResDirs , String [ ] overlayDirs , String [ ] libDirs , int displayId , Configuration overrideConfiguration , CompatibilityInfo compatInfo ) { try { return newInstance ( CLASS_RESOURCES_KEY , resDir , splitResDirs , overlayDirs , libDirs , displayId , overrideConfiguration , compatInfo ) ; } catch ( Throwable t ) { XposedBridge . log ( t ) ; return null ; } } public static void addActiveResource ( String resDir , float scale , boolean isThemeable , Resources resources ) { addActiveResource ( resDir , resources ) ; } public static void addActiveResource ( String resDir , Resources resources ) { ActivityThread thread = ActivityThread . currentActivityThread ( ) ; if ( thread == null ) { return ; } Object resourcesKey ; if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { CompatibilityInfo compatInfo = ( CompatibilityInfo ) newInstance ( CompatibilityInfo . class ) ; setFloatField ( compatInfo , \"<STR_LIT>\" , resources . hashCode ( ) ) ; resourcesKey = createResourcesKey ( resDir , null , null , null , Display . DEFAULT_DISPLAY , null , compatInfo ) ; } else if ( Build . VERSION . SDK_INT == <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) , null ) ; } else if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { resourcesKey = createResourcesKey ( resDir , Display . DEFAULT_DISPLAY , null , resources . hashCode ( ) ) ; } else { resourcesKey = createResourcesKey ( resDir , resources . hashCode ( ) ) ; } if ( resourcesKey != null ) { if ( Build . VERSION . SDK_INT >= <NUM_LIT> ) { Object resImpl = getObjectField ( resources , \"<STR_LIT>\" ) ; getResourcesMap ( thread ) . put ( resourcesKey , new WeakReference < > ( resImpl ) ) ; } else { getResourcesMap ( thread ) . put ( resourcesKey , new WeakReference < > ( resources ) ) ; } } } public static String currentProcessName ( ) { String processName = ActivityThread . currentPackageName ( ) ; if ( processName == null ) return \"<STR_LIT>\" ; return processName ; } public static ApplicationInfo currentApplicationInfo ( ) { ActivityThread am = ActivityThread . currentActivityThread ( ) ; if ( am == null ) return null ; Object boundApplication = getObjectField ( am , \"<STR_LIT>\" ) ; if ( boundApplication == null ) return null ; return ( ApplicationInfo ) getObjectField ( boundApplication , \"<STR_LIT>\" ) ; } public static String currentPackageName ( ) { ApplicationInfo ai = currentApplicationInfo ( ) ;", "output": "return ( ai != null ) ? ai . packageName : \"<STR_LIT>\" ; } public static Application currentApplication ( ) { return ActivityThread . currentApplication ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) @ Deprecated public static SharedPreferences getSharedPreferencesForPackage ( String packageName , String prefFileName , int mode ) { return new XSharedPreferences ( packageName , prefFileName ) ; } @ Deprecated public static SharedPreferences getDefaultSharedPreferencesForPackage ( String packageName ) { return new XSharedPreferences ( packageName ) ; } @ Deprecated public static void reloadSharedPreferencesIfNeeded ( SharedPreferences pref ) { if ( pref instanceof XSharedPreferences ) { ( ( XSharedPreferences ) pref ) . reload ( ) ; } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . os . RemoteException ; import android . util . Log ; import java . io . File ; import java . io . IOException ; import java . net . BindException ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . core . FileTransferServer ; import top . weixiansen574 . hybridfilexfer . core . bean . FileTransferEvent ; import top . weixiansen574 . hybridfilexfer . core . bean . RemoteFile ; import top . weixiansen574 . hybridfilexfer . droidcore . EndCommandFTEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . Error ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableFileTransferEvent ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableTransferredBytesInfo ; public class TransferServiceBinder extends ITransferService . Stub { public static final String TAG = \"<STR_LIT>\" ; FileTransferServer fileTransferServer ; public LinkedList < ArrayList < ParcelableRemoteFile > > localFileQueue ; public LinkedList < ArrayList < ParcelableRemoteFile > > remoteFileQueue ; public static final int SLICE_SIZE = <NUM_LIT> ; @ Override public void destroy ( ) throws RemoteException { System . exit ( <NUM_LIT> ) ; } @ Override public void exit ( ) throws RemoteException { } public synchronized void stopServer ( ) { fileTransferServer . stopServer ( ) ; notifyAll ( ) ; } @ Override public synchronized void waitingForDied ( ) throws RemoteException { try { wait ( ) ; } catch ( InterruptedException ignored ) { } } @ Override public Error startServer ( ) throws RemoteException { try { fileTransferServer . startServer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; if ( e instanceof BindException ) { return new Error ( Error . CODE_PORT_IS_OCCUPIED , e . getMessage ( ) ) ; } else { return new Error ( Error . CODE_IOEXCEPTION , e . toString ( ) ) ; } } return null ; } public TransferServiceBinder ( ) { fileTransferServer = new FileTransferServer ( ) ; } @ Override public void transferToPc ( List < String > files , String localDir , String remoteDir ) throws RemoteException { List < File > fileList = new ArrayList < > ( ) ; for ( String file : files ) { fileList . add ( new File ( file ) ) ; } fileTransferServer . transferToClient ( fileList , new File ( localDir ) , remoteDir ) ; } public void transferToMe ( List < String > files , String remoteDir , String localDir ) throws RemoteException { try { fileTransferServer . transferToMe ( files , remoteDir , localDir ) ; } catch ( IOException e ) { throw new RemoteException ( e . toString ( ) ) ; } } @ Override public int listClientFiles ( String path ) throws RemoteException { try { ArrayList < RemoteFile > remoteFiles = fileTransferServer . listClientFiles ( path ) ; int count = <NUM_LIT> ; remoteFileQueue = new LinkedList < > ( ) ; ArrayList < ParcelableRemoteFile > fileArraySlice = new ArrayList < > ( ) ; for ( RemoteFile remoteFile : remoteFiles ) { count ++ ; fileArraySlice . add ( new ParcelableRemoteFile ( remoteFile ) ) ; if ( count >= SLICE_SIZE ) { remoteFileQueue . add ( fileArraySlice ) ; fileArraySlice = new ArrayList < > ( ) ; count = <NUM_LIT> ; } } remoteFileQueue . add ( fileArraySlice ) ; return remoteFileQueue . size ( ) ; } catch ( IOException e ) { throw new RemoteException ( e . toString ( ) ) ; } } @ Override public ArrayList < ParcelableRemoteFile > pollRemoteFiles ( ) throws RemoteException { if ( remoteFileQueue == null ) { return null ; } return remoteFileQueue . poll ( ) ; } @ Override public ParcelableFileTransferEvent getNextFileTransferEvent ( ) throws RemoteException { try { FileTransferEvent nextTransferEvent = fileTransferServer . getNextTransferEvent ( ) ; if ( nextTransferEvent instanceof EndCommandFTEvent ) { System . out . println ( \"<STR_LIT>\" ) ; return null ; } return new ParcelableFileTransferEvent ( nextTransferEvent ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ;", "output": "System . out . println ( \"<STR_LIT>\" ) ; return null ; } } @ Override public ParcelableTransferredBytesInfo getTransferredBytesInfo ( ) throws RemoteException { return new ParcelableTransferredBytesInfo ( fileTransferServer . getTransferredBytesInfo ( ) ) ; } @ Override public void stopGetNextEvent ( ) { fileTransferServer . fileTransferEvents . add ( new EndCommandFTEvent ( ) ) ; } @ Override public int listLocalFiles ( String path ) throws RemoteException { File dir = new File ( path ) ; File [ ] files = dir . listFiles ( ) ; if ( files == null ) { return - <NUM_LIT> ; } int count = <NUM_LIT> ; localFileQueue = new LinkedList < > ( ) ; ArrayList < ParcelableRemoteFile > fileArraySlice = new ArrayList < > ( ) ; for ( File file : files ) { count ++ ; ParcelableRemoteFile parcelableRemoteFile = new ParcelableRemoteFile ( file ) ; fileArraySlice . add ( parcelableRemoteFile ) ; if ( count >= SLICE_SIZE ) { localFileQueue . add ( fileArraySlice ) ; fileArraySlice = new ArrayList < > ( ) ; count = <NUM_LIT> ; } } localFileQueue . add ( fileArraySlice ) ; return localFileQueue . size ( ) ; } @ Override public List < ParcelableRemoteFile > pollLocalFiles ( ) throws RemoteException { if ( localFileQueue == null ) { return null ; } return localFileQueue . poll ( ) ; } @ Override public ParcelableRemoteFile getParentFile ( String path ) throws RemoteException { String parent = new File ( path ) . getParent ( ) ; Log . i ( TAG , parent + \"<STR_LIT>\" ) ; File parentFile = new File ( path ) . getParentFile ( ) ; Log . i ( TAG , parentFile + \"<STR_LIT>\" ) ; if ( parentFile == null ) { return null ; } return new ParcelableRemoteFile ( parentFile ) ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import java . util . Date ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . async . CookieFailedException ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliComment ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentReplyPage ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; public class CommentCheckTask extends CommentOperateTask < CommentCheckTask . EventHandler > { private final String testCommentText ; public CommentCheckTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment , String testCommentText ) { super ( handle , commentManipulator , config , statisticsDB , comment ) ; this . testCommentText = testCommentText ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { CommentArea commentArea = comment . commentArea ; HistoryComment historyComment = new HistoryComment ( comment ) ; historyComment . lastCheckDate = new Date ( ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_START_COMMENT_CHECK ) ; if ( ! commentManipulator . checkCookieNotFailed ( ) ) { eventHandler . sendError ( new CookieFailedException ( ) ) ; return ; } BiliComment biliComment = commentManipulator . findComment ( comment . commentArea , comment . rpid , comment . root ) ; if ( biliComment != null ) { if ( biliComment . invisible ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_INVISIBLE ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_INVISIBLE ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_NORMAL ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_COMMENT_OK ) ; } } else { if ( comment . root == <NUM_LIT> ) { eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_ON_COMMENT_NOT_FOUND ) ; GeneralResponse < CommentReplyPage > response = commentManipulator . getCommentReplyHasAccount ( commentArea , comment . rpid , <NUM_LIT> , false ) ; OkHttpUtil . respNotNull ( response ) ; if ( response . code == CommentAddResult . CODE_SUCCESS ) { try { Thread . sleep ( <NUM_LIT> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } GeneralResponse < CommentReplyPage > noACResp = commentManipulator . getCommentReplyNoAccount ( commentArea , comment . rpid , <NUM_LIT> ) ; OkHttpUtil . respNotNull ( noACResp ) ; if ( noACResp . isSuccess ( ) ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_UNDER_REVIEW ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_UNDER_REVIEW ) ; } else if ( noACResp . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( noACResp , null ) ) ; } } else if ( response . code == CommentAddResult . CODE_DELETED ) { GeneralResponse < CommentAddResult > response1 = commentManipulator . getSendCommentCall ( testCommentText , comment . rpid , comment . root , commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( response1 ) ; if ( response1 . isSuccess ( ) ) { sleep ( config . getWaitTime ( ) ) ; commentManipulator . deleteComment ( comment . commentArea , comment . rpid , false ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else if ( response1 . code == CommentAddResult . CODE_DELETED ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( response1 . code , response1 . message , null ) ) ; } } else { eventHandler . sendError ( new BiliBiliApiException ( response . code , response . message , null ) ) ; } } else { BiliComment foundReply = commentManipulator . findCommentFromCommentReplyArea ( commentArea , comment . rpid , comment . root , true ) ; if ( foundReply != null ) { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_SHADOW_BAN ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_SHADOW_BAN ) ; } else { historyComment . setFirstStateAndCurrentState ( HistoryComment . STATE_DELETED ) ; insertHistoryComment ( historyComment ) ; eventHandler . sendEmptyEventMessage ( EventHandler . WHAT_THEN_DELETED ) ; } } } } public abstract static class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_START_COMMENT_CHECK = <NUM_LIT> ; public static final int WHAT_ON_COMMENT_NOT_FOUND = <NUM_LIT> ; public static final int WHAT_ON_PAGE_TURN_FOR_HAS_ACC_REPLY = <NUM_LIT> ; public static final int WHAT_THEN_COMMENT_OK = <NUM_LIT> ; public static final int WHAT_THEN_SHADOW_BAN = <NUM_LIT> ; public static final int WHAT_THEN_DELETED = <NUM_LIT> ; public static final int WHAT_THEN_UNDER_REVIEW = <NUM_LIT> ; public static final int WHAT_THEN_INVISIBLE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; }", "output": "} }"}, {"input": "package com . wmods . wppenhacer . ui . fragments ; import android . annotation . SuppressLint ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . SharedPreferences ; import android . os . Build ; import android . os . Bundle ; import android . util . Log ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . content . ContextCompat ; import androidx . fragment . app . FragmentActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . App ; import com . wmods . wppenhacer . BuildConfig ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . MainActivity ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . databinding . FragmentHomeBinding ; import com . wmods . wppenhacer . ui . fragments . base . BaseFragment ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . utils . Utils ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Date ; import java . util . HashSet ; import java . util . Locale ; import java . util . Objects ; import rikka . core . util . IOUtils ; public class HomeFragment extends BaseFragment { private FragmentHomeBinding binding ; @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; var intentFilter = new IntentFilter ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; ContextCompat . registerReceiver ( requireContext ( ) , new BroadcastReceiver ( ) { @ Override public void onReceive ( Context context , Intent intent ) { try { if ( FeatureLoader . PACKAGE_WPP . equals ( intent . getStringExtra ( \"<STR_LIT>\" ) ) ) receiverBroadcastWpp ( context , intent ) ; else receiverBroadcastBusiness ( context , intent ) ; } catch ( Exception ignored ) { } } } , intentFilter , ContextCompat . RECEIVER_EXPORTED ) ; } public View onCreateView ( @ NonNull LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { binding = FragmentHomeBinding . inflate ( inflater , container , false ) ; checkStateWpp ( requireActivity ( ) ) ; binding . rebootBtn . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; disableWpp ( requireActivity ( ) ) ; } ) ; binding . rebootBtn2 . setOnClickListener ( view -> { App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; disableBusiness ( requireActivity ( ) ) ; } ) ; binding . exportBtn . setOnClickListener ( view -> saveConfigs ( this . getContext ( ) ) ) ; binding . importBtn . setOnClickListener ( view -> importConfigs ( this . getContext ( ) ) ) ; binding . resetBtn . setOnClickListener ( view -> resetConfigs ( this . getContext ( ) ) ) ; return binding . getRoot ( ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void receiverBroadcastBusiness ( Context context , Intent intent ) { binding . statusTitle3 . setText ( R . string . business_in_background ) ; var version = intent . getStringExtra ( \"<STR_LIT>\" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ) { binding . statusSummary3 . setText ( getString ( R . string . version_s , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary3 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status3 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn2 . setVisibility ( View . VISIBLE ) ; binding . statusSummary3 . setVisibility ( View . VISIBLE ) ; binding . statusIcon3 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void receiverBroadcastWpp ( Context context , Intent intent ) { binding . statusTitle2 . setText ( R . string . whatsapp_in_background ) ; var version = intent . getStringExtra ( \"<STR_LIT>\" ) ; var supported_list = Arrays . asList ( context . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ; if ( version != null && supported_list . stream ( ) . anyMatch ( s -> version . startsWith ( s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ) { binding . statusSummary1 . setText ( getString ( R . string . version_s , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_green ) ) ; } else { binding . statusSummary1 . setText ( getString ( R . string . version_s_not_listed , version ) ) ; binding . status2 . setCardBackgroundColor ( context . getColor ( R . color . material_state_yellow ) ) ; } binding . rebootBtn . setVisibility ( View . VISIBLE ) ; binding . statusSummary1 . setVisibility ( View . VISIBLE ) ; binding . statusIcon2 . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; } private void resetConfigs ( Context context ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; Utils . showToast ( context . getString ( R . string . configs_reset ) , Toast . LENGTH_SHORT ) ; } private static @ NonNull JSONObject getJsonObject ( SharedPreferences prefs ) throws JSONException { var entries = prefs . getAll ( ) ; var JSOjsonObject = new JSONObject ( ) ; for ( var entry : entries . entrySet ( ) ) { var type = new JSONObject ( ) ; var keyValue = entry . getValue ( ) ; if ( keyValue instanceof HashSet < ? > hashSet ) { keyValue = new JSONArray ( new ArrayList < > ( hashSet ) ) ; } type . put ( \"<STR_LIT>\" , entry . getValue ( ) . getClass ( ) . getSimpleName ( ) ) ; type . put ( \"<STR_LIT>\" , keyValue ) ; JSOjsonObject . put ( entry . getKey ( ) , type ) ; } return JSOjsonObject ; } private void saveConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var output = context . getContentResolver ( ) . openOutputStream ( uri ) ) { var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var JSOjsonObject = getJsonObject ( prefs ) ; Objects . requireNonNull ( output ) . write ( JSOjsonObject . toString ( <NUM_LIT> ) . getBytes ( ) ) ; } Toast . makeText ( context , context . getString ( R . string . configs_saved ) , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( \"<STR_LIT>\" , Locale . US ) ; String formattedDate = dateFormat . format ( new Date ( ) ) ; FilePicker . fileSalve . launch ( \"<STR_LIT>\" + formattedDate + \"<STR_LIT>\" ) ; } private void importConfigs ( Context context ) { FilePicker . setOnUriPickedListener ( ( uri ) -> { try { try ( var input = context . getContentResolver ( ) . openInputStream ( uri ) ) { var data = IOUtils . toString ( input ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; var jsonObject = new JSONObject ( data ) ; prefs . getAll ( ) . forEach ( ( key , value ) -> prefs . edit ( ) . remove ( key ) . apply ( ) ) ; var key = jsonObject . keys ( ) ; while ( key . hasNext ( ) ) { var keyName = key . next ( ) ; var value = jsonObject . get ( keyName ) ; var type = value . getClass ( ) . getSimpleName ( ) ; if ( value instanceof JSONObject valueJson ) { value = valueJson . get ( \"<STR_LIT>\" ) ; type = valueJson . getString ( \"<STR_LIT>\" ) ; } if ( type . equals ( JSONArray . class . getSimpleName ( ) ) ) { var jsonArray = ( JSONArray ) value ; HashSet < String > hashSet = new HashSet < > ( ) ; for ( var i = <NUM_LIT> ; i < jsonArray . length ( ) ; i ++ ) { hashSet . add ( jsonArray . getString ( i ) ) ; } prefs . edit ( ) . putStringSet ( keyName , hashSet ) . apply ( ) ; } else if ( type . equals ( String . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putString ( keyName , ( String ) value ) . apply ( ) ; } else if ( type . equals ( Boolean . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putBoolean ( keyName , ( boolean ) value ) . apply ( ) ; } else if ( type . equals ( Integer . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putInt ( keyName , ( int ) value ) . apply ( ) ; } else if ( type . equals ( Long . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putLong ( keyName , ( long ) value ) . apply ( ) ; } else if ( type . equals ( Double . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } else if ( type . equals ( Float . class . getSimpleName ( ) ) ) { prefs . edit ( ) . putFloat ( keyName , Float . parseFloat ( String . valueOf ( value ) ) ) . apply ( ) ; } } } Toast . makeText ( context , context . getString ( R . string . configs_imported ) , Toast . LENGTH_SHORT ) . show ( ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_WPP ) ; App . getInstance ( ) . restartApp ( FeatureLoader . PACKAGE_BUSINESS ) ; } catch ( Exception e ) { Log . e ( \"<STR_LIT>\" , e . getMessage ( ) , e ) ; Toast . makeText ( context , e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; FilePicker . fileCapture . launch ( new String [ ] { \"<STR_LIT>\" } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void checkStateWpp ( FragmentActivity activity ) { if ( MainActivity . isXposedEnabled ( ) ) { binding . statusIcon . setImageResource ( R . drawable . ic_round_check_circle_24 ) ; binding . statusTitle . setText ( R . string . module_enabled ) ; binding . statusSummary . setText ( String . format ( getString ( R . string . version_s ) , BuildConfig . VERSION_NAME ) ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_green ) ) ; } else { binding . statusIcon . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle . setText ( R . string . module_disabled ) ; binding . status . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary . setVisibility ( View . GONE ) ; } if ( isInstalled ( FeatureLoader . PACKAGE_WPP ) ) { disableWpp ( activity ) ; } else { binding . status2 . setVisibility ( View . GONE ) ;", "output": "} if ( isInstalled ( FeatureLoader . PACKAGE_BUSINESS ) ) { disableBusiness ( activity ) ; } else { binding . status3 . setVisibility ( View . GONE ) ; } checkWpp ( activity ) ; binding . deviceName . setText ( Build . MANUFACTURER ) ; binding . sdk . setText ( String . valueOf ( Build . VERSION . SDK_INT ) ) ; binding . modelName . setText ( Build . DEVICE ) ; binding . listWpp . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_wpp ) ) ) ; binding . listBusiness . setText ( Arrays . toString ( activity . getResources ( ) . getStringArray ( R . array . supported_versions_business ) ) ) ; } private boolean isInstalled ( String packageWpp ) { try { App . getInstance ( ) . getPackageManager ( ) . getPackageInfo ( packageWpp , <NUM_LIT> ) ; return true ; } catch ( Exception ignored ) { } return false ; } private void disableBusiness ( FragmentActivity activity ) { binding . statusIcon3 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle3 . setText ( R . string . business_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status3 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary3 . setVisibility ( View . GONE ) ; binding . rebootBtn2 . setVisibility ( View . GONE ) ; } private void disableWpp ( FragmentActivity activity ) { binding . statusIcon2 . setImageResource ( R . drawable . ic_round_error_outline_24 ) ; binding . statusTitle2 . setText ( R . string . whatsapp_is_not_running_or_has_not_been_activated_in_lsposed ) ; binding . status2 . setCardBackgroundColor ( activity . getColor ( R . color . material_state_red ) ) ; binding . statusSummary1 . setVisibility ( View . GONE ) ; binding . rebootBtn . setVisibility ( View . GONE ) ; } private static void checkWpp ( FragmentActivity activity ) { Intent checkWpp = new Intent ( BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; activity . sendBroadcast ( checkWpp ) ; } @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; binding = null ; } }"}, {"input": "package com . appspa . update . widget ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . util . DisplayMetrics ; import android . view . Gravity ; import android . view . KeyEvent ; import android . view . View ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AppCompatActivity ; import androidx . core . app . ActivityCompat ; import com . appspa . update . R ; import com . appspa . update . _AppSpace ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; import static com . appspa . update . entity . UpdateError . ERROR . DOWNLOAD_PERMISSION_DENIED ; import static com . appspa . update . widget . UpdateDialogFragment . KEY_UPDATE_ENTITY ; import static com . appspa . update . widget . UpdateDialogFragment . KEY_UPDATE_PROMPT_ENTITY ; import static com . appspa . update . widget . UpdateDialogFragment . REQUEST_CODE_REQUEST_PERMISSIONS ; public class UpdateDialogActivity extends AppCompatActivity implements View . OnClickListener , IDownloadEventHandler { private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private static IPrompterProxy sIPrompterProxy ; private PromptEntity mPromptEntity ; public static void show ( @ NonNull Context context , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , @ NonNull PromptEntity promptEntity ) { Intent intent = new Intent ( context , UpdateDialogActivity . class ) ; intent . putExtra ( KEY_UPDATE_ENTITY , updateEntity ) ; intent . putExtra ( KEY_UPDATE_PROMPT_ENTITY , promptEntity ) ; if ( ! ( context instanceof Activity ) ) { intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; } setIPrompterProxy ( prompterProxy ) ; context . startActivity ( intent ) ; } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . spa_layout_update_prompter ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; initView ( ) ; initData ( ) ; } private void initView ( ) { mIvTop = findViewById ( R . id . iv_top ) ; mTvTitle = findViewById ( R . id . tv_title ) ; mTvUpdateInfo = findViewById ( R . id . tv_update_info ) ; mBtnUpdate = findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = findViewById ( R . id . btn_background_update ) ; mTvIgnore = findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = findViewById ( R . id . npb_progress ) ; mLlClose = findViewById ( R . id . ll_close ) ; mIvClose = findViewById ( R . id . iv_close ) ; } private void initData ( ) { Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle == null ) { return ; } mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } initTheme ( mPromptEntity . getThemeColor ( ) , mPromptEntity . getTopResId ( ) , mPromptEntity . getButtonTextColor ( ) ) ; mUpdateEntity = bundle . getParcelable ( KEY_UPDATE_ENTITY ) ; if ( mUpdateEntity != null ) { initUpdateInfo ( mUpdateEntity ) ; initListeners ( ) ; } } private PromptEntity getPromptEntity ( ) { if ( mPromptEntity == null ) { Bundle bundle = getIntent ( ) . getExtras ( ) ; if ( bundle != null ) { mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; } } if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } return mPromptEntity ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( this , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( this , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , this ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , this ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; } private void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; } @ Override public void onStart ( ) { super . onStart ( ) ; initWindowStyle ( ) ; } private void initWindowStyle ( ) { Window window = getWindow ( ) ; if ( window != null ) { PromptEntity promptEntity = getPromptEntity ( ) ; window . setGravity ( Gravity . CENTER ) ; WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getResources ( ) . getDisplayMetrics ( ) ; if ( promptEntity . getWidthRatio ( ) > <NUM_LIT> && promptEntity . getWidthRatio ( ) < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * promptEntity . getWidthRatio ( ) ) ; } if ( promptEntity . getHeightRatio ( ) > <NUM_LIT> && promptEntity . getHeightRatio ( ) < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * promptEntity . getHeightRatio ( ) ) ; } window . setAttributes ( lp ) ; } } @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { return keyCode == KeyEvent . KEYCODE_BACK ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( this , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . backgroundDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . iv_close ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . cancelDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( this , mUpdateEntity . getVersionName ( ) ) ; dismissDialog ( ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == REQUEST_CODE_REQUEST_PERMISSIONS ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { installApp ( ) ; } else { _AppSpace . onUpdateError ( DOWNLOAD_PERMISSION_DENIED ) ; dismissDialog ( ) ; } } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismissDialog ( ) ; } else { showInstallButton ( ) ; } } else { if ( sIPrompterProxy != null ) { sIPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( ! isFinishing ( ) ) { doStart ( ) ;", "output": "} } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( ! isFinishing ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( ! isFinishing ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismissDialog ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( ! isFinishing ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismissDialog ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( this , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } private void dismissDialog ( ) { finish ( ) ; } @ Override protected void onStop ( ) { if ( isFinishing ( ) ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; } super . onStop ( ) ; } private static void setIPrompterProxy ( IPrompterProxy prompterProxy ) { UpdateDialogActivity . sIPrompterProxy = prompterProxy ; } private static void clearIPrompterProxy ( ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . recycle ( ) ; sIPrompterProxy = null ; } } private String getUrl ( ) { return sIPrompterProxy != null ? sIPrompterProxy . getUrl ( ) : \"<STR_LIT>\" ; } }"}, {"input": "package com . wmods . wppenhacer . ui . fragments ; import android . os . Bundle ; import androidx . annotation . Nullable ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . ui . fragments . base . BasePreferenceFragment ; public class CustomizationFragment extends BasePreferenceFragment { @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { super . onCreatePreferences ( savedInstanceState , rootKey ) ; setPreferencesFromResource ( R . xml . fragment_customization , rootKey ) ; }", "output": "}"}, {"input": "package top . weixiansen574 . async ; import android . os . Handler ; import android . os . Looper ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; public class TaskManger { private static volatile Handler mainThreadHandler ; private static Handler getUiThreadHandler ( ) { if ( mainThreadHandler == null ) { synchronized ( TaskManger . class ) { if ( mainThreadHandler == null ) { mainThreadHandler = new Handler ( Looper . getMainLooper ( ) ) ; } } } return mainThreadHandler ; } public static void postOnUiThread ( Runnable runnable ) { getUiThreadHandler ( ) . post ( runnable ) ; } private static final ExecutorService executorService = Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; public static void start ( Runnable runnable ) { executorService . execute ( runnable ) ; }", "output": "public static void execute ( BackstageTask < ? > backstageTask ) { start ( backstageTask ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Context ; import android . util . Log ; import com . baidu . speech . EventListener ; import com . baidu . speech . EventManager ; import com . baidu . speech . EventManagerFactory ; import com . baidu . speech . asr . SpeechConstant ; import org . json . JSONException ; import org . json . JSONObject ; import java . util . LinkedHashMap ; import java . util . Map ; public class BaiduAsrClient extends AsrClientBase { private EventManager asr = null ; String asrBuffer = \"<STR_LIT>\" ; IAsrCallback callback = null ; EventListener listener = null ; boolean autoStop = false ; public BaiduAsrClient ( Context context ) { asr = EventManagerFactory . create ( context , \"<STR_LIT>\" ) ; listener = new EventListener ( ) { @ Override public void onEvent ( String name , String params , byte [ ] data , int offset , int length ) { if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_PARTIAL ) ) { Log . d ( \"<STR_LIT>\" , params ) ; try { JSONObject json = new JSONObject ( params ) ; String resultType = json . getString ( \"<STR_LIT>\" ) ; if ( resultType . equals ( \"<STR_LIT>\" ) ) { String bestResult = json . getString ( \"<STR_LIT>\" ) ; asrBuffer += bestResult ; callback . onResult ( asrBuffer ) ; } else if ( resultType . equals ( \"<STR_LIT>\" ) ) { String bestResult = json . getString ( \"<STR_LIT>\" ) ; callback . onResult ( String . format ( \"<STR_LIT>\" , asrBuffer , bestResult ) ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } else if ( name . equals ( SpeechConstant . CALLBACK_EVENT_ASR_FINISH ) ) { Log . d ( \"<STR_LIT>\" , params ) ; try { JSONObject json = new JSONObject ( params ) ; int errorCode = json . getInt ( \"<STR_LIT>\" ) ; if ( errorCode == <NUM_LIT> && autoStop ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; callback . onAutoStop ( ) ; } else if ( errorCode == <NUM_LIT> ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; startRecognize ( ) ; } else if ( errorCode != <NUM_LIT> ) { String errorMessage = json . getString ( \"<STR_LIT>\" ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + errorCode + \"<STR_LIT>\" + errorMessage ) ; callback . onError ( errorMessage ) ; } } catch ( JSONException e ) { e . printStackTrace ( ) ; } } }", "output": "} ; asr . registerListener ( listener ) ; } @ Override public void startRecognize ( ) { Map < String , Object > params = new LinkedHashMap < > ( ) ; params . put ( SpeechConstant . APP_ID , GlobalDataHolder . getAsrAppId ( ) ) ; params . put ( SpeechConstant . APP_KEY , GlobalDataHolder . getAsrApiKey ( ) ) ; params . put ( SpeechConstant . SECRET , GlobalDataHolder . getAsrSecretKey ( ) ) ; if ( autoStop ) { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , false ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_DNN ) ; params . put ( SpeechConstant . VAD_ENDPOINT_TIMEOUT , <NUM_LIT> ) ; } else { if ( GlobalDataHolder . getAsrUseRealTime ( ) ) { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , true ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_DNN ) ; } else { params . put ( SpeechConstant . BDS_ASR_ENABLE_LONG_SPEECH , false ) ; params . put ( SpeechConstant . VAD , SpeechConstant . VAD_TOUCH ) ; } } params . put ( SpeechConstant . PID , <NUM_LIT> ) ; asr . send ( SpeechConstant . ASR_START , ( new JSONObject ( params ) ) . toString ( ) , null , <NUM_LIT> , <NUM_LIT> ) ; asrBuffer = \"<STR_LIT>\" ; } @ Override public void stopRecognize ( ) { asr . send ( SpeechConstant . ASR_STOP , \"<STR_LIT>\" , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void cancelRecognize ( ) { asr . send ( SpeechConstant . ASR_CANCEL , null , null , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { cancelRecognize ( ) ; asr . unregisterListener ( listener ) ; } }"}, {"input": "package com . google . android . material . tabs ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_DRAGGING ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_IDLE ; import static androidx . fluidviewpager2 . widget . ViewPager2 . SCROLL_STATE_SETTLING ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . fluidrecyclerview . widget . RecyclerView ; import androidx . fluidviewpager2 . widget . ViewPager2 ; import java . lang . ref . WeakReference ; public final class FluidTabLayoutMediator { @ NonNull private final TabLayout tabLayout ; @ NonNull private final ViewPager2 viewPager ; private final boolean autoRefresh ; private final boolean smoothScroll ; private final TabConfigurationStrategy tabConfigurationStrategy ; @ Nullable private RecyclerView . Adapter < ? > adapter ; private boolean attached ; @ Nullable private TabLayoutOnPageChangeCallback onPageChangeCallback ; @ Nullable private TabLayout . OnTabSelectedListener onTabSelectedListener ; @ Nullable private RecyclerView . AdapterDataObserver pagerAdapterObserver ; public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this ( tabLayout , viewPager , autoRefresh , true , tabConfigurationStrategy ) ; } public FluidTabLayoutMediator ( @ NonNull TabLayout tabLayout , @ NonNull ViewPager2 viewPager , boolean autoRefresh , boolean smoothScroll , @ NonNull TabConfigurationStrategy tabConfigurationStrategy ) { this . tabLayout = tabLayout ; this . viewPager = viewPager ; this . autoRefresh = autoRefresh ; this . smoothScroll = smoothScroll ; this . tabConfigurationStrategy = tabConfigurationStrategy ; } public void attach ( ) { if ( attached ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } adapter = viewPager . getAdapter ( ) ; if ( adapter == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } attached = true ; onPageChangeCallback = new TabLayoutOnPageChangeCallback ( tabLayout ) ; viewPager . registerOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = new ViewPagerOnTabSelectedListener ( viewPager , smoothScroll ) ; tabLayout . addOnTabSelectedListener ( onTabSelectedListener ) ; if ( autoRefresh ) {", "output": "pagerAdapterObserver = new PagerAdapterObserver ( ) ; adapter . registerAdapterDataObserver ( pagerAdapterObserver ) ; } populateTabsFromPagerAdapter ( ) ; tabLayout . setScrollPosition ( viewPager . getCurrentItem ( ) , <NUM_LIT> , true ) ; } public void detach ( ) { if ( autoRefresh && adapter != null ) { adapter . unregisterAdapterDataObserver ( pagerAdapterObserver ) ; pagerAdapterObserver = null ; } tabLayout . removeOnTabSelectedListener ( onTabSelectedListener ) ; viewPager . unregisterOnPageChangeCallback ( onPageChangeCallback ) ; onTabSelectedListener = null ; onPageChangeCallback = null ; adapter = null ; attached = false ; } public boolean isAttached ( ) { return attached ; } @ SuppressWarnings ( \"<STR_LIT>\" ) void populateTabsFromPagerAdapter ( ) { tabLayout . removeAllTabs ( ) ; if ( adapter != null ) { int adapterCount = adapter . getItemCount ( ) ; for ( int i = <NUM_LIT> ; i < adapterCount ; i ++ ) { TabLayout . Tab tab = tabLayout . newTab ( ) ; tabConfigurationStrategy . onConfigureTab ( tab , i ) ; tabLayout . addTab ( tab , false ) ; } if ( adapterCount > <NUM_LIT> ) { int lastItem = tabLayout . getTabCount ( ) - <NUM_LIT> ; int currItem = Math . min ( viewPager . getCurrentItem ( ) , lastItem ) ; if ( currItem != tabLayout . getSelectedTabPosition ( ) ) { tabLayout . selectTab ( tabLayout . getTabAt ( currItem ) ) ; } } } } public interface TabConfigurationStrategy { void onConfigureTab ( @ NonNull TabLayout . Tab tab , int position ) ; } private static class TabLayoutOnPageChangeCallback extends ViewPager2 . OnPageChangeCallback { @ NonNull private final WeakReference < TabLayout > tabLayoutRef ; private int previousScrollState ; private int scrollState ; TabLayoutOnPageChangeCallback ( TabLayout tabLayout ) { tabLayoutRef = new WeakReference < > ( tabLayout ) ; reset ( ) ; } @ Override public void onPageScrollStateChanged ( final int state ) { previousScrollState = scrollState ; scrollState = state ; TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { tabLayout . updateViewPagerScrollState ( scrollState ) ; } } @ Override public void onPageScrolled ( int position , float positionOffset , int positionOffsetPixels ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null ) { boolean updateSelectedTabView = scrollState != SCROLL_STATE_SETTLING || previousScrollState == SCROLL_STATE_DRAGGING ; boolean updateIndicator = ! ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . setScrollPosition ( position , positionOffset , updateSelectedTabView , updateIndicator , false ) ; } } @ Override public void onPageSelected ( final int position ) { TabLayout tabLayout = tabLayoutRef . get ( ) ; if ( tabLayout != null && tabLayout . getSelectedTabPosition ( ) != position && position < tabLayout . getTabCount ( ) ) { boolean updateIndicator = scrollState == SCROLL_STATE_IDLE || ( scrollState == SCROLL_STATE_SETTLING && previousScrollState == SCROLL_STATE_IDLE ) ; tabLayout . selectTab ( tabLayout . getTabAt ( position ) , updateIndicator ) ; } } void reset ( ) { previousScrollState = scrollState = SCROLL_STATE_IDLE ; } } private static class ViewPagerOnTabSelectedListener implements TabLayout . OnTabSelectedListener { private final ViewPager2 viewPager ; private final boolean smoothScroll ; ViewPagerOnTabSelectedListener ( ViewPager2 viewPager , boolean smoothScroll ) { this . viewPager = viewPager ; this . smoothScroll = smoothScroll ; } @ Override public void onTabSelected ( @ NonNull TabLayout . Tab tab ) { viewPager . setCurrentItem ( tab . getPosition ( ) , smoothScroll ) ; } @ Override public void onTabUnselected ( TabLayout . Tab tab ) { } @ Override public void onTabReselected ( TabLayout . Tab tab ) { } } private class PagerAdapterObserver extends RecyclerView . AdapterDataObserver { PagerAdapterObserver ( ) { } @ Override public void onChanged ( ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeChanged ( int positionStart , int itemCount , @ Nullable Object payload ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeInserted ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeRemoved ( int positionStart , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } @ Override public void onItemRangeMoved ( int fromPosition , int toPosition , int itemCount ) { populateTabsFromPagerAdapter ( ) ; } } }"}, {"input": "package de . robv . android . xposed . services ; import java . io . IOException ; import java . util . Arrays ; @ SuppressWarnings ( \"<STR_LIT>\" ) public final class ZygoteService extends BaseService { @ Override public native boolean checkFileAccess ( String filename , int mode ) ; @ Override public native FileResult statFile ( String filename ) throws IOException ; @ Override public native byte [ ] readFile ( String filename ) throws IOException ; @ Override public FileResult readFile ( String filename , long previousSize , long previousTime ) throws IOException { FileResult stat = statFile ( filename ) ; if ( previousSize == stat . size && previousTime == stat . mtime ) return stat ; return new FileResult ( readFile ( filename ) , stat . size , stat . mtime ) ; } @ Override public FileResult readFile ( String filename , int offset , int length , long previousSize , long previousTime ) throws IOException { FileResult stat = statFile ( filename ) ; if ( previousSize == stat . size && previousTime == stat . mtime ) return stat ; if ( offset <= <NUM_LIT> && length <= <NUM_LIT> ) return new FileResult ( readFile ( filename ) , stat . size , stat . mtime ) ; if ( offset > <NUM_LIT> && offset >= stat . size ) {", "output": "throw new IllegalArgumentException ( \"<STR_LIT>\" + offset + \"<STR_LIT>\" + stat . size + \"<STR_LIT>\" + filename ) ; } else if ( offset < <NUM_LIT> ) { offset = <NUM_LIT> ; } if ( length > <NUM_LIT> && ( offset + length ) > stat . size ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + offset + \"<STR_LIT>\" + length + \"<STR_LIT>\" + stat . size + \"<STR_LIT>\" + filename ) ; } else if ( length <= <NUM_LIT> ) { length = ( int ) ( stat . size - offset ) ; } byte [ ] content = readFile ( filename ) ; return new FileResult ( Arrays . copyOfRange ( content , offset , offset + length ) , stat . size , stat . mtime ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . batteryoptimization ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . PowerManager ; import android . provider . Settings ; import androidx . annotation . RequiresApi ; public class BatteryOptimization { private final BatteryOptimizationPlugin plugin ; public BatteryOptimization ( BatteryOptimizationPlugin plugin ) { this . plugin = plugin ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public boolean isBatteryOptimizationEnabled ( ) { PowerManager powerManager = ( PowerManager ) plugin . getContext ( ) . getSystemService ( Context . POWER_SERVICE ) ;", "output": "return ! powerManager . isIgnoringBatteryOptimizations ( plugin . getContext ( ) . getPackageName ( ) ) ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public void openBatteryOptimizationSettings ( ) { Intent intent = new Intent ( ) ; intent . setAction ( Settings . ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; plugin . getContext ( ) . startActivity ( intent ) ; } @ RequiresApi ( api = Build . VERSION_CODES . M ) public void requestIgnoreBatteryOptimization ( ) { Intent intent = new Intent ( ) ; intent . setAction ( Settings . ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" + plugin . getContext ( ) . getPackageName ( ) ) ) ; plugin . getContext ( ) . startActivity ( intent ) ; } }"}, {"input": "package com . appspa . demo . utils ; import android . app . NotificationManager ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . provider . Settings ; import androidx . core . app . NotificationManagerCompat ; public final class NotifyUtils { private NotifyUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static boolean isNotifyPermissionOpen ( Context context ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { return NotificationManagerCompat . from ( context ) . getImportance ( ) != NotificationManager . IMPORTANCE_NONE ; } return NotificationManagerCompat . from ( context ) . areNotificationsEnabled ( ) ; } public static void openNotifyPermissionSetting ( Context context ) { try { Intent intent = new Intent ( ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { intent . setAction ( Settings . ACTION_APP_NOTIFICATION_SETTINGS ) ; intent . putExtra ( Settings . EXTRA_APP_PACKAGE , context . getPackageName ( ) ) ; intent . putExtra ( Settings . EXTRA_CHANNEL_ID , context . getApplicationInfo ( ) . uid ) ; context . startActivity ( intent ) ; return ; } if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { intent . setAction ( \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , context . getPackageName ( ) ) ; intent . putExtra ( \"<STR_LIT>\" , context . getApplicationInfo ( ) . uid ) ; context . startActivity ( intent ) ; return ; } if ( android . os . Build . VERSION . SDK_INT == Build . VERSION_CODES . KITKAT ) {", "output": "intent . setAction ( Settings . ACTION_APPLICATION_DETAILS_SETTINGS ) ; intent . addCategory ( Intent . CATEGORY_DEFAULT ) ; intent . setData ( Uri . parse ( \"<STR_LIT>\" + context . getPackageName ( ) ) ) ; context . startActivity ( intent ) ; return ; } if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { intent . setAction ( \"<STR_LIT>\" ) ; intent . setData ( Uri . fromParts ( \"<STR_LIT>\" , context . getPackageName ( ) , null ) ) ; context . startActivity ( intent ) ; return ; } intent . setAction ( Intent . ACTION_VIEW ) ; intent . setClassName ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; intent . putExtra ( \"<STR_LIT>\" , context . getPackageName ( ) ) ; context . startActivity ( intent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package com . simon . harmonichackernews . data ; import java . util . HashSet ; public class CommentsScrollProgress { public CommentsScrollProgress ( ) { collapsedIDs = new HashSet < > ( ) ; }", "output": "public int storyId ; public int topCommentId ; public int topCommentOffset ; public HashSet < Integer > collapsedIDs ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . comment ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . SharedPreferences ; import android . util . Log ; import android . view . View ; import android . widget . EditText ; import android . widget . Toast ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Random ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; import icu . freedomIntrovert . biliSendCommAntifraud . VoidDialogInterfaceOnClickListener ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . CommentArea ; public class CommentUtil { private CommentArea yourCommentArea ; private String sourceRandomComments ; private String [ ] randomComments ; private HashMap < CommentArea , LinkedList < String > > usedTestCommentMap ; SharedPreferences sp_config ; public CommentUtil ( Context context ) { sp_config = context . getSharedPreferences ( \"<STR_LIT>\" , Context . MODE_PRIVATE ) ; this . sourceRandomComments = sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; this . randomComments = sourceRandomComments . split ( \"<STR_LIT>\" ) ; usedTestCommentMap = new HashMap < > ( ) ; if ( sp_config . contains ( \"<STR_LIT>\" ) ) { this . yourCommentArea = new CommentArea ( Long . parseLong ( sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , sp_config . getInt ( \"<STR_LIT>\" , <NUM_LIT> ) ) ; } } public String getSourceRandomComments ( ) { return sourceRandomComments ; } public String getAreaSourceText ( ) { return sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public CommentArea getYourCommentArea ( ) { return yourCommentArea ; } public boolean setYourCommentArea ( String sourceAreaText , CommentManipulator commentManipulator ) throws IOException { CommentArea commentArea = commentManipulator . matchCommentArea ( sourceAreaText ) ; if ( commentArea != null ) { sp_config . edit ( ) . putString ( \"<STR_LIT>\" , String . valueOf ( commentArea . oid ) ) . putInt ( \"<STR_LIT>\" , commentArea . type ) . putString ( \"<STR_LIT>\" , commentArea . sourceId ) . putString ( \"<STR_LIT>\" , sourceAreaText ) . apply ( ) ; yourCommentArea = commentArea ; return true ; } else { return false ; } } public void setYourCommentArea ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( getAreaSourceText ( ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setView ( dialogView ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) {", "output": "Toast . makeText ( context , \"<STR_LIT>\" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { sp_config . edit ( ) . putString ( \"<STR_LIT>\" , String . valueOf ( commentArea . oid ) ) . putInt ( \"<STR_LIT>\" , commentArea . type ) . putString ( \"<STR_LIT>\" , commentArea . sourceId ) . putString ( \"<STR_LIT>\" , editText . getText ( ) . toString ( ) ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( \"<STR_LIT>\" ) ; } } } ) ; } } ) ; } public String getForwardDynamicId ( ) { return sp_config . getString ( \"<STR_LIT>\" , null ) ; } public void setDynamicIdToBeForward ( Context context , CommentManipulator commentManipulator ) { View dialogView = View . inflate ( context , R . layout . edit_text , null ) ; EditText editText = dialogView . findViewById ( R . id . edit_text ) ; editText . setText ( sp_config . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; AlertDialog dialog = new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setView ( dialogView ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setPositiveButton ( \"<STR_LIT>\" , null ) . show ( ) ; dialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { commentManipulator . matchCommentAreaInUi ( editText . getText ( ) . toString ( ) , new CommentManipulator . MatchCommentAreaCallBack ( ) { @ Override public void onNetworkError ( IOException e ) { Toast . makeText ( context , \"<STR_LIT>\" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMatchedArea ( CommentArea commentArea ) { if ( commentArea != null ) { if ( commentArea . type == CommentArea . AREA_TYPE_DYNAMIC17 || commentArea . type == CommentArea . AREA_TYPE_DYNAMIC11 ) { sp_config . edit ( ) . putString ( \"<STR_LIT>\" , editText . getText ( ) . toString ( ) ) . putString ( \"<STR_LIT>\" , commentArea . sourceId ) . apply ( ) ; yourCommentArea = commentArea ; dialog . dismiss ( ) ; Toast . makeText ( context , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } else { editText . setError ( \"<STR_LIT>\" ) ; } } else { editText . setError ( \"<STR_LIT>\" ) ; } } } ) ; } } ) ; } public String getRandomComment ( CommentArea area ) { if ( usedTestCommentMap . get ( area ) == null ) { LinkedList < String > noUsedCommentList = new LinkedList < > ( Arrays . asList ( randomComments ) ) ; usedTestCommentMap . put ( area , noUsedCommentList ) ; } Random random = new Random ( ) ; LinkedList < String > noUsedCommentList = usedTestCommentMap . get ( area ) ; int randomNum = random . nextInt ( noUsedCommentList . size ( ) ) ; String randomComment = noUsedCommentList . get ( randomNum ) ; noUsedCommentList . remove ( randomNum ) ; Log . i ( \"<STR_LIT>\" , randomComment ) ; return randomComment ; } public void updateRandomComments ( String sourceRandomComments ) { this . sourceRandomComments = sourceRandomComments ; sp_config . edit ( ) . putString ( \"<STR_LIT>\" , sourceRandomComments ) . apply ( ) ; } public static String sourceIdToUrl ( CommentArea area ) { String url = null ; if ( area . type == CommentArea . AREA_TYPE_VIDEO ) { url = \"<STR_LIT>\" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_ARTICLE ) { url = \"<STR_LIT>\" + area . sourceId ; } else if ( area . type == CommentArea . AREA_TYPE_DYNAMIC11 || area . type == CommentArea . AREA_TYPE_DYNAMIC17 ) { url = \"<STR_LIT>\" + area . sourceId ; } return url ; } public static String subComment ( String comment , int length ) { if ( comment . length ( ) > length ) { return comment . substring ( <NUM_LIT> , length - <NUM_LIT> ) + \"<STR_LIT>\" ; } else { return comment ; } } }"}, {"input": "package com . appspa . demo . activity ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . View ; import android . widget . EditText ; import com . appspa . demo . Constants ; import com . appspa . demo . R ; import com . appspa . demo . custom . CustomUpdateParser ; import com . appspa . demo . utils . NotifyUtils ; import com . appspa . demo . utils . SettingSPUtils ; import com . appspa . update . AppSpace ; import java . util . List ; import okhttp3 . HttpUrl ; public class MainActivity extends Activity implements View . OnClickListener { private EditText mEtServiceUrl ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; if ( ! NotifyUtils . isNotifyPermissionOpen ( this ) ) { new AlertDialog . Builder ( this ) . setCancelable ( false ) . setMessage ( \"<STR_LIT>\" ) . setPositiveButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface d , int w ) { NotifyUtils . openNotifyPermissionSetting ( MainActivity . this ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , null ) . show ( ) ; } initView ( ) ; } void initView ( ) { mEtServiceUrl = findViewById ( R . id . et_service_url ) ; mEtServiceUrl . setText ( Constants . CUSTOM_UPDATE_URL ) ; } @ Override public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . btn_save : String url = mEtServiceUrl . getText ( ) . toString ( ) . trim ( ) ; if ( parseBaseUrl ( url ) ) { SettingSPUtils . get ( ) . setServiceURL ( url ) ; } break ;", "output": "case R . id . btn_update : AppSpace . newBuild ( this ) . updateUrl ( Constants . CUSTOM_UPDATE_URL ) . updateParser ( new CustomUpdateParser ( ) ) . update ( ) ; break ; case R . id . btn_auto_update : AppSpace . newBuild ( this ) . isGet ( false ) . isAutoMode ( true ) . update ( ) ; break ; case R . id . btn_force_update : AppSpace . newBuild ( this ) . isGet ( false ) . param ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . update ( ) ; break ; default : break ; } } public static boolean parseBaseUrl ( String baseUrl ) { if ( ! TextUtils . isEmpty ( baseUrl ) ) { HttpUrl httpUrl = HttpUrl . parse ( baseUrl ) ; if ( httpUrl != null ) { List < String > pathSegments = httpUrl . pathSegments ( ) ; return \"<STR_LIT>\" . equals ( pathSegments . get ( pathSegments . size ( ) - <NUM_LIT> ) ) ; } } return false ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes ; import com . getcapacitor . JSObject ; public class ProcessImageResult { private final String imagePath ; private final int width ; private final int height ; public ProcessImageResult ( String imagePath , int width , int height ) { this . imagePath = imagePath ; this . width = width ; this . height = height ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , imagePath ) ; result . put ( \"<STR_LIT>\" , width ) ; result . put ( \"<STR_LIT>\" , height ) ; return result ; }", "output": "}"}, {"input": "package top . weixiansen574 . hybridfilexfer . async ; import java . util . List ; import top . weixiansen574 . async . BackstageTask ; import top . weixiansen574 . hybridfilexfer . IIServiceFileSelectAdapter ; import top . weixiansen574 . hybridfilexfer . Utils ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class CDParentTask extends BackstageTask < CDParentTask . EventHandler > { IIServiceFileSelectAdapter adapter ; String path ; public CDParentTask ( EventHandler handle , IIServiceFileSelectAdapter adapter , String path ) { super ( handle ) ; this . adapter = adapter ; this . path = path ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { String parentPath = Utils . getParentByPath ( path ) ; System . out . println ( \"<STR_LIT>\" + parentPath ) ; if ( parentPath != null ) { List < ParcelableRemoteFile > files = null ; files = adapter . listTargetFiles ( parentPath ) ; if ( files == null ) { eventHandler . onPermissionDenied ( ) ; }", "output": "else if ( files . size ( ) > <NUM_LIT> ) { Utils . sortFiles ( files ) ; eventHandler . onSuccess ( files , parentPath ) ; } else { eventHandler . onParentDirNotFiles ( ) ; } } else { eventHandler . onThisIsTheLastPage ( ) ; } } public interface EventHandler extends BaseEventHandler { void onSuccess ( List < ParcelableRemoteFile > files , String parentPath ) ; void onPermissionDenied ( ) ; void onParentDirNotFiles ( ) ; void onThisIsTheLastPage ( ) ; } }"}, {"input": "package external . org . apache . commons . lang3 ; public enum JavaVersion { JAVA_0_9 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_1 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_2 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_3 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_4 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_5 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_6 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_7 ( <NUM_LIT> , \"<STR_LIT>\" ) , JAVA_1_8 ( <NUM_LIT> , \"<STR_LIT>\" ) ; private float value ; private String name ; JavaVersion ( final float value , final String name ) { this . value = value ; this . name = name ; } public boolean atLeast ( JavaVersion requiredVersion ) { return this . value >= requiredVersion . value ; } static JavaVersion getJavaVersion ( final String nom ) { return get ( nom ) ; } static JavaVersion get ( final String nom ) { if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_0_9 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_1 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_2 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_3 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_4 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_5 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_6 ; } else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_7 ;", "output": "} else if ( \"<STR_LIT>\" . equals ( nom ) ) { return JAVA_1_8 ; } else { return null ; } } @ Override public String toString ( ) { return name ; } }"}, {"input": "package com . simon . harmonichackernews . utils ; import static androidx . browser . customtabs . CustomTabsService . ACTION_CUSTOM_TABS_CONNECTION ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . content . pm . ResolveInfo ; import android . content . res . Resources ; import android . net . ConnectivityManager ; import android . net . Network ; import android . net . NetworkCapabilities ; import android . net . Uri ; import android . os . AsyncTask ; import android . text . TextUtils ; import android . util . Log ; import android . util . TypedValue ; import android . webkit . URLUtil ; import android . widget . Toast ; import androidx . browser . customtabs . CustomTabColorSchemeParams ; import androidx . browser . customtabs . CustomTabsIntent ; import androidx . core . content . ContextCompat ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . preference . PreferenceManager ; import androidx . swiperefreshlayout . widget . SwipeRefreshLayout ; import com . simon . harmonichackernews . BuildConfig ; import com . simon . harmonichackernews . CommentsActivity ; import com . simon . harmonichackernews . R ; import com . simon . harmonichackernews . data . Bookmark ; import org . json . JSONArray ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . math . BigDecimal ; import java . net . URI ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . text . NumberFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . concurrent . TimeUnit ; public class Utils { private static final long SECOND_MILLIS = <NUM_LIT> ; private static final long MINUTE_MILLIS = <NUM_LIT> * SECOND_MILLIS ; private static final long HOUR_MILLIS = <NUM_LIT> * MINUTE_MILLIS ; private static final long DAY_MILLIS = <NUM_LIT> * HOUR_MILLIS ; private static final long YEAR_MILLIS = <NUM_LIT> * DAY_MILLIS ; public final static String KEY_SHARED_PREFERENCES_CLICKED_IDS = \"<STR_LIT>\" ; public final static String KEY_SHARED_PREFERENCES_CACHED_STORY = \"<STR_LIT>\" ; public final static String KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS = \"<STR_LIT>\" ; public final static String GLOBAL_SHARED_PREFERENCES_KEY = \"<STR_LIT>\" ; public final static String KEY_SHARED_PREFERENCES_BOOKMARKS = \"<STR_LIT>\" ; public final static String KEY_SHARED_PREFERENCES_FIRST_TIME = \"<STR_LIT>\" ; public final static String KEY_SHARED_PREFERENCES_LAST_VERSION = \"<STR_LIT>\" ; public final static String KEY_NIGHTTIME_FROM_HOUR = \"<STR_LIT>\" ; public final static String KEY_NIGHTTIME_FROM_MINUTE = \"<STR_LIT>\" ; public final static String KEY_NIGHTTIME_TO_HOUR = \"<STR_LIT>\" ; public final static String KEY_NIGHTTIME_TO_MINUTE = \"<STR_LIT>\" ; public final static String URL_TOP = \"<STR_LIT>\" ; public final static String URL_NEW = \"<STR_LIT>\" ; public final static String URL_BEST = \"<STR_LIT>\" ; public final static String URL_ASK = \"<STR_LIT>\" ; public final static String URL_SHOW = \"<STR_LIT>\" ; public final static String URL_JOBS = \"<STR_LIT>\" ; public static String adservers ; public static void log ( String s ) { Log . d ( \"<STR_LIT>\" , s ) ; } public static void log ( long i ) { Log . d ( \"<STR_LIT>\" , String . valueOf ( i ) ) ; } public static void log ( int i ) { Log . d ( \"<STR_LIT>\" , String . valueOf ( i ) ) ; } public static void log ( float i ) { Log . d ( \"<STR_LIT>\" , String . valueOf ( i ) ) ; } public static void log ( boolean b ) { Log . d ( \"<STR_LIT>\" , String . valueOf ( b ) ) ; } public static void toast ( String s , Context ctx ) { Toast . makeText ( ctx , s , Toast . LENGTH_SHORT ) . show ( ) ; } public static String getDomainName ( String url ) throws Exception { if ( url . endsWith ( \"<STR_LIT>\" ) ) { url = url . substring ( <NUM_LIT> , url . length ( ) - <NUM_LIT> ) ; } URI uri = new URI ( url ) ; String domain = uri . getHost ( ) ; return domain . startsWith ( \"<STR_LIT>\" ) ? domain . substring ( <NUM_LIT> ) : domain ; } public static void loadAdservers ( Resources resources ) { Runnable r = new Runnable ( ) { @ Override public void run ( ) { String strLine2 ; StringBuilder adserversBuilder = new StringBuilder ( ) ; InputStream fis2 = resources . openRawResource ( R . raw . adblockserverlist ) ; BufferedReader br2 = new BufferedReader ( new InputStreamReader ( fis2 ) ) ; if ( fis2 != null ) { try { while ( ( strLine2 = br2 . readLine ( ) ) != null ) { adserversBuilder . append ( strLine2 ) ; adserversBuilder . append ( \"<STR_LIT>\" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } Utils . adservers = String . valueOf ( adserversBuilder ) ; } } ; AsyncTask . execute ( r ) ; } public static void cacheStory ( Context ctx , int id , String data ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORY + id , data ) ; Set < String > cachedStories = SettingsUtils . readStringSetFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS ) ; if ( cachedStories == null ) { cachedStories = new HashSet < > ( ) ; } if ( ! cachedStories . isEmpty ( ) ) { for ( Iterator < String > iterator = cachedStories . iterator ( ) ; iterator . hasNext ( ) ; ) { String cached = iterator . next ( ) ; String [ ] idAndDate = cached . split ( \"<STR_LIT>\" ) ; if ( Integer . parseInt ( idAndDate [ <NUM_LIT> ] ) == id ) { iterator . remove ( ) ; } } } cachedStories . add ( id + \"<STR_LIT>\" + System . currentTimeMillis ( ) ) ; if ( cachedStories . size ( ) > <NUM_LIT> ) { long oldestTime = - <NUM_LIT> ; int oldestId = - <NUM_LIT> ; for ( String cachedStory : cachedStories ) { String [ ] idAndDate = cachedStory . split ( \"<STR_LIT>\" ) ; if ( oldestTime == - <NUM_LIT> || Long . parseLong ( idAndDate [ <NUM_LIT> ] ) < oldestTime ) { oldestTime = Long . parseLong ( idAndDate [ <NUM_LIT> ] ) ; oldestId = Integer . parseInt ( idAndDate [ <NUM_LIT> ] ) ; } } cachedStories . remove ( oldestId + \"<STR_LIT>\" + oldestTime ) ; ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) . edit ( ) . remove ( KEY_SHARED_PREFERENCES_CACHED_STORY + oldestId ) . apply ( ) ; } SettingsUtils . saveStringSetToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORIES_STRINGS , cachedStories ) ; } public static String loadCachedStory ( Context ctx , int id ) { return SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_CACHED_STORY + id ) ; } public static ArrayList < Bookmark > loadBookmarks ( Context ctx , boolean sorted ) { return loadBookmarks ( sorted , SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_BOOKMARKS ) ) ; } public static ArrayList < Bookmark > loadBookmarks ( boolean sorted , String bookmarksString ) { ArrayList < Bookmark > bookmarks = new ArrayList < > ( ) ; if ( bookmarksString == null || bookmarksString . isEmpty ( ) ) { return bookmarks ; } String [ ] pairs = bookmarksString . split ( \"<STR_LIT>\" ) ; for ( String pair : pairs ) { Bookmark b = new Bookmark ( ) ; String [ ] info = pair . split ( \"<STR_LIT>\" ) ; if ( info . length == <NUM_LIT> ) { b . id = Integer . parseInt ( info [ <NUM_LIT> ] ) ; b . created = Long . parseLong ( info [ <NUM_LIT> ] ) ; bookmarks . add ( b ) ; } } if ( sorted ) { Collections . sort ( bookmarks , ( b1 , b2 ) -> Long . compare ( b2 . created , b1 . created ) ) ; } return bookmarks ; } public static boolean isBookmarked ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; for ( Bookmark b : bookmarks ) { if ( b . id == id ) { return true ; } } return false ; } public static void saveBookmarks ( Context ctx , ArrayList < Bookmark > bookmarks ) { StringBuilder sb = new StringBuilder ( ) ; int size = bookmarks . size ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Bookmark b = bookmarks . get ( i ) ; sb . append ( b . id ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( b . created ) ; if ( i != size - <NUM_LIT> ) { sb . append ( \"<STR_LIT>\" ) ; } } SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_SHARED_PREFERENCES_BOOKMARKS , sb . toString ( ) ) ; } public static void addBookmark ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; Bookmark b = new Bookmark ( ) ; b . id = id ; b . created = System . currentTimeMillis ( ) ; bookmarks . add ( b ) ; saveBookmarks ( ctx , bookmarks ) ; } public static void removeBookmark ( Context ctx , int id ) { ArrayList < Bookmark > bookmarks = loadBookmarks ( ctx , false ) ; for ( Bookmark bookmark : bookmarks ) { if ( bookmark . id == id ) { bookmarks . remove ( bookmark ) ; break ; } }", "output": "saveBookmarks ( ctx , bookmarks ) ; } public static String getThousandSeparatedString ( int n ) { BigDecimal bd = new BigDecimal ( n ) ; NumberFormat formatter = NumberFormat . getInstance ( new Locale ( \"<STR_LIT>\" ) ) ; return formatter . format ( bd . longValue ( ) ) ; } public static ArrayList < String > getFilterWords ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String prefText = prefs . getString ( \"<STR_LIT>\" , null ) ; ArrayList < String > phrases = new ArrayList < > ( ) ; if ( ! TextUtils . isEmpty ( prefText ) ) { for ( String phrase : prefText . split ( \"<STR_LIT>\" ) ) { phrases . add ( phrase . trim ( ) ) ; } } return phrases ; } public static ArrayList < String > getFilterDomains ( Context ctx ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ctx ) ; String prefText = prefs . getString ( \"<STR_LIT>\" , null ) ; ArrayList < String > phrases = new ArrayList < > ( ) ; if ( ! TextUtils . isEmpty ( prefText ) ) { for ( String phrase : prefText . split ( \"<STR_LIT>\" ) ) { phrases . add ( phrase . trim ( ) ) ; } } return phrases ; } public static boolean isFirstAppStart ( Context ctx ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; if ( sharedPref . getBoolean ( KEY_SHARED_PREFERENCES_FIRST_TIME , true ) && SettingsUtils . readIntSetFromSharedPreferences ( ctx , Utils . KEY_SHARED_PREFERENCES_CLICKED_IDS ) . isEmpty ( ) ) { sharedPref . edit ( ) . putBoolean ( KEY_SHARED_PREFERENCES_FIRST_TIME , false ) . apply ( ) ; return true ; } return false ; } public static boolean justUpdated ( Context ctx ) { SharedPreferences sharedPref = ctx . getSharedPreferences ( GLOBAL_SHARED_PREFERENCES_KEY , Context . MODE_PRIVATE ) ; if ( BuildConfig . VERSION_CODE > sharedPref . getInt ( KEY_SHARED_PREFERENCES_LAST_VERSION , - <NUM_LIT> ) ) { sharedPref . edit ( ) . putInt ( KEY_SHARED_PREFERENCES_LAST_VERSION , BuildConfig . VERSION_CODE ) . apply ( ) ; return true ; } return false ; } public static String getTimeAgo ( long time ) { if ( time < <NUM_LIT> ) { time *= <NUM_LIT> ; } long now = System . currentTimeMillis ( ) ; if ( time > now || time <= <NUM_LIT> ) { return \"<STR_LIT>\" ; } final long diff = now - time ; if ( diff < MINUTE_MILLIS ) { return \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return diff / MINUTE_MILLIS + \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * MINUTE_MILLIS ) { return \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * HOUR_MILLIS ) { return diff / HOUR_MILLIS + \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * HOUR_MILLIS ) { return \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * DAY_MILLIS ) { return diff / DAY_MILLIS + \"<STR_LIT>\" ; } else if ( diff < <NUM_LIT> * YEAR_MILLIS ) { return \"<STR_LIT>\" ; } else { return diff / YEAR_MILLIS + \"<STR_LIT>\" ; } } public static boolean isOnWiFi ( Context ctx ) { ConnectivityManager connectivityManager = ( ConnectivityManager ) ctx . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; Network network = connectivityManager . getActiveNetwork ( ) ; if ( network == null ) { return false ; } NetworkCapabilities networkCapabilities = connectivityManager . getNetworkCapabilities ( network ) ; return networkCapabilities != null && networkCapabilities . hasTransport ( NetworkCapabilities . TRANSPORT_WIFI ) ; } public static void launchCustomTab ( Context ctx , String url ) { launchCustomTab ( ctx , url , true ) ; } public static void launchCustomTab ( Context ctx , String url , boolean shareable ) { if ( url != null ) { if ( SettingsUtils . shouldUseExternalBrowser ( ctx ) || ! isCustomTabSupported ( ctx ) ) { launchInExternalBrowser ( ctx , url ) ; } else { try { CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( url ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; try { CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( URLUtil . guessUrl ( url ) ) ) ; } catch ( Exception e1 ) { try { if ( ! url . startsWith ( \"<STR_LIT>\" ) && ! url . startsWith ( \"<STR_LIT>\" ) ) url = \"<STR_LIT>\" + url ; CustomTabsIntent . Builder builder = new CustomTabsIntent . Builder ( ) ; builder . setShareState ( shareable ? CustomTabsIntent . SHARE_STATE_ON : CustomTabsIntent . SHARE_STATE_OFF ) ; CustomTabColorSchemeParams . Builder colorBuilder = new CustomTabColorSchemeParams . Builder ( ) ; colorBuilder . setToolbarColor ( ContextCompat . getColor ( ctx , ThemeUtils . getBackgroundColorResource ( ctx ) ) ) ; builder . setDefaultColorSchemeParams ( colorBuilder . build ( ) ) ; CustomTabsIntent customTabsIntent = builder . build ( ) ; customTabsIntent . launchUrl ( ctx , Uri . parse ( url ) ) ; } catch ( Exception e2 ) { launchInExternalBrowser ( ctx , url ) ; } } } } } } public static void launchInExternalBrowser ( Context ctx , String url ) { try { Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e ) { try { Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( URLUtil . guessUrl ( url ) ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e1 ) { try { if ( ! url . startsWith ( \"<STR_LIT>\" ) && ! url . startsWith ( \"<STR_LIT>\" ) ) url = \"<STR_LIT>\" + url ; Intent browserIntent = new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ; ctx . startActivity ( browserIntent ) ; } catch ( Exception e2 ) { Toast . makeText ( ctx , \"<STR_LIT>\" + url , Toast . LENGTH_SHORT ) . show ( ) ; } } } } public static boolean downloadPDF ( Context context , String pdfUrl ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( pdfUrl ) ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( intent . resolveActivity ( context . getPackageManager ( ) ) != null ) { context . startActivity ( intent ) ; return true ; } return false ; } public static boolean isCustomTabSupported ( Context context ) { return ! getCustomTabsPackages ( context ) . isEmpty ( ) ; } public static ArrayList < ResolveInfo > getCustomTabsPackages ( Context context ) { PackageManager pm = context . getPackageManager ( ) ; Intent activityIntent = new Intent ( ) . setAction ( Intent . ACTION_VIEW ) . addCategory ( Intent . CATEGORY_BROWSABLE ) . setData ( Uri . fromParts ( \"<STR_LIT>\" , \"<STR_LIT>\" , null ) ) ; List < ResolveInfo > resolvedActivityList = pm . queryIntentActivities ( activityIntent , <NUM_LIT> ) ; ArrayList < ResolveInfo > packagesSupportingCustomTabs = new ArrayList < > ( ) ; for ( ResolveInfo info : resolvedActivityList ) { Intent serviceIntent = new Intent ( ) ; serviceIntent . setAction ( ACTION_CUSTOM_TABS_CONNECTION ) ; serviceIntent . setPackage ( info . activityInfo . packageName ) ; if ( pm . resolveService ( serviceIntent , <NUM_LIT> ) != null ) { packagesSupportingCustomTabs . add ( info ) ; } } return packagesSupportingCustomTabs ; } public static int [ ] JSONArrayToIntArray ( JSONArray jsonArray ) { int [ ] intArray = new int [ jsonArray . length ( ) ] ; for ( int i = <NUM_LIT> ; i < intArray . length ; ++ i ) { intArray [ i ] = jsonArray . optInt ( i ) ; } return intArray ; } public static int getColorViaAttr ( Context ctx , int attr ) { TypedValue typedValue = new TypedValue ( ) ; Resources . Theme theme = ctx . getTheme ( ) ; theme . resolveAttribute ( attr , typedValue , true ) ; return typedValue . data ; } public static String thousandSeparated ( int n ) { DecimalFormatSymbols symbols = DecimalFormatSymbols . getInstance ( ) ; symbols . setGroupingSeparator ( '<STR_LIT>' ) ; DecimalFormat formatter = new DecimalFormat ( \"<STR_LIT>\" , symbols ) ; return formatter . format ( new BigDecimal ( n ) . longValue ( ) ) ; } public static void writeInFile ( Context ctx , Uri uri , String text ) throws IOException { OutputStream outputStream ; outputStream = ctx . getContentResolver ( ) . openOutputStream ( uri ) ; BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( outputStream ) ) ; bw . write ( text ) ; bw . flush ( ) ; bw . close ( ) ; } public static String readFileContent ( Context ctx , Uri uri ) throws IOException { InputStream inputStream = ctx . getContentResolver ( ) . openInputStream ( uri ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; String currentline ; while ( ( currentline = reader . readLine ( ) ) != null ) { stringBuilder . append ( currentline ) ; } inputStream . close ( ) ; return stringBuilder . toString ( ) ; } public static boolean isTimeBetweenTwoTimes ( long initialTime , long finalTime , long currentTime ) { if ( finalTime < initialTime ) { finalTime += TimeUnit . DAYS . toMinutes ( <NUM_LIT> ) ; } if ( currentTime < initialTime ) { currentTime += TimeUnit . DAYS . toMinutes ( <NUM_LIT> ) ; } return initialTime <= currentTime && currentTime < finalTime ; } public static void setNighttimeHours ( int fromHour , int fromMinute , int toHour , int toMinute , Context ctx ) { SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_HOUR , fromHour + \"<STR_LIT>\" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_MINUTE , fromMinute + \"<STR_LIT>\" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_TO_HOUR , toHour + \"<STR_LIT>\" ) ; SettingsUtils . saveStringToSharedPreferences ( ctx , KEY_NIGHTTIME_TO_MINUTE , toMinute + \"<STR_LIT>\" ) ; } public static int [ ] getNighttimeHours ( Context ctx ) { return new int [ ] { Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_HOUR , \"<STR_LIT>\" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_FROM_MINUTE , \"<STR_LIT>\" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_TO_HOUR , \"<STR_LIT>\" ) ) , Integer . parseInt ( SettingsUtils . readStringFromSharedPreferences ( ctx , KEY_NIGHTTIME_TO_MINUTE , \"<STR_LIT>\" ) ) } ; } public static boolean timeInSecondsMoreThanTwoWeeksAgo ( int time ) { return ( System . currentTimeMillis ( ) - ( ( long ) time ) * <NUM_LIT> ) / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> > <NUM_LIT> ; } public static boolean timeInSecondsMoreThanTwoHoursAgo ( int time ) { return ( System . currentTimeMillis ( ) - ( ( long ) time ) * <NUM_LIT> ) / <NUM_LIT> / <NUM_LIT> / <NUM_LIT> > <NUM_LIT> ; } public static float pxFromDp ( final Resources resources , final float dp ) { return dp * resources . getDisplayMetrics ( ) . density ; } public static int pxFromDpInt ( final Resources resources , final float dp ) { return Math . round ( pxFromDp ( resources , dp ) ) ; } public static boolean isTablet ( Resources res ) { return res . getBoolean ( R . bool . is_tablet ) ; } public static void openLinkMaybeHN ( Context context , String href ) { Uri uri = Uri . parse ( href ) ; String scheme = uri . getScheme ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( scheme ) || \"<STR_LIT>\" . equalsIgnoreCase ( scheme ) ) { if ( \"<STR_LIT>\" . equalsIgnoreCase ( uri . getHost ( ) ) && \"<STR_LIT>\" . equals ( uri . getPath ( ) ) ) { String sId = uri . getQueryParameter ( \"<STR_LIT>\" ) ; if ( sId != null && ! sId . isEmpty ( ) && TextUtils . isDigitsOnly ( sId ) ) { int id = Integer . parseInt ( sId ) ; openCommentsActivity ( id , context ) ; return ; } } } Utils . launchCustomTab ( context , href ) ; } public static void openCommentsActivity ( int id , Context context ) { Uri uri = Uri . parse ( \"<STR_LIT>\" ) . buildUpon ( ) . appendQueryParameter ( \"<STR_LIT>\" , String . valueOf ( id ) ) . build ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW , uri ) ; intent . setClass ( context , CommentsActivity . class ) ; context . startActivity ( intent ) ; } }"}, {"input": "package com . wmods . wppenhacer ; import android . annotation . SuppressLint ; import android . content . ContextWrapper ; import android . content . res . XModuleResources ; import android . view . Window ; import android . view . WindowManager ; import androidx . annotation . NonNull ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . xposed . AntiUpdater ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import com . wmods . wppenhacer . xposed . downgrade . Patch ; import com . wmods . wppenhacer . xposed . utils . ResId ; import de . robv . android . xposed . IXposedHookInitPackageResources ; import de . robv . android . xposed . IXposedHookLoadPackage ; import de . robv . android . xposed . IXposedHookZygoteInit ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XC_MethodReplacement ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import de . robv . android . xposed . callbacks . XC_InitPackageResources ; import de . robv . android . xposed . callbacks . XC_LoadPackage ; public class WppXposed implements IXposedHookLoadPackage , IXposedHookInitPackageResources , IXposedHookZygoteInit { private static XSharedPreferences pref ; private String MODULE_PATH ; public static XC_InitPackageResources . InitPackageResourcesParam ResParam ; @ NonNull public static XSharedPreferences getPref ( ) { if ( pref == null ) { pref = new XSharedPreferences ( BuildConfig . APPLICATION_ID , BuildConfig . APPLICATION_ID + \"<STR_LIT>\" ) ; pref . makeWorldReadable ( ) ; pref . reload ( ) ; } return pref ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public void handleLoadPackage ( XC_LoadPackage . LoadPackageParam lpparam ) throws Throwable { var packageName = lpparam . packageName ; var classLoader = lpparam . classLoader ; if ( packageName . equals ( BuildConfig . APPLICATION_ID ) ) { XposedHelpers . findAndHookMethod ( MainActivity . class . getName ( ) , lpparam . classLoader , \"<STR_LIT>\" , XC_MethodReplacement . returnConstant ( true ) ) ; XposedHelpers . findAndHookMethod ( PreferenceManager . class . getName ( ) , lpparam . classLoader , \"<STR_LIT>\" , XC_MethodReplacement . returnConstant ( ContextWrapper . MODE_WORLD_READABLE ) ) ; return ; } XposedBridge . log ( \"<STR_LIT>\" + lpparam . packageName ) ;", "output": "AntiUpdater . hookSession ( pref ) ; Patch . handleLoadPackage ( lpparam , pref ) ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; var sourceDir = lpparam . appInfo . sourceDir ; FeatureLoader . start ( classLoader , getPref ( ) , sourceDir ) ; disableSecureFlag ( ) ; } @ Override public void handleInitPackageResources ( XC_InitPackageResources . InitPackageResourcesParam resparam ) throws Throwable { var packageName = resparam . packageName ; if ( ! packageName . equals ( FeatureLoader . PACKAGE_WPP ) && ! packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) return ; XModuleResources modRes = XModuleResources . createInstance ( MODULE_PATH , resparam . res ) ; for ( var field : ResId . string . class . getFields ( ) ) { var field1 = R . string . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . array . class . getFields ( ) ) { var field1 = R . array . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } for ( var field : ResId . drawable . class . getFields ( ) ) { var field1 = R . drawable . class . getField ( field . getName ( ) ) ; field . set ( null , resparam . res . addResource ( modRes , field1 . getInt ( null ) ) ) ; } ResParam = resparam ; } @ Override public void initZygote ( StartupParam startupParam ) throws Throwable { MODULE_PATH = startupParam . modulePath ; } public void disableSecureFlag ( ) { XposedHelpers . findAndHookMethod ( Window . class , \"<STR_LIT>\" , int . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; } } ) ; XposedHelpers . findAndHookMethod ( Window . class , \"<STR_LIT>\" , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = ( int ) param . args [ <NUM_LIT> ] & ~ WindowManager . LayoutParams . FLAG_SECURE ; if ( ( int ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { param . setResult ( null ) ; } } } ) ; } }"}, {"input": "package com . appspa . update ; import android . app . Application ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . listener . OnInstallListener ; import com . appspa . update . listener . OnUpdateFailureListener ; import com . appspa . update . logs . ILogger ; import com . appspa . update . logs . UpdateLog ; import com . appspa . update . proxy . IFileEncryptor ; import com . appspa . update . proxy . IUpdateChecker ; import com . appspa . update . proxy . IUpdateDownloader ; import com . appspa . update . proxy . IUpdateHttpService ; import com . appspa . update . proxy . IUpdateParser ; import com . appspa . update . proxy . IUpdatePrompter ; import com . appspa . update . proxy . impl . DefaultFileEncryptor ; import com . appspa . update . proxy . impl . DefaultUpdatePrompter ; import com . appspa . update . utils . ApkUtils ; import com . appspa . update . listener . impl . DefaultInstallListener ; import com . appspa . update . listener . impl . DefaultUpdateFailureListener ; import com . appspa . update . proxy . impl . DefaultUpdateChecker ; import com . appspa . update . proxy . impl . DefaultUpdateDownloader ; import com . appspa . update . proxy . impl . DefaultUpdateParser ; import java . util . Map ; import java . util . TreeMap ; public class AppSpace { private Application mContext ; private static AppSpace sInstance ;", "output": "Map < String , Object > mParams ; boolean mIsGet ; boolean mIsWifiOnly ; boolean mIsAutoMode ; boolean mIsPatchMode ; String mApkCacheDir ; IUpdateHttpService mUpdateHttpService ; IUpdateChecker mUpdateChecker ; IUpdateParser mUpdateParser ; IUpdatePrompter mUpdatePrompter ; IUpdateDownloader mUpdateDownloader ; IFileEncryptor mFileEncryptor ; OnInstallListener mOnInstallListener ; OnUpdateFailureListener mOnUpdateFailureListener ; private AppSpace ( ) { mIsGet = false ; mIsWifiOnly = true ; mIsAutoMode = false ; mUpdateChecker = new DefaultUpdateChecker ( ) ; mUpdateParser = new DefaultUpdateParser ( ) ; mUpdateDownloader = new DefaultUpdateDownloader ( ) ; mUpdatePrompter = new DefaultUpdatePrompter ( ) ; mFileEncryptor = new DefaultFileEncryptor ( ) ; mOnInstallListener = new DefaultInstallListener ( ) ; mOnUpdateFailureListener = new DefaultUpdateFailureListener ( ) ; } public static AppSpace get ( ) { if ( sInstance == null ) { synchronized ( AppSpace . class ) { if ( sInstance == null ) { sInstance = new AppSpace ( ) ; } } } return sInstance ; } public void init ( Application application ) { mContext = application ; UpdateError . init ( mContext ) ; } private Application getApplication ( ) { testInitialize ( ) ; return mContext ; } private void testInitialize ( ) { if ( mContext == null ) { throw new ExceptionInInitializerError ( \"<STR_LIT>\" ) ; } } public static Context getContext ( ) { return get ( ) . getApplication ( ) ; } public static UpdateManager . Builder newBuild ( @ NonNull Context context ) { return new UpdateManager . Builder ( context ) ; } public static UpdateManager . Builder newBuild ( @ NonNull Context context , String updateUrl ) { return new UpdateManager . Builder ( context ) . updateUrl ( updateUrl ) ; } public AppSpace param ( @ NonNull String key , @ NonNull Object value ) { if ( mParams == null ) { mParams = new TreeMap < > ( ) ; } UpdateLog . d ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + value . toString ( ) ) ; mParams . put ( key , value ) ; return this ; } public AppSpace params ( @ NonNull Map < String , Object > params ) { logForParams ( params ) ; mParams = params ; return this ; } private void logForParams ( @ NonNull Map < String , Object > params ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { sb . append ( \"<STR_LIT>\" ) . append ( entry . getKey ( ) ) . append ( \"<STR_LIT>\" ) . append ( entry . getValue ( ) . toString ( ) ) . append ( \"<STR_LIT>\" ) ; } sb . append ( \"<STR_LIT>\" ) ; UpdateLog . d ( sb . toString ( ) ) ; } public AppSpace setIUpdateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { UpdateLog . d ( \"<STR_LIT>\" + updateHttpService . getClass ( ) . getCanonicalName ( ) ) ; mUpdateHttpService = updateHttpService ; return this ; } public AppSpace setIUpdateChecker ( @ NonNull IUpdateChecker updateChecker ) { mUpdateChecker = updateChecker ; return this ; } public AppSpace setIUpdateParser ( @ NonNull IUpdateParser updateParser ) { mUpdateParser = updateParser ; return this ; } public AppSpace setIUpdatePrompter ( IUpdatePrompter updatePrompter ) { mUpdatePrompter = updatePrompter ; return this ; } public AppSpace setIUpdateDownLoader ( @ NonNull IUpdateDownloader updateDownLoader ) { mUpdateDownloader = updateDownLoader ; return this ; } public AppSpace isGet ( boolean isGet ) { UpdateLog . d ( \"<STR_LIT>\" + isGet ) ; mIsGet = isGet ; return this ; } public AppSpace isWifiOnly ( boolean isWifiOnly ) { UpdateLog . d ( \"<STR_LIT>\" + isWifiOnly ) ; mIsWifiOnly = isWifiOnly ; return this ; } public AppSpace isAutoMode ( boolean isAutoMode ) { UpdateLog . d ( \"<STR_LIT>\" + isAutoMode ) ; mIsAutoMode = isAutoMode ; return this ; } public AppSpace isPatchMode ( boolean isPatchMode ) { UpdateLog . d ( \"<STR_LIT>\" + isPatchMode ) ; mIsPatchMode = isPatchMode ; return this ; } public AppSpace setApkCacheDir ( String apkCacheDir ) { UpdateLog . d ( \"<STR_LIT>\" + apkCacheDir ) ; mApkCacheDir = apkCacheDir ; return this ; } public AppSpace supportSilentInstall ( boolean supportSilentInstall ) { ApkUtils . setSupportSilentInstall ( supportSilentInstall ) ; return this ; } public AppSpace debug ( boolean isDebug ) { UpdateLog . debug ( isDebug ) ; return this ; } public AppSpace setILogger ( @ NonNull ILogger logger ) { UpdateLog . setLogger ( logger ) ; return this ; } public AppSpace setIFileEncryptor ( IFileEncryptor fileEncryptor ) { mFileEncryptor = fileEncryptor ; return this ; } public AppSpace setOnInstallListener ( OnInstallListener onInstallListener ) { mOnInstallListener = onInstallListener ; return this ; } public AppSpace setOnUpdateFailureListener ( @ NonNull OnUpdateFailureListener onUpdateFailureListener ) { mOnUpdateFailureListener = onUpdateFailureListener ; return this ; } }"}, {"input": "package in . hridayan . ashell . utils ; import android . content . Context ; import java . io . Serializable ; import in . hridayan . ashell . utils . Preferences ; public class CommandItems implements Serializable { private final String mTitle , mSummary , mExample ; private int mUseCounter ; private Context context ; private boolean isChecked , isPinned ; public CommandItems ( String title , String example , Context context ) { this . mTitle = title ; this . mSummary = summary ( title , context ) ; this . mExample = example ; this . context = context ; this . mUseCounter = Preferences . getUseCounter ( context , mTitle ) ; this . isPinned = Preferences . getPinned ( context , mTitle ) ; } public String getTitle ( ) { return mTitle ; } public String getSummary ( ) { return mSummary ; } public String getExample ( ) { return mExample ; } public int getUseCounter ( ) { return mUseCounter ; } public void setUseCounter ( int counter ) { this . mUseCounter = counter ; Preferences . setUseCounter ( context , mTitle , counter ) ; } public boolean isPinned ( ) { return isPinned ; } public void setPinned ( boolean pinned ) { this . isPinned = pinned ; Preferences . setPinned ( context , mTitle , pinned ) ; }", "output": "public boolean isChecked ( ) { return isChecked ; } public void setChecked ( boolean checked ) { isChecked = checked ; } private String summary ( String title , Context context ) { String trimmedTitle = title . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . trim ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int resourceId = context . getResources ( ) . getIdentifier ( trimmedTitle , \"<STR_LIT>\" , context . getPackageName ( ) ) ; return context . getResources ( ) . getString ( resourceId ) ; } }"}, {"input": "package com . simon . harmonichackernews ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . res . Configuration ; import android . content . res . Resources ; import android . os . Bundle ; import android . text . Editable ; import android . text . TextUtils ; import android . view . View ; import android . view . ViewGroup ; import android . widget . Button ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . ScrollView ; import android . widget . TextView ; import android . widget . Toast ; import androidx . activity . OnBackPressedCallback ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . appcompat . app . AlertDialog ; import androidx . appcompat . app . AppCompatActivity ; import androidx . appcompat . content . res . AppCompatResources ; import androidx . core . graphics . Insets ; import androidx . core . view . OnApplyWindowInsetsListener ; import androidx . core . view . ViewCompat ; import androidx . core . view . WindowCompat ; import androidx . core . view . WindowInsetsAnimationCompat ; import androidx . core . view . WindowInsetsCompat ; import androidx . swiperefreshlayout . widget . CircularProgressDrawable ; import com . google . android . material . button . MaterialButton ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . google . android . material . textfield . TextInputEditText ; import com . google . android . material . textfield . TextInputLayout ; import com . simon . harmonichackernews . network . UserActions ; import com . simon . harmonichackernews . utils . ThemeUtils ; import com . simon . harmonichackernews . utils . Utils ; import com . simon . harmonichackernews . utils . ViewUtils ; import org . sufficientlysecure . htmltextview . HtmlTextView ; import org . sufficientlysecure . htmltextview . OnClickATagListener ; import java . util . List ; import okhttp3 . Response ; public class ComposeActivity extends AppCompatActivity { public final static String EXTRA_ID = \"<STR_LIT>\" ; public final static String EXTRA_PARENT_TEXT = \"<STR_LIT>\" ; public final static String EXTRA_USER = \"<STR_LIT>\" ; public final static String EXTRA_TYPE = \"<STR_LIT>\" ; public final static int TYPE_TOP_COMMENT = <NUM_LIT> ; public final static int TYPE_COMMENT_REPLY = <NUM_LIT> ; public final static int TYPE_POST = <NUM_LIT> ; private EditText editText ; private TextInputEditText editTextTitle ; private TextInputEditText editTextUrl ; private TextInputEditText editTextText ; private TextInputLayout titleContainer ; private TextInputLayout urlContainer ; private TextInputLayout textContainer ; private Button submitButton ; private HtmlTextView replyingTextView ; private ScrollView replyingScrollView ; private TextView topCommentTextView ; private int id ; private String parentText ; private String user ; private int type ; private OnBackPressedCallback backPressedCallback ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ThemeUtils . setupTheme ( this , false , false ) ; setContentView ( R . layout . activity_compose ) ; editText = findViewById ( R . id . compose_edittext ) ; editTextTitle = findViewById ( R . id . compose_edittext_title ) ; editTextUrl = findViewById ( R . id . compose_edittext_url ) ; editTextText = findViewById ( R . id . compose_edittext_text ) ; titleContainer = findViewById ( R . id . compose_title_container ) ; urlContainer = findViewById ( R . id . compose_url_container ) ; textContainer = findViewById ( R . id . compose_text_container ) ; submitButton = findViewById ( R . id . compose_submit ) ; replyingTextView = findViewById ( R . id . compose_replying_text ) ; replyingScrollView = findViewById ( R . id . compose_replying_scrollview ) ; topCommentTextView = findViewById ( R . id . compose_top_comment ) ; TextView postInfo = findViewById ( R . id . compose_submit_info ) ; LinearLayout bottomContainer = findViewById ( R . id . compose_bottom_container ) ; LinearLayout container = findViewById ( R . id . compose_container ) ; Intent intent = getIntent ( ) ; id = intent . getIntExtra ( EXTRA_ID , - <NUM_LIT> ) ; parentText = intent . getStringExtra ( EXTRA_PARENT_TEXT ) ; user = intent . getStringExtra ( EXTRA_USER ) ; type = intent . getIntExtra ( EXTRA_TYPE , TYPE_POST ) ; if ( type != TYPE_POST && id == - <NUM_LIT> ) { Toast . makeText ( this , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } switch ( type ) { case TYPE_TOP_COMMENT : replyingScrollView . setVisibility ( View . GONE ) ; topCommentTextView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setText ( \"<STR_LIT>\" + parentText ) ; break ; case TYPE_COMMENT_REPLY : replyingScrollView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setVisibility ( View . GONE ) ; replyingTextView . setHtml ( \"<STR_LIT>\" + user + \"<STR_LIT>\" + parentText ) ; replyingTextView . setOnClickATagListener ( new OnClickATagListener ( ) { @ Override public boolean onClick ( View widget , String spannedText , @ Nullable String href ) { Utils . openLinkMaybeHN ( widget . getContext ( ) , href ) ; return true ; } } ) ; break ; case TYPE_POST : replyingScrollView . setVisibility ( View . GONE ) ; topCommentTextView . setVisibility ( View . VISIBLE ) ; topCommentTextView . setText ( \"<STR_LIT>\" ) ; titleContainer . setVisibility ( View . VISIBLE ) ; urlContainer . setVisibility ( View . VISIBLE ) ; textContainer . setVisibility ( View . VISIBLE ) ; postInfo . setVisibility ( View . VISIBLE ) ; editText . setVisibility ( View . GONE ) ; break ; } ViewUtils . SimpleTextWatcher updateStatusTextWatcher = new ViewUtils . SimpleTextWatcher ( ) { @ Override public void afterTextChanged ( Editable editable ) { updateEnabledStatuses ( ) ; } } ; editText . addTextChangedListener ( updateStatusTextWatcher ) ; editTextTitle . addTextChangedListener ( updateStatusTextWatcher ) ; editTextUrl . addTextChangedListener ( updateStatusTextWatcher ) ; editTextText . addTextChangedListener ( updateStatusTextWatcher ) ; WindowCompat . setDecorFitsSystemWindows ( getWindow ( ) , false ) ; ViewCompat . setOnApplyWindowInsetsListener ( container , new OnApplyWindowInsetsListener ( ) { @ NonNull @ Override public WindowInsetsCompat onApplyWindowInsets ( @ NonNull View v , @ NonNull WindowInsetsCompat windowInsets ) { Insets insets = windowInsets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) | WindowInsetsCompat . Type . ime ( ) ) ; int sideMargin = getResources ( ) . getDimensionPixelSize ( R . dimen . single_view_side_margin ) ; bottomContainer . setPadding ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , insets . bottom ) ; container . setPadding ( insets . left + sideMargin , insets . top , insets . right + sideMargin , <NUM_LIT> ) ; return windowInsets ; } } ) ; ViewUtils . requestApplyInsetsWhenAttached ( container ) ; ViewCompat . setWindowInsetsAnimationCallback ( bottomContainer , new WindowInsetsAnimationCompat . Callback ( WindowInsetsAnimationCompat . Callback . DISPATCH_MODE_STOP ) { @ NonNull @ Override public WindowInsetsCompat onProgress ( @ NonNull WindowInsetsCompat insets , @ NonNull List < WindowInsetsAnimationCompat > runningAnimations ) { WindowInsetsAnimationCompat imeAnimation = null ; for ( WindowInsetsAnimationCompat animation : runningAnimations ) { if ( ( animation . getTypeMask ( ) & WindowInsetsCompat . Type . ime ( ) ) != <NUM_LIT> ) { imeAnimation = animation ; break ; } } if ( imeAnimation != null ) { bottomContainer . setTranslationY ( - ( startBottom - endBottom ) * ( <NUM_LIT> - imeAnimation . getInterpolatedFraction ( ) ) ) ; } return insets ; } float startBottom ; @ Override public void onPrepare ( @ NonNull WindowInsetsAnimationCompat animation ) { startBottom = bottomContainer . getPaddingBottom ( ) ; } float endBottom ; @ NonNull @ Override public WindowInsetsAnimationCompat . BoundsCompat onStart ( @ NonNull WindowInsetsAnimationCompat animation , @ NonNull WindowInsetsAnimationCompat . BoundsCompat bounds ) { endBottom = bottomContainer . getPaddingBottom ( ) ; return bounds ; } } ) ; backPressedCallback = new OnBackPressedCallback ( true ) { @ Override public void handleOnBackPressed ( ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( editText . getContext ( ) ) . setMessage ( type == TYPE_POST ? \"<STR_LIT>\" : \"<STR_LIT>\" ) . setPositiveButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int whichButton ) { dialog . cancel ( ) ; finish ( ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , null ) . create ( ) ; dialog . show ( ) ; } } ; getOnBackPressedDispatcher ( ) . addCallback ( this , backPressedCallback ) ; updateEnabledStatuses ( ) ; } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; ViewGroup . LayoutParams layout = replyingScrollView . getLayoutParams ( ) ; int dp160 = Utils . pxFromDpInt ( getResources ( ) , <NUM_LIT> ) ; int screenHeightThird = Resources . getSystem ( ) . getDisplayMetrics ( ) . heightPixels / <NUM_LIT> ; layout . height = Math . min ( dp160 , screenHeightThird ) ; replyingScrollView . setLayoutParams ( layout ) ; } public void infoClick ( View view ) { AlertDialog dialog = new MaterialAlertDialogBuilder ( this ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( \"<STR_LIT>\" ) . setNegativeButton ( \"<STR_LIT>\" , null ) . create ( ) ; dialog . show ( ) ; } private void updateEnabledStatuses ( ) { boolean enable ; if ( type == TYPE_POST ) { boolean hasTitle = ! TextUtils . isEmpty ( editTextTitle . getText ( ) . toString ( ) ) ; boolean hasUrl = ! TextUtils . isEmpty ( editTextUrl . getText ( ) . toString ( ) ) ; boolean hasText = ! TextUtils . isEmpty ( editTextText . getText ( ) . toString ( ) ) ; enable = hasTitle && ( hasText || hasUrl ) ; } else {", "output": "enable = ! TextUtils . isEmpty ( editText . getText ( ) . toString ( ) ) ; } backPressedCallback . setEnabled ( enable ) ; submitButton . setEnabled ( enable ) ; } public void submit ( View view ) { MaterialButton submitButton = ( MaterialButton ) view ; CircularProgressDrawable c = new CircularProgressDrawable ( this ) ; submitButton . setIcon ( c ) ; c . start ( ) ; if ( type == TYPE_POST ) { UserActions . submit ( editTextTitle . getText ( ) . toString ( ) , editText . getText ( ) . toString ( ) , editTextUrl . getText ( ) . toString ( ) , view . getContext ( ) , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; Toast . makeText ( view . getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } @ Override public void onFailure ( String summary , String response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; UserActions . showFailureDetailDialog ( view . getContext ( ) , summary , response ) ; Toast . makeText ( view . getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } else { UserActions . comment ( String . valueOf ( id ) , editText . getText ( ) . toString ( ) , getApplicationContext ( ) , new UserActions . ActionCallback ( ) { @ Override public void onSuccess ( Response response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; Toast . makeText ( view . getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; } @ Override public void onFailure ( String summary , String response ) { submitButton . setIcon ( AppCompatResources . getDrawable ( getApplicationContext ( ) , R . drawable . ic_action_send ) ) ; UserActions . showFailureDetailDialog ( view . getContext ( ) , summary , response ) ; Toast . makeText ( view . getContext ( ) , \"<STR_LIT>\" , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } } }"}, {"input": "package com . appspa . update . utils ; import java . io . File ; import java . io . InputStream ; import java . security . MessageDigest ; public final class Md5Utils { private Md5Utils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static String getFileMD5 ( File file ) { if ( ! FileUtils . isFileExists ( file ) ) { return \"<STR_LIT>\" ; } InputStream fis = null ; try { MessageDigest digest = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; fis = FileUtils . getFileInputStream ( file ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len ; while ( ( len = fis . read ( buffer ) ) != - <NUM_LIT> ) { digest . update ( buffer , <NUM_LIT> , len ) ; } return bytes2Hex ( digest . digest ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally {", "output": "FileUtils . closeIOQuietly ( fis ) ; } return \"<STR_LIT>\" ; } private static String bytes2Hex ( byte [ ] src ) { char [ ] res = new char [ src . length << <NUM_LIT> ] ; final char hexDigits [ ] = { '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' } ; for ( int i = <NUM_LIT> , j = <NUM_LIT> ; i < src . length ; i ++ ) { res [ j ++ ] = hexDigits [ src [ i ] > > > <NUM_LIT> & <NUM_LIT> ] ; res [ j ++ ] = hexDigits [ src [ i ] & <NUM_LIT> ] ; } return new String ( res ) ; } }"}, {"input": "package icu . freedomIntrovert . async ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class BackstageTaskByMVP < T extends BackstageTaskByMVP . BaseEventHandler > implements Runnable { private final T uiHandler ; public BackstageTaskByMVP ( T uiHandler ) { this . uiHandler = uiHandler ; } protected abstract void onStart ( T eventHandlerProxy ) throws Throwable ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public void run ( ) { T proxyInstance = ( T ) Proxy . newProxyInstance ( uiHandler . getClass ( ) . getClassLoader ( ) , uiHandler . getClass ( ) . getInterfaces ( ) , new EvProxyHandler ( uiHandler ) ) ; try { onStart ( proxyInstance ) ; TaskManger . postOnUiThread ( uiHandler :: onComplete ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; TaskManger . postOnUiThread ( ( ) -> uiHandler . onError ( e ) ) ; } } public void execute ( ) { TaskManger . start ( this ) ; } public static class EvProxyHandler implements InvocationHandler { Object evHandler ; public EvProxyHandler ( Object evHandler ) { this . evHandler = evHandler ; } @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) == Object . class ) { return method . invoke ( proxy , args ) ; } TaskManger . postOnUiThread ( ( ) -> { try { method . invoke ( evHandler , args ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } ) ; return null ; } } public interface BaseEventHandler {", "output": "default void onError ( Throwable th ) { throw new RuntimeException ( th ) ; } default void onComplete ( ) { } } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . core ; import java . io . File ; public class Utils { public static String legalizationPath ( String path ) { if ( File . separator . equals ( \"<STR_LIT>\" ) ) { return path . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } return path ; } public static String replaceBackslashToSlash ( String path ) { return path . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String replaceBackslashToUnderline ( String path ) { return path . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String replaceColon ( String path ) { return path . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; }", "output": "}"}, {"input": "package com . reactnative . nestedscroll ; import android . content . Context ; import android . graphics . Canvas ; import android . graphics . Rect ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . uimanager . MeasureSpecAssertions ; import com . facebook . react . uimanager . ReactOverflowView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . NativeGestureUtil ; public class NestedScrollView extends androidx . core . widget . NestedScrollView implements ReactOverflowView { private final NestedScrollViewLocalData mNestedScrollViewLocalData = new NestedScrollViewLocalData ( ) ; private String mOverflow = \"<STR_LIT>\" ; private final Rect mRect ; private final NestedScrollFlingHelper mFlingHelper ; public NestedScrollView ( @ NonNull Context context ) { super ( context ) ; mRect = new Rect ( ) ; mFlingHelper = new NestedScrollFlingHelper ( this ) ; } public void setOverflow ( String overflow ) { mOverflow = overflow ; invalidate ( ) ; } @ Nullable @ Override public String getOverflow ( ) { return mOverflow ; } @ Override public void onNestedPreScroll ( @ NonNull View target , int dx , int dy , @ NonNull int [ ] consumed , int type ) { super . onNestedPreScroll ( target , dx , dy , consumed , type ) ; int dyUnconsumed = dy - consumed [ <NUM_LIT> ] ; if ( dyUnconsumed > <NUM_LIT> ) { final int oldScrollY = getScrollY ( ) ; scrollBy ( <NUM_LIT> , dyUnconsumed ) ; final int myConsumed = getScrollY ( ) - oldScrollY ; consumed [ <NUM_LIT> ] += myConsumed ; } } @ Override public boolean onNestedPreFling ( View target , float velocityX , float velocityY ) { boolean consumed = super . onNestedPreFling ( target , velocityX , velocityY ) ; if ( ! consumed ) { consumed = mFlingHelper . onNestedPreFling ( target , velocityY ) ; } return consumed ; } @ Override public void computeScroll ( ) { super . computeScroll ( ) ; mFlingHelper . computeScroll ( ) ; } @ Override public boolean dispatchTouchEvent ( MotionEvent ev ) { mFlingHelper . dispatchTouchEvent ( ev ) ; return super . dispatchTouchEvent ( ev ) ; } @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( super . onInterceptTouchEvent ( ev ) ) { NativeGestureUtil . notifyNativeGestureStarted ( this , ev ) ; return true ; } return false ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { MeasureSpecAssertions . assertExplicitMeasureSpec ( widthMeasureSpec , heightMeasureSpec ) ; this . setMeasuredDimension ( MeasureSpec . getSize ( widthMeasureSpec ) , MeasureSpec . getSize ( heightMeasureSpec ) ) ; } void notifyStickyHeightChanged ( ) { if ( isLaidOut ( ) && ! isInLayout ( ) ) { fitStickyHeightIfNeeded ( ) ; } } private void fitStickyHeightIfNeeded ( ) { Context context = getContext ( ) ; if ( context instanceof ReactContext ) { UIManagerModule uiManagerModule = ( ( ReactContext ) context ) . getNativeModule ( UIManagerModule . class ) ; if ( uiManagerModule == null ) { return ; } ViewGroup content = ( ViewGroup ) getChildAt ( <NUM_LIT> ) ; if ( content == null ) { return ; } int headerFixedHeight = <NUM_LIT> ; float headerHeight = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < content . getChildCount ( ) ; i ++ ) { View child = content . getChildAt ( i ) ; if ( child instanceof NestedScrollViewHeader ) { headerFixedHeight = ( ( NestedScrollViewHeader ) child ) . getStickyHeight ( ) ; headerHeight = child . getHeight ( ) ; } } int nestedScrollViewH = getHeight ( ) ; float contentHeight = nestedScrollViewH - headerFixedHeight ; if ( contentHeight != mNestedScrollViewLocalData . contentNodeH || headerHeight != mNestedScrollViewLocalData . headerNodeH ) { mNestedScrollViewLocalData . contentNodeH = contentHeight ; mNestedScrollViewLocalData . headerNodeH = headerHeight ; uiManagerModule . setViewLocalData ( getId ( ) , mNestedScrollViewLocalData ) ; } int maxScrollRange = ( int ) ( headerHeight - headerFixedHeight ) ; if ( getScrollY ( ) > maxScrollRange ) {", "output": "scrollTo ( <NUM_LIT> , maxScrollRange ) ; } } } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { super . onLayout ( changed , l , t , r , b ) ; fitStickyHeightIfNeeded ( ) ; } @ Override public void draw ( Canvas canvas ) { getDrawingRect ( mRect ) ; if ( ! \"<STR_LIT>\" . equals ( mOverflow ) ) { canvas . clipRect ( mRect ) ; } super . draw ( canvas ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_AND_DISAPPEAR ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_APPEAR_PRE_AND_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_DISAPPEARED ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_POST ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE ; import static androidx . fluidrecyclerview . widget . ViewInfoStore . InfoRecord . FLAG_PRE_AND_POST ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . VisibleForTesting ; import androidx . collection . LongSparseArray ; import androidx . collection . SimpleArrayMap ; import androidx . core . util . Pools ; class ViewInfoStore { private static final boolean DEBUG = false ; @ VisibleForTesting final SimpleArrayMap < RecyclerView . ViewHolder , InfoRecord > mLayoutHolderMap = new SimpleArrayMap < > ( ) ; @ VisibleForTesting final LongSparseArray < RecyclerView . ViewHolder > mOldChangedHolders = new LongSparseArray < > ( ) ; void clear ( ) { mLayoutHolderMap . clear ( ) ; mOldChangedHolders . clear ( ) ; } void addToPreLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . preInfo = info ; record . flags |= FLAG_PRE ; } boolean isDisappearing ( RecyclerView . ViewHolder holder ) { final InfoRecord record = mLayoutHolderMap . get ( holder ) ; return record != null && ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPreLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_PRE ) ; } @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo popFromPostLayout ( RecyclerView . ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG_POST ) ; } private RecyclerView . ItemAnimator . ItemHolderInfo popFromLayoutStep ( RecyclerView . ViewHolder vh , int flag ) { int index = mLayoutHolderMap . indexOfKey ( vh ) ; if ( index < <NUM_LIT> ) { return null ; } final InfoRecord record = mLayoutHolderMap . valueAt ( index ) ; if ( record != null && ( record . flags & flag ) != <NUM_LIT> ) { record . flags &= ~ flag ; final RecyclerView . ItemAnimator . ItemHolderInfo info ; if ( flag == FLAG_PRE ) { info = record . preInfo ; } else if ( flag == FLAG_POST ) { info = record . postInfo ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( ( record . flags & ( FLAG_PRE | FLAG_POST ) ) == <NUM_LIT> ) { mLayoutHolderMap . removeAt ( index ) ; InfoRecord . recycle ( record ) ; }", "output": "return info ; } return null ; } void addToOldChangeHolders ( long key , RecyclerView . ViewHolder holder ) { mOldChangedHolders . put ( key , holder ) ; } void addToAppearedInPreLayoutHolders ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_APPEAR ; record . preInfo = info ; } boolean isInPreLayout ( RecyclerView . ViewHolder viewHolder ) { final InfoRecord record = mLayoutHolderMap . get ( viewHolder ) ; return record != null && ( record . flags & FLAG_PRE ) != <NUM_LIT> ; } RecyclerView . ViewHolder getFromOldChangeHolders ( long key ) { return mOldChangedHolders . get ( key ) ; } void addToPostLayout ( RecyclerView . ViewHolder holder , RecyclerView . ItemAnimator . ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags |= FLAG_POST ; } void addToDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags |= FLAG_DISAPPEARED ; } void removeFromDisappearedInLayout ( RecyclerView . ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record == null ) { return ; } record . flags &= ~ FLAG_DISAPPEARED ; } void process ( ProcessCallback callback ) { for ( int index = mLayoutHolderMap . size ( ) - <NUM_LIT> ; index >= <NUM_LIT> ; index -- ) { final RecyclerView . ViewHolder viewHolder = mLayoutHolderMap . keyAt ( index ) ; final InfoRecord record = mLayoutHolderMap . removeAt ( index ) ; if ( ( record . flags & FLAG_APPEAR_AND_DISAPPEAR ) == FLAG_APPEAR_AND_DISAPPEAR ) { callback . unused ( viewHolder ) ; } else if ( ( record . flags & FLAG_DISAPPEARED ) != <NUM_LIT> ) { if ( record . preInfo == null ) { callback . unused ( viewHolder ) ; } else { callback . processDisappeared ( viewHolder , record . preInfo , record . postInfo ) ; } } else if ( ( record . flags & FLAG_APPEAR_PRE_AND_POST ) == FLAG_APPEAR_PRE_AND_POST ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE_AND_POST ) == FLAG_PRE_AND_POST ) { callback . processPersistent ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_PRE ) != <NUM_LIT> ) { callback . processDisappeared ( viewHolder , record . preInfo , null ) ; } else if ( ( record . flags & FLAG_POST ) != <NUM_LIT> ) { callback . processAppeared ( viewHolder , record . preInfo , record . postInfo ) ; } else if ( ( record . flags & FLAG_APPEAR ) != <NUM_LIT> ) { } else if ( DEBUG ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } InfoRecord . recycle ( record ) ; } } void removeViewHolder ( RecyclerView . ViewHolder holder ) { for ( int i = mOldChangedHolders . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( holder == mOldChangedHolders . valueAt ( i ) ) { mOldChangedHolders . removeAt ( i ) ; break ; } } final InfoRecord info = mLayoutHolderMap . remove ( holder ) ; if ( info != null ) { InfoRecord . recycle ( info ) ; } } void onDetach ( ) { InfoRecord . drainCache ( ) ; } public void onViewDetached ( RecyclerView . ViewHolder viewHolder ) { removeFromDisappearedInLayout ( viewHolder ) ; } interface ProcessCallback { void processDisappeared ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processAppeared ( RecyclerView . ViewHolder viewHolder , @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo , RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void processPersistent ( RecyclerView . ViewHolder viewHolder , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo preInfo , @ NonNull RecyclerView . ItemAnimator . ItemHolderInfo postInfo ) ; void unused ( RecyclerView . ViewHolder holder ) ; } static class InfoRecord { static final int FLAG_DISAPPEARED = <NUM_LIT> ; static final int FLAG_APPEAR = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_PRE = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_POST = <NUM_LIT> << <NUM_LIT> ; static final int FLAG_APPEAR_AND_DISAPPEAR = FLAG_APPEAR | FLAG_DISAPPEARED ; static final int FLAG_PRE_AND_POST = FLAG_PRE | FLAG_POST ; static final int FLAG_APPEAR_PRE_AND_POST = FLAG_APPEAR | FLAG_PRE | FLAG_POST ; int flags ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo preInfo ; @ Nullable RecyclerView . ItemAnimator . ItemHolderInfo postInfo ; static Pools . Pool < InfoRecord > sPool = new Pools . SimplePool < > ( <NUM_LIT> ) ; private InfoRecord ( ) { } static InfoRecord obtain ( ) { InfoRecord record = sPool . acquire ( ) ; return record == null ? new InfoRecord ( ) : record ; } static void recycle ( InfoRecord record ) { record . flags = <NUM_LIT> ; record . preInfo = null ; record . postInfo = null ; sPool . release ( record ) ; } static void drainCache ( ) { while ( sPool . acquire ( ) != null ) ; } } }"}, {"input": "package com . skythinker . gptassistant ; import org . junit . Test ; import static org . junit . Assert . * ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) {", "output": "assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ; } }"}, {"input": "package com . wmods . wppenhacer . preference ; import android . Manifest ; import android . app . Activity ; import android . content . Context ; import android . content . Intent ; import android . content . pm . PackageManager ; import android . util . AttributeSet ; import androidx . annotation . NonNull ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . ContactPickerActivity ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . stream . Collectors ; public class ContactPickerPreference extends Preference implements Preference . OnPreferenceClickListener { public static final int REQUEST_CONTACT_PICKER = <NUM_LIT> ; public static final int PERMISSIONS_REQUEST_READ_CONTACTS = <NUM_LIT> ; private CharSequence summaryOff ; private CharSequence summaryOn ; private ArrayList < String > mContacts ; public ContactPickerPreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( context , attrs ) ; } public ContactPickerPreference ( Context context , AttributeSet attrs , int defStyleAttr , int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ;", "output": "init ( context , attrs ) ; } @ Override public boolean onPreferenceClick ( @ NonNull Preference preference ) { if ( ContextCompat . checkSelfPermission ( getContext ( ) , Manifest . permission . READ_CONTACTS ) != PackageManager . PERMISSION_GRANTED ) { ( ( Activity ) getContext ( ) ) . requestPermissions ( new String [ ] { Manifest . permission . READ_CONTACTS } , PERMISSIONS_REQUEST_READ_CONTACTS ) ; } else { startContactPickerActivity ( ) ; } return true ; } private void init ( Context context , AttributeSet attrs ) { setOnPreferenceClickListener ( this ) ; var typedArray = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . ContactPickerPreference , <NUM_LIT> , <NUM_LIT> ) ; summaryOff = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOff ) ; summaryOn = typedArray . getText ( R . styleable . ContactPickerPreference_summaryOn ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; String namesString = prefs . getString ( getKey ( ) , \"<STR_LIT>\" ) ; if ( namesString . length ( ) > <NUM_LIT> ) { mContacts = Arrays . stream ( namesString . substring ( <NUM_LIT> , namesString . length ( ) - <NUM_LIT> ) . split ( \"<STR_LIT>\" ) ) . map ( item -> item . trim ( ) ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; } if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } public void startContactPickerActivity ( ) { Context context = getContext ( ) ; Intent intent = new Intent ( context , ContactPickerActivity . class ) ; if ( mContacts != null ) { intent . putStringArrayListExtra ( \"<STR_LIT>\" , mContacts ) ; } intent . putExtra ( \"<STR_LIT>\" , getKey ( ) ) ; ( ( Activity ) getContext ( ) ) . startActivityForResult ( intent , REQUEST_CONTACT_PICKER ) ; } public void handleActivityResult ( int requestCode , int resultCode , Intent data ) { if ( requestCode == REQUEST_CONTACT_PICKER && resultCode == Activity . RESULT_OK ) { mContacts = data . getStringArrayListExtra ( \"<STR_LIT>\" ) ; getSharedPreferences ( ) . edit ( ) . putString ( getKey ( ) , mContacts . toString ( ) ) . apply ( ) ; if ( mContacts != null && ! mContacts . isEmpty ( ) ) { setSummary ( String . format ( String . valueOf ( summaryOn ) , mContacts . size ( ) ) ) ; } else { setSummary ( String . valueOf ( summaryOff ) ) ; } } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . async . EventHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . Comment ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . db . StatisticsDBOpenHelper ; public abstract class CommentOperateTask < T extends EventHandler > extends BackstageTask < T > { protected final CommentManipulator commentManipulator ; protected final Comment comment ; protected final Config config ; protected final StatisticsDBOpenHelper statisticsDB ; public CommentOperateTask ( T handle , CommentManipulator commentManipulator , Config config , StatisticsDBOpenHelper statisticsDB , Comment comment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . comment = comment ; this . config = config ; this . statisticsDB = statisticsDB ; } public void insertHistoryComment ( HistoryComment historyComment ) { if ( config . getRecordeHistoryIsEnable ( ) ) {", "output": "statisticsDB . insertHistoryComment ( historyComment ) ; } } }"}, {"input": "package org . woheller69 . weather . preferences ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Handler ; import android . os . Looper ; import android . widget . Toast ; import androidx . preference . PreferenceManager ; import org . woheller69 . weather . BuildConfig ; import org . woheller69 . weather . R ; public class AppPreferencesManager { SharedPreferences preferences ; public AppPreferencesManager ( SharedPreferences preferences ) { this . preferences = preferences ; } public boolean isFirstTimeLaunch ( Context context ) { boolean result = preferences . getBoolean ( \"<STR_LIT>\" , true ) ; SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = sp . edit ( ) ; editor . putBoolean ( \"<STR_LIT>\" , false ) ; editor . apply ( ) ; return result ; } public float convertTemperatureFromCelsius ( float temperature ) { int prefValue = Integer . parseInt ( preferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( prefValue == <NUM_LIT> ) { return temperature ; } else { return ( ( ( temperature * <NUM_LIT> ) / <NUM_LIT> ) + <NUM_LIT> ) ; } } public float convertPrecipitationFromMM ( float precipitation ) { int prefValue = Integer . parseInt ( preferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( prefValue == <NUM_LIT> ) { return precipitation ; } else { return ( float ) ( precipitation / <NUM_LIT> ) ; } } public String getTemperatureUnit ( ) { int prefValue = Integer . parseInt ( preferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( prefValue == <NUM_LIT> ) { return \"<STR_LIT>\" ; } else { return \"<STR_LIT>\" ; } } public String getPrecipitationUnit ( Context context ) { int prefValue = Integer . parseInt ( preferences . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( prefValue == <NUM_LIT> ) { return context . getString ( R . string . units_mm ) ; } else { return context . getString ( R . string . units_in ) ; } } public boolean showStarDialog ( Context context ) { int versionCode = preferences . getInt ( \"<STR_LIT>\" , BuildConfig . VERSION_CODE ) ; boolean askForStar = preferences . getBoolean ( \"<STR_LIT>\" , true ) ; if ( ! isFirstTimeLaunch ( context ) && BuildConfig . VERSION_CODE > versionCode && askForStar ) { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putInt ( \"<STR_LIT>\" , BuildConfig . VERSION_CODE ) ; editor . apply ( ) ; return true ; } else { SharedPreferences . Editor editor = preferences . edit ( ) ; editor . putInt ( \"<STR_LIT>\" , BuildConfig . VERSION_CODE ) ; editor . apply ( ) ; return false ; } } public void setAskForStar ( boolean askForStar ) { SharedPreferences . Editor editor = preferences . edit ( ) ;", "output": "editor . putBoolean ( \"<STR_LIT>\" , askForStar ) ; editor . apply ( ) ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection ; import android . net . Uri ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . mlkit . vision . common . InputImage ; import com . google . mlkit . vision . facemesh . FaceMeshDetector ; import com . google . mlkit . vision . facemesh . FaceMeshDetectorOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageOptions ; import io . capawesome . capacitorjs . plugins . mlkit . facemeshdetection . classes . ProcessImageResult ; public class FaceMeshDetection { @ NonNull private final FaceMeshDetectionPlugin plugin ; public FaceMeshDetection ( @ NonNull FaceMeshDetectionPlugin plugin ) { this . plugin = plugin ; } @ Nullable public InputImage createInputImageFromFilePath ( @ NonNull String path ) { try { return InputImage . fromFilePath ( this . plugin . getContext ( ) , Uri . parse ( path ) ) ; } catch ( Exception exception ) { return null ; } } public void processImage ( ProcessImageOptions options , ProcessImageResultCallback callback ) { InputImage inputImage = options . getInputImage ( ) ;", "output": "int useCase = options . getUseCase ( ) ; FaceMeshDetectorOptions . Builder builder = new FaceMeshDetectorOptions . Builder ( ) ; builder . setUseCase ( useCase ) ; builder . build ( ) ; FaceMeshDetectorOptions faceMeshDetectorOptions = builder . build ( ) ; final FaceMeshDetector faceMeshDetector = com . google . mlkit . vision . facemesh . FaceMeshDetection . getClient ( faceMeshDetectorOptions ) ; plugin . getActivity ( ) . runOnUiThread ( ( ) -> { faceMeshDetector . process ( inputImage ) . addOnSuccessListener ( faceMeshs -> { faceMeshDetector . close ( ) ; ProcessImageResult result = new ProcessImageResult ( faceMeshs ) ; callback . success ( result ) ; } ) . addOnCanceledListener ( ( ) -> { faceMeshDetector . close ( ) ; callback . cancel ( ) ; } ) . addOnFailureListener ( exception -> { faceMeshDetector . close ( ) ; callback . error ( exception ) ; } ) ; } ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import top . weixiansen574 . hybridfilexfer . core . FileTransferClient ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { if ( executeAdbForwardCommand ( <NUM_LIT> , args ) ) { System . out . println ( \"<STR_LIT>\" ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; return ; } if ( executeAdbForwardCommand ( <NUM_LIT> , args ) ) { System . out . println ( \"<STR_LIT>\" ) ; } else { System . out . println ( \"<STR_LIT>\" ) ;", "output": "} System . out . println ( \"<STR_LIT>\" ) ; new FileTransferClient ( ) . startUp ( ) ; } public static boolean executeAdbForwardCommand ( int port , String [ ] args ) { try { String jarDirectory = System . getProperty ( \"<STR_LIT>\" ) ; StringBuilder adbCommand = new StringBuilder ( ) ; adbCommand . append ( \"<STR_LIT>\" ) ; for ( String arg : args ) { adbCommand . append ( \"<STR_LIT>\" ) . append ( arg ) ; } adbCommand . append ( \"<STR_LIT>\" ) ; adbCommand . append ( port ) ; adbCommand . append ( \"<STR_LIT>\" ) ; adbCommand . append ( port ) ; String adbForwardCommand = adbCommand . toString ( ) ; Process process = Runtime . getRuntime ( ) . exec ( adbForwardCommand , null , new java . io . File ( jarDirectory ) ) ; BufferedReader errorReader = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; String l ; while ( ( l = errorReader . readLine ( ) ) != null ) { System . err . println ( l ) ; } BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { System . out . println ( \"<STR_LIT>\" + line ) ; } int exitCode = process . waitFor ( ) ; return exitCode == <NUM_LIT> ; } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; return false ; } } }"}, {"input": "package com . appspa . update . widget ; import android . Manifest ; import android . app . Dialog ; import android . content . pm . PackageManager ; import android . content . res . Configuration ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Build ; import android . os . Bundle ; import android . util . DisplayMetrics ; import android . view . Gravity ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . view . Window ; import android . view . WindowManager ; import android . widget . Button ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . ColorInt ; import androidx . annotation . DrawableRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . app . ActivityCompat ; import androidx . fragment . app . DialogFragment ; import androidx . fragment . app . FragmentManager ; import com . appspa . update . R ; import com . appspa . update . entity . PromptEntity ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . entity . UpdateError ; import com . appspa . update . _AppSpace ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . utils . ColorUtils ; import com . appspa . update . utils . DialogUtils ; import com . appspa . update . utils . DrawableUtils ; import com . appspa . update . utils . UpdateUtils ; import java . io . File ; public class UpdateDialogFragment extends DialogFragment implements View . OnClickListener , IDownloadEventHandler { public final static String KEY_UPDATE_ENTITY = \"<STR_LIT>\" ; public final static String KEY_UPDATE_PROMPT_ENTITY = \"<STR_LIT>\" ; public final static int REQUEST_CODE_REQUEST_PERMISSIONS = <NUM_LIT> ; private ImageView mIvTop ; private TextView mTvTitle ; private TextView mTvUpdateInfo ; private Button mBtnUpdate ; private Button mBtnBackgroundUpdate ; private TextView mTvIgnore ; private NumberProgressBar mNumberProgressBar ; private LinearLayout mLlClose ; private ImageView mIvClose ; private UpdateEntity mUpdateEntity ; private static IPrompterProxy sIPrompterProxy ; private PromptEntity mPromptEntity ; private int mCurrentOrientation ; public static void show ( @ NonNull FragmentManager fragmentManager , @ NonNull UpdateEntity updateEntity , @ NonNull IPrompterProxy prompterProxy , @ NonNull PromptEntity promptEntity ) { UpdateDialogFragment fragment = new UpdateDialogFragment ( ) ; Bundle args = new Bundle ( ) ; args . putParcelable ( KEY_UPDATE_ENTITY , updateEntity ) ; args . putParcelable ( KEY_UPDATE_PROMPT_ENTITY , promptEntity ) ; fragment . setArguments ( args ) ; setIPrompterProxy ( prompterProxy ) ; fragment . show ( fragmentManager ) ; } @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; _AppSpace . setIsPrompterShow ( getUrl ( ) , true ) ; setStyle ( DialogFragment . STYLE_NO_TITLE , R . style . XUpdate_Fragment_Dialog ) ; mCurrentOrientation = getResources ( ) . getConfiguration ( ) . orientation ; } @ Override public void onStart ( ) { Dialog dialog = getDialog ( ) ; if ( dialog == null ) { return ; } Window window = dialog . getWindow ( ) ; if ( window == null ) { return ; } window . addFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; super . onStart ( ) ; DialogUtils . syncSystemUiVisibility ( getActivity ( ) , window ) ; window . clearFlags ( WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE ) ; initDialog ( ) ; } private void initDialog ( ) { Dialog dialog = getDialog ( ) ; if ( dialog == null ) { return ; } dialog . setCanceledOnTouchOutside ( false ) ; setCancelable ( false ) ; Window window = dialog . getWindow ( ) ; if ( window == null ) { return ; } PromptEntity promptEntity = getPromptEntity ( ) ; window . setGravity ( Gravity . CENTER ) ; WindowManager . LayoutParams lp = window . getAttributes ( ) ; DisplayMetrics displayMetrics = getResources ( ) . getDisplayMetrics ( ) ; if ( promptEntity . getWidthRatio ( ) > <NUM_LIT> && promptEntity . getWidthRatio ( ) < <NUM_LIT> ) { lp . width = ( int ) ( displayMetrics . widthPixels * promptEntity . getWidthRatio ( ) ) ; } if ( promptEntity . getHeightRatio ( ) > <NUM_LIT> && promptEntity . getHeightRatio ( ) < <NUM_LIT> ) { lp . height = ( int ) ( displayMetrics . heightPixels * promptEntity . getHeightRatio ( ) ) ; } window . setAttributes ( lp ) ; } @ Nullable @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { return inflater . inflate ( R . layout . spa_layout_update_prompter , container ) ; } @ Override public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; initView ( view ) ; initData ( ) ; } private void initView ( View view ) { mIvTop = view . findViewById ( R . id . iv_top ) ; mTvTitle = view . findViewById ( R . id . tv_title ) ; mTvUpdateInfo = view . findViewById ( R . id . tv_update_info ) ; mBtnUpdate = view . findViewById ( R . id . btn_update ) ; mBtnBackgroundUpdate = view . findViewById ( R . id . btn_background_update ) ; mTvIgnore = view . findViewById ( R . id . tv_ignore ) ; mNumberProgressBar = view . findViewById ( R . id . npb_progress ) ; mLlClose = view . findViewById ( R . id . ll_close ) ; mIvClose = view . findViewById ( R . id . iv_close ) ; } private void initData ( ) { Bundle bundle = getArguments ( ) ; if ( bundle == null ) { return ; } mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } initTheme ( mPromptEntity . getThemeColor ( ) , mPromptEntity . getTopResId ( ) , mPromptEntity . getButtonTextColor ( ) ) ; mUpdateEntity = bundle . getParcelable ( KEY_UPDATE_ENTITY ) ; if ( mUpdateEntity != null ) { initUpdateInfo ( mUpdateEntity ) ; initListeners ( ) ; } } private PromptEntity getPromptEntity ( ) { if ( mPromptEntity == null ) { Bundle bundle = getArguments ( ) ; if ( bundle != null ) {", "output": "mPromptEntity = bundle . getParcelable ( KEY_UPDATE_PROMPT_ENTITY ) ; } } if ( mPromptEntity == null ) { mPromptEntity = new PromptEntity ( ) ; } return mPromptEntity ; } private void initUpdateInfo ( UpdateEntity updateEntity ) { final String newVersion = updateEntity . getVersionName ( ) ; String updateInfo = UpdateUtils . getDisplayUpdateInfo ( getContext ( ) , updateEntity ) ; mTvUpdateInfo . setText ( updateInfo ) ; mTvTitle . setText ( String . format ( getString ( R . string . space_lab_ready_update ) , newVersion ) ) ; refreshUpdateButton ( ) ; if ( updateEntity . isForce ( ) ) { mLlClose . setVisibility ( View . GONE ) ; } } private void initTheme ( @ ColorInt int themeColor , @ DrawableRes int topResId , @ ColorInt int buttonTextColor ) { if ( themeColor == - <NUM_LIT> ) { themeColor = ColorUtils . getColor ( getContext ( ) , R . color . space_default_theme_color ) ; } if ( topResId == - <NUM_LIT> ) { topResId = R . drawable . spa_bg_app_top ; } if ( buttonTextColor == <NUM_LIT> ) { buttonTextColor = ColorUtils . isColorDark ( themeColor ) ? Color . WHITE : Color . BLACK ; } setDialogTheme ( themeColor , topResId , buttonTextColor ) ; } private void setDialogTheme ( int themeColor , int topResId , int buttonTextColor ) { Drawable topDrawable = _AppSpace . getTopDrawable ( mPromptEntity . getTopDrawableTag ( ) ) ; if ( topDrawable != null ) { mIvTop . setImageDrawable ( topDrawable ) ; } else { mIvTop . setImageResource ( topResId ) ; } DrawableUtils . setBackgroundCompat ( mBtnUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; DrawableUtils . setBackgroundCompat ( mBtnBackgroundUpdate , DrawableUtils . getDrawable ( UpdateUtils . dip2px ( <NUM_LIT> , getContext ( ) ) , themeColor ) ) ; mNumberProgressBar . setProgressTextColor ( themeColor ) ; mNumberProgressBar . setReachedBarColor ( themeColor ) ; mBtnUpdate . setTextColor ( buttonTextColor ) ; mBtnBackgroundUpdate . setTextColor ( buttonTextColor ) ; } private void initListeners ( ) { mBtnUpdate . setOnClickListener ( this ) ; mBtnBackgroundUpdate . setOnClickListener ( this ) ; mIvClose . setOnClickListener ( this ) ; mTvIgnore . setOnClickListener ( this ) ; } @ Override public void onClick ( View view ) { int i = view . getId ( ) ; if ( i == R . id . btn_update ) { int flag = ActivityCompat . checkSelfPermission ( getActivity ( ) , Manifest . permission . WRITE_EXTERNAL_STORAGE ) ; if ( ! UpdateUtils . isPrivateApkCacheDir ( mUpdateEntity ) && flag != PackageManager . PERMISSION_GRANTED ) { requestPermissions ( new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , REQUEST_CODE_REQUEST_PERMISSIONS ) ; } else { installApp ( ) ; } } else if ( i == R . id . btn_background_update ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . backgroundDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . iv_close ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . cancelDownload ( ) ; } dismissDialog ( ) ; } else if ( i == R . id . tv_ignore ) { UpdateUtils . saveIgnoreVersion ( getActivity ( ) , mUpdateEntity . getVersionName ( ) ) ; dismissDialog ( ) ; } } @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == REQUEST_CODE_REQUEST_PERMISSIONS ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { installApp ( ) ; } else { _AppSpace . onUpdateError ( UpdateError . ERROR . DOWNLOAD_PERMISSION_DENIED ) ; dismissDialog ( ) ; } } } private void installApp ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { onInstallApk ( ) ; if ( ! mUpdateEntity . isForce ( ) ) { dismissDialog ( ) ; } else { showInstallButton ( ) ; } } else { if ( sIPrompterProxy != null ) { sIPrompterProxy . startDownload ( mUpdateEntity , new WeakFileDownloadListener ( this ) ) ; } if ( mUpdateEntity . isIgnorable ( ) ) { mTvIgnore . setVisibility ( View . GONE ) ; } } } @ Override public void handleStart ( ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { doStart ( ) ; } } private void doStart ( ) { mNumberProgressBar . setVisibility ( View . VISIBLE ) ; mNumberProgressBar . setProgress ( <NUM_LIT> ) ; mBtnUpdate . setVisibility ( View . GONE ) ; if ( mPromptEntity . isSupportBackgroundUpdate ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . VISIBLE ) ; } else { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; } } @ Override public void handleProgress ( float progress ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { if ( mNumberProgressBar . getVisibility ( ) == View . GONE ) { doStart ( ) ; } mNumberProgressBar . setProgress ( Math . round ( progress * <NUM_LIT> ) ) ; mNumberProgressBar . setMax ( <NUM_LIT> ) ; } } @ Override public boolean handleCompleted ( File file ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; if ( mUpdateEntity . isForce ( ) ) { showInstallButton ( ) ; } else { dismissDialog ( ) ; } } return true ; } @ Override public void handleError ( Throwable throwable ) { if ( ! UpdateDialogFragment . this . isRemoving ( ) ) { if ( mPromptEntity . isIgnoreDownloadError ( ) ) { refreshUpdateButton ( ) ; } else { dismissDialog ( ) ; } } } private void refreshUpdateButton ( ) { if ( UpdateUtils . isApkDownloaded ( mUpdateEntity ) ) { showInstallButton ( ) ; } else { showUpdateButton ( ) ; } mTvIgnore . setVisibility ( mUpdateEntity . isIgnorable ( ) ? View . VISIBLE : View . GONE ) ; } private void showInstallButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_install ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void showUpdateButton ( ) { mNumberProgressBar . setVisibility ( View . GONE ) ; mBtnBackgroundUpdate . setVisibility ( View . GONE ) ; mBtnUpdate . setText ( R . string . space_lab_update ) ; mBtnUpdate . setVisibility ( View . VISIBLE ) ; mBtnUpdate . setOnClickListener ( this ) ; } private void onInstallApk ( ) { _AppSpace . startInstallApk ( getContext ( ) , UpdateUtils . getApkFileByUpdateEntity ( mUpdateEntity ) , mUpdateEntity . getCurDownloadEntity ( ) ) ; } private void dismissDialog ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; dismissAllowingStateLoss ( ) ; } @ Override public void show ( @ NonNull FragmentManager manager , @ Nullable String tag ) { if ( Build . VERSION . SDK_INT > Build . VERSION_CODES . JELLY_BEAN ) { if ( manager . isDestroyed ( ) || manager . isStateSaved ( ) ) { return ; } } try { super . show ( manager , tag ) ; } catch ( Exception e ) { _AppSpace . onUpdateError ( UpdateError . ERROR . PROMPT_UNKNOWN , e . getMessage ( ) ) ; } } public void show ( FragmentManager manager ) { show ( manager , \"<STR_LIT>\" ) ; } @ Override public void onDestroyView ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; clearIPrompterProxy ( ) ; super . onDestroyView ( ) ; } private static void setIPrompterProxy ( IPrompterProxy prompterProxy ) { UpdateDialogFragment . sIPrompterProxy = prompterProxy ; } private static void clearIPrompterProxy ( ) { if ( sIPrompterProxy != null ) { sIPrompterProxy . recycle ( ) ; sIPrompterProxy = null ; } } @ Override public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; if ( newConfig . orientation != mCurrentOrientation ) { reloadView ( ) ; } mCurrentOrientation = newConfig . orientation ; } private void reloadView ( ) { View view = LayoutInflater . from ( getContext ( ) ) . inflate ( R . layout . spa_layout_update_prompter , null ) ; ViewGroup root = ( ViewGroup ) getView ( ) ; if ( root != null ) { root . removeAllViews ( ) ; root . addView ( view ) ; initView ( root ) ; initData ( ) ; } } private String getUrl ( ) { return sIPrompterProxy != null ? sIPrompterProxy . getUrl ( ) : \"<STR_LIT>\" ; } }"}, {"input": "package com . reactnative . wheelpicker ; import androidx . annotation . NonNull ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class WheelPickerPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ;", "output": "} @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new PickerViewManager ( ) ) ; } }"}, {"input": "package com . reactnative . bottomsheet ; import androidx . annotation . NonNull ; import java . util . Collections ; import java . util . List ; import com . facebook . react . ReactPackage ; import com . facebook . react . bridge . NativeModule ; import com . facebook . react . bridge . ReactApplicationContext ; import com . facebook . react . uimanager . ViewManager ; public class BottomSheetPackage implements ReactPackage { @ NonNull @ Override public List < NativeModule > createNativeModules ( @ NonNull ReactApplicationContext reactContext ) { return Collections . emptyList ( ) ; } @ NonNull @ Override public List < ViewManager > createViewManagers ( @ NonNull ReactApplicationContext reactContext ) { return Collections . singletonList ( new BottomSheetManager ( ) ) ;", "output": "} }"}, {"input": "package com . baidu . aip . asrwakeup3 . core . util ; import android . content . res . AssetManager ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; public class FileUtil { public static boolean makeDir ( String dirPath ) { File file = new File ( dirPath ) ; if ( ! file . exists ( ) ) {", "output": "return file . mkdirs ( ) ; } else { return true ; } } public static String getContentFromAssetsFile ( AssetManager assets , String source ) { InputStream is = null ; FileOutputStream fos = null ; String result = \"<STR_LIT>\" ; try { is = assets . open ( source ) ; int lenght = is . available ( ) ; byte [ ] buffer = new byte [ lenght ] ; is . read ( buffer ) ; result = new String ( buffer , \"<STR_LIT>\" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; } public static boolean copyFromAssets ( AssetManager assets , String source , String dest , boolean isCover ) throws IOException { File file = new File ( dest ) ; boolean isCopyed = false ; if ( isCover || ( ! isCover && ! file . exists ( ) ) ) { InputStream is = null ; FileOutputStream fos = null ; try { is = assets . open ( source ) ; String path = dest ; fos = new FileOutputStream ( path ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int size = <NUM_LIT> ; while ( ( size = is . read ( buffer , <NUM_LIT> , <NUM_LIT> ) ) >= <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , size ) ; } isCopyed = true ; } finally { if ( fos != null ) { try { fos . close ( ) ; } finally { if ( is != null ) { is . close ( ) ; } } } } } return isCopyed ; } }"}, {"input": "package com . reactnative . keyboardinsets ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . core . view . ViewCompat ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . ViewGroupManager ; import com . facebook . react . uimanager . annotations . ReactProp ; import java . util . Map ; public class KeyboardInsetsViewManager extends ViewGroupManager < KeyboardInsetsView > { public static final String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override protected KeyboardInsetsView createViewInstance ( @ NonNull ThemedReactContext themedReactContext ) {", "output": "KeyboardInsetsView view = new KeyboardInsetsView ( themedReactContext ) ; KeyboardInsetsCallback callback = new KeyboardInsetsCallback ( view , themedReactContext ) ; ViewCompat . setWindowInsetsAnimationCallback ( view , callback ) ; ViewCompat . setOnApplyWindowInsetsListener ( view , callback ) ; return view ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setMode ( KeyboardInsetsView view , String mode ) { view . setMode ( mode ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setExtraHeight ( KeyboardInsetsView view , float extraHeight ) { view . setExtraHeight ( extraHeight ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . of ( \"<STR_LIT>\" , MapBuilder . of ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \"<STR_LIT>\" , MapBuilder . of ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import java . util . List ; public abstract class ListAdapter < T , VH extends RecyclerView . ViewHolder > extends RecyclerView . Adapter < VH > { final AsyncListDiffer < T > mDiffer ; private final AsyncListDiffer . ListListener < T > mListener = new AsyncListDiffer . ListListener < T > ( ) { @ Override public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { ListAdapter . this . onCurrentListChanged ( previousList , currentList ) ; } } ; @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull DiffUtil . ItemCallback < T > diffCallback ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , new AsyncDifferConfig . Builder < > ( diffCallback ) . build ( ) ) ; mDiffer . addListListener ( mListener ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected ListAdapter ( @ NonNull AsyncDifferConfig < T > config ) { mDiffer = new AsyncListDiffer < > ( new AdapterListUpdateCallback ( this ) , config ) ; mDiffer . addListListener ( mListener ) ; } public void submitList ( @ Nullable List < T > list ) { mDiffer . submitList ( list ) ; } public void submitList ( @ Nullable List < T > list , @ Nullable final Runnable commitCallback ) { mDiffer . submitList ( list , commitCallback ) ; } protected T getItem ( int position ) { return mDiffer . getCurrentList ( ) . get ( position ) ; } @ Override public int getItemCount ( ) { return mDiffer . getCurrentList ( ) . size ( ) ; } @ NonNull public List < T > getCurrentList ( ) {", "output": "return mDiffer . getCurrentList ( ) ; } public void onCurrentListChanged ( @ NonNull List < T > previousList , @ NonNull List < T > currentList ) { } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . general ; import android . annotation . SuppressLint ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . PorterDuff ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Handler ; import android . os . Looper ; import android . view . Gravity ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . collection . ArraySet ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . components . FMessageWpp ; import com . wmods . wppenhacer . xposed . core . db . MessageStore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . DesignUtils ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . CompletableFuture ; import java . util . stream . Collectors ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class SeenTick extends Feature { private static final ArraySet < MessageInfo > messages = new ArraySet < > ( ) ; private static Object mWaJobManager ; private static Class < ? > mSendReadClass ; private static Method WaJobManagerMethod ; private static String currentJid ; private static String currentScreen = \"<STR_LIT>\" ; private static final HashMap < String , ImageView > messageMap = new HashMap < > ( ) ; public SeenTick ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var bubbleMethod = Unobfuscator . loadAntiRevokeBubbleMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( bubbleMethod ) ) ; var messageSendClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; WaJobManagerMethod = Unobfuscator . loadBlueOnReplayWaJobManagerMethod ( classLoader ) ; var messageJobMethod = Unobfuscator . loadBlueOnReplayMessageJobMethod ( classLoader ) ; mSendReadClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; WppCore . addListenerChat ( ( activity , type ) -> { if ( activity . getClass ( ) . getSimpleName ( ) . equals ( \"<STR_LIT>\" ) && ( type == WppCore . ActivityChangeState . ChangeType . START || type == WppCore . ActivityChangeState . ChangeType . RESUME ) ) { var jid = WppCore . getCurrentRawJID ( ) ; if ( ! Objects . equals ( jid , currentJid ) ) { currentJid = jid ; messages . clear ( ) ; } currentScreen = \"<STR_LIT>\" ; } } ) ; XposedBridge . hookMethod ( bubbleMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var objMessage = param . args [ <NUM_LIT> ] ; var fMessage = new FMessageWpp ( objMessage ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; messages . add ( new MessageInfo ( fMessage , key . messageID , fMessage . getUserJid ( ) ) ) ; } } ) ; XposedBridge . hookMethod ( messageJobMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var obj = messageSendClass . cast ( param . thisObject ) ; var rawJid = ( String ) XposedHelpers . getObjectField ( obj , \"<STR_LIT>\" ) ; var handler = new Handler ( Looper . getMainLooper ( ) ) ; if ( Objects . equals ( currentScreen , \"<STR_LIT>\" ) ) { if ( messages . isEmpty ( ) ) return ; MessageStore . getInstance ( ) . storeMessageRead ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; var view = messageMap . get ( messages . valueAt ( <NUM_LIT> ) . messageId ) ; if ( view != null ) view . post ( ( ) -> setSeenButton ( view , true ) ) ; handler . post ( ( ) -> sendBlueTickStatus ( currentJid ) ) ; } else handler . post ( ( ) -> sendBlueTick ( rawJid ) ) ; } } ) ; XposedBridge . hookAllConstructors ( WaJobManagerMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mWaJobManager = param . thisObject ; } } ) ; var ticktype = Integer . parseInt ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ticktype == <NUM_LIT> ) return ; var onCreateMenuConversationMethod = Unobfuscator . loadBlueOnReplayCreateMenuConversationMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onCreateMenuConversationMethod ) ) ; XposedBridge . hookMethod ( onCreateMenuConversationMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var menu = ( Menu ) param . args [ <NUM_LIT> ] ; var menuItem = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) ; if ( ticktype == <NUM_LIT> ) menuItem . setShowAsAction ( <NUM_LIT> ) ; menuItem . setIcon ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; menuItem . setOnMenuItemClickListener ( item -> { Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTick ( currentJid ) ; return true ; } ) ; } } ) ; var setPageActiveMethod = Unobfuscator . loadStatusActivePage ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( setPageActiveMethod ) ) ; var fieldList = Unobfuscator . getFieldByType ( setPageActiveMethod . getDeclaringClass ( ) , List . class ) ; XposedBridge . hookMethod ( setPageActiveMethod , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var position = ( int ) param . args [ <NUM_LIT> ] ; var list = ( List < ? > ) XposedHelpers . getObjectField ( param . args [ <NUM_LIT> ] , fieldList . getName ( ) ) ; var fMessage = new FMessageWpp ( list . get ( position ) ) ; var messageKey = ( String ) fMessage . getKey ( ) . messageID ; var jid = WppCore . getRawString ( fMessage . getUserJid ( ) ) ; messages . clear ( ) ; messages . add ( new MessageInfo ( fMessage , messageKey , null ) ) ; currentJid = jid ; currentScreen = \"<STR_LIT>\" ; } } ) ; var viewButtonMethod = Unobfuscator . loadBlueOnReplayViewButtonMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( viewButtonMethod ) ) ; if ( ticktype == <NUM_LIT> ) { XposedBridge . hookMethod ( viewButtonMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var fMessageField = ReflectionUtils . getFieldByExtendType ( param . thisObject . getClass ( ) , FMessageWpp . TYPE ) ; var fMessage = new FMessageWpp ( ReflectionUtils . getField ( fMessageField , param . thisObject ) ) ; var key = fMessage . getKey ( ) ; if ( key . isFromMe ) return ; var view = ( View ) param . getResult ( ) ; var contentView = ( LinearLayout ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var buttonImage = new ImageView ( view . getContext ( ) ) ; LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) ) ; params . gravity = Gravity . CENTER_VERTICAL ; params . setMargins ( Utils . dipToPixels ( <NUM_LIT> ) , Utils . dipToPixels ( <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; buttonImage . setLayoutParams ( params ) ; buttonImage . setImageResource ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; GradientDrawable border = new GradientDrawable ( ) ; border . setShape ( GradientDrawable . RECTANGLE ) ; border . setStroke ( <NUM_LIT> , Color . WHITE ) ; border . setCornerRadius ( <NUM_LIT> ) ; border . setColor ( Color . parseColor ( \"<STR_LIT>\" ) ) ; buttonImage . setBackground ( border ) ; contentView . setOrientation ( LinearLayout . HORIZONTAL ) ;", "output": "contentView . addView ( buttonImage , <NUM_LIT> ) ; messageMap . put ( key . messageID , buttonImage ) ; buttonImage . setOnClickListener ( v -> CompletableFuture . runAsync ( ( ) -> { Utils . showToast ( view . getContext ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; sendBlueTickStatus ( currentJid ) ; setSeenButton ( buttonImage , true ) ; } ) ) ; CompletableFuture . runAsync ( ( ) -> { var seen = MessageStore . getInstance ( ) . isReadMessageStatus ( key . messageID ) ; setSeenButton ( buttonImage , seen ) ; } ) ; } } ) ; } else { MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . send_blue_tick ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . send_blue_tick , <NUM_LIT> , ResId . string . send_blue_tick ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; } MenuStatus . menuStatuses . add ( new MenuStatus . MenuItemStatus ( ) { @ Override public MenuItem addMenu ( Menu menu , FMessageWpp fMessage ) { if ( menu . findItem ( ResId . string . read_all_mark_as_read ) != null ) return null ; if ( fMessage . getKey ( ) . isFromMe ) return null ; return menu . add ( <NUM_LIT> , ResId . string . read_all_mark_as_read , <NUM_LIT> , ResId . string . read_all_mark_as_read ) ; } @ Override public void onClick ( MenuItem item , Object fragmentInstance , FMessageWpp fMessageWpp ) { try { messages . clear ( ) ; var listStatusField = ReflectionUtils . getFieldByExtendType ( fragmentInstance . getClass ( ) , List . class ) ; var listStatus = ( List ) listStatusField . get ( fragmentInstance ) ; for ( int i = <NUM_LIT> ; i < listStatus . size ( ) ; i ++ ) { var fMessage = new FMessageWpp ( listStatus . get ( i ) ) ; var messageId = fMessage . getKey ( ) . messageID ; if ( ! fMessage . getKey ( ) . isFromMe ) { messages . add ( new MessageInfo ( fMessage , messageId , null ) ) ; } var view = messageMap . get ( messageId ) ; if ( view != null ) { view . post ( ( ) -> setSeenButton ( view , true ) ) ; } } } catch ( Exception e ) { log ( e ) ; } sendBlueTickStatus ( currentJid ) ; Utils . showToast ( Utils . getApplication ( ) . getString ( ResId . string . sending_read_blue_tick ) , Toast . LENGTH_SHORT ) ; } } ) ; var menuMethod = Unobfuscator . loadViewOnceDownloadMenuMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( menuMethod ) ) ; var menuIntField = Unobfuscator . loadViewOnceDownloadMenuField ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( menuIntField ) ) ; var classThreadMessage = Unobfuscator . loadFMessageClass ( classLoader ) ; XposedBridge . hookMethod ( menuMethod , new XC_MethodHook ( ) { @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var id = XposedHelpers . getIntField ( param . thisObject , menuIntField . getName ( ) ) ; if ( id == <NUM_LIT> || id == <NUM_LIT> ) { Menu menu = ( Menu ) param . args [ <NUM_LIT> ] ; MenuItem item = menu . add ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , ResId . string . send_blue_tick ) . setIcon ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( ticktype == <NUM_LIT> ) item . setShowAsAction ( MenuItem . SHOW_AS_ACTION_ALWAYS ) ; item . setOnMenuItemClickListener ( item1 -> { var messageField = Unobfuscator . getFieldByExtendType ( menuMethod . getDeclaringClass ( ) , classThreadMessage ) ; var messageObject = XposedHelpers . getObjectField ( param . thisObject , messageField . getName ( ) ) ; sendBlueTickMedia ( messageObject , true ) ; Toast . makeText ( Utils . getApplication ( ) , ResId . string . sending_read_blue_tick , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } ) ; } } } ) ; } public static void setSeenButton ( ImageView buttonImage , boolean b ) { Drawable originalDrawable = DesignUtils . getDrawableByName ( \"<STR_LIT>\" ) ; Drawable clonedDrawable ; if ( originalDrawable instanceof BitmapDrawable ) { Bitmap bitmap = ( ( BitmapDrawable ) originalDrawable ) . getBitmap ( ) ; Bitmap clonedBitmap = bitmap . copy ( bitmap . getConfig ( ) , true ) ; clonedDrawable = new BitmapDrawable ( buttonImage . getResources ( ) , clonedBitmap ) ; } else { clonedDrawable = Objects . requireNonNull ( originalDrawable . getConstantState ( ) ) . newDrawable ( ) . mutate ( ) ; } if ( b ) { clonedDrawable . setColorFilter ( Color . CYAN , PorterDuff . Mode . SRC_ATOP ) ; } buttonImage . setImageDrawable ( clonedDrawable ) ; buttonImage . postInvalidate ( ) ; } private void sendBlueTick ( String currentJid ) { logDebug ( \"<STR_LIT>\" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; var messagekeys = messages . stream ( ) . map ( item -> item . messageId ) . collect ( Collectors . toList ( ) ) ; var listAudios = MessageStore . getInstance ( ) . getAudioListByMessageList ( messagekeys ) ; logDebug ( \"<STR_LIT>\" + listAudios ) ; for ( var messageKey : listAudios ) { var mInfo = messages . stream ( ) . filter ( messageInfo -> messageInfo . messageId . equals ( messageKey ) ) . findAny ( ) ; if ( mInfo . isPresent ( ) ) { messages . remove ( mInfo . get ( ) ) ; sendBlueTickMedia ( mInfo . get ( ) . fMessage . getObject ( ) , false ) ; } } sendBlueTickMsg ( currentJid ) ; } private void sendBlueTickMsg ( String currentJid ) { logDebug ( \"<STR_LIT>\" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . contains ( Utils . getMyNumber ( ) ) ) return ; try { logDebug ( \"<STR_LIT>\" + currentJid ) ; HashMap < Object , List < String > > map = new HashMap < > ( ) ; for ( var messageInfo : messages ) { map . computeIfAbsent ( messageInfo . userJid , k -> new ArrayList < > ( ) ) ; Objects . requireNonNull ( map . get ( messageInfo . userJid ) ) . add ( messageInfo . messageId ) ; } var userJidTarget = WppCore . createUserJid ( currentJid ) ; for ( var userjid : map . keySet ( ) ) { var messages = Objects . requireNonNull ( map . get ( userjid ) ) . toArray ( new String [ <NUM_LIT> ] ) ; WppCore . setPrivBoolean ( messages [ <NUM_LIT> ] + \"<STR_LIT>\" , true ) ; var participant = WppCore . isGroup ( currentJid ) ? userjid : null ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidTarget , participant , null , null , messages , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; } messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } private void sendBlueTickStatus ( String currentJid ) { logDebug ( \"<STR_LIT>\" + Arrays . toString ( messages . toArray ( new MessageInfo [ <NUM_LIT> ] ) ) ) ; if ( messages . isEmpty ( ) || currentJid == null || currentJid . equals ( \"<STR_LIT>\" ) ) return ; try { logDebug ( \"<STR_LIT>\" + currentJid ) ; var arr_s = messages . stream ( ) . map ( item -> item . messageId ) . toArray ( String [ ] :: new ) ; Arrays . stream ( arr_s ) . forEach ( s -> MessageStore . getInstance ( ) . storeMessageRead ( s ) ) ; var userJidSender = WppCore . createUserJid ( \"<STR_LIT>\" ) ; var userJid = WppCore . createUserJid ( currentJid ) ; WppCore . setPrivBoolean ( arr_s [ <NUM_LIT> ] + \"<STR_LIT>\" , true ) ; var sendJob = XposedHelpers . newInstance ( mSendReadClass , userJidSender , userJid , null , null , arr_s , - <NUM_LIT> , <NUM_LIT> , false ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } private void sendBlueTickMedia ( Object messageObject , boolean clear ) { try { logDebug ( \"<STR_LIT>\" + WppCore . getCurrentRawJID ( ) ) ; var sendPlayerClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var sendJob = XposedHelpers . newInstance ( sendPlayerClass , messageObject ) ; WaJobManagerMethod . invoke ( mWaJobManager , sendJob ) ; if ( clear ) messages . clear ( ) ; } catch ( Throwable e ) { XposedBridge . log ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } static class MessageInfo { public Object userJid ; public String messageId ; public FMessageWpp fMessage ; public MessageInfo ( FMessageWpp fMessage , String messageId , Object userJid ) { this . messageId = messageId ; this . fMessage = fMessage ; this . userJid = userJid ; } @ Override public boolean equals ( @ Nullable Object obj ) { if ( obj instanceof MessageInfo messageInfo ) { return Objects . equals ( messageId , messageInfo . messageId ) && Objects . equals ( fMessage , messageInfo . fMessage ) && Objects . equals ( userJid , messageInfo . userJid ) ; } return false ; } @ NonNull @ Override public String toString ( ) { return messageId ; } } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . ShapeDrawable ; import android . graphics . drawable . shapes . OvalShape ; import android . text . TextUtils ; import android . view . Gravity ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . RelativeLayout ; import android . widget . TextView ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . core . devkit . UnobfuscatorCache ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class DotOnline extends Feature { private Object mStatusUser ; private Object mInstancePresence ; public DotOnline ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { var showOnlineText = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var showOnlineIcon = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; if ( ! showOnlineText && ! showOnlineIcon ) return ; var classViewHolder = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; XposedBridge . hookAllConstructors ( classViewHolder , new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var view = ( View ) param . args [ <NUM_LIT> ] ; var context = ( Context ) param . args [ <NUM_LIT> ] ; var content = ( LinearLayout ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( showOnlineText ) { var linearLayout = new LinearLayout ( context ) ; linearLayout . setGravity ( Gravity . END | Gravity . TOP ) ; content . addView ( linearLayout ) ; TextView lastSeenText = new TextView ( context ) ; lastSeenText . setId ( <NUM_LIT> ) ; lastSeenText . setTextSize ( <NUM_LIT> ) ; lastSeenText . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; lastSeenText . setGravity ( Gravity . CENTER_VERTICAL ) ; lastSeenText . setVisibility ( View . INVISIBLE ) ; linearLayout . addView ( lastSeenText ) ; } if ( showOnlineIcon ) { var contactView = ( FrameLayout ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var photoView = ( ImageView ) contactView . getChildAt ( <NUM_LIT> ) ; contactView . removeView ( photoView ) ; var relativeLayout = new RelativeLayout ( context ) ; relativeLayout . setId ( <NUM_LIT> ) ; var params = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params . addRule ( RelativeLayout . CENTER_IN_PARENT ) ; photoView . setLayoutParams ( params ) ; relativeLayout . addView ( photoView ) ; contactView . addView ( relativeLayout ) ; var imageView = new ImageView ( context ) ; imageView . setId ( <NUM_LIT> ) ; var params2 = new RelativeLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params2 . addRule ( RelativeLayout . ALIGN_TOP , photoView . getId ( ) ) ; params2 . addRule ( RelativeLayout . ALIGN_RIGHT , photoView . getId ( ) ) ; params2 . topMargin = Utils . dipToPixels ( <NUM_LIT> ) ; imageView . setLayoutParams ( params2 ) ; ShapeDrawable shapeDrawable = new ShapeDrawable ( new OvalShape ( ) ) ; shapeDrawable . getPaint ( ) . setColor ( Color . GREEN ) ; shapeDrawable . setIntrinsicHeight ( <NUM_LIT> ) ; shapeDrawable . setIntrinsicWidth ( <NUM_LIT> ) ; imageView . setImageDrawable ( shapeDrawable ) ; imageView . setVisibility ( View . INVISIBLE ) ; relativeLayout . addView ( imageView ) ; } } } ) ; var onChangeStatus = Unobfuscator . loadOnChangeStatus ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( onChangeStatus ) ) ; var field1 = Unobfuscator . loadViewHolderField1 ( classLoader ) ; logDebug ( Unobfuscator . getFieldDescriptor ( field1 ) ) ; var getStatusUser = Unobfuscator . loadStatusUserMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( getStatusUser ) ) ; var sendPresenceMethod = Unobfuscator . loadSendPresenceMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( sendPresenceMethod ) ) ; var absViewHolderClass = Unobfuscator . loadAbsViewHolder ( classLoader ) ; XposedBridge . hookAllConstructors ( getStatusUser . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mStatusUser = param . thisObject ; } } ) ; XposedBridge . hookAllConstructors ( sendPresenceMethod . getDeclaringClass ( ) , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { mInstancePresence = param . thisObject ;", "output": "} } ) ; XposedBridge . hookMethod ( onChangeStatus , new XC_MethodHook ( ) { @ Override @ SuppressLint ( \"<STR_LIT>\" ) protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var viewHolder = field1 . get ( param . thisObject ) ; var object = param . args [ <NUM_LIT> ] ; var viewField = ReflectionUtils . findFieldUsingFilter ( absViewHolderClass , field -> field . getType ( ) == View . class ) ; var view = ( View ) viewField . get ( viewHolder ) ; var getAdapterPositionMethod = ReflectionUtils . findMethodUsingFilter ( absViewHolderClass , method -> method . getParameterCount ( ) == <NUM_LIT> && method . getReturnType ( ) == int . class ) ; var position = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; ImageView csDot = showOnlineIcon ? view . findViewById ( <NUM_LIT> ) . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineIcon ) { csDot . setVisibility ( View . INVISIBLE ) ; } TextView lastSeenText = showOnlineText ? view . findViewById ( <NUM_LIT> ) : null ; if ( showOnlineText ) { lastSeenText . setVisibility ( View . INVISIBLE ) ; } var jidFiled = Unobfuscator . getFieldByExtendType ( object . getClass ( ) , XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ) ; var jidObject = jidFiled . get ( object ) ; var jid = WppCore . getRawString ( jidObject ) ; if ( WppCore . isGroup ( jid ) ) return ; Class < ? > JidClass = classLoader . loadClass ( \"<STR_LIT>\" ) ; var method = ReflectionUtils . findMethodUsingFilter ( sendPresenceMethod . getDeclaringClass ( ) , method1 -> method1 . getParameterCount ( ) == <NUM_LIT> && JidClass . isAssignableFrom ( method1 . getParameterTypes ( ) [ <NUM_LIT> ] ) && method1 . getParameterTypes ( ) [ <NUM_LIT> ] == sendPresenceMethod . getDeclaringClass ( ) ) ; var instance = ReflectionUtils . callMethod ( method , null , jidObject , mInstancePresence ) ; sendPresenceMethod . invoke ( null , jidObject , instance , mInstancePresence ) ; var status = ( String ) getStatusUser . invoke ( mStatusUser , object ) ; var currentPosition = ( int ) ReflectionUtils . callMethod ( getAdapterPositionMethod , viewHolder ) ; if ( currentPosition != position ) return ; if ( ! TextUtils . isEmpty ( status ) && status . trim ( ) . equals ( UnobfuscatorCache . getInstance ( ) . getString ( \"<STR_LIT>\" ) ) ) { if ( csDot != null ) { csDot . setVisibility ( View . VISIBLE ) ; } } if ( ! TextUtils . isEmpty ( status ) ) { if ( lastSeenText != null ) { lastSeenText . setText ( status ) ; lastSeenText . setVisibility ( View . VISIBLE ) ; } } } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . TYPE ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( { TYPE } ) @ Inherited public @ interface ClassType {", "output": "Class < ? > value ( ) ; }"}, {"input": "package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . Activity ; import android . content . Intent ; import android . database . Cursor ; import android . os . Bundle ; import android . provider . ContactsContract ; import android . text . Editable ; import android . text . TextWatcher ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ListView ; import androidx . appcompat . app . AppCompatActivity ; import com . wmods . wppenhacer . R ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; public class ContactPickerActivity extends AppCompatActivity { private String mKey ; private ListView contactListView ; private ArrayAdapter < String > adapter ; private HashSet < String > selectedNumbers = new HashSet < > ( ) ; private final List < Contact > allContacts = new ArrayList < > ( ) ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; setContentView ( R . layout . activity_contact_picker ) ; mKey = getIntent ( ) . getStringExtra ( \"<STR_LIT>\" ) ; contactListView = findViewById ( R . id . contactListView ) ; Button selectButton = findViewById ( R . id . selectButton ) ; EditText searchBar = findViewById ( R . id . searchBar ) ; ArrayList < String > selectedNumbersInIntent = getIntent ( ) . getStringArrayListExtra ( \"<STR_LIT>\" ) ; if ( selectedNumbersInIntent != null ) { selectedNumbers = new HashSet < > ( selectedNumbersInIntent ) ; } loadAllContacts ( ) ; insertContactsInList ( allContacts ) ; selectButton . setOnClickListener ( view -> { Intent resultIntent = new Intent ( ) ; resultIntent . putExtra ( \"<STR_LIT>\" , new ArrayList < > ( selectedNumbers ) ) ; resultIntent . putExtra ( \"<STR_LIT>\" , mKey ) ; setResult ( Activity . RESULT_OK , resultIntent ) ; finish ( ) ; } ) ; searchBar . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { } @ Override public void onTextChanged ( CharSequence charSequence , int i , int i1 , int i2 ) { String searchText = charSequence . toString ( ) . toLowerCase ( ) ; List < Contact > filteredContacts = allContacts . stream ( ) . filter ( contact -> contact . name . toLowerCase ( ) . contains ( searchText ) || contact . number . contains ( searchText ) ) . collect ( Collectors . toList ( ) ) ; insertContactsInList ( filteredContacts ) ; } @ Override public void afterTextChanged ( Editable editable ) { } } ) ; } @ SuppressLint ( \"<STR_LIT>\" ) private void loadAllContacts ( ) { allContacts . clear ( ) ; Set < String > uniqueNumbers = new HashSet < > ( ) ; Cursor cursor = getContentResolver ( ) . query ( ContactsContract . CommonDataKinds . Phone . CONTENT_URI , null , null , null , ContactsContract . CommonDataKinds . Phone . STARRED + \"<STR_LIT>\" + ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME + \"<STR_LIT>\" ) ; if ( cursor != null ) { while ( cursor . moveToNext ( ) ) { String nome = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . DISPLAY_NAME ) ) ; String numero = cursor . getString ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . NUMBER ) ) ; int starred = cursor . getInt ( cursor . getColumnIndex ( ContactsContract . CommonDataKinds . Phone . STARRED ) ) ; String numeroLimpo = numero . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( ! uniqueNumbers . contains ( numeroLimpo ) ) { uniqueNumbers . add ( numeroLimpo ) ; allContacts . add ( new Contact ( nome , numeroLimpo , starred == <NUM_LIT> ) ) ; } } cursor . close ( ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void insertContactsInList ( List < Contact > contacts ) { List < String > contactList = contacts . stream ( ) . map ( contact -> contact . name + \"<STR_LIT>\" + contact . number ) . collect ( Collectors . toList ( ) ) ; contactList . sort ( ( contact1 , contact2 ) -> { String number1 = contact1 . substring ( contact1 . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . trim ( ) ; String number2 = contact2 . substring ( contact2 . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . trim ( ) ; boolean isSelected1 = selectedNumbers . contains ( number1 ) ; boolean isSelected2 = selectedNumbers . contains ( number2 ) ; if ( isSelected1 && ! isSelected2 ) { return - <NUM_LIT> ; } else if ( ! isSelected1 && isSelected2 ) { return <NUM_LIT> ; } else { return contact1 . compareToIgnoreCase ( contact2 ) ; } } ) ; adapter = new ArrayAdapter < > ( this , android . R . layout . simple_list_item_multiple_choice , contactList ) ; contactListView . setAdapter ( adapter ) ; contactListView . setChoiceMode ( ListView . CHOICE_MODE_MULTIPLE ) ; for ( int i = <NUM_LIT> ; i < contactList . size ( ) ; i ++ ) { String contactInfo = contactList . get ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . trim ( ) ; if ( selectedNumbers . contains ( number ) ) { contactListView . setItemChecked ( i , true ) ; } } contactListView . setOnItemClickListener ( ( adapterView , view , i , l ) -> { String contactInfo = adapter . getItem ( i ) ; String number = contactInfo . substring ( contactInfo . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . trim ( ) ;", "output": "if ( selectedNumbers . contains ( number ) ) { selectedNumbers . remove ( number ) ; } else { selectedNumbers . add ( number ) ; } } ) ; } public static class Contact { public String name ; public String number ; public boolean isStarred ; public Contact ( String name , String number , boolean isStarred ) { this . name = name ; this . number = number ; this . isStarred = isStarred ; } } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation ; import io . capawesome . capacitorjs . plugins . mlkit . selfiesegmentation . classes . ProcessImageResult ; public interface ProcessImageResultCallback { void success ( ProcessImageResult result ) ;", "output": "void cancel ( ) ; void error ( Exception exception ) ; }"}, {"input": "package com . simon . harmonichackernews . utils ; import android . content . Context ; import android . os . Environment ; import android . os . Handler ; import android . os . Looper ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import androidx . annotation . WorkerThread ; import com . simon . harmonichackernews . network . NetworkComponent ; import java . io . File ; import java . io . IOException ; import okhttp3 . Call ; import okhttp3 . Callback ; import okhttp3 . Request ; import okhttp3 . Response ; import okio . BufferedSink ; import okio . Okio ; public class FileDownloader { private String mCacheDir ; private final Handler mMainHandler ; public FileDownloader ( Context ctx ) { if ( Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) || ! Environment . isExternalStorageRemovable ( ) ) { if ( ctx . getExternalCacheDir ( ) != null ) { mCacheDir = ctx . getExternalCacheDir ( ) . getPath ( ) ; } } else { if ( ctx . getCacheDir ( ) != null ) { mCacheDir = ctx . getCacheDir ( ) . getPath ( ) ; } } mMainHandler = new Handler ( Looper . getMainLooper ( ) ) ; } @ WorkerThread public void downloadFile ( String url , String mimeType , FileDownloaderCallback callback ) { if ( TextUtils . isEmpty ( mCacheDir ) ) { mMainHandler . post ( ( ) -> callback . onFailure ( null , null ) ) ; return ; } File outputFile = new File ( mCacheDir , new File ( url ) . getName ( ) ) ;", "output": "if ( outputFile . exists ( ) ) { mMainHandler . post ( ( ) -> callback . onSuccess ( outputFile . getPath ( ) ) ) ; return ; } final Request request = new Request . Builder ( ) . url ( url ) . addHeader ( \"<STR_LIT>\" , mimeType ) . build ( ) ; NetworkComponent . getOkHttpClientInstance ( ) . newCall ( request ) . enqueue ( new Callback ( ) { @ Override public void onFailure ( @ NonNull Call call , @ NonNull IOException e ) { mMainHandler . post ( ( ) -> callback . onFailure ( call , e ) ) ; } @ Override public void onResponse ( @ NonNull Call call , @ NonNull Response response ) { try { BufferedSink sink = Okio . buffer ( Okio . sink ( outputFile ) ) ; sink . writeAll ( response . body ( ) . source ( ) ) ; sink . close ( ) ; mMainHandler . post ( ( ) -> callback . onSuccess ( outputFile . getPath ( ) ) ) ; } catch ( IOException e ) { this . onFailure ( call , e ) ; } } } ) ; } public interface FileDownloaderCallback { void onFailure ( Call call , IOException e ) ; void onSuccess ( String filePath ) ; } }"}, {"input": "package com . appspa . update . listener ; import android . content . Context ; import androidx . annotation . NonNull ; import com . appspa . update . entity . DownloadEntity ; import java . io . File ; public interface OnInstallListener { boolean onInstallApk ( @ NonNull Context context , @ NonNull File apkFile , @ NonNull DownloadEntity downloadEntity ) ; void onInstallApkSuccess ( ) ;", "output": "}"}, {"input": "package in . hridayan . ashell . utils ; import android . content . Context ; import android . content . res . Configuration ; import android . os . Build ; import android . util . TypedValue ; import androidx . appcompat . app . AppCompatActivity ; import in . hridayan . ashell . R ; public class ThemeUtils { private static boolean isAmoledTheme ; public static void updateTheme ( AppCompatActivity activity ) { isAmoledTheme = Preferences . getAmoledTheme ( activity ) ; int currentMode = activity . getResources ( ) . getConfiguration ( ) . uiMode & Configuration . UI_MODE_NIGHT_MASK ; if ( isAmoledTheme && currentMode == Configuration . UI_MODE_NIGHT_YES ) {", "output": "activity . setTheme ( Utils . androidVersion ( ) >= Build . VERSION_CODES . S ? R . style . ThemeOverlay_aShellYou_AmoledTheme : R . style . ThemeOverlay_aShellYou_AmoledThemeBelowV31 ) ; } else { activity . setTheme ( R . style . aShellYou_AppTheme ) ; } } public static int colorError ( Context context ) { TypedValue typedValue = new TypedValue ( ) ; context . getTheme ( ) . resolveAttribute ( android . R . attr . colorError , typedValue , true ) ; int colorError = typedValue . data ; return colorError ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import com . google . mlkit . vision . barcode . common . Barcode ; import java . util . List ; public interface ReadBarcodesFromImageResultCallback { void success ( List < Barcode > barcodes ) ; void error ( Exception exception ) ;", "output": "}"}, {"input": "package org . woheller69 . weather . ui . updater ; import org . woheller69 . weather . database . CurrentWeatherData ; import org . woheller69 . weather . database . HourlyForecast ; import org . woheller69 . weather . database . WeekForecast ; import java . util . List ; public interface IUpdateableCityUI {", "output": "void processNewCurrentWeatherData ( CurrentWeatherData data ) ; void processNewForecasts ( List < HourlyForecast > hourlyForecasts ) ; void processNewWeekForecasts ( List < WeekForecast > forecasts ) ; }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud ; import static android . view . KeyEvent . KEYCODE_BACK ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . os . Bundle ; import android . util . Log ; import android . view . KeyEvent ; import android . view . MenuItem ; import android . webkit . CookieManager ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . ProgressBar ; import androidx . appcompat . app . AppCompatActivity ; public class WebViewLoginActivity extends AppCompatActivity { WebView webView ; public Context context ; Config config ; ProgressBar progressBar ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_web_view_login ) ; progressBar = findViewById ( R . id . progressBar ) ; context = this ; config = new Config ( context ) ; webView = findViewById ( R . id . web_view ) ; webView . loadUrl ( \"<STR_LIT>\" ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } @ Override public void onPageFinished ( WebView view , String url ) { CookieManager cookieManager = CookieManager . getInstance ( ) ; String cookieStr = cookieManager . getCookie ( url ) ; if ( cookieStr != null ) { Log . i ( \"<STR_LIT>\" , \"<STR_LIT>\" + cookieStr ) ; if ( cookieStr . contains ( \"<STR_LIT>\" ) ) { new AlertDialog . Builder ( context ) . setTitle ( \"<STR_LIT>\" ) . setMessage ( cookieStr ) . setPositiveButton ( \"<STR_LIT>\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { onCookieSet ( cookieStr ) ; finish ( ) ; } } ) . setNegativeButton ( \"<STR_LIT>\" , new VoidDialogInterfaceOnClickListener ( ) ) . setNeutralButton ( \"<STR_LIT>\" , ( dialog , which ) -> { cookieManager . removeAllCookies ( value -> { } ) ; finish ( ) ; }", "output": ") . show ( ) ; } } super . onPageFinished ( view , url ) ; } } ) ; webView . setWebChromeClient ( new WebChromeClient ( ) { @ Override public void onProgressChanged ( WebView view , int newProgress ) { super . onProgressChanged ( view , newProgress ) ; progressBar . setProgress ( newProgress ) ; if ( newProgress == <NUM_LIT> ) { progressBar . setProgress ( <NUM_LIT> ) ; } } } ) ; } protected void onCookieSet ( String cookie ) { config . setCookie ( cookie ) ; } public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( ( keyCode == KEYCODE_BACK ) && webView . canGoBack ( ) ) { if ( webView . canGoBack ( ) ) { webView . goBack ( ) ; return true ; } else { finish ( ) ; return true ; } } return super . onKeyDown ( keyCode , event ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { if ( item . getItemId ( ) == <NUM_LIT> ) { finish ( ) ; } return true ; } @ Override protected void onDestroy ( ) { if ( webView != null ) { webView . clearHistory ( ) ; webView . destroy ( ) ; webView = null ; } super . onDestroy ( ) ; } }"}, {"input": "package com . reactnative . wheelpicker ; import android . content . Context ; import android . view . Gravity ; import android . widget . FrameLayout ; import androidx . annotation . NonNull ; import com . facebook . react . bridge . Arguments ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . bridge . WritableMap ; import com . facebook . react . uimanager . events . RCTEventEmitter ; import com . reactnative . wheelpicker . wheel . OnItemSelectedListener ; import com . reactnative . wheelpicker . wheel . WheelAdapter ; import com . reactnative . wheelpicker . wheel . WheelView ; import java . util . Collections ; import java . util . List ; public class PickerView extends FrameLayout implements WheelAdapter , OnItemSelectedListener { final WheelView wheelView ; public PickerView ( @ NonNull Context context ) { super ( context ) ; wheelView = new WheelView ( context ) ; LayoutParams layoutParams = new LayoutParams ( - <NUM_LIT> , - <NUM_LIT> ) ; layoutParams . gravity = Gravity . CENTER ; addView ( wheelView , layoutParams ) ; wheelView . setTextXOffset ( <NUM_LIT> ) ; wheelView . setAdapter ( this ) ; wheelView . setOnItemSelectedListener ( this ) ; wheelView . setCyclic ( false ) ; setClipChildren ( true ) ; } List < String > items = Collections . emptyList ( ) ; public void setItems ( List < String > items ) { this . items = items ; wheelView . setAdapter ( this ) ; if ( items . size ( ) > selectedIndex ) { wheelView . setCurrentItem ( selectedIndex ) ; } } int selectedIndex = <NUM_LIT> ; public void setSelectedItem ( int index ) { selectedIndex = index ; if ( items . size ( ) > index ) { wheelView . setCurrentItem ( index ) ; } } public void setCyclic ( boolean cyclic ) { wheelView . setCyclic ( cyclic ) ; } public void setTextSize ( int size ) { wheelView . setTextSize ( size ) ; } public void setItemHeight ( float height ) { wheelView . setItemHeight ( height ) ; } public void setTextColorOut ( int textColorOut ) { wheelView . setTextColorOut ( textColorOut ) ; }", "output": "public void setTextColorCenter ( int textColorCenter ) { wheelView . setTextColorCenter ( textColorCenter ) ; } @ Override public int getItemsCount ( ) { return items . size ( ) ; } @ Override public Object getItem ( int index ) { return items . get ( index ) ; } @ Override public int indexOf ( Object o ) { return items . indexOf ( o ) ; } @ Override public void onItemSelected ( int index ) { if ( getItemsCount ( ) > index ) { WritableMap event = Arguments . createMap ( ) ; event . putInt ( \"<STR_LIT>\" , index ) ; ReactContext reactContext = ( ReactContext ) getContext ( ) ; reactContext . getJSModule ( RCTEventEmitter . class ) . receiveEvent ( getId ( ) , \"<STR_LIT>\" , event ) ; } } }"}, {"input": "package com . wmods . wppenhacer . activities ; import android . annotation . SuppressLint ; import android . app . AlertDialog ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . Menu ; import android . view . MenuItem ; import android . view . ViewGroup ; import android . webkit . WebChromeClient ; import android . webkit . WebView ; import android . webkit . WebViewClient ; import android . widget . EditText ; import android . widget . LinearLayout ; import android . widget . Toast ; import androidx . activity . result . ActivityResultLauncher ; import androidx . activity . result . contract . ActivityResultContracts ; import androidx . annotation . NonNull ; import androidx . appcompat . app . AppCompatActivity ; import androidx . preference . PreferenceManager ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . preference . ThemePreference ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CompletableFuture ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import kotlin . io . FilesKt ; import rikka . core . util . IOUtils ; public class TextEditorActivity extends AppCompatActivity { private String folderName ; private ActivityResultLauncher < String > mGetContent ; private ActivityResultLauncher < String > mExportFile ; private WebView webView ; @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void onCreate ( Bundle savedInstanceState ) { getTheme ( ) . applyStyle ( rikka . material . preference . R . style . ThemeOverlay_Rikka_Material3_Preference , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay , true ) ; getTheme ( ) . applyStyle ( R . style . ThemeOverlay_MaterialGreen , true ) ; super . onCreate ( savedInstanceState ) ; webView = new WebView ( this ) ; webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; webView . getSettings ( ) . setAllowContentAccess ( true ) ; webView . getSettings ( ) . setDomStorageEnabled ( true ) ; webView . getSettings ( ) . setAllowUniversalAccessFromFileURLs ( true ) ; webView . getSettings ( ) . setJavaScriptCanOpenWindowsAutomatically ( true ) ; webView . setWebViewClient ( new WebViewClient ( ) ) ; webView . setWebChromeClient ( new WebChromeClient ( ) ) ; updateWebViewContent ( \"<STR_LIT>\" ) ; setContentView ( webView , new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; mGetContent = registerForActivityResult ( new ActivityResultContracts . GetContent ( ) , this :: onUriSelected ) ; mExportFile = registerForActivityResult ( new ActivityResultContracts . CreateDocument ( \"<STR_LIT>\" ) , this :: exportAsZip ) ; folderName = getIntent ( ) . getStringExtra ( \"<STR_LIT>\" ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { readFile ( folderName ) ; } } @ SuppressLint ( \"<STR_LIT>\" ) private void updateWebViewContent ( String newContent ) { if ( webView != null ) { try { var inputStream = getAssets ( ) . open ( \"<STR_LIT>\" ) ; var code = IOUtils . toString ( inputStream ) ; code = code . replace ( \"<STR_LIT>\" , newContent ) ; webView . loadDataWithBaseURL ( \"<STR_LIT>\" , code , \"<STR_LIT>\" , \"<STR_LIT>\" , null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } private CompletableFuture < String > getTextareaContentAsync ( ) { CompletableFuture < String > future = new CompletableFuture < > ( ) ; if ( webView != null ) { webView . evaluateJavascript ( \"<STR_LIT>\" , content -> { if ( content != null ) { content = content . substring ( <NUM_LIT> , content . length ( ) - <NUM_LIT> ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } future . complete ( content ) ; } ) ; } else { future . completeExceptionally ( new Exception ( \"<STR_LIT>\" ) ) ; } return future ; } private void readFile ( String folderName ) { try { File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , \"<STR_LIT>\" ) ; if ( cssCode . exists ( ) ) { var code = FilesKt . readText ( cssCode , Charset . defaultCharset ( ) ) ; updateWebViewContent ( code ) ; } else { cssCode . createNewFile ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . css_editor_menu , menu ) ; return super . onCreateOptionsMenu ( menu ) ; } @ SuppressLint ( \"<STR_LIT>\" ) @ Override public boolean onOptionsItemSelected ( @ NonNull MenuItem item ) { switch ( item . getItemId ( ) ) {", "output": "case R . id . menuitem_save -> { try { getTextareaContentAsync ( ) . thenAccept ( content -> { String code = content ; File folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; File cssCode = new File ( folderFolder , \"<STR_LIT>\" ) ; FilesKt . writeText ( cssCode , code , Charset . defaultCharset ( ) ) ; Toast . makeText ( this , R . string . saved , Toast . LENGTH_SHORT ) . show ( ) ; var prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; var key = getIntent ( ) . getStringExtra ( \"<STR_LIT>\" ) ; if ( key != null && prefs . getString ( key , \"<STR_LIT>\" ) . equals ( folderName ) ) { prefs . edit ( ) . putString ( \"<STR_LIT>\" , code ) . commit ( ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } case R . id . menuitem_exit -> finish ( ) ; case R . id . menuitem_clear -> { updateWebViewContent ( \"<STR_LIT>\" ) ; } case R . id . menuitem_import_image -> { mGetContent . launch ( \"<STR_LIT>\" ) ; } case R . id . menuitem_export -> { mExportFile . launch ( folderName + \"<STR_LIT>\" ) ; } } return super . onOptionsItemSelected ( item ) ; } private void exportAsZip ( Uri uri ) { try ( var outputStream = getContentResolver ( ) . openOutputStream ( uri ) ) { var zipOutputStream = new ZipOutputStream ( outputStream ) ; var dir = ThemePreference . rootDirectory . getAbsolutePath ( ) + \"<STR_LIT>\" ; var folderFolder = new File ( ThemePreference . rootDirectory , folderName ) ; var files = getAllFilesPath ( folderFolder ) ; for ( File file : files ) { var name = file . getAbsolutePath ( ) . replace ( dir , \"<STR_LIT>\" ) ; zipOutputStream . putNextEntry ( new ZipEntry ( name ) ) ; var bytes = FilesKt . readBytes ( file ) ; zipOutputStream . write ( bytes ) ; zipOutputStream . closeEntry ( ) ; } zipOutputStream . close ( ) ; Toast . makeText ( this , R . string . exported , Toast . LENGTH_SHORT ) . show ( ) ; } catch ( Exception e ) { Utils . showToast ( \"<STR_LIT>\" + e . getMessage ( ) , <NUM_LIT> ) ; } } private List < File > getAllFilesPath ( File folderFolder ) { File [ ] files = folderFolder . listFiles ( ) ; if ( files == null ) { return Collections . emptyList ( ) ; } ArrayList < File > list = new ArrayList < > ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { list . addAll ( getAllFilesPath ( file ) ) ; } else { list . add ( file ) ; } } return list ; } public void onUriSelected ( Uri uri ) { if ( uri == null ) { return ; } var linearLayout = new LinearLayout ( this ) ; linearLayout . setOrientation ( LinearLayout . VERTICAL ) ; linearLayout . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; var input = new EditText ( this ) ; input . setHint ( \"<STR_LIT>\" ) ; input . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; linearLayout . addView ( input ) ; new AlertDialog . Builder ( this ) . setTitle ( R . string . enter_image_file_name ) . setPositiveButton ( \"<STR_LIT>\" , ( dialog , which ) -> { var fileName = input . getText ( ) . toString ( ) ; if ( fileName . endsWith ( \"<STR_LIT>\" ) ) { copyFromUri ( fileName , uri ) ; } else { Toast . makeText ( this , R . string . error_image_name , Toast . LENGTH_SHORT ) . show ( ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . setView ( linearLayout ) . show ( ) ; } public void copyFromUri ( String fileName , Uri uri ) { var outFolder = new File ( ThemePreference . rootDirectory , folderName ) ; try ( InputStream inputStream = getContentResolver ( ) . openInputStream ( uri ) ) { Bitmap bitmap = BitmapFactory . decodeStream ( inputStream ) ; var outFile = new File ( outFolder , fileName ) ; FileOutputStream out = new FileOutputStream ( outFile ) ; bitmap . compress ( Bitmap . CompressFormat . PNG , <NUM_LIT> , out ) ; out . close ( ) ; Toast . makeText ( this , getString ( R . string . imported_as ) + fileName , Toast . LENGTH_LONG ) . show ( ) ; } catch ( Exception e ) { Toast . makeText ( this , \"<STR_LIT>\" + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } }"}, {"input": "package com . gw . swipeback . tools ; import android . app . Activity ; import android . app . Application ; import android . os . Bundle ; import java . util . Stack ; public class WxSwipeBackActivityManager extends ActivityLifecycleCallbacksAdapter { private static final WxSwipeBackActivityManager instance = new WxSwipeBackActivityManager ( ) ; private Stack < Activity > mActivityStack = new Stack < > ( ) ; private WxSwipeBackActivityManager ( ) { } public static WxSwipeBackActivityManager getInstance ( ) { return instance ; } public void init ( Application mApplication ) { mApplication . registerActivityLifecycleCallbacks ( this ) ; } @ Override public void onActivityCreated ( Activity activity , Bundle savedInstanceState ) {", "output": "mActivityStack . add ( activity ) ; } @ Override public void onActivityDestroyed ( Activity activity ) { mActivityStack . remove ( activity ) ; } public Activity getPenultimateActivity ( ) { return mActivityStack . size ( ) >= <NUM_LIT> ? mActivityStack . get ( mActivityStack . size ( ) - <NUM_LIT> ) : null ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . async . commentcheck ; import icu . freedomIntrovert . async . BackstageTask ; import icu . freedomIntrovert . biliSendCommAntifraud . Config ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiException ; import icu . freedomIntrovert . biliSendCommAntifraud . async . BiliBiliApiRequestHandler ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . CommentAddResult ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . GeneralResponse ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . CommentManipulator ; import icu . freedomIntrovert . biliSendCommAntifraud . comment . bean . HistoryComment ; import icu . freedomIntrovert . biliSendCommAntifraud . okretro . OkHttpUtil ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressBarDialog ; import icu . freedomIntrovert . biliSendCommAntifraud . view . ProgressTimer ; public class ResendCommentTask extends BackstageTask < ResendCommentTask . EventHandler > { private final CommentManipulator commentManipulator ; private final Config config ; private final String newCommentText ; private final HistoryComment historyComment ; public ResendCommentTask ( EventHandler handle , CommentManipulator commentManipulator , Config config , String newCommentText , HistoryComment historyComment ) { super ( handle ) ; this . commentManipulator = commentManipulator ; this . config = config ; this . newCommentText = newCommentText ; this . historyComment = historyComment ; } @ Override protected void onStart ( EventHandler eventHandler ) throws Throwable { GeneralResponse < CommentAddResult > body = commentManipulator . getSendCommentCall ( newCommentText , historyComment . parent , historyComment . root , historyComment . commentArea , false ) . execute ( ) . body ( ) ; OkHttpUtil . respNotNull ( body ) ; long waitTime = config . getWaitTime ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_SEND_SUCCESS_AND_SLEEP , waitTime ) ; if ( body . isSuccess ( ) ) { new ProgressTimer ( waitTime , ProgressBarDialog . DEFAULT_MAX_PROGRESS , ( progress , sleepSeg ) -> eventHandler . sendEventMessage ( EventHandler . WHAT_ON_NEW_PROGRESS , progress , sleepSeg , waitTime ) ) . start ( ) ; eventHandler . sendEventMessage ( EventHandler . WHAT_ON_RESENT_COMMENT , body . data ) ; } else { if ( body . code == <NUM_LIT> ) { eventHandler . sendEventMessage ( EventHandler . WHAT_ON_CONTAIN_SENSITIVE , body . message , newCommentText ) ; } else { eventHandler . sendError ( new BiliBiliApiException ( body , \"<STR_LIT>\" ) ) ; } } }", "output": "public static abstract class EventHandler extends BiliBiliApiRequestHandler { public static final int WHAT_ON_SEND_SUCCESS_AND_SLEEP = <NUM_LIT> ; public static final int WHAT_ON_NEW_PROGRESS = <NUM_LIT> ; public static final int WHAT_ON_RESENT_COMMENT = <NUM_LIT> ; public static final int WHAT_ON_CONTAIN_SENSITIVE = <NUM_LIT> ; public EventHandler ( ErrorHandle errorHandle ) { super ( errorHandle ) ; } } }"}, {"input": "package com . getcapacitor ; import static org . junit . Assert . * ; import org . junit . Test ; public class ExampleUnitTest { @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( <NUM_LIT> , <NUM_LIT> + <NUM_LIT> ) ;", "output": "} }"}, {"input": "package com . reactnative . nestedscroll ; import android . content . Context ; import android . view . View ; import android . view . ViewParent ; import androidx . annotation . NonNull ; import com . facebook . react . views . view . ReactViewGroup ; public class NestedScrollViewHeader extends ReactViewGroup { public final static int INVALID_STICKY_HEIGHT = - <NUM_LIT> ; public final static int INVALID_STICKY_BEGIN_INDEX = Integer . MAX_VALUE ; private int mStickyHeight = INVALID_STICKY_HEIGHT ; private int mStickyHeaderBeginIndex = INVALID_STICKY_BEGIN_INDEX ; private androidx . core . widget . NestedScrollView . OnScrollChangeListener mOnScrollChangeListener ; public NestedScrollViewHeader ( @ NonNull Context context ) { super ( context ) ; } public void setOnScrollChangeListener ( androidx . core . widget . NestedScrollView . OnScrollChangeListener onScrollChangeListener ) { this . mOnScrollChangeListener = onScrollChangeListener ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; NestedScrollView nestedScrollView = getParentNestedScrollView ( ) ; if ( nestedScrollView != null && mOnScrollChangeListener != null ) { nestedScrollView . setOnScrollChangeListener ( mOnScrollChangeListener ) ; } } @ Override protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; notifyStickyHeightChanged ( ) ; } public void setStickyHeight ( int stickyHeight ) { mStickyHeight = stickyHeight ; notifyStickyHeightChanged ( ) ; } public void setStickyHeaderBeginIndex ( int index ) { mStickyHeaderBeginIndex = index ; notifyStickyHeightChanged ( ) ; } public int getStickyHeight ( ) { if ( mStickyHeight >= <NUM_LIT> ) { return Math . min ( mStickyHeight , getHeight ( ) ) ; } if ( mStickyHeaderBeginIndex != INVALID_STICKY_BEGIN_INDEX ) { int stickyHeaderHeight = <NUM_LIT> ; for ( int i = <NUM_LIT> , count = getChildCount ( ) ; i < count ; i ++ ) { View child = getChildAt ( i ) ; int childHeight = i >= mStickyHeaderBeginIndex ? child . getHeight ( ) : <NUM_LIT> ; stickyHeaderHeight += childHeight ;", "output": "} return stickyHeaderHeight ; } return <NUM_LIT> ; } private void notifyStickyHeightChanged ( ) { NestedScrollView nestedScrollView = getParentNestedScrollView ( ) ; if ( nestedScrollView != null ) { nestedScrollView . notifyStickyHeightChanged ( ) ; } } private NestedScrollView getParentNestedScrollView ( ) { ViewParent parent = getParent ( ) ; if ( parent != null ) { parent = parent . getParent ( ) ; if ( parent instanceof NestedScrollView ) { return ( NestedScrollView ) parent ; } } return null ; } }"}, {"input": "package com . norman . webviewup . lib . service . interfaces ; import android . content . pm . PackageManager ; import com . norman . webviewup . lib . reflect . annotation . ClassName ; import com . norman . webviewup . lib . reflect . annotation . Field ; @ ClassName ( \"<STR_LIT>\" ) public interface IContextImpl { @ Field ( \"<STR_LIT>\" ) void setPackageManager ( PackageManager packageManager ) ;", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . xposed . hooks ; import android . app . Activity ; import android . content . Intent ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . Arrays ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; import icu . freedomIntrovert . biliSendCommAntifraud . xposed . BaseHook ; public class PostPictureHook extends BaseHook { @ Override public void startHook ( int appVersionCode , ClassLoader classLoader ) throws ClassNotFoundException { XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , android . content . Intent . class , int . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; int requestCode = ( Integer ) param . args [ <NUM_LIT> ] ; if ( requestCode == <NUM_LIT> ) { Intent newIntent = new Intent ( ) ; newIntent . setAction ( Intent . ACTION_PICK ) ; newIntent . setType ( \"<STR_LIT>\" ) ; param . args [ <NUM_LIT> ] = newIntent ; } } @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; } } ) ; XposedHelpers . findAndHookMethod ( \"<STR_LIT>\" , classLoader , \"<STR_LIT>\" , int . class , int . class , android . content . Intent . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; Activity activity = ( Activity ) param . thisObject ; Intent intent = ( Intent ) param . args [ <NUM_LIT> ] ; if ( ( Integer ) param . args [ <NUM_LIT> ] == <NUM_LIT> ) { if ( intent != null && intent . getData ( ) != null ) {", "output": "String fileName = \"<STR_LIT>\" + System . currentTimeMillis ( ) + \"<STR_LIT>\" ; try ( InputStream inputStream = activity . getContentResolver ( ) . openInputStream ( intent . getData ( ) ) ; FileOutputStream fos = new FileOutputStream ( fileName ) ) { if ( inputStream == null ) { XposedBridge . log ( \"<STR_LIT>\" ) ; return ; } byte [ ] buffer = new byte [ <NUM_LIT> ] ; int read ; while ( ( read = inputStream . read ( buffer ) ) > - <NUM_LIT> ) { fos . write ( buffer , <NUM_LIT> , read ) ; } XposedBridge . log ( \"<STR_LIT>\" ) ; } catch ( IOException e ) { XposedBridge . log ( \"<STR_LIT>\" + e ) ; } for ( Method declaredMethod : activity . getClass ( ) . getDeclaredMethods ( ) ) { Class < ? > [ ] parameterTypes = declaredMethod . getParameterTypes ( ) ; if ( Arrays . equals ( new Class [ ] { String . class } , parameterTypes ) ) { XposedHelpers . callMethod ( activity , declaredMethod . getName ( ) , fileName ) ; } } } else { activity . finish ( ) ; } } } } ) ; } }"}, {"input": "package androidx . fluidrecyclerview . widget ; import androidx . annotation . Nullable ; public interface ListUpdateCallback { void onInserted ( int position , int count ) ;", "output": "void onRemoved ( int position , int count ) ; void onMoved ( int fromPosition , int toPosition ) ; void onChanged ( int position , int count , @ Nullable Object payload ) ; }"}, {"input": "package in . hridayan . ashell . utils ; import androidx . annotation . Nullable ; import android . content . Context ; import android . content . SharedPreferences ; import android . graphics . drawable . Drawable ; import androidx . annotation . DrawableRes ; import androidx . core . content . ContextCompat ; import androidx . preference . PreferenceManager ; public class SettingsItem { private int symbolResId ; private String description , title , id ; private boolean hasSwitch , isChecked ; public SettingsItem ( String id , @ Nullable @ DrawableRes int symbolResId , String title , String description , boolean hasSwitch , boolean isChecked ) { this . id = id ; this . symbolResId = symbolResId ; this . title = title ; this . description = description ; this . hasSwitch = hasSwitch ; this . isChecked = isChecked ; } public String getId ( ) { return id ; } public Drawable getSymbol ( Context context ) { return ContextCompat . getDrawable ( context , symbolResId ) ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public boolean hasSwitch ( ) { return hasSwitch ; } public boolean isChecked ( ) { return isChecked ; } public void setChecked ( boolean isChecked ) { this . isChecked = isChecked ; } public void saveSwitchState ( Context context ) {", "output": "SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( id , isChecked ) ; editor . apply ( ) ; } public void loadSwitchState ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; isChecked = prefs . getBoolean ( id , false ) ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer . droidcore ; import android . os . Parcel ; import android . os . Parcelable ; public class Error implements Parcelable { public static final int CODE_IOEXCEPTION = <NUM_LIT> ; public static final int CODE_PORT_IS_OCCUPIED = <NUM_LIT> ; protected int errorCode ; protected String exceptionMessage ; public Error ( int errorCode , String exceptionMessage ) { this . errorCode = errorCode ; this . exceptionMessage = exceptionMessage ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeInt ( this . errorCode ) ; dest . writeString ( this . exceptionMessage ) ; } public void readFromParcel ( Parcel source ) { this . errorCode = source . readInt ( ) ; this . exceptionMessage = source . readString ( ) ; } protected Error ( Parcel in ) { this . errorCode = in . readInt ( ) ; this . exceptionMessage = in . readString ( ) ; } public static final Parcelable . Creator < Error > CREATOR = new Parcelable . Creator < Error > ( ) { @ Override public Error createFromParcel ( Parcel source ) { return new Error ( source ) ; } @ Override public Error [ ] newArray ( int size ) { return new Error [ size ] ; } } ; public int getErrorCode ( ) { return errorCode ; } public String getExceptionMessage ( ) { return exceptionMessage ; }", "output": "}"}, {"input": "package com . wmods . wppenhacer . preference ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Build ; import android . os . Environment ; import android . text . TextUtils ; import android . util . AttributeSet ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . LinearLayout ; import android . widget . TextView ; import androidx . annotation . RequiresApi ; import androidx . core . content . ContextCompat ; import androidx . preference . Preference ; import androidx . preference . PreferenceManager ; import com . google . android . material . dialog . MaterialAlertDialogBuilder ; import com . wmods . wppenhacer . FilePicker ; import com . wmods . wppenhacer . R ; import com . wmods . wppenhacer . activities . TextEditorActivity ; import com . wmods . wppenhacer . xposed . utils . Utils ; import java . io . File ; import java . nio . charset . Charset ; import java . nio . file . Files ; import java . nio . file . StandardCopyOption ; import java . util . ArrayList ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import kotlin . io . FilesKt ; public class ThemePreference extends Preference implements FilePicker . OnUriPickedListener { public static File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , \"<STR_LIT>\" ) ; private androidx . appcompat . app . AlertDialog mainDialog ; public ThemePreference ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; setPersistent ( false ) ; } @ Override protected void onClick ( ) { super . onClick ( ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { if ( Environment . isExternalStorageManager ( ) ) { showThemeDialog ( ) ; } else { showAlertPermission ( ) ; } } else { showThemeDialog ( ) ; } } @ RequiresApi ( api = Build . VERSION_CODES . R ) private void showAlertPermission ( ) { MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( getContext ( ) ) ; builder . setTitle ( R . string . storage_permission ) ; builder . setMessage ( R . string . permission_storage ) ; builder . setPositiveButton ( R . string . allow , ( dialog , which ) -> { Intent intent = new Intent ( android . provider . Settings . ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; intent . setData ( Uri . fromParts ( \"<STR_LIT>\" , getContext ( ) . getPackageName ( ) , null ) ) ; getContext ( ) . startActivity ( intent ) ; } ) ; builder . setNegativeButton ( R . string . deny , ( dialog , which ) -> dialog . dismiss ( ) ) ; builder . show ( ) ;", "output": "} @ SuppressLint ( \"<STR_LIT>\" ) private void showThemeDialog ( ) { final Context context = getContext ( ) ; List < String > folders = getFolders ( ) ; folders . add ( <NUM_LIT> , \"<STR_LIT>\" ) ; var folder_name = getSharedPreferences ( ) . getString ( getKey ( ) , null ) ; MaterialAlertDialogBuilder builder = new MaterialAlertDialogBuilder ( context ) ; View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . preference_theme , null ) ; builder . setView ( dialogView ) ; LinearLayout folderListContainer = dialogView . findViewById ( R . id . folder_list_container ) ; Button newTheme = dialogView . findViewById ( R . id . create_theme_button ) ; newTheme . setOnClickListener ( v -> showCreateNewThemeDialog ( ) ) ; Button importTheme = dialogView . findViewById ( R . id . import_theme_button ) ; importTheme . setOnClickListener ( v -> { FilePicker . setOnUriPickedListener ( this ) ; FilePicker . fileCapture . launch ( new String [ ] { \"<STR_LIT>\" } ) ; } ) ; for ( String folder : folders ) { View itemView = LayoutInflater . from ( context ) . inflate ( R . layout . item_folder , null , false ) ; TextView folderNameView = itemView . findViewById ( R . id . folder_name ) ; folderNameView . setText ( folder ) ; if ( folder . equals ( folder_name ) ) { folderNameView . setTextColor ( ContextCompat . getColor ( context , R . color . md_theme_material_green_dark_onPrimaryContainer ) ) ; } itemView . setOnClickListener ( v -> { var sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( context ) ; sharedPreferences . edit ( ) . putString ( getKey ( ) , folder ) . commit ( ) ; var cssFile = new File ( rootDirectory , folder + \"<STR_LIT>\" ) ; if ( cssFile . exists ( ) ) { var code = FilesKt . readText ( cssFile , Charset . defaultCharset ( ) ) ; sharedPreferences . edit ( ) . putString ( \"<STR_LIT>\" , code ) . commit ( ) ; } else { sharedPreferences . edit ( ) . putString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . commit ( ) ; } mainDialog . dismiss ( ) ; } ) ; ImageButton editButton = itemView . findViewById ( R . id . edit_button ) ; if ( folder . equals ( \"<STR_LIT>\" ) ) { editButton . setVisibility ( View . INVISIBLE ) ; } else { editButton . setOnClickListener ( v -> { Intent intent = new Intent ( context , TextEditorActivity . class ) ; intent . putExtra ( \"<STR_LIT>\" , folder ) ; intent . putExtra ( \"<STR_LIT>\" , getKey ( ) ) ; ContextCompat . startActivity ( context , intent , null ) ; } ) ; } folderListContainer . addView ( itemView ) ; } mainDialog = builder . show ( ) ; } private List < String > getFolders ( ) { List < String > folderNames = new ArrayList < > ( ) ; File [ ] folders = rootDirectory . listFiles ( File :: isDirectory ) ; if ( folders != null ) { for ( File folder : folders ) { folderNames . add ( folder . getName ( ) ) ; } } return folderNames ; } private void showCreateNewThemeDialog ( ) { final Context context = getContext ( ) ; final EditText input = new EditText ( context ) ; new MaterialAlertDialogBuilder ( context ) . setTitle ( R . string . new_theme_name ) . setView ( input ) . setPositiveButton ( R . string . create , ( dialog , whichButton ) -> { String folderName = input . getText ( ) . toString ( ) ; if ( ! TextUtils . isEmpty ( folderName ) ) { createNewFolder ( folderName ) ; } } ) . setNegativeButton ( R . string . cancel , null ) . show ( ) ; } private void createNewFolder ( String folderName ) { File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , \"<STR_LIT>\" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) { if ( newFolder . mkdirs ( ) ) { mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } } } @ Override public void onUriPicked ( Uri uri ) { if ( uri == null ) return ; try ( var inputStream = getContext ( ) . getContentResolver ( ) . openInputStream ( uri ) ) { var zipInputStream = new ZipInputStream ( inputStream ) ; ZipEntry zipEntry = zipInputStream . getNextEntry ( ) ; if ( zipEntry == null ) { Utils . showToast ( getContext ( ) . getString ( R . string . invalid_zip_file ) , <NUM_LIT> ) ; return ; } do { var name = zipEntry . getName ( ) ; if ( ! name . contains ( \"<STR_LIT>\" ) ) { continue ; } var folderName = name . substring ( <NUM_LIT> , name . lastIndexOf ( '<STR_LIT>' ) ) ; File rootDirectory = new File ( Environment . getExternalStorageDirectory ( ) , \"<STR_LIT>\" ) ; File newFolder = new File ( rootDirectory , folderName ) ; if ( ! newFolder . exists ( ) ) newFolder . mkdirs ( ) ; var file = new File ( rootDirectory , name ) ; Files . copy ( zipInputStream , file . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; zipEntry = zipInputStream . getNextEntry ( ) ; } while ( zipEntry != null ) ; Utils . showToast ( getContext ( ) . getString ( R . string . theme_imported_successfully ) , <NUM_LIT> ) ; mainDialog . dismiss ( ) ; showThemeDialog ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package com . reactnative . pulltorefresh ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . facebook . react . bridge . ReadableArray ; import com . facebook . react . bridge . ReadableType ; import com . facebook . react . common . MapBuilder ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . ThemedReactContext ; import com . facebook . react . uimanager . UIManagerHelper ; import com . facebook . react . uimanager . annotations . ReactProp ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; import com . facebook . react . views . view . ReactViewManager ; import com . reactnative . pulltorefresh . event . OffsetChangedEvent ; import com . reactnative . pulltorefresh . event . RefreshEvent ; import com . reactnative . pulltorefresh . event . StateChangedEvent ; import java . util . Map ; public class PullToRefreshFooterManager extends ReactViewManager { public final static String REACT_CLASS = \"<STR_LIT>\" ; @ NonNull @ Override public String getName ( ) { return REACT_CLASS ; } @ NonNull @ Override public ReactViewGroup createViewInstance ( ThemedReactContext context ) { return new PullToRefreshFooter ( context ) ; } @ Override public LayoutShadowNode createShadowNodeInstance ( ) { return new PullToRefreshFooterShadowNode ( ) ; } @ Override public Class < ? extends LayoutShadowNode > getShadowNodeClass ( ) { return PullToRefreshFooterShadowNode . class ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setRefreshing ( PullToRefreshFooter footer , boolean refreshing ) { footer . setLoadingMore ( refreshing ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setNoMoreData ( PullToRefreshFooter footer , boolean noMoreData ) { footer . setNoMoreData ( noMoreData ) ; } @ ReactProp ( name = \"<STR_LIT>\" ) public void setManual ( PullToRefreshFooter footer , boolean manual ) { footer . setAutoLoadMore ( ! manual ) ; } @ Nullable @ Override public Map < String , Object > getExportedCustomDirectEventTypeConstants ( ) { return MapBuilder . < String , Object > builder ( ) . put ( RefreshEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , RefreshEvent . JSEventName ) ) . put ( StateChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , StateChangedEvent . JSEventName ) ) . put ( OffsetChangedEvent . Name , MapBuilder . of ( \"<STR_LIT>\" , OffsetChangedEvent . JSEventName ) ) . build ( ) ; } @ Override public void receiveCommand ( ReactViewGroup root , String commandId , @ Nullable ReadableArray args ) { if ( root instanceof PullToRefreshFooter ) { PullToRefreshFooter footer = ( PullToRefreshFooter ) root ; if ( \"<STR_LIT>\" . equals ( commandId ) ) { if ( args != null && args . getType ( <NUM_LIT> ) == ReadableType . Boolean ) { footer . setLoadingMore ( args . getBoolean ( <NUM_LIT> ) ) ; } } } } @ Override protected void addEventEmitters ( @ NonNull ThemedReactContext reactContext , @ NonNull ReactViewGroup view ) { super . addEventEmitters ( reactContext , view ) ; if ( view instanceof PullToRefreshFooter ) { PullToRefreshFooter pullToRefreshFooter = ( ( PullToRefreshFooter ) view ) ; int surfaceId = UIManagerHelper . getSurfaceId ( reactContext ) ; int viewId = view . getId ( ) ; pullToRefreshFooter . setOnRefreshHeaderChangeListener ( new OnRefreshChangeListener ( ) { @ Override public void onRefresh ( ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new RefreshEvent ( surfaceId , viewId ) ) ; } } } @ Override public void onOffsetChange ( int offset ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new OffsetChangedEvent ( surfaceId , viewId , offset ) ) ;", "output": "} } } @ Override public void onStateChanged ( PullToRefreshState state ) { if ( reactContext . hasActiveReactInstance ( ) ) { EventDispatcher eventDispatcher = UIManagerHelper . getEventDispatcherForReactTag ( reactContext , viewId ) ; if ( eventDispatcher != null ) { eventDispatcher . dispatchEvent ( new StateChangedEvent ( surfaceId , viewId , state ) ) ; } } } } ) ; } } }"}, {"input": "package com . reactnative . wheelpicker . wheel ; import android . os . Handler ; import android . os . Message ; public final class MessageHandler extends Handler { public static final int WHAT_INVALIDATE_LOOP_VIEW = <NUM_LIT> ; public static final int WHAT_SMOOTH_SCROLL = <NUM_LIT> ; public static final int WHAT_ITEM_SELECTED = <NUM_LIT> ; private final WheelView wheelView ; public MessageHandler ( WheelView wheelView ) { this . wheelView = wheelView ; }", "output": "@ Override public final void handleMessage ( Message msg ) { switch ( msg . what ) { case WHAT_INVALIDATE_LOOP_VIEW : wheelView . invalidate ( ) ; break ; case WHAT_SMOOTH_SCROLL : wheelView . smoothScroll ( WheelView . ACTION . FLING ) ; break ; case WHAT_ITEM_SELECTED : wheelView . onItemSelected ( ) ; break ; } } }"}, {"input": "package com . norman . webviewup . demo ; import android . app . Application ; public class MyApp extends Application { @ Override public void onCreate ( ) { super . onCreate ( ) ;", "output": "} }"}, {"input": "package com . reactnative . nestedscroll ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . widget . ScrollView ; import android . widget . Scroller ; import androidx . core . view . ViewCompat ; public class NestedScrollFlingHelper { private final NestedScrollView mNestedScrollView ; private final Scroller mScroller ; private ViewGroup mTarget ; private int mLastScrollerY = <NUM_LIT> ; public NestedScrollFlingHelper ( NestedScrollView nestedScrollView ) { mNestedScrollView = nestedScrollView ; mScroller = new Scroller ( nestedScrollView . getContext ( ) ) ; } public boolean onNestedPreFling ( View target , float velocityY ) { mTarget = findScrollableView ( target ) ; if ( mTarget != null && mTarget . getChildCount ( ) > <NUM_LIT> ) { mScroller . fling ( mTarget . getScrollX ( ) , mTarget . getScrollY ( ) , <NUM_LIT> , ( int ) velocityY , <NUM_LIT> , <NUM_LIT> , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; runAnimatedScroll ( ) ; return true ; } return false ; } private ViewGroup findScrollableView ( View target ) { if ( ! ( target instanceof ViewGroup ) ) { return null ; } ViewGroup viewGroup = ( ViewGroup ) target ; if ( viewGroup instanceof ScrollView ) { return viewGroup ; } ViewGroup scrollableView ; if ( viewGroup . getChildCount ( ) > <NUM_LIT> ) { int size = viewGroup . getChildCount ( ) ;", "output": "for ( int i = size - <NUM_LIT> ; i > - <NUM_LIT> ; i -- ) { View child = viewGroup . getChildAt ( i ) ; scrollableView = findScrollableView ( child ) ; if ( scrollableView != null ) { return scrollableView ; } } } return null ; } private void runAnimatedScroll ( ) { mLastScrollerY = mTarget . getScrollY ( ) ; ViewCompat . postInvalidateOnAnimation ( mNestedScrollView ) ; } public void computeScroll ( ) { if ( mScroller . isFinished ( ) ) { return ; } mScroller . computeScrollOffset ( ) ; final int y = mScroller . getCurrY ( ) ; int unconsumed = y - mLastScrollerY ; mLastScrollerY = y ; if ( unconsumed > <NUM_LIT> ) { unconsumed = scrollBy ( unconsumed , mNestedScrollView ) ; } unconsumed = scrollBy ( unconsumed , mTarget ) ; if ( unconsumed < <NUM_LIT> ) { unconsumed = scrollBy ( unconsumed , mNestedScrollView ) ; } if ( unconsumed != <NUM_LIT> ) { abortAnimatedScroll ( ) ; } if ( ! mScroller . isFinished ( ) ) { ViewCompat . postInvalidateOnAnimation ( mNestedScrollView ) ; } } private int scrollBy ( int unconsumed , View view ) { final int oldScrollY = view . getScrollY ( ) ; view . scrollBy ( <NUM_LIT> , unconsumed ) ; final int myConsumed = view . getScrollY ( ) - oldScrollY ; unconsumed -= myConsumed ; return unconsumed ; } private void abortAnimatedScroll ( ) { mScroller . abortAnimation ( ) ; } public void dispatchTouchEvent ( MotionEvent ev ) { final int actionMasked = ev . getActionMasked ( ) ; if ( actionMasked == MotionEvent . ACTION_DOWN ) { abortAnimatedScroll ( ) ; mTarget = null ; } } }"}, {"input": "package com . norman . webviewup . lib ; public interface UpgradeCallback { void onUpgradeProcess ( float percent ) ; void onUpgradeComplete ( ) ;", "output": "void onUpgradeError ( Throwable throwable ) ; }"}, {"input": "package com . wmods . wppenhacer . xposed . features . others ; import android . annotation . SuppressLint ; import android . view . Gravity ; import android . view . View ; import android . widget . ImageView ; import android . widget . LinearLayout ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . WppCore ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import com . wmods . wppenhacer . xposed . utils . ReflectionUtils ; import com . wmods . wppenhacer . xposed . utils . ResId ; import com . wmods . wppenhacer . xposed . utils . Utils ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class GroupAdmin extends Feature { public GroupAdmin ( @ NonNull ClassLoader classLoader , @ NonNull XSharedPreferences preferences ) { super ( classLoader , preferences ) ; } @ Override public void doHook ( ) throws Throwable { if ( ! prefs . getBoolean ( \"<STR_LIT>\" , false ) ) return ; var jidFactory = Unobfuscator . loadJidFactory ( classLoader ) ; var grpAdmin1 = Unobfuscator . loadGroupAdminMethod ( classLoader ) ; var grpcheckAdmin = Unobfuscator . loadGroupCheckAdminMethod ( classLoader ) ; var hooked = new XC_MethodHook ( ) { @ SuppressLint ( \"<STR_LIT>\" ) @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { var fMessage = XposedHelpers . callMethod ( param . thisObject , \"<STR_LIT>\" ) ; var userJidClass = XposedHelpers . findClass ( \"<STR_LIT>\" , classLoader ) ; var methodResult = ReflectionUtils . findMethodUsingFilter ( fMessage . getClass ( ) , method -> method . getReturnType ( ) == userJidClass && method . getParameterCount ( ) == <NUM_LIT> ) ; var userJid = ReflectionUtils . callMethod ( methodResult , fMessage ) ; var chatCurrentJid = WppCore . getCurrentRawJID ( ) ; if ( ! WppCore . isGroup ( chatCurrentJid ) ) return ; var field = ReflectionUtils . getFieldByType ( param . thisObject . getClass ( ) , grpcheckAdmin . getDeclaringClass ( ) ) ; var grpParticipants = field . get ( param . thisObject ) ; var jidGrp = jidFactory . invoke ( null , chatCurrentJid ) ; var result = ReflectionUtils . callMethod ( grpcheckAdmin , grpParticipants , jidGrp , userJid ) ; var view = ( View ) param . thisObject ; var context = view . getContext ( ) ; ImageView iconAdmin ; if ( ( iconAdmin = view . findViewById ( <NUM_LIT> ) ) == null ) { var nameGroup = ( LinearLayout ) view . findViewById ( Utils . getID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; var view1 = new LinearLayout ( context ) ; view1 . setOrientation ( LinearLayout . HORIZONTAL ) ; view1 . setGravity ( Gravity . CENTER_VERTICAL ) ; var nametv = nameGroup . getChildAt ( <NUM_LIT> ) ; iconAdmin = new ImageView ( context ) ; var size = Utils . dipToPixels ( <NUM_LIT> ) ; iconAdmin . setLayoutParams ( new LinearLayout . LayoutParams ( size , size ) ) ; iconAdmin . setImageResource ( ResId . drawable . admin ) ; iconAdmin . setId ( <NUM_LIT> ) ; nameGroup . removeView ( nametv ) ; view1 . addView ( nametv ) ; view1 . addView ( iconAdmin ) ;", "output": "nameGroup . addView ( view1 , <NUM_LIT> ) ; } iconAdmin . setVisibility ( result != null && ( boolean ) result ? View . VISIBLE : View . GONE ) ; } } ; XposedBridge . hookMethod ( grpAdmin1 , hooked ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . reactnative . pulltorefresh ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . NativeViewHierarchyOptimizer ; import com . facebook . yoga . YogaEdge ; import com . facebook . yoga . YogaPositionType ; public class PullToRefreshFooterShadowNode extends LayoutShadowNode { @ Override public void setLocalData ( Object data ) { super . setLocalData ( data ) ; if ( data instanceof PullToRefreshFooterLocalData ) { PullToRefreshFooterLocalData footerLocalData = ( PullToRefreshFooterLocalData ) data ; setStyleHeight ( footerLocalData . viewRect . bottom - footerLocalData . viewRect . top ) ; } } @ Override public void onBeforeLayout ( NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer ) { setPositionType ( YogaPositionType . ABSOLUTE ) ; setPosition ( YogaEdge . LEFT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . RIGHT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . BOTTOM . intValue ( ) , - getLayoutHeight ( ) ) ;", "output": "} }"}, {"input": "package com . appspa . update . widget ; import android . annotation . SuppressLint ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . RectF ; import android . os . Bundle ; import android . os . Parcelable ; import android . util . AttributeSet ; import android . view . View ; import com . appspa . update . R ; public class NumberProgressBar extends View { private static final String INSTANCE_STATE = \"<STR_LIT>\" ; private static final String INSTANCE_TEXT_COLOR = \"<STR_LIT>\" ; private static final String INSTANCE_TEXT_SIZE = \"<STR_LIT>\" ; private static final String INSTANCE_REACHED_BAR_HEIGHT = \"<STR_LIT>\" ; private static final String INSTANCE_REACHED_BAR_COLOR = \"<STR_LIT>\" ; private static final String INSTANCE_UNREACHED_BAR_HEIGHT = \"<STR_LIT>\" ; private static final String INSTANCE_UNREACHED_BAR_COLOR = \"<STR_LIT>\" ; private static final String INSTANCE_MAX = \"<STR_LIT>\" ; private static final String INSTANCE_PROGRESS = \"<STR_LIT>\" ; private static final String INSTANCE_SUFFIX = \"<STR_LIT>\" ; private static final String INSTANCE_PREFIX = \"<STR_LIT>\" ; private static final String INSTANCE_TEXT_VISIBILITY = \"<STR_LIT>\" ; private static final int PROGRESS_TEXT_VISIBLE = <NUM_LIT> ; private int mMaxProgress = <NUM_LIT> ; private int mCurrentProgress = <NUM_LIT> ; private int mReachedBarColor ; private int mUnreachedBarColor ; private int mTextColor ; private float mTextSize ; private float mReachedBarHeight ; private float mUnreachedBarHeight ; private String mSuffix = \"<STR_LIT>\" ; private String mPrefix = \"<STR_LIT>\" ; private float mDrawTextStart ; private float mDrawTextEnd ; private String mCurrentDrawText ; private Paint mReachedBarPaint ; private Paint mUnreachedBarPaint ; private Paint mTextPaint ; private RectF mUnreachedRectF = new RectF ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private RectF mReachedRectF = new RectF ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; private float mOffset ; private boolean mDrawUnreachedBar = true ; private boolean mDrawReachedBar = true ; private boolean mIfDrawText = true ; private OnProgressBarListener mListener ; public NumberProgressBar ( Context context ) { this ( context , null ) ; } public NumberProgressBar ( Context context , AttributeSet attrs ) { this ( context , attrs , <NUM_LIT> ) ; } public NumberProgressBar ( Context context , AttributeSet attrs , int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; float defaultReachedBarHeight = dp2px ( <NUM_LIT> ) ; float defaultUnreachedBarHeight = dp2px ( <NUM_LIT> ) ; float defaultTextSize = sp2px ( <NUM_LIT> ) ; float defaultProgressTextOffset = dp2px ( <NUM_LIT> ) ; final TypedArray attributes = context . getTheme ( ) . obtainStyledAttributes ( attrs , R . styleable . XNumberProgressBar , defStyleAttr , <NUM_LIT> ) ; int defaultReachedColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mReachedBarColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_reached_color , defaultReachedColor ) ; int defaultUnreachedColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mUnreachedBarColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_unreached_color , defaultUnreachedColor ) ; int defaultTextColor = Color . rgb ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; mTextColor = attributes . getColor ( R . styleable . XNumberProgressBar_xnpb_text_color , defaultTextColor ) ; mTextSize = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_text_size , defaultTextSize ) ; mReachedBarHeight = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_reached_bar_height , defaultReachedBarHeight ) ; mUnreachedBarHeight = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_unreached_bar_height , defaultUnreachedBarHeight ) ; mOffset = attributes . getDimension ( R . styleable . XNumberProgressBar_xnpb_text_offset , defaultProgressTextOffset ) ; int textVisible = attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_text_visibility , PROGRESS_TEXT_VISIBLE ) ; if ( textVisible != PROGRESS_TEXT_VISIBLE ) { mIfDrawText = false ; } setProgress ( attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_current , <NUM_LIT> ) ) ; setMax ( attributes . getInt ( R . styleable . XNumberProgressBar_xnpb_max , <NUM_LIT> ) ) ; attributes . recycle ( ) ; initializePainters ( ) ; } @ Override protected int getSuggestedMinimumWidth ( ) { return ( int ) mTextSize ; } @ Override protected int getSuggestedMinimumHeight ( ) { return Math . max ( ( int ) mTextSize , Math . max ( ( int ) mReachedBarHeight , ( int ) mUnreachedBarHeight ) ) ; } @ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( measure ( widthMeasureSpec , true ) , measure ( heightMeasureSpec , false ) ) ; } private int measure ( int measureSpec , boolean isWidth ) { int result ; int mode = MeasureSpec . getMode ( measureSpec ) ; int size = MeasureSpec . getSize ( measureSpec ) ; int padding = isWidth ? getPaddingLeft ( ) + getPaddingRight ( ) : getPaddingTop ( ) + getPaddingBottom ( ) ; if ( mode == MeasureSpec . EXACTLY ) { result = size ; } else { result = isWidth ? getSuggestedMinimumWidth ( ) : getSuggestedMinimumHeight ( ) ; result += padding ; if ( mode == MeasureSpec . AT_MOST ) { if ( isWidth ) { result = Math . max ( result , size ) ; } else { result = Math . min ( result , size ) ; } } } return result ; } @ Override protected void onDraw ( Canvas canvas ) { if ( mIfDrawText ) { calculateDrawRectF ( ) ; } else { calculateDrawRectFWithoutProgressText ( ) ; } if ( mDrawReachedBar ) { canvas . drawRect ( mReachedRectF , mReachedBarPaint ) ; } if ( mDrawUnreachedBar ) { canvas . drawRect ( mUnreachedRectF , mUnreachedBarPaint ) ; } if ( mIfDrawText ) { canvas . drawText ( mCurrentDrawText , mDrawTextStart , mDrawTextEnd , mTextPaint ) ; } } private void initializePainters ( ) { mReachedBarPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mReachedBarPaint . setColor ( mReachedBarColor ) ; mUnreachedBarPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mUnreachedBarPaint . setColor ( mUnreachedBarColor ) ; mTextPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mTextPaint . setColor ( mTextColor ) ; mTextPaint . setTextSize ( mTextSize ) ; } private void calculateDrawRectFWithoutProgressText ( ) { mReachedRectF . left = getPaddingLeft ( ) ; mReachedRectF . top = getHeight ( ) / <NUM_LIT> - mReachedBarHeight / <NUM_LIT> ; mReachedRectF . right = ( getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ) / ( getMax ( ) * <NUM_LIT> ) * getProgress ( ) + getPaddingLeft ( ) ; mReachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mReachedBarHeight / <NUM_LIT> ; mUnreachedRectF . left = mReachedRectF . right ; mUnreachedRectF . right = getWidth ( ) - getPaddingRight ( ) ; mUnreachedRectF . top = getHeight ( ) / <NUM_LIT> + - mUnreachedBarHeight / <NUM_LIT> ; mUnreachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mUnreachedBarHeight / <NUM_LIT> ; } @ SuppressLint ( \"<STR_LIT>\" ) private void calculateDrawRectF ( ) { mCurrentDrawText = String . format ( \"<STR_LIT>\" , getProgress ( ) * <NUM_LIT> / getMax ( ) ) ; mCurrentDrawText = mPrefix + mCurrentDrawText + mSuffix ; float drawTextWidth = mTextPaint . measureText ( mCurrentDrawText ) ; if ( getProgress ( ) == <NUM_LIT> ) { mDrawReachedBar = false ; mDrawTextStart = getPaddingLeft ( ) ; } else { mDrawReachedBar = true ; mReachedRectF . left = getPaddingLeft ( ) ; mReachedRectF . top = getHeight ( ) / <NUM_LIT> - mReachedBarHeight / <NUM_LIT> ; mReachedRectF . right = ( getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ) / ( getMax ( ) * <NUM_LIT> ) * getProgress ( ) - mOffset + getPaddingLeft ( ) ; mReachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mReachedBarHeight / <NUM_LIT> ; mDrawTextStart = ( mReachedRectF . right + mOffset ) ; } mDrawTextEnd = ( int ) ( ( getHeight ( ) / <NUM_LIT> ) - ( ( mTextPaint . descent ( ) + mTextPaint . ascent ( ) ) / <NUM_LIT> ) ) ; if ( ( mDrawTextStart + drawTextWidth ) >= getWidth ( ) - getPaddingRight ( ) ) { mDrawTextStart = getWidth ( ) - getPaddingRight ( ) - drawTextWidth ; mReachedRectF . right = mDrawTextStart - mOffset ; } float unreachedBarStart = mDrawTextStart + drawTextWidth + mOffset ; if ( unreachedBarStart >= getWidth ( ) - getPaddingRight ( ) ) { mDrawUnreachedBar = false ; } else { mDrawUnreachedBar = true ; mUnreachedRectF . left = unreachedBarStart ; mUnreachedRectF . right = getWidth ( ) - getPaddingRight ( ) ; mUnreachedRectF . top = getHeight ( ) / <NUM_LIT> + - mUnreachedBarHeight / <NUM_LIT> ; mUnreachedRectF . bottom = getHeight ( ) / <NUM_LIT> + mUnreachedBarHeight / <NUM_LIT> ; } } public int getTextColor ( ) { return mTextColor ; } public float getProgressTextSize ( ) { return mTextSize ; } public void setProgressTextSize ( float textSize ) { mTextSize = textSize ; mTextPaint . setTextSize ( mTextSize ) ; postInvalidate ( ) ; } public int getUnreachedBarColor ( ) { return mUnreachedBarColor ; } public void setUnreachedBarColor ( int barColor ) { mUnreachedBarColor = barColor ; mUnreachedBarPaint . setColor ( mUnreachedBarColor ) ; postInvalidate ( ) ; } public int getReachedBarColor ( ) { return mReachedBarColor ; } public void setReachedBarColor ( int progressColor ) { mReachedBarColor = progressColor ; mReachedBarPaint . setColor ( mReachedBarColor ) ; postInvalidate ( ) ; } public int getProgress ( ) { return mCurrentProgress ; } public void setProgress ( int progress ) { if ( progress <= getMax ( ) && progress >= <NUM_LIT> ) { mCurrentProgress = progress ; postInvalidate ( ) ; } } public int getMax ( ) { return mMaxProgress ; } public void setMax ( int maxProgress ) { if ( maxProgress > <NUM_LIT> ) { mMaxProgress = maxProgress ; postInvalidate ( ) ; } } public float getReachedBarHeight ( ) { return mReachedBarHeight ; } public void setReachedBarHeight ( float height ) { mReachedBarHeight = height ; } public float getUnreachedBarHeight ( ) { return mUnreachedBarHeight ; } public void setUnreachedBarHeight ( float height ) { mUnreachedBarHeight = height ; } public void setProgressTextColor ( int textColor ) { this . mTextColor = textColor ; mTextPaint . setColor ( mTextColor ) ; postInvalidate ( ) ; } public String getSuffix ( ) { return mSuffix ; } public void setSuffix ( String suffix ) { if ( suffix == null ) { mSuffix = \"<STR_LIT>\" ; } else { mSuffix = suffix ; } } public String getPrefix ( ) { return mPrefix ; } public void setPrefix ( String prefix ) { if ( prefix == null ) { mPrefix = \"<STR_LIT>\" ; } else { mPrefix = prefix ; }", "output": "} public void incrementProgressBy ( int by ) { if ( by > <NUM_LIT> ) { setProgress ( getProgress ( ) + by ) ; } if ( mListener != null ) { mListener . onProgressChange ( getProgress ( ) , getMax ( ) ) ; } } @ Override protected Parcelable onSaveInstanceState ( ) { final Bundle bundle = new Bundle ( ) ; bundle . putParcelable ( INSTANCE_STATE , super . onSaveInstanceState ( ) ) ; bundle . putInt ( INSTANCE_TEXT_COLOR , getTextColor ( ) ) ; bundle . putFloat ( INSTANCE_TEXT_SIZE , getProgressTextSize ( ) ) ; bundle . putFloat ( INSTANCE_REACHED_BAR_HEIGHT , getReachedBarHeight ( ) ) ; bundle . putFloat ( INSTANCE_UNREACHED_BAR_HEIGHT , getUnreachedBarHeight ( ) ) ; bundle . putInt ( INSTANCE_REACHED_BAR_COLOR , getReachedBarColor ( ) ) ; bundle . putInt ( INSTANCE_UNREACHED_BAR_COLOR , getUnreachedBarColor ( ) ) ; bundle . putInt ( INSTANCE_MAX , getMax ( ) ) ; bundle . putInt ( INSTANCE_PROGRESS , getProgress ( ) ) ; bundle . putString ( INSTANCE_SUFFIX , getSuffix ( ) ) ; bundle . putString ( INSTANCE_PREFIX , getPrefix ( ) ) ; bundle . putBoolean ( INSTANCE_TEXT_VISIBILITY , getProgressTextVisibility ( ) ) ; return bundle ; } @ Override protected void onRestoreInstanceState ( Parcelable state ) { if ( state instanceof Bundle ) { final Bundle bundle = ( Bundle ) state ; mTextColor = bundle . getInt ( INSTANCE_TEXT_COLOR ) ; mTextSize = bundle . getFloat ( INSTANCE_TEXT_SIZE ) ; mReachedBarHeight = bundle . getFloat ( INSTANCE_REACHED_BAR_HEIGHT ) ; mUnreachedBarHeight = bundle . getFloat ( INSTANCE_UNREACHED_BAR_HEIGHT ) ; mReachedBarColor = bundle . getInt ( INSTANCE_REACHED_BAR_COLOR ) ; mUnreachedBarColor = bundle . getInt ( INSTANCE_UNREACHED_BAR_COLOR ) ; initializePainters ( ) ; setMax ( bundle . getInt ( INSTANCE_MAX ) ) ; setProgress ( bundle . getInt ( INSTANCE_PROGRESS ) ) ; setPrefix ( bundle . getString ( INSTANCE_PREFIX ) ) ; setSuffix ( bundle . getString ( INSTANCE_SUFFIX ) ) ; setProgressTextVisibility ( bundle . getBoolean ( INSTANCE_TEXT_VISIBILITY ) ? ProgressTextVisibility . VISIBLE : ProgressTextVisibility . INVISIBLE ) ; super . onRestoreInstanceState ( bundle . getParcelable ( INSTANCE_STATE ) ) ; return ; } super . onRestoreInstanceState ( state ) ; } public float dp2px ( float dp ) { final float scale = getResources ( ) . getDisplayMetrics ( ) . density ; return dp * scale + <NUM_LIT> ; } public float sp2px ( float sp ) { final float scale = getResources ( ) . getDisplayMetrics ( ) . scaledDensity ; return sp * scale ; } public boolean getProgressTextVisibility ( ) { return mIfDrawText ; } public void setProgressTextVisibility ( ProgressTextVisibility visibility ) { mIfDrawText = visibility == ProgressTextVisibility . VISIBLE ; postInvalidate ( ) ; } public void setOnProgressBarListener ( OnProgressBarListener listener ) { mListener = listener ; } public enum ProgressTextVisibility { VISIBLE , INVISIBLE } public interface OnProgressBarListener { void onProgressChange ( int current , int max ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . ClipData ; import android . content . ClipboardManager ; import android . content . Context ; import android . content . Intent ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . net . Uri ; import android . util . Base64 ; import android . util . TypedValue ; import android . widget . Toast ; import java . util . Arrays ; public class GlobalUtils { public static int dpToPx ( Context context , int dp ) { return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , dp , context . getResources ( ) . getDisplayMetrics ( ) ) ; } public static Bitmap resizeBitmap ( Bitmap bitmap , int maxWidth , int maxHeight ) { int width = bitmap . getWidth ( ) ; int height = bitmap . getHeight ( ) ; float scale = <NUM_LIT> ;", "output": "if ( width > maxWidth || height > maxHeight ) scale = Math . min ( ( float ) maxWidth / width , ( float ) maxHeight / height ) ; return Bitmap . createScaledBitmap ( bitmap , ( int ) ( width * scale ) , ( int ) ( height * scale ) , true ) ; } public static Bitmap base64ToBitmap ( String base64 ) { byte [ ] bytes = Base64 . decode ( base64 , Base64 . NO_WRAP ) ; return BitmapFactory . decodeByteArray ( bytes , <NUM_LIT> , bytes . length ) ; } public static void browseURL ( Context context , String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; context . startActivity ( intent ) ; } public static void copyToClipboard ( Context context , String text ) { ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; ClipData clip = ClipData . newPlainText ( \"<STR_LIT>\" , text ) ; clipboard . setPrimaryClip ( clip ) ; } public static void showToast ( Context context , String text , boolean isLong ) { Toast . makeText ( context , text , isLong ? Toast . LENGTH_LONG : Toast . LENGTH_SHORT ) . show ( ) ; } public static void showToast ( Context context , int resId , boolean isLong ) { Toast . makeText ( context , resId , isLong ? Toast . LENGTH_LONG : Toast . LENGTH_SHORT ) . show ( ) ; } public static boolean checkVisionSupport ( String model ) { final String [ ] specialVisionModels = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; return model . contains ( \"<STR_LIT>\" ) || Arrays . asList ( specialVisionModels ) . contains ( model ) || model . endsWith ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . privacy ; import android . view . View ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . util . Objects ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class HideChat extends Feature { public static View . OnClickListener mClickListenerLocked ; public HideChat ( @ NonNull ClassLoader loader , @ NonNull XSharedPreferences preferences ) { super ( loader , preferences ) ;", "output": "} @ Override public void doHook ( ) throws Throwable { if ( ! Objects . equals ( prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ) { var archiveHideViewMethod = Unobfuscator . loadArchiveHideViewMethod ( classLoader ) ; for ( var method : archiveHideViewMethod ) { logDebug ( Unobfuscator . getMethodDescriptor ( method ) ) ; XposedBridge . hookMethod ( method , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { param . args [ <NUM_LIT> ] = false ; } } ) ; } } } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . reactnative . pulltorefresh ; import com . facebook . react . uimanager . LayoutShadowNode ; import com . facebook . react . uimanager . NativeViewHierarchyOptimizer ; import com . facebook . yoga . YogaEdge ; import com . facebook . yoga . YogaPositionType ; public class PullToRefreshHeaderShadowNode extends LayoutShadowNode { @ Override public void setLocalData ( Object data ) { super . setLocalData ( data ) ; if ( data instanceof PullToRefreshHeaderLocalData ) { PullToRefreshHeaderLocalData headerLocalData = ( PullToRefreshHeaderLocalData ) data ;", "output": "setStyleHeight ( headerLocalData . viewRect . bottom - headerLocalData . viewRect . top ) ; } } @ Override public void onBeforeLayout ( NativeViewHierarchyOptimizer nativeViewHierarchyOptimizer ) { setPositionType ( YogaPositionType . ABSOLUTE ) ; setPosition ( YogaEdge . LEFT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . RIGHT . intValue ( ) , <NUM_LIT> ) ; setPosition ( YogaEdge . TOP . intValue ( ) , - getLayoutHeight ( ) ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed ; import android . content . pm . PackageInstaller ; import com . wmods . wppenhacer . xposed . core . FeatureLoader ; import java . io . IOException ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class AntiUpdater { public static void hookSession ( XSharedPreferences prefs ) {", "output": "XposedBridge . hookAllMethods ( PackageInstaller . class , \"<STR_LIT>\" , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { var session = ( PackageInstaller . SessionParams ) param . args [ <NUM_LIT> ] ; var packageName = XposedHelpers . getObjectField ( session , \"<STR_LIT>\" ) ; if ( packageName . equals ( FeatureLoader . PACKAGE_WPP ) || packageName . equals ( FeatureLoader . PACKAGE_BUSINESS ) ) { if ( prefs . getBoolean ( \"<STR_LIT>\" , false ) ) { param . setThrowable ( new IOException ( \"<STR_LIT>\" ) ) ; } } } } ) ; } }"}, {"input": "package com . skythinker . gptassistant ; import android . content . Intent ; import android . service . quicksettings . TileService ; import android . util . Log ; import android . os . Handler ; import androidx . localbroadcastmanager . content . LocalBroadcastManager ; public class QuickStartService extends TileService { @ Override public void onClick ( ) {", "output": "super . onClick ( ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( ! MainActivity . isAlive ( ) || ! MainActivity . isRunning ( ) ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK | Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivityAndCollapse ( intent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; new Handler ( ) . postDelayed ( ( ) -> { Intent broadcastIntent = new Intent ( \"<STR_LIT>\" ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( broadcastIntent ) ; Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } , <NUM_LIT> ) ; } } }"}, {"input": "public class StaticReferenceLeakActivity extends AppCompatActivity { private static TextView textView ; private static Activity activity ; private static String a ; @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_first ) ; textView = findViewById ( R . id . activity_text ) ; textView . setText ( \"<STR_LIT>\" ) ;", "output": "activity = this ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . app . Activity ; import android . content . Context ; import android . os . RemoteException ; import android . view . View ; import android . widget . FrameLayout ; import androidx . appcompat . widget . Toolbar ; import androidx . recyclerview . widget . RecyclerView ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . droidcore . ParcelableRemoteFile ; public class RemoteFileSelectAdapter extends IIServiceFileSelectAdapter { public RemoteFileSelectAdapter ( Activity context , View . OnTouchListener onTouchListener , Toolbar fileSelectToolbar , FrameLayout frameLayout , View listInView , ITransferService service ) { super ( context , onTouchListener , fileSelectToolbar , frameLayout , listInView , service ) ; currentDir = \"<STR_LIT>\" ;", "output": "cd ( currentDir ) ; } @ Override public List < ParcelableRemoteFile > listTargetFiles ( String path ) throws RemoteException { ArrayList < ParcelableRemoteFile > files = new ArrayList < > ( ) ; int size = service . listClientFiles ( path ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { files . addAll ( service . pollRemoteFiles ( ) ) ; } return files ; } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . picturestorage ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . drawable . Drawable ; import android . widget . ImageView ; import androidx . appcompat . content . res . AppCompatResources ; import java . io . IOException ; import icu . freedomIntrovert . async . TaskManger ; import icu . freedomIntrovert . biliSendCommAntifraud . R ; public class PictureLoader { private final Context context ; private String url ; private PictureLoader ( Context context ) { this . context = context ; } public static PictureLoader with ( Context context ) { return new PictureLoader ( context ) ; } public PictureLoader load ( String url ) { this . url = url ; return this ; } public PictureLoader into ( ImageView imageView ) { Bitmap bitmap = PictureStorage . getBitMap ( url ) ; if ( bitmap != null ) { imageView . setImageBitmap ( bitmap ) ; return this ; } TaskManger . start ( ( ) -> { boolean loaded = PictureStorage . loadImage ( context , url ) ; if ( loaded ) { setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; return ; } try { if ( PictureStorage . save ( context , url ) ) { PictureStorage . loadImage ( context , url ) ; setBitMap ( imageView , PictureStorage . getBitMap ( url ) ) ; } else { setFailed ( imageView ) ; } } catch ( IOException e ) { setFailed ( imageView ) ; } } ) ; return this ; } private static void setBitMap ( ImageView imageView , Bitmap bitmap ) {", "output": "TaskManger . postOnUiThread ( ( ) -> imageView . setImageBitmap ( bitmap ) ) ; } private void setFailed ( ImageView imageView ) { TaskManger . postOnUiThread ( ( ) -> { Drawable drawable = AppCompatResources . getDrawable ( context , R . drawable . picture_failed ) ; imageView . setImageDrawable ( drawable ) ; } ) ; } }"}, {"input": "package me . zhanghai . android . fastscroll ; import android . annotation . SuppressLint ; import android . content . Context ; import android . graphics . Canvas ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . widget . ScrollView ; import androidx . annotation . AttrRes ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import androidx . annotation . StyleRes ; @ SuppressLint ( \"<STR_LIT>\" ) public class FastScrollScrollView extends ScrollView implements ViewHelperProvider { @ NonNull private final ViewHelper mViewHelper = new ViewHelper ( ) ; public FastScrollScrollView ( @ NonNull Context context ) { super ( context ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr ) { super ( context , attrs , defStyleAttr ) ; init ( ) ; } public FastScrollScrollView ( @ NonNull Context context , @ Nullable AttributeSet attrs , @ AttrRes int defStyleAttr , @ StyleRes int defStyleRes ) { super ( context , attrs , defStyleAttr , defStyleRes ) ; init ( ) ; } private void init ( ) {", "output": "setVerticalScrollBarEnabled ( false ) ; setScrollContainer ( true ) ; } @ NonNull @ Override public FastScroller . ViewHelper getViewHelper ( ) { return mViewHelper ; } @ Override public void draw ( @ NonNull Canvas canvas ) { mViewHelper . draw ( canvas ) ; } @ Override protected void onScrollChanged ( int left , int top , int oldLeft , int oldTop ) { mViewHelper . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override public boolean onInterceptTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onInterceptTouchEvent ( event ) ; } @ Override @ SuppressLint ( \"<STR_LIT>\" ) public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mViewHelper . onTouchEvent ( event ) ; } private class ViewHelper extends SimpleViewHelper { @ Override public int getScrollRange ( ) { return super . getScrollRange ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; } @ Override protected void superDraw ( @ NonNull Canvas canvas ) { FastScrollScrollView . super . draw ( canvas ) ; } @ Override protected void superOnScrollChanged ( int left , int top , int oldLeft , int oldTop ) { FastScrollScrollView . super . onScrollChanged ( left , top , oldLeft , oldTop ) ; } @ Override protected boolean superOnInterceptTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onInterceptTouchEvent ( event ) ; } @ Override protected boolean superOnTouchEvent ( @ NonNull MotionEvent event ) { return FastScrollScrollView . super . onTouchEvent ( event ) ; } @ Override protected int computeVerticalScrollRange ( ) { return FastScrollScrollView . this . computeVerticalScrollRange ( ) ; } @ Override protected int computeVerticalScrollOffset ( ) { return FastScrollScrollView . this . computeVerticalScrollOffset ( ) ; } @ Override protected int getScrollX ( ) { return FastScrollScrollView . this . getScrollX ( ) ; } @ Override protected void scrollTo ( int x , int y ) { FastScrollScrollView . this . scrollTo ( x , y ) ; } } }"}, {"input": "package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import android . text . TextUtils ; import com . appspa . update . _AppSpace ; import java . io . File ; public class DownloadEntity implements Parcelable { private String mDownloadUrl ; private String mMd5 ; private String mWholeMd5 ; private long mSize ; private boolean mIsShowNotification ; private String mTip ; private boolean isPatch ; public DownloadEntity ( ) { } protected DownloadEntity ( Parcel in ) { mDownloadUrl = in . readString ( ) ; mMd5 = in . readString ( ) ; mWholeMd5 = in . readString ( ) ; mSize = in . readLong ( ) ; mIsShowNotification = in . readByte ( ) != <NUM_LIT> ; mTip = in . readString ( ) ; isPatch = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < DownloadEntity > CREATOR = new Creator < DownloadEntity > ( ) { @ Override public DownloadEntity createFromParcel ( Parcel in ) { return new DownloadEntity ( in ) ; } @ Override public DownloadEntity [ ] newArray ( int size ) {", "output": "return new DownloadEntity [ size ] ; } } ; public String getDownloadUrl ( ) { return mDownloadUrl ; } public DownloadEntity setDownloadUrl ( String downloadUrl ) { mDownloadUrl = downloadUrl ; return this ; } public String getMd5 ( ) { return mMd5 ; } public DownloadEntity setMd5 ( String md5 ) { mMd5 = md5 ; return this ; } public String getWholeMd5 ( ) { if ( mWholeMd5 == null || TextUtils . isEmpty ( mWholeMd5 ) ) { return mMd5 ; } return mWholeMd5 ; } public DownloadEntity setWholeMd5 ( String md5 ) { mWholeMd5 = md5 ; return this ; } public long getSize ( ) { return mSize ; } public DownloadEntity setSize ( long size ) { mSize = size ; return this ; } public boolean isShowNotification ( ) { return mIsShowNotification ; } public DownloadEntity setShowNotification ( boolean showNotification ) { mIsShowNotification = showNotification ; return this ; } public DownloadEntity setTip ( String mTip ) { this . mTip = mTip ; return this ; } public DownloadEntity setIsPatch ( boolean isPatch ) { this . isPatch = isPatch ; return this ; } public boolean isFileValid ( File file ) { return _AppSpace . isFileValid ( mMd5 , file ) ; } public boolean isPatch ( ) { return isPatch ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + mDownloadUrl + '<STR_LIT>' + \"<STR_LIT>\" + mMd5 + '<STR_LIT>' + \"<STR_LIT>\" + mWholeMd5 + '<STR_LIT>' + \"<STR_LIT>\" + mSize + '<STR_LIT>' + \"<STR_LIT>\" + mIsShowNotification + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( mDownloadUrl ) ; dest . writeString ( mMd5 ) ; dest . writeString ( mWholeMd5 ) ; dest . writeLong ( mSize ) ; dest . writeByte ( ( byte ) ( mIsShowNotification ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeString ( mTip ) ; dest . writeByte ( ( byte ) ( isPatch ? <NUM_LIT> : <NUM_LIT> ) ) ; } }"}, {"input": "package de . robv . android . xposed . callbacks ; import android . content . res . XResources ; import android . content . res . XResources . ResourceNames ; import android . view . View ; import de . robv . android . xposed . XposedBridge . CopyOnWriteSortedSet ; public abstract class XC_LayoutInflated extends XCallback { @ SuppressWarnings ( \"<STR_LIT>\" ) public XC_LayoutInflated ( ) { super ( ) ; } public XC_LayoutInflated ( int priority ) { super ( priority ) ; }", "output": "public static final class LayoutInflatedParam extends XCallback . Param { public LayoutInflatedParam ( CopyOnWriteSortedSet < XC_LayoutInflated > callbacks ) { super ( callbacks ) ; } public View view ; public ResourceNames resNames ; public String variant ; public XResources res ; } @ Override protected void call ( Param param ) throws Throwable { if ( param instanceof LayoutInflatedParam ) handleLayoutInflated ( ( LayoutInflatedParam ) param ) ; } public abstract void handleLayoutInflated ( LayoutInflatedParam liparam ) throws Throwable ; public class Unhook implements IXUnhook < XC_LayoutInflated > { private final String resDir ; private final int id ; public Unhook ( String resDir , int id ) { this . resDir = resDir ; this . id = id ; } public int getId ( ) { return id ; } @ Override public XC_LayoutInflated getCallback ( ) { return XC_LayoutInflated . this ; } @ Override public void unhook ( ) { XResources . unhookLayout ( resDir , id , XC_LayoutInflated . this ) ; } } }"}, {"input": "package com . wmods . wppenhacer . views ; import android . content . Context ; import android . view . ViewGroup ; import android . widget . ListView ; public class NoScrollListView extends ListView { public NoScrollListView ( Context context ) { super ( context ) ; } public void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( <NUM_LIT> , MeasureSpec . AT_MOST ) ) ;", "output": "ViewGroup . LayoutParams layoutParams = this . getLayoutParams ( ) ; layoutParams . height = this . getMeasuredHeight ( ) ; } }"}, {"input": "package org . woheller69 . weather . activities ; import android . Manifest ; import android . content . SharedPreferences ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . Bundle ; import androidx . annotation . NonNull ; import androidx . annotation . RequiresApi ; import androidx . appcompat . app . AlertDialog ; import androidx . core . app . ActivityCompat ; import androidx . preference . PreferenceFragmentCompat ; import androidx . preference . PreferenceManager ; import androidx . preference . SeekBarPreference ; import org . woheller69 . weather . R ; import org . woheller69 . weather . database . SQLiteHelper ; import static java . lang . Boolean . TRUE ; public class SettingsActivity extends NavigationActivity implements SharedPreferences . OnSharedPreferenceChangeListener { @ Override protected void onRestart ( ) { super . onRestart ( ) ; recreate ( ) ; } @ RequiresApi ( api = Build . VERSION_CODES . Q ) @ Override public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == <NUM_LIT> ) { if ( grantResults . length > <NUM_LIT> && grantResults [ <NUM_LIT> ] == PackageManager . PERMISSION_GRANTED ) { if ( ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_FINE_LOCATION ) == PackageManager . PERMISSION_GRANTED ) && ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_BACKGROUND_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { AlertDialog . Builder alertDialogBuilder = new AlertDialog . Builder ( this ) ; String message = getString ( R . string . rationale_background_location ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { message = message + \"<STR_LIT>\" + getPackageManager ( ) . getBackgroundPermissionOptionLabel ( ) . toString ( ) + \"<STR_LIT>\" ; } alertDialogBuilder . setMessage ( message ) ; alertDialogBuilder . setPositiveButton ( getString ( R . string . dialog_OK_button ) , ( dialog , which ) -> requestBackgroundLocation ( ) ) ; alertDialogBuilder . setNegativeButton ( getString ( R . string . dialog_NO_button ) , ( dialog , which ) -> { } ) ; AlertDialog alertDialog = alertDialogBuilder . create ( ) ; alertDialog . show ( ) ; } } } } } @ RequiresApi ( api = Build . VERSION_CODES . Q ) private void requestBackgroundLocation ( ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_BACKGROUND_LOCATION } , <NUM_LIT> ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; PreferenceManager . getDefaultSharedPreferences ( this . getApplicationContext ( ) ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) {", "output": "super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_settings ) ; } @ Override protected int getNavigationDrawerID ( ) { return R . id . nav_settings ; } @ RequiresApi ( api = Build . VERSION_CODES . Q ) @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String s ) { if ( s . equals ( \"<STR_LIT>\" ) ) { if ( sharedPreferences . getBoolean ( \"<STR_LIT>\" , true ) == TRUE ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . R ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_COARSE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION } , <NUM_LIT> ) ; } else { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . ACCESS_COARSE_LOCATION , Manifest . permission . ACCESS_FINE_LOCATION , Manifest . permission . ACCESS_BACKGROUND_LOCATION } , <NUM_LIT> ) ; } } } } else if ( s . equals ( \"<STR_LIT>\" ) ) { SQLiteHelper database = SQLiteHelper . getInstance ( getApplicationContext ( ) . getApplicationContext ( ) ) ; database . deleteAllForecasts ( ) ; } } public static class GeneralPreferenceFragment extends PreferenceFragmentCompat implements SharedPreferences . OnSharedPreferenceChangeListener { @ Override public void onCreatePreferences ( Bundle savedInstanceState , String rootKey ) { setPreferencesFromResource ( R . xml . pref_general , rootKey ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; getPreferenceManager ( ) . getSharedPreferences ( ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override public void onPause ( ) { getPreferenceManager ( ) . getSharedPreferences ( ) . unregisterOnSharedPreferenceChangeListener ( this ) ; super . onPause ( ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { if ( key . equals ( \"<STR_LIT>\" ) ) { SeekBarPreference numberDays = findPreference ( \"<STR_LIT>\" ) ; if ( numberDays . getValue ( ) < <NUM_LIT> ) numberDays . setValue ( <NUM_LIT> ) ; } } } }"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . okretro ; import icu . freedomIntrovert . biliSendCommAntifraud . biliApis . BiliApiService ; import retrofit2 . Retrofit ; import retrofit2 . converter . fastjson . FastJsonConverterFactory ; public class ServiceGenerator { private static Retrofit retrofit ; private static BiliApiService biliApiService ; public static < T > T createService ( Class < T > cls ) { return ( T ) getRetrofit ( ) . create ( cls ) ; } public synchronized static Retrofit getRetrofit ( ) {", "output": "if ( retrofit == null ) { retrofit = new Retrofit . Builder ( ) . baseUrl ( \"<STR_LIT>\" ) . addConverterFactory ( FastJsonConverterFactory . create ( ) ) . client ( OkHttpUtil . getHttpClient ( ) ) . build ( ) ; } return retrofit ; } public synchronized static BiliApiService getBiliApiService ( ) { if ( biliApiService == null ) { biliApiService = getRetrofit ( ) . create ( BiliApiService . class ) ; } return biliApiService ; } }"}, {"input": "package com . cgutman . adblib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . security . GeneralSecurityException ; import java . security . KeyFactory ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . NoSuchAlgorithmException ; import java . security . interfaces . RSAPublicKey ; import java . security . spec . EncodedKeySpec ; import java . security . spec . InvalidKeySpecException ; import java . security . spec . PKCS8EncodedKeySpec ; import java . security . spec . X509EncodedKeySpec ; import javax . crypto . Cipher ; public class AdbCrypto { private KeyPair keyPair ; private AdbBase64 base64 ; public static final int KEY_LENGTH_BITS = <NUM_LIT> ; public static final int KEY_LENGTH_BYTES = KEY_LENGTH_BITS / <NUM_LIT> ; public static final int KEY_LENGTH_WORDS = KEY_LENGTH_BYTES / <NUM_LIT> ; public static final int [ ] SIGNATURE_PADDING_AS_INT = new int [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static byte [ ] SIGNATURE_PADDING ; static { SIGNATURE_PADDING = new byte [ SIGNATURE_PADDING_AS_INT . length ] ; for ( int i = <NUM_LIT> ; i < SIGNATURE_PADDING . length ; i ++ ) SIGNATURE_PADDING [ i ] = ( byte ) SIGNATURE_PADDING_AS_INT [ i ] ; } private static byte [ ] convertRsaPublicKeyToAdbFormat ( RSAPublicKey pubkey ) { BigInteger r32 , r , rr , rem , n , n0inv ; r32 = BigInteger . ZERO . setBit ( <NUM_LIT> ) ; n = pubkey . getModulus ( ) ; r = BigInteger . ZERO . setBit ( KEY_LENGTH_WORDS * <NUM_LIT> ) ; rr = r . modPow ( BigInteger . valueOf ( <NUM_LIT> ) , n ) ; rem = n . remainder ( r32 ) ; n0inv = rem . modInverse ( r32 ) ; int myN [ ] = new int [ KEY_LENGTH_WORDS ] ; int myRr [ ] = new int [ KEY_LENGTH_WORDS ] ; BigInteger res [ ] ; for ( int i = <NUM_LIT> ; i < KEY_LENGTH_WORDS ; i ++ ) { res = rr . divideAndRemainder ( r32 ) ; rr = res [ <NUM_LIT> ] ; rem = res [ <NUM_LIT> ] ; myRr [ i ] = rem . intValue ( ) ; res = n . divideAndRemainder ( r32 ) ; n = res [ <NUM_LIT> ] ; rem = res [ <NUM_LIT> ] ; myN [ i ] = rem . intValue ( ) ; } ByteBuffer bbuf = ByteBuffer . allocate ( <NUM_LIT> ) . order ( ByteOrder . LITTLE_ENDIAN ) ; bbuf . putInt ( KEY_LENGTH_WORDS ) ; bbuf . putInt ( n0inv . negate ( ) . intValue ( ) ) ; for ( int i : myN ) bbuf . putInt ( i ) ; for ( int i : myRr ) bbuf . putInt ( i ) ; bbuf . putInt ( pubkey . getPublicExponent ( ) . intValue ( ) ) ; return bbuf . array ( ) ; } public static AdbCrypto loadAdbKeyPair ( AdbBase64 base64 , File privateKey , File publicKey ) throws IOException , NoSuchAlgorithmException , InvalidKeySpecException { AdbCrypto crypto = new AdbCrypto ( ) ; int privKeyLength = ( int ) privateKey . length ( ) ; int pubKeyLength = ( int ) publicKey . length ( ) ; byte [ ] privKeyBytes = new byte [ privKeyLength ] ; byte [ ] pubKeyBytes = new byte [ pubKeyLength ] ; FileInputStream privIn = new FileInputStream ( privateKey ) ; FileInputStream pubIn = new FileInputStream ( publicKey ) ; privIn . read ( privKeyBytes ) ; pubIn . read ( pubKeyBytes ) ; privIn . close ( ) ; pubIn . close ( ) ; KeyFactory keyFactory = KeyFactory . getInstance ( \"<STR_LIT>\" ) ; EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec ( privKeyBytes ) ; EncodedKeySpec publicKeySpec = new X509EncodedKeySpec ( pubKeyBytes ) ; crypto . keyPair = new KeyPair ( keyFactory . generatePublic ( publicKeySpec ) , keyFactory . generatePrivate ( privateKeySpec ) ) ; crypto . base64 = base64 ; return crypto ; } public static AdbCrypto generateAdbKeyPair ( AdbBase64 base64 ) throws NoSuchAlgorithmException { AdbCrypto crypto = new AdbCrypto ( ) ; KeyPairGenerator rsaKeyPg = KeyPairGenerator . getInstance ( \"<STR_LIT>\" ) ; rsaKeyPg . initialize ( KEY_LENGTH_BITS ) ; crypto . keyPair = rsaKeyPg . genKeyPair ( ) ; crypto . base64 = base64 ; return crypto ; } public byte [ ] signAdbTokenPayload ( byte [ ] payload ) throws GeneralSecurityException { Cipher c = Cipher . getInstance ( \"<STR_LIT>\" ) ; c . init ( Cipher . ENCRYPT_MODE , keyPair . getPrivate ( ) ) ; c . update ( SIGNATURE_PADDING ) ; return c . doFinal ( payload ) ; } public byte [ ] getAdbPublicKeyPayload ( ) throws IOException { byte [ ] convertedKey = convertRsaPublicKeyToAdbFormat ( ( RSAPublicKey ) keyPair . getPublic ( ) ) ; StringBuilder keyString = new StringBuilder ( <NUM_LIT> ) ; keyString . append ( base64 . encodeToString ( convertedKey ) ) ; keyString . append ( \"<STR_LIT>\" ) ; keyString . append ( '<STR_LIT>' ) ; return keyString . toString ( ) . getBytes ( \"<STR_LIT>\" ) ; }", "output": "public void saveAdbKeyPair ( File privateKey , File publicKey ) throws IOException { FileOutputStream privOut = new FileOutputStream ( privateKey ) ; FileOutputStream pubOut = new FileOutputStream ( publicKey ) ; privOut . write ( keyPair . getPrivate ( ) . getEncoded ( ) ) ; pubOut . write ( keyPair . getPublic ( ) . getEncoded ( ) ) ; privOut . close ( ) ; pubOut . close ( ) ; } }"}, {"input": "package com . wmods . wppenhacer . xposed . features . customization ; import androidx . annotation . NonNull ; import com . wmods . wppenhacer . xposed . core . Feature ; import com . wmods . wppenhacer . xposed . core . devkit . Unobfuscator ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import de . robv . android . xposed . XC_MethodHook ; import de . robv . android . xposed . XSharedPreferences ; import de . robv . android . xposed . XposedBridge ; public class CustomTime extends Feature { public CustomTime ( ClassLoader loader , XSharedPreferences preferences ) { super ( loader , preferences ) ; } @ Override public void doHook ( ) throws Exception { var secondsToTime = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var ampm = prefs . getBoolean ( \"<STR_LIT>\" , false ) ; var secondsToTimeMethod = Unobfuscator . loadTimeToSecondsMethod ( classLoader ) ; logDebug ( Unobfuscator . getMethodDescriptor ( secondsToTimeMethod ) ) ; XposedBridge . hookMethod ( secondsToTimeMethod , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) { var timestamp = ( long ) param . args [ <NUM_LIT> ] ; var date = new Date ( timestamp ) ; var patternDefault = \"<STR_LIT>\" ; var patternSeconds = \"<STR_LIT>\" ; if ( ampm ) { patternDefault = \"<STR_LIT>\" ; patternSeconds = \"<STR_LIT>\" ; } var pattern = secondsToTime ? patternSeconds : patternDefault ; var formattedDate = new SimpleDateFormat ( pattern , Locale . US ) . format ( date ) ;", "output": "param . setResult ( getTextInHour ( formattedDate ) ) ; } } ) ; } @ NonNull @ Override public String getPluginName ( ) { return \"<STR_LIT>\" ; } private String getTextInHour ( String date ) { var summary = prefs . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( summary == null ) return date ; else return date + \"<STR_LIT>\" + summary ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . liveupdate . classes . results ; import androidx . annotation . Nullable ; import com . getcapacitor . JSObject ; import io . capawesome . capacitorjs . plugins . liveupdate . interfaces . Result ; import org . json . JSONObject ; public class SyncResult implements Result { @ Nullable private final String nextBundleId ; public SyncResult ( @ Nullable String nextBundleId ) { this . nextBundleId = nextBundleId ; } public JSObject toJSObject ( ) { JSObject result = new JSObject ( ) ; result . put ( \"<STR_LIT>\" , nextBundleId == null ? JSONObject . NULL : nextBundleId ) ;", "output": "return result ; } }"}, {"input": "package com . appspa . update . proxy . impl ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . appspa . update . entity . UpdateEntity ; import com . appspa . update . service . OnFileDownloadListener ; import com . appspa . update . _AppSpace ; import com . appspa . update . proxy . IPrompterProxy ; import com . appspa . update . proxy . IUpdateProxy ; public class DefaultPrompterProxyImpl implements IPrompterProxy { private IUpdateProxy mUpdateProxy ; DefaultPrompterProxyImpl ( IUpdateProxy proxy ) { mUpdateProxy = proxy ; } @ Override public String getUrl ( ) { return mUpdateProxy != null ? mUpdateProxy . getUrl ( ) : \"<STR_LIT>\" ; } @ Override public void startDownload ( @ NonNull UpdateEntity updateEntity , @ Nullable OnFileDownloadListener downloadListener ) { if ( mUpdateProxy != null ) { mUpdateProxy . startDownload ( updateEntity , downloadListener ) ; } } @ Override public void backgroundDownload ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . backgroundDownload ( ) ; }", "output": "} @ Override public void cancelDownload ( ) { _AppSpace . setIsPrompterShow ( getUrl ( ) , false ) ; if ( mUpdateProxy != null ) { mUpdateProxy . cancelDownload ( ) ; } } @ Override public void recycle ( ) { if ( mUpdateProxy != null ) { mUpdateProxy . recycle ( ) ; mUpdateProxy = null ; } } }"}, {"input": "package com . appspa . update . utils ; import android . graphics . Color ; import android . graphics . Paint ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . graphics . drawable . StateListDrawable ; import android . os . Build ; import android . view . View ; import android . widget . TextView ; public final class DrawableUtils { private DrawableUtils ( ) { throw new UnsupportedOperationException ( \"<STR_LIT>\" ) ; } public static GradientDrawable getSolidRectDrawable ( int cornerRadius , int solidColor ) { GradientDrawable gradientDrawable = new GradientDrawable ( ) ; gradientDrawable . setCornerRadius ( cornerRadius ) ; gradientDrawable . setColor ( solidColor ) ; gradientDrawable . setGradientType ( GradientDrawable . RADIAL_GRADIENT ) ; return gradientDrawable ; } public static GradientDrawable getStrokeRectDrawable ( int cornerRadius , int solidColor , int strokeColor , int strokeWidth ) { GradientDrawable gradientDrawable = new GradientDrawable ( ) ; gradientDrawable . setStroke ( strokeWidth , strokeColor ) ; gradientDrawable . setColor ( solidColor ) ; gradientDrawable . setCornerRadius ( cornerRadius ) ; gradientDrawable . setGradientType ( GradientDrawable . RADIAL_GRADIENT ) ; return gradientDrawable ; } public static StateListDrawable getStateListDrawable ( Drawable pressedDrawable , Drawable normalDrawable ) { StateListDrawable stateListDrawable = new StateListDrawable ( ) ; stateListDrawable . addState ( new int [ ] { android . R . attr . state_enabled , android . R . attr . state_pressed } , pressedDrawable ) ; stateListDrawable . addState ( new int [ ] { android . R . attr . state_enabled } , normalDrawable ) ; GradientDrawable gray = getSolidRectDrawable ( <NUM_LIT> , Color . GRAY ) ; stateListDrawable . addState ( new int [ ] { } , gray ) ; return stateListDrawable ; } public static StateListDrawable getDrawable ( int cornerRadius , int pressedColor , int normalColor ) { return getStateListDrawable ( getSolidRectDrawable ( cornerRadius , pressedColor ) , getSolidRectDrawable ( cornerRadius , normalColor ) ) ; } public static StateListDrawable getStrokeSolidDrawable ( int cornerRadiusPX , int strokeWidthPX , int subColor , int mainColor ) { return getStateListDrawable ( getSolidRectDrawable ( cornerRadiusPX , subColor ) , getStrokeRectDrawable ( cornerRadiusPX , mainColor , subColor , strokeWidthPX ) ) ; } public static StateListDrawable getSolidStrokeDrawable ( int cornerRadiusPX , int strokeWidthPX , int subColor , int mainColor ) { return getStateListDrawable ( getStrokeRectDrawable ( cornerRadiusPX , subColor , mainColor , strokeWidthPX ) , getSolidRectDrawable ( cornerRadiusPX , mainColor ) ) ; } public static StateListDrawable getDrawable ( int cornerRadius , int normalColor ) { return getDrawable ( cornerRadius , ColorUtils . colorDeep ( normalColor ) , normalColor ) ; } public static StateListDrawable getDrawable ( int cornerRadius ) { return getDrawable ( cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static StateListDrawable getDrawable ( ) { return getDrawable ( <NUM_LIT> ) ; } public static StateListDrawable getRandomColorDrawable ( int cornerRadius ) { return getDrawable ( cornerRadius , ColorUtils . getRandomColor ( ) , ColorUtils . getRandomColor ( ) ) ; } public static StateListDrawable getRandomColorDrawable ( ) { return getRandomColorDrawable ( <NUM_LIT> ) ; } public static StateListDrawable getStrokeRandomColorDrawable ( ) { return getStrokeSolidDrawable ( <NUM_LIT> , <NUM_LIT> , ColorUtils . getRandomColor ( ) , Color . TRANSPARENT ) ; } public static void setTextStrokeTheme ( TextView textView , int strokeWidth , int cornerRadius , int color ) { textView . setBackgroundDrawable ( getStrokeSolidDrawable ( cornerRadius , strokeWidth , color , Color . WHITE ) ) ; textView . setTextColor ( ColorUtils . getColorStateList ( Color . WHITE , color ) ) ; textView . getPaint ( ) . setFlags ( Paint . FAKE_BOLD_TEXT_FLAG ) ; } public static void setTextStrokeTheme ( TextView textView , int strokeWidth , int cornerRadius ) { setTextStrokeTheme ( textView , strokeWidth , cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static void setTextStrokeTheme ( TextView textView ) { setTextStrokeTheme ( textView , <NUM_LIT> , <NUM_LIT> ) ; } public static void setTextStrokeTheme ( TextView textView , int color ) {", "output": "setTextStrokeTheme ( textView , <NUM_LIT> , <NUM_LIT> , color ) ; } public static void setTextSolidTheme ( TextView textView , int strokeWidth , int cornerRadius , int color ) { textView . setBackgroundDrawable ( getSolidStrokeDrawable ( cornerRadius , strokeWidth , Color . WHITE , color ) ) ; textView . setTextColor ( ColorUtils . getColorStateList ( color , Color . WHITE ) ) ; textView . getPaint ( ) . setFlags ( Paint . FAKE_BOLD_TEXT_FLAG ) ; } public static void setTextSolidTheme ( TextView textView , int strokeWidth , int cornerRadius ) { setTextSolidTheme ( textView , strokeWidth , cornerRadius , ColorUtils . getRandomColor ( ) ) ; } public static void setTextSolidTheme ( TextView textView ) { setTextSolidTheme ( textView , <NUM_LIT> , <NUM_LIT> ) ; } public static void setBackgroundCompat ( View view , Drawable d ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . JELLY_BEAN ) { view . setBackgroundDrawable ( d ) ; } else { view . setBackground ( d ) ; } } }"}, {"input": "package com . norman . webviewup . lib . source ; import android . content . Context ; import android . content . SharedPreferences ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . util . FileUtils ; import com . norman . webviewup . lib . util . HandlerUtils ; import java . util . HashSet ; public abstract class UpgradeSource { private final HashSet < OnPrepareCallback > prepareCallbackSet = new HashSet < > ( ) ; private final Context context ; private boolean success ; private boolean running ; private Throwable errorThrowable ; public UpgradeSource ( @ NonNull Context context ) { this . context = context . getApplicationContext ( ) ; } public synchronized boolean isSuccess ( ) { return success ; } public synchronized boolean isProcess ( ) { return running ; } public synchronized final Throwable getError ( ) { return errorThrowable ; } public synchronized void prepare ( OnPrepareCallback prepareCallback ) { prepare ( prepareCallback , null ) ; } public synchronized void prepare ( OnPrepareCallback prepareCallback , Object params ) { if ( isSuccess ( ) ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareSuccess ( this ) ; } ) ; } else if ( errorThrowable != null ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareError ( this , errorThrowable ) ; } ) ; } else { prepareCallbackSet . add ( prepareCallback ) ; if ( ! running ) { running = true ; try { onPrepare ( params ) ; } catch ( Throwable throwable ) { error ( throwable ) ; } } } } protected abstract void onPrepare ( Object params ) ; protected synchronized final void success ( ) { if ( success || errorThrowable != null ) { return ; } success = true ; running = false ; onSuccess ( ) ; for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareSuccess ( this ) ; } ) ; } prepareCallbackSet . clear ( ) ; } protected synchronized final void error ( @ NonNull Throwable throwable ) { if ( isSuccess ( ) || errorThrowable != null ) { return ; } errorThrowable = throwable ; running = false ; for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareError ( this , throwable ) ; } ) ; } prepareCallbackSet . clear ( ) ; onError ( throwable ) ; } protected synchronized final void process ( float percent ) { if ( isSuccess ( ) || errorThrowable != null ) { return ; } for ( OnPrepareCallback prepareCallback : prepareCallbackSet ) { HandlerUtils . runInMainThread ( ( ) -> { prepareCallback . onPrepareProcess ( this , percent ) ; } ) ; } onProcess ( percent ) ; } protected void onSuccess ( ) { } protected void onError ( Throwable throwable ) { }", "output": "protected void onProcess ( float percent ) { } public Context getContext ( ) { return context ; } public interface OnPrepareCallback { void onPrepareSuccess ( UpgradeSource webViewSource ) ; void onPrepareProcess ( UpgradeSource webViewSource , float percent ) ; void onPrepareError ( UpgradeSource webViewSource , Throwable throwable ) ; } }"}, {"input": "package in . hridayan . ashell . utils ; public class ChangelogItem { private String title ; private String description ; public ChangelogItem ( String title , String description ) { this . title = title ; this . description = description ;", "output": "} public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } }"}, {"input": "package in . hridayan . ashell . UI ; import androidx . lifecycle . ViewModel ; public class MainViewModel extends ViewModel { private static final int nullValue = <NUM_LIT> ; private int currentFragment = nullValue ; public int currentFragment ( ) { return currentFragment ; } public void setCurrentFragment ( int fragment ) { currentFragment = fragment ;", "output": "} public boolean isFragmentSaved ( ) { return currentFragment != nullValue ; } }"}, {"input": "package de . robv . android . xposed ; import android . os . SELinux ; import de . robv . android . xposed . services . BaseService ; import de . robv . android . xposed . services . BinderService ; import de . robv . android . xposed . services . DirectAccessService ; import de . robv . android . xposed . services . ZygoteService ; public final class SELinuxHelper { private SELinuxHelper ( ) { } public static boolean isSELinuxEnabled ( ) { return sIsSELinuxEnabled ;", "output": "} public static boolean isSELinuxEnforced ( ) { return sIsSELinuxEnabled && SELinux . isSELinuxEnforced ( ) ; } public static String getContext ( ) { return sIsSELinuxEnabled ? SELinux . getContext ( ) : null ; } public static BaseService getAppDataFileService ( ) { if ( sServiceAppDataFile != null ) return sServiceAppDataFile ; throw new UnsupportedOperationException ( ) ; } private static boolean sIsSELinuxEnabled = false ; private static BaseService sServiceAppDataFile = null ; static void initOnce ( ) { try { sIsSELinuxEnabled = SELinux . isSELinuxEnabled ( ) ; } catch ( NoClassDefFoundError ignored ) { } } static void initForProcess ( String packageName ) { if ( sIsSELinuxEnabled ) { if ( packageName == null ) { sServiceAppDataFile = new ZygoteService ( ) ; } else if ( packageName . equals ( \"<STR_LIT>\" ) ) { sServiceAppDataFile = BinderService . getService ( BinderService . TARGET_APP ) ; } else { sServiceAppDataFile = new DirectAccessService ( ) ; } } else { sServiceAppDataFile = new DirectAccessService ( ) ; } } }"}, {"input": "package icu . freedomIntrovert . async ; public class EventMessage { private final int what ; private final Object [ ] objects ; public EventMessage ( Object [ ] objects , int what ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what , Object ... objects ) { this . what = what ; this . objects = objects ; } public EventMessage ( int what ) { this . what = what ; this . objects = new Object [ <NUM_LIT> ] ; } public < T > T getObject ( int index , Class < T > clazz ) { return clazz . cast ( objects [ index ] ) ; } public int getWhat ( ) { return what ; }", "output": "public Object [ ] getObjects ( ) { return objects ; } }"}, {"input": "package io . capawesome . capacitorjs . plugins . mlkit . barcodescanning ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_CANCELED ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_COMPLETED ; import static com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate . InstallState . STATE_FAILED ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import com . google . android . gms . common . moduleinstall . InstallStatusListener ; import com . google . android . gms . common . moduleinstall . ModuleInstall ; import com . google . android . gms . common . moduleinstall . ModuleInstallClient ; import com . google . android . gms . common . moduleinstall . ModuleInstallStatusUpdate ; public class ModuleInstallProgressListener implements InstallStatusListener { @ NonNull private final BarcodeScanner implementation ; public ModuleInstallProgressListener ( BarcodeScanner implementation ) { this . implementation = implementation ; } public static boolean isTerminateState ( @ ModuleInstallStatusUpdate . InstallState int state ) { return state == STATE_CANCELED || state == STATE_COMPLETED || state == STATE_FAILED ; } @ Override public void onInstallStatusUpdated ( ModuleInstallStatusUpdate update ) { ModuleInstallStatusUpdate . ProgressInfo progressInfo = update . getProgressInfo ( ) ; @ ModuleInstallStatusUpdate . InstallState int state = update . getInstallState ( ) ; Integer progress = null ; if ( progressInfo != null ) { progress = ( int ) ( <NUM_LIT> * ( progressInfo . getBytesDownloaded ( ) / progressInfo . getTotalBytesToDownload ( ) ) ) ; } implementation . handleGoogleBarcodeScannerModuleInstallProgress ( state , progress ) ; }", "output": "}"}, {"input": "package icu . freedomIntrovert . biliSendCommAntifraud . biliApis ; public class VideoInfo { public String bvid ; public long aid ; public String title ; public String desc ; public String pic ;", "output": "}"}, {"input": "package com . norman . webviewup . lib . reflect . annotation ; import static java . lang . annotation . ElementType . PARAMETER ; import static java . lang . annotation . RetentionPolicy . RUNTIME ; import java . lang . annotation . Retention ; import java . lang . annotation . Target ; @ Retention ( RUNTIME ) @ Target ( {", "output": "PARAMETER } ) public @ interface ParameterName { String value ( ) ; }"}, {"input": "package com . skythinker . gptassistant ; import android . content . ComponentName ; import android . content . Context ; import android . content . Intent ; import android . os . Bundle ; import android . provider . Settings ; import android . speech . RecognitionListener ; import android . speech . RecognizerIntent ; import android . speech . SpeechRecognizer ; import android . util . Log ; import android . widget . Toast ; import java . util . ArrayList ; import java . util . Locale ; public class GoogleAsrClient extends AsrClientBase { SpeechRecognizer speechRecognizer = null ; IAsrCallback callback = null ; Context context = null ; boolean autoStop = false ; public GoogleAsrClient ( Context context ) { this . context = context ; if ( ! SpeechRecognizer . isRecognitionAvailable ( context . getApplicationContext ( ) ) ) return ; speechRecognizer = SpeechRecognizer . createSpeechRecognizer ( context ) ; speechRecognizer . setRecognitionListener ( new RecognitionListener ( ) { @ Override public void onReadyForSpeech ( Bundle params ) { } @ Override public void onBeginningOfSpeech ( ) { } @ Override public void onRmsChanged ( float rmsdB ) { } @ Override public void onBufferReceived ( byte [ ] buffer ) { } @ Override public void onEndOfSpeech ( ) { } @ Override public void onError ( int error ) { String errorStr = \"<STR_LIT>\" + error ; if ( error == SpeechRecognizer . ERROR_INSUFFICIENT_PERMISSIONS ) errorStr = context . getString ( R . string . text_google_asr_permission_error ) ; callback . onError ( errorStr ) ; } @ Override public void onResults ( Bundle results ) {", "output": "ArrayList < String > data = results . getStringArrayList ( SpeechRecognizer . RESULTS_RECOGNITION ) ; if ( data != null && ! data . isEmpty ( ) ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + data . get ( <NUM_LIT> ) ) ; callback . onResult ( data . get ( <NUM_LIT> ) ) ; if ( autoStop ) callback . onAutoStop ( ) ; } } @ Override public void onPartialResults ( Bundle partialResults ) { ArrayList < String > data = partialResults . getStringArrayList ( SpeechRecognizer . RESULTS_RECOGNITION ) ; if ( data != null && ! data . isEmpty ( ) ) { Log . d ( \"<STR_LIT>\" , \"<STR_LIT>\" + data . get ( <NUM_LIT> ) ) ; callback . onResult ( data . get ( <NUM_LIT> ) ) ; } } @ Override public void onEvent ( int eventType , Bundle params ) { } } ) ; } @ Override public void startRecognize ( ) { if ( speechRecognizer != null ) { Intent speechRecognizerIntent = new Intent ( RecognizerIntent . ACTION_RECOGNIZE_SPEECH ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_LANGUAGE_MODEL , RecognizerIntent . LANGUAGE_MODEL_FREE_FORM ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_LANGUAGE , Locale . getDefault ( ) ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_PARTIAL_RESULTS , true ) ; speechRecognizerIntent . putExtra ( RecognizerIntent . EXTRA_MAX_RESULTS , <NUM_LIT> ) ; try { speechRecognizer . startListening ( speechRecognizerIntent ) ; } catch ( SecurityException e ) { callback . onError ( context . getString ( R . string . text_google_asr_typing_error ) ) ; new ConfirmDialog ( context ) . setContent ( context . getString ( R . string . text_google_asr_typing_error ) ) . setOnConfirmListener ( ( ) -> { context . startActivity ( new Intent ( Settings . ACTION_VOICE_INPUT_SETTINGS ) . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ) ) ; } ) . show ( ) ; e . printStackTrace ( ) ; } } else { callback . onError ( context . getString ( R . string . text_google_asr_unavailable ) ) ; } } @ Override public void stopRecognize ( ) { if ( speechRecognizer != null ) { speechRecognizer . cancel ( ) ; } } @ Override public void cancelRecognize ( ) { if ( speechRecognizer != null ) { speechRecognizer . cancel ( ) ; } } @ Override public void setCallback ( IAsrCallback callback ) { this . callback = callback ; } @ Override public void setParam ( String key , Object value ) { } @ Override public void setEnableAutoStop ( boolean enable ) { autoStop = enable ; } @ Override public void destroy ( ) { if ( speechRecognizer != null ) { speechRecognizer . destroy ( ) ; } } }"}, {"input": "package com . appspa . update . entity ; import android . os . Parcel ; import android . os . Parcelable ; import androidx . annotation . NonNull ; import androidx . annotation . Nullable ; import android . text . TextUtils ; import com . appspa . update . proxy . IUpdateHttpService ; public class UpdateEntity implements Parcelable { private boolean mHasUpdate ; private boolean mIsForce ; private boolean mIsIgnorable ; private int mVersionCode ; private String mVersionName ; private String mUpdateContent ; private DownloadEntity mDownloadEntity ; private DownloadEntity mPatchDownloadEntity ; private boolean mIsSilent ; private boolean mIsAutoInstall ; private String mCacheDir ; public UpdateEntity ( ) { mVersionName = \"<STR_LIT>\" ; mDownloadEntity = new DownloadEntity ( ) ; mIsAutoInstall = true ; } protected UpdateEntity ( Parcel in ) { mHasUpdate = in . readByte ( ) != <NUM_LIT> ; mIsForce = in . readByte ( ) != <NUM_LIT> ; mIsIgnorable = in . readByte ( ) != <NUM_LIT> ; mVersionCode = in . readInt ( ) ; mVersionName = in . readString ( ) ; mUpdateContent = in . readString ( ) ; mDownloadEntity = in . readParcelable ( DownloadEntity . class . getClassLoader ( ) ) ; mPatchDownloadEntity = in . readParcelable ( DownloadEntity . class . getClassLoader ( ) ) ; mIsSilent = in . readByte ( ) != <NUM_LIT> ; mIsAutoInstall = in . readByte ( ) != <NUM_LIT> ; } public static final Creator < UpdateEntity > CREATOR = new Creator < UpdateEntity > ( ) { @ Override public UpdateEntity createFromParcel ( Parcel in ) { return new UpdateEntity ( in ) ; } @ Override public UpdateEntity [ ] newArray ( int size ) { return new UpdateEntity [ size ] ; } } ; public boolean isHasUpdate ( ) { return mHasUpdate ; } public UpdateEntity setHasUpdate ( boolean hasUpdate ) { mHasUpdate = hasUpdate ; return this ; } public boolean isForce ( ) { return mIsForce ; } public UpdateEntity setForce ( boolean force ) { if ( force ) { mIsIgnorable = false ; } mIsForce = force ; return this ; } public boolean isIgnorable ( ) { return mIsIgnorable ; } public UpdateEntity setIsIgnorable ( boolean isIgnorable ) { if ( isIgnorable ) { mIsForce = false ; } mIsIgnorable = isIgnorable ; return this ; } public boolean isSilent ( ) { return mIsSilent ; } public UpdateEntity setIsSilent ( boolean isSilent ) { mIsSilent = isSilent ; return this ; } public boolean isAutoInstall ( ) { return mIsAutoInstall ; } public UpdateEntity setIsAutoInstall ( boolean isAutoInstall ) { mIsAutoInstall = isAutoInstall ; return this ; } public UpdateEntity setCacheDir ( String apkCacheDir ) { mCacheDir = apkCacheDir ; if ( ! TextUtils . isEmpty ( apkCacheDir ) && TextUtils . isEmpty ( mCacheDir ) ) { mCacheDir = apkCacheDir ; } return this ; } public String getCacheDir ( ) { return mCacheDir ; } public UpdateEntity setIsAutoMode ( boolean isAutoMode ) { if ( isAutoMode ) { mIsSilent = true ; mIsAutoInstall = true ; mDownloadEntity . setShowNotification ( true ) ; if ( mPatchDownloadEntity != null ) { mPatchDownloadEntity . setShowNotification ( true ) ; } } return this ; } public UpdateEntity setShowNotification ( boolean showNotification ) { mDownloadEntity . setShowNotification ( showNotification ) ;", "output": "if ( mPatchDownloadEntity != null ) { mPatchDownloadEntity . setShowNotification ( true ) ; } return this ; } public int getVersionCode ( ) { return mVersionCode ; } public UpdateEntity setVersionCode ( int versionCode ) { mVersionCode = versionCode ; return this ; } public String getVersionName ( ) { return mVersionName ; } public UpdateEntity setVersionName ( String versionName ) { mVersionName = versionName ; return this ; } public String getUpdateContent ( ) { return mUpdateContent ; } public UpdateEntity setUpdateContent ( String updateContent ) { mUpdateContent = updateContent ; return this ; } public UpdateEntity setDownLoadEntity ( @ NonNull DownloadEntity downloadEntity ) { mDownloadEntity = downloadEntity ; return this ; } public UpdateEntity setPatchDownloadEntity ( DownloadEntity mPatchDownloadEntity ) { this . mPatchDownloadEntity = mPatchDownloadEntity ; return this ; } public boolean hasPatch ( ) { return mPatchDownloadEntity != null && mPatchDownloadEntity . getDownloadUrl ( ) != null ; } public DownloadEntity getPatchDownloadEntity ( ) { return mPatchDownloadEntity ; } @ NonNull public DownloadEntity getDownLoadEntity ( ) { return mDownloadEntity ; } public DownloadEntity getCurDownloadEntity ( ) { return this . hasPatch ( ) ? getPatchDownloadEntity ( ) : getDownLoadEntity ( ) ; } private IUpdateHttpService mIUpdateHttpService ; public UpdateEntity setIUpdateHttpService ( @ NonNull IUpdateHttpService updateHttpService ) { mIUpdateHttpService = updateHttpService ; return this ; } @ Nullable public IUpdateHttpService getIUpdateHttpService ( ) { return mIUpdateHttpService ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + mHasUpdate + \"<STR_LIT>\" + mIsForce + \"<STR_LIT>\" + mIsIgnorable + \"<STR_LIT>\" + mVersionCode + \"<STR_LIT>\" + mVersionName + '<STR_LIT>' + \"<STR_LIT>\" + mUpdateContent + '<STR_LIT>' + \"<STR_LIT>\" + mDownloadEntity + \"<STR_LIT>\" + mPatchDownloadEntity + \"<STR_LIT>\" + mIsSilent + \"<STR_LIT>\" + mIsAutoInstall + \"<STR_LIT>\" + mIUpdateHttpService + '<STR_LIT>' ; } @ Override public int describeContents ( ) { return <NUM_LIT> ; } @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeByte ( ( byte ) ( mHasUpdate ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsForce ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsIgnorable ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeInt ( mVersionCode ) ; dest . writeString ( mVersionName ) ; dest . writeString ( mUpdateContent ) ; dest . writeParcelable ( mDownloadEntity , flags ) ; dest . writeParcelable ( mPatchDownloadEntity , flags ) ; dest . writeByte ( ( byte ) ( mIsSilent ? <NUM_LIT> : <NUM_LIT> ) ) ; dest . writeByte ( ( byte ) ( mIsAutoInstall ? <NUM_LIT> : <NUM_LIT> ) ) ; } }"}, {"input": "package com . appspa . demo . utils ; import android . content . Context ; import com . appspa . demo . R ; public class SettingSPUtils { private static SettingSPUtils sInstance ; private SettingSPUtils ( ) { } public static SettingSPUtils get ( ) { if ( sInstance == null ) { synchronized ( SettingSPUtils . class ) { if ( sInstance == null ) { sInstance = new SettingSPUtils ( ) ; } } } return sInstance ; } public String getServiceURL ( ) { return \"<STR_LIT>\" ; }", "output": "public boolean setServiceURL ( String apiUrl ) { return true ; } }"}, {"input": "package top . weixiansen574 . hybridfilexfer ; import android . content . Context ; import android . content . DialogInterface ; import java . util . List ; import top . weixiansen574 . hybridfilexfer . bean . BookMark ; public class LocalBookmarkAdapter extends BookmarkAdapter { private final IIServiceFileSelectAdapter adapter ; private final List < BookMark > bookMarks ; private final ConfigDB db ; public LocalBookmarkAdapter ( Context context , DialogInterface dialog , IIServiceFileSelectAdapter adapter , ConfigDB db ) { super ( context , dialog ) ;", "output": "this . db = db ; this . bookMarks = db . getAllLocalBookmark ( ) ; this . adapter = adapter ; } @ Override protected boolean onDelete ( BookMark bookMark ) { boolean success = db . removeLocalBookmark ( bookMark . id ) > <NUM_LIT> ; if ( success ) { bookMarks . remove ( bookMark ) ; } return success ; } @ Override protected BookMark getItem ( int position ) { return bookMarks . get ( position ) ; } @ Override protected void onItemClick ( BookMark bookMark ) { adapter . cd ( bookMark . path ) ; } @ Override public int getItemCount ( ) { return bookMarks . size ( ) ; } }"}, {"input": "public class MainActivity extends AppCompatActivity { WebView webView ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; webView = new WebView ( this ) ; WebSettings settings = webView . getSettings ( ) ;", "output": "settings . setJavaScriptEnabled ( true ) ; setContentView ( webView ) ; WebView webview2 = new WebView ( this ) ; setContentView ( webview2 ) ; webview2 . getSettings ( ) . setJavaScriptEnabled ( true ) ; } }"}, {"input": "package com . norman . webviewup . lib . hook ; import android . content . ComponentName ; import android . content . Context ; import android . content . ContextWrapper ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import android . os . Build ; import android . os . IBinder ; import android . os . IInterface ; import android . os . RemoteException ; import android . text . TextUtils ; import androidx . annotation . NonNull ; import com . norman . webviewup . lib . reflect . RuntimeAccess ; import com . norman . webviewup . lib . service . binder . BinderHook ; import com . norman . webviewup . lib . service . interfaces . IActivityThread ; import com . norman . webviewup . lib . service . interfaces . IApplicationInfo ; import com . norman . webviewup . lib . service . interfaces . IContextImpl ; import com . norman . webviewup . lib . service . interfaces . IPackageManager ; import com . norman . webviewup . lib . service . interfaces . IServiceManager ; import com . norman . webviewup . lib . service . binder . ProxyBinder ; import com . norman . webviewup . lib . service . proxy . PackageManagerProxy ; import com . norman . webviewup . lib . util . FileUtils ; import com . norman . webviewup . lib . util . ProcessUtils ; import java . io . File ; import java . io . FileNotFoundException ; import java . util . Arrays ; import java . util . Collections ; import java . util . Enumeration ; import java . util . Map ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class PackageManagerServiceHook extends BinderHook { private final Context context ; private final String webViewPackageName ; private final String apkPath ; private final String libsPath ; private Map < String , IBinder > binderCacheMap ; public PackageManagerServiceHook ( @ NonNull Context context , @ NonNull String packageName , @ NonNull String apkPath , @ NonNull String libsPath ) { this . context = context ; this . webViewPackageName = packageName ; this . apkPath = apkPath ; this . libsPath = libsPath ; } private final PackageManagerProxy proxy = new PackageManagerProxy ( ) { @ Override protected PackageInfo getPackageInfo ( String packageName , long flags , int userId ) { return getPackageInfo ( packageName , ( int ) flags ) ; } @ Override protected PackageInfo getPackageInfo ( String packageName , int flags , int userId ) { return getPackageInfo ( packageName , flags ) ; } @ Override protected int getComponentEnabledSetting ( ComponentName componentName , int userId ) { return getComponentEnabledSetting ( componentName ) ; } @ Override protected PackageInfo getPackageInfo ( String packageName , int flags ) { if ( packageName . equals ( webViewPackageName ) ) { PackageInfo packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , flags ) ; if ( packageInfo == null ) { flags &= ~ PackageManager . GET_SIGNATURES ; packageInfo = context . getPackageManager ( ) . getPackageArchiveInfo ( apkPath , flags ) ; } if ( packageInfo == null ) { throw new RuntimeException ( \"<STR_LIT>\" + apkPath ) ; } boolean is64Bit = ProcessUtils . is64Bit ( ) ; String [ ] supportBitAbis = is64Bit ? Build . SUPPORTED_64_BIT_ABIS : Build . SUPPORTED_32_BIT_ABIS ; Arrays . sort ( supportBitAbis , Collections . reverseOrder ( ) ) ; String nativeLibraryDir = null ; File libsDir = new File ( libsPath ) ; if ( ! FileUtils . exist ( libsDir ) ) { throw new RuntimeException ( \"<STR_LIT>\" + libsPath ) ; } String [ ] list = libsDir . list ( ) ; if ( list == null ) { throw new RuntimeException ( \"<STR_LIT>\" + libsPath ) ; } Arrays . sort ( supportBitAbis ) ; String cpuAbi = null ; for ( String name : list ) { if ( Arrays . binarySearch ( supportBitAbis , name ) >= <NUM_LIT> ) { cpuAbi = name ; nativeLibraryDir = new File ( libsDir , name ) . getAbsolutePath ( ) ; break ; } } if ( nativeLibraryDir == null ) { throw new NullPointerException ( \"<STR_LIT>\" + Arrays . toString ( supportBitAbis ) + \"<STR_LIT>\" + libsPath ) ; } try { IApplicationInfo iApplicationInfo = RuntimeAccess . objectAccess ( IApplicationInfo . class , packageInfo . applicationInfo ) ; iApplicationInfo . setPrimaryCpuAbi ( cpuAbi ) ; } catch ( Throwable ignore ) { } try { IApplicationInfo iApplicationInfo = RuntimeAccess . objectAccess ( IApplicationInfo . class , packageInfo . applicationInfo ) ; iApplicationInfo . setNativeLibraryRootDir ( libsPath ) ; } catch ( Throwable ignore ) { } packageInfo . applicationInfo . nativeLibraryDir = nativeLibraryDir ; if ( TextUtils . isEmpty ( packageInfo . applicationInfo . sourceDir ) ) { packageInfo . applicationInfo . sourceDir = apkPath ; } if ( TextUtils . isEmpty ( packageInfo . applicationInfo . publicSourceDir ) ) { packageInfo . applicationInfo . publicSourceDir = apkPath ; } return packageInfo ; } return ( PackageInfo ) invoke ( ) ; } @ Override protected int getComponentEnabledSetting ( ComponentName componentName ) { if ( componentName . getPackageName ( ) . equals ( webViewPackageName ) ) { return PackageManager . COMPONENT_ENABLED_STATE_DISABLED ; } else { return ( int ) invoke ( ) ; } } @ Override protected String getInstallerPackageName ( String packageName ) { if ( packageName . equals ( webViewPackageName ) ) { return \"<STR_LIT>\" ; } else { return ( String ) invoke ( ) ; } } @ Override protected IBinder asBinder ( ) { IBinder proxyBinder = getProxyBinder ( ) ; return proxyBinder != null ? proxyBinder : ( IBinder ) invoke ( ) ; } } ; @ Override protected IBinder onTargetBinderObtain ( ) { IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; return serviceManager . getService ( IPackageManager . SERVICE ) ; } @ Override protected ProxyBinder onProxyBinderCreate ( IBinder binder ) { IPackageManager service = RuntimeAccess . staticAccess ( IPackageManager . class ) ; IServiceManager serviceManager = RuntimeAccess . staticAccess ( IServiceManager . class ) ; IInterface targetInterface = service . asInterface ( binder ) ; proxy . setTarget ( targetInterface ) ; IInterface proxyInterface = ( IInterface ) proxy . get ( ) ;", "output": "ProxyBinder proxyBinder = new ProxyBinder ( targetInterface , proxyInterface ) ; binderCacheMap = serviceManager . getServiceCache ( ) ; return proxyBinder ; } @ Override protected void onTargetBinderRestore ( IBinder binder ) { IInterface targetInterface ; try { targetInterface = binder . queryLocalInterface ( binder . getInterfaceDescriptor ( ) ) ; } catch ( RemoteException e ) { throw new RuntimeException ( e ) ; } binderCacheMap . put ( IPackageManager . SERVICE , binder ) ; updateActivityThreadPackageManager ( targetInterface ) ; flushContextImplPackageManager ( ) ; } @ Override protected void onProxyBinderReplace ( ProxyBinder binder ) { binderCacheMap . put ( IPackageManager . SERVICE , binder ) ; updateActivityThreadPackageManager ( binder . getProxyIInterface ( ) ) ; flushContextImplPackageManager ( ) ; } private static void updateActivityThreadPackageManager ( IInterface iInterface ) { IActivityThread activityThread = RuntimeAccess . staticAccess ( IActivityThread . class ) ; activityThread . setPackageManager ( iInterface ) ; } private void flushContextImplPackageManager ( ) { Context baseContext = context . getApplicationContext ( ) ; while ( baseContext instanceof ContextWrapper ) { baseContext = ( ( ContextWrapper ) context ) . getBaseContext ( ) ; } IContextImpl contextImpl = RuntimeAccess . objectAccess ( IContextImpl . class , baseContext ) ; contextImpl . setPackageManager ( null ) ; } }"}, {"input": "package com . wmods . wppenhacer . utils ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . StateListDrawable ; import android . os . Build ; import androidx . annotation . Nullable ; import java . lang . reflect . Method ; import de . robv . android . xposed . XposedBridge ; import de . robv . android . xposed . XposedHelpers ; public class StateListDrawableCompact { private static final Class < ? > mClass = StateListDrawable . class ; private StateListDrawableCompact ( ) { } public static int getStateCount ( StateListDrawable stateListDrawable ) {", "output": "if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateCount ( ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , \"<STR_LIT>\" ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable ) ; if ( invoke instanceof Integer ) { return ( Integer ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return <NUM_LIT> ; } @ Nullable public static Drawable getStateDrawable ( StateListDrawable stateListDrawable , int i ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . Q ) { return stateListDrawable . getStateDrawable ( i ) ; } else { try { Method method = XposedHelpers . findMethodBestMatch ( mClass , \"<STR_LIT>\" , Integer . TYPE ) ; if ( method != null ) { Object invoke = method . invoke ( stateListDrawable , i ) ; if ( invoke instanceof Drawable ) { return ( Drawable ) invoke ; } } } catch ( Exception e ) { XposedBridge . log ( e ) ; } } return null ; } }"}]