[{"input": "import os \n from flask import Flask , request , jsonify \n from claude_api import Client \n from common . utils import * \n app = Flask ( __name__ ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def create_chat ( ) : \n data = request . get_json ( ) \n prompt = data [ '<STR_LIT>' ] \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n conversation = client . create_new_chat ( ) \n conversation_id = conversation [ '<STR_LIT>' ] \n response = client . send_message ( prompt , conversation_id ) \n return jsonify ( { '<STR_LIT>' : conversation_id , '<STR_LIT>' : response } ) \n @ app . route ( '<STR_LIT>' ) \n def get_chat_history ( conversation_id ) : \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n print ( isproxy ) \n client = Client ( cookie , isproxy ) \n history = client . chat_conversation_history ( conversation_id ) \n return jsonify ( history ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def send_message ( ) : \n data = request . get_json ( ) \n conversation_id = data [ '<STR_LIT>' ] \n prompt = data [ '<STR_LIT>' ] \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n response = client . send_message ( prompt , conversation_id ) \n return jsonify ( { '<STR_LIT>' : response } ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def send_message_attachment ( ) : \n conversation_id = request . form . get ( \"<STR_LIT>\" ) \n prompt = request . form . get ( \"<STR_LIT>\" ) \n file = request . files [ '<STR_LIT>' ] \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n file_path = None", "output": "if file : \n file_path = save_upload_file ( file ) \n response = client . send_message ( prompt , conversation_id , file_path ) \n return jsonify ( { '<STR_LIT>' : response } ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def reset_conversations ( ) : \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n result = client . reset_all ( ) \n return jsonify ( { '<STR_LIT>' : result } ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def rename_conversation ( ) : \n data = request . get_json ( ) \n conversation_id = data [ '<STR_LIT>' ] \n title = data [ '<STR_LIT>' ] \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n result = client . rename_chat ( title , conversation_id ) \n return jsonify ( { '<STR_LIT>' : result } ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' ] ) \n def upload_attachment ( ) : \n file = request . files [ '<STR_LIT>' ] \n if file : \n file_path = save_upload_file ( file ) \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n response = client . upload_attachment ( file_path ) \n return jsonify ( { '<STR_LIT>' : response } ) \n else : \n return jsonify ( { '<STR_LIT>' : '<STR_LIT>' } ) , <NUM_LIT> \n def save_upload_file ( file ) : \n uploads_dir = os . getenv ( '<STR_LIT>' ) \n print ( uploads_dir ) \n file_path = os . path . join ( uploads_dir , file . filename ) \n file . save ( file_path ) \n return file_path \n @ app . route ( '<STR_LIT>' ) \n def list_all_conversations ( ) : \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n conversations = client . list_all_conversations ( ) \n return jsonify ( conversations ) \n @ app . route ( '<STR_LIT>' ) \n def chat_conversation_history ( conversation_id ) : \n cookie = get_cookie ( ) \n isproxy = get_proxy ( ) \n client = Client ( cookie , isproxy ) \n history = client . chat_conversation_history ( conversation_id ) \n return jsonify ( history ) \n if __name__ == '<STR_LIT>' : \n app . run ( host = '<STR_LIT>' , port = <NUM_LIT> , debug = True , use_reloader = True ) \n app . default_encoding = '<STR_LIT>'"}, {"input": "import pickle \n class IDStorage : \n def __init__ ( self ) : \n self . id = None \n def get_id ( self ) : \n if self . id is None : \n try : \n with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : \n self . id = pickle . load ( f ) \n except FileNotFoundError : \n print ( \"<STR_LIT>\" ) \n return self . id \n def set_id ( self , id ) : \n self . id = id \n with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : \n pickle . dump ( self . id , f ) \n storage = IDStorage ( ) \n id_value = storage . get_id ( )", "output": "storage . set_id ( \"<STR_LIT>\" ) \n if id_value is not None : \n print ( \"<STR_LIT>\" ) \n else : \n print ( id_value )"}, {"input": "import re , os , sys , subprocess , copy , traceback , logging \n try : \n from HTMLParser import HTMLParser \n except ImportError : \n from html . parser import HTMLParser \n try : \n from urllib import quote as _quote \n quote = lambda n : _quote ( n . encode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n except ImportError : \n from urllib . parse import quote \n import requests \n from . import config \n logger = logging . getLogger ( '<STR_LIT>' ) \n emojiRegex = re . compile ( r'<STR_LIT>' ) \n htmlParser = HTMLParser ( ) \n if not hasattr ( htmlParser , '<STR_LIT>' ) : \n import html \n htmlParser . unescape = html . unescape \n try : \n b = u'<STR_LIT>' \n sys . stdout . write ( b + '<STR_LIT>' ) \n sys . stdout . flush ( ) \n except UnicodeEncodeError : \n BLOCK = '<STR_LIT>' \n else : \n BLOCK = b \n friendInfoTemplate = { } \n for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : \n friendInfoTemplate [ k ] = '<STR_LIT>' \n for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' , '<STR_LIT>' ) : \n friendInfoTemplate [ k ] = <NUM_LIT> \n friendInfoTemplate [ '<STR_LIT>' ] = [ ] \n def clear_screen ( ) : \n os . system ( '<STR_LIT>' if config . OS == '<STR_LIT>' else '<STR_LIT>' ) \n def emoji_formatter ( d , k ) : \n def _emoji_debugger ( d , k ) : \n s = d [ k ] . replace ( '<STR_LIT>' ,", "output": "'<STR_LIT>' ) \n def __fix_miss_match ( m ) : \n return '<STR_LIT>' % ( { \n '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' , \n } . get ( m . group ( <NUM_LIT> ) , m . group ( <NUM_LIT> ) ) ) \n return emojiRegex . sub ( __fix_miss_match , s ) \n def _emoji_formatter ( m ) : \n s = m . group ( <NUM_LIT> ) \n if len ( s ) == <NUM_LIT> : \n return ( '<STR_LIT>' % ( s [ : <NUM_LIT> ] . rjust ( <NUM_LIT> , '<STR_LIT>' ) , s [ <NUM_LIT> : ] . rjust ( <NUM_LIT> , '<STR_LIT>' ) ) \n ) . encode ( '<STR_LIT>' ) . decode ( '<STR_LIT>' , '<STR_LIT>' ) \n elif len ( s ) == <NUM_LIT> : \n return ( '<STR_LIT>' % ( s [ : <NUM_LIT> ] . rjust ( <NUM_LIT> , '<STR_LIT>' ) , s [ <NUM_LIT> : ] . rjust ( <NUM_LIT> , '<STR_LIT>' ) ) \n ) . encode ( '<STR_LIT>' ) . decode ( '<STR_LIT>' , '<STR_LIT>' ) \n else : \n return ( '<STR_LIT>' % m . group ( <NUM_LIT> ) . rjust ( <NUM_LIT> , '<STR_LIT>' ) \n ) . encode ( '<STR_LIT>' ) . decode ( '<STR_LIT>' , '<STR_LIT>' ) \n d [ k ] = _emoji_debugger ( d , k ) \n d [ k ] = emojiRegex . sub ( _emoji_formatter , d [ k ] ) \n def msg_formatter ( d , k ) : \n emoji_formatter ( d , k ) \n d [ k ] = d [ k ] . replace ( '<STR_LIT>' , '<STR_LIT>' ) \n d [ k ] = htmlParser . unescape ( d [ k ] ) \n def check_file ( fileDir ) : \n try : \n with open ( fileDir ) : \n pass \n return True \n except : \n return False \n def print_qr ( fileDir ) : \n if config . OS == '<STR_LIT>' : \n subprocess . call ( [ '<STR_LIT>' , fileDir ] ) \n elif config . OS == '<STR_LIT>' : \n subprocess . call ( [ '<STR_LIT>' , fileDir ] ) \n else : \n os . startfile ( fileDir ) \n def print_cmd_qr ( qrText , white = BLOCK , black = '<STR_LIT>' , enableCmdQR = True ) : \n blockCount = int ( enableCmdQR ) \n if abs ( blockCount ) == <NUM_LIT> : \n blockCount = <NUM_LIT> \n white *= abs ( blockCount ) \n if blockCount < <NUM_LIT> : \n white , black = black , white \n sys . stdout . write ( '<STR_LIT>' * <NUM_LIT> + '<STR_LIT>' ) \n sys . stdout . flush ( ) \n qr = qrText . replace ( '<STR_LIT>' , white ) . replace ( '<STR_LIT>' , black ) \n sys . stdout . write ( qr ) \n sys . stdout . flush ( ) \n def struct_friend_info ( knownInfo ) : \n member = copy . deepcopy ( friendInfoTemplate ) \n for k , v in copy . deepcopy ( knownInfo ) . items ( ) : member [ k ] = v \n return member \n def search_dict_list ( l , key , value ) : \n for i in l : \n if i . get ( key ) == value : \n return i \n def print_line ( msg , oneLine = False ) : \n if oneLine : \n sys . stdout . write ( '<STR_LIT>' * <NUM_LIT> + '<STR_LIT>' ) \n sys . stdout . flush ( ) \n else : \n sys . stdout . write ( '<STR_LIT>' ) \n sys . stdout . write ( msg . encode ( sys . stdin . encoding or '<STR_LIT>' , '<STR_LIT>' \n ) . decode ( sys . stdin . encoding or '<STR_LIT>' , '<STR_LIT>' ) ) \n sys . stdout . flush ( ) \n def test_connect ( retryTime = <NUM_LIT> ) : \n for i in range ( retryTime ) : \n try : \n r = requests . get ( config . BASE_URL ) \n return True \n except : \n if i == retryTime - <NUM_LIT> : \n logger . error ( traceback . format_exc ( ) ) \n return False \n def contact_deep_copy ( core , contact ) : \n with core . storageClass . updateLock : \n return copy . deepcopy ( contact ) \n def get_image_postfix ( data ) : \n data = data [ : <NUM_LIT> ] \n if b'<STR_LIT>' in data : \n return '<STR_LIT>' \n elif b'<STR_LIT>' in data : \n return '<STR_LIT>' \n elif b'<STR_LIT>' in data : \n return '<STR_LIT>' \n return '<STR_LIT>' \n def update_info_dict ( oldInfoDict , newInfoDict ) : \n for k , v in newInfoDict . items ( ) : \n if any ( ( isinstance ( v , t ) for t in ( tuple , list , dict ) ) ) : \n pass \n elif oldInfoDict . get ( k ) is None or v not in ( None , '<STR_LIT>' , '<STR_LIT>' , <NUM_LIT> ) : \n oldInfoDict [ k ] = v"}, {"input": "import time \n import re \n import io \n import json \n import copy \n import logging \n from . . import config , utils \n from . . returnvalues import ReturnValue \n from . . storage import contact_change \n from . . utils import update_info_dict \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_contact ( core ) : \n core . update_chatroom = update_chatroom \n core . update_friend = update_friend \n core . get_contact = get_contact \n core . get_friends = get_friends \n core . get_chatrooms = get_chatrooms \n core . get_mps = get_mps \n core . set_alias = set_alias \n core . set_pinned = set_pinned \n core . accept_friend = accept_friend \n core . get_head_img = get_head_img \n core . create_chatroom = create_chatroom \n core . set_chatroom_name = set_chatroom_name \n core . delete_member_from_chatroom = delete_member_from_chatroom \n core . add_member_into_chatroom = add_member_into_chatroom \n def update_chatroom ( self , userName , detailedMember = False ) : \n if not isinstance ( userName , list ) : \n userName = [ userName ] \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , int ( time . time ( ) ) ) \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : len ( userName ) , \n '<STR_LIT>' : [ { \n '<STR_LIT>' : u , \n '<STR_LIT>' : '<STR_LIT>' , } for u in userName ] , } \n chatroomList = json . loads ( self . s . post ( url , data = json . dumps ( data ) , headers = headers \n ) . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) . get ( '<STR_LIT>' ) \n if not chatroomList : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n if detailedMember : \n def get_detailed_member_info ( encryChatroomId , memberList ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , int ( time . time ( ) ) ) \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : len ( memberList ) , \n '<STR_LIT>' : [ { \n '<STR_LIT>' : member [ '<STR_LIT>' ] , \n '<STR_LIT>' : encryChatroomId } \n for member in memberList ] , } \n return json . loads ( self . s . post ( url , data = json . dumps ( data ) , headers = headers \n ) . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) [ '<STR_LIT>' ] \n MAX_GET_NUMBER = <NUM_LIT> \n for chatroom in chatroomList : \n totalMemberList = [ ] \n for i in range ( int ( len ( chatroom [ '<STR_LIT>' ] ) / MAX_GET_NUMBER + <NUM_LIT> ) ) : \n memberList = chatroom [ '<STR_LIT>' ] [ i * \n MAX_GET_NUMBER : ( i + <NUM_LIT> ) * MAX_GET_NUMBER ] \n totalMemberList += get_detailed_member_info ( \n chatroom [ '<STR_LIT>' ] , memberList ) \n chatroom [ '<STR_LIT>' ] = totalMemberList \n update_local_chatrooms ( self , chatroomList ) \n r = [ self . storageClass . search_chatrooms ( userName = c [ '<STR_LIT>' ] ) \n for c in chatroomList ] \n return r if <NUM_LIT> < len ( r ) else r [ <NUM_LIT> ] \n def update_friend ( self , userName ) : \n if not isinstance ( userName , list ) : \n userName = [ userName ] \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , int ( time . time ( ) ) ) \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : len ( userName ) , \n '<STR_LIT>' : [ { \n '<STR_LIT>' : u , \n '<STR_LIT>' : '<STR_LIT>' , } for u in userName ] , } \n friendList = json . loads ( self . s . post ( url , data = json . dumps ( data ) , headers = headers \n ) . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) . get ( '<STR_LIT>' ) \n update_local_friends ( self , friendList ) \n r = [ self . storageClass . search_friends ( userName = f [ '<STR_LIT>' ] ) \n for f in friendList ] \n return r if len ( r ) != <NUM_LIT> else r [ <NUM_LIT> ] \n @ contact_change \n def update_local_chatrooms ( core , l ) : \n for chatroom in l : \n utils . emoji_formatter ( chatroom , '<STR_LIT>' ) \n for member in chatroom [ '<STR_LIT>' ] : \n if '<STR_LIT>' in member : \n utils . emoji_formatter ( member , '<STR_LIT>' ) \n if '<STR_LIT>' in member : \n utils . emoji_formatter ( member , '<STR_LIT>' ) \n if '<STR_LIT>' in member : \n utils . emoji_formatter ( member , '<STR_LIT>' ) \n oldChatroom = utils . search_dict_list ( \n core . chatroomList , '<STR_LIT>' , chatroom [ '<STR_LIT>' ] ) \n if oldChatroom : \n update_info_dict ( oldChatroom , chatroom ) \n memberList = chatroom . get ( '<STR_LIT>' , [ ] ) \n oldMemberList = oldChatroom [ '<STR_LIT>' ] \n if memberList : \n for member in memberList : \n oldMember = utils . search_dict_list ( \n oldMemberList , '<STR_LIT>' , member [ '<STR_LIT>' ] ) \n if oldMember : \n update_info_dict ( oldMember , member ) \n else : \n oldMemberList . append ( member ) \n else : \n core . chatroomList . append ( chatroom ) \n oldChatroom = utils . search_dict_list ( \n core . chatroomList , '<STR_LIT>' , chatroom [ '<STR_LIT>' ] ) \n if len ( chatroom [ '<STR_LIT>' ] ) != len ( oldChatroom [ '<STR_LIT>' ] ) and chatroom [ '<STR_LIT>' ] : \n existsUserNames = [ member [ '<STR_LIT>' ] \n for member in chatroom [ '<STR_LIT>' ] ] \n delList = [ ] \n for i , member in enumerate ( oldChatroom [ '<STR_LIT>' ] ) : \n if member [ '<STR_LIT>' ] not in existsUserNames : \n delList . append ( i ) \n delList . sort ( reverse = True ) \n for i in delList : \n del oldChatroom [ '<STR_LIT>' ] [ i ] \n if oldChatroom . get ( '<STR_LIT>' ) and oldChatroom . get ( '<STR_LIT>' ) : \n owner = utils . search_dict_list ( oldChatroom [ '<STR_LIT>' ] , \n '<STR_LIT>' , oldChatroom [ '<STR_LIT>' ] ) \n oldChatroom [ '<STR_LIT>' ] = ( owner or { } ) . get ( '<STR_LIT>' , <NUM_LIT> ) \n if '<STR_LIT>' in oldChatroom and oldChatroom [ '<STR_LIT>' ] != <NUM_LIT> : \n oldChatroom [ '<STR_LIT>' ] = oldChatroom [ '<STR_LIT>' ] == int ( core . loginInfo [ '<STR_LIT>' ] )", "output": "else : \n oldChatroom [ '<STR_LIT>' ] = None \n newSelf = utils . search_dict_list ( oldChatroom [ '<STR_LIT>' ] , \n '<STR_LIT>' , core . storageClass . userName ) \n oldChatroom [ '<STR_LIT>' ] = newSelf or copy . deepcopy ( core . loginInfo [ '<STR_LIT>' ] ) \n return { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : [ chatroom [ '<STR_LIT>' ] for chatroom in l ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : core . storageClass . userName , \n '<STR_LIT>' : core . storageClass . userName , } \n @ contact_change \n def update_local_friends ( core , l ) : \n fullList = core . memberList + core . mpList \n for friend in l : \n if '<STR_LIT>' in friend : \n utils . emoji_formatter ( friend , '<STR_LIT>' ) \n if '<STR_LIT>' in friend : \n utils . emoji_formatter ( friend , '<STR_LIT>' ) \n if '<STR_LIT>' in friend : \n utils . emoji_formatter ( friend , '<STR_LIT>' ) \n oldInfoDict = utils . search_dict_list ( \n fullList , '<STR_LIT>' , friend [ '<STR_LIT>' ] ) \n if oldInfoDict is None : \n oldInfoDict = copy . deepcopy ( friend ) \n if oldInfoDict [ '<STR_LIT>' ] & <NUM_LIT> == <NUM_LIT> : \n core . memberList . append ( oldInfoDict ) \n else : \n core . mpList . append ( oldInfoDict ) \n else : \n update_info_dict ( oldInfoDict , friend ) \n @ contact_change \n def update_local_uin ( core , msg ) : \n uins = re . search ( '<STR_LIT>' , msg [ '<STR_LIT>' ] ) \n usernameChangedList = [ ] \n r = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : usernameChangedList , \n '<STR_LIT>' : '<STR_LIT>' , } \n if uins : \n uins = uins . group ( <NUM_LIT> ) . split ( '<STR_LIT>' ) \n usernames = msg [ '<STR_LIT>' ] . split ( '<STR_LIT>' ) \n if <NUM_LIT> < len ( uins ) == len ( usernames ) : \n for uin , username in zip ( uins , usernames ) : \n if not '<STR_LIT>' in username : \n continue \n fullContact = core . memberList + core . chatroomList + core . mpList \n userDicts = utils . search_dict_list ( fullContact , \n '<STR_LIT>' , username ) \n if userDicts : \n if userDicts . get ( '<STR_LIT>' , <NUM_LIT> ) == <NUM_LIT> : \n userDicts [ '<STR_LIT>' ] = uin \n usernameChangedList . append ( username ) \n logger . debug ( '<STR_LIT>' % ( username , uin ) ) \n else : \n if userDicts [ '<STR_LIT>' ] != uin : \n logger . debug ( '<STR_LIT>' % ( \n userDicts [ '<STR_LIT>' ] , uin ) ) \n else : \n if '<STR_LIT>' in username : \n core . storageClass . updateLock . release ( ) \n update_chatroom ( core , username ) \n core . storageClass . updateLock . acquire ( ) \n newChatroomDict = utils . search_dict_list ( \n core . chatroomList , '<STR_LIT>' , username ) \n if newChatroomDict is None : \n newChatroomDict = utils . struct_friend_info ( { \n '<STR_LIT>' : username , \n '<STR_LIT>' : uin , \n '<STR_LIT>' : copy . deepcopy ( core . loginInfo [ '<STR_LIT>' ] ) } ) \n core . chatroomList . append ( newChatroomDict ) \n else : \n newChatroomDict [ '<STR_LIT>' ] = uin \n elif '<STR_LIT>' in username : \n core . storageClass . updateLock . release ( ) \n update_friend ( core , username ) \n core . storageClass . updateLock . acquire ( ) \n newFriendDict = utils . search_dict_list ( \n core . memberList , '<STR_LIT>' , username ) \n if newFriendDict is None : \n newFriendDict = utils . struct_friend_info ( { \n '<STR_LIT>' : username , \n '<STR_LIT>' : uin , } ) \n core . memberList . append ( newFriendDict ) \n else : \n newFriendDict [ '<STR_LIT>' ] = uin \n usernameChangedList . append ( username ) \n logger . debug ( '<STR_LIT>' % ( username , uin ) ) \n else : \n logger . debug ( '<STR_LIT>' % ( \n len ( uins ) , len ( usernames ) ) ) \n else : \n logger . debug ( '<STR_LIT>' ) \n logger . debug ( msg [ '<STR_LIT>' ] ) \n return r \n def get_contact ( self , update = False ) : \n if not update : \n return utils . contact_deep_copy ( self , self . chatroomList ) \n def _get_contact ( seq = <NUM_LIT> ) : \n url = '<STR_LIT>' % ( self . loginInfo [ '<STR_LIT>' ] , \n int ( time . time ( ) ) , seq , self . loginInfo [ '<STR_LIT>' ] ) \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n try : \n r = self . s . get ( url , headers = headers ) \n except : \n logger . info ( \n '<STR_LIT>' ) \n for chatroom in self . get_chatrooms ( ) : \n self . update_chatroom ( chatroom [ '<STR_LIT>' ] , detailedMember = True ) \n return <NUM_LIT> , [ ] \n j = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n return j . get ( '<STR_LIT>' , <NUM_LIT> ) , j . get ( '<STR_LIT>' ) \n seq , memberList = <NUM_LIT> , [ ] \n while <NUM_LIT> : \n seq , batchMemberList = _get_contact ( seq ) \n memberList . extend ( batchMemberList ) \n if seq == <NUM_LIT> : \n break \n chatroomList , otherList = [ ] , [ ] \n for m in memberList : \n if m [ '<STR_LIT>' ] != <NUM_LIT> : \n otherList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n chatroomList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n otherList . append ( m ) \n if chatroomList : \n update_local_chatrooms ( self , chatroomList ) \n if otherList : \n update_local_friends ( self , otherList ) \n return utils . contact_deep_copy ( self , chatroomList ) \n def get_friends ( self , update = False ) : \n if update : \n self . get_contact ( update = True ) \n return utils . contact_deep_copy ( self , self . memberList ) \n def get_chatrooms ( self , update = False , contactOnly = False ) : \n if contactOnly : \n return self . get_contact ( update = True ) \n else : \n if update : \n self . get_contact ( True ) \n return utils . contact_deep_copy ( self , self . chatroomList ) \n def get_mps ( self , update = False ) : \n if update : \n self . get_contact ( update = True ) \n return utils . contact_deep_copy ( self , self . mpList ) \n def set_alias ( self , userName , alias ) : \n oldFriendInfo = utils . search_dict_list ( \n self . memberList , '<STR_LIT>' , userName ) \n if oldFriendInfo is None : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : userName , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : alias , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' ) , \n headers = headers ) \n r = ReturnValue ( rawResponse = r ) \n if r : \n oldFriendInfo [ '<STR_LIT>' ] = alias \n return r \n def set_pinned ( self , userName , isPinned = True ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : userName , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : int ( isPinned ) , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , json = data , headers = headers ) \n return ReturnValue ( rawResponse = r ) \n def accept_friend ( self , userName , v4 = '<STR_LIT>' , autoUpdate = True ) : \n url = f\"<STR_LIT>\" \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : [ { \n '<STR_LIT>' : userName , \n '<STR_LIT>' : v4 , } ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : [ <NUM_LIT> ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , headers = headers , \n data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n if autoUpdate : \n self . update_friend ( userName ) \n return ReturnValue ( rawResponse = r ) \n def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : \n params = { \n '<STR_LIT>' : userName or chatroomUserName or self . storageClass . userName , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : '<STR_LIT>' , } \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n if chatroomUserName is None : \n infoDict = self . storageClass . search_friends ( userName = userName ) \n if infoDict is None : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n else : \n if userName is None : \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n else : \n chatroom = self . storageClass . search_chatrooms ( \n userName = chatroomUserName ) \n if chatroomUserName is None : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n if '<STR_LIT>' in chatroom : \n params [ '<STR_LIT>' ] = chatroom [ '<STR_LIT>' ] \n params [ '<STR_LIT>' ] = params . get ( \n '<STR_LIT>' ) or chatroom [ '<STR_LIT>' ] \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . get ( url , params = params , stream = True , headers = headers ) \n tempStorage = io . BytesIO ( ) \n for block in r . iter_content ( <NUM_LIT> ) : \n tempStorage . write ( block ) \n if picDir is None : \n return tempStorage . getvalue ( ) \n with open ( picDir , '<STR_LIT>' ) as f : \n f . write ( tempStorage . getvalue ( ) ) \n tempStorage . seek ( <NUM_LIT> ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , } , \n '<STR_LIT>' : utils . get_image_postfix ( tempStorage . read ( <NUM_LIT> ) ) , } ) \n def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] , int ( time . time ( ) ) ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : len ( memberList . split ( '<STR_LIT>' ) ) , \n '<STR_LIT>' : [ { '<STR_LIT>' : member } for member in memberList . split ( '<STR_LIT>' ) ] , \n '<STR_LIT>' : topic , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , headers = headers , \n data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n return ReturnValue ( rawResponse = r ) \n def set_chatroom_name ( self , chatroomUserName , name ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : chatroomUserName , \n '<STR_LIT>' : name , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , headers = headers , \n data = json . dumps ( data , ensure_ascii = False ) . encode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n return ReturnValue ( rawResponse = r ) \n def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : chatroomUserName , \n '<STR_LIT>' : '<STR_LIT>' . join ( [ member [ '<STR_LIT>' ] for member in memberList ] ) , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , data = json . dumps ( data ) , headers = headers ) \n return ReturnValue ( rawResponse = r ) \n def add_member_into_chatroom ( self , chatroomUserName , memberList , \n useInvitation = False ) : \n if not useInvitation : \n chatroom = self . storageClass . search_chatrooms ( \n userName = chatroomUserName ) \n if not chatroom : \n chatroom = self . update_chatroom ( chatroomUserName ) \n if len ( chatroom [ '<STR_LIT>' ] ) > self . loginInfo [ '<STR_LIT>' ] : \n useInvitation = True \n if useInvitation : \n fun , memberKeyName = '<STR_LIT>' , '<STR_LIT>' \n else : \n fun , memberKeyName = '<STR_LIT>' , '<STR_LIT>' \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , fun , self . loginInfo [ '<STR_LIT>' ] ) \n params = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : chatroomUserName , \n memberKeyName : memberList , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , data = json . dumps ( params ) , headers = headers ) \n return ReturnValue ( rawResponse = r )"}]