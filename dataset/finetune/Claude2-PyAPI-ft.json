[{"input": "import os \n import time \n import re \n import io \n import threading \n import json \n import xml . dom . minidom \n import random \n import traceback \n import logging \n try : \n from httplib import BadStatusLine \n except ImportError : \n from http . client import BadStatusLine \n import requests \n from pyqrcode import QRCode \n from . . import config , utils \n from . . returnvalues import ReturnValue \n from . . storage . templates import wrap_user_dict \n from . contact import update_local_chatrooms , update_local_friends \n from . messages import produce_msg \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_login ( core ) : \n core . login = login \n core . get_QRuuid = get_QRuuid \n core . get_QR = get_QR \n core . check_login = check_login \n core . web_init = web_init \n core . show_mobile_login = show_mobile_login \n core . start_receiving = start_receiving \n core . get_msg = get_msg \n core . logout = logout \n def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , \n loginCallback = None , exitCallback = None ) : \n if self . alive or self . isLogging : \n logger . warning ( '<STR_LIT>' ) \n return \n self . isLogging = True \n logger . info ( '<STR_LIT>' ) \n while self . isLogging : \n uuid = push_login ( self ) \n if uuid : \n qrStorage = io . BytesIO ( ) \n else : \n logger . info ( '<STR_LIT>' ) \n while not self . get_QRuuid ( ) : \n time . sleep ( <NUM_LIT> ) \n logger . info ( '<STR_LIT>' ) \n qrStorage = self . get_QR ( enableCmdQR = enableCmdQR , \n picDir = picDir , qrCallback = qrCallback ) \n isLoggedIn = False \n while not isLoggedIn : \n status = self . check_login ( ) \n if hasattr ( qrCallback , '<STR_LIT>' ) : \n qrCallback ( uuid = self . uuid , status = status , \n qrcode = qrStorage . getvalue ( ) ) \n if status == '<STR_LIT>' : \n isLoggedIn = True \n elif status == '<STR_LIT>' : \n if isLoggedIn is not None : \n logger . info ( '<STR_LIT>' ) \n isLoggedIn = None \n time . sleep ( <NUM_LIT> ) \n time . sleep ( <NUM_LIT> ) \n elif status != '<STR_LIT>' : \n break \n if isLoggedIn : \n break \n elif self . isLogging : \n logger . info ( '<STR_LIT>' ) \n else : \n return \n logger . info ( '<STR_LIT>' ) \n self . web_init ( ) \n self . show_mobile_login ( ) \n self . get_contact ( True ) \n if hasattr ( loginCallback , '<STR_LIT>' ) : \n r = loginCallback ( ) \n else : \n if os . path . exists ( picDir or config . DEFAULT_QR ) : \n os . remove ( picDir or config . DEFAULT_QR ) \n logger . info ( '<STR_LIT>' % self . storageClass . nickName ) \n self . start_receiving ( exitCallback ) \n self . isLogging = False \n def push_login ( core ) : \n cookiesDict = core . s . cookies . get_dict ( ) \n if '<STR_LIT>' in cookiesDict : \n url = '<STR_LIT>' % ( \n config . BASE_URL , cookiesDict [ '<STR_LIT>' ] ) \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = core . s . get ( url , headers = headers ) . json ( ) \n if '<STR_LIT>' in r and r . get ( '<STR_LIT>' ) in ( <NUM_LIT> , '<STR_LIT>' ) : \n core . uuid = r [ '<STR_LIT>' ] \n return r [ '<STR_LIT>' ] \n return False \n def get_QRuuid ( self ) : \n url = '<STR_LIT>' % config . BASE_URL \n params = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . get ( url , params = params , headers = headers ) \n regx = r'<STR_LIT>' \n data = re . search ( regx , r . text ) \n if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : \n self . uuid = data . group ( <NUM_LIT> ) \n return self . uuid \n def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : \n uuid = uuid or self . uuid \n picDir = picDir or config . DEFAULT_QR \n qrStorage = io . BytesIO ( ) \n qrCode = QRCode ( '<STR_LIT>' + uuid ) \n qrCode . png ( qrStorage , scale = <NUM_LIT> ) \n if hasattr ( qrCallback , '<STR_LIT>' ) : \n qrCallback ( uuid = uuid , status = '<STR_LIT>' , qrcode = qrStorage . getvalue ( ) ) \n else : \n with open ( picDir , '<STR_LIT>' ) as f : \n f . write ( qrStorage . getvalue ( ) ) \n if enableCmdQR : \n utils . print_cmd_qr ( qrCode . text ( <NUM_LIT> ) , enableCmdQR = enableCmdQR ) \n else : \n utils . print_qr ( picDir ) \n return qrStorage \n def check_login ( self , uuid = None ) : \n uuid = uuid or self . uuid \n url = '<STR_LIT>' % config . BASE_URL \n localTime = int ( time . time ( ) ) \n params = '<STR_LIT>' % ( \n uuid , int ( - localTime / <NUM_LIT> ) , localTime ) \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . get ( url , params = params , headers = headers ) \n regx = r'<STR_LIT>' \n data = re . search ( regx , r . text ) \n if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : \n if process_login_info ( self , r . text ) : \n return '<STR_LIT>' \n else : \n return '<STR_LIT>' \n elif data : \n return data . group ( <NUM_LIT> ) \n else : \n return '<STR_LIT>' \n def process_login_info ( core , loginContent ) : \n regx = r'<STR_LIT>' \n core . loginInfo [ '<STR_LIT>' ] = re . search ( regx , loginContent ) . group ( <NUM_LIT> ) \n headers = { '<STR_LIT>' : config . USER_AGENT , \n '<STR_LIT>' : config . UOS_PATCH_CLIENT_VERSION , \n '<STR_LIT>' : config . UOS_PATCH_EXTSPAM , \n '<STR_LIT>' : '<STR_LIT>' \n } \n r = core . s . get ( core . loginInfo [ '<STR_LIT>' ] , \n headers = headers , allow_redirects = False ) \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ : core . loginInfo [ '<STR_LIT>' ] . rfind ( \n '<STR_LIT>' ) ] \n for indexUrl , detailedUrl in ( \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) :", "output": "fileUrl , syncUrl = [ '<STR_LIT>' % \n url for url in detailedUrl ] \n if indexUrl in core . loginInfo [ '<STR_LIT>' ] : \n core . loginInfo [ '<STR_LIT>' ] , core . loginInfo [ '<STR_LIT>' ] = fileUrl , syncUrl \n break \n else : \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] \n core . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] \n core . loginInfo [ '<STR_LIT>' ] = int ( time . time ( ) * <NUM_LIT> ) \n core . loginInfo [ '<STR_LIT>' ] = { } \n cookies = core . s . cookies . get_dict ( ) \n res = re . findall ( '<STR_LIT>' , r . text , re . S ) \n skey = res [ <NUM_LIT> ] if res else None \n res = re . findall ( \n '<STR_LIT>' , r . text , re . S ) \n pass_ticket = res [ <NUM_LIT> ] if res else None \n if skey is not None : \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = skey \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ \"<STR_LIT>\" ] \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ \"<STR_LIT>\" ] \n if pass_ticket is not None : \n core . loginInfo [ '<STR_LIT>' ] = pass_ticket \n if not all ( [ key in core . loginInfo for key in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : \n logger . error ( \n '<STR_LIT>' % r . text ) \n core . isLogging = False \n return False \n return True \n def web_init ( self ) : \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n params = { \n '<STR_LIT>' : int ( - time . time ( ) / <NUM_LIT> ) , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n data = { '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n r = self . s . post ( url , params = params , data = json . dumps ( data ) , headers = headers ) \n dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n utils . emoji_formatter ( dic [ '<STR_LIT>' ] , '<STR_LIT>' ) \n self . loginInfo [ '<STR_LIT>' ] = int ( dic [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] = wrap_user_dict ( \n utils . struct_friend_info ( dic [ '<STR_LIT>' ] ) ) \n self . memberList . append ( self . loginInfo [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) \n for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) \n self . storageClass . userName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n self . storageClass . nickName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n contactList = dic . get ( '<STR_LIT>' , [ ] ) \n chatroomList , otherList = [ ] , [ ] \n for m in contactList : \n if m [ '<STR_LIT>' ] != <NUM_LIT> : \n otherList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n m [ '<STR_LIT>' ] = [ ] \n chatroomList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n otherList . append ( m ) \n if chatroomList : \n update_local_chatrooms ( self , chatroomList ) \n if otherList : \n update_local_friends ( self , otherList ) \n return dic \n def show_mobile_login ( self ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : self . storageClass . userName , \n '<STR_LIT>' : self . storageClass . userName , \n '<STR_LIT>' : int ( time . time ( ) ) , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n r = self . s . post ( url , data = json . dumps ( data ) , headers = headers ) \n return ReturnValue ( rawResponse = r ) \n def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : \n self . alive = True \n def maintain_loop ( ) : \n retryCount = <NUM_LIT> \n while self . alive : \n try : \n i = sync_check ( self ) \n if i is None : \n self . alive = False \n elif i == '<STR_LIT>' : \n pass \n else : \n msgList , contactList = self . get_msg ( ) \n if msgList : \n msgList = produce_msg ( self , msgList ) \n for msg in msgList : \n self . msgList . put ( msg ) \n if contactList : \n chatroomList , otherList = [ ] , [ ] \n for contact in contactList : \n if '<STR_LIT>' in contact [ '<STR_LIT>' ] : \n chatroomList . append ( contact ) \n else : \n otherList . append ( contact ) \n chatroomMsg = update_local_chatrooms ( \n self , chatroomList ) \n chatroomMsg [ '<STR_LIT>' ] = self . loginInfo [ '<STR_LIT>' ] \n self . msgList . put ( chatroomMsg ) \n update_local_friends ( self , otherList ) \n retryCount = <NUM_LIT> \n except requests . exceptions . ReadTimeout : \n pass \n except : \n retryCount += <NUM_LIT> \n logger . error ( traceback . format_exc ( ) ) \n if self . receivingRetryCount < retryCount : \n logger . error ( \"<STR_LIT>\" % ( \n retryCount ) + \"<STR_LIT>\" ) \n self . alive = False \n else : \n time . sleep ( <NUM_LIT> ) \n self . logout ( ) \n if hasattr ( exitCallback , '<STR_LIT>' ) : \n exitCallback ( ) \n else : \n logger . info ( '<STR_LIT>' ) \n if getReceivingFnOnly : \n return maintain_loop \n else : \n maintainThread = threading . Thread ( target = maintain_loop ) \n maintainThread . setDaemon ( True ) \n maintainThread . start ( ) \n def sync_check ( self ) : \n url = '<STR_LIT>' % self . loginInfo . get ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) \n params = { \n '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n self . loginInfo [ '<STR_LIT>' ] += <NUM_LIT> \n try : \n r = self . s . get ( url , params = params , headers = headers , \n timeout = config . TIMEOUT ) \n except requests . exceptions . ConnectionError as e : \n try : \n if not isinstance ( e . args [ <NUM_LIT> ] . args [ <NUM_LIT> ] , BadStatusLine ) : \n raise \n return '<STR_LIT>' \n except : \n raise \n r . raise_for_status ( ) \n regx = r'<STR_LIT>' \n pm = re . search ( regx , r . text ) \n if pm is None or pm . group ( <NUM_LIT> ) != '<STR_LIT>' : \n logger . error ( '<STR_LIT>' % r . text ) \n return None \n return pm . group ( <NUM_LIT> ) \n def get_msg ( self ) : \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] , \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : ~ int ( time . time ( ) ) , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , data = json . dumps ( data ) , \n headers = headers , timeout = config . TIMEOUT ) \n dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n if dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] != <NUM_LIT> : \n return None , None \n self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) \n for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) \n return dic [ '<STR_LIT>' ] , dic [ '<STR_LIT>' ] \n def logout ( self ) : \n if self . alive : \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n params = { \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n self . s . get ( url , params = params , headers = headers ) \n self . alive = False \n self . isLogging = False \n self . s . cookies . clear ( ) \n del self . chatroomList [ : ] \n del self . memberList [ : ] \n del self . mpList [ : ] \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , } } )"}, {"input": "from bridge . bridge import Bridge \n class Channel ( object ) : \n def startup ( self ) : \n raise NotImplementedError", "output": "def handle ( self , msg ) : \n raise NotImplementedError \n def send ( self , msg , receiver ) : \n raise NotImplementedError \n def build_reply_content ( self , query , context = None ) : \n return Bridge ( ) . fetch_reply_content ( query , context )"}, {"input": "from . core import Core \n from . config import VERSION , ASYNC_COMPONENTS \n from . log import set_logging \n if ASYNC_COMPONENTS : \n from . async_components import load_components \n else : \n from . components import load_components \n __version__ = VERSION \n instanceList = [ ] \n def load_async_itchat ( ) -> Core : \n from . async_components import load_components \n load_components ( Core ) \n return Core ( ) \n def load_sync_itchat ( ) -> Core : \n from . components import load_components \n load_components ( Core ) \n return Core ( ) \n if ASYNC_COMPONENTS : \n instance = load_async_itchat ( ) \n else : \n instance = load_sync_itchat ( ) \n instanceList = [ instance ] \n login = instance . login \n get_QRuuid = instance . get_QRuuid \n get_QR = instance . get_QR \n check_login = instance . check_login \n web_init = instance . web_init \n show_mobile_login = instance . show_mobile_login \n start_receiving = instance . start_receiving \n get_msg = instance . get_msg \n logout = instance . logout \n update_chatroom = instance . update_chatroom \n update_friend = instance . update_friend \n get_contact = instance . get_contact \n get_friends = instance . get_friends \n get_chatrooms = instance . get_chatrooms \n get_mps = instance . get_mps \n set_alias = instance . set_alias \n set_pinned = instance . set_pinned \n accept_friend = instance . accept_friend \n get_head_img = instance . get_head_img \n create_chatroom = instance . create_chatroom \n set_chatroom_name = instance . set_chatroom_name \n delete_member_from_chatroom = instance . delete_member_from_chatroom \n add_member_into_chatroom = instance . add_member_into_chatroom", "output": "send_raw_msg = instance . send_raw_msg \n send_msg = instance . send_msg \n upload_file = instance . upload_file \n send_file = instance . send_file \n send_image = instance . send_image \n send_video = instance . send_video \n send = instance . send \n revoke = instance . revoke \n dump_login_status = instance . dump_login_status \n load_login_status = instance . load_login_status \n auto_login = instance . auto_login \n configured_reply = instance . configured_reply \n msg_register = instance . msg_register \n run = instance . run \n search_friends = instance . search_friends \n search_chatrooms = instance . search_chatrooms \n search_mps = instance . search_mps \n set_logging = set_logging"}, {"input": "import requests \n from bot . bot import Bot \n class BaiduUnitBot ( Bot ) : \n def reply ( self , query , context = None ) : \n token = self . get_token ( ) \n url = '<STR_LIT>' + token \n post_data = \"<STR_LIT>\" + query + \"<STR_LIT>\" \n print ( post_data ) \n headers = { '<STR_LIT>' : '<STR_LIT>' }", "output": "response = requests . post ( url , data = post_data . encode ( ) , headers = headers ) \n if response : \n return response . json ( ) [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ '<STR_LIT>' ] [ <NUM_LIT> ] \n def get_token ( self ) : \n access_key = '<STR_LIT>' \n secret_key = '<STR_LIT>' \n host = '<STR_LIT>' + access_key + '<STR_LIT>' + secret_key \n response = requests . get ( host ) \n if response : \n print ( response . json ( ) ) \n return response . json ( ) [ '<STR_LIT>' ]"}, {"input": "import json \n import hmac \n import hashlib \n import base64 \n import time \n import requests \n from urllib . parse import quote_plus \n from common . log import logger \n from config import conf \n from bridge . bridge import Bridge \n from flask import Flask , request , render_template , make_response \n from channel . channel import Channel \n from concurrent . futures import ThreadPoolExecutor \n class DingTalkHandler ( Channel ) : \n def __init__ ( self ) : \n self . dingtalk_key = conf ( ) . get ( '<STR_LIT>' ) \n self . dingtalk_secret = conf ( ) . get ( '<STR_LIT>' ) \n self . dingtalk_token = conf ( ) . get ( '<STR_LIT>' ) \n self . dingtalk_post_token = conf ( ) . get ( '<STR_LIT>' ) \n self . access_token = None \n logger . info ( \"<STR_LIT>\" . format ( self . dingtalk_secret , self . dingtalk_token , self . dingtalk_post_token ) ) \n def notify_dingtalk_webhook ( self , data ) : \n timestamp = round ( time . time ( ) * <NUM_LIT> ) \n secret_enc = bytes ( self . dingtalk_secret , encoding = '<STR_LIT>' ) \n string_to_sign = '<STR_LIT>' . format ( timestamp , self . dingtalk_secret ) \n string_to_sign_enc = bytes ( string_to_sign , encoding = '<STR_LIT>' ) \n hmac_code = hmac . new ( secret_enc , string_to_sign_enc , \n digestmod = hashlib . sha256 ) . digest ( ) \n sign = quote_plus ( base64 . b64encode ( hmac_code ) ) \n notify_url = f\"<STR_LIT>\" \n try : \n logger . info ( \"<STR_LIT>\" . format ( str ( notify_url ) ) ) \n r = requests . post ( notify_url , json = data ) \n reply = r . json ( ) \n logger . info ( \"<STR_LIT>\" . format ( str ( reply ) ) ) \n except Exception as e : \n logger . error ( e ) \n def get_token_internal ( self ) : \n access_token_url = '<STR_LIT>' \n try : \n r = requests . post ( access_token_url , json = { \"<STR_LIT>\" : self . dingtalk_key , \"<STR_LIT>\" : self . dingtalk_secret } ) \n except : \n raise Exception ( \"<STR_LIT>\" ) \n data = json . loads ( r . content ) \n access_token = data [ '<STR_LIT>' ] \n expire_in = data [ '<STR_LIT>' ] \n self . access_token = access_token \n self . expire_at = int ( expire_in ) + time . time ( ) \n return self . access_token \n def get_token ( self ) : \n if self . access_token is None or self . expire_at <= time . time ( ) : \n self . get_token_internal ( ) \n return self . access_token \n def get_post_url ( self , data ) : \n type = data [ '<STR_LIT>' ] \n if type == \"<STR_LIT>\" : \n return f\"<STR_LIT>\" \n else : \n return f\"<STR_LIT>\" \n def build_response ( self , reply , data ) : \n type = data [ '<STR_LIT>' ] \n if type == \"<STR_LIT>\" :", "output": "return self . build_oto_response ( reply , data ) \n else : \n return self . build_group_response ( reply , data ) \n def build_oto_response ( self , reply , data ) : \n conversation_id = data [ '<STR_LIT>' ] \n prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n prompt = prompt . strip ( ) \n nick = data [ '<STR_LIT>' ] \n staffid = data [ '<STR_LIT>' ] \n robotCode = data [ '<STR_LIT>' ] \n resp = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : json . dumps ( { \n \"<STR_LIT>\" : reply \n } ) , \n \"<STR_LIT>\" : robotCode , \n \"<STR_LIT>\" : [ staffid ] \n } \n return resp \n def build_group_response ( self , reply , data ) : \n conversation_id = data [ '<STR_LIT>' ] \n prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n prompt = prompt . strip ( ) \n nick = data [ '<STR_LIT>' ] \n staffid = data [ '<STR_LIT>' ] \n robot_code = data [ '<STR_LIT>' ] \n resp = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : json . dumps ( { \n \"<STR_LIT>\" : reply + \"<STR_LIT>\" + \"<STR_LIT>\" + nick \n } ) , \n \"<STR_LIT>\" : robot_code , \n \"<STR_LIT>\" : conversation_id , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \n staffid \n ] , \n \"<STR_LIT>\" : False \n } \n } \n return resp \n def build_webhook_response ( self , reply , data ) : \n conversation_id = data [ '<STR_LIT>' ] \n prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n prompt = prompt . strip ( ) \n nick = data [ '<STR_LIT>' ] \n staffid = data [ '<STR_LIT>' ] \n robotCode = data [ '<STR_LIT>' ] \n resp = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : reply \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \n staffid \n ] , \n \"<STR_LIT>\" : False \n } \n } \n return resp \n def chat ( self , channel , data ) : \n reply = channel . handle ( data ) \n type = data [ '<STR_LIT>' ] \n if type == \"<STR_LIT>\" : \n reply_json = self . build_response ( reply , data ) \n self . notify_dingtalk ( data , reply_json ) \n else : \n reply_json = self . build_webhook_response ( reply , data ) \n self . notify_dingtalk_webhook ( reply_json ) \n def notify_dingtalk ( self , data , reply_json ) : \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : self . get_token ( ) \n } \n notify_url = self . get_post_url ( data ) \n try : \n r = requests . post ( notify_url , json = reply_json , headers = headers ) \n resp = r . json ( ) \n logger . info ( \"<STR_LIT>\" . format ( str ( resp ) ) ) \n except Exception as e : \n logger . error ( e ) \n class DingTalkChannel ( Channel ) : \n def __init__ ( self ) : \n self . host = conf ( ) . get ( '<STR_LIT>' ) \n self . port = conf ( ) . get ( '<STR_LIT>' ) \n logger . info ( \"<STR_LIT>\" ) \n def startup ( self ) : \n http_app . run ( host = self . host , port = self . port ) \n def handle ( self , data ) : \n reply = \"<STR_LIT>\" \n prompt = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n prompt = prompt . strip ( ) \n if str ( prompt ) != <NUM_LIT> : \n conversation_id = data [ '<STR_LIT>' ] \n sender_id = data [ '<STR_LIT>' ] \n context = dict ( ) \n id = sender_id \n context [ '<STR_LIT>' ] = str ( id ) \n reply = self . build_reply_content ( prompt , context ) \n return reply \n def build_reply_content ( self , query , context = None ) : \n return Bridge ( ) . fetch_reply_content ( query , context ) \n dd = DingTalkChannel ( ) \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n http_app = Flask ( __name__ , ) \n @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) \n def chat ( ) : \n handlers = DingTalkHandler ( ) \n logger . info ( \"<STR_LIT>\" . format ( str ( request . headers ) ) ) \n logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) ) \n token = request . headers . get ( '<STR_LIT>' ) \n data = json . loads ( request . data ) \n if data : \n content = data [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n if not content : \n return \n code = data [ '<STR_LIT>' ] \n group_name = None \n if '<STR_LIT>' in data : \n group_name = data [ '<STR_LIT>' ] \n handlers . chat ( dd , data ) \n return { '<STR_LIT>' : <NUM_LIT> } \n return { '<STR_LIT>' : <NUM_LIT> }"}, {"input": "import logging \n class LogSystem ( object ) : \n handlerList = [ ] \n showOnCmd = True \n loggingLevel = logging . INFO \n loggingFile = None \n def __init__ ( self ) : \n self . logger = logging . getLogger ( '<STR_LIT>' ) \n self . logger . addHandler ( logging . NullHandler ( ) ) \n self . logger . setLevel ( self . loggingLevel ) \n self . cmdHandler = logging . StreamHandler ( ) \n self . fileHandler = None \n self . logger . addHandler ( self . cmdHandler ) \n def set_logging ( self , showOnCmd = True , loggingFile = None , \n loggingLevel = logging . INFO ) : \n if showOnCmd != self . showOnCmd : \n if showOnCmd : \n self . logger . addHandler ( self . cmdHandler ) \n else : \n self . logger . removeHandler ( self . cmdHandler ) \n self . showOnCmd = showOnCmd \n if loggingFile != self . loggingFile : \n if self . loggingFile is not None : \n self . logger . removeHandler ( self . fileHandler ) \n self . fileHandler . close ( )", "output": "if loggingFile is not None : \n self . fileHandler = logging . FileHandler ( loggingFile ) \n self . logger . addHandler ( self . fileHandler ) \n self . loggingFile = loggingFile \n if loggingLevel != self . loggingLevel : \n self . logger . setLevel ( loggingLevel ) \n self . loggingLevel = loggingLevel \n ls = LogSystem ( ) \n set_logging = ls . set_logging"}, {"input": "import io \n import os \n from dotenv import load_dotenv \n from PIL import Image \n def fsize ( file ) : \n if isinstance ( file , io . BytesIO ) : \n return file . getbuffer ( ) . nbytes \n elif isinstance ( file , str ) : \n return os . path . getsize ( file ) \n elif hasattr ( file , \"<STR_LIT>\" ) and hasattr ( file , \"<STR_LIT>\" ) : \n pos = file . tell ( ) \n file . seek ( <NUM_LIT> , os . SEEK_END ) \n size = file . tell ( ) \n file . seek ( pos ) \n return size \n else : \n raise TypeError ( \"<STR_LIT>\" ) \n def compress_imgfile ( file , max_size ) : \n if fsize ( file ) <= max_size : \n return file \n file . seek ( <NUM_LIT> ) \n img = Image . open ( file ) \n rgb_image = img . convert ( \"<STR_LIT>\" ) \n quality = <NUM_LIT> \n while True : \n out_buf = io . BytesIO ( ) \n rgb_image . save ( out_buf , \"<STR_LIT>\" , quality = quality ) \n if fsize ( out_buf ) <= max_size : \n return out_buf \n quality -= <NUM_LIT> \n def split_string_by_utf8_length ( string , max_length , max_split = <NUM_LIT> ) :", "output": "encoded = string . encode ( \"<STR_LIT>\" ) \n start , end = <NUM_LIT> , <NUM_LIT> \n result = [ ] \n while end < len ( encoded ) : \n if max_split > <NUM_LIT> and len ( result ) >= max_split : \n result . append ( encoded [ start : ] . decode ( \"<STR_LIT>\" ) ) \n break \n end = min ( start + max_length , len ( encoded ) ) \n while end < len ( encoded ) and ( encoded [ end ] & <NUM_LIT> ) == <NUM_LIT> : \n end -= <NUM_LIT> \n result . append ( encoded [ start : end ] . decode ( \"<STR_LIT>\" ) ) \n start = end \n return result \n load_dotenv ( ) \n def get_cookie ( ) : \n cookie = os . getenv ( '<STR_LIT>' ) \n print ( cookie ) \n if not cookie : \n raise ValueError ( \"<STR_LIT>\" ) \n return cookie \n def get_proxy ( ) -> bool : \n isproxy = os . getenv ( '<STR_LIT>' ) \n print ( isproxy ) \n if not isproxy : \n return False \n else : \n return True if isproxy . lower ( ) == '<STR_LIT>' else False"}, {"input": "import hashlib \n import web", "output": "class Handle ( object ) : \n def GET ( self ) : \n try : \n data = web . input ( ) \n if len ( data ) == <NUM_LIT> : \n return \"<STR_LIT>\" \n signature = data . signature \n timestamp = data . timestamp \n nonce = data . nonce \n echostr = data . echostr \n token = \"<STR_LIT>\" \n list = [ token , timestamp , nonce ] \n list . sort ( ) \n sha1 = hashlib . sha1 ( ) \n sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) \n sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) \n sha1 . update ( list [ <NUM_LIT> ] . encode ( \"<STR_LIT>\" ) ) \n hashcode = sha1 . hexdigest ( ) \n print ( \"<STR_LIT>\" , hashcode , signature ) \n if hashcode == signature : \n return echostr \n else : \n return \"<STR_LIT>\" \n except Exception as Argument : \n return Argument"}, {"input": "import os \n from claude_api import Client \n def get_cookie ( ) : \n cookie = os . getenv ( '<STR_LIT>' ) \n if not cookie : \n raise ValueError ( \"<STR_LIT>\" ) \n return cookie \n def main ( ) : \n cookie = get_cookie ( ) \n claude = Client ( cookie ) \n conversation_id = None \n print ( \"<STR_LIT>\" ) \n while True : \n user_input = input ( \"<STR_LIT>\" ) \n if user_input . lower ( ) == '<STR_LIT>' : \n print ( \"<STR_LIT>\" ) \n break \n if not conversation_id : \n conversation = claude . create_new_chat ( ) \n conversation_id = conversation [ '<STR_LIT>' ] \n response = claude . send_message ( user_input , conversation_id )", "output": "print ( \"<STR_LIT>\" , response ) \n if __name__ == \"<STR_LIT>\" : \n main ( )"}, {"input": "import logging \n import sys \n def _reset_logger ( log ) : \n for handler in log . handlers : \n handler . close ( ) \n log . removeHandler ( handler ) \n del handler \n log . handlers . clear ( ) \n log . propagate = False \n console_handle = logging . StreamHandler ( sys . stdout ) \n console_handle . setFormatter ( \n logging . Formatter ( \n \"<STR_LIT>\" , \n datefmt = \"<STR_LIT>\" , \n ) \n ) \n file_handle = logging . FileHandler ( \"<STR_LIT>\" , encoding = \"<STR_LIT>\" ) \n file_handle . setFormatter ( \n logging . Formatter ( \n \"<STR_LIT>\" , \n datefmt = \"<STR_LIT>\" , \n ) \n ) \n log . addHandler ( file_handle ) \n log . addHandler ( console_handle ) \n def _get_logger ( ) : \n log = logging . getLogger ( \"<STR_LIT>\" ) \n _reset_logger ( log ) \n log . setLevel ( logging . INFO )", "output": "return log \n logger = _get_logger ( )"}, {"input": "import os , time , copy \n from threading import Lock \n from . messagequeue import Queue \n from . templates import ( \n ContactList , AbstractUserDict , User , \n MassivePlatform , Chatroom , ChatroomMember ) \n def contact_change ( fn ) : \n def _contact_change ( core , * args , ** kwargs ) : \n with core . storageClass . updateLock : \n return fn ( core , * args , ** kwargs ) \n return _contact_change \n class Storage ( object ) : \n def __init__ ( self , core ) : \n self . userName = None \n self . nickName = None \n self . updateLock = Lock ( ) \n self . memberList = ContactList ( ) \n self . mpList = ContactList ( ) \n self . chatroomList = ContactList ( ) \n self . msgList = Queue ( - <NUM_LIT> ) \n self . lastInputUserName = None \n self . memberList . set_default_value ( contactClass = User ) \n self . memberList . core = core \n self . mpList . set_default_value ( contactClass = MassivePlatform ) \n self . mpList . core = core \n self . chatroomList . set_default_value ( contactClass = Chatroom ) \n self . chatroomList . core = core \n def dumps ( self ) : \n return { \n '<STR_LIT>' : self . userName , \n '<STR_LIT>' : self . nickName , \n '<STR_LIT>' : self . memberList , \n '<STR_LIT>' : self . mpList , \n '<STR_LIT>' : self . chatroomList , \n '<STR_LIT>' : self . lastInputUserName , } \n def loads ( self , j ) : \n self . userName = j . get ( '<STR_LIT>' , None ) \n self . nickName = j . get ( '<STR_LIT>' , None ) \n del self . memberList [ : ] \n for i in j . get ( '<STR_LIT>' , [ ] ) : \n self . memberList . append ( i ) \n del self . mpList [ : ] \n for i in j . get ( '<STR_LIT>' , [ ] ) : \n self . mpList . append ( i ) \n del self . chatroomList [ : ] \n for i in j . get ( '<STR_LIT>' , [ ] ) : \n self . chatroomList . append ( i ) \n for chatroom in self . chatroomList : \n if '<STR_LIT>' in chatroom : \n for member in chatroom [ '<STR_LIT>' ] : \n member . core = chatroom . core \n member . chatroom = chatroom \n if '<STR_LIT>' in chatroom : \n chatroom [ '<STR_LIT>' ] . core = chatroom . core \n chatroom [ '<STR_LIT>' ] . chatroom = chatroom \n self . lastInputUserName = j . get ( '<STR_LIT>' , None ) \n def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , \n wechatAccount = None ) : \n with self . updateLock : \n if ( name or userName or remarkName or nickName or wechatAccount ) is None : \n return copy . deepcopy ( self . memberList [ <NUM_LIT> ] ) \n elif userName : \n for m in self . memberList : \n if m [ '<STR_LIT>' ] == userName : \n return copy . deepcopy ( m ) \n else : \n matchDict = { \n '<STR_LIT>' : remarkName , \n '<STR_LIT>' : nickName , \n '<STR_LIT>' : wechatAccount , } \n for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : \n if matchDict [ k ] is None :", "output": "del matchDict [ k ] \n if name : \n contact = [ ] \n for m in self . memberList : \n if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : \n contact . append ( m ) \n else : \n contact = self . memberList [ : ] \n if matchDict : \n friendList = [ ] \n for m in contact : \n if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : \n friendList . append ( m ) \n return copy . deepcopy ( friendList ) \n else : \n return copy . deepcopy ( contact ) \n def search_chatrooms ( self , name = None , userName = None ) : \n with self . updateLock : \n if userName is not None : \n for m in self . chatroomList : \n if m [ '<STR_LIT>' ] == userName : \n return copy . deepcopy ( m ) \n elif name is not None : \n matchList = [ ] \n for m in self . chatroomList : \n if name in m [ '<STR_LIT>' ] : \n matchList . append ( copy . deepcopy ( m ) ) \n return matchList \n def search_mps ( self , name = None , userName = None ) : \n with self . updateLock : \n if userName is not None : \n for m in self . mpList : \n if m [ '<STR_LIT>' ] == userName : \n return copy . deepcopy ( m ) \n elif name is not None : \n matchList = [ ] \n for m in self . mpList : \n if name in m [ '<STR_LIT>' ] : \n matchList . append ( copy . deepcopy ( m ) ) \n return matchList"}, {"input": "from . contact import load_contact \n from . hotreload import load_hotreload \n from . login import load_login \n from . messages import load_messages \n from . register import load_register \n def load_components ( core ) : \n load_contact ( core ) \n load_hotreload ( core )", "output": "load_login ( core ) \n load_messages ( core ) \n load_register ( core )"}, {"input": "import uuid \n import json \n from curl_cffi import requests \n url = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' \n } \n proxies = { \"<STR_LIT>\" : \"<STR_LIT>\" } \n response = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" , headers = headers , proxies = proxies , timeout = <NUM_LIT> ) \n if response . status_code == <NUM_LIT> :", "output": "res = json . loads ( response . text ) \n uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] \n print ( f\"<STR_LIT>\" ) \n else : \n print ( f\"<STR_LIT>\" )"}, {"input": "import logging , traceback , sys , threading \n try : \n import Queue \n except ImportError : \n import queue as Queue \n from . . log import set_logging \n from . . utils import test_connect", "output": "from . . storage import templates \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_register ( core ) : \n core . auto_login = auto_login \n core . configured_reply = configured_reply \n core . msg_register = msg_register \n core . run = run \n async def auto_login ( self , EventScanPayload = None , ScanStatus = None , event_stream = None , \n hotReload = True , statusStorageDir = '<STR_LIT>' , \n enableCmdQR = False , picDir = None , qrCallback = None , \n loginCallback = None , exitCallback = None ) : \n if not test_connect ( ) : \n logger . info ( \"<STR_LIT>\" ) \n sys . exit ( ) \n self . useHotReload = hotReload \n self . hotReloadDir = statusStorageDir \n if hotReload : \n if await self . load_login_status ( statusStorageDir , \n loginCallback = loginCallback , exitCallback = exitCallback ) : \n return \n await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , \n loginCallback = loginCallback , exitCallback = exitCallback ) \n await self . dump_login_status ( statusStorageDir ) \n else : \n await self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , EventScanPayload = EventScanPayload , ScanStatus = ScanStatus , event_stream = event_stream , \n loginCallback = loginCallback , exitCallback = exitCallback ) \n async def configured_reply ( self , event_stream , payload , message_container ) : \n try : \n msg = self . msgList . get ( timeout = <NUM_LIT> ) \n if '<STR_LIT>' in msg . keys ( ) : \n message_container [ msg [ '<STR_LIT>' ] ] = msg \n except Queue . Empty : \n pass \n else : \n if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) : \n replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : \n replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : \n replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n if replyFn is None : \n r = None \n else : \n try : \n r = await replyFn ( msg ) \n if r is not None : \n await self . send ( r , msg . get ( '<STR_LIT>' ) ) \n except : \n logger . warning ( traceback . format_exc ( ) ) \n def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : \n if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : \n msgType = [ msgType ] \n def _msg_register ( fn ) : \n for _msgType in msgType : \n if isFriendChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if isGroupChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if isMpChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n return fn \n return _msg_register \n async def run ( self , debug = False , blockThread = True ) : \n logger . info ( '<STR_LIT>' ) \n if debug : \n set_logging ( loggingLevel = logging . DEBUG ) \n async def reply_fn ( ) : \n try : \n while self . alive : \n await self . configured_reply ( ) \n except KeyboardInterrupt : \n if self . useHotReload : \n await self . dump_login_status ( ) \n self . alive = False \n logger . debug ( '<STR_LIT>' ) \n logger . info ( '<STR_LIT>' ) \n if blockThread : \n await reply_fn ( ) \n else : \n replyThread = threading . Thread ( target = reply_fn ) \n replyThread . setDaemon ( True ) \n replyThread . start ( )"}, {"input": "def create_bot ( bot_type ) : \n if bot_type == '<STR_LIT>' : \n from bot . baidu . baidu_unit_bot import BaiduUnitBot \n return BaiduUnitBot ( ) \n elif bot_type == '<STR_LIT>' : \n from bot . chatgpt . chat_gpt_bot import ChatGPTBot \n return ChatGPTBot ( ) \n elif bot_type == '<STR_LIT>' : \n from bot . openai . open_ai_bot import OpenAIBot \n return OpenAIBot ( ) \n elif bot_type == '<STR_LIT>' : \n from bot . claude . claude_ai_bot import ClaudeAiBot \n return ClaudeAiBot ( )", "output": "raise RuntimeError"}, {"input": "from concurrent . futures import ThreadPoolExecutor \n import io \n import requests \n import telebot \n from common . log import logger \n from channel . channel import Channel \n from config import conf \n bot = telebot . TeleBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n @ bot . message_handler ( commands = [ '<STR_LIT>' ] ) \n def send_welcome ( message ) : \n bot . send_message ( message . chat . id , \"<STR_LIT>\" , parse_mode = \"<STR_LIT>\" ) \n @ bot . message_handler ( content_types = [ '<STR_LIT>' ] ) \n def send_welcome ( msg ) : \n TelegramChannel ( ) . handle ( msg ) \n class TelegramChannel ( Channel ) : \n def __init__ ( self ) : \n pass \n def startup ( self ) : \n logger . info ( \"<STR_LIT>\" ) \n bot . infinity_polling ( ) \n def handle ( self , msg ) : \n logger . debug ( \"<STR_LIT>\" + msg . text ) \n thread_pool . submit ( self . _dosend , msg . text , msg ) \n def _dosend ( self , query , msg ) : \n context = dict ( ) \n context [ '<STR_LIT>' ] = str ( msg . chat . id ) \n reply_text = super ( ) . build_reply_content ( query , context ) \n logger . info ( '<STR_LIT>' . format ( reply_text ) )", "output": "bot . reply_to ( msg , reply_text )"}, {"input": "import logging \n try : \n import Queue as queue \n except ImportError : \n import queue \n from . templates import AttributeDict \n logger = logging . getLogger ( '<STR_LIT>' ) \n class Queue ( queue . Queue ) : \n def put ( self , message ) : \n queue . Queue . put ( self , Message ( message ) ) \n class Message ( AttributeDict ) : \n def download ( self , fileName ) : \n if hasattr ( self . text , '<STR_LIT>' ) : \n return self . text ( fileName ) \n else : \n return b'<STR_LIT>' \n def __getitem__ ( self , value ) : \n if value in ( '<STR_LIT>' , '<STR_LIT>' ) :", "output": "v = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] \n logger . debug ( '<STR_LIT>' % ( value , v ) ) \n value = v \n return super ( Message , self ) . __getitem__ ( value ) \n def __str__ ( self ) : \n return '<STR_LIT>' % '<STR_LIT>' . join ( \n [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) \n def __repr__ ( self ) : \n return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , \n self . __str__ ( ) )"}, {"input": "import asyncio \n import os , time , re , io \n import threading \n import json \n import random \n import traceback \n import logging \n try : \n from httplib import BadStatusLine \n except ImportError : \n from http . client import BadStatusLine \n import requests \n from pyqrcode import QRCode \n from . . import config , utils \n from . . returnvalues import ReturnValue \n from . . storage . templates import wrap_user_dict \n from . contact import update_local_chatrooms , update_local_friends \n from . messages import produce_msg \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_login ( core ) : \n core . login = login \n core . get_QRuuid = get_QRuuid \n core . get_QR = get_QR \n core . check_login = check_login \n core . web_init = web_init \n core . show_mobile_login = show_mobile_login \n core . start_receiving = start_receiving \n core . get_msg = get_msg \n core . logout = logout \n async def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , EventScanPayload = None , ScanStatus = None , event_stream = None , \n loginCallback = None , exitCallback = None ) : \n if self . alive or self . isLogging : \n logger . warning ( '<STR_LIT>' ) \n return \n self . isLogging = True \n while self . isLogging : \n uuid = await push_login ( self ) \n if uuid : \n payload = EventScanPayload ( \n status = ScanStatus . Waiting , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n else : \n logger . info ( '<STR_LIT>' ) \n self . get_QRuuid ( )", "output": "payload = EventScanPayload ( \n status = ScanStatus . Waiting , \n qrcode = f\"<STR_LIT>\" \n ) \n print ( f\"<STR_LIT>\" ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n isLoggedIn = False \n while not isLoggedIn : \n status = await self . check_login ( ) \n if status == '<STR_LIT>' : \n isLoggedIn = True \n payload = EventScanPayload ( \n status = ScanStatus . Scanned , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n elif status == '<STR_LIT>' : \n if isLoggedIn is not None : \n logger . info ( '<STR_LIT>' ) \n isLoggedIn = None \n payload = EventScanPayload ( \n status = ScanStatus . Waiting , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n elif status != '<STR_LIT>' : \n payload = EventScanPayload ( \n status = ScanStatus . Cancel , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n break \n if isLoggedIn : \n payload = EventScanPayload ( \n status = ScanStatus . Confirmed , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n break \n elif self . isLogging : \n logger . info ( '<STR_LIT>' ) \n payload = EventScanPayload ( \n status = ScanStatus . Timeout , \n qrcode = f\"<STR_LIT>\" \n ) \n event_stream . emit ( '<STR_LIT>' , payload ) \n await asyncio . sleep ( <NUM_LIT> ) \n else : \n return \n logger . info ( '<STR_LIT>' ) \n await self . web_init ( ) \n await self . show_mobile_login ( ) \n self . get_contact ( True ) \n if hasattr ( loginCallback , '<STR_LIT>' ) : \n r = await loginCallback ( self . storageClass . userName ) \n else : \n utils . clear_screen ( ) \n if os . path . exists ( picDir or config . DEFAULT_QR ) : \n os . remove ( picDir or config . DEFAULT_QR ) \n logger . info ( '<STR_LIT>' % self . storageClass . nickName ) \n await self . start_receiving ( exitCallback ) \n self . isLogging = False \n async def push_login ( core ) : \n cookiesDict = core . s . cookies . get_dict ( ) \n if '<STR_LIT>' in cookiesDict : \n url = '<STR_LIT>' % ( \n config . BASE_URL , cookiesDict [ '<STR_LIT>' ] ) \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = core . s . get ( url , headers = headers ) . json ( ) \n if '<STR_LIT>' in r and r . get ( '<STR_LIT>' ) in ( <NUM_LIT> , '<STR_LIT>' ) : \n core . uuid = r [ '<STR_LIT>' ] \n return r [ '<STR_LIT>' ] \n return False \n def get_QRuuid ( self ) : \n url = '<STR_LIT>' % config . BASE_URL \n params = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . get ( url , params = params , headers = headers ) \n regx = r'<STR_LIT>' \n data = re . search ( regx , r . text ) \n if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : \n self . uuid = data . group ( <NUM_LIT> ) \n return self . uuid \n async def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : \n uuid = uuid or self . uuid \n picDir = picDir or config . DEFAULT_QR \n qrStorage = io . BytesIO ( ) \n qrCode = QRCode ( '<STR_LIT>' + uuid ) \n qrCode . png ( qrStorage , scale = <NUM_LIT> ) \n if hasattr ( qrCallback , '<STR_LIT>' ) : \n await qrCallback ( uuid = uuid , status = '<STR_LIT>' , qrcode = qrStorage . getvalue ( ) ) \n else : \n with open ( picDir , '<STR_LIT>' ) as f : \n f . write ( qrStorage . getvalue ( ) ) \n if enableCmdQR : \n utils . print_cmd_qr ( qrCode . text ( <NUM_LIT> ) , enableCmdQR = enableCmdQR ) \n else : \n utils . print_qr ( picDir ) \n return qrStorage \n async def check_login ( self , uuid = None ) : \n uuid = uuid or self . uuid \n url = '<STR_LIT>' % config . BASE_URL \n localTime = int ( time . time ( ) ) \n params = '<STR_LIT>' % ( \n uuid , int ( - localTime / <NUM_LIT> ) , localTime ) \n headers = { '<STR_LIT>' : config . USER_AGENT } \n r = self . s . get ( url , params = params , headers = headers ) \n regx = r'<STR_LIT>' \n data = re . search ( regx , r . text ) \n if data and data . group ( <NUM_LIT> ) == '<STR_LIT>' : \n if await process_login_info ( self , r . text ) : \n return '<STR_LIT>' \n else : \n return '<STR_LIT>' \n elif data : \n return data . group ( <NUM_LIT> ) \n else : \n return '<STR_LIT>' \n async def process_login_info ( core , loginContent ) : \n regx = r'<STR_LIT>' \n core . loginInfo [ '<STR_LIT>' ] = re . search ( regx , loginContent ) . group ( <NUM_LIT> ) \n headers = { '<STR_LIT>' : config . USER_AGENT , \n '<STR_LIT>' : config . UOS_PATCH_CLIENT_VERSION , \n '<STR_LIT>' : config . UOS_PATCH_EXTSPAM , \n '<STR_LIT>' : '<STR_LIT>' \n } \n r = core . s . get ( core . loginInfo [ '<STR_LIT>' ] , headers = headers , allow_redirects = False ) \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ : core . loginInfo [ '<STR_LIT>' ] . rfind ( '<STR_LIT>' ) ] \n for indexUrl , detailedUrl in ( \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) , \n ( \"<STR_LIT>\" , ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) : \n fileUrl , syncUrl = [ '<STR_LIT>' % url for url in detailedUrl ] \n if indexUrl in core . loginInfo [ '<STR_LIT>' ] : \n core . loginInfo [ '<STR_LIT>' ] , core . loginInfo [ '<STR_LIT>' ] = fileUrl , syncUrl \n break \n else : \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] \n core . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] \n core . loginInfo [ '<STR_LIT>' ] = int ( time . time ( ) * <NUM_LIT> ) \n core . loginInfo [ '<STR_LIT>' ] = { } \n cookies = core . s . cookies . get_dict ( ) \n skey = re . findall ( '<STR_LIT>' , r . text , re . S ) [ <NUM_LIT> ] \n pass_ticket = re . findall ( '<STR_LIT>' , r . text , re . S ) [ <NUM_LIT> ] \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = skey \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ \"<STR_LIT>\" ] \n core . loginInfo [ '<STR_LIT>' ] = core . loginInfo [ '<STR_LIT>' ] [ '<STR_LIT>' ] = cookies [ \"<STR_LIT>\" ] \n core . loginInfo [ '<STR_LIT>' ] = pass_ticket \n if not all ( [ key in core . loginInfo for key in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : \n logger . error ( '<STR_LIT>' % r . text ) \n core . isLogging = False \n return False \n return True \n async def web_init ( self ) : \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n params = { \n '<STR_LIT>' : int ( - time . time ( ) / <NUM_LIT> ) , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n data = { '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n r = self . s . post ( url , params = params , data = json . dumps ( data ) , headers = headers ) \n dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n utils . emoji_formatter ( dic [ '<STR_LIT>' ] , '<STR_LIT>' ) \n self . loginInfo [ '<STR_LIT>' ] = int ( dic [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] = wrap_user_dict ( utils . struct_friend_info ( dic [ '<STR_LIT>' ] ) ) \n self . memberList . append ( self . loginInfo [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) \n for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) \n self . storageClass . userName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n self . storageClass . nickName = dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n contactList = dic . get ( '<STR_LIT>' , [ ] ) \n chatroomList , otherList = [ ] , [ ] \n for m in contactList : \n if m [ '<STR_LIT>' ] != <NUM_LIT> : \n otherList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n m [ '<STR_LIT>' ] = [ ] \n chatroomList . append ( m ) \n elif '<STR_LIT>' in m [ '<STR_LIT>' ] : \n otherList . append ( m ) \n if chatroomList : \n update_local_chatrooms ( self , chatroomList ) \n if otherList : \n update_local_friends ( self , otherList ) \n return dic \n async def show_mobile_login ( self ) : \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : self . storageClass . userName , \n '<STR_LIT>' : self . storageClass . userName , \n '<STR_LIT>' : int ( time . time ( ) ) , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT , } \n r = self . s . post ( url , data = json . dumps ( data ) , headers = headers ) \n return ReturnValue ( rawResponse = r ) \n async def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : \n self . alive = True \n def maintain_loop ( ) : \n retryCount = <NUM_LIT> \n while self . alive : \n try : \n i = sync_check ( self ) \n if i is None : \n self . alive = False \n elif i == '<STR_LIT>' : \n pass \n else : \n msgList , contactList = self . get_msg ( ) \n if msgList : \n msgList = produce_msg ( self , msgList ) \n for msg in msgList : \n self . msgList . put ( msg ) \n if contactList : \n chatroomList , otherList = [ ] , [ ] \n for contact in contactList : \n if '<STR_LIT>' in contact [ '<STR_LIT>' ] : \n chatroomList . append ( contact ) \n else : \n otherList . append ( contact ) \n chatroomMsg = update_local_chatrooms ( self , chatroomList ) \n chatroomMsg [ '<STR_LIT>' ] = self . loginInfo [ '<STR_LIT>' ] \n self . msgList . put ( chatroomMsg ) \n update_local_friends ( self , otherList ) \n retryCount = <NUM_LIT> \n except requests . exceptions . ReadTimeout : \n pass \n except : \n retryCount += <NUM_LIT> \n logger . error ( traceback . format_exc ( ) ) \n if self . receivingRetryCount < retryCount : \n self . alive = False \n else : \n time . sleep ( <NUM_LIT> ) \n self . logout ( ) \n if hasattr ( exitCallback , '<STR_LIT>' ) : \n exitCallback ( self . storageClass . userName ) \n else : \n logger . info ( '<STR_LIT>' ) \n if getReceivingFnOnly : \n return maintain_loop \n else : \n maintainThread = threading . Thread ( target = maintain_loop ) \n maintainThread . setDaemon ( True ) \n maintainThread . start ( ) \n def sync_check ( self ) : \n url = '<STR_LIT>' % self . loginInfo . get ( '<STR_LIT>' , self . loginInfo [ '<STR_LIT>' ] ) \n params = { \n '<STR_LIT>' : int ( time . time ( ) * <NUM_LIT> ) , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n self . loginInfo [ '<STR_LIT>' ] += <NUM_LIT> \n try : \n r = self . s . get ( url , params = params , headers = headers , timeout = config . TIMEOUT ) \n except requests . exceptions . ConnectionError as e : \n try : \n if not isinstance ( e . args [ <NUM_LIT> ] . args [ <NUM_LIT> ] , BadStatusLine ) : \n raise \n return '<STR_LIT>' \n except : \n raise \n r . raise_for_status ( ) \n regx = r'<STR_LIT>' \n pm = re . search ( regx , r . text ) \n if pm is None or pm . group ( <NUM_LIT> ) != '<STR_LIT>' : \n logger . debug ( '<STR_LIT>' % r . text ) \n return None \n return pm . group ( <NUM_LIT> ) \n def get_msg ( self ) : \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' + repr ( random . random ( ) ) [ <NUM_LIT> : <NUM_LIT> ] \n url = '<STR_LIT>' % ( \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] , \n self . loginInfo [ '<STR_LIT>' ] , self . loginInfo [ '<STR_LIT>' ] ) \n data = { \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , \n '<STR_LIT>' : ~ int ( time . time ( ) ) , } \n headers = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : config . USER_AGENT } \n r = self . s . post ( url , data = json . dumps ( data ) , headers = headers , timeout = config . TIMEOUT ) \n dic = json . loads ( r . content . decode ( '<STR_LIT>' , '<STR_LIT>' ) ) \n if dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] != <NUM_LIT> : return None , None \n self . loginInfo [ '<STR_LIT>' ] = dic [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = '<STR_LIT>' . join ( [ '<STR_LIT>' % ( item [ '<STR_LIT>' ] , item [ '<STR_LIT>' ] ) \n for item in dic [ '<STR_LIT>' ] [ '<STR_LIT>' ] ] ) \n return dic [ '<STR_LIT>' ] , dic [ '<STR_LIT>' ] \n def logout ( self ) : \n if self . alive : \n url = '<STR_LIT>' % self . loginInfo [ '<STR_LIT>' ] \n params = { \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : <NUM_LIT> , \n '<STR_LIT>' : self . loginInfo [ '<STR_LIT>' ] , } \n headers = { '<STR_LIT>' : config . USER_AGENT } \n self . s . get ( url , params = params , headers = headers ) \n self . alive = False \n self . isLogging = False \n self . s . cookies . clear ( ) \n del self . chatroomList [ : ] \n del self . memberList [ : ] \n del self . mpList [ : ] \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , } } )"}, {"input": "from lib import itchat \n from lib . itchat . content import * \n import json \n from channel . channel import Channel \n from concurrent . futures import ThreadPoolExecutor \n from common . log import logger \n from config import conf \n import requests \n import io \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n @ itchat . msg_register ( TEXT ) \n def handler_single_msg ( msg ) : \n WechatChannel ( ) . handle ( msg ) \n return None \n @ itchat . msg_register ( TEXT , isGroupChat = True ) \n def handler_group_msg ( msg ) : \n WechatChannel ( ) . handle_group ( msg ) \n return None \n class WechatChannel ( Channel ) : \n def __init__ ( self ) : \n pass \n def startup ( self ) : \n itchat . auto_login ( enableCmdQR = <NUM_LIT> ) \n itchat . run ( ) \n def handle ( self , msg ) : \n logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) \n from_user_id = msg [ '<STR_LIT>' ] \n to_user_id = msg [ '<STR_LIT>' ] \n other_user_id = msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n content = msg [ '<STR_LIT>' ] \n match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) \n if from_user_id == other_user_id and match_prefix is not None : \n if match_prefix != '<STR_LIT>' : \n str_list = content . split ( match_prefix , <NUM_LIT> ) \n if len ( str_list ) == <NUM_LIT> : \n content = str_list [ <NUM_LIT> ] . strip ( ) \n img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) \n if img_match_prefix : \n content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) \n thread_pool . submit ( self . _do_send_img , content , from_user_id ) \n else : \n thread_pool . submit ( self . _do_send , content , from_user_id ) \n elif to_user_id == other_user_id and match_prefix : \n str_list = content . split ( match_prefix , <NUM_LIT> ) \n if len ( str_list ) == <NUM_LIT> : \n content = str_list [ <NUM_LIT> ] . strip ( ) \n img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) \n if img_match_prefix : \n content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) \n thread_pool . submit ( self . _do_send_img , content , to_user_id ) \n else : \n thread_pool . submit ( self . _do_send , content , to_user_id ) \n def handle_group ( self , msg ) : \n logger . debug ( \"<STR_LIT>\" + json . dumps ( msg , ensure_ascii = False ) ) \n group_name = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) \n group_id = msg [ '<STR_LIT>' ] . get ( '<STR_LIT>' , None ) \n if not group_name : \n return \"<STR_LIT>\" \n origin_content = msg [ '<STR_LIT>' ] \n content = msg [ '<STR_LIT>' ] \n content_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) \n context_special_list = content . split ( '<STR_LIT>' , <NUM_LIT> ) \n if len ( context_special_list ) == <NUM_LIT> :", "output": "content = context_special_list [ <NUM_LIT> ] \n elif len ( content_list ) == <NUM_LIT> : \n content = content_list [ <NUM_LIT> ] \n config = conf ( ) \n match_prefix = ( msg [ '<STR_LIT>' ] and not config . get ( \"<STR_LIT>\" , False ) ) or self . check_prefix ( origin_content , config . get ( '<STR_LIT>' ) ) or self . check_contain ( origin_content , config . get ( '<STR_LIT>' ) ) \n if ( '<STR_LIT>' in config . get ( '<STR_LIT>' ) or group_name in config . get ( '<STR_LIT>' ) or self . check_contain ( group_name , config . get ( '<STR_LIT>' ) ) ) and match_prefix : \n img_match_prefix = self . check_prefix ( content , conf ( ) . get ( '<STR_LIT>' ) ) \n if img_match_prefix : \n content = content . split ( img_match_prefix , <NUM_LIT> ) [ <NUM_LIT> ] . strip ( ) \n thread_pool . submit ( self . _do_send_img , content , group_id ) \n else : \n thread_pool . submit ( self . _do_send_group , content , msg ) \n def send ( self , msg , receiver ) : \n logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) \n itchat . send ( msg , toUserName = receiver ) \n def _do_send ( self , query , reply_user_id ) : \n try : \n if not query : \n return \n context = dict ( ) \n context [ '<STR_LIT>' ] = reply_user_id \n reply_text = super ( ) . build_reply_content ( query , context ) \n if reply_text : \n self . send ( conf ( ) . get ( \"<STR_LIT>\" ) + reply_text , reply_user_id ) \n except Exception as e : \n logger . exception ( e ) \n def _do_send_img ( self , query , reply_user_id ) : \n try : \n if not query : \n return \n context = dict ( ) \n context [ '<STR_LIT>' ] = '<STR_LIT>' \n img_url = super ( ) . build_reply_content ( query , context ) \n if not img_url : \n return \n pic_res = requests . get ( img_url , stream = True ) \n image_storage = io . BytesIO ( ) \n for block in pic_res . iter_content ( <NUM_LIT> ) : \n image_storage . write ( block ) \n image_storage . seek ( <NUM_LIT> ) \n logger . info ( '<STR_LIT>' . format ( reply_user_id ) ) \n itchat . send_image ( image_storage , reply_user_id ) \n except Exception as e : \n logger . exception ( e ) \n def _do_send_group ( self , query , msg ) : \n if not query : \n return \n context = dict ( ) \n context [ '<STR_LIT>' ] = msg [ '<STR_LIT>' ] \n reply_text = super ( ) . build_reply_content ( query , context ) \n if reply_text : \n reply_text = '<STR_LIT>' + msg [ '<STR_LIT>' ] + '<STR_LIT>' + reply_text . strip ( ) \n self . send ( conf ( ) . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + reply_text , msg [ '<STR_LIT>' ] [ '<STR_LIT>' ] ) \n def check_prefix ( self , content , prefix_list ) : \n for prefix in prefix_list : \n if content . startswith ( prefix ) : \n return prefix \n return None \n def check_contain ( self , content , keyword_list ) : \n if not keyword_list : \n return None \n for ky in keyword_list : \n if content . find ( ky ) != - <NUM_LIT> : \n return True \n return None"}, {"input": "import json \n import os \n import uuid \n import requests \n from curl_cffi import requests , Curl , CurlOpt \n from dotenv import load_dotenv \n from common . log import logger \n import PyPDF2 \n import docx \n import re \n from io import BytesIO \n load_dotenv ( ) \n class Client : \n def __init__ ( self , cookie , use_proxy = False ) : \n self . cookie = cookie \n self . use_proxy = use_proxy \n self . proxies = self . load_proxies_from_env ( ) \n self . organization_id = self . get_organization_id ( ) \n def load_proxies_from_env ( self ) : \n proxies = { } \n if self . use_proxy : \n http_proxy = os . getenv ( '<STR_LIT>' ) \n https_proxy = os . getenv ( '<STR_LIT>' ) \n socks5_proxy = os . getenv ( '<STR_LIT>' ) \n if http_proxy : \n proxies [ '<STR_LIT>' ] = http_proxy \n if https_proxy : \n proxies [ '<STR_LIT>' ] = https_proxy \n if socks5_proxy : \n proxies [ '<STR_LIT>' ] = socks5_proxy \n return proxies \n def get_organization_id ( self ) : \n url = \"<STR_LIT>\" \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers ) \n if response . status_code == <NUM_LIT> : \n res = json . loads ( response . text ) \n uuid = res [ <NUM_LIT> ] [ '<STR_LIT>' ] \n return uuid \n else : \n print ( f\"<STR_LIT>\" ) \n def get_content_type ( self , file_path ) : \n extension = os . path . splitext ( file_path ) [ - <NUM_LIT> ] . lower ( ) \n if extension == '<STR_LIT>' : \n return '<STR_LIT>' \n elif extension == '<STR_LIT>' : \n return '<STR_LIT>' \n elif extension == '<STR_LIT>' : \n return '<STR_LIT>' \n else : \n return '<STR_LIT>' \n def list_all_conversations ( self ) : \n url = f\"<STR_LIT>\" \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers ) \n conversations = response . json ( ) \n if response . status_code == <NUM_LIT> : \n return conversations \n else : \n print ( f\"<STR_LIT>\" ) \n def send_message ( self , prompt , conversation_id , attachment = None ) : \n url = \"<STR_LIT>\" \n attachments = [ ] \n if attachment : \n attachment_response = self . upload_attachment ( attachment ) \n if attachment_response : \n attachments = [ attachment_response ] \n else : \n return { \"<STR_LIT>\" } \n if not attachment : \n attachments = [ ] \n payload = json . dumps ( { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" \n } , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : attachments \n } ) \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' \n } \n buffer = BytesIO ( ) \n c = Curl ( ) \n def stream_callback ( data ) : \n json_str = data . decode ( '<STR_LIT>' ) \n decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) \n data_strings = decoded_data . split ( '<STR_LIT>' ) \n for data_string in data_strings : \n json_str = data_string [ <NUM_LIT> : ] . strip ( ) \n _data = json . loads ( json_str ) \n if '<STR_LIT>' in _data : \n buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) \n print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) \n c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) \n c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) \n c . setopt ( CurlOpt . HTTPHEADER , headers ) \n c . setopt ( CurlOpt . POSTFIELDS , payload ) \n c . impersonate ( \"<STR_LIT>\" ) \n c . perform ( ) \n c . close ( ) \n body = buffer . getvalue ( ) \n print ( body . decode ( ) ) \n return body \n def delete_conversation ( self , conversation_id ) : \n url = f\"<STR_LIT>\" \n payload = json . dumps ( f\"<STR_LIT>\" ) \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) \n if response . status_code == <NUM_LIT> : \n return True \n else : \n return False \n def chat_conversation_history ( self , conversation_id ) : \n url = f\"<STR_LIT>\" \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers , params = { '<STR_LIT>' : '<STR_LIT>' } ) \n print ( type ( response ) ) \n return response . json ( ) \n def generate_uuid ( self ) : \n random_uuid = uuid . uuid4 ( ) \n random_uuid_str = str ( random_uuid ) \n formatted_uuid = f\"<STR_LIT>\" \n return formatted_uuid \n def create_new_chat ( self ) : \n url = f\"<STR_LIT>\" \n uuid = self . generate_uuid ( ) \n payload = json . dumps ( { \"<STR_LIT>\" : uuid , \"<STR_LIT>\" : \"<STR_LIT>\" } ) \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : self . cookie , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) \n return response . json ( ) \n def reset_all ( self ) : \n conversations = self . list_all_conversations ( ) \n for conversation in conversations : \n conversation_id = conversation [ '<STR_LIT>' ] \n delete_id = self . delete_conversation ( conversation_id ) \n return True \n def upload_attachment ( self , file_path ) : \n if file_path . endswith ( ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) : \n file_name = os . path . basename ( file_path ) \n file_size = os . path . getsize ( file_path ) \n file_type = \"<STR_LIT>\" \n file_content = \"<STR_LIT>\" \n if file_path . endswith ( '<STR_LIT>' ) : \n with open ( file_path , '<STR_LIT>' , encoding = '<STR_LIT>' ) as file : \n file_content = file . read ( ) \n elif file_path . endswith ( '<STR_LIT>' ) : \n with open ( file_path , '<STR_LIT>' ) as file : \n pdf_reader = PyPDF2 . PdfFileReader ( file ) \n for page_num in range ( pdf_reader . numPages ) : \n page = pdf_reader . getPage ( page_num ) \n file_content += page . extractText ( ) \n elif file_path . endswith ( ( '<STR_LIT>' , '<STR_LIT>' ) ) : \n doc = docx . Document ( file_path ) \n paragraphs = doc . paragraphs \n for paragraph in paragraphs : \n file_content += paragraph . text \n return { \n \"<STR_LIT>\" : file_name , \n \"<STR_LIT>\" : file_type , \n \"<STR_LIT>\" : file_size , \n \"<STR_LIT>\" : file_content \n } \n url = '<STR_LIT>' \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' \n } \n file_name = os . path . basename ( file_path ) \n content_type = self . get_content_type ( file_path ) \n files = { \n '<STR_LIT>' : ( file_name , open ( file_path , '<STR_LIT>' ) , content_type ) , \n '<STR_LIT>' : ( None , self . organization_id ) \n } \n response = self . send_request ( url , \"<STR_LIT>\" , headers = headers , files = files ) \n if response . status_code == <NUM_LIT> : \n return response . json ( ) \n else : \n return False \n def rename_chat ( self , title , conversation_id ) : \n url = \"<STR_LIT>\" \n payload = json . dumps ( { \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\"", "output": "} ) \n headers = { \n '<STR_LIT>' : \n '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : f'<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' \n } \n response = self . send_request ( \"<STR_LIT>\" , url , headers = headers , data = payload ) \n if response . status_code == <NUM_LIT> : \n return True \n else : \n return False \n def send_request ( self , method , url , headers , data = None , files = None , params = None , stream = False ) : \n if self . use_proxy : \n return requests . request ( method , url , headers = headers , data = data , files = files , params = params , impersonate = \"<STR_LIT>\" , proxies = self . proxies , timeout = <NUM_LIT> ) \n else : \n return requests . request ( method , url , headers = headers , data = data , files = files , params = params , impersonate = \"<STR_LIT>\" , timeout = <NUM_LIT> )"}, {"input": "import json \n import hmac \n import hashlib \n import base64 \n import time \n import requests \n from urllib . parse import quote_plus \n from common . log import logger \n from flask import Flask , request , render_template , make_response \n from config import conf \n from bridge . bridge import Bridge \n from channel . channel import Channel \n from urllib import request as url_request \n from concurrent . futures import ThreadPoolExecutor \n class FeiShuChannel ( Channel ) : \n def __init__ ( self ) : \n self . app_id = conf ( ) . get ( '<STR_LIT>' ) \n self . app_secret = conf ( ) . get ( '<STR_LIT>' ) \n self . verification_token = conf ( ) . get ( '<STR_LIT>' ) \n self . host = conf ( ) . get ( '<STR_LIT>' ) \n self . port = conf ( ) . get ( '<STR_LIT>' ) \n logger . info ( \"<STR_LIT>\" . format ( \n self . app_id , self . app_secret , self . verification_token , self . host , self . port ) ) \n def startup ( self ) : \n http_app . run ( host = self . host , port = self . port ) \n def get_tenant_access_token ( self ) : \n url = \"<STR_LIT>\" \n headers = {", "output": "\"<STR_LIT>\" : \"<STR_LIT>\" \n } \n req_body = { \n \"<STR_LIT>\" : self . app_id , \n \"<STR_LIT>\" : self . app_secret \n } \n data = bytes ( json . dumps ( req_body ) , encoding = '<STR_LIT>' ) \n req = url_request . Request ( url = url , data = data , \n headers = headers , method = '<STR_LIT>' ) \n try : \n response = url_request . urlopen ( req ) \n except Exception as e : \n print ( e . read ( ) . decode ( ) ) \n return \"<STR_LIT>\" \n rsp_body = response . read ( ) . decode ( '<STR_LIT>' ) \n rsp_dict = json . loads ( rsp_body ) \n code = rsp_dict . get ( \"<STR_LIT>\" , - <NUM_LIT> ) \n if code != <NUM_LIT> : \n print ( \"<STR_LIT>\" , code ) \n return \"<STR_LIT>\" \n return rsp_dict . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n def notify_feishu ( self , token , receive_type , receive_id , at_id , answer ) : \n url = \"<STR_LIT>\" \n params = { \"<STR_LIT>\" : receive_type } \n text = answer . lstrip ( ) \n msgContent = { \n \"<STR_LIT>\" : text , \n } \n req = { \n \"<STR_LIT>\" : receive_id , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : json . dumps ( msgContent ) , \n } \n payload = json . dumps ( req ) \n headers = { \n \"<STR_LIT>\" : \"<STR_LIT>\" + token , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n response = requests . request ( \n \"<STR_LIT>\" , url , params = params , headers = headers , data = payload \n ) \n def handle ( self , message ) : \n event = message [ \"<STR_LIT>\" ] \n msg = event [ \"<STR_LIT>\" ] \n messageId = msg [ \"<STR_LIT>\" ] \n chat_type = msg [ \"<STR_LIT>\" ] \n sender_id = event [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] \n prompt = json . loads ( msg [ \"<STR_LIT>\" ] ) [ \"<STR_LIT>\" ] \n prompt = prompt . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n message_type = msg [ \"<STR_LIT>\" ] \n if message_type != \"<STR_LIT>\" : \n return { '<STR_LIT>' : <NUM_LIT> } \n if chat_type == \"<STR_LIT>\" : \n mentions = msg [ \"<STR_LIT>\" ] \n if not mentions : \n return { '<STR_LIT>' : <NUM_LIT> } \n receive_type = \"<STR_LIT>\" \n receive_id = msg . get ( \"<STR_LIT>\" ) \n at_id = sender_id \n elif chat_type == \"<STR_LIT>\" : \n receive_type = \"<STR_LIT>\" \n receive_id = sender_id \n at_id = None \n access_token = self . get_tenant_access_token ( ) \n if access_token == \"<STR_LIT>\" : \n logger . error ( \"<STR_LIT>\" ) \n return { '<STR_LIT>' : <NUM_LIT> } \n context = dict ( ) \n context [ '<STR_LIT>' ] = str ( sender_id ) \n reply = self . build_reply_content ( prompt , context ) \n self . notify_feishu ( access_token , receive_type , \n receive_id , at_id , reply ) \n return { '<STR_LIT>' : <NUM_LIT> } \n def handle_request_url_verify ( self , post_obj ) : \n challenge = post_obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n logger . info ( \"<STR_LIT>\" . format ( challenge ) ) \n return { '<STR_LIT>' : challenge } \n def build_reply_content ( self , query , context = None ) : \n return Bridge ( ) . fetch_reply_content ( query , context ) \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n http_app = Flask ( __name__ ) \n @ http_app . route ( \"<STR_LIT>\" , methods = [ '<STR_LIT>' ] ) \n def chat ( ) : \n feishu = FeiShuChannel ( ) \n logger . info ( \"<STR_LIT>\" . format ( str ( request . data ) ) ) \n obj = json . loads ( request . data ) \n if not obj : \n return { '<STR_LIT>' : <NUM_LIT> } \n headers = obj . get ( \"<STR_LIT>\" ) \n if not headers : \n return { '<STR_LIT>' : <NUM_LIT> } \n t = obj . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n if \"<STR_LIT>\" == t : \n return feishu . handle_request_url_verify ( obj ) \n elif headers . get ( \"<STR_LIT>\" , None ) == \"<STR_LIT>\" : \n return feishu . handle ( obj ) \n return { '<STR_LIT>' : <NUM_LIT> }"}, {"input": "from curl_cffi import requests , Curl , CurlOpt \n from io import BytesIO \n import json \n import re \n def send_message ( ) : \n url = \"<STR_LIT>\" \n attachments = [ ] \n prompt = \"<STR_LIT>\" \n organization_id = \"<STR_LIT>\" \n conversation_id = \"<STR_LIT>\" \n cookie = \"<STR_LIT>\" \n proxies = \"<STR_LIT>\" \n payload = json . dumps ( { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" ,", "output": "\"<STR_LIT>\" : \"<STR_LIT>\" \n } , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : attachments \n } ) \n headers = [ b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' % cookie . encode ( '<STR_LIT>' ) , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' , \n b'<STR_LIT>' ] \n buffer = BytesIO ( ) \n c = Curl ( ) \n def stream_callback ( data ) : \n json_str = data . decode ( '<STR_LIT>' ) \n decoded_data = re . sub ( '<STR_LIT>' , '<STR_LIT>' , json_str ) . strip ( ) \n data_strings = decoded_data . split ( '<STR_LIT>' ) \n for data_string in data_strings : \n json_str = data_string [ <NUM_LIT> : ] . strip ( ) \n _data = json . loads ( json_str ) \n if '<STR_LIT>' in _data : \n buffer . write ( str ( _data [ '<STR_LIT>' ] ) . encode ( '<STR_LIT>' ) ) \n print ( _data [ '<STR_LIT>' ] , end = \"<STR_LIT>\" ) \n c . setopt ( CurlOpt . URL , b'<STR_LIT>' ) \n c . setopt ( CurlOpt . WRITEFUNCTION , stream_callback ) \n c . setopt ( CurlOpt . HTTPHEADER , headers ) \n c . setopt ( CurlOpt . POSTFIELDS , payload ) \n c . setopt ( CurlOpt . PROXY , proxies . encode ( ) ) \n c . impersonate ( \"<STR_LIT>\" ) \n c . perform ( ) \n c . close ( ) \n body = buffer . getvalue ( ) \n print ( body . decode ( ) ) \n send_message ( )"}, {"input": "TRANSLATE = '<STR_LIT>' \n class ReturnValue ( dict ) : \n def __init__ ( self , returnValueDict = { } , rawResponse = None ) : \n if rawResponse : \n try : \n returnValueDict = rawResponse . json ( ) \n except ValueError : \n returnValueDict = { \n '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' , } , \n '<STR_LIT>' : rawResponse . content , } \n for k , v in returnValueDict . items ( ) : \n self [ k ] = v \n if not '<STR_LIT>' in self : \n self [ '<STR_LIT>' ] = { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , }", "output": "if TRANSLATE : \n self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) \n self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = TRANSLATION [ TRANSLATE ] . get ( \n self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , '<STR_LIT>' ) ) or self [ '<STR_LIT>' ] . get ( '<STR_LIT>' , u'<STR_LIT>' ) \n self [ '<STR_LIT>' ] [ '<STR_LIT>' ] = self [ '<STR_LIT>' ] [ '<STR_LIT>' ] or self [ '<STR_LIT>' ] [ '<STR_LIT>' ] \n def __nonzero__ ( self ) : \n return self [ '<STR_LIT>' ] . get ( '<STR_LIT>' ) == <NUM_LIT> \n def __bool__ ( self ) : \n return self . __nonzero__ ( ) \n def __str__ ( self ) : \n return '<STR_LIT>' % '<STR_LIT>' . join ( \n [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) \n def __repr__ ( self ) : \n return '<STR_LIT>' % self . __str__ ( ) \n TRANSLATION = { \n '<STR_LIT>' : { \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n - <NUM_LIT> : u'<STR_LIT>' , \n <NUM_LIT> : u'<STR_LIT>' , \n } , \n }"}, {"input": "import json \n import os \n from common . log import logger \n config = { } \n def load_config ( ) : \n global config \n config_path = \"<STR_LIT>\" \n if not os . path . exists ( config_path ) : \n raise Exception ( '<STR_LIT>' ) \n config_str = read_file ( config_path ) \n config = json . loads ( config_str ) \n logger . info ( \"<STR_LIT>\" . format ( config ) ) \n def get_root ( ) :", "output": "return os . path . dirname ( os . path . abspath ( __file__ ) ) \n def read_file ( path ) : \n with open ( path , mode = '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : \n return f . read ( ) \n def conf ( ) : \n return config"}, {"input": "from aiocqhttp import CQHttp , Event , MessageSegment \n from channel . channel import Channel \n from common . log import logger \n from config import conf \n from bridge . bridge import Bridge \n from concurrent . futures import ThreadPoolExecutor \n bot = CQHttp ( ) \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n @ bot . on_message ( '<STR_LIT>' ) \n async def _ ( event : Event ) : \n logger . info ( \"<STR_LIT>\" , event ) \n QqchaChannel ( ) . handle ( event )", "output": "@ bot . on_startup \n async def startup ( ) : \n logger . info ( \"<STR_LIT>\" ) \n class QqchaChannel ( Channel ) : \n def __init__ ( self ) : \n self . host = conf ( ) . get ( '<STR_LIT>' ) \n self . port = conf ( ) . get ( '<STR_LIT>' ) \n logger . info ( \"<STR_LIT>\" . format ( \n self . host , self . port ) ) \n def startup ( self ) : \n bot . run ( host = self . host , port = self . port ) \n def handle ( self , msg ) : \n thread_pool . submit ( self . _do_handle , msg ) \n def _do_handle ( self , msg ) : \n context = dict ( ) \n reply_text = self . build_reply_content ( msg . message , context ) \n bot . sync . send_private_msg ( user_id = msg . user_id , message = reply_text ) \n def send ( self , msg , receiver ) : \n logger . info ( '<STR_LIT>' . format ( msg , receiver ) ) \n bot . send ( receiver , msg ) \n def build_reply_content ( self , query , context = None ) : \n return Bridge ( ) . fetch_reply_content ( query , context )"}, {"input": "import pickle \n class idStore ( ) : \n def __init__ ( self ) : \n self . id = None \n def get_id ( self ) :", "output": "if self . id is None : \n try : \n with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : \n self . id = pickle . load ( f ) \n except FileNotFoundError : \n print ( \"<STR_LIT>\" ) \n return self . id \n def set_id ( self , id ) : \n self . id = id \n with open ( '<STR_LIT>' , '<STR_LIT>' ) as f : \n pickle . dump ( self . id , f )"}, {"input": "from curl_cffi import Curl , CurlOpt \n from io import BytesIO \n buffer = BytesIO ( ) \n c = Curl ( ) \n c . setopt ( CurlOpt . URL , b'<STR_LIT>' )", "output": "c . setopt ( CurlOpt . WRITEDATA , buffer ) \n c . impersonate ( \"<STR_LIT>\" ) \n c . perform ( ) \n c . close ( ) \n body = buffer . getvalue ( ) \n print ( body . decode ( ) )"}, {"input": "from channel . wechat . wechat_channel import WechatChannel \n from channel . wechatcom . wechatenterprise_channel import WechatEnterpriseChannel \n from channel . qqchat . qqchat_channel import QqchaChannel \n from channel . dingtalk . dingtalk_channel import DingTalkChannel \n from channel . feishu . feishu_channel import FeiShuChannel \n from channel . webchatmp . wechat_mp_channel import WechatSubsribeAccount \n def create_channel ( channel_type ) : \n if channel_type == '<STR_LIT>' : \n return WechatChannel ( )", "output": "if channel_type == '<STR_LIT>' : \n return WechatEnterpriseChannel ( ) \n if channel_type == '<STR_LIT>' : \n return QqchaChannel ( ) \n if channel_type == '<STR_LIT>' : \n return DingTalkChannel ( ) \n if channel_type == '<STR_LIT>' : \n return FeiShuChannel ( ) \n if channel_type == '<STR_LIT>' : \n return WechatSubsribeAccount ( ) \n raise RuntimeError"}, {"input": "from io import BytesIO \n from curl_cffi import Curl , CurlInfo , CurlOpt , requests \n def main_curl ( ) : \n buffer = BytesIO ( ) \n c = Curl ( ) \n c . setopt ( CurlOpt . CUSTOMREQUEST , b\"<STR_LIT>\" ) \n c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) \n c . setopt ( CurlOpt . WRITEDATA , buffer ) \n c . perform ( ) \n body = buffer . getvalue ( ) \n print ( \"<STR_LIT>\" )", "output": "print ( body . decode ( ) ) \n print ( \"<STR_LIT>\" ) \n buffer = BytesIO ( ) \n c . setopt ( CurlOpt . WRITEDATA , buffer ) \n c . setopt ( CurlOpt . URL , b\"<STR_LIT>\" ) \n c . impersonate ( \"<STR_LIT>\" ) \n c . setopt ( CurlOpt . HTTPHEADER , [ b\"<STR_LIT>\" ] ) \n c . perform ( ) \n body = buffer . getvalue ( ) \n print ( \"<STR_LIT>\" ) \n print ( body . decode ( ) ) \n c . close ( ) \n def main_requests ( ) : \n r = requests . get ( \"<STR_LIT>\" ) \n print ( r . json ( ) ) \n r = requests . get ( \"<STR_LIT>\" , impersonate = \"<STR_LIT>\" ) \n print ( r . json ( ) ) \n async def async_main ( ) : \n async with requests . AsyncSession ( ) as s : \n r = await s . get ( \"<STR_LIT>\" ) \n print ( r . text ) \n r = await s . get ( \"<STR_LIT>\" , stream = True ) \n async for content in r . iter_content ( ) : \n print ( content ) \n if __name__ == \"<STR_LIT>\" : \n async_main ( )"}, {"input": "TEXT = '<STR_LIT>' \n MAP = '<STR_LIT>'", "output": "CARD = '<STR_LIT>' \n NOTE = '<STR_LIT>' \n SHARING = '<STR_LIT>' \n PICTURE = '<STR_LIT>' \n RECORDING = VOICE = '<STR_LIT>' \n ATTACHMENT = '<STR_LIT>' \n VIDEO = '<STR_LIT>' \n FRIENDS = '<STR_LIT>' \n SYSTEM = '<STR_LIT>' \n INCOME_MSG = [ TEXT , MAP , CARD , NOTE , SHARING , PICTURE , \n RECORDING , VOICE , ATTACHMENT , VIDEO , FRIENDS , SYSTEM ]"}, {"input": "from channel . channel import Channel \n from concurrent . futures import ThreadPoolExecutor \n from common . log import logger \n from config import conf \n import json \n import requests \n import io \n from wechatpy . enterprise . crypto import WeChatCrypto \n from wechatpy . enterprise import WeChatClient \n from wechatpy . exceptions import InvalidSignatureException \n from wechatpy . enterprise . exceptions import InvalidCorpIdException \n from wechatpy . enterprise import parse_message \n from flask import Flask , request , abort \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n app = Flask ( __name__ ) \n @ app . route ( '<STR_LIT>' , methods = [ '<STR_LIT>' , '<STR_LIT>' ] ) \n def handler_msg ( ) : \n return WechatEnterpriseChannel ( ) . handle ( ) \n class WechatEnterpriseChannel ( Channel ) : \n def __init__ ( self ) : \n self . CorpId = conf ( ) . get ( '<STR_LIT>' ) \n self . Secret = conf ( ) . get ( '<STR_LIT>' ) \n self . AppId = conf ( ) . get ( '<STR_LIT>' ) \n self . TOKEN = conf ( ) . get ( '<STR_LIT>' ) \n self . EncodingAESKey = conf ( ) . get ( '<STR_LIT>' ) \n self . crypto = WeChatCrypto ( self . TOKEN , self . EncodingAESKey , self . CorpId ) \n self . client = WeChatClient ( self . CorpId , self . Secret , self . AppId ) \n logger . info ( \"<STR_LIT>\" . format ( \n self . CorpId , self . Secret , self . AppId , self . TOKEN , self . EncodingAESKey ) ) \n def startup ( self ) : \n app . run ( host = '<STR_LIT>' , port = <NUM_LIT> ) \n def send ( self , msg , receiver ) : \n logger . info ( '<STR_LIT>' . format ( msg , receiver ) )", "output": "self . client . message . send_text ( self . AppId , receiver , msg ) \n def _do_send ( self , query , reply_user_id ) : \n try : \n if not query : \n return \n context = dict ( ) \n context [ '<STR_LIT>' ] = reply_user_id \n reply_text = super ( ) . build_reply_content ( query , context ) \n if reply_text : \n self . send ( reply_text , reply_user_id ) \n except Exception as e : \n logger . exception ( e ) \n def handle ( self ) : \n query_params = request . args \n signature = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) \n timestamp = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) \n nonce = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) \n if request . method == '<STR_LIT>' : \n echostr = query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) \n try : \n echostr = self . crypto . check_signature ( signature , timestamp , nonce , echostr ) \n except InvalidSignatureException : \n abort ( <NUM_LIT> ) \n print ( echostr ) \n return echostr \n elif request . method == '<STR_LIT>' : \n try : \n message = self . crypto . decrypt_message ( \n request . data , \n signature , \n timestamp , \n nonce \n ) \n except ( InvalidSignatureException , InvalidCorpIdException ) : \n abort ( <NUM_LIT> ) \n msg = parse_message ( message ) \n if msg . type == '<STR_LIT>' : \n reply = '<STR_LIT>' \n thread_pool . submit ( self . _do_send , msg . content , msg . source ) \n else : \n reply = '<STR_LIT>' \n self . client . message . send_text ( self . AppId , msg . source , reply ) \n return '<STR_LIT>'"}, {"input": "import pickle , os \n import logging \n import requests \n from . . config import VERSION \n from . . returnvalues import ReturnValue \n from . . storage import templates \n from . contact import update_local_chatrooms , update_local_friends \n from . messages import produce_msg \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_hotreload ( core ) : \n core . dump_login_status = dump_login_status \n core . load_login_status = load_login_status \n def dump_login_status ( self , fileDir = None ) : \n fileDir = fileDir or self . hotReloadDir \n try :", "output": "with open ( fileDir , '<STR_LIT>' ) as f : \n f . write ( '<STR_LIT>' ) \n os . remove ( fileDir ) \n except : \n raise Exception ( '<STR_LIT>' ) \n status = { \n '<STR_LIT>' : VERSION , \n '<STR_LIT>' : self . loginInfo , \n '<STR_LIT>' : self . s . cookies . get_dict ( ) , \n '<STR_LIT>' : self . storageClass . dumps ( ) } \n with open ( fileDir , '<STR_LIT>' ) as f : \n pickle . dump ( status , f ) \n logger . debug ( '<STR_LIT>' ) \n def load_login_status ( self , fileDir , \n loginCallback = None , exitCallback = None ) : \n try : \n with open ( fileDir , '<STR_LIT>' ) as f : \n j = pickle . load ( f ) \n except Exception as e : \n logger . debug ( '<STR_LIT>' ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : \n logger . debug ( ( '<STR_LIT>' + \n '<STR_LIT>' ) % ( \n j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n self . loginInfo = j [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] . core = self \n self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) \n self . storageClass . loads ( j [ '<STR_LIT>' ] ) \n try : \n msgList , contactList = self . get_msg ( ) \n except : \n msgList = contactList = None \n if ( msgList or contactList ) is None : \n self . logout ( ) \n load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) \n logger . debug ( '<STR_LIT>' ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n else : \n if contactList : \n for contact in contactList : \n if '<STR_LIT>' in contact [ '<STR_LIT>' ] : \n update_local_chatrooms ( self , [ contact ] ) \n else : \n update_local_friends ( self , [ contact ] ) \n if msgList : \n msgList = produce_msg ( self , msgList ) \n for msg in msgList : self . msgList . put ( msg ) \n self . start_receiving ( exitCallback ) \n logger . debug ( '<STR_LIT>' ) \n if hasattr ( loginCallback , '<STR_LIT>' ) : \n loginCallback ( ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , } } ) \n def load_last_login_status ( session , cookiesDict ) : \n try : \n session . cookies = requests . utils . cookiejar_from_dict ( { \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , } ) \n except : \n logger . info ( '<STR_LIT>' ) \n logger . info ( '<STR_LIT>' )"}, {"input": "import logging , traceback , sys , threading \n try : \n import Queue \n except ImportError : \n import queue as Queue \n from . . log import set_logging \n from . . utils import test_connect \n from . . storage import templates \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_register ( core ) : \n core . auto_login = auto_login \n core . configured_reply = configured_reply \n core . msg_register = msg_register \n core . run = run \n def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , \n enableCmdQR = False , picDir = None , qrCallback = None , \n loginCallback = None , exitCallback = None ) : \n if not test_connect ( ) : \n logger . info ( \"<STR_LIT>\" ) \n sys . exit ( ) \n self . useHotReload = hotReload \n self . hotReloadDir = statusStorageDir \n if hotReload : \n rval = self . load_login_status ( statusStorageDir , \n loginCallback = loginCallback , exitCallback = exitCallback ) \n if rval : \n return \n logger . error ( '<STR_LIT>' . format ( rval ) ) \n self . logout ( ) \n self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , \n loginCallback = loginCallback , exitCallback = exitCallback ) \n self . dump_login_status ( statusStorageDir ) \n else : \n self . login ( enableCmdQR = enableCmdQR , picDir = picDir , qrCallback = qrCallback , \n loginCallback = loginCallback , exitCallback = exitCallback ) \n def configured_reply ( self ) : \n try : \n msg = self . msgList . get ( timeout = <NUM_LIT> ) \n except Queue . Empty : \n pass \n else : \n if isinstance ( msg [ '<STR_LIT>' ] , templates . User ) :", "output": "replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n elif isinstance ( msg [ '<STR_LIT>' ] , templates . MassivePlatform ) : \n replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n elif isinstance ( msg [ '<STR_LIT>' ] , templates . Chatroom ) : \n replyFn = self . functionDict [ '<STR_LIT>' ] . get ( msg [ '<STR_LIT>' ] ) \n if replyFn is None : \n r = None \n else : \n try : \n r = replyFn ( msg ) \n if r is not None : \n self . send ( r , msg . get ( '<STR_LIT>' ) ) \n except : \n logger . warning ( traceback . format_exc ( ) ) \n def msg_register ( self , msgType , isFriendChat = False , isGroupChat = False , isMpChat = False ) : \n if not ( isinstance ( msgType , list ) or isinstance ( msgType , tuple ) ) : \n msgType = [ msgType ] \n def _msg_register ( fn ) : \n for _msgType in msgType : \n if isFriendChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if isGroupChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if isMpChat : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n if not any ( ( isFriendChat , isGroupChat , isMpChat ) ) : \n self . functionDict [ '<STR_LIT>' ] [ _msgType ] = fn \n return fn \n return _msg_register \n def run ( self , debug = False , blockThread = True ) : \n logger . info ( '<STR_LIT>' ) \n if debug : \n set_logging ( loggingLevel = logging . DEBUG ) \n def reply_fn ( ) : \n try : \n while self . alive : \n self . configured_reply ( ) \n except KeyboardInterrupt : \n if self . useHotReload : \n self . dump_login_status ( ) \n self . alive = False \n logger . debug ( '<STR_LIT>' ) \n logger . info ( '<STR_LIT>' ) \n if blockThread : \n reply_fn ( ) \n else : \n replyThread = threading . Thread ( target = reply_fn ) \n replyThread . setDaemon ( True ) \n replyThread . start ( )"}, {"input": "from fastapi import FastAPI , BackgroundTasks , File , UploadFile \n from claude_api import Client \n import os \n app = FastAPI ( ) \n def get_cookie ( ) : \n cookie = os . getenv ( '<STR_LIT>' ) \n if not cookie : \n raise ValueError ( \"<STR_LIT>\" ) \n return cookie \n @ app . post ( \"<STR_LIT>\" ) \n async def create_chat ( prompt : str , background_tasks : BackgroundTasks ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n conversation = client . create_new_chat ( ) \n conversation_id = conversation [ '<STR_LIT>' ] \n background_tasks . add_task ( client . send_message , prompt , conversation_id ) \n return { \"<STR_LIT>\" : conversation_id } \n @ app . get ( \"<STR_LIT>\" ) \n async def get_chat_history ( conversation_id ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n history = client . chat_conversation_history ( conversation_id ) \n return history \n @ app . post ( \"<STR_LIT>\" ) \n async def send_message ( conversation_id : str , prompt : str ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n response = client . send_message ( prompt , conversation_id )", "output": "return { \"<STR_LIT>\" : response } \n @ app . post ( \"<STR_LIT>\" ) \n async def reset_conversations ( ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n result = client . reset_all ( ) \n return { \"<STR_LIT>\" : result } \n @ app . post ( \"<STR_LIT>\" ) \n async def rename_conversation ( conversation_id : str , title : str ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n result = client . rename_chat ( title , conversation_id ) \n return { \"<STR_LIT>\" : result } \n @ app . post ( \"<STR_LIT>\" ) \n async def upload_attachment ( file : UploadFile ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n file_path = save_upload_file ( file ) \n response = client . upload_attachment ( file_path ) \n return { \"<STR_LIT>\" : response } \n def save_upload_file ( uploaded_file ) : \n file_path = f\"<STR_LIT>\" \n with open ( file_path , \"<STR_LIT>\" ) as buffer : \n buffer . write ( uploaded_file . file . read ( ) ) \n return file_path \n @ app . get ( \"<STR_LIT>\" ) \n async def list_all_conversations ( ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n conversations = client . list_all_conversations ( ) \n return { \"<STR_LIT>\" : conversations } \n @ app . get ( \"<STR_LIT>\" ) \n async def chat_conversation_history ( conversation_id ) : \n cookie = get_cookie ( ) \n client = Client ( cookie ) \n history = client . chat_conversation_history ( conversation_id ) \n return { \"<STR_LIT>\" : history }"}, {"input": "import os , platform \n VERSION = '<STR_LIT>' \n ASYNC_COMPONENTS = os . environ . get ( '<STR_LIT>' , False ) \n BASE_URL = '<STR_LIT>' \n OS = platform . system ( ) \n DIR = os . getcwd ( ) \n DEFAULT_QR = '<STR_LIT>' \n TIMEOUT = ( <NUM_LIT> , <NUM_LIT> )", "output": "USER_AGENT = '<STR_LIT>' \n UOS_PATCH_CLIENT_VERSION = '<STR_LIT>' \n UOS_PATCH_EXTSPAM = '<STR_LIT>'"}, {"input": "import config \n from common . log import logger \n from channel import channel_factory \n def run ( ) : \n try : \n config . load_config ( )", "output": "channel = channel_factory . create_channel ( \"<STR_LIT>\" ) \n channel . startup ( ) \n except Exception as e : \n logger . error ( \"<STR_LIT>\" ) \n logger . exception ( e ) \n if __name__ == \"<STR_LIT>\" : \n run ( )"}, {"input": "import pickle , os \n import logging \n import requests \n from . . config import VERSION \n from . . returnvalues import ReturnValue \n from . . storage import templates \n from . contact import update_local_chatrooms , update_local_friends \n from . messages import produce_msg \n logger = logging . getLogger ( '<STR_LIT>' ) \n def load_hotreload ( core ) : \n core . dump_login_status = dump_login_status \n core . load_login_status = load_login_status \n async def dump_login_status ( self , fileDir = None ) : \n fileDir = fileDir or self . hotReloadDir \n try : \n with open ( fileDir , '<STR_LIT>' ) as f : \n f . write ( '<STR_LIT>' ) \n os . remove ( fileDir ) \n except : \n raise Exception ( '<STR_LIT>' ) \n status = { \n '<STR_LIT>' : VERSION , \n '<STR_LIT>' : self . loginInfo , \n '<STR_LIT>' : self . s . cookies . get_dict ( ) , \n '<STR_LIT>' : self . storageClass . dumps ( ) } \n with open ( fileDir , '<STR_LIT>' ) as f : \n pickle . dump ( status , f ) \n logger . debug ( '<STR_LIT>' ) \n async def load_login_status ( self , fileDir , \n loginCallback = None , exitCallback = None ) : \n try : \n with open ( fileDir , '<STR_LIT>' ) as f : \n j = pickle . load ( f ) \n except Exception as e : \n logger . debug ( '<STR_LIT>' ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n if j . get ( '<STR_LIT>' , '<STR_LIT>' ) != VERSION : \n logger . debug ( ( '<STR_LIT>' + \n '<STR_LIT>' ) % ( \n j . get ( '<STR_LIT>' , '<STR_LIT>' ) , VERSION ) )", "output": "return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n self . loginInfo = j [ '<STR_LIT>' ] \n self . loginInfo [ '<STR_LIT>' ] = templates . User ( self . loginInfo [ '<STR_LIT>' ] ) \n self . loginInfo [ '<STR_LIT>' ] . core = self \n self . s . cookies = requests . utils . cookiejar_from_dict ( j [ '<STR_LIT>' ] ) \n self . storageClass . loads ( j [ '<STR_LIT>' ] ) \n try : \n msgList , contactList = self . get_msg ( ) \n except : \n msgList = contactList = None \n if ( msgList or contactList ) is None : \n self . logout ( ) \n await load_last_login_status ( self . s , j [ '<STR_LIT>' ] ) \n logger . debug ( '<STR_LIT>' ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : - <NUM_LIT> , } } ) \n else : \n if contactList : \n for contact in contactList : \n if '<STR_LIT>' in contact [ '<STR_LIT>' ] : \n update_local_chatrooms ( self , [ contact ] ) \n else : \n update_local_friends ( self , [ contact ] ) \n if msgList : \n msgList = produce_msg ( self , msgList ) \n for msg in msgList : self . msgList . put ( msg ) \n await self . start_receiving ( exitCallback ) \n logger . debug ( '<STR_LIT>' ) \n if hasattr ( loginCallback , '<STR_LIT>' ) : \n await loginCallback ( self . storageClass . userName ) \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : <NUM_LIT> , } } ) \n async def load_last_login_status ( session , cookiesDict ) : \n try : \n session . cookies = requests . utils . cookiejar_from_dict ( { \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] + '<STR_LIT>' , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : cookiesDict [ '<STR_LIT>' ] , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , \n '<STR_LIT>' : '<STR_LIT>' , } ) \n except : \n logger . info ( '<STR_LIT>' ) \n logger . info ( '<STR_LIT>' )"}, {"input": "import werobot \n import time \n from config import conf \n from common . log import logger \n from channel . channel import Channel \n from bridge . bridge import Bridge \n from concurrent . futures import ThreadPoolExecutor \n import config \n import os \n config . load_config ( ) \n robot = werobot . WeRoBot ( token = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) ) \n thread_pool = ThreadPoolExecutor ( max_workers = <NUM_LIT> ) \n cache = { } \n @ robot . text \n def hello_world ( msg ) : \n with open ( '<STR_LIT>' , '<STR_LIT>' , encoding = '<STR_LIT>' ) as f : \n sensitive_words = [ line . strip ( ) for line in f . readlines ( ) ] \n found = False \n for word in sensitive_words : \n if word != '<STR_LIT>' and word in msg . content : \n found = True \n break \n if found : \n return \"<STR_LIT>\" \n else : \n logger . info ( '<STR_LIT>' . format ( msg . content , msg . source ) ) \n key = msg . content + '<STR_LIT>' + msg . source \n if cache . get ( key ) : \n cache . get ( key ) [ '<STR_LIT>' ] += <NUM_LIT> \n return WechatSubsribeAccount ( ) . handle ( msg ) \n class WechatSubsribeAccount ( Channel ) : \n def __init__ ( self ) : \n self . host = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) \n self . port = conf ( ) . get ( '<STR_LIT>' ) . get ( '<STR_LIT>' ) \n logger . info ( \"<STR_LIT>\" . format ( \n self . host , self . port ) )", "output": "def startup ( self ) : \n logger . info ( '<STR_LIT>' ) \n robot . config [ '<STR_LIT>' ] = self . host \n robot . config [ '<STR_LIT>' ] = self . port \n robot . run ( ) \n def handle ( self , msg , count = <NUM_LIT> ) : \n if msg . content == \"<STR_LIT>\" : \n return self . get_un_send_content ( msg . source ) \n context = dict ( ) \n context [ '<STR_LIT>' ] = msg . source \n key = msg . content + '<STR_LIT>' + msg . source \n res = cache . get ( key ) \n if not res : \n cache [ key ] = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : <NUM_LIT> } \n thread_pool . submit ( self . _do_send , msg . content , context ) \n res = cache . get ( key ) \n logger . info ( \"<STR_LIT>\" . format ( count , res ) ) \n if res . get ( '<STR_LIT>' ) == '<STR_LIT>' : \n res [ '<STR_LIT>' ] = \"<STR_LIT>\" \n cache . pop ( key ) \n return res . get ( \"<STR_LIT>\" ) \n if cache . get ( key ) [ '<STR_LIT>' ] == <NUM_LIT> and count >= <NUM_LIT> : \n logger . info ( \"<STR_LIT>\" ) \n return \"<STR_LIT>\" \n if count <= <NUM_LIT> : \n time . sleep ( <NUM_LIT> ) \n if count == <NUM_LIT> : \n return None \n return self . handle ( msg , count + <NUM_LIT> ) \n def _do_send ( self , query , context ) : \n key = query + '<STR_LIT>' + context [ '<STR_LIT>' ] \n reply_text = self . build_reply_content ( query , context ) \n logger . info ( '<STR_LIT>' . format ( reply_text ) ) \n cache [ key ] [ '<STR_LIT>' ] = \"<STR_LIT>\" \n cache [ key ] [ '<STR_LIT>' ] = reply_text \n def get_un_send_content ( self , from_user_id ) : \n for key in cache : \n if from_user_id in key : \n value = cache [ key ] \n if value . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : \n cache . pop ( key ) \n return value . get ( \"<STR_LIT>\" ) \n return \"<STR_LIT>\" \n return \"<STR_LIT>\" \n def build_reply_content ( self , query , context = None ) : \n return Bridge ( ) . fetch_reply_content ( query , context )"}, {"input": "import requests \n from . import storage \n class Core ( object ) : \n def __init__ ( self ) : \n self . alive , self . isLogging = False , False \n self . storageClass = storage . Storage ( self ) \n self . memberList = self . storageClass . memberList \n self . mpList = self . storageClass . mpList \n self . chatroomList = self . storageClass . chatroomList \n self . msgList = self . storageClass . msgList \n self . loginInfo = { } \n self . s = requests . Session ( ) \n self . uuid = None \n self . functionDict = { '<STR_LIT>' : { } , '<STR_LIT>' : { } , '<STR_LIT>' : { } } \n self . useHotReload , self . hotReloadDir = False , '<STR_LIT>' \n self . receivingRetryCount = <NUM_LIT> \n def login ( self , enableCmdQR = False , picDir = None , qrCallback = None , \n loginCallback = None , exitCallback = None ) : \n raise NotImplementedError ( ) \n def get_QRuuid ( self ) : \n raise NotImplementedError ( ) \n def get_QR ( self , uuid = None , enableCmdQR = False , picDir = None , qrCallback = None ) : \n raise NotImplementedError ( ) \n def check_login ( self , uuid = None ) : \n raise NotImplementedError ( ) \n def web_init ( self ) : \n raise NotImplementedError ( ) \n def show_mobile_login ( self ) : \n raise NotImplementedError ( ) \n def start_receiving ( self , exitCallback = None , getReceivingFnOnly = False ) : \n raise NotImplementedError ( ) \n def get_msg ( self ) : \n raise NotImplementedError ( ) \n def logout ( self ) : \n raise NotImplementedError ( ) \n def update_chatroom ( self , userName , detailedMember = False ) : \n raise NotImplementedError ( ) \n def update_friend ( self , userName ) : \n raise NotImplementedError ( ) \n def get_contact ( self , update = False ) : \n raise NotImplementedError ( ) \n def get_friends ( self , update = False ) : \n raise NotImplementedError ( ) \n def get_chatrooms ( self , update = False , contactOnly = False ) : \n raise NotImplementedError ( ) \n def get_mps ( self , update = False ) : \n raise NotImplementedError ( ) \n def set_alias ( self , userName , alias ) : \n raise NotImplementedError ( ) \n def set_pinned ( self , userName , isPinned = True ) : \n raise NotImplementedError ( ) \n def accept_friend ( self , userName , v4 , autoUpdate = True ) : \n raise NotImplementedError ( ) \n def get_head_img ( self , userName = None , chatroomUserName = None , picDir = None ) : \n raise NotImplementedError ( ) \n def create_chatroom ( self , memberList , topic = '<STR_LIT>' ) : \n raise NotImplementedError ( ) \n def set_chatroom_name ( self , chatroomUserName , name ) : \n raise NotImplementedError ( ) \n def delete_member_from_chatroom ( self , chatroomUserName , memberList ) : \n raise NotImplementedError ( ) \n def add_member_into_chatroom ( self , chatroomUserName , memberList , \n useInvitation = False ) : \n raise NotImplementedError ( ) \n def send_raw_msg ( self , msgType , content , toUserName ) : \n raise NotImplementedError ( ) \n def send_msg ( self , msg = '<STR_LIT>' , toUserName = None ) : \n raise NotImplementedError ( ) \n def upload_file ( self , fileDir , isPicture = False , isVideo = False , \n toUserName = '<STR_LIT>' , file_ = None , preparedFile = None ) : \n raise NotImplementedError ( ) \n def send_file ( self , fileDir , toUserName = None , mediaId = None , file_ = None ) : \n raise NotImplementedError ( ) \n def send_image ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : \n raise NotImplementedError ( ) \n def send_video ( self , fileDir = None , toUserName = None , mediaId = None , file_ = None ) : \n raise NotImplementedError ( ) \n def send ( self , msg , toUserName = None , mediaId = None ) : \n raise NotImplementedError ( ) \n def revoke ( self , msgId , toUserName , localId = None ) : \n raise NotImplementedError ( ) \n def dump_login_status ( self , fileDir = None ) : \n raise NotImplementedError ( ) \n def load_login_status ( self , fileDir , \n loginCallback = None , exitCallback = None ) : \n raise NotImplementedError ( ) \n def auto_login ( self , hotReload = False , statusStorageDir = '<STR_LIT>' , \n enableCmdQR = False , picDir = None , qrCallback = None , \n loginCallback = None , exitCallback = None ) : \n raise NotImplementedError ( ) \n def configured_reply ( self ) : \n raise NotImplementedError ( )", "output": "def msg_register ( self , msgType , \n isFriendChat = False , isGroupChat = False , isMpChat = False ) : \n raise NotImplementedError ( ) \n def run ( self , debug = True , blockThread = True ) : \n raise NotImplementedError ( ) \n def search_friends ( self , name = None , userName = None , remarkName = None , nickName = None , \n wechatAccount = None ) : \n return self . storageClass . search_friends ( name , userName , remarkName , \n nickName , wechatAccount ) \n def search_chatrooms ( self , name = None , userName = None ) : \n return self . storageClass . search_chatrooms ( name , userName ) \n def search_mps ( self , name = None , userName = None ) : \n return self . storageClass . search_mps ( name , userName )"}, {"input": "import logging , copy , pickle \n from weakref import ref \n from . . returnvalues import ReturnValue \n from . . utils import update_info_dict \n logger = logging . getLogger ( '<STR_LIT>' ) \n class AttributeDict ( dict ) : \n def __getattr__ ( self , value ) : \n keyName = value [ <NUM_LIT> ] . upper ( ) + value [ <NUM_LIT> : ] \n try : \n return self [ keyName ] \n except KeyError : \n raise AttributeError ( \"<STR_LIT>\" % ( \n self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , keyName ) ) \n def get ( self , v , d = None ) : \n try : \n return self [ v ] \n except KeyError : \n return d \n class UnInitializedItchat ( object ) : \n def _raise_error ( self , * args , ** kwargs ) : \n logger . warning ( '<STR_LIT>' ) \n def __getattr__ ( self , value ) : \n return self . _raise_error \n class ContactList ( list ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( ContactList , self ) . __init__ ( * args , ** kwargs ) \n self . __setstate__ ( None ) \n @ property \n def core ( self ) : \n return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat \n @ core . setter \n def core ( self , value ) : \n self . _core = ref ( value ) \n def set_default_value ( self , initFunction = None , contactClass = None ) : \n if hasattr ( initFunction , '<STR_LIT>' ) : \n self . contactInitFn = initFunction \n if hasattr ( contactClass , '<STR_LIT>' ) : \n self . contactClass = contactClass \n def append ( self , value ) : \n contact = self . contactClass ( value ) \n contact . core = self . core \n if self . contactInitFn is not None : \n contact = self . contactInitFn ( self , contact ) or contact \n super ( ContactList , self ) . append ( contact ) \n def __deepcopy__ ( self , memo ) : \n r = self . __class__ ( [ copy . deepcopy ( v ) for v in self ] ) \n r . contactInitFn = self . contactInitFn \n r . contactClass = self . contactClass \n r . core = self . core \n return r \n def __getstate__ ( self ) : \n return <NUM_LIT> \n def __setstate__ ( self , state ) : \n self . contactInitFn = None \n self . contactClass = User \n def __str__ ( self ) :", "output": "return '<STR_LIT>' % '<STR_LIT>' . join ( [ repr ( v ) for v in self ] ) \n def __repr__ ( self ) : \n return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , \n self . __str__ ( ) ) \n class AbstractUserDict ( AttributeDict ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) \n @ property \n def core ( self ) : \n return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat \n @ core . setter \n def core ( self , value ) : \n self . _core = ref ( value ) \n def update ( self ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def set_alias ( self , alias ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def set_pinned ( self , isPinned = True ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def verify ( self ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def get_head_image ( self , imageDir = None ) : \n return self . core . get_head_img ( self . userName , picDir = imageDir ) \n def delete_member ( self , userName ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def add_member ( self , userName ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send_raw_msg ( self , msgType , content ) : \n return self . core . send_raw_msg ( msgType , content , self . userName ) \n def send_msg ( self , msg = '<STR_LIT>' ) : \n return self . core . send_msg ( msg , self . userName ) \n def send_file ( self , fileDir , mediaId = None ) : \n return self . core . send_file ( fileDir , self . userName , mediaId ) \n def send_image ( self , fileDir , mediaId = None ) : \n return self . core . send_image ( fileDir , self . userName , mediaId ) \n def send_video ( self , fileDir = None , mediaId = None ) : \n return self . core . send_video ( fileDir , self . userName , mediaId ) \n def send ( self , msg , mediaId = None ) : \n return self . core . send ( msg , self . userName , mediaId ) \n def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , \n wechatAccount = None ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def __deepcopy__ ( self , memo ) : \n r = self . __class__ ( ) \n for k , v in self . items ( ) : \n r [ copy . deepcopy ( k ) ] = copy . deepcopy ( v ) \n r . core = self . core \n return r \n def __str__ ( self ) : \n return '<STR_LIT>' % '<STR_LIT>' . join ( \n [ '<STR_LIT>' % ( repr ( k ) , repr ( v ) ) for k , v in self . items ( ) ] ) \n def __repr__ ( self ) : \n return '<STR_LIT>' % ( self . __class__ . __name__ . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] , \n self . __str__ ( ) ) \n def __getstate__ ( self ) : \n return <NUM_LIT> \n def __setstate__ ( self , state ) : \n pass \n class User ( AbstractUserDict ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( User , self ) . __init__ ( * args , ** kwargs ) \n self . __setstate__ ( None ) \n def update ( self ) : \n r = self . core . update_friend ( self . userName ) \n if r : \n update_info_dict ( self , r ) \n return r \n def set_alias ( self , alias ) : \n return self . core . set_alias ( self . userName , alias ) \n def set_pinned ( self , isPinned = True ) : \n return self . core . set_pinned ( self . userName , isPinned ) \n def verify ( self ) : \n return self . core . add_friend ( ** self . verifyDict ) \n def __deepcopy__ ( self , memo ) : \n r = super ( User , self ) . __deepcopy__ ( memo ) \n r . verifyDict = copy . deepcopy ( self . verifyDict ) \n return r \n def __setstate__ ( self , state ) : \n super ( User , self ) . __setstate__ ( state ) \n self . verifyDict = { } \n self [ '<STR_LIT>' ] = fakeContactList \n class MassivePlatform ( AbstractUserDict ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( MassivePlatform , self ) . __init__ ( * args , ** kwargs ) \n self . __setstate__ ( None ) \n def __setstate__ ( self , state ) : \n super ( MassivePlatform , self ) . __setstate__ ( state ) \n self [ '<STR_LIT>' ] = fakeContactList \n class Chatroom ( AbstractUserDict ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( Chatroom , self ) . __init__ ( * args , ** kwargs ) \n memberList = ContactList ( ) \n userName = self . get ( '<STR_LIT>' , '<STR_LIT>' ) \n refSelf = ref ( self ) \n def init_fn ( parentList , d ) : \n d . chatroom = refSelf ( ) or parentList . core . search_chatrooms ( userName = userName ) \n memberList . set_default_value ( init_fn , ChatroomMember ) \n if '<STR_LIT>' in self : \n for member in self . memberList : \n memberList . append ( member ) \n self [ '<STR_LIT>' ] = memberList \n @ property \n def core ( self ) : \n return getattr ( self , '<STR_LIT>' , lambda : fakeItchat ) ( ) or fakeItchat \n @ core . setter \n def core ( self , value ) : \n self . _core = ref ( value ) \n self . memberList . core = value \n for member in self . memberList : \n member . core = value \n def update ( self , detailedMember = False ) : \n r = self . core . update_chatroom ( self . userName , detailedMember ) \n if r : \n update_info_dict ( self , r ) \n self [ '<STR_LIT>' ] = r [ '<STR_LIT>' ] \n return r \n def set_alias ( self , alias ) : \n return self . core . set_chatroom_name ( self . userName , alias ) \n def set_pinned ( self , isPinned = True ) : \n return self . core . set_pinned ( self . userName , isPinned ) \n def delete_member ( self , userName ) : \n return self . core . delete_member_from_chatroom ( self . userName , userName ) \n def add_member ( self , userName ) : \n return self . core . add_member_into_chatroom ( self . userName , userName ) \n def search_member ( self , name = None , userName = None , remarkName = None , nickName = None , \n wechatAccount = None ) : \n with self . core . storageClass . updateLock : \n if ( name or userName or remarkName or nickName or wechatAccount ) is None : \n return None \n elif userName : \n for m in self . memberList : \n if m . userName == userName : \n return copy . deepcopy ( m ) \n else : \n matchDict = { \n '<STR_LIT>' : remarkName , \n '<STR_LIT>' : nickName , \n '<STR_LIT>' : wechatAccount , } \n for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) : \n if matchDict [ k ] is None : \n del matchDict [ k ] \n if name : \n contact = [ ] \n for m in self . memberList : \n if any ( [ m . get ( k ) == name for k in ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ] ) : \n contact . append ( m ) \n else : \n contact = self . memberList [ : ] \n if matchDict : \n friendList = [ ] \n for m in contact : \n if all ( [ m . get ( k ) == v for k , v in matchDict . items ( ) ] ) : \n friendList . append ( m ) \n return copy . deepcopy ( friendList ) \n else : \n return copy . deepcopy ( contact ) \n def __setstate__ ( self , state ) : \n super ( Chatroom , self ) . __setstate__ ( state ) \n if not '<STR_LIT>' in self : \n self [ '<STR_LIT>' ] = fakeContactList \n class ChatroomMember ( AbstractUserDict ) : \n def __init__ ( self , * args , ** kwargs ) : \n super ( AbstractUserDict , self ) . __init__ ( * args , ** kwargs ) \n self . __setstate__ ( None ) \n @ property \n def chatroom ( self ) : \n r = getattr ( self , '<STR_LIT>' , lambda : fakeChatroom ) ( ) \n if r is None : \n userName = getattr ( self , '<STR_LIT>' , '<STR_LIT>' ) \n r = self . core . search_chatrooms ( userName = userName ) \n if isinstance ( r , dict ) : \n self . chatroom = r \n return r or fakeChatroom \n @ chatroom . setter \n def chatroom ( self , value ) : \n if isinstance ( value , dict ) and '<STR_LIT>' in value : \n self . _chatroom = ref ( value ) \n self . _chatroomUserName = value [ '<STR_LIT>' ] \n def get_head_image ( self , imageDir = None ) : \n return self . core . get_head_img ( self . userName , self . chatroom . userName , picDir = imageDir ) \n def delete_member ( self , userName ) : \n return self . core . delete_member_from_chatroom ( self . chatroom . userName , self . userName ) \n def send_raw_msg ( self , msgType , content ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send_msg ( self , msg = '<STR_LIT>' ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send_file ( self , fileDir , mediaId = None ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send_image ( self , fileDir , mediaId = None ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send_video ( self , fileDir = None , mediaId = None ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def send ( self , msg , mediaId = None ) : \n return ReturnValue ( { '<STR_LIT>' : { \n '<STR_LIT>' : - <NUM_LIT> , \n '<STR_LIT>' : '<STR_LIT>' % self . __class__ . __name__ , } , } ) \n def __setstate__ ( self , state ) : \n super ( ChatroomMember , self ) . __setstate__ ( state ) \n self [ '<STR_LIT>' ] = fakeContactList \n def wrap_user_dict ( d ) : \n userName = d . get ( '<STR_LIT>' ) \n if '<STR_LIT>' in userName : \n r = Chatroom ( d ) \n elif d . get ( '<STR_LIT>' , <NUM_LIT> ) & <NUM_LIT> == <NUM_LIT> : \n r = User ( d ) \n else : \n r = MassivePlatform ( d ) \n return r \n fakeItchat = UnInitializedItchat ( ) \n fakeContactList = ContactList ( ) \n fakeChatroom = Chatroom ( )"}]