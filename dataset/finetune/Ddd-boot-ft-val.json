[{"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySources ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . annotation . AnnotatedBeanDefinition ; import org . springframework . core . type . AnnotationMetadata ; import java . util . * ; public class AnnotationNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < AnnotatedBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( AnnotatedBeanDefinition beanDefinition , Properties globalNacosProperties ) { AnnotationMetadata metadata = beanDefinition . getMetadata ( ) ; Set < String > annotationTypes = metadata . getAnnotationTypes ( ) ; List < Map < String , Object > > annotationAttributesList = new LinkedList < Map < String , Object > > ( ) ; for ( String annotationType : annotationTypes ) { annotationAttributesList . addAll ( getAnnotationAttributesList ( metadata , annotationType ) ) ; } return annotationAttributesList . toArray ( new Map [ <NUM_LIT> ] ) ; } private List < Map < String , Object > > getAnnotationAttributesList ( AnnotationMetadata metadata , String annotationType ) { List < Map < String , Object > > annotationAttributesList = new LinkedList < Map < String , Object > > ( ) ; if ( NacosPropertySources . class . getName ( ) . equals ( annotationType ) ) { Map < String , Object > annotationAttributes = metadata . getAnnotationAttributes ( annotationType ) ; if ( annotationAttributes != null ) { annotationAttributesList . addAll ( Arrays . asList ( ( Map < String , Object > [ ] ) annotationAttributes . get ( \"<STR_LIT>\" ) ) ) ; } } else if ( NacosPropertySource . class . getName ( ) . equals ( annotationType ) ) {", "output": "annotationAttributesList . add ( metadata . getAnnotationAttributes ( annotationType ) ) ; } return annotationAttributesList ; } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , AnnotatedBeanDefinition beanDefinition , Map < String , Object > annotationAttributes ) { initAttributesMetadata ( nacosPropertySource , annotationAttributes ) ; initAutoRefreshed ( nacosPropertySource , annotationAttributes ) ; initOrigin ( nacosPropertySource , beanDefinition ) ; initOrder ( nacosPropertySource , annotationAttributes ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Map < String , Object > annotationAttributes ) { nacosPropertySource . setAttributesMetadata ( annotationAttributes ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Map < String , Object > annotationAttributes ) { boolean autoRefreshed = Boolean . TRUE . equals ( annotationAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME ) ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , AnnotatedBeanDefinition beanDefinition ) { AnnotationMetadata metadata = beanDefinition . getMetadata ( ) ; nacosPropertySource . setOrigin ( metadata . getClassName ( ) ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Map < String , Object > annotationAttributes ) { boolean first = Boolean . TRUE . equals ( annotationAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME ) ) ; String before = ( String ) annotationAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME ) ; String after = ( String ) annotationAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME ) ; nacosPropertySource . setFirst ( first ) ; nacosPropertySource . setBefore ( before ) ; nacosPropertySource . setAfter ( after ) ; } @ Override protected NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , AnnotatedBeanDefinition beanDefinition ) { return new NacosConfigMetadataEvent ( beanDefinition . getMetadata ( ) ) ; } @ Override protected void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , AnnotatedBeanDefinition beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setAnnotatedElement ( metadataEvent . getAnnotatedElement ( ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . ConfigurableEnvironment ; public class NacosConfigPropertiesUtils { private static final Logger logger = LoggerFactory . getLogger ( NacosConfigPropertiesUtils . class ) ; public static NacosConfigProperties buildNacosConfigProperties ( ConfigurableEnvironment environment ) { NacosConfigProperties nacosConfigProperties = new NacosConfigProperties ( ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = ResolvableType . forClass ( NacosConfigProperties . class ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( nacosConfigProperties ) ; binder . bind ( NacosConfigConstants . PREFIX , target ) ; logger . info ( \"<STR_LIT>\" , nacosConfigProperties ) ; return nacosConfigProperties ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . Comparator ; public class MoreLists { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T extends Comparable > SortedArrayList < T > createSortedArrayList ( ) {", "output": "return new SortedArrayList < T > ( ) ; } public static < T > SortedArrayList < T > createSortedArrayList ( Comparator < ? super T > c ) { return new SortedArrayList < T > ( c ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Sets ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . type . ConcurrentHashSet ; import java . util . * ; public class SetUtil { public static < T > HashSet < T > newHashSet ( ) { return new HashSet < T > ( ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > HashSet < T > newHashSet ( T ... elements ) { return Sets . newHashSet ( elements ) ; } public static < T > HashSet < T > newHashSet ( Iterable < ? extends T > elements ) { return Sets . newHashSet ( elements ) ; } public static < T > HashSet < T > newHashSetWithCapacity ( int expectedSize ) { return Sets . newHashSetWithExpectedSize ( expectedSize ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T extends Comparable > TreeSet < T > newSortedSet ( ) { return new TreeSet < T > ( ) ; } public static < T > TreeSet < T > newSortedSet ( @ Nullable Comparator < ? super T > comparator ) { return Sets . newTreeSet ( comparator ) ; } public static < T > ConcurrentHashSet < T > newConcurrentHashSet ( ) { return new ConcurrentHashSet < T > ( ) ; } public static final < T > Set < T > emptySet ( ) { return Collections . emptySet ( ) ; } public static < T > Set < T > emptySetIfNull ( final Set < T > set ) { return set == null ? ( Set < T > ) Collections . EMPTY_SET : set ; } public static final < T > Set < T > singletonSet ( T o ) { return Collections . singleton ( o ) ;", "output": "} public static < T > Set < T > unmodifiableSet ( Set < ? extends T > s ) { return Collections . unmodifiableSet ( s ) ; } public static < T > Set < T > newSetFromMap ( Map < T , Boolean > map ) { return Collections . newSetFromMap ( map ) ; } public static < E > Set < E > unionView ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { return Sets . union ( set1 , set2 ) ; } public static < E > Set < E > intersectionView ( final Set < E > set1 , final Set < ? > set2 ) { return Sets . intersection ( set1 , set2 ) ; } public static < E > Set < E > differenceView ( final Set < E > set1 , final Set < ? > set2 ) { return Sets . difference ( set1 , set2 ) ; } public static < E > Set < E > disjointView ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { return Sets . symmetricDifference ( set1 , set2 ) ; } }"}, {"input": "package org . example . application . example . dto . result ; import lombok . Data ; @ Data public class ExampleResult { private Long id ; private String username ;", "output": "}"}, {"input": "package org . example . ddduser ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) { SpringApplication app = new SpringApplication ( Application . class ) ;", "output": "app . run ( args ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import org . apache . poi . ss . usermodel . * ; import java . util . Objects ; public class CellStyleConfig { public static final CellStyleConfig EMPTY_STYLE = new CellStyleConfig ( ) ; public static final CellStyleConfig DEFAULT_HEADER_CELL_STYLE ; static { DEFAULT_HEADER_CELL_STYLE = createDefaultStyle ( ) ; } private static CellStyleConfig createDefaultStyle ( ) { CellStyleConfig cellStyleConfig = new CellStyleConfig ( ) ; FontConfig headerCellFont = new FontConfig ( ) ; headerCellFont . setFontName ( \"<STR_LIT>\" ) ; headerCellFont . setFontHeightInPoints ( ( short ) <NUM_LIT> ) ; headerCellFont . setBold ( true ) ; cellStyleConfig . setFont ( headerCellFont ) ; cellStyleConfig . setWrapText ( true ) ; cellStyleConfig . setVerticalAlignment ( VerticalAlignment . CENTER ) ; cellStyleConfig . setAlignment ( HorizontalAlignment . CENTER ) ; cellStyleConfig . setLocked ( true ) ; cellStyleConfig . setFillPattern ( FillPatternType . SOLID_FOREGROUND ) ; cellStyleConfig . setFillForegroundColor ( IndexedColors . GREY_25_PERCENT . getIndex ( ) ) ; cellStyleConfig . setBorderBottom ( BorderStyle . THIN ) ; cellStyleConfig . setBorderLeft ( BorderStyle . THIN ) ; return cellStyleConfig ; } private FontConfig font ; private Boolean wrapText ; private VerticalAlignment verticalAlignment ; private HorizontalAlignment alignment ; private Boolean locked ; private FillPatternType fillPattern ; private Short fillForegroundColor ; private BorderStyle borderBottom ; private BorderStyle borderLeft ; public FontConfig getFont ( ) { return font ; } public void setFont ( FontConfig font ) {", "output": "this . font = font ; } public Boolean getWrapText ( ) { return wrapText ; } public void setWrapText ( Boolean wrapText ) { this . wrapText = wrapText ; } public VerticalAlignment getVerticalAlignment ( ) { return verticalAlignment ; } public void setVerticalAlignment ( VerticalAlignment verticalAlignment ) { this . verticalAlignment = verticalAlignment ; } public HorizontalAlignment getAlignment ( ) { return alignment ; } public void setAlignment ( HorizontalAlignment alignment ) { this . alignment = alignment ; } public Boolean getLocked ( ) { return locked ; } public void setLocked ( Boolean locked ) { this . locked = locked ; } public FillPatternType getFillPattern ( ) { return fillPattern ; } public void setFillPattern ( FillPatternType fillPattern ) { this . fillPattern = fillPattern ; } public Short getFillForegroundColor ( ) { return fillForegroundColor ; } public void setFillForegroundColor ( Short fillForegroundColor ) { this . fillForegroundColor = fillForegroundColor ; } public BorderStyle getBorderBottom ( ) { return borderBottom ; } public void setBorderBottom ( BorderStyle borderBottom ) { this . borderBottom = borderBottom ; } public BorderStyle getBorderLeft ( ) { return borderLeft ; } public void setBorderLeft ( BorderStyle borderLeft ) { this . borderLeft = borderLeft ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; CellStyleConfig that = ( CellStyleConfig ) o ; return Objects . equals ( font , that . font ) && Objects . equals ( wrapText , that . wrapText ) && verticalAlignment == that . verticalAlignment && alignment == that . alignment && Objects . equals ( locked , that . locked ) && fillPattern == that . fillPattern && Objects . equals ( fillForegroundColor , that . fillForegroundColor ) && borderBottom == that . borderBottom && borderLeft == that . borderLeft ; } @ Override public int hashCode ( ) { return Objects . hash ( font , wrapText , verticalAlignment , alignment , locked , fillPattern , fillForegroundColor , borderBottom , borderLeft ) ; } public static class FontConfig { private String fontName ; private short fontHeightInPoints ; private boolean bold ; public String getFontName ( ) { return fontName ; } public void setFontName ( String fontName ) { this . fontName = fontName ; } public short getFontHeightInPoints ( ) { return fontHeightInPoints ; } public void setFontHeightInPoints ( short fontHeightInPoints ) { this . fontHeightInPoints = fontHeightInPoints ; } public boolean isBold ( ) { return bold ; } public void setBold ( boolean bold ) { this . bold = bold ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; FontConfig that = ( FontConfig ) o ; return fontHeightInPoints == that . fontHeightInPoints && bold == that . bold && Objects . equals ( fontName , that . fontName ) ; } @ Override public int hashCode ( ) { return Objects . hash ( fontName , fontHeightInPoints , bold ) ; } } }"}, {"input": "package io . github . chensheng . dddboot . web . core ; public class CommonResponse extends Response < Object > { private static final long serialVersionUID = <NUM_LIT> ; public CommonResponse ( ) { } public CommonResponse ( String code , String msg ) { super ( code , msg ) ; } public CommonResponse ( String code , String msg , Object data ) { super ( code , msg , data ) ; } public static CommonResponse bizSuccess ( Object data ) { return new CommonResponse ( ResponseType . BIZ_SUCCESS . getCode ( ) , ResponseType . BIZ_SUCCESS . getMsg ( ) , data ) ; } public static CommonResponse bizError ( String msg ) { return new CommonResponse ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; }", "output": "public static CommonResponse sysError ( String msg ) { return new CommonResponse ( ResponseType . SYS_ERROR . getCode ( ) , msg ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Triple < L , M , R > { @ Nullable private final L left ; @ Nullable private final M middle ; @ Nullable private final R right ; public Triple ( @ Nullable L left , @ Nullable M middle , @ Nullable R right ) { this . left = left ; this . middle = middle ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public M getMiddle ( ) { return middle ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; result = prime * result + ( ( middle == null ) ? <NUM_LIT> : middle . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Triple other = ( Triple ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; }", "output": "} else if ( ! left . equals ( other . left ) ) { return false ; } if ( middle == null ) { if ( other . middle != null ) { return false ; } } else if ( ! middle . equals ( other . middle ) ) { return false ; } if ( right == null ) { if ( other . right != null ) { return false ; } } else if ( ! right . equals ( other . right ) ) { return false ; } return true ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + left + \"<STR_LIT>\" + middle + \"<STR_LIT>\" + right + '<STR_LIT>' ; } public static < L , M , R > Triple < L , M , R > of ( @ Nullable L left , @ Nullable M middle , @ Nullable R right ) { return new Triple < L , M , R > ( left , middle , right ) ; } }"}, {"input": "package org . example . api . web . example ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . application . example . dto . command . ExampleCreateCommand ; import org . example . application . example . dto . command . ExampleUpdatePasswordCommand ; import org . example . application . example . dto . query . ExampleListQuery ; import org . example . application . example . dto . query . ExamplePageQuery ; import org . example . application . example . dto . result . ExampleResult ; import org . example . application . example . service . ExampleCommandService ; import org . example . application . example . service . ExampleQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class ExampleController { @ Autowired private ExampleQueryService exampleQueryService ; @ Autowired private ExampleCommandService exampleCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < ExampleResult > page ( @ Valid ExamplePageQuery query ) { return exampleQueryService . page ( query ) ; } @ GetMapping ( \"<STR_LIT>\" ) public List < ExampleResult > list ( @ Valid ExampleListQuery query ) { return exampleQueryService . list ( query ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ExampleResult detail ( @ PathVariable Long id ) { return exampleQueryService . detail ( id ) ; } @ PostMapping public void create ( @ Valid @ RequestBody ExampleCreateCommand command ) { exampleCommandService . create ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void updatePassword ( @ Valid @ RequestBody ExampleUpdatePasswordCommand command ) { exampleCommandService . update ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) { exampleCommandService . enable ( id ) ;", "output": "} @ PutMapping ( \"<STR_LIT>\" ) public void disable ( @ PathVariable Long id ) { exampleCommandService . disable ( id ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) public void delete ( @ PathVariable Long id ) { exampleCommandService . delete ( id ) ; } }"}, {"input": "package org . example . application . example . service . impl ; import org . example . application . example . dto . command . ExampleCreateCommand ; import org . example . application . example . dto . command . ExampleUpdatePasswordCommand ; import org . example . application . example . service . ExampleCommandService ; import org . example . domain . example . ExampleDomainService ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class ExampleCommandServiceImpl implements ExampleCommandService { @ Autowired private ExampleRepository exampleRepository ; @ Autowired private ExampleSecurityRepository securityRepository ; @ Autowired private ExampleDomainService exampleDomainService ; @ Override public void create ( ExampleCreateCommand command ) { exampleDomainService . validateUsername ( command . getUsername ( ) ) ; ExampleEntity entity = ExampleEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ;", "output": "exampleRepository . save ( entity ) ; } @ Override public void update ( ExampleUpdatePasswordCommand command ) { Long userId = securityRepository . getLoginUser ( ) ; ExampleEntity entity = exampleRepository . getById ( userId ) ; entity . updatePassword ( command . getOldPassword ( ) , command . getNewPassword ( ) ) ; exampleRepository . save ( entity ) ; } @ Override public void enable ( Long id ) { ExampleEntity entity = exampleRepository . getById ( id ) ; entity . enable ( ) ; exampleRepository . save ( entity ) ; } @ Override public void disable ( Long id ) { ExampleEntity entity = exampleRepository . getById ( id ) ; entity . disable ( ) ; exampleRepository . save ( entity ) ; } @ Override public void delete ( Long id ) { ExampleEntity entity = exampleRepository . getById ( id ) ; exampleRepository . remove ( entity ) ; } }"}, {"input": "package org . example . application . example . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; @ Data public class ExampleModifyPasswordCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String oldPassword ; @ NotEmpty ( message = \"<STR_LIT>\" ) private String newPassword ;", "output": "}"}, {"input": "package org . example . infrastructure . repository . example . database ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ; public interface ExampleMapper extends BaseMapper < Example > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import java . util . List ; public interface RowWritingListener { List < ? > getSheetData ( SheetConfig sheetConfig ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; public abstract class BasicFuture < T > implements Future < T > { private volatile boolean completed ; private volatile boolean cancelled ; private volatile T result ; private volatile Exception ex ; @ Override public boolean isCancelled ( ) { return this . cancelled ; } @ Override public boolean isDone ( ) { return this . completed ; } @ Override public synchronized T get ( ) throws InterruptedException , ExecutionException { while ( ! this . completed ) { wait ( ) ; } return getResult ( ) ; } @ Override public synchronized T get ( final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Validate . notNull ( unit , \"<STR_LIT>\" ) ; final long msecs = unit . toMillis ( timeout ) ; final long startTime = ( msecs <= <NUM_LIT> ) ? <NUM_LIT> : System . currentTimeMillis ( ) ; long waitTime = msecs ; if ( this . completed ) { return getResult ( ) ; } else if ( waitTime <= <NUM_LIT> ) { throw new TimeoutException ( ) ; } else { for ( ; ; ) { wait ( waitTime ) ; if ( this . completed ) { return getResult ( ) ; } else { waitTime = msecs - ( System . currentTimeMillis ( ) - startTime ) ; if ( waitTime <= <NUM_LIT> ) { throw new TimeoutException ( ) ; } } } } } private T getResult ( ) throws ExecutionException { if ( this . ex != null ) { throw new ExecutionException ( this . ex ) ; } if ( cancelled ) { throw new CancellationException ( ) ; } return this . result ; } public boolean completed ( final T result ) { synchronized ( this ) { if ( this . completed ) { return false ; } this . completed = true ; this . result = result ; notifyAll ( ) ; } onCompleted ( result ) ; return true ; } public boolean failed ( final Exception exception ) { synchronized ( this ) { if ( this . completed ) { return false ; }", "output": "this . completed = true ; this . ex = exception ; notifyAll ( ) ; } onFailed ( exception ) ; return true ; } @ Override public boolean cancel ( final boolean mayInterruptIfRunning ) { synchronized ( this ) { if ( this . completed ) { return false ; } this . completed = true ; this . cancelled = true ; notifyAll ( ) ; } onCancelled ( ) ; return true ; } protected abstract void onCompleted ( T result ) ; protected abstract void onFailed ( Exception ex ) ; protected abstract void onCancelled ( ) ; }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . util . Map ; import java . util . Properties ; public class PropertiesPlaceholderResolver { private final PropertyResolver propertyResolver ; public PropertiesPlaceholderResolver ( PropertyResolver propertyResolver ) { this . propertyResolver = propertyResolver ; } public Properties resolve ( Annotation annotation ) {", "output": "Map < String , Object > attributes = AnnotationUtils . getAnnotationAttributes ( annotation ) ; return resolve ( attributes ) ; } public Properties resolve ( Map < ? , ? > properties ) { Properties resolvedProperties = new Properties ( ) ; for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { if ( entry . getValue ( ) instanceof CharSequence ) { String key = String . valueOf ( entry . getKey ( ) ) ; String value = String . valueOf ( entry . getValue ( ) ) ; String resolvedValue = propertyResolver . resolvePlaceholders ( value ) ; if ( StringUtils . hasText ( resolvedValue ) ) { resolvedProperties . setProperty ( key , resolvedValue ) ; } } } return resolvedProperties ; } }"}, {"input": "package org . example . ddduser . application . service ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; public interface UserCommandService {", "output": "void register ( UserRegisterCommand command ) ; void modifyProfile ( ModifyProfileCommand command ) ; void modifyPassword ( ModifyPasswordCommand command ) ; void modifyAddress ( ModifyAddressCommand command ) ; }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import com . google . common . util . concurrent . RateLimiter ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; public class RateLimiterUtil { public static RateLimiter create ( double permitsPerSecond , double maxBurstSeconds ) throws ReflectiveOperationException { return create ( permitsPerSecond , maxBurstSeconds , true ) ;", "output": "} public static RateLimiter create ( double permitsPerSecond , double maxBurstSeconds , boolean filledWithToken ) throws ReflectiveOperationException { Class < ? > sleepingStopwatchClass = Class . forName ( \"<STR_LIT>\" ) ; Method createStopwatchMethod = sleepingStopwatchClass . getDeclaredMethod ( \"<STR_LIT>\" ) ; createStopwatchMethod . setAccessible ( true ) ; Object stopwatch = createStopwatchMethod . invoke ( null ) ; Class < ? > burstyRateLimiterClass = Class . forName ( \"<STR_LIT>\" ) ; Constructor < ? > burstyRateLimiterConstructor = burstyRateLimiterClass . getDeclaredConstructors ( ) [ <NUM_LIT> ] ; burstyRateLimiterConstructor . setAccessible ( true ) ; RateLimiter rateLimiter = ( RateLimiter ) burstyRateLimiterConstructor . newInstance ( stopwatch , maxBurstSeconds ) ; rateLimiter . setRate ( permitsPerSecond ) ; if ( filledWithToken ) { setField ( rateLimiter , \"<STR_LIT>\" , permitsPerSecond * maxBurstSeconds ) ; } return rateLimiter ; } private static boolean setField ( Object targetObject , String fieldName , Object fieldValue ) { Field field ; try { field = targetObject . getClass ( ) . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException e ) { field = null ; } Class superClass = targetObject . getClass ( ) . getSuperclass ( ) ; while ( field == null && superClass != null ) { try { field = superClass . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException e ) { superClass = superClass . getSuperclass ( ) ; } } if ( field == null ) { return false ; } field . setAccessible ( true ) ; try { field . set ( targetObject , fieldValue ) ; return true ; } catch ( IllegalAccessException e ) { return false ; } } }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import java . io . UnsupportedEncodingException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; public class MD5Util { public static String md5With16 ( String input ) { return code ( input , <NUM_LIT> ) ; } public static String md5With32 ( String input ) { return code ( input , <NUM_LIT> ) ; } public static String md5With16 ( byte [ ] input ) { return code ( input , <NUM_LIT> ) ; }", "output": "public static String md5With32 ( byte [ ] input ) { return code ( input , <NUM_LIT> ) ; } public static String md3 ( String b ) { try { MessageDigest md = MessageDigest . getInstance ( System . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; byte [ ] a = md . digest ( b . getBytes ( ) ) ; a = md . digest ( a ) ; a = md . digest ( a ) ; return bytesToHex ( a ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return null ; } private static String code ( byte [ ] input , int bit ) { if ( input == null ) { return null ; } try { MessageDigest md = MessageDigest . getInstance ( System . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( bit == <NUM_LIT> ) { return bytesToHex ( md . digest ( input ) ) . substring ( <NUM_LIT> , <NUM_LIT> ) ; } return bytesToHex ( md . digest ( input ) ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return null ; } private static String code ( String input , int bit ) { if ( input == null ) { return null ; } try { MessageDigest md = MessageDigest . getInstance ( System . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; if ( bit == <NUM_LIT> ) { return bytesToHex ( md . digest ( input . getBytes ( \"<STR_LIT>\" ) ) ) . substring ( <NUM_LIT> , <NUM_LIT> ) ; } return bytesToHex ( md . digest ( input . getBytes ( \"<STR_LIT>\" ) ) ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return null ; } private static String bytesToHex ( byte [ ] bytes ) { StringBuffer md5str = new StringBuffer ( ) ; int digital ; for ( int i = <NUM_LIT> ; i < bytes . length ; i ++ ) { digital = bytes [ i ] ; if ( digital < <NUM_LIT> ) { digital += <NUM_LIT> ; } if ( digital < <NUM_LIT> ) { md5str . append ( \"<STR_LIT>\" ) ; } md5str . append ( Integer . toHexString ( digital ) ) ; } return md5str . toString ( ) . toUpperCase ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; public class StringBuilderHolder { private static ThreadLocal < StringBuilder > globalStringBuilder = new ThreadLocal < StringBuilder > ( ) { @ Override protected StringBuilder initialValue ( ) {", "output": "return new StringBuilder ( <NUM_LIT> ) ; } } ; private ThreadLocal < StringBuilder > stringBuilder = new ThreadLocal < StringBuilder > ( ) { @ Override protected StringBuilder initialValue ( ) { return new StringBuilder ( initSize ) ; } } ; private int initSize ; public StringBuilderHolder ( int initSize ) { this . initSize = initSize ; } public static StringBuilder getGlobal ( ) { StringBuilder sb = globalStringBuilder . get ( ) ; sb . setLength ( <NUM_LIT> ) ; return sb ; } public StringBuilder get ( ) { StringBuilder sb = stringBuilder . get ( ) ; sb . setLength ( <NUM_LIT> ) ; return sb ; } }"}, {"input": "package org . example . ddduser . application . dto . command ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import javax . validation . constraints . NotEmpty ; @ Data public class ModifyProfileCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String nickName ; private String avatar ; private Gender gender ; private Integer age ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigReceivedEvent extends NacosConfigEvent { private final String content ; private final String type ; public NacosConfigReceivedEvent ( ConfigService configService , String dataId , String groupId , String content , String type ) { super ( configService , dataId , groupId ) ; this . content = content ; this . type = type ; }", "output": "public String getContent ( ) { return content ; } public String getType ( ) { return type ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository . microservice . response ; import lombok . Data ; @ Data public class Workspace { private String name ; private Long owner ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . binder . NacosBootConfigurationPropertiesBinder ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . support . DefaultListableBeanFactory ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . type . AnnotationMetadata ; @ Configuration public class NacosConfigBootBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , BeanFactoryAware { @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { DefaultListableBeanFactory defaultListableBeanFactory = ( DefaultListableBeanFactory ) beanFactory ; BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( NacosBootConfigurationPropertiesBinder . class ) ; defaultListableBeanFactory . registerBeanDefinition ( NacosBootConfigurationPropertiesBinder . BEAN_NAME , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) {", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Lists ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ListUtil { public static boolean isEmpty ( List < ? > list ) { return ( list == null ) || list . isEmpty ( ) ; } public static boolean isNotEmpty ( List < ? > list ) { return ( list != null ) && ! ( list . isEmpty ( ) ) ; } public static < T > T getFirst ( List < T > list ) { if ( isEmpty ( list ) ) { return null ; } return list . get ( <NUM_LIT> ) ; } public static < T > T getLast ( List < T > list ) { if ( isEmpty ( list ) ) { return null ; } return list . get ( list . size ( ) - <NUM_LIT> ) ; } @ Deprecated public static < T > ArrayList < T > newArrayList ( ) { return new ArrayList < T > ( ) ; } public static < T > ArrayList < T > newArrayList ( T ... elements ) { return Lists . newArrayList ( elements ) ; } public static < T > ArrayList < T > newArrayList ( Iterable < T > elements ) { return Lists . newArrayList ( elements ) ; } public static < T > ArrayList < T > newArrayListWithCapacity ( int initSize ) { return new ArrayList < T > ( initSize ) ; } @ Deprecated public static < T > LinkedList < T > newLinkedList ( ) { return new LinkedList < T > ( ) ; } public static < T > LinkedList < T > newLinkedList ( Iterable < ? extends T > elements ) { return Lists . newLinkedList ( elements ) ; } @ Deprecated public static < T > CopyOnWriteArrayList < T > newCopyOnWriteArrayList ( ) { return new CopyOnWriteArrayList < T > ( ) ; } public static < T > CopyOnWriteArrayList < T > newCopyOnWriteArrayList ( T ... elements ) { return new CopyOnWriteArrayList < T > ( elements ) ; } public static final < T > List < T > emptyList ( ) { return Collections . emptyList ( ) ; } public static < T > List < T > emptyListIfNull ( final List < T > list ) { return list == null ? ( List < T > ) Collections . EMPTY_LIST : list ; } public static < T > List < T > singletonList ( T o ) { return Collections . singletonList ( o ) ; } public static < T > List < T > unmodifiableList ( List < ? extends T > list ) { return Collections . unmodifiableList ( list ) ; } public static < T > List < T > synchronizedList ( List < T > list ) { return Collections . synchronizedList ( list ) ; } public static < T extends Comparable < ? super T > > void sort ( List < T > list ) { Collections . sort ( list ) ; } public static < T extends Comparable < ? super T > > void sortReverse ( List < T > list ) { Collections . sort ( list , Collections . reverseOrder ( ) ) ; } public static < T > void sort ( List < T > list , Comparator < ? super T > c ) { Collections . sort ( list , c ) ; } public static < T > void sortReverse ( List < T > list , Comparator < ? super T > c ) { Collections . sort ( list , Collections . reverseOrder ( c ) ) ; } public static < T > int binarySearch ( List < ? extends Comparable < ? super T > > sortedList , T key ) { return Collections . binarySearch ( sortedList , key ) ; } public static < T > int binarySearch ( List < ? extends T > sortedList , T key , Comparator < ? super T > c ) { return Collections . binarySearch ( sortedList , key , c ) ; } public static void shuffle ( List < ? > list ) { Collections . shuffle ( list ) ; } public static void shuffle ( List < ? > list , Random rnd ) { Collections . shuffle ( list , rnd ) ; } public static < T > List < T > reverse ( final List < T > list ) { return Lists . reverse ( list ) ; } public static < T > List < List < T > > partition ( List < T > list , int size ) { return Lists . partition ( list , size ) ; } public static < T > void notNullList ( List < T > list ) { if ( isEmpty ( list ) ) { return ; } Iterator < T > ite = list . iterator ( ) ; while ( ite . hasNext ( ) ) { T obj = ite . next ( ) ; if ( null == obj ) { ite . remove ( ) ; } } } public static < T > void uniqueNotNullList ( List < T > list ) { if ( isEmpty ( list ) ) { return ; } Iterator < T > ite = list . iterator ( ) ; Set < T > set = new HashSet < > ( ( int ) ( list . size ( ) / <NUM_LIT> + <NUM_LIT> ) ) ; while ( ite . hasNext ( ) ) { T obj = ite . next ( ) ; if ( null == obj ) { ite . remove ( ) ; continue ; } if ( set . contains ( obj ) ) { ite . remove ( ) ; continue ; } set . add ( obj ) ; } } public static < E > List < E > union ( final List < ? extends E > list1 , final List < ? extends E > list2 ) { final List < E > result = new ArrayList < E > ( list1 . size ( ) + list2 . size ( ) ) ; result . addAll ( list1 ) ; result . addAll ( list2 ) ; return result ; } public static < T > List < T > intersection ( final List < ? extends T > list1 , final List < ? extends T > list2 ) { List < ? extends T > smaller = list1 ; List < ? extends T > larger = list2 ; if ( list1 . size ( ) > list2 . size ( ) ) { smaller = list2 ; larger = list1 ; } List < T > newSmaller = new ArrayList < T > ( smaller ) ; List < T > result = new ArrayList < T > ( smaller . size ( ) ) ; for ( final T e : larger ) {", "output": "if ( newSmaller . contains ( e ) ) { result . add ( e ) ; newSmaller . remove ( e ) ; } } return result ; } public static < T > List < T > difference ( final List < ? extends T > list1 , final List < ? extends T > list2 ) { final List < T > result = new ArrayList < T > ( list1 ) ; final Iterator < ? extends T > iterator = list2 . iterator ( ) ; while ( iterator . hasNext ( ) ) { result . remove ( iterator . next ( ) ) ; } return result ; } public static < T > List < T > disjoint ( final List < ? extends T > list1 , final List < ? extends T > list2 ) { List < T > intersection = intersection ( list1 , list2 ) ; List < T > towIntersection = union ( intersection , intersection ) ; return difference ( union ( list1 , list2 ) , towIntersection ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultJsonConfigParse ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultPropertiesConfigParse ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultXmlConfigParse ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import java . util . * ; public final class ConfigParseUtils { private static final String LINK_CHAR = \"<STR_LIT>\" ; private static Map < String , ConfigParse > DEFAULT_CONFIG_PARSE_MAP = new HashMap ( <NUM_LIT> ) ; private static Map < String , Map < String , ConfigParse > > CUSTOMER_CONFIG_PARSE_MAP = new HashMap ( <NUM_LIT> ) ; static { DefaultJsonConfigParse jsonConfigParse = new DefaultJsonConfigParse ( ) ; DefaultPropertiesConfigParse propertiesConfigParse = new DefaultPropertiesConfigParse ( ) ; DefaultYamlConfigParse yamlConfigParse = new DefaultYamlConfigParse ( ) ; DefaultXmlConfigParse xmlConfigParse = new DefaultXmlConfigParse ( ) ; DEFAULT_CONFIG_PARSE_MAP . put ( jsonConfigParse . processType ( ) . toLowerCase ( ) , jsonConfigParse ) ; DEFAULT_CONFIG_PARSE_MAP . put ( propertiesConfigParse . processType ( ) . toLowerCase ( ) , propertiesConfigParse ) ; DEFAULT_CONFIG_PARSE_MAP . put ( yamlConfigParse . processType ( ) . toLowerCase ( ) , yamlConfigParse ) ; DEFAULT_CONFIG_PARSE_MAP . put ( xmlConfigParse . processType ( ) . toLowerCase ( ) , xmlConfigParse ) ; ServiceLoader < ConfigParse > configParses = ServiceLoader . load ( ConfigParse . class ) ; StringBuilder sb = new StringBuilder ( ) ; for ( ConfigParse configParse : configParses ) {", "output": "String type = configParse . processType ( ) . toLowerCase ( ) ; if ( ! CUSTOMER_CONFIG_PARSE_MAP . containsKey ( type ) ) { CUSTOMER_CONFIG_PARSE_MAP . put ( type , new HashMap < String , ConfigParse > ( <NUM_LIT> ) ) ; } sb . setLength ( <NUM_LIT> ) ; sb . append ( configParse . dataId ( ) ) . append ( LINK_CHAR ) . append ( configParse . group ( ) ) ; if ( LINK_CHAR . equals ( sb . toString ( ) ) ) { DEFAULT_CONFIG_PARSE_MAP . put ( type , configParse ) ; } else { CUSTOMER_CONFIG_PARSE_MAP . get ( type ) . put ( sb . toString ( ) , configParse ) ; } } DEFAULT_CONFIG_PARSE_MAP = Collections . unmodifiableMap ( DEFAULT_CONFIG_PARSE_MAP ) ; CUSTOMER_CONFIG_PARSE_MAP = Collections . unmodifiableMap ( CUSTOMER_CONFIG_PARSE_MAP ) ; } public static Map < String , Object > toProperties ( final String context , String type ) { if ( context == null ) { return new LinkedHashMap < String , Object > ( ) ; } type = type . toLowerCase ( ) ; if ( DEFAULT_CONFIG_PARSE_MAP . containsKey ( type ) ) { ConfigParse configParse = DEFAULT_CONFIG_PARSE_MAP . get ( type ) ; return configParse . parse ( context ) ; } else { throw new UnsupportedOperationException ( \"<STR_LIT>\" + type ) ; } } public static Map < String , Object > toProperties ( final String dataId , final String group , final String context , String type ) { if ( context == null ) { return new LinkedHashMap < String , Object > ( ) ; } type = type . toLowerCase ( ) ; String configParseKey = dataId + LINK_CHAR + group ; if ( CUSTOMER_CONFIG_PARSE_MAP . isEmpty ( ) || LINK_CHAR . equals ( configParseKey ) ) { return toProperties ( context , type ) ; } if ( CUSTOMER_CONFIG_PARSE_MAP . get ( type ) == null || CUSTOMER_CONFIG_PARSE_MAP . get ( type ) . isEmpty ( ) ) { return toProperties ( context , type ) ; } if ( CUSTOMER_CONFIG_PARSE_MAP . get ( type ) . get ( configParseKey ) == null ) { return toProperties ( context , type ) ; } else { if ( CUSTOMER_CONFIG_PARSE_MAP . containsKey ( type ) ) { ConfigParse configParse = CUSTOMER_CONFIG_PARSE_MAP . get ( type ) . get ( configParseKey ) ; if ( configParse == null ) { throw new NoSuchElementException ( \"<STR_LIT>\" ) ; } return configParse . parse ( context ) ; } else { throw new UnsupportedOperationException ( \"<STR_LIT>\" + type ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type ; import com . google . common . collect . * ; import com . google . common . util . concurrent . AtomicLongMap ; import io . github . chensheng . dddboot . tools . collection . type . primitive . IntObjectHashMap ; import io . github . chensheng . dddboot . tools . collection . type . primitive . LongObjectHashMap ; import org . apache . commons . lang3 . mutable . MutableInt ; import org . apache . commons . lang3 . mutable . MutableLong ; import java . util . Comparator ; import java . util . HashMap ; import java . util . concurrent . ConcurrentMap ; public class MoreMaps { public static < K , V > ConcurrentMap < K , V > createWeakKeyConcurrentMap ( int initialCapacity , int concurrencyLevel ) { return new MapMaker ( ) . weakKeys ( ) . initialCapacity ( initialCapacity ) . concurrencyLevel ( concurrencyLevel ) . makeMap ( ) ; } public static < K , V > ConcurrentMap < K , V > createWeakValueConcurrentMap ( int initialCapacity , int concurrencyLevel ) { return new MapMaker ( ) . weakValues ( ) . initialCapacity ( initialCapacity ) . concurrencyLevel ( concurrencyLevel ) . makeMap ( ) ; } public static < V > IntObjectHashMap < V > createPrimitiveIntKeyMap ( int initialCapacity , float loadFactor ) { return new IntObjectHashMap < V > ( initialCapacity , loadFactor ) ; } public static < V > LongObjectHashMap < V > createPrimitiveLongKeyMap ( int initialCapacity , float loadFactor ) { return new LongObjectHashMap < V > ( initialCapacity , loadFactor ) ; } public static < K > HashMap < K , MutableInt > createMutableIntValueMap ( int initialCapacity , float loadFactor ) { return new HashMap < K , MutableInt > ( initialCapacity , loadFactor ) ; } public static < K > HashMap < K , MutableLong > createMutableLongValueMap ( int initialCapacity , float loadFactor ) { return new HashMap < K , MutableLong > ( initialCapacity , loadFactor ) ; } public static < E > AtomicLongMap < E > createConcurrentCounterMap ( ) { return AtomicLongMap . create ( ) ; } public static < K , V > ArrayListMultimap < K , V > createListMultiValueMap ( int expectedKeys , int expectedValuesPerKey ) { return ArrayListMultimap . create ( expectedKeys , expectedValuesPerKey ) ; } public static < K , V extends Comparable > SortedSetMultimap < K , V > createSortedSetMultiValueMap ( ) { return MultimapBuilder . hashKeys ( ) . treeSetValues ( ) . build ( ) ; } public static < K , V > SortedSetMultimap < K , V > createSortedSetMultiValueMap ( Comparator < V > comparator ) { return ( SortedSetMultimap < K , V > ) MultimapBuilder . hashKeys ( ) . treeSetValues ( comparator ) ; }", "output": "@ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeRangeMap < K , V > createRangeMap ( ) { return TreeRangeMap . create ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . excel . reader . ExcelReaderFactory ; import io . github . chensheng . dddboot . excel . writer . ExcelWriterFactory ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; public class ExcelUtil { public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowType == null ) {", "output": "throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } return ExcelReaderFactory . read ( inputStream , rowType ) ; } public static void write ( OutputStream outputStream , List < ? > rowDataList ) { write ( outputStream , rowDataList , null ) ; } public static void write ( OutputStream outputStream , List < ? > rowDataList , InputStream templateIs ) { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( rowDataList ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } ExcelWriterFactory . write ( outputStream , templateIs , rowDataList ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . apache . commons . lang3 . Validate ; public class Sampler { private static final Double ALWAYS = Double . valueOf ( <NUM_LIT> ) ; private static final Double NEVER = Double . valueOf ( <NUM_LIT> ) ; private double threshold ; protected Sampler ( ) { } protected Sampler ( double selectPercent ) { Validate . isTrue ( ( selectPercent >= <NUM_LIT> ) && ( selectPercent <= <NUM_LIT> ) , \"<STR_LIT>\" + selectPercent ) ; this . threshold = selectPercent / <NUM_LIT> ; } public static Sampler create ( Double selectPercent ) { if ( selectPercent . equals ( ALWAYS ) ) { return new AlwaysSampler ( ) ; } else if ( selectPercent . equals ( NEVER ) ) { return new NeverSampler ( ) ; } else { return new Sampler ( selectPercent ) ; } } public boolean select ( ) { return RandomUtil . threadLocalRandom ( ) . nextDouble ( ) < threshold ; }", "output": "protected static class AlwaysSampler extends Sampler { @ Override public boolean select ( ) { return true ; } } protected static class NeverSampler extends Sampler { @ Override public boolean select ( ) { return false ; } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigTimeoutEvent extends NacosConfigEvent { private final long timeout ; private final String errorMessage ; public NacosConfigTimeoutEvent ( ConfigService configService , String dataId , String groupId , long timeout , String errorMessage ) { super ( configService , dataId , groupId ) ; this . timeout = timeout ; this . errorMessage = errorMessage ; } public long getTimeout ( ) { return timeout ; } public String getErrorMessage ( ) { return errorMessage ; }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . springframework . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import javax . xml . parsers . DocumentBuilderFactory ; import java . io . ByteArrayInputStream ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; public class DefaultXmlConfigParse extends AbstractConfigParse { private DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; @ Override public Map < String , Object > parse ( String configText ) { Map < String , Object > properties = new LinkedHashMap < String , Object > ( <NUM_LIT> ) ; try { Document document = factory . newDocumentBuilder ( ) . parse ( new ByteArrayInputStream ( configText . getBytes ( \"<STR_LIT>\" ) ) ) ; Element root = document . getDocumentElement ( ) ; Map < String , Object > map = new LinkedHashMap < String , Object > ( <NUM_LIT> ) ; recursionXmlToMap ( map , root ) ; mapToProperties ( \"<STR_LIT>\" , properties , map ) ; } catch ( Exception e ) { throw new ConfigParseException ( e ) ; } return properties ; } private void recursionXmlToMap ( Map < String , Object > outMap , Element element ) { NodeList nodeList = element . getChildNodes ( ) ; String name = element . getNodeName ( ) ; if ( nodeList . getLength ( ) == <NUM_LIT> && ! nodeList . item ( <NUM_LIT> ) . hasChildNodes ( ) ) { addData ( outMap , name , element . getTextContent ( ) ) ; } else { Map < String , Object > innerMap = new LinkedHashMap < String , Object > ( <NUM_LIT> ) ; int length = nodeList . getLength ( ) ; for ( int i = <NUM_LIT> ; i < length ; i ++ ) { Node node = nodeList . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { Element tElement = ( Element ) node ; recursionXmlToMap ( innerMap , tElement ) ; } } addData ( outMap , name , innerMap ) ; } } private void addData ( Map < String , Object > map , String key , Object data ) { if ( map . containsKey ( key ) ) { if ( map . get ( key ) instanceof List ) { ( ( List ) map . get ( key ) ) . add ( data ) ; } else { List < Object > list = new LinkedList < Object > ( ) ; list . add ( map . get ( key ) ) ; map . put ( key , list ) ; } } else { map . put ( key , data ) ; } } private void mapToProperties ( String prefixName , Map < String , Object > properties , Object data ) { if ( data instanceof List ) { List list = ( List ) data ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; i ++ ) { int lastIndex = prefixName . lastIndexOf ( '<STR_LIT>' ) ; String preName = prefixName . substring ( <NUM_LIT> , lastIndex ) ; String lastName = prefixName . substring ( lastIndex ) ; mapToProperties ( preName + \"<STR_LIT>\" + i + \"<STR_LIT>\" , properties , list . get ( i ) ) ; } } else if ( data instanceof Map ) { Map < String , Object > map = ( Map < String , Object > ) data ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { String tmpPrefix = StringUtils . isEmpty ( prefixName ) ? entry . getKey ( ) : prefixName + \"<STR_LIT>\" + entry . getKey ( ) ; mapToProperties ( tmpPrefix , properties , entry . getValue ( ) ) ; } }", "output": "else { properties . put ( prefixName , String . valueOf ( data ) ) ; } } @ Override public String processType ( ) { return ConfigType . XML . getType ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . annotation . AutowiredAnnotationBeanPostProcessor ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . InstantiationAwareBeanPostProcessorAdapter ; import org . springframework . beans . factory . support . MergedBeanDefinitionPostProcessor ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . Ordered ; import org . springframework . core . PriorityOrdered ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . util . ClassUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . beans . PropertyDescriptor ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import static io . github . chensheng . dddboot . nacos . spring . util . AnnotationUtils . getAnnotationAttributes ; import static java . util . Collections . unmodifiableMap ; import static org . springframework . aop . support . AopUtils . getTargetClass ; import static org . springframework . core . BridgeMethodResolver . findBridgedMethod ; import static org . springframework . core . BridgeMethodResolver . isVisibilityBridgeMethodPair ; import static org . springframework . core . GenericTypeResolver . resolveTypeArgument ; public abstract class AbstractAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor , PriorityOrdered , BeanFactoryAware , BeanClassLoaderAware , EnvironmentAware , DisposableBean { private final static int CACHE_SIZE = Integer . getInteger ( \"<STR_LIT>\" , <NUM_LIT> ) ; private final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < ? extends Annotation > [ ] annotationTypes ; private final ConcurrentMap < String , AnnotatedInjectionMetadata > injectionMetadataCache = new ConcurrentHashMap < String , AnnotatedInjectionMetadata > ( CACHE_SIZE ) ; private final ConcurrentMap < String , Object > injectedObjectsCache = new ConcurrentHashMap < String , Object > ( CACHE_SIZE ) ; private ConfigurableListableBeanFactory beanFactory ; private Environment environment ; private ClassLoader classLoader ; private int order = Ordered . LOWEST_PRECEDENCE - <NUM_LIT> ; private boolean classValuesAsString = true ; private boolean nestedAnnotationsAsMap = true ; private boolean ignoreDefaultValue = true ; private boolean tryMergedAnnotation = true ; public AbstractAnnotationBeanPostProcessor ( Class < ? extends Annotation > ... annotationTypes ) { Assert . notEmpty ( annotationTypes , \"<STR_LIT>\" ) ; this . annotationTypes = annotationTypes ; } private static < T > Collection < T > combine ( Collection < ? extends T > ... elements ) { List < T > allElements = new ArrayList < T > ( ) ; for ( Collection < ? extends T > e : elements ) { allElements . addAll ( e ) ; } return allElements ; } @ Deprecated public final Class < ? extends Annotation > getAnnotationType ( ) { return annotationTypes [ <NUM_LIT> ] ; } protected final Class < ? extends Annotation > [ ] getAnnotationTypes ( ) { return annotationTypes ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { Assert . isInstanceOf ( ConfigurableListableBeanFactory . class , beanFactory , \"<STR_LIT>\" ) ; this . beanFactory = ( ConfigurableListableBeanFactory ) beanFactory ; } @ Override public PropertyValues postProcessPropertyValues ( PropertyValues pvs , PropertyDescriptor [ ] pds , Object bean , String beanName ) throws BeanCreationException { InjectionMetadata metadata = findInjectionMetadata ( beanName , bean . getClass ( ) , pvs ) ; try { metadata . inject ( bean , beanName , pvs ) ; } catch ( BeanCreationException ex ) { throw ex ; } catch ( Throwable ex ) { throw new BeanCreationException ( beanName , \"<STR_LIT>\" + getAnnotationType ( ) . getSimpleName ( ) + \"<STR_LIT>\" , ex ) ; } return pvs ; } private List < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > findFieldAnnotationMetadata ( final Class < ? > beanClass ) { final List < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > elements = new LinkedList < AnnotatedFieldElement > ( ) ; ReflectionUtils . doWithFields ( beanClass , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { for ( Class < ? extends Annotation > annotationType : getAnnotationTypes ( ) ) { AnnotationAttributes attributes = doGetAnnotationAttributes ( field , annotationType ) ; if ( attributes != null ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + annotationType . getName ( ) + \"<STR_LIT>\" + field ) ; } return ; } elements . add ( new AnnotatedFieldElement ( field , attributes ) ) ; } } } } ) ; return elements ; } private List < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > findAnnotatedMethodMetadata ( final Class < ? > beanClass ) { final List < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > elements = new LinkedList < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > ( ) ; ReflectionUtils . doWithMethods ( beanClass , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { Method bridgedMethod = findBridgedMethod ( method ) ; if ( ! isVisibilityBridgeMethodPair ( method , bridgedMethod ) ) { return ; } for ( Class < ? extends Annotation > annotationType : getAnnotationTypes ( ) ) { AnnotationAttributes attributes = doGetAnnotationAttributes ( bridgedMethod , annotationType ) ; if ( attributes != null && method . equals ( ClassUtils . getMostSpecificMethod ( method , beanClass ) ) ) { if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + annotationType . getName ( ) + \"<STR_LIT>\" + method ) ; } return ; } if ( method . getParameterTypes ( ) . length == <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + annotationType . getName ( ) + \"<STR_LIT>\" + method ) ; } } PropertyDescriptor pd = BeanUtils . findPropertyForMethod ( bridgedMethod , beanClass ) ; elements . add ( new AnnotatedMethodElement ( method , pd , attributes ) ) ; } } } } ) ; return elements ; } protected AnnotationAttributes doGetAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType ) { return getAnnotationAttributes ( annotatedElement , annotationType , getEnvironment ( ) , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , tryMergedAnnotation ) ; } private AbstractAnnotationBeanPostProcessor . AnnotatedInjectionMetadata buildAnnotatedMetadata ( final Class < ? > beanClass ) { Collection < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > fieldElements = findFieldAnnotationMetadata ( beanClass ) ; Collection < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > methodElements = findAnnotatedMethodMetadata ( beanClass ) ; return new AbstractAnnotationBeanPostProcessor . AnnotatedInjectionMetadata ( beanClass , fieldElements , methodElements ) ; } private InjectionMetadata findInjectionMetadata ( String beanName , Class < ? > clazz , PropertyValues pvs ) { String cacheKey = ( StringUtils . hasLength ( beanName ) ? beanName : clazz . getName ( ) ) ; AbstractAnnotationBeanPostProcessor . AnnotatedInjectionMetadata metadata = this . injectionMetadataCache . get ( cacheKey ) ; if ( InjectionMetadata . needsRefresh ( metadata , clazz ) ) { synchronized ( this . injectionMetadataCache ) { metadata = this . injectionMetadataCache . get ( cacheKey ) ; if ( InjectionMetadata . needsRefresh ( metadata , clazz ) ) { if ( metadata != null ) { metadata . clear ( pvs ) ; } try { metadata = buildAnnotatedMetadata ( clazz ) ; this . injectionMetadataCache . put ( cacheKey , metadata ) ; } catch ( NoClassDefFoundError err ) { throw new IllegalStateException ( \"<STR_LIT>\" + clazz . getName ( ) + \"<STR_LIT>\" , err ) ; } } } } return metadata ; } @ Override public void postProcessMergedBeanDefinition ( RootBeanDefinition beanDefinition , Class < ? > beanType , String beanName ) {", "output": "if ( beanType != null ) { InjectionMetadata metadata = findInjectionMetadata ( beanName , beanType , null ) ; metadata . checkConfigMembers ( beanDefinition ) ; } } @ Override public int getOrder ( ) { return order ; } public void setOrder ( int order ) { this . order = order ; } @ Override public void destroy ( ) throws Exception { for ( Object object : injectedObjectsCache . values ( ) ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( object + \"<STR_LIT>\" ) ; } if ( object instanceof DisposableBean ) { ( ( DisposableBean ) object ) . destroy ( ) ; } } injectionMetadataCache . clear ( ) ; injectedObjectsCache . clear ( ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( getClass ( ) + \"<STR_LIT>\" ) ; } } @ Override public void setBeanClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } protected Environment getEnvironment ( ) { return environment ; } protected ClassLoader getClassLoader ( ) { return classLoader ; } protected ConfigurableListableBeanFactory getBeanFactory ( ) { return beanFactory ; } protected Collection < Object > getInjectedObjects ( ) { return this . injectedObjectsCache . values ( ) ; } protected Object getInjectedObject ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { String cacheKey = buildInjectedObjectCacheKey ( attributes , bean , beanName , injectedType , injectedElement ) ; Object injectedObject = injectedObjectsCache . get ( cacheKey ) ; if ( injectedObject == null ) { injectedObject = doGetInjectedBean ( attributes , bean , beanName , injectedType , injectedElement ) ; injectedObjectsCache . putIfAbsent ( cacheKey , injectedObject ) ; } return injectedObject ; } protected abstract Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception ; protected abstract String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) ; protected Map < InjectionMetadata . InjectedElement , Object > getInjectedFieldObjectsMap ( ) { Map < InjectionMetadata . InjectedElement , Object > injectedElementBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , Object > ( ) ; for ( AbstractAnnotationBeanPostProcessor . AnnotatedInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > fieldElements = metadata . getFieldElements ( ) ; for ( AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement fieldElement : fieldElements ) { injectedElementBeanMap . put ( fieldElement , fieldElement . bean ) ; } } return unmodifiableMap ( injectedElementBeanMap ) ; } protected Map < InjectionMetadata . InjectedElement , Object > getInjectedMethodObjectsMap ( ) { Map < InjectionMetadata . InjectedElement , Object > injectedElementBeanMap = new LinkedHashMap < InjectionMetadata . InjectedElement , Object > ( ) ; for ( AbstractAnnotationBeanPostProcessor . AnnotatedInjectionMetadata metadata : injectionMetadataCache . values ( ) ) { Collection < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > methodElements = metadata . getMethodElements ( ) ; for ( AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement methodElement : methodElements ) { injectedElementBeanMap . put ( methodElement , methodElement . object ) ; } } return unmodifiableMap ( injectedElementBeanMap ) ; } public void setClassValuesAsString ( boolean classValuesAsString ) { this . classValuesAsString = classValuesAsString ; } public void setNestedAnnotationsAsMap ( boolean nestedAnnotationsAsMap ) { this . nestedAnnotationsAsMap = nestedAnnotationsAsMap ; } public void setIgnoreDefaultValue ( boolean ignoreDefaultValue ) { this . ignoreDefaultValue = ignoreDefaultValue ; } public void setTryMergedAnnotation ( boolean tryMergedAnnotation ) { this . tryMergedAnnotation = tryMergedAnnotation ; } private class AnnotatedInjectionMetadata extends InjectionMetadata { private final Collection < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > fieldElements ; private final Collection < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > methodElements ; public AnnotatedInjectionMetadata ( Class < ? > targetClass , Collection < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > fieldElements , Collection < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > methodElements ) { super ( targetClass , combine ( fieldElements , methodElements ) ) ; this . fieldElements = fieldElements ; this . methodElements = methodElements ; } public Collection < AbstractAnnotationBeanPostProcessor . AnnotatedFieldElement > getFieldElements ( ) { return fieldElements ; } public Collection < AbstractAnnotationBeanPostProcessor . AnnotatedMethodElement > getMethodElements ( ) { return methodElements ; } } private class AnnotatedMethodElement extends InjectionMetadata . InjectedElement { private final Method method ; private final AnnotationAttributes attributes ; private volatile Object object ; protected AnnotatedMethodElement ( Method method , PropertyDescriptor pd , AnnotationAttributes attributes ) { super ( method , pd ) ; this . method = method ; this . attributes = attributes ; } @ Override protected void inject ( Object bean , String beanName , PropertyValues pvs ) throws Throwable { Class < ? > injectedType = pd . getPropertyType ( ) ; Object injectedObject = getInjectedObject ( attributes , bean , beanName , injectedType , this ) ; ReflectionUtils . makeAccessible ( method ) ; method . invoke ( bean , injectedObject ) ; } } public class AnnotatedFieldElement extends InjectionMetadata . InjectedElement { private final Field field ; private final AnnotationAttributes attributes ; private volatile Object bean ; protected AnnotatedFieldElement ( Field field , AnnotationAttributes attributes ) { super ( field , null ) ; this . field = field ; this . attributes = attributes ; } @ Override protected void inject ( Object bean , String beanName , PropertyValues pvs ) throws Throwable { Class < ? > injectedType = resolveInjectedType ( bean , field ) ; Object injectedObject = getInjectedObject ( attributes , bean , beanName , injectedType , this ) ; ReflectionUtils . makeAccessible ( field ) ; field . set ( bean , injectedObject ) ; } private Class < ? > resolveInjectedType ( Object bean , Field field ) { Type genericType = field . getGenericType ( ) ; if ( genericType instanceof Class ) { return field . getType ( ) ; } else { return resolveTypeArgument ( getTargetClass ( bean ) , field . getDeclaringClass ( ) ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class IntegerConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Integer . class == fieldType || int . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { return Integer . parseInt ( cellContent ) ; } catch ( NumberFormatException e ) { try { return ( int ) Double . parseDouble ( cellContent ) ; } catch ( Exception ex ) { return Integer . class == field . getType ( ) ? null : <NUM_LIT> ; } } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Integer value = ( Integer ) cellValue ; cell . setCellType ( CellType . NUMERIC ) ;", "output": "cell . setCellValue ( value ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . io . Resources ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassLoaderUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; public class ResourceUtil { public static URL asUrl ( String resourceName ) { return Resources . getResource ( resourceName ) ; } public static URL asUrl ( Class < ? > contextClass , String resourceName ) { return Resources . getResource ( contextClass , resourceName ) ; } public static InputStream asStream ( String resourceName ) throws IOException { return Resources . getResource ( resourceName ) . openStream ( ) ; } public static InputStream asStream ( Class < ? > contextClass , String resourceName ) throws IOException { return Resources . getResource ( contextClass , resourceName ) . openStream ( ) ; } public static String toString ( String resourceName ) throws IOException { return Resources . toString ( Resources . getResource ( resourceName ) , Charsets . UTF_8 ) ; } public static String toString ( Class < ? > contextClass , String resourceName ) throws IOException { return Resources . toString ( Resources . getResource ( contextClass , resourceName ) , Charsets . UTF_8 ) ; } public static List < String > toLines ( String resourceName ) throws IOException { return Resources . readLines ( Resources . getResource ( resourceName ) , Charsets . UTF_8 ) ; } public static List < String > toLines ( Class < ? > contextClass , String resourceName ) throws IOException { return Resources . readLines ( Resources . getResource ( contextClass , resourceName ) , Charsets . UTF_8 ) ; } public static List < URL > getResourcesQuietly ( String resourceName ) { return getResourcesQuietly ( resourceName , ClassLoaderUtil . getDefaultClassLoader ( ) ) ; } public static List < URL > getResourcesQuietly ( String resourceName , ClassLoader contextClassLoader ) { try { Enumeration < URL > urls = contextClassLoader . getResources ( resourceName ) ; List < URL > list = new ArrayList < URL > ( <NUM_LIT> ) ; while ( urls . hasMoreElements ( ) ) { list . add ( urls . nextElement ( ) ) ; } return list ; } catch ( IOException e ) { return ListUtil . emptyList ( ) ; } }", "output": "}"}]