[{"input": "from dvadmin . system . models import LoginLog \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class LoginLogSerializer ( CustomModelSerializer ) : \n class Meta : \n model = LoginLog \n fields = \"<STR_LIT>\"", "output": "read_only_fields = [ \"<STR_LIT>\" ] \n class LoginLogViewSet ( CustomModelViewSet ) : \n queryset = LoginLog . objects . all ( ) \n serializer_class = LoginLogSerializer \n extra_filter_class = [ ]"}, {"input": "import hashlib \n from django . contrib . auth . hashers import make_password , check_password \n from django_restql . fields import DynamicSerializerMethodField \n from rest_framework import serializers \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from django . db import connection \n from django . db . models import Q \n from application import dispatch \n from dvadmin . system . models import Users , Role , Dept \n from dvadmin . system . views . role import RoleSerializer \n from dvadmin . utils . json_response import ErrorResponse , DetailResponse , SuccessResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . validator import CustomUniqueValidator \n from dvadmin . utils . viewset import CustomModelViewSet \n def recursion ( instance , parent , result ) : \n new_instance = getattr ( instance , parent , None ) \n res = [ ] \n data = getattr ( instance , result , None ) \n if data : \n res . append ( data ) \n if new_instance : \n array = recursion ( new_instance , parent , result ) \n res += array \n return res \n class UserSerializer ( CustomModelSerializer ) : \n dept_name = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n role_info = DynamicSerializerMethodField ( ) \n dept_name_all = serializers . SerializerMethodField ( ) \n class Meta : \n model = Users \n read_only_fields = [ \"<STR_LIT>\" ] \n exclude = [ \"<STR_LIT>\" ] \n extra_kwargs = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n } \n def get_dept_name_all ( self , instance ) : \n dept_name_all = recursion ( instance . dept , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n dept_name_all . reverse ( ) \n return \"<STR_LIT>\" . join ( dept_name_all ) \n def get_role_info ( self , instance , parsed_query ) : \n roles = instance . role . all ( ) \n serializer = RoleSerializer ( \n roles , \n many = True , \n parsed_query = parsed_query \n ) \n return serializer . data \n class UserCreateSerializer ( CustomModelSerializer ) : \n username = serializers . CharField ( \n max_length = <NUM_LIT> , \n validators = [ \n CustomUniqueValidator ( queryset = Users . objects . all ( ) , message = \"<STR_LIT>\" ) \n ] , \n ) \n password = serializers . CharField ( \n required = False , \n ) \n def validate_password ( self , value ) : \n md5 = hashlib . md5 ( ) \n md5 . update ( value . encode ( '<STR_LIT>' ) ) \n md5_password = md5 . hexdigest ( ) \n return make_password ( md5_password ) \n def save ( self , ** kwargs ) : \n data = super ( ) . save ( ** kwargs ) \n data . dept_belong_id = data . dept_id \n data . save ( ) \n data . post . set ( self . initial_data . get ( \"<STR_LIT>\" , [ ] ) ) \n return data \n class Meta : \n model = Users \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n extra_kwargs = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n } \n class UserUpdateSerializer ( CustomModelSerializer ) : \n username = serializers . CharField ( \n max_length = <NUM_LIT> , \n validators = [ \n CustomUniqueValidator ( queryset = Users . objects . all ( ) , message = \"<STR_LIT>\" ) \n ] , \n ) \n def save ( self , ** kwargs ) : \n data = super ( ) . save ( ** kwargs ) \n data . dept_belong_id = data . dept_id \n data . save ( ) \n data . post . set ( self . initial_data . get ( \"<STR_LIT>\" , [ ] ) ) \n return data \n class Meta : \n model = Users \n read_only_fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] \n fields = \"<STR_LIT>\" \n extra_kwargs = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False , \"<STR_LIT>\" : True } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n } \n class UserInfoUpdateSerializer ( CustomModelSerializer ) : \n mobile = serializers . CharField ( \n max_length = <NUM_LIT> , \n validators = [ \n CustomUniqueValidator ( queryset = Users . objects . all ( ) , message = \"<STR_LIT>\" ) \n ] , \n allow_blank = True \n ) \n def update ( self , instance , validated_data ) : \n return super ( ) . update ( instance , validated_data ) \n class Meta : \n model = Users \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n extra_kwargs = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False , \"<STR_LIT>\" : True } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : False } , \n } \n class ExportUserProfileSerializer ( CustomModelSerializer ) : \n last_login = serializers . DateTimeField ( \n format = \"<STR_LIT>\" , required = False , read_only = True \n ) \n is_active = serializers . SerializerMethodField ( read_only = True ) \n dept_name = serializers . CharField ( source = \"<STR_LIT>\" , default = \"<STR_LIT>\" ) \n dept_owner = serializers . CharField ( source = \"<STR_LIT>\" , default = \"<STR_LIT>\" ) \n gender = serializers . CharField ( source = \"<STR_LIT>\" , read_only = True ) \n def get_is_active ( self , instance ) : \n return \"<STR_LIT>\" if instance . is_active else \"<STR_LIT>\" \n class Meta : \n model = Users \n fields = ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) \n class UserProfileImportSerializer ( CustomModelSerializer ) : \n password = serializers . CharField ( read_only = True , required = False ) \n def save ( self , ** kwargs ) : \n data = super ( ) . save ( ** kwargs ) \n password = hashlib . new ( \n \"<STR_LIT>\" , str ( self . initial_data . get ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) . encode ( encoding = \"<STR_LIT>\" ) \n ) . hexdigest ( ) \n data . set_password ( password ) \n data . save ( ) \n return data \n class Meta : \n model = Users \n exclude = ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" ,", "output": "\"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) \n class UserViewSet ( CustomModelViewSet ) : \n queryset = Users . objects . exclude ( is_superuser = <NUM_LIT> ) . all ( ) \n serializer_class = UserSerializer \n create_serializer_class = UserCreateSerializer \n update_serializer_class = UserUpdateSerializer \n filter_fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n search_fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n export_field_label = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n export_serializer_class = ExportUserProfileSerializer \n import_serializer_class = UserProfileImportSerializer \n import_field_dict = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : <NUM_LIT> } , \n } \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : True , \"<STR_LIT>\" : False } , \n } \n } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : { \"<STR_LIT>\" : Dept . objects . filter ( status = True ) , \"<STR_LIT>\" : \"<STR_LIT>\" } } , \n \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : { \"<STR_LIT>\" : Role . objects . filter ( status = True ) , \"<STR_LIT>\" : \"<STR_LIT>\" } } , \n } \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def user_info ( self , request ) : \n user = request . user \n result = { \n \"<STR_LIT>\" : user . id , \n \"<STR_LIT>\" : user . username , \n \"<STR_LIT>\" : user . name , \n \"<STR_LIT>\" : user . mobile , \n \"<STR_LIT>\" : user . user_type , \n \"<STR_LIT>\" : user . gender , \n \"<STR_LIT>\" : user . email , \n \"<STR_LIT>\" : user . avatar , \n \"<STR_LIT>\" : user . dept_id , \n \"<STR_LIT>\" : user . is_superuser , \n \"<STR_LIT>\" : user . role . values_list ( '<STR_LIT>' , flat = True ) , \n } \n if hasattr ( connection , '<STR_LIT>' ) : \n result [ '<STR_LIT>' ] = connection . tenant and connection . tenant . id \n result [ '<STR_LIT>' ] = connection . tenant and connection . tenant . name \n dept = getattr ( user , '<STR_LIT>' , None ) \n if dept : \n result [ '<STR_LIT>' ] = { \n '<STR_LIT>' : dept . id , \n '<STR_LIT>' : dept . name \n } \n else : \n result [ '<STR_LIT>' ] = { \n '<STR_LIT>' : None , \n '<STR_LIT>' : \"<STR_LIT>\" \n } \n role = getattr ( user , '<STR_LIT>' , None ) \n if role : \n result [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n return DetailResponse ( data = result , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def update_user_info ( self , request ) : \n serializer = UserInfoUpdateSerializer ( request . user , data = request . data , request = request ) \n serializer . is_valid ( raise_exception = True ) \n serializer . save ( ) \n return DetailResponse ( data = None , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def change_password ( self , request , * args , ** kwargs ) : \n data = request . data \n old_pwd = data . get ( \"<STR_LIT>\" ) \n new_pwd = data . get ( \"<STR_LIT>\" ) \n new_pwd2 = data . get ( \"<STR_LIT>\" ) \n if old_pwd is None or new_pwd is None or new_pwd2 is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n if new_pwd != new_pwd2 : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n verify_password = check_password ( old_pwd , self . request . user . password ) \n if not verify_password : \n verify_password = check_password ( hashlib . md5 ( old_pwd . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) , self . request . user . password ) \n if verify_password : \n request . user . password = make_password ( hashlib . md5 ( new_pwd . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) ) \n request . user . save ( ) \n return DetailResponse ( data = None , msg = \"<STR_LIT>\" ) \n else : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = True , permission_classes = [ IsAuthenticated ] ) \n def reset_to_default_password ( self , request , * args , ** kwargs ) : \n instance = Users . objects . filter ( id = kwargs . get ( \"<STR_LIT>\" ) ) . first ( ) \n if instance : \n instance . set_password ( dispatch . get_system_config_values ( \"<STR_LIT>\" ) ) \n instance . save ( ) \n return DetailResponse ( data = None , msg = \"<STR_LIT>\" ) \n else : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = True ) \n def reset_password ( self , request , pk ) : \n if not self . request . user . is_superuser : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n instance = Users . objects . filter ( id = pk ) . first ( ) \n data = request . data \n new_pwd = data . get ( \"<STR_LIT>\" ) \n new_pwd2 = data . get ( \"<STR_LIT>\" ) \n if instance : \n if new_pwd != new_pwd2 : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n else : \n instance . password = make_password ( new_pwd ) \n instance . save ( ) \n return DetailResponse ( data = None , msg = \"<STR_LIT>\" ) \n else : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n def list ( self , request , * args , ** kwargs ) : \n dept_id = request . query_params . get ( '<STR_LIT>' ) \n show_all = request . query_params . get ( '<STR_LIT>' ) \n if not dept_id : \n dept_id = '<STR_LIT>' \n if not show_all : \n show_all = <NUM_LIT> \n if int ( show_all ) : \n all_did = [ dept_id ] \n def inner ( did ) : \n sub = Dept . objects . filter ( parent_id = did ) \n if not sub . exists ( ) : \n return \n for i in sub : \n all_did . append ( i . pk ) \n inner ( i ) \n if dept_id != '<STR_LIT>' : \n inner ( dept_id ) \n searchs = [ \n Q ( ** { f + '<STR_LIT>' : i } ) \n for f in self . search_fields \n ] if ( i := request . query_params . get ( '<STR_LIT>' ) ) else [ ] \n q_obj = [ ] \n if searchs : \n q = searchs [ <NUM_LIT> ] \n for i in searchs [ <NUM_LIT> : ] : \n q |= i \n q_obj . append ( Q ( q ) ) \n queryset = Users . objects . filter ( * q_obj , dept_id__in = all_did ) \n else : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n else : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n page = self . paginate_queryset ( queryset ) \n if page is not None : \n serializer = self . get_serializer ( page , many = True , request = request ) \n return self . get_paginated_response ( serializer . data ) \n serializer = self . get_serializer ( queryset , many = True , request = request ) \n return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" )"}, {"input": "from collections import OrderedDict \n from django . core import paginator \n from django . core . paginator import Paginator as DjangoPaginator , InvalidPage \n from rest_framework . pagination import PageNumberPagination \n from rest_framework . response import Response \n class CustomPagination ( PageNumberPagination ) : \n page_size = <NUM_LIT> \n page_size_query_param = \"<STR_LIT>\"", "output": "max_page_size = <NUM_LIT> \n django_paginator_class = DjangoPaginator \n def paginate_queryset ( self , queryset , request , view = None ) : \n empty = True \n page_size = self . get_page_size ( request ) \n if not page_size : \n return None \n paginator = self . django_paginator_class ( queryset , page_size ) \n page_number = request . query_params . get ( self . page_query_param , <NUM_LIT> ) \n if page_number in self . last_page_strings : \n page_number = paginator . num_pages \n try : \n self . page = paginator . page ( page_number ) \n except InvalidPage as exc : \n empty = False \n if paginator . num_pages > <NUM_LIT> and self . template is not None : \n self . display_page_controls = True \n self . request = request \n if not empty : \n self . page = [ ] \n return list ( self . page ) \n def get_paginated_response ( self , data ) : \n code = <NUM_LIT> \n msg = '<STR_LIT>' \n page = int ( self . get_page_number ( self . request , paginator ) ) or <NUM_LIT> \n total = self . page . paginator . count if self . page else <NUM_LIT> \n limit = int ( self . get_page_size ( self . request ) ) or <NUM_LIT> \n is_next = self . page . has_next ( ) if self . page else False \n is_previous = self . page . has_previous ( ) if self . page else False \n if not data : \n code = <NUM_LIT> \n msg = \"<STR_LIT>\" \n data = [ ] \n return Response ( OrderedDict ( [ \n ( '<STR_LIT>' , code ) , \n ( '<STR_LIT>' , msg ) , \n ( '<STR_LIT>' , page ) , \n ( '<STR_LIT>' , limit ) , \n ( '<STR_LIT>' , total ) , \n ( '<STR_LIT>' , is_next ) , \n ( '<STR_LIT>' , is_previous ) , \n ( '<STR_LIT>' , data ) \n ] ) )"}, {"input": "from urllib . parse import quote \n from django . db import transaction \n from django . http import HttpResponse \n from openpyxl import Workbook \n from openpyxl . worksheet . datavalidation import DataValidation \n from openpyxl . utils import get_column_letter , quote_sheetname \n from openpyxl . worksheet . table import Table , TableStyleInfo \n from rest_framework . decorators import action \n from rest_framework . request import Request \n from dvadmin . utils . import_export import import_to_data \n from dvadmin . utils . json_response import DetailResponse \n from dvadmin . utils . request_util import get_verbose_name \n class ImportSerializerMixin : \n import_field_dict = { } \n import_serializer_class = None \n export_column_width = <NUM_LIT> \n def is_number ( self , num ) : \n try : \n float ( num ) \n return True \n except ValueError : \n pass \n try : \n import unicodedata \n unicodedata . numeric ( num ) \n return True \n except ( TypeError , ValueError ) : \n pass \n return False \n def get_string_len ( self , string ) : \n length = <NUM_LIT> \n if string is None : \n return length \n if self . is_number ( string ) : \n return length \n for char in string : \n length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> \n return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width \n @ action ( methods = [ '<STR_LIT>' , '<STR_LIT>' ] , detail = False ) \n @ transaction . atomic \n def import_data ( self , request : Request , * args , ** kwargs ) : \n assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ \n if request . method == \"<STR_LIT>\" : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n response = HttpResponse ( content_type = \"<STR_LIT>\" ) \n response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" \n response [ \n \"<STR_LIT>\" \n ] = f'<STR_LIT>' \n wb = Workbook ( ) \n ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) \n ws1 . sheet_state = \"<STR_LIT>\" \n ws = wb . active \n row = get_column_letter ( len ( self . import_field_dict ) + <NUM_LIT> ) \n column = <NUM_LIT> \n header_data = [ \n \"<STR_LIT>\" , \n ] \n validation_data_dict = { } \n for index , ele in enumerate ( self . import_field_dict . values ( ) ) : \n if isinstance ( ele , dict ) : \n header_data . append ( ele . get ( \"<STR_LIT>\" ) ) \n choices = ele . get ( \"<STR_LIT>\" , { } ) \n if choices . get ( \"<STR_LIT>\" ) : \n data_list = [ ] \n data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) \n validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = data_list \n elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : \n data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) \n validation_data_dict [ ele . get ( \"<STR_LIT>\" ) ] = list ( data_list ) \n else : \n continue \n column_letter = get_column_letter ( len ( validation_data_dict ) ) \n dv = DataValidation ( \n type = \"<STR_LIT>\" , \n formula1 = f\"<STR_LIT>\" , \n allow_blank = True , \n ) \n ws . add_data_validation ( dv ) \n dv . add ( f\"<STR_LIT>\" ) \n else : \n header_data . append ( ele ) \n ws1 . append ( list ( validation_data_dict . keys ( ) ) ) \n for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : \n for inx , ele in enumerate ( validation_data ) : \n ws1 [ f\"<STR_LIT>\" ] = ele \n df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] \n ws . append ( header_data ) \n for index , width in enumerate ( df_len_max ) : \n ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width \n tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) \n style = TableStyleInfo ( \n name = \"<STR_LIT>\" , \n showFirstColumn = True ,", "output": "showLastColumn = True , \n showRowStripes = True , \n showColumnStripes = True , \n ) \n tab . tableStyleInfo = style \n ws . add_table ( tab ) \n wb . save ( response ) \n return response \n else : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n m2m_fields = [ \n ele . name \n for ele in queryset . model . _meta . get_fields ( ) \n if hasattr ( ele , \"<STR_LIT>\" ) and ele . many_to_many == True \n ] \n import_field_dict = { '<STR_LIT>' : '<STR_LIT>' , ** self . import_field_dict } \n data = import_to_data ( request . data . get ( \"<STR_LIT>\" ) , import_field_dict , m2m_fields ) \n for ele in data : \n filter_dic = { '<STR_LIT>' : ele . get ( '<STR_LIT>' ) } \n instance = filter_dic and queryset . filter ( ** filter_dic ) . first ( ) \n serializer = self . import_serializer_class ( instance , data = ele , request = request ) \n serializer . is_valid ( raise_exception = True ) \n serializer . save ( ) \n return DetailResponse ( msg = f\"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False ) \n def update_template ( self , request ) : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n assert self . import_field_dict , \"<STR_LIT>\" % self . __class__ . __name__ \n assert self . import_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ \n data = self . import_serializer_class ( queryset , many = True , request = request ) . data \n response = HttpResponse ( content_type = \"<STR_LIT>\" ) \n response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" \n response [ \"<STR_LIT>\" ] = f'<STR_LIT>' \n wb = Workbook ( ) \n ws1 = wb . create_sheet ( \"<STR_LIT>\" , <NUM_LIT> ) \n ws1 . sheet_state = \"<STR_LIT>\" \n ws = wb . active \n import_field_dict = { } \n header_data = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] \n hidden_header = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] \n validation_data_dict = { } \n for index , item in enumerate ( self . import_field_dict . items ( ) ) : \n items = list ( item ) \n key = items [ <NUM_LIT> ] \n value = items [ <NUM_LIT> ] \n if isinstance ( value , dict ) : \n header_data . append ( value . get ( \"<STR_LIT>\" ) ) \n hidden_header . append ( value . get ( '<STR_LIT>' ) ) \n choices = value . get ( \"<STR_LIT>\" , { } ) \n if choices . get ( \"<STR_LIT>\" ) : \n data_list = [ ] \n data_list . extend ( choices . get ( \"<STR_LIT>\" ) . keys ( ) ) \n validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = data_list \n elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : \n data_list = choices . get ( \"<STR_LIT>\" ) . values_list ( choices . get ( \"<STR_LIT>\" ) , flat = True ) \n validation_data_dict [ value . get ( \"<STR_LIT>\" ) ] = list ( data_list ) \n else : \n continue \n column_letter = get_column_letter ( len ( validation_data_dict ) ) \n dv = DataValidation ( \n type = \"<STR_LIT>\" , \n formula1 = f\"<STR_LIT>\" , \n allow_blank = True , \n ) \n ws . add_data_validation ( dv ) \n dv . add ( f\"<STR_LIT>\" ) \n else : \n header_data . append ( value ) \n hidden_header . append ( key ) \n ws1 . append ( list ( validation_data_dict . keys ( ) ) ) \n for index , validation_data in enumerate ( validation_data_dict . values ( ) ) : \n for inx , ele in enumerate ( validation_data ) : \n ws1 [ f\"<STR_LIT>\" ] = ele \n df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] \n row = get_column_letter ( len ( hidden_header ) + <NUM_LIT> ) \n column = <NUM_LIT> \n ws . append ( header_data ) \n for index , results in enumerate ( data ) : \n results_list = [ ] \n for h_index , h_item in enumerate ( hidden_header ) : \n for key , val in results . items ( ) : \n if key == h_item : \n if val is None or val == \"<STR_LIT>\" : \n results_list . append ( \"<STR_LIT>\" ) \n elif isinstance ( val , list ) : \n results_list . append ( str ( val ) ) \n else : \n results_list . append ( val ) \n if isinstance ( val , str ) : \n result_column_width = self . get_string_len ( val ) \n if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : \n df_len_max [ h_index ] = result_column_width \n ws . append ( [ index + <NUM_LIT> , * results_list ] ) \n column += <NUM_LIT> \n for index , width in enumerate ( df_len_max ) : \n ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width \n tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) \n style = TableStyleInfo ( \n name = \"<STR_LIT>\" , \n showFirstColumn = True , \n showLastColumn = True , \n showRowStripes = True , \n showColumnStripes = True , \n ) \n tab . tableStyleInfo = style \n ws . add_table ( tab ) \n wb . save ( response ) \n return response \n class ExportSerializerMixin : \n export_field_label = [ ] \n export_serializer_class = None \n export_column_width = <NUM_LIT> \n def is_number ( self , num ) : \n try : \n float ( num ) \n return True \n except ValueError : \n pass \n try : \n import unicodedata \n unicodedata . numeric ( num ) \n return True \n except ( TypeError , ValueError ) : \n pass \n return False \n def get_string_len ( self , string ) : \n length = <NUM_LIT> \n if string is None : \n return length \n if self . is_number ( string ) : \n return length \n for char in string : \n length += <NUM_LIT> if ord ( char ) > <NUM_LIT> else <NUM_LIT> \n return round ( length , <NUM_LIT> ) if length <= self . export_column_width else self . export_column_width \n @ action ( methods = [ '<STR_LIT>' ] , detail = False ) \n def export_data ( self , request : Request , * args , ** kwargs ) : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n assert self . export_field_label , \"<STR_LIT>\" % self . __class__ . __name__ \n assert self . export_serializer_class , \"<STR_LIT>\" % self . __class__ . __name__ \n data = self . export_serializer_class ( queryset , many = True , request = request ) . data \n response = HttpResponse ( content_type = \"<STR_LIT>\" ) \n response [ \"<STR_LIT>\" ] = f\"<STR_LIT>\" \n response [ \"<STR_LIT>\" ] = f'<STR_LIT>' \n wb = Workbook ( ) \n ws = wb . active \n header_data = [ \"<STR_LIT>\" , * self . export_field_label . values ( ) ] \n hidden_header = [ \"<STR_LIT>\" , * self . export_field_label . keys ( ) ] \n df_len_max = [ self . get_string_len ( ele ) for ele in header_data ] \n row = get_column_letter ( len ( self . export_field_label ) + <NUM_LIT> ) \n column = <NUM_LIT> \n ws . append ( header_data ) \n for index , results in enumerate ( data ) : \n results_list = [ ] \n for h_index , h_item in enumerate ( hidden_header ) : \n for key , val in results . items ( ) : \n if key == h_item : \n if val is None or val == \"<STR_LIT>\" : \n results_list . append ( \"<STR_LIT>\" ) \n else : \n results_list . append ( val ) \n result_column_width = self . get_string_len ( val ) \n if h_index != <NUM_LIT> and result_column_width > df_len_max [ h_index ] : \n df_len_max [ h_index ] = result_column_width \n ws . append ( [ index + <NUM_LIT> , * results_list ] ) \n column += <NUM_LIT> \n for index , width in enumerate ( df_len_max ) : \n ws . column_dimensions [ get_column_letter ( index + <NUM_LIT> ) ] . width = width \n tab = Table ( displayName = \"<STR_LIT>\" , ref = f\"<STR_LIT>\" ) \n style = TableStyleInfo ( \n name = \"<STR_LIT>\" , \n showFirstColumn = True , \n showLastColumn = True , \n showRowStripes = True , \n showColumnStripes = True , \n ) \n tab . tableStyleInfo = style \n ws . add_table ( tab ) \n wb . save ( response ) \n return response"}]